[
    {
        "title": "Check If Word Is Valid After Substitutions",
        "question_content": "Given a string s, determine if it is valid.\nA string s is valid if, starting with an empty string t = \"\", you can transform t into s after performing the following operation any number of times:\n\n\tInsert string \"abc\" into any position in t. More formally, t becomes tleft + \"abc\" + tright, where t == tleft + tright. Note that tleft and tright may be empty.\n\nReturn true if s is a valid string, otherwise, return false.\n&nbsp;\nExample 1:\n\nInput: s = \"aabcbc\"\nOutput: true\nExplanation:\n\"\" -> \"abc\" -> \"aabcbc\"\nThus, \"aabcbc\" is valid.\nExample 2:\n\nInput: s = \"abcabcababcc\"\nOutput: true\nExplanation:\n\"\" -> \"abc\" -> \"abcabc\" -> \"abcabcabc\" -> \"abcabcababcc\"\nThus, \"abcabcababcc\" is valid.\n\nExample 3:\n\nInput: s = \"abccba\"\nOutput: false\nExplanation: It is impossible to get \"abccba\" using the operation.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 2 * 104\n\ts consists of letters 'a', 'b', and 'c'",
        "solutions": [
            {
                "id": 247626,
                "title": "java-python-c-stack-solution-o-n",
                "content": "## **Solution 1, Brute Force**\\n\\nBrute force using replace will get accepted. Though it\\'s not expected.\\n\\nTime complexity `O(N^2)`, space `O(N^2)` (depending on implementation).\\n**Python**\\n```\\n    def isValid(self, S):\\n        S2 = \"\"\\n        while S != S2:\\n            S, S2 = S.replace(\"abc\", \"\"), S\\n        return S == \"\"\\n```\\n<br>\\n\\n## **Solution 2**\\n\\nKeep a stack, whenever meet `\\'c\\'`,\\npop `a` and `b` at the end of stack.\\nOtherwise return `false`.\\n\\n**Java**\\n```\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for (char c: s.toCharArray()) {\\n            if (c == \\'c\\') {\\n                if (stack.isEmpty() || stack.pop() != \\'b\\') return false;\\n                if (stack.isEmpty() || stack.pop() != \\'a\\') return false;\\n            } else {\\n                stack.push(c);\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n```\\n\\n**C++**\\n```\\n    bool isValid(string S) {\\n        vector<char> stack;\\n        for (char c : S) {\\n            if (c == \\'c\\') {\\n                int n = stack.size();\\n                if (n < 2 || stack[n - 1] != \\'b\\' || stack[n - 2] != \\'a\\') return false;\\n                stack.pop_back(), stack.pop_back();\\n            } else {\\n                stack.push_back(c);\\n            }\\n        }\\n        return stack.size() == 0;\\n    }\\n```\\n\\n**Python**\\n```\\n    def isValid(self, S):\\n        stack = []\\n        for i in S:\\n            if i == \\'c\\':\\n                if stack[-2:] != [\\'a\\', \\'b\\']:\\n                    return False\\n                stack.pop()\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        return not stack\\n```\\n\\n\\n<br>\\n\\n## **Solution 3,  Accepted Wrong Solution...**\\nOne wrong solution is that check that if `count[a] >= count[b] >= count[c]` always valid.\\nIt\\'s hard for Leetcode to construct all kinds of false positive test cases.\\nOne easy counterexample can be `\"aabbcc\"`, expecting Leetcode to add it later.\\n\\n```\\n    def isValid(self, S):\\n        count = [0, 0, 0]\\n        for i in S:\\n            count[ord(i) - ord(\\'a\\')] += 1\\n            if not count[0] >= count[1] >= count[2]:\\n                return False\\n        return count[0] == count[1] == count[2]\\n```",
                "solutionTags": [],
                "code": "```\\n    def isValid(self, S):\\n        S2 = \"\"\\n        while S != S2:\\n            S, S2 = S.replace(\"abc\", \"\"), S\\n        return S == \"\"\\n```\n```\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for (char c: s.toCharArray()) {\\n            if (c == \\'c\\') {\\n                if (stack.isEmpty() || stack.pop() != \\'b\\') return false;\\n                if (stack.isEmpty() || stack.pop() != \\'a\\') return false;\\n            } else {\\n                stack.push(c);\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n```\n```\\n    bool isValid(string S) {\\n        vector<char> stack;\\n        for (char c : S) {\\n            if (c == \\'c\\') {\\n                int n = stack.size();\\n                if (n < 2 || stack[n - 1] != \\'b\\' || stack[n - 2] != \\'a\\') return false;\\n                stack.pop_back(), stack.pop_back();\\n            } else {\\n                stack.push_back(c);\\n            }\\n        }\\n        return stack.size() == 0;\\n    }\\n```\n```\\n    def isValid(self, S):\\n        stack = []\\n        for i in S:\\n            if i == \\'c\\':\\n                if stack[-2:] != [\\'a\\', \\'b\\']:\\n                    return False\\n                stack.pop()\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        return not stack\\n```\n```\\n    def isValid(self, S):\\n        count = [0, 0, 0]\\n        for i in S:\\n            count[ord(i) - ord(\\'a\\')] += 1\\n            if not count[0] >= count[1] >= count[2]:\\n                return False\\n        return count[0] == count[1] == count[2]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 247548,
                "title": "search-stack-and-2-pointers",
                "content": "**Intuition:** just do the reverse: search for \"abc\" and remove it. The string is valid if we get an empty string in the end.\\n\\n#### Simple Search Solution\\nSearch for substring, remove it, and repeat.\\n\\n**C++**\\n```cpp\\nbool isValid(string S) {\\n  for (auto i = S.find(\"abc\"); i != string::npos; i = S.find(\"abc\"))\\n    S.erase(i, 3);\\n  return S.empty();\\n}\\n```\\n**Complexity Analysis**\\n- Runtime: *O(n * n)*, where n is the number of characters. ```find``` is O(n + 3) and ```erase``` is O(n), and we repeat it n / 3 times.\\n- Memory: *O(n)*.\\n\\n#### Stack\\nWe can use a stack to build the string, removing \"abc\" as we go. This leads to a linear time complexity.\\n\\n**C++**\\n```cpp\\nbool isValid(string s) {\\n    vector<char> st;\\n    for (auto ch : s)\\n        if (ch == \\'c\\' && st.size() > 1 && st.back() == \\'b\\' && st[st.size() - 2] == \\'a\\')\\n            st.resize(st.size() - 2);\\n        else\\n            st.push_back(ch);\\n    return st.empty();\\n}\\n```\\n\\n#### 2 Pointers\\nSimilar to the stack solution, but we use a string and a pointer to build the resulting string.\\n\\n**C++**\\n```cpp\\nbool isValid(string s) {\\n    int j = 0;\\n    for (int i = 0; i < s.size(); ++i) {\\n        if (s[i] == \\'c\\' && j > 1 && s[j - 1] == \\'b\\' && s[j - 2] == \\'a\\')\\n            j -= 2;\\n        else\\n            s[j++] = s[i];\\n    }\\n    return j == 0;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nbool isValid(string S) {\\n  for (auto i = S.find(\"abc\"); i != string::npos; i = S.find(\"abc\"))\\n    S.erase(i, 3);\\n  return S.empty();\\n}\\n```\n```find```\n```erase```\n```cpp\\nbool isValid(string s) {\\n    vector<char> st;\\n    for (auto ch : s)\\n        if (ch == \\'c\\' && st.size() > 1 && st.back() == \\'b\\' && st[st.size() - 2] == \\'a\\')\\n            st.resize(st.size() - 2);\\n        else\\n            st.push_back(ch);\\n    return st.empty();\\n}\\n```\n```cpp\\nbool isValid(string s) {\\n    int j = 0;\\n    for (int i = 0; i < s.size(); ++i) {\\n        if (s[i] == \\'c\\' && j > 1 && s[j - 1] == \\'b\\' && s[j - 2] == \\'a\\')\\n            j -= 2;\\n        else\\n            s[j++] = s[i];\\n    }\\n    return j == 0;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 247643,
                "title": "java-3-lines-solution",
                "content": "```\\n    \\tString abc = \"abc\";\\n    \\t\\n    \\twhile(S.contains(abc)) {\\n    \\t\\tS = S.replace(abc, \"\");\\n    \\t}\\n    \\t\\n        return S.isEmpty();\\n\\n\\n```",
                "solutionTags": [],
                "code": "```\\n    \\tString abc = \"abc\";\\n    \\t\\n    \\twhile(S.contains(abc)) {\\n    \\t\\tS = S.replace(abc, \"\");\\n    \\t}\\n    \\t\\n        return S.isEmpty();\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1002730,
                "title": "c-short-o-n-time-o-1-space",
                "content": "## Solution 1.\\n\\n`j` is read pointer and `i` is write pointer. We always write `s[j]` to `s[i]`.\\n\\nIf the last 3 characters in front of `i` is `abc`, we clean them by `i -= 3`.\\n\\nIn the end, return `i == 0`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/check-if-word-is-valid-after-substitutions/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int i = 0, N = s.size();\\n        for (int j = 0; j < N; ++j) {\\n            s[i++] = s[j];\\n            if (i >= 3 && s[i - 3] == \\'a\\' && s[i - 2] == \\'b\\' && s[i - 1] == \\'c\\') i -= 3;\\n        }\\n        return i == 0;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/check-if-word-is-valid-after-substitutions/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int i = 0, N = s.size();\\n        for (int j = 0; j < N; ++j) {\\n            s[i++] = s[j];\\n            if (i >= 3 && s[i - 3] == \\'a\\' && s[i - 2] == \\'b\\' && s[i - 1] == \\'c\\') i -= 3;\\n        }\\n        return i == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 266550,
                "title": "python-stack-o-n-solution-with-explanation",
                "content": "#### Explanation :\\n1. If length of S be less than 3, absolutely it doesn\\'t contains any *\\'abc\\'*\\n2. Create a Stack and call it **Check**.\\n3. If the last three character of **Check** be *\\'abc\\'*, remove them.*(pop, pop, pop)*\\n4. So on.\\n5. if stack be empty, return true otherwise false.\\n\\n#### Example 1 :\\n`Input: \"aabcbc\"`\\n1. Check = [a]\\n2. Check = [a, a]\\n3. Check = [a, a, b]\\n4. Check = [a, **a, b, c**], Remove a,b,c (pop, pop , pop), Then Check = [a]\\n5. Check = [a, b]\\n6. Check = [**a, b, c**], Remove a,b,c (pop, pop , pop), Then Check = []\\n7. Check is Empty, Return `True`.\\n\\n#### Example 2 :\\n`Input: \"abcaba\"`\\n1. Check = [a]\\n2. Check = [a, b]\\n3. Check = [a, **a, b, c**], Remove a,b,c (pop, pop , pop), Then Check = [a]\\n4. Check = [a, b]\\n5. Check = [a, b, a]\\n6. Check is not Empty, Return `False`.\\n\\n#### Code : \\n```\\ndef isValid(self, S: str) -> bool:\\n    if len(S)<3:\\n        return False\\n    check=[]\\n    for c in S:\\n        check.append(c)\\n        if len(check)>=3:\\n            if check[-1]==\\'c\\' and check[-2]==\\'b\\' and check[-3]==\\'a\\': #three last characters be a,b,c\\n                check.pop()\\n                check.pop()\\n                check.pop()\\n    return not check \\'\\'\\'means check == []\\'\\'\\'\\n```",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\ndef isValid(self, S: str) -> bool:\\n    if len(S)<3:\\n        return False\\n    check=[]\\n    for c in S:\\n        check.append(c)\\n        if len(check)>=3:\\n            if check[-1]==\\'c\\' and check[-2]==\\'b\\' and check[-3]==\\'a\\': #three last characters be a,b,c\\n                check.pop()\\n                check.pop()\\n                check.pop()\\n    return not check \\'\\'\\'means check == []\\'\\'\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 263378,
                "title": "java-easy-understanding-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char curr: S.toCharArray()) {\\n            if(curr == \\'a\\'){\\n                stack.push(\\'c\\');\\n                stack.push(\\'b\\');\\n            }else if(stack.isEmpty() || stack.pop() != curr) return false;\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char curr: S.toCharArray()) {\\n            if(curr == \\'a\\'){\\n                stack.push(\\'c\\');\\n                stack.push(\\'b\\');\\n            }else if(stack.isEmpty() || stack.pop() != curr) return false;\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1340880,
                "title": "java-92-faster-6-ms-4-lines-of-clean-code",
                "content": "<-----**If you like the solution . Kindly UPvote for better reach**\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        while(s.contains(\"abc\"))\\n            s=s.replace(\"abc\",\"\"); \\n\\t\\tif(s.isEmpty())\\n\\t\\t\\treturn true;\\n        return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        while(s.contains(\"abc\"))\\n            s=s.replace(\"abc\",\"\"); \\n\\t\\tif(s.isEmpty())\\n\\t\\t\\treturn true;\\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247653,
                "title": "c-easy-short-solution",
                "content": "class Solution {\\npublic:\\n    bool isValid(string S) {\\n        \\n        while(!S.empty())\\n        {\\n            auto posn = S.find( \"abc\" );\\n            if( posn == string::npos )\\n                return 0;\\n            S.erase(posn, 3 );\\n        }\\n        return 1;\\n    }\\n};",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    bool isValid(string S) {\\n        \\n        while(!S.empty())\\n        {\\n            auto posn = S.find( \"abc\" );\\n            if( posn == string::npos )\\n                return 0;\\n            S.erase(posn, 3 );\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 700237,
                "title": "simple-c-solution-using-stack-32ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string S) {\\n        stack<char>stk ;\\n        for(int i=0;i<S.length();i++){\\n            if(S[i]==\\'a\\'){\\n                stk.push(S[i]);\\n            }else if(S[i]==\\'b\\'){\\n                if(stk.empty()==true || stk.top()!=\\'a\\')return false;\\n                stk.push(S[i]);   \\n            }else if(S[i]==\\'c\\'){\\n                if(stk.empty() || stk.top()!=\\'b\\')return false;\\n                stk.pop();\\n                if(stk.empty() || stk.top()!=\\'a\\')return false;\\n                stk.pop();\\n            }else{\\n                return false;\\n            }\\n        }\\n        return stk.empty()==true; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string S) {\\n        stack<char>stk ;\\n        for(int i=0;i<S.length();i++){\\n            if(S[i]==\\'a\\'){\\n                stk.push(S[i]);\\n            }else if(S[i]==\\'b\\'){\\n                if(stk.empty()==true || stk.top()!=\\'a\\')return false;\\n                stk.push(S[i]);   \\n            }else if(S[i]==\\'c\\'){\\n                if(stk.empty() || stk.top()!=\\'b\\')return false;\\n                stk.pop();\\n                if(stk.empty() || stk.top()!=\\'a\\')return false;\\n                stk.pop();\\n            }else{\\n                return false;\\n            }\\n        }\\n        return stk.empty()==true; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651582,
                "title": "o-n-similar-to-parenthesis-solved-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s.length()==0)   return true;\\n        if(s.length()%3!=0) return false;   // return false as string must ave equal no of a,b and c\\n        \\n        stack<char> sk;\\n        for(auto i:s)\\n        {\\n            if(i!=\\'c\\')          // if char encountered is not \\'c\\' then push\\n                sk.push(i);\\n            else\\n            {       // once we encounter \\'c\\' we must have preceding  \"ab\"\\n                    // else seq is not valid\\n                if(sk.size()>=2)\\n                {\\n                    if(sk.top()==\\'b\\')       \\n                    {\\n                        sk.pop();\\n                        if(sk.top()==\\'a\\')   // now checking for \\'a\\' to make sequence valid\\n                            sk.pop();\\n                        else\\n                            return false;\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n        }\\n        return (sk.size()==0) ? true : false;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s.length()==0)   return true;\\n        if(s.length()%3!=0) return false;   // return false as string must ave equal no of a,b and c\\n        \\n        stack<char> sk;\\n        for(auto i:s)\\n        {\\n            if(i!=\\'c\\')          // if char encountered is not \\'c\\' then push\\n                sk.push(i);\\n            else\\n            {       // once we encounter \\'c\\' we must have preceding  \"ab\"\\n                    // else seq is not valid\\n                if(sk.size()>=2)\\n                {\\n                    if(sk.top()==\\'b\\')       \\n                    {\\n                        sk.pop();\\n                        if(sk.top()==\\'a\\')   // now checking for \\'a\\' to make sequence valid\\n                            sk.pop();\\n                        else\\n                            return false;\\n                    }\\n                    else\\n                        return false;\\n                }\\n            }\\n        }\\n        return (sk.size()==0) ? true : false;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247546,
                "title": "simple-python-stack-based-solution",
                "content": "Very simple logic. \\nIf you see a \\'c\\', check if there is \\'a\\' and \\'b\\'  in stack.\\n\\n```\\ndef isValid(self, S: str) -> bool:\\n        stack = []\\n        for i in range(len(S)):\\n            if S[i] == \\'c\\':\\n                if not stack or stack.pop() != \\'b\\': return False\\n                if not stack or stack.pop() != \\'a\\': return False\\n            else:\\n                stack.append(S[i])\\n        return len(stack) == 0\\n```",
                "solutionTags": [],
                "code": "```\\ndef isValid(self, S: str) -> bool:\\n        stack = []\\n        for i in range(len(S)):\\n            if S[i] == \\'c\\':\\n                if not stack or stack.pop() != \\'b\\': return False\\n                if not stack or stack.pop() != \\'a\\': return False\\n            else:\\n                stack.append(S[i])\\n        return len(stack) == 0\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3067699,
                "title": "java-c-100-solution-using-stack-check-if-word-is-valid-after-substitutions",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```Java []\\nclass Solution {\\n    public boolean isValid(String s) {\\n        int n = s.length();\\n        Stack<Character> stk = new Stack<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            stk.push(s.charAt(i));\\n            if(s.charAt(i)==\\'c\\' && stk.size()>=3)\\n            {\\n                char c,b,a;\\n                c = stk.pop();\\n                b = stk.pop();\\n                a = stk.pop();\\n                if(a==\\'a\\' && b==\\'b\\' && c==\\'c\\')\\n                {\\n                    //Ignore\\n                }\\n                else\\n                {\\n                    stk.push(a);\\n                    stk.push(b);\\n                    stk.push(c);\\n                }\\n            }\\n            else if(s.charAt(i)==\\'c\\')\\n                return false;\\n        }\\n        return stk.empty();\\n    }\\n}\\n```\\n```C++ []\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n = s.size();\\n        stack<char> stk;\\n        for(int i=0;i<n;i++)\\n        {\\n            stk.push(s[i]);\\n            if(s[i]==\\'c\\' && stk.size()>=3)\\n            {\\n                char c,b,a;\\n                c = stk.top();\\n                stk.pop();\\n                b = stk.top();\\n                stk.pop();\\n                a = stk.top();\\n                stk.pop();\\n                if(a==\\'a\\' && b==\\'b\\' && c==\\'c\\')\\n                {\\n                    //Ignore\\n                }\\n                else\\n                {\\n                    stk.push(a);\\n                    stk.push(b);\\n                    stk.push(c);\\n                }\\n            }\\n            else if(s[i]==\\'c\\')\\n                return false;\\n        }\\n        return stk.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```Java []\\nclass Solution {\\n    public boolean isValid(String s) {\\n        int n = s.length();\\n        Stack<Character> stk = new Stack<>();\\n        for(int i=0;i<n;i++)\\n        {\\n            stk.push(s.charAt(i));\\n            if(s.charAt(i)==\\'c\\' && stk.size()>=3)\\n            {\\n                char c,b,a;\\n                c = stk.pop();\\n                b = stk.pop();\\n                a = stk.pop();\\n                if(a==\\'a\\' && b==\\'b\\' && c==\\'c\\')\\n                {\\n                    //Ignore\\n                }\\n                else\\n                {\\n                    stk.push(a);\\n                    stk.push(b);\\n                    stk.push(c);\\n                }\\n            }\\n            else if(s.charAt(i)==\\'c\\')\\n                return false;\\n        }\\n        return stk.empty();\\n    }\\n}\\n```\n```C++ []\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n = s.size();\\n        stack<char> stk;\\n        for(int i=0;i<n;i++)\\n        {\\n            stk.push(s[i]);\\n            if(s[i]==\\'c\\' && stk.size()>=3)\\n            {\\n                char c,b,a;\\n                c = stk.top();\\n                stk.pop();\\n                b = stk.top();\\n                stk.pop();\\n                a = stk.top();\\n                stk.pop();\\n                if(a==\\'a\\' && b==\\'b\\' && c==\\'c\\')\\n                {\\n                    //Ignore\\n                }\\n                else\\n                {\\n                    stk.push(a);\\n                    stk.push(b);\\n                    stk.push(c);\\n                }\\n            }\\n            else if(s[i]==\\'c\\')\\n                return false;\\n        }\\n        return stk.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1830729,
                "title": "easy-c-stack-solution",
                "content": "```\\nbool isValid(string s) {\\n        stack<char> st;\\n        unordered_map<char,int> m;\\n        for(auto it : s){\\n            m[it]++;\\n        }\\n        if(m[\\'a\\']!=m[\\'b\\']) return false;\\n        if(m[\\'a\\']!=m[\\'c\\']) return false;\\n        if(m[\\'b\\']!=m[\\'c\\']) return false;\\n        int n = s.size();\\n        for(int i=0;i<n;i++){\\n            if(!st.empty() and st.top()==\\'a\\' and s[i]==\\'b\\') st.push(s[i]);\\n            else if(!st.empty() and st.top()==\\'b\\' and s[i]==\\'c\\'){\\n                st.pop();\\n                if(!st.empty())\\n                st.pop();\\n            }\\n            else st.push(s[i]);\\n        }\\n        if(st.empty()) return true;\\n        return false;\\n    }",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nbool isValid(string s) {\\n        stack<char> st;\\n        unordered_map<char,int> m;\\n        for(auto it : s){\\n            m[it]++;\\n        }\\n        if(m[\\'a\\']!=m[\\'b\\']) return false;\\n        if(m[\\'a\\']!=m[\\'c\\']) return false;\\n        if(m[\\'b\\']!=m[\\'c\\']) return false;\\n        int n = s.size();\\n        for(int i=0;i<n;i++){\\n            if(!st.empty() and st.top()==\\'a\\' and s[i]==\\'b\\') st.push(s[i]);\\n            else if(!st.empty() and st.top()==\\'b\\' and s[i]==\\'c\\'){\\n                st.pop();\\n                if(!st.empty())\\n                st.pop();\\n            }\\n            else st.push(s[i]);\\n        }\\n        if(st.empty()) return true;\\n        return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1198831,
                "title": "python3-using-stack",
                "content": "\\tclass Solution:\\n\\t\\tdef isValid(self, s: str) -> bool:\\n\\t\\t\"\"\"\\n\\t\\tWe can consider this problem as a valid parenthesis, \\n\\t\\twhere for every \\'a\\' there must be \\'b\\' and for every \\'b\\' there must be \\'c\\'.\\n\\t\\tWe can use stack to track the elements.\\n\\t\\t\"\"\"\\n\\t\\t\\t# the  first ch must be \\'a\\' and last ch must be \\'c\\'\\n\\t\\t\\tif s[0] != \\'a\\' or s[-1]!=\\'c\\':\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tstack = []\\n\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tch = s[i]\\n\\t\\t\\t\\t# if ch is \\'a\\' or \\'b\\' then simply append it into the stack\\n\\t\\t\\t\\tif ch == \\'a\\' or ch == \\'b\\':\\n\\t\\t\\t\\t\\tstack.append(ch)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t# this means if ch is \\'c\\' then there must be \\'b\\' on the top of the stack\\n\\t\\t\\t\\t\\tif len(stack)==0 or stack[-1]!=\\'b\\':\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# there must be \\'a\\' on the top of the stack after popping out \\'b\\'\\n\\t\\t\\t\\t\\tif len(stack) == 0 or stack[-1]!=\\'a\\':\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tstack.pop()\\n\\n\\t\\t\\t# if the string is valid, the stack must be empty in the end\\n\\t\\t\\treturn len(stack) == 0\\n\\n",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef isValid(self, s: str) -> bool:\\n\\t\\t\"\"\"\\n\\t\\tWe can consider this problem as a valid parenthesis, \\n\\t\\twhere for every \\'a\\' there must be \\'b\\' and for every \\'b\\' there must be \\'c\\'.\\n\\t\\tWe can use stack to track the elements.\\n\\t\\t\"\"\"\\n\\t\\t\\t# the  first ch must be \\'a\\' and last ch must be \\'c\\'\\n\\t\\t\\tif s[0] != \\'a\\' or s[-1]!=\\'c\\':\\n\\t\\t\\t\\treturn False\\n\\n\\t\\t\\tstack = []\\n\\n\\t\\t\\tfor i in range(len(s)):\\n\\t\\t\\t\\tch = s[i]\\n\\t\\t\\t\\t# if ch is \\'a\\' or \\'b\\' then simply append it into the stack\\n\\t\\t\\t\\tif ch == \\'a\\' or ch == \\'b\\':\\n\\t\\t\\t\\t\\tstack.append(ch)\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t# this means if ch is \\'c\\' then there must be \\'b\\' on the top of the stack\\n\\t\\t\\t\\t\\tif len(stack)==0 or stack[-1]!=\\'b\\':\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tstack.pop()\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t# there must be \\'a\\' on the top of the stack after popping out \\'b\\'\\n\\t\\t\\t\\t\\tif len(stack) == 0 or stack[-1]!=\\'a\\':\\n\\t\\t\\t\\t\\t\\treturn False\\n\\t\\t\\t\\t\\tstack.pop()\\n\\n\\t\\t\\t# if the string is valid, the stack must be empty in the end\\n\\t\\t\\treturn len(stack) == 0\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 1191183,
                "title": "94-faster-java-2-line-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        while (s.contains(\"abc\")) s = s.replace(\"abc\", \"\");\\n        return s.equals(\"\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        while (s.contains(\"abc\")) s = s.replace(\"abc\", \"\");\\n        return s.equals(\"\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 778791,
                "title": "short-iterative-python-o-n-stack-solution",
                "content": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        stack = []\\n        for ch in S:\\n            if ch == \\'c\\':\\n                if len(stack) < 2 or stack.pop() != \\'b\\' or stack.pop() != \\'a\\':\\n                    return False\\n            else:\\n                stack.append(ch)\\n        \\n        return not stack\\n```",
                "solutionTags": [
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        stack = []\\n        for ch in S:\\n            if ch == \\'c\\':\\n                if len(stack) < 2 or stack.pop() != \\'b\\' or stack.pop() != \\'a\\':\\n                    return False\\n            else:\\n                stack.append(ch)\\n        \\n        return not stack\\n```",
                "codeTag": "Java"
            },
            {
                "id": 447844,
                "title": "3-lines-java-solution-use-recursion",
                "content": "```\\npublic boolean isValid(String S) {\\n        if (S.isEmpty()) return true;\\n        if (!S.contains(\"abc\")) return false;\\n        return isValid(S.replace(\"abc\", \"\"));\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isValid(String S) {\\n        if (S.isEmpty()) return true;\\n        if (!S.contains(\"abc\")) return false;\\n        return isValid(S.replace(\"abc\", \"\"));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 250085,
                "title": "java-o-n-time-o-1-space",
                "content": "Hi, this is a combination of counting occurrences of characters, and not allowing certain characters to appear after others. For example, it is simple to deduce that \"b\" can never appear after another \"b\", and \"c\" can never appear after an \"a\". \\n\\nSo we scan first to check for wrong occurrences, and then we scan again to count the occurrences of each character. In the second loop, we are careful not to have more \"b\\'s\" than \"a\\'s\" or more \"c\\'s\" than \"b\\'s\". \\n\\n````\\nclass Solution {\\n    public boolean isValid(String S) {\\n        int[] abc = new int[3];\\n        if(S.length() < 3) return false;\\n        char f = S.charAt(0);\\n        for(int i = 1; i < S.length(); i++){\\n            if(f == \\'a\\'){\\n                if(S.charAt(i) == \\'c\\') return false;\\n            }\\n            else if(f == \\'b\\'){\\n                if(S.charAt(i) == \\'b\\') return false;\\n            }\\n            f = S.charAt(i);\\n        }\\n        for(int i = 0; i < S.length(); i++){\\n            char c = S.charAt(i);\\n            if(c == \\'a\\'){\\n                abc[0]++;\\n            }\\n            if(c == \\'b\\'){\\n                if(abc[1] >= abc[0]) return false;\\n                abc[1]++;\\n            }\\n            if(c == \\'c\\'){\\n                if(abc[2] >= abc[1]) return false;\\n                abc[2]++;\\n            }\\n        }\\n        \\n        return abc[0] == abc[1] && abc[1] == abc[2];\\n    }\\n}\\n````",
                "solutionTags": [],
                "code": "````\\nclass Solution {\\n    public boolean isValid(String S) {\\n        int[] abc = new int[3];\\n        if(S.length() < 3) return false;\\n        char f = S.charAt(0);\\n        for(int i = 1; i < S.length(); i++){\\n            if(f == \\'a\\'){\\n                if(S.charAt(i) == \\'c\\') return false;\\n            }\\n            else if(f == \\'b\\'){\\n                if(S.charAt(i) == \\'b\\') return false;\\n            }\\n            f = S.charAt(i);\\n        }\\n        for(int i = 0; i < S.length(); i++){\\n            char c = S.charAt(i);\\n            if(c == \\'a\\'){\\n                abc[0]++;\\n            }\\n            if(c == \\'b\\'){\\n                if(abc[1] >= abc[0]) return false;\\n                abc[1]++;\\n            }\\n            if(c == \\'c\\'){\\n                if(abc[2] >= abc[1]) return false;\\n                abc[2]++;\\n            }\\n        }\\n        \\n        return abc[0] == abc[1] && abc[1] == abc[2];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2892010,
                "title": "cpp-must-see-very-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) \\n\\t{\\n       stack<char>stk;\\n\\t   int idx = 0;\\n\\t   \\n\\t   while(idx < s.length())\\n\\t   {\\n\\t       char ch = s[idx];\\n           \\n           if(ch == \\'a\\')\\n           { \\n           \\t   stk.push(ch);\\n\\t\\t   }\\n\\t\\t   else if(ch == \\'b\\')\\n\\t\\t   {\\n\\t\\t   \\t   stk.push(ch);\\n\\t\\t   }\\n\\t\\t   else if(ch == \\'c\\')\\n\\t\\t   {\\n\\t\\t   \\t    if(stk.size() >= 2)\\n\\t\\t   \\t    {\\n\\t\\t   \\t         char ch2 = stk.top();\\n\\t\\t   \\t         stk.pop();\\n\\t\\t\\t\\t\\t char ch1 = stk.top();\\t\\n\\t\\t\\t\\t\\t stk.pop();\\n\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t if(!(ch1==\\'a\\' and ch2==\\'b\\' and ch==\\'c\\'))\\n\\t\\t\\t\\t\\t {\\n\\t\\t\\t\\t\\t \\t stk.push(ch1);\\n\\t\\t\\t\\t\\t \\t stk.push(ch2);\\n\\t\\t\\t\\t\\t \\t stk.push(ch);\\n\\t\\t\\t\\t\\t }\\n\\t\\t        } \\n\\t\\t   }\\n\\t\\t   idx++;\\n\\t   }    \\n\\t   if(stk.empty()==true and idx>=s.length())\\n\\t   return true;\\n\\t   \\n\\t   return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) \\n\\t{\\n       stack<char>stk;\\n\\t   int idx = 0;\\n\\t   \\n\\t   while(idx < s.length())\\n\\t   {\\n\\t       char ch = s[idx];\\n           \\n           if(ch == \\'a\\')\\n           { \\n           \\t   stk.push(ch);\\n\\t\\t   }\\n\\t\\t   else if(ch == \\'b\\')\\n\\t\\t   {\\n\\t\\t   \\t   stk.push(ch);\\n\\t\\t   }\\n\\t\\t   else if(ch == \\'c\\')\\n\\t\\t   {\\n\\t\\t   \\t    if(stk.size() >= 2)\\n\\t\\t   \\t    {\\n\\t\\t   \\t         char ch2 = stk.top();\\n\\t\\t   \\t         stk.pop();\\n\\t\\t\\t\\t\\t char ch1 = stk.top();\\t\\n\\t\\t\\t\\t\\t stk.pop();\\n\\t\\t\\t\\t\\t \\n\\t\\t\\t\\t\\t if(!(ch1==\\'a\\' and ch2==\\'b\\' and ch==\\'c\\'))\\n\\t\\t\\t\\t\\t {\\n\\t\\t\\t\\t\\t \\t stk.push(ch1);\\n\\t\\t\\t\\t\\t \\t stk.push(ch2);\\n\\t\\t\\t\\t\\t \\t stk.push(ch);\\n\\t\\t\\t\\t\\t }\\n\\t\\t        } \\n\\t\\t   }\\n\\t\\t   idx++;\\n\\t   }    \\n\\t   if(stk.empty()==true and idx>=s.length())\\n\\t   return true;\\n\\t   \\n\\t   return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2653460,
                "title": "c-easy-to-understand-detailed",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool isValid(string S) {\\n        vector<char> stack;\\n        for (char c : S) {\\n            if (c == \\'c\\') {\\n                int n = stack.size();\\n                if (n < 2 || stack[n - 1] != \\'b\\' || stack[n - 2] != \\'a\\') return false;\\n                stack.pop_back(), stack.pop_back();\\n            } else {\\n                stack.push_back(c);\\n            }\\n        }\\n        return stack.size() == 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool isValid(string S) {\\n        vector<char> stack;\\n        for (char c : S) {\\n            if (c == \\'c\\') {\\n                int n = stack.size();\\n                if (n < 2 || stack[n - 1] != \\'b\\' || stack[n - 2] != \\'a\\') return false;\\n                stack.pop_back(), stack.pop_back();\\n            } else {\\n                stack.push_back(c);\\n            }\\n        }\\n        return stack.size() == 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2276513,
                "title": "java-o-n-solution",
                "content": "In this approach we are simply checking character by character,\\n* if character is not \\'c\\' simply push it in the stack.\\n* if the character is \\'c\\'  and stack\\'s top most element is \\'b\\' pop it and then check if the top most element now is \\'a\\' if so pop it.\\n\\nsimply after completely checking the string character by character, and popping out \\'b\\' then \\'a\\' (whenever \\'c\\' comes,) we are able to pop out all \\'abc\\'s, now we will check if the stack is empty or not, well it should be if the word is valid because, we popped out all the \\'abc\\'s so anything remaining in the stack is a clear indication that something is there which is making the string invalid, so return true if stack is empty otherwise false.\\n\\nNote: Refer the code below after reading above approach for better understanding.\\n\\n```class Solution {\\n    public boolean isValid(String s) {\\n        \\n        \\n           Stack<Character> st = new Stack<>();\\n    \\n    for(int i=0;i<s.length();i++){\\n        \\n        char ch = s.charAt(i);\\n        \\n        if(ch == \\'a\\' || ch == \\'b\\'){\\n            st.push(ch);\\n        }\\n        else{\\n                \\n                if(st.size()>0 && st.peek() == \\'b\\'){\\n                    st.pop();\\n                }\\n                else{\\n                    return false;\\n                }\\n                \\n                if(st.size()>0 && st.peek()==\\'a\\'){\\n                    st.pop();\\n                }\\n                else{\\n                    return false;\\n                }\\n                \\n        }\\n        \\n    }\\n        \\nif(st.size()==0){\\n    return true;\\n}\\n    return false;\\n    }\\n}```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```class Solution {\\n    public boolean isValid(String s) {\\n        \\n        \\n           Stack<Character> st = new Stack<>();\\n    \\n    for(int i=0;i<s.length();i++){\\n        \\n        char ch = s.charAt(i);\\n        \\n        if(ch == \\'a\\' || ch == \\'b\\'){\\n            st.push(ch);\\n        }\\n        else{\\n                \\n                if(st.size()>0 && st.peek() == \\'b\\'){\\n                    st.pop();\\n                }\\n                else{\\n                    return false;\\n                }\\n                \\n                if(st.size()>0 && st.peek()==\\'a\\'){\\n                    st.pop();\\n                }\\n                else{\\n                    return false;\\n                }\\n                \\n        }\\n        \\n    }\\n        \\nif(st.size()==0){\\n    return true;\\n}\\n    return false;\\n    }\\n}```",
                "codeTag": "Java"
            },
            {
                "id": 937857,
                "title": "easy-to-understand-c-solution-18-fast-beginner-friendly",
                "content": "The idea behind this solution is to check for the substring \"abc\" and erase when found. If there is a leftover string that cannot fit into a component \"abc\", we know that the string cannot be formed with the given rules. \\n\\nAn optimisation is added to increasing runtime with this method. \\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s[0]!=\\'a\\'||s.size()%3!=0){//Quick and easy optimisation, check if the whole string starts with \\'a\\', and if the length is a multiple of 3.\\n            return false;\\n        }\\n        string phrase=\"abc\";\\n        while(!s.empty()){\\n            int start_point=s.find(\"abc\");\\n            if(start_point==string::npos){\\n                if(!s.empty()){\\n                    return false;\\n                }\\n            }\\n            else{\\n                s.erase(start_point,3);\\n            }\\n        }\\n        return true;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s[0]!=\\'a\\'||s.size()%3!=0){//Quick and easy optimisation, check if the whole string starts with \\'a\\', and if the length is a multiple of 3.\\n            return false;\\n        }\\n        string phrase=\"abc\";\\n        while(!s.empty()){\\n            int start_point=s.find(\"abc\");\\n            if(start_point==string::npos){\\n                if(!s.empty()){\\n                    return false;\\n                }\\n            }\\n            else{\\n                s.erase(start_point,3);\\n            }\\n        }\\n        return true;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 651234,
                "title": "one-line-java-solution",
                "content": "```return S.isEmpty()|| (S.contains(\"abc\") && isValid(S.replaceAll(\"abc\",\"\")));```",
                "solutionTags": [],
                "code": "```return S.isEmpty()|| (S.contains(\"abc\") && isValid(S.replaceAll(\"abc\",\"\")));```",
                "codeTag": "Unknown"
            },
            {
                "id": 362940,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String S) {// \\u6BCF\\u6B21\\u628Aabc\\u66FF\\u6362\\u6389\\uFF0C\\u53EA\\u8981\\u770B\\u6700\\u7EC8\\u662F\\u4E0D\\u662F\\u7A7A\\u5C31\\u884C\\n        if (S.equals(\"\"))\\n\\t\\t\\treturn true;\\n\\t\\telse {\\n\\t\\t\\tif (S.contains(\"abc\")) {\\n\\t\\t\\t\\tS = S.replace(\"abc\", \"\");\\n\\t\\t\\t\\treturn isValid(S);\\n\\t\\t\\t} else\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String S) {// \\u6BCF\\u6B21\\u628Aabc\\u66FF\\u6362\\u6389\\uFF0C\\u53EA\\u8981\\u770B\\u6700\\u7EC8\\u662F\\u4E0D\\u662F\\u7A7A\\u5C31\\u884C\\n        if (S.equals(\"\"))\\n\\t\\t\\treturn true;\\n\\t\\telse {\\n\\t\\t\\tif (S.contains(\"abc\")) {\\n\\t\\t\\t\\tS = S.replace(\"abc\", \"\");\\n\\t\\t\\t\\treturn isValid(S);\\n\\t\\t\\t} else\\n\\t\\t\\t\\treturn false;\\n\\t\\t}\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247569,
                "title": "easy-to-understand-python-solution",
                "content": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        A = [\\'abc\\' * i for i in range(6667)]\\n        if S in A:\\n            return True\\n        while len(S)>3:\\n            if \\'abc\\' in S:\\n                S = S.replace(\\'abc\\',\\'\\')\\n            else:\\n                return False\\n        if S == \\'abc\\':\\n            return True\\n        return False\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        A = [\\'abc\\' * i for i in range(6667)]\\n        if S in A:\\n            return True\\n        while len(S)>3:\\n            if \\'abc\\' in S:\\n                S = S.replace(\\'abc\\',\\'\\')\\n            else:\\n                return False\\n        if S == \\'abc\\':\\n            return True\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3886246,
                "title": "stack-valid-parentheses-easy-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a **Stack** to Solve This Problem. This Problem is Exactly **Same as Valid Parenthesis**.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<string> st;\\n        for(int i = 0;i<s.size();i++)\\n        {   \\n            string str(1,s[i]);\\n            if(st.empty()) st.push(str);\\n            else\\n            {\\n                string tmp = st.top();\\n                if(s[i]-tmp[tmp.size()-1]==1)\\n                {\\n                   st.pop();\\n                   tmp+=s[i]; \\n                   if(tmp.size()<3) st.push(tmp);\\n                } \\n                else st.push(str);\\n            }\\n        }\\n        return st.size()==0;\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/923dbf6a-8105-4923-a6d7-1e83b9ff7202_1691585643.2219536.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<string> st;\\n        for(int i = 0;i<s.size();i++)\\n        {   \\n            string str(1,s[i]);\\n            if(st.empty()) st.push(str);\\n            else\\n            {\\n                string tmp = st.top();\\n                if(s[i]-tmp[tmp.size()-1]==1)\\n                {\\n                   st.pop();\\n                   tmp+=s[i]; \\n                   if(tmp.size()<3) st.push(tmp);\\n                } \\n                else st.push(str);\\n            }\\n        }\\n        return st.size()==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072025,
                "title": "js-t-100-s-100",
                "content": "# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nvar isValid = function (s) {\\n  while (s.length) {\\n    if (s.indexOf(\"abc\") === -1) break;\\n    s = s.replaceAll(\"abc\", \"\");\\n  }\\n  return !s.length;\\n};\\n\\n```\\n\\n![1.jpg](https://assets.leetcode.com/users/images/1420e185-6a39-4562-bae9-f43367ef5587_1674118852.2081017.jpeg)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValid = function (s) {\\n  while (s.length) {\\n    if (s.indexOf(\"abc\") === -1) break;\\n    s = s.replaceAll(\"abc\", \"\");\\n  }\\n  return !s.length;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3069665,
                "title": "7ms-c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is asking to determine if a given string s is valid, where a valid string is one in which c can only be present if it is immediately preceded by b and b is immediately preceded by a. My first thoughts would be to use a stack data structure to keep track of the characters in the string and check if the conditions are met.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMy approach is to iterate through the characters in the string and for each character, if the current character is c, I will check if the stack has at least two elements and the top element is b, and if so, I will pop b and check if the new top element is a. If it is not, the string is not valid. If the current character is not c, I will push it onto the stack. After iterating through the string, I will check if the stack is empty and return True if it is, indicating that the string is valid. Otherwise, I will return False.\\n\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for (char c : s) {\\n            if (c == \\'c\\') {\\n                if (st.size() < 2 || st.top() != \\'b\\') return false;\\n                st.pop();\\n                if (st.top() != \\'a\\') return false;\\n                st.pop();\\n            } else st.push(c);\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for (char c : s) {\\n            if (c == \\'c\\') {\\n                if (st.size() < 2 || st.top() != \\'b\\') return false;\\n                st.pop();\\n                if (st.top() != \\'a\\') return false;\\n                st.pop();\\n            } else st.push(c);\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2658673,
                "title": "java-one-pass",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n            public boolean isValid(String s) {\\n        // Stack<Character> stack = new Stack<>();\\n        // for (char c: s.toCharArray()) {\\n        //     if (c == \\'c\\') {\\n        //         if (stack.isEmpty() || stack.pop() != \\'b\\') return false;\\n        //         if (stack.isEmpty() || stack.pop() != \\'a\\') return false;\\n        //     } else {\\n        //         stack.push(c);\\n        //     }\\n        // }\\n        // return stack.isEmpty();\\n        while(s.contains(\"abc\"))s=s.replace(\"abc\",\"\");\\n        return s==\"\";\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n            public boolean isValid(String s) {\\n        // Stack<Character> stack = new Stack<>();\\n        // for (char c: s.toCharArray()) {\\n        //     if (c == \\'c\\') {\\n        //         if (stack.isEmpty() || stack.pop() != \\'b\\') return false;\\n        //         if (stack.isEmpty() || stack.pop() != \\'a\\') return false;\\n        //     } else {\\n        //         stack.push(c);\\n        //     }\\n        // }\\n        // return stack.isEmpty();\\n        while(s.contains(\"abc\"))s=s.replace(\"abc\",\"\");\\n        return s==\"\";\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2238315,
                "title": "easy-simple-stack-and-string-replace-approaches",
                "content": "### Without Stack Approach\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        incomplete = True\\n        \\n        while incomplete:\\n            if \\'abc\\' in s:\\n                s= s.replace(\\'abc\\',\\'\\')\\n            else:\\n                incomplete = False\\n        \\n        return s == \\'\\'\\n```\\n\\n### With Stack Approach\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack = []\\n        \\n        for i in s:\\n            if i == \\'c\\' and len(stack) >= 2 and stack[-1] == \\'b\\' and stack[-2] == \\'a\\':\\n                stack.pop()\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        \\n        if \\'\\'.join(stack) == \\'abc\\': stack = []\\n            \\n        return stack == []\\n```                \\n**Please upvote if this helped! :)**\\n\\t\\t\\n\\t\\t",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        incomplete = True\\n        \\n        while incomplete:\\n            if \\'abc\\' in s:\\n                s= s.replace(\\'abc\\',\\'\\')\\n            else:\\n                incomplete = False\\n        \\n        return s == \\'\\'\\n```\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack = []\\n        \\n        for i in s:\\n            if i == \\'c\\' and len(stack) >= 2 and stack[-1] == \\'b\\' and stack[-2] == \\'a\\':\\n                stack.pop()\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        \\n        if \\'\\'.join(stack) == \\'abc\\': stack = []\\n            \\n        return stack == []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1344384,
                "title": "java-92-faster-3-lines-of-code",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        while (s.contains(\"abc\"))\\n            s = s.replace(\"abc\", \"\");\\n        return s.length() == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        while (s.contains(\"abc\"))\\n            s = s.replace(\"abc\", \"\");\\n        return s.length() == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1291378,
                "title": "python-solution-using-stack",
                "content": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack=[]\\n        for i in s:\\n            if i == \\'a\\':stack.append(i)\\n            elif i==\\'b\\':\\n                if not stack:return False\\n                else:\\n                    if stack[-1]==\\'a\\':stack.pop()\\n                    else:return False\\n                    stack.append(i)\\n            else:\\n                if not stack:return False\\n                else:\\n                    if stack[-1]==\\'b\\':stack.pop()\\n                    else:return False\\n\\n        return len(stack)==0\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack=[]\\n        for i in s:\\n            if i == \\'a\\':stack.append(i)\\n            elif i==\\'b\\':\\n                if not stack:return False\\n                else:\\n                    if stack[-1]==\\'a\\':stack.pop()\\n                    else:return False\\n                    stack.append(i)\\n            else:\\n                if not stack:return False\\n                else:\\n                    if stack[-1]==\\'b\\':stack.pop()\\n                    else:return False\\n\\n        return len(stack)==0\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1220206,
                "title": "c-simple-o-n-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        ios_base::sync_with_stdio(false);\\t\\n        cin.tie(NULL);\\t\\n        stack<char> valid;\\n        for (auto ele: s){\\n            if (ele==\\'a\\')\\n                valid.push(ele);\\n            else if(ele==\\'b\\' && !valid.empty() && valid.top()==\\'a\\'){\\n                valid.pop();\\n                valid.push(ele);\\n            }\\n            else if(ele==\\'c\\' && !valid.empty() && valid.top()==\\'b\\')\\n                valid.pop();\\n            else\\n                return false;\\n        }\\n        return valid.empty();\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        ios_base::sync_with_stdio(false);\\t\\n        cin.tie(NULL);\\t\\n        stack<char> valid;\\n        for (auto ele: s){\\n            if (ele==\\'a\\')\\n                valid.push(ele);\\n            else if(ele==\\'b\\' && !valid.empty() && valid.top()==\\'a\\'){\\n                valid.pop();\\n                valid.push(ele);\\n            }\\n            else if(ele==\\'c\\' && !valid.empty() && valid.top()==\\'b\\')\\n                valid.pop();\\n            else\\n                return false;\\n        }\\n        return valid.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1155359,
                "title": "java-string",
                "content": "class Solution {\\n    public boolean isValid(String s) {\\n\\t\\n        while(s.length()!=0)\\n        {\\n            if(s.contains(\"abc\"))\\n                s=s.replace(\"abc\",\"\");\\n            else \\n                return false;       \\n        }\\n        return true;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isValid(String s) {\\n\\t\\n        while(s.length()!=0)\\n        {\\n            if(s.contains(\"abc\"))\\n                s=s.replace(\"abc\",\"\");\\n            else \\n                return false;       \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1009739,
                "title": "c-3-solutions-vector-read-write-pointer-stack",
                "content": "### Vector Solution is the Fastest\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n      vector<char> v;\\n      for(int i=0;i<s.size();i++){\\n        if(s[i]==\\'c\\'){\\n          int sz = v.size();\\n          if(sz<2 || v[sz-2]!=\\'a\\' || v[sz-1]!=\\'b\\') return false;\\n          v.pop_back();\\n          v.pop_back();\\n        }else{\\n          v.push_back(s[i]);\\n        }\\n      }\\n      return v.size()==0;\\n        \\n    }\\n};\\n```\\n\\n\\n### Read and Write Pointer is faster\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n      int i = 0, N = s.size();\\n        for (int j = 0; j < N; ++j) {\\n            s[i++] = s[j];\\n            if (i >= 3 && s[i - 3] == \\'a\\' && s[i - 2] == \\'b\\' && s[i - 1] == \\'c\\') i -= 3;\\n        }\\n        return i == 0;\\n    }\\n};\\n```\\n\\n \\n ### Stack is Slow compared to Vector & Pointer Solution\\n\\n```cpp\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n      stack<char> Stack;\\n      for(int i = 0; i< s.size(); i++){\\n        if(s[i]==\\'c\\'){\\n          if(Stack.empty() || Stack.top()!=\\'b\\') return false;\\n          Stack.pop();\\n          if(Stack.empty() || Stack.top()!=\\'a\\') return false;\\n          Stack.pop();\\n        }else{\\n          Stack.push(s[i]);\\n        }\\n      }\\n      return Stack.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n      vector<char> v;\\n      for(int i=0;i<s.size();i++){\\n        if(s[i]==\\'c\\'){\\n          int sz = v.size();\\n          if(sz<2 || v[sz-2]!=\\'a\\' || v[sz-1]!=\\'b\\') return false;\\n          v.pop_back();\\n          v.pop_back();\\n        }else{\\n          v.push_back(s[i]);\\n        }\\n      }\\n      return v.size()==0;\\n        \\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n      int i = 0, N = s.size();\\n        for (int j = 0; j < N; ++j) {\\n            s[i++] = s[j];\\n            if (i >= 3 && s[i - 3] == \\'a\\' && s[i - 2] == \\'b\\' && s[i - 1] == \\'c\\') i -= 3;\\n        }\\n        return i == 0;\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n      stack<char> Stack;\\n      for(int i = 0; i< s.size(); i++){\\n        if(s[i]==\\'c\\'){\\n          if(Stack.empty() || Stack.top()!=\\'b\\') return false;\\n          Stack.pop();\\n          if(Stack.empty() || Stack.top()!=\\'a\\') return false;\\n          Stack.pop();\\n        }else{\\n          Stack.push(s[i]);\\n        }\\n      }\\n      return Stack.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 945165,
                "title": "simple-java-solution",
                "content": "As per the question the stating of the string is always a empty string .\\nSo in the input string every time we encounter a \"abc\" replace it with a \"\" .\\nSo at the end if it is a empty the result is true else false.\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        \\n        String check = \"abc\";\\n        while(s.contains(check))\\n            s = s.replace(check,\"\"); \\n        return s.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        \\n        String check = \"abc\";\\n        while(s.contains(check))\\n            s = s.replace(check,\"\"); \\n        return s.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 845895,
                "title": "java-stack-but-bad-question",
                "content": "Although there are a lot of passed solution using, for example, stack. I don\\'t think it is clear.\\nNo statement in the problem shows that a + str + b + str + c is a valid string.\\nSee my second solution for excluding this case;\\nref from [@lee215](https://leetcode.com/problems/check-if-word-is-valid-after-substitutions/discuss/247626/JavaPythonC%2B%2B-Stack-Solution-O(N)).\\n```\\n\\t\\tStack<Character> st = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'c\\') {\\n                if (st.isEmpty() || st.pop() != \\'b\\') return false;\\n                if (st.isEmpty() || st.pop() != \\'a\\') return false;\\n            } else st.push(c);\\n        }\\n        return st.isEmpty();\\n```\\n\\n2nd: (not pass)\\n```\\n    public boolean isValid(String s) {\\n        int len = s.length();\\n        if (len % 3 != 0) return false; \\n        if (len == 0) return true;\\n        if (len == 3) return s.equals(\"abc\");\\n        if (s.substring(0, 3).equals(\"abc\") && isValid(s.substring(3))) return true;\\n        if (s.substring(len - 3).equals(\"abc\") && isValid(s.substring(0, len - 3))) return true;\\n        if (s.substring(0, 1).equals(\"a\") && s.substring(len - 2).equals(\"bc\") && isValid(s.substring(1, len - 2))) return true;\\n        if (s.substring(0, 2).equals(\"ab\") && s.substring(len - 1).equals(\"c\") && isValid(s.substring(2, len - 1))) return true;\\n        return false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\t\\tStack<Character> st = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char c = s.charAt(i);\\n            if (c == \\'c\\') {\\n                if (st.isEmpty() || st.pop() != \\'b\\') return false;\\n                if (st.isEmpty() || st.pop() != \\'a\\') return false;\\n            } else st.push(c);\\n        }\\n        return st.isEmpty();\\n```\n```\\n    public boolean isValid(String s) {\\n        int len = s.length();\\n        if (len % 3 != 0) return false; \\n        if (len == 0) return true;\\n        if (len == 3) return s.equals(\"abc\");\\n        if (s.substring(0, 3).equals(\"abc\") && isValid(s.substring(3))) return true;\\n        if (s.substring(len - 3).equals(\"abc\") && isValid(s.substring(0, len - 3))) return true;\\n        if (s.substring(0, 1).equals(\"a\") && s.substring(len - 2).equals(\"bc\") && isValid(s.substring(1, len - 2))) return true;\\n        if (s.substring(0, 2).equals(\"ab\") && s.substring(len - 1).equals(\"c\") && isValid(s.substring(2, len - 1))) return true;\\n        return false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 571352,
                "title": "simple-c-code-using-stack",
                "content": "```\\nbool isValid(string S) {\\n\\tstring t;\\n\\tfor (int i = 0; i < S.length(); ++i) {\\n\\t\\tt.push_back(S[i]);\\n\\t\\twhile (t.size() >= 3 && t.back() == \\'c\\' && t[t.size() - 2] == \\'b\\' && t[t.size() - 3] == \\'a\\') {\\n\\t\\t\\tt.pop_back();\\n\\t\\t\\tt.pop_back();\\n\\t\\t\\tt.pop_back();\\n\\t\\t}\\n\\t}\\n\\treturn (bool)(!t.size());\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nbool isValid(string S) {\\n\\tstring t;\\n\\tfor (int i = 0; i < S.length(); ++i) {\\n\\t\\tt.push_back(S[i]);\\n\\t\\twhile (t.size() >= 3 && t.back() == \\'c\\' && t[t.size() - 2] == \\'b\\' && t[t.size() - 3] == \\'a\\') {\\n\\t\\t\\tt.pop_back();\\n\\t\\t\\tt.pop_back();\\n\\t\\t\\tt.pop_back();\\n\\t\\t}\\n\\t}\\n\\treturn (bool)(!t.size());\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 491793,
                "title": "swift-stack-solution-o-n",
                "content": "```\\nclass Solution {\\n    func isValid(_ S: String) -> Bool {\\n        var stack:[Character] = []\\n        for item in S{\\n            if item == \"c\"{\\n                let prev2 = stack.popLast()\\n                let prev1 = stack.popLast()\\n                if prev1 == \"a\" && prev2 == \"b\"{\\n                    continue\\n                }else{\\n                    return false\\n                }\\n            }else{\\n                stack.append(item)\\n            }\\n        }\\n        return stack.isEmpty\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    func isValid(_ S: String) -> Bool {\\n        var stack:[Character] = []\\n        for item in S{\\n            if item == \"c\"{\\n                let prev2 = stack.popLast()\\n                let prev1 = stack.popLast()\\n                if prev1 == \"a\" && prev2 == \"b\"{\\n                    continue\\n                }else{\\n                    return false\\n                }\\n            }else{\\n                stack.append(item)\\n            }\\n        }\\n        return stack.isEmpty\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 428162,
                "title": "java-6ms-o-n-stack-based-solution-easy-5-liner-with-comments",
                "content": "Intuition: We work in reverse and delete all the \\'abc\\' occurances recursively(using a stack here). If we are left with nothing in the end after removing all such occurances we return true else false.\\t\\n\\t\\n\\tclass Solution {\\n    public boolean isValid(String S) {\\n        char[]stk=new char[S.length()]; int top=-1;\\n        char[] arr=S.toCharArray();\\n        \\n        for(int i=0;i<arr.length;i++)\\n\\t\\t/* if current character is \\'c\\' and we have \\'a\\' & \\'b\\' on top of the stack, move top two places before to forget/dump this \\'abc\\' occurance*/\\n            if(arr[i]==\\'c\\' && top>0 && stk[top]==\\'b\\' && stk[top-1]==\\'a\\')    \\n                top-=2;\\n            else   \\n                stk[++top]=arr[i]; \\n\\n        return top==-1;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isValid(String S) {\\n        char[]stk=new char[S.length()]; int top=-1;\\n        char[] arr=S.toCharArray();\\n        \\n        for(int i=0;i<arr.length;i++)\\n\\t\\t/* if current character is \\'c\\' and we have \\'a\\' & \\'b\\' on top of the stack, move top two places before to forget/dump this \\'abc\\' occurance*/\\n            if(arr[i]==\\'c\\' && top>0 && stk[top]==\\'b\\' && stk[top-1]==\\'a\\')    \\n                top-=2;\\n            else   \\n                stk[++top]=arr[i]; \\n\\n        return top==-1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 424502,
                "title": "python-100-fast-100-memory",
                "content": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        n = len(S)\\n        if n%3 or S[0]==\\'b\\' or S[0]==\\'c\\' or S[n-1]==\\'a\\' or S[n-1]==\\'b\\':\\n            return False\\n        if \\'ac\\' in S or \\'bb\\' in S:\\n            return False   \\n        return S.count(\\'a\\')==S.count(\\'b\\') and S.count(\\'b\\')==S.count(\\'c\\')\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        n = len(S)\\n        if n%3 or S[0]==\\'b\\' or S[0]==\\'c\\' or S[n-1]==\\'a\\' or S[n-1]==\\'b\\':\\n            return False\\n        if \\'ac\\' in S or \\'bb\\' in S:\\n            return False   \\n        return S.count(\\'a\\')==S.count(\\'b\\') and S.count(\\'b\\')==S.count(\\'c\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 423848,
                "title": "easy-to-understand-c-solution-16ms-beats-89",
                "content": "Runtime: 16 ms, faster than 89.58% of C++ online submissions for Check If Word Is Valid After Substitutions.\\nMemory Usage: 10.4 MB, less than 100.00% of C++ online submissions for Check If Word Is Valid After Substitutions.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string S) {\\n        stack<char> st;\\n        for(char ch : S)\\n        {\\n            if(ch == \\'a\\')\\n                st.push(ch);\\n            else if(ch == \\'b\\')\\n            {\\n                if(st.empty() || st.top() != \\'a\\')\\n                    return false;\\n                st.push(ch);\\n            }\\n            else if(ch == \\'c\\')\\n            {\\n                if(st.empty() || st.top() != \\'b\\')\\n                    return false;\\n                st.pop();\\n                if(st.empty() || st.top() != \\'a\\')\\n                    return false;\\n                else\\n                    st.pop();\\n            }\\n        }\\n        return (st.empty());\\n    }\\n};",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    bool isValid(string S) {\\n        stack<char> st;\\n        for(char ch : S)\\n        {\\n            if(ch == \\'a\\')\\n                st.push(ch);\\n            else if(ch == \\'b\\')\\n            {\\n                if(st.empty() || st.top() != \\'a\\')\\n                    return false;\\n                st.push(ch);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 410700,
                "title": "java-using-stack",
                "content": "For what I did. I marked abc with different val, a == 1, b == 2, c == 3;\\nif we have a string aabcbc\\nthen for index from 0 to end we will have stack as follow:\\n1\\n1 1\\n1 2\\n1\\n2\\nempty\\n\\n```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        Stack<Integer> stack = new Stack();\\n        \\n        for(int i = 0; i < S.length(); ++i){\\n            if(stack.isEmpty()){\\n                if(S.charAt(i) == \\'a\\'){\\n                    stack.push(1);\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n            else{\\n                switch(S.charAt(i)){\\n                    case \\'a\\':\\n                        stack.push(1);\\n                        break;\\n                    case \\'b\\':\\n                        if(stack.peek() == 1){\\n                            stack.pop();\\n                            stack.push(2);\\n                        }\\n                        else{\\n                            return false;\\n                        }\\n                        break;\\n                    default:\\n                        if(stack.peek() == 2){\\n                            stack.pop();\\n                        }\\n                        else{\\n                            return false;\\n                        }\\n                        break;\\n                }\\n            }\\n        }\\n        \\n        if(stack.isEmpty()){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        Stack<Integer> stack = new Stack();\\n        \\n        for(int i = 0; i < S.length(); ++i){\\n            if(stack.isEmpty()){\\n                if(S.charAt(i) == \\'a\\'){\\n                    stack.push(1);\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n            else{\\n                switch(S.charAt(i)){\\n                    case \\'a\\':\\n                        stack.push(1);\\n                        break;\\n                    case \\'b\\':\\n                        if(stack.peek() == 1){\\n                            stack.pop();\\n                            stack.push(2);\\n                        }\\n                        else{\\n                            return false;\\n                        }\\n                        break;\\n                    default:\\n                        if(stack.peek() == 2){\\n                            stack.pop();\\n                        }\\n                        else{\\n                            return false;\\n                        }\\n                        break;\\n                }\\n            }\\n        }\\n        \\n        if(stack.isEmpty()){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 336280,
                "title": "simple-solution-in-python-using-count-and-replace",
                "content": "We simply want to use count and replace in Python to check if we have any instances of \"abc\" left to replace, and if so, replace them. At the end, when there are no more instances of \"abc\" we return whether the string is empty.\\n\\n```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n\\n\\twhile S.count(\\'abc\\'):\\n\\t\\tS = S.replace(\\'abc\\',\\'\\')\\n\\n\\treturn not S\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n\\n\\twhile S.count(\\'abc\\'):\\n\\t\\tS = S.replace(\\'abc\\',\\'\\')\\n\\n\\treturn not S\\n```",
                "codeTag": "Java"
            },
            {
                "id": 252159,
                "title": "just-use-replaceall-abc",
                "content": "I don\\'t understand why this is medium difficulty...\\n\\npublic boolean isValid(String S) {\\n        while (S.contains(\"abc\")) {\\n            S = S.replaceAll(\"abc\", \"\");\\n        }\\n        return S.length() == 0;\\n    }",
                "solutionTags": [],
                "code": "I don\\'t understand why this is medium difficulty...\\n\\npublic boolean isValid(String S) {\\n        while (S.contains(\"abc\")) {\\n            S = S.replaceAll(\"abc\", \"\");\\n        }\\n        return S.length() == 0;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 248246,
                "title": "java-stack-20-ms-100-easy",
                "content": "Solution based on stashing letters in stack. If we see characters in sequence of \"abc\" - split it, pop from stack on last \"c\". Otherwise accumulate or return false\\n\\n```\\n    public boolean isValid(String S) {\\n        Stack<String> s = new Stack();\\n        char[] arr = S.toCharArray();\\n        int N = arr.length;\\n        for (int i = 0; i < N; i++) {\\n            char next = arr[i];\\n            if (next == \\'a\\') {\\n                s.push(\"a\");\\n            } else if (next == \\'b\\' && !s.isEmpty() && s.peek().equals(\"a\"))  {\\n                s.pop();\\n                s.push(\"ab\");\\n            } else if (next == \\'c\\' && !s.isEmpty() && s.peek().equals(\"ab\"))  {\\n                s.pop();\\n            } else\\n                return false;\\n        }\\n        return s.isEmpty();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n    public boolean isValid(String S) {\\n        Stack<String> s = new Stack();\\n        char[] arr = S.toCharArray();\\n        int N = arr.length;\\n        for (int i = 0; i < N; i++) {\\n            char next = arr[i];\\n            if (next == \\'a\\') {\\n                s.push(\"a\");\\n            } else if (next == \\'b\\' && !s.isEmpty() && s.peek().equals(\"a\"))  {\\n                s.pop();\\n                s.push(\"ab\");\\n            } else if (next == \\'c\\' && !s.isEmpty() && s.peek().equals(\"ab\"))  {\\n                s.pop();\\n            } else\\n                return false;\\n        }\\n        return s.isEmpty();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4082130,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isValid(String str) {\\n\\n        StringBuilder s = new StringBuilder(str);\\n\\n        while(s.length()!=0){\\n            int a = s.indexOf(\"abc\");\\n            if(a==-1) return false;\\n            else{\\n                s.delete(a,a+3);\\n            }\\n        }\\n\\n        if(s.length()==0) return true;\\n        else return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String str) {\\n\\n        StringBuilder s = new StringBuilder(str);\\n\\n        while(s.length()!=0){\\n            int a = s.indexOf(\"abc\");\\n            if(a==-1) return false;\\n            else{\\n                s.delete(a,a+3);\\n            }\\n        }\\n\\n        if(s.length()==0) return true;\\n        else return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3629151,
                "title": "easy-c-solution-beat-100",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s[0]!=\\'a\\')\\n        return false;\\n        stack<char> st;\\n        for(char ch:s){\\n            if(ch==\\'a\\')\\n                st.push(ch);\\n            else if(ch==\\'b\\'){\\n                if(!st.empty()&&st.top()==\\'a\\')\\n                    st.push(ch);\\n                else\\n                    return false;\\n            }\\n            else\\n            {\\n                if(!st.empty()&&st.top()==\\'b\\'){\\n                    st.pop();\\n                        if(!st.empty()&&st.top()==\\'a\\')\\n                            st.pop();\\n                        else return false;\\n                    }\\n                else\\n                    return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s[0]!=\\'a\\')\\n        return false;\\n        stack<char> st;\\n        for(char ch:s){\\n            if(ch==\\'a\\')\\n                st.push(ch);\\n            else if(ch==\\'b\\'){\\n                if(!st.empty()&&st.top()==\\'a\\')\\n                    st.push(ch);\\n                else\\n                    return false;\\n            }\\n            else\\n            {\\n                if(!st.empty()&&st.top()==\\'b\\'){\\n                    st.pop();\\n                        if(!st.empty()&&st.top()==\\'a\\')\\n                            st.pop();\\n                        else return false;\\n                    }\\n                else\\n                    return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3597382,
                "title": "easy-to-understand-2-approaches-c",
                "content": "\\n\\n# Approach\\n- solution 1 Recursion \\n- solution 2 using stack\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//recursion\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n       if(s.size()==0)\\n       return true;\\n\\n       int find = s.find(\"abc\");\\n       if(find != string::npos){\\n           //found\\n           string tleft = s.substr(0,find);\\n           string tright = s.substr(find+3,s.size());\\n           \\n           return isValid(tleft + tright);\\n       } \\n       return false;\\n    }\\n};\\n\\n//TC O(N^2)\\n\\n```\\n\\n```\\n// stack \\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s[0] != \\'a\\'){\\n            return false;\\n        }\\n\\n        stack<char>st;\\n        for(char ch:s){\\n            if(ch == \\'a\\'){\\n                st.push(ch);\\n            }\\n            else if(ch == \\'b\\'){\\n                if(!st.empty() && st.top() == \\'a\\'){\\n                    st.push(ch);\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n            else{\\n                // if ch == \\'c\\'\\n                if(!st.empty() && st.top() == \\'b\\'){\\n                    st.pop();\\n                    if(!st.empty() && st.top() == \\'a\\'){\\n                        st.pop();\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return st.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Stack",
                    "Recursion"
                ],
                "code": "```\\n//recursion\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n       if(s.size()==0)\\n       return true;\\n\\n       int find = s.find(\"abc\");\\n       if(find != string::npos){\\n           //found\\n           string tleft = s.substr(0,find);\\n           string tright = s.substr(find+3,s.size());\\n           \\n           return isValid(tleft + tright);\\n       } \\n       return false;\\n    }\\n};\\n\\n//TC O(N^2)\\n\\n```\n```\\n// stack \\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s[0] != \\'a\\'){\\n            return false;\\n        }\\n\\n        stack<char>st;\\n        for(char ch:s){\\n            if(ch == \\'a\\'){\\n                st.push(ch);\\n            }\\n            else if(ch == \\'b\\'){\\n                if(!st.empty() && st.top() == \\'a\\'){\\n                    st.push(ch);\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n            else{\\n                // if ch == \\'c\\'\\n                if(!st.empty() && st.top() == \\'b\\'){\\n                    st.pop();\\n                    if(!st.empty() && st.top() == \\'a\\'){\\n                        st.pop();\\n                    }\\n                    else{\\n                        return false;\\n                    }\\n                }\\n                else{\\n                    return false;\\n                }\\n            }\\n        }\\n\\n        return st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3540701,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n\\n        if(s.size()%3!=0) return false;\\n        stack<char> st;\\n\\n        for(char c:s){\\n            if(st.empty()) st.push(c);\\n            else if(c==\\'c\\'){\\n                char b=st.top();st.pop();\\n                if(st.empty()) return false;\\n                char a = st.top(); st.pop();\\n                if(b!=\\'b\\' || a!=\\'a\\') return false;\\n            }\\n            else st.push(c);\\n        }\\n        return st.empty();\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        prev = None\\n        while s != \"\" and s != prev:\\n            prev = s\\n            s = s.replace(\"abc\", \"\")\\n        return s == \"\"\\n```\\n\\n```Java []\\nclass Solution {\\n    public boolean isValid(String s) {\\n        char[] cs = s.toCharArray();\\n        int i = 0;\\n        for (char c : cs) {\\n            if (c != \\'a\\' && (i == 0 || c != cs[--i] + 1)) {\\n                return false;\\n            }\\n            if (c != \\'c\\') {\\n                cs[i++] = c;\\n            }\\n        }\\n        return i == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n\\n        if(s.size()%3!=0) return false;\\n        stack<char> st;\\n\\n        for(char c:s){\\n            if(st.empty()) st.push(c);\\n            else if(c==\\'c\\'){\\n                char b=st.top();st.pop();\\n                if(st.empty()) return false;\\n                char a = st.top(); st.pop();\\n                if(b!=\\'b\\' || a!=\\'a\\') return false;\\n            }\\n            else st.push(c);\\n        }\\n        return st.empty();\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        prev = None\\n        while s != \"\" and s != prev:\\n            prev = s\\n            s = s.replace(\"abc\", \"\")\\n        return s == \"\"\\n```\n```Java []\\nclass Solution {\\n    public boolean isValid(String s) {\\n        char[] cs = s.toCharArray();\\n        int i = 0;\\n        for (char c : cs) {\\n            if (c != \\'a\\' && (i == 0 || c != cs[--i] + 1)) {\\n                return false;\\n            }\\n            if (c != \\'c\\') {\\n                cs[i++] = c;\\n            }\\n        }\\n        return i == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362070,
                "title": "c-check-if-word-is-valid-after-substitutions-very-easy-100-beat",
                "content": "# Approach\\nIn this case we use iterative approach for saving space with the help of stack.\\n\\n# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\npublic class Solution \\n{\\n    public bool IsValid(string s) \\n    {\\n        if(s.Length % 3 != 0) return false;\\n\\n        Stack<char> stack = new Stack<char>();\\n\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            if(s[i] != \\'c\\') stack.Push(s[i]);\\n            else\\n            {\\n                if(stack.Count < 2) return false;\\n                if(stack.Pop() != \\'b\\' || stack.Pop() != \\'a\\') return false;\\n            }\\n        }\\n\\n        return (stack.Count == 0)? true : false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution \\n{\\n    public bool IsValid(string s) \\n    {\\n        if(s.Length % 3 != 0) return false;\\n\\n        Stack<char> stack = new Stack<char>();\\n\\n        for(int i = 0; i < s.Length; i++)\\n        {\\n            if(s[i] != \\'c\\') stack.Push(s[i]);\\n            else\\n            {\\n                if(stack.Count < 2) return false;\\n                if(stack.Pop() != \\'b\\' || stack.Pop() != \\'a\\') return false;\\n            }\\n        }\\n\\n        return (stack.Count == 0)? true : false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3342101,
                "title": "chatgpt-c-solution-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   bool isValid(string s) {\\n    int i = 0, n = s.size();\\n    for (int j = 0; j < n; j++, i++) {\\n        s[i] = s[j];\\n        if (i >= 2 && s[i] == \\'c\\' && s[i-1] == \\'b\\' && s[i-2] == \\'a\\') {\\n            i -= 3;\\n        }\\n    }\\n    return i == 0;\\n}\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   bool isValid(string s) {\\n    int i = 0, n = s.size();\\n    for (int j = 0; j < n; j++, i++) {\\n        s[i] = s[j];\\n        if (i >= 2 && s[i] == \\'c\\' && s[i-1] == \\'b\\' && s[i-2] == \\'a\\') {\\n            i -= 3;\\n        }\\n    }\\n    return i == 0;\\n}\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3028339,
                "title": "most-easiest-approach-to-solve",
                "content": "# Intuition\\n  Thought at first time was to store this characters and keep track of last 3 pushes...so that it equals abc or not...So I think 3 stacks is better option...\\n\\n Example stacks st1, st2, st3 :\\n\\n st3 : abc\\n \\n then make arrangements such that\\n st2 : ab\\n \\n then\\n st1 : a\\n\\n\\n# Approach\\n   ##  Using three stacks we simply make it more easier.We track the last 3 elements in stack just by making 3 stacks.\\n\\n\\n   \\n\\n# Complexity\\n- Time complexity: linear\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n\\nbool isValid(string s) \\n{\\n    int n=s.length();\\n\\n    if(n<=2)\\n        return false;\\n       \\n    stack<char>st1,st2,st3;\\n\\n    st3.push(s[0]);\\n    st3.push(s[1]);\\n\\n    for(int i=2;i<n;i++)\\n    {\\n        st3.push(s[i]);\\n\\n        if(st3.size()>=3)\\n          {\\n            st2=st3;\\n            st2.pop();\\n            st1=st2;\\n            st1.pop();\\n\\n            if((st1.top()==\\'a\\')&&(st2.top()==\\'b\\')&&(st3.top()==\\'c\\'))\\n            {\\n                st3.pop();\\n                st3.pop();\\n                st3.pop(); \\n            }\\n       }\\n\\n    }\\n\\n    if(st3.empty())\\n          return true;\\n\\n    return false;  \\n   \\n}\\n\\n};\\n```\\n\\n\\n# Motivation Quote:\\n ## Learn the rules like a pro so you can break them like an artist \\u2764\\uFE0F\\n",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\nbool isValid(string s) \\n{\\n    int n=s.length();\\n\\n    if(n<=2)\\n        return false;\\n       \\n    stack<char>st1,st2,st3;\\n\\n    st3.push(s[0]);\\n    st3.push(s[1]);\\n\\n    for(int i=2;i<n;i++)\\n    {\\n        st3.push(s[i]);\\n\\n        if(st3.size()>=3)\\n          {\\n            st2=st3;\\n            st2.pop();\\n            st1=st2;\\n            st1.pop();\\n\\n            if((st1.top()==\\'a\\')&&(st2.top()==\\'b\\')&&(st3.top()==\\'c\\'))\\n            {\\n                st3.pop();\\n                st3.pop();\\n                st3.pop(); \\n            }\\n       }\\n\\n    }\\n\\n    if(st3.empty())\\n          return true;\\n\\n    return false;  \\n   \\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2895518,
                "title": "beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        \\n        stack<char>st;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n             if( !st.empty() && st.top()==\\'b\\'&& s[i]==\\'c\\')\\n            {\\n                st.pop();\\n                if( !st.empty() && st.top()==\\'a\\')\\n                    st.pop();\\n                else\\n                    st.push(\\'b\\');\\n            }\\n            else\\n            st.push(s[i]);\\n        }\\n        return st.size()==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        \\n        stack<char>st;\\n        int n=s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n             if( !st.empty() && st.top()==\\'b\\'&& s[i]==\\'c\\')\\n            {\\n                st.pop();\\n                if( !st.empty() && st.top()==\\'a\\')\\n                    st.pop();\\n                else\\n                    st.push(\\'b\\');\\n            }\\n            else\\n            st.push(s[i]);\\n        }\\n        return st.size()==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2776423,
                "title": "fastly-solve-this-problem-in-o-n-code-is-written-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem i solved using stack.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe idea is to solve this problem is scan string from left to right and when string char is \"a\" push onto the stack and when string char is \"b\" then check if top of the stack is \"a\" or not if yes then pop \"a\" and push \"b\" if no then return false.\\nand if string char is \"c\" then check top of the stack is \"b\" or not if yes then pop from stack and if no then return false.\\nwhen string gets over then at the end check stack empty or not if yes then return true otherwise false;\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nTime complexity is o(n) in worst case\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nSpace Complexity is o(n) in worst case\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s)\\n    {\\n        if(s[0]==\\'b\\' || s[0]==\\'c\\')\\n        {\\n            return false;\\n        }\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                st.push(s[i]);\\n                // st.push(s[i]);\\n            }\\n            else if(!st.empty() && s[i]==\\'b\\')\\n            {\\n                if(st.top()==\\'a\\')\\n                {\\n                    st.pop();\\n                    st.push(s[i]);\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                if(!st.empty() && st.top()==\\'b\\')\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        if(st.empty())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s)\\n    {\\n        if(s[0]==\\'b\\' || s[0]==\\'c\\')\\n        {\\n            return false;\\n        }\\n        stack<char> st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                st.push(s[i]);\\n                // st.push(s[i]);\\n            }\\n            else if(!st.empty() && s[i]==\\'b\\')\\n            {\\n                if(st.top()==\\'a\\')\\n                {\\n                    st.pop();\\n                    st.push(s[i]);\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                if(!st.empty() && st.top()==\\'b\\')\\n                {\\n                    st.pop();\\n                }\\n                else\\n                {\\n                    return false;\\n                }\\n            }\\n        }\\n        if(st.empty())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2542403,
                "title": "stack-solution-with-o-n-time-complexity-and-o-n-space-complexity",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char ch: s.toCharArray()){\\n            if(ch ==\\'a\\'){\\n                stack.push(\\'a\\');\\n            }\\n            else if(ch ==\\'b\\'){\\n                if(stack.size() <1 || stack.peek() != \\'a\\'){\\n                    return false;\\n                }\\n                stack.push(\\'b\\');\\n            }else{\\n                if(stack.size() < 2){\\n                    return false;\\n                }\\n                Character first = stack.pop();\\n                Character second = stack.pop();\\n                if(first != \\'b\\' || second != \\'a\\'){\\n                    return false;\\n                }\\n            }\\n        }\\n        return stack.size() == 0;\\n    }\\n}",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for(char ch: s.toCharArray()){\\n            if(ch ==\\'a\\'){\\n                stack.push(\\'a\\');\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2302064,
                "title": "java-stack-valid-after-substitutions-easy-explanation-with-comments",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        \\n        //Lets see how we can solve that as we know we have only abc in string.\\n        //Like           aabcbc\\n        // See as that   ((b)b) Think a is \\'(\\' and c is \\')\\'.\\n        // If a string is made by using abc only we can remove abc to make it empty also.\\n        \\n        //Think in Reverse Way.\\n        \\n        \\n        \\n        Stack<Character> stack = new Stack<>();\\n        char[] arr = s.toCharArray();\\n        for (int i = 0; i < arr.length; i++) {\\n            \\n            // We have to work only when we get \\')\\' means c.\\n            \\n            if(arr[i] == \\'c\\')\\n            {\\n                // If we at c means we have 2 elements before us a and b.\\n                // When we first pop we get b at second pop we get a\\n                \\n            // If this all hold true we will delete a and b we are not adding c so c also\\n                \\n                if(stack.size()>=2 && stack.pop() == \\'b\\' && stack.pop() == \\'a\\')\\n                {\\n\\n                }\\n                else\\n                {\\n                    \\n                    // If anywhere we get false in any condition that means this is not a                          valid set i.e. abc pattern is not present.\\n                    \\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                // For a and b we simply add.\\n                \\n                stack.push(arr[i]);\\n            }\\n        }\\n        \\n        //If we have only abc pattern the stack will become empty.\\n        \\n        return stack.size()==0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        \\n        //Lets see how we can solve that as we know we have only abc in string.\\n        //Like           aabcbc\\n        // See as that   ((b)b) Think a is \\'(\\' and c is \\')\\'.\\n        // If a string is made by using abc only we can remove abc to make it empty also.\\n        \\n        //Think in Reverse Way.\\n        \\n        \\n        \\n        Stack<Character> stack = new Stack<>();\\n        char[] arr = s.toCharArray();\\n        for (int i = 0; i < arr.length; i++) {\\n            \\n            // We have to work only when we get \\')\\' means c.\\n            \\n            if(arr[i] == \\'c\\')\\n            {\\n                // If we at c means we have 2 elements before us a and b.\\n                // When we first pop we get b at second pop we get a\\n                \\n            // If this all hold true we will delete a and b we are not adding c so c also\\n                \\n                if(stack.size()>=2 && stack.pop() == \\'b\\' && stack.pop() == \\'a\\')\\n                {\\n\\n                }\\n                else\\n                {\\n                    \\n                    // If anywhere we get false in any condition that means this is not a                          valid set i.e. abc pattern is not present.\\n                    \\n                    return false;\\n                }\\n            }\\n            else\\n            {\\n                // For a and b we simply add.\\n                \\n                stack.push(arr[i]);\\n            }\\n        }\\n        \\n        //If we have only abc pattern the stack will become empty.\\n        \\n        return stack.size()==0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2249534,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n\\n            if(ch == \\'a\\' || ch == \\'b\\'){\\n                st.push(ch);\\n            }else{\\n                if(st.size() == 0 || st.size() == 1) return false;\\n\\n                int top = st.pop();\\n                int stop = st.pop();\\n                if(top != \\'b\\' || stop != \\'a\\') return false;\\n            }\\n        }\\n\\n        return st.size() == 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n        for(int i = 0; i < s.length(); i++){\\n            char ch = s.charAt(i);\\n\\n            if(ch == \\'a\\' || ch == \\'b\\'){\\n                st.push(ch);\\n            }else{\\n                if(st.size() == 0 || st.size() == 1) return false;\\n\\n                int top = st.pop();\\n                int stop = st.pop();\\n                if(top != \\'b\\' || stop != \\'a\\') return false;\\n            }\\n        }\\n\\n        return st.size() == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2210215,
                "title": "simple-stack-based-solution",
                "content": "if \\'c\\' is to be inserted, there must \"ab\" before insertion. Similary if \\'b\\' is to be inserted, there must be \"a\" before insertion. Otheriwise, it\\'s an invalid string. Here \\'d\\' char is used to indicate that either a, b or c can be inserted in array i.e it\\'s not filled yet.\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<vector<char>> st;\\n        \\n        for(char ch: s){\\n            if(ch==\\'a\\'){\\n                vector<char> v{\\'a\\',\\'d\\',\\'d\\'};\\n                st.push(v);\\n            }else if(ch==\\'b\\'){\\n                if(!st.empty() and st.top()[1]==\\'d\\'){\\n                    st.pop();\\n                    vector<char> v{\\'a\\',\\'b\\',\\'d\\'};\\n                    st.push(v);\\n                }else{\\n                    return false;\\n                }\\n            }else{\\n                 if(!st.empty() && st.top()[2]==\\'d\\'){\\n                    st.pop();\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        if(st.empty()){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<vector<char>> st;\\n        \\n        for(char ch: s){\\n            if(ch==\\'a\\'){\\n                vector<char> v{\\'a\\',\\'d\\',\\'d\\'};\\n                st.push(v);\\n            }else if(ch==\\'b\\'){\\n                if(!st.empty() and st.top()[1]==\\'d\\'){\\n                    st.pop();\\n                    vector<char> v{\\'a\\',\\'b\\',\\'d\\'};\\n                    st.push(v);\\n                }else{\\n                    return false;\\n                }\\n            }else{\\n                 if(!st.empty() && st.top()[2]==\\'d\\'){\\n                    st.pop();\\n                }else{\\n                    return false;\\n                }\\n            }\\n        }\\n        \\n        if(st.empty()){\\n            return true;\\n        }\\n        \\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2139559,
                "title": "easy-c-code",
                "content": "class Solution {\\npublic:\\n\\n    bool isValid(string s) {\\n        \\n        while( s.find(\"abc\") != string::npos )\\n            s.replace(s.find(\"abc\"), 3, \"\");\\n        \\n        if(s.empty()) return 1;\\n        else return 0;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    bool isValid(string s) {\\n        \\n        while( s.find(\"abc\") != string::npos )\\n            s.replace(s.find(\"abc\"), 3, \"\");\\n        \\n        if(s.empty()) return 1;\\n        else return 0;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2045851,
                "title": "python-stack",
                "content": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        \\n        if len(s)%3 !=0:\\n            return False\\n        stack = []\\n        letters = [\\'a\\',\\'b\\']\\n        \\n        for x in s:\\n            if x in letters:\\n                stack.append(x)\\n            else:\\n                if len(stack) == 0 or stack.pop()!=\\'b\\':\\n                    return False\\n                if len(stack) == 0 or stack.pop()!=\\'a\\':\\n                    return False\\n        return len(stack) == 0",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "class Solution:\\n    def isValid(self, s: str) -> bool:\\n        \\n        if len(s)%3 !=0:\\n            return False\\n        stack = []\\n        letters = [\\'a\\',\\'b\\']\\n        \\n        for x in s:\\n            if x in letters:\\n                stack.append(x)\\n            else:\\n                if len(stack) == 0 or stack.pop()!=\\'b\\':\\n                    return False\\n                if len(stack) == 0 or stack.pop()!=\\'a\\':\\n                    return False\\n        return len(stack) == 0",
                "codeTag": "Java"
            },
            {
                "id": 1997919,
                "title": "2-solutions-with-and-without-stack-short-and-concise-c",
                "content": "**Using Stack**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string str) {\\n        stack<char> s;\\n        \\n        for(char c : str) {\\n            if(c == \\'a\\') s.push(c);\\n            else if(c == \\'b\\') {\\n                if(s.empty() || s.top() != \\'a\\') return false;\\n                s.push(c);\\n            }\\n            else {\\n                if(s.empty() || s.top() != \\'b\\') return false;\\n                s.pop();\\n                s.pop();\\n            }\\n        }\\n        \\n        return s.empty();\\n    }\\n};\\n```\\n\\n**Without Stack**\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n       while(s.size()) {\\n           int p = s.find(\"abc\");\\n           if(p < 0 || p > s.size() - 1) return false;\\n           else s.erase(p, 3);\\n       }\\n       return true;    \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string str) {\\n        stack<char> s;\\n        \\n        for(char c : str) {\\n            if(c == \\'a\\') s.push(c);\\n            else if(c == \\'b\\') {\\n                if(s.empty() || s.top() != \\'a\\') return false;\\n                s.push(c);\\n            }\\n            else {\\n                if(s.empty() || s.top() != \\'b\\') return false;\\n                s.pop();\\n                s.pop();\\n            }\\n        }\\n        \\n        return s.empty();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n       while(s.size()) {\\n           int p = s.find(\"abc\");\\n           if(p < 0 || p > s.size() - 1) return false;\\n           else s.erase(p, 3);\\n       }\\n       return true;    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1904579,
                "title": "5ms-o-n-faster-than-99",
                "content": "```\\n\\t\\tint n=s.length()-1; // cal. length of string-1\\n\\t\\t//checking whether string ends with **a** or **b** or its length is not **multiple of 3** and\\n\\t\\t//return false if any of these condition becomes true\\n        if(s.charAt(n)==\\'a\\'||s.charAt(n)==\\'b\\'||(n+1)%3!=0)return false;\\n        Deque<Character> st=new ArrayDeque<>();\\n        for(char ch:s.toCharArray()){\\n\\t\\t//putting characters in stack if they are a or b (just think about the concept of \\n\\t\\t//balanced paranthesis)\\n            if(ch==\\'a\\'||ch==\\'b\\') st.push(ch);\\n            else{\\n\\t\\t\\t//here we can see that if we encounter c then it means the top of stack has to be \\n\\t\\t\\t//**b** and after that **a** and if any of this is not true then just return false \\n\\t\\t\\t//otherwise pop two characters from stack and move on to next character\\n                if(st.isEmpty()||st.pop()==\\'a\\') return false;\\n                if(st.isEmpty()||st.pop()==\\'b\\') return false;\\n            }\\n        }\\n        return true;\\n```",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\n\\t\\tint n=s.length()-1; // cal. length of string-1\\n\\t\\t//checking whether string ends with **a** or **b** or its length is not **multiple of 3** and\\n\\t\\t//return false if any of these condition becomes true\\n        if(s.charAt(n)==\\'a\\'||s.charAt(n)==\\'b\\'||(n+1)%3!=0)return false;\\n        Deque<Character> st=new ArrayDeque<>();\\n        for(char ch:s.toCharArray()){\\n\\t\\t//putting characters in stack if they are a or b (just think about the concept of \\n\\t\\t//balanced paranthesis)\\n            if(ch==\\'a\\'||ch==\\'b\\') st.push(ch);\\n            else{\\n\\t\\t\\t//here we can see that if we encounter c then it means the top of stack has to be \\n\\t\\t\\t//**b** and after that **a** and if any of this is not true then just return false \\n\\t\\t\\t//otherwise pop two characters from stack and move on to next character\\n                if(st.isEmpty()||st.pop()==\\'a\\') return false;\\n                if(st.isEmpty()||st.pop()==\\'b\\') return false;\\n            }\\n        }\\n        return true;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1849841,
                "title": "c-solution-using-stack",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(char c:s){\\n            if( c != \\'c\\')\\n                st.push(c);\\n            else{\\n                string t = \"\";\\n                if(st.size() > 1){\\n                    t += st.top();  st.pop();\\n                    t += st.top();  st.pop();\\n                }\\n                if(t != \"ba\")\\n                    return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(char c:s){\\n            if( c != \\'c\\')\\n                st.push(c);\\n            else{\\n                string t = \"\";\\n                if(st.size() > 1){\\n                    t += st.top();  st.pop();\\n                    t += st.top();  st.pop();\\n                }\\n                if(t != \"ba\")\\n                    return false;\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1843907,
                "title": "beginner-friendly-solution-c",
                "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char>st;\\n        string str; //declare a string\\n        for(int i=0;i<s.length();i++)\\n        {\\n            st.push(s[i]);\\n            if(s[i]==\\'c\\')  // check when the c is inserted into the stack\\n            {\\n                int k=3;\\n                while(k--){\\n                if(st.empty())\\n                    break;\\n                char ch=st.top();\\n                st.pop();\\n                str+=ch;\\n                }\\n                cout<<str<<\"\\\\n\";\\n                if(str!=\"cba\")\\n                    return false;\\n                str.clear();       //clear after every check\\n            }\\n        }\\n        if(st.empty())\\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char>st;\\n        string str; //declare a string\\n        for(int i=0;i<s.length();i++)\\n        {\\n            st.push(s[i]);\\n            if(s[i]==\\'c\\')  // check when the c is inserted into the stack\\n            {\\n                int k=3;\\n                while(k--){\\n                if(st.empty())\\n                    break;\\n                char ch=st.top();\\n                st.pop();\\n                str+=ch;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1831206,
                "title": "recursive-easy-c-beginner-friendly",
                "content": "```\\nbool isValid(string s) {\\n        int n = s.length();\\n        int index = s.find(\"abc\");\\n        \\n        if (s == \"abc\")\\n            return true;\\n        \\n        if (index == -1)\\n            return false;\\n        \\n        return isValid(s.substr(0, index)+s.substr(index+3));\\n        \\n    }",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nbool isValid(string s) {\\n        int n = s.length();\\n        int index = s.find(\"abc\");\\n        \\n        if (s == \"abc\")\\n            return true;\\n        \\n        if (index == -1)\\n            return false;\\n        \\n        return isValid(s.substr(0, index)+s.substr(index+3));\\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1800316,
                "title": "c-time-o-n-space-o-1-easy-simple-solution",
                "content": "**Intuition**\\n`j` is read pointer and `i` is write pointer. We always write `s[j]` to `s[i]`.\\nIf the last 3 characters in front of `i` is `\"abc\"`, we clean them by `i -= 3`.\\nIn the end, return `i == 0`.\\n**Code**\\n```\\nclass Solution {\\npublic:\\n\\tbool isValid(string s) {\\n\\t\\tint i = 0;\\n\\t\\tint j = 0;\\n\\t\\tint n = s.size();\\n\\t\\twhile (j < n)\\n\\t\\t{\\n\\t\\t\\ts[i] = s[j];\\n\\t\\t\\t// checking is last three character is \"abc\" then we erase them means set i to i-3\\n\\t\\t\\tif (i >= 2 && s[i - 2] == \\'a\\' && s[i - 1] == \\'b\\' && s[i] == \\'c\\')\\n\\t\\t\\t{\\n\\t\\t\\t\\ti -= 3;\\n\\t\\t\\t}\\n\\t\\t\\ti++; j++;\\n\\t\\t}\\n\\t\\treturn (i == 0);\\n\\t}\\n};\\n```\\n**Time Complexity : O(n)**\\n**Space Complexity : O(1)**\\n\\n**If find Helpful *Upvote It* \\uD83D\\uDC4D**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\tbool isValid(string s) {\\n\\t\\tint i = 0;\\n\\t\\tint j = 0;\\n\\t\\tint n = s.size();\\n\\t\\twhile (j < n)\\n\\t\\t{\\n\\t\\t\\ts[i] = s[j];\\n\\t\\t\\t// checking is last three character is \"abc\" then we erase them means set i to i-3\\n\\t\\t\\tif (i >= 2 && s[i - 2] == \\'a\\' && s[i - 1] == \\'b\\' && s[i] == \\'c\\')\\n\\t\\t\\t{\\n\\t\\t\\t\\ti -= 3;\\n\\t\\t\\t}\\n\\t\\t\\ti++; j++;\\n\\t\\t}\\n\\t\\treturn (i == 0);\\n\\t}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1793602,
                "title": "98-67-lesser-memory-only-3-lines-of-code-very-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while(\"abc\" in s): \\n            s = s.replace(\"abc\",\"\") # continuously replace \"abc\" by \"\". By the end if we end up with \"\", then the word is valid.\\n        return s == \"\"\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while(\"abc\" in s): \\n            s = s.replace(\"abc\",\"\") # continuously replace \"abc\" by \"\". By the end if we end up with \"\", then the word is valid.\\n        return s == \"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732646,
                "title": "c-easy-to-understand-stack-usage-2-approaches-o-1-space-complexity",
                "content": "**Approach 1 \\nO(n) time complexity\\nO(n) space complexity**\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n      stack<char> st;\\n        for(char &ch:s)\\n        {\\n          if(ch==\\'c\\')\\n          {\\n              if(st.size()<2)\\n              {\\n                  return false;\\n              }\\n              else\\n              {\\n                  char c1=st.top();\\n                  if(c1!=\\'b\\')\\n                  {\\n                      return false;\\n                  }\\n                  st.pop();\\n                  char c2=st.top();\\n                  if(c2!=\\'a\\')\\n                  {\\n                      return false;\\n                  }\\n                  st.pop();\\n              }\\n          }\\n          else\\n          {\\n              st.push(ch);\\n          }\\n        }\\n        return st.empty();\\n    }\\n};\\n```\\n**Approach 2\\nO(n) time complexity\\nO(1) space complexity**\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n=s.size();\\n        int j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            s[j++]=s[i];\\n            if(j>=3&&s[j-1]==\\'c\\'&&s[j-2]==\\'b\\'&&s[j-3]==\\'a\\')\\n            {\\n                j-=3;\\n            }\\n        }\\n        return j==0;\\n    }\\n};\\n```\\n**Please upvote to motivate me in my quest of documenting all leetcode solutions(to help the community). HAPPY CODING:)\\nAny suggestions and improvements are always welcome**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n      stack<char> st;\\n        for(char &ch:s)\\n        {\\n          if(ch==\\'c\\')\\n          {\\n              if(st.size()<2)\\n              {\\n                  return false;\\n              }\\n              else\\n              {\\n                  char c1=st.top();\\n                  if(c1!=\\'b\\')\\n                  {\\n                      return false;\\n                  }\\n                  st.pop();\\n                  char c2=st.top();\\n                  if(c2!=\\'a\\')\\n                  {\\n                      return false;\\n                  }\\n                  st.pop();\\n              }\\n          }\\n          else\\n          {\\n              st.push(ch);\\n          }\\n        }\\n        return st.empty();\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n=s.size();\\n        int j=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            s[j++]=s[i];\\n            if(j>=3&&s[j-1]==\\'c\\'&&s[j-2]==\\'b\\'&&s[j-3]==\\'a\\')\\n            {\\n                j-=3;\\n            }\\n        }\\n        return j==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1645671,
                "title": "check-if-word-is-valid-after-substitutions",
                "content": "```\\nclass Solution:\\n    def isValid(self, s):\\n        while \"abc\" in s:\\n            s = s.split(\"abc\")\\n            s = \"\".join(s)\\n            \\n        return len(s)==0\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s):\\n        while \"abc\" in s:\\n            s = s.split(\"abc\")\\n            s = \"\".join(s)\\n            \\n        return len(s)==0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1642146,
                "title": "python-3-lines-of-code-99-faster",
                "content": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        if len(s) == 0: return True\\n        if \"abc\" in s: return self.isValid(s.replace(\"abc\", \"\"))\\n        return False\\n```",
                "solutionTags": [
                    "Backtracking",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        if len(s) == 0: return True\\n        if \"abc\" in s: return self.isValid(s.replace(\"abc\", \"\"))\\n        return False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1596490,
                "title": "java-2-solutions",
                "content": "Using a stack:\\n\\n```java\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> characters = new Stack();\\n        \\n        for(int i = 0; i < s.length(); ++i) {\\n            if(s.charAt(i) == \\'c\\') {\\n                if(characters.isEmpty() || characters.pop() != \\'b\\' || characters.isEmpty() || characters.pop() != \\'a\\')\\n                    return false;\\n            } else {\\n                characters.push(s.charAt(i));\\n            }\\n        }\\n        \\n        return characters.isEmpty();\\n    }\\n}\\n```\\n\\nWithout a stack:\\n\\n```java\\nclass Solution {\\n    public boolean isValid(String s) {\\n        while(s.contains(\"abc\"))\\n            s = s.replace(\"abc\", \"\");\\n        \\n        return s.length() == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> characters = new Stack();\\n        \\n        for(int i = 0; i < s.length(); ++i) {\\n            if(s.charAt(i) == \\'c\\') {\\n                if(characters.isEmpty() || characters.pop() != \\'b\\' || characters.isEmpty() || characters.pop() != \\'a\\')\\n                    return false;\\n            } else {\\n                characters.push(s.charAt(i));\\n            }\\n        }\\n        \\n        return characters.isEmpty();\\n    }\\n}\\n```\n```java\\nclass Solution {\\n    public boolean isValid(String s) {\\n        while(s.contains(\"abc\"))\\n            s = s.replace(\"abc\", \"\");\\n        \\n        return s.length() == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575456,
                "title": "c-8ms-98-simple-easy-small-stack",
                "content": "Runtime: 8 ms, faster than 98.37% of C++ online submissions for Check If Word Is Valid After Substitutions.\\nMemory Usage: 8.2 MB, less than 86.71% of C++ online submissions for Check If Word Is Valid After Substitutions.\\n```\\nclass Solution {\\npublic:\\n  bool isValid(string s) {\\n    vector<char>st;\\n    \\n    for(auto &ch : s)\\n      if(ch == \\'c\\'){\\n        if(st.empty() || st.back() == \\'a\\') return false;\\n        st.pop_back();\\n        if(st.empty() || st.back() == \\'b\\') return false;\\n        st.pop_back();\\n      }else st.push_back(ch);\\n    \\n    return st.empty();\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool isValid(string s) {\\n    vector<char>st;\\n    \\n    for(auto &ch : s)\\n      if(ch == \\'c\\'){\\n        if(st.empty() || st.back() == \\'a\\') return false;\\n        st.pop_back();\\n        if(st.empty() || st.back() == \\'b\\') return false;\\n        st.pop_back();\\n      }else st.push_back(ch);\\n    \\n    return st.empty();\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1510597,
                "title": "java-stack-o-n-time-and-o-n-space",
                "content": "This is a modified version of balanced paranthesis problem. For every \\'a\\', there should be \\'bc\\' after it.\\n\\n```\\nclass Solution \\n{\\n    public boolean isValid(String s) \\n    {\\n        Stack<Character> st = new Stack<>();\\n        for(char c: s.toCharArray())\\n        {\\n            if(c==\\'a\\' || c==\\'b\\')\\n                st.push(c);\\n            else\\n            {\\n                if(!st.isEmpty() && st.peek()==\\'b\\')\\n                {\\n                    char ch = st.pop();\\n                    if(!st.isEmpty() && st.peek()==\\'a\\')\\n                        st.pop();\\n                    else\\n                        st.push(ch);\\n                }\\n                else\\n                    st.push(c);\\n            }\\n        }\\n        return st.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public boolean isValid(String s) \\n    {\\n        Stack<Character> st = new Stack<>();\\n        for(char c: s.toCharArray())\\n        {\\n            if(c==\\'a\\' || c==\\'b\\')\\n                st.push(c);\\n            else\\n            {\\n                if(!st.isEmpty() && st.peek()==\\'b\\')\\n                {\\n                    char ch = st.pop();\\n                    if(!st.isEmpty() && st.peek()==\\'a\\')\\n                        st.pop();\\n                    else\\n                        st.push(ch);\\n                }\\n                else\\n                    st.push(c);\\n            }\\n        }\\n        return st.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1501769,
                "title": "2-lines-code-beats-96",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        while ((s = s.replace(\"abc\", \"\")).contains(\"abc\")) {}\\n        return s.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        while ((s = s.replace(\"abc\", \"\")).contains(\"abc\")) {}\\n        return s.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1476772,
                "title": "java-easy-to-understand-using-stack-hashmap",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        \\n        Stack<Character> st = new Stack<>();\\n        Map<Character,Integer> map = new HashMap<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(ch == \\'a\\' || ch == \\'b\\')\\n                st.push(ch);\\n            else\\n            {\\n                if(st.size() <= 1)\\n                    return false;\\n                else{\\n                    char b = st.pop();\\n                    char a = st.pop();\\n                    if(a != \\'a\\' || b != \\'b\\')\\n                        return false;\\n                }\\n            }\\n            if(map.containsKey(ch))\\n                    map.put(ch,map.get(ch)+1);\\n                else    map.put(ch,1);\\n        }\\n        int x=0;\\n        if(map.containsKey(\\'a\\') && map.size()>=3)\\n            x = map.get(\\'a\\');\\n        else return false;\\n        \\n        for(int i : map.values())\\n        {\\n            if(x!=i)\\n                return false;\\n        }\\n        \\n        return true ;\\n        \\n    }\\n}\\n```\\nPlease upvote if u find my code easy to understand",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        \\n        Stack<Character> st = new Stack<>();\\n        Map<Character,Integer> map = new HashMap<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            char ch = s.charAt(i);\\n            if(ch == \\'a\\' || ch == \\'b\\')\\n                st.push(ch);\\n            else\\n            {\\n                if(st.size() <= 1)\\n                    return false;\\n                else{\\n                    char b = st.pop();\\n                    char a = st.pop();\\n                    if(a != \\'a\\' || b != \\'b\\')\\n                        return false;\\n                }\\n            }\\n            if(map.containsKey(ch))\\n                    map.put(ch,map.get(ch)+1);\\n                else    map.put(ch,1);\\n        }\\n        int x=0;\\n        if(map.containsKey(\\'a\\') && map.size()>=3)\\n            x = map.get(\\'a\\');\\n        else return false;\\n        \\n        for(int i : map.values())\\n        {\\n            if(x!=i)\\n                return false;\\n        }\\n        \\n        return true ;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1378500,
                "title": "c-stack-solution",
                "content": "I recommend you solve Valid Parentheses first. Here\\'s the same idea.\\n``` \\nbool isValid(string s) {\\n        stack<char> st;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (!st.empty() && s[i] == \\'c\\') {\\n                if (!st.empty() && st.top() == \\'b\\') {\\n                    st.pop();\\n                } else {\\n                    return false;\\n                }\\n                if (!st.empty() && st.top() == \\'a\\') {\\n                    st.pop();\\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                st.push(s[i]);\\n            }\\n        }\\n        return st.empty();\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "``` \\nbool isValid(string s) {\\n        stack<char> st;\\n        for (int i = 0; i < s.size(); ++i) {\\n            if (!st.empty() && s[i] == \\'c\\') {\\n                if (!st.empty() && st.top() == \\'b\\') {\\n                    st.pop();\\n                } else {\\n                    return false;\\n                }\\n                if (!st.empty() && st.top() == \\'a\\') {\\n                    st.pop();\\n                } else {\\n                    return false;\\n                }\\n            } else {\\n                st.push(s[i]);\\n            }\\n        }\\n        return st.empty();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1354243,
                "title": "short-java-solution-o-n",
                "content": "traverse from end and while \\'a\\' comes pop \\'b\\' and \\'c\\' respectively\\n\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        for(int i=s.length()-1;i>=0;--i){\\n            char temp=s.charAt(i);\\n            if(temp==\\'a\\'){\\n                if(stack.isEmpty() || stack.peek()!=\\'b\\') return false;\\n                stack.pop();\\n                if(stack.isEmpty() || stack.peek()!=\\'c\\') return false;\\n                stack.pop();\\n            }\\n            else stack.push(temp);\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack=new Stack<>();\\n        for(int i=s.length()-1;i>=0;--i){\\n            char temp=s.charAt(i);\\n            if(temp==\\'a\\'){\\n                if(stack.isEmpty() || stack.peek()!=\\'b\\') return false;\\n                stack.pop();\\n                if(stack.isEmpty() || stack.peek()!=\\'c\\') return false;\\n                stack.pop();\\n            }\\n            else stack.push(temp);\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1339139,
                "title": "java-easy",
                "content": "class Solution {\\n    public boolean isValid(String s) {\\n        \\n         if(s.equals(\"abc\")) return true;\\n        \\n         Stack<Character> st = new Stack<>();\\n    \\n         for(int i = 0 ; i < s.length();i++){\\n         char ch = s.charAt(i);\\n        \\n         if(ch == \\'c\\'){\\n            if(st.size()>= 2 && st.pop() == \\'b\\' && st.pop() == \\'a\\'){\\n                \\n            }else{\\n                return false;\\n            }\\n        }else{\\n            st.push(ch);\\n        }\\n        \\n    }\\n\\n        return st.size() == 0;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public boolean isValid(String s) {\\n        \\n         if(s.equals(\"abc\")) return true;\\n        \\n         Stack<Character> st = new Stack<>();\\n    \\n         for(int i = 0 ; i < s.length();i++){\\n         char ch = s.charAt(i);\\n        \\n         if(ch == \\'c\\'){\\n            if(st.size()>= 2 && st.pop() == \\'b\\' && st.pop() == \\'a\\'){\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1283339,
                "title": "5-line-c-code-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(char c: s){\\n            if(c==\\'c\\' && st.size()>1){\\n                if(st.top()==\\'b\\') st.pop();\\n                else return false;\\n                if(st.top()==\\'a\\') st.pop();\\n                else return false;\\n            }\\n            else st.push(c);\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st;\\n        for(char c: s){\\n            if(c==\\'c\\' && st.size()>1){\\n                if(st.top()==\\'b\\') st.pop();\\n                else return false;\\n                if(st.top()==\\'a\\') st.pop();\\n                else return false;\\n            }\\n            else st.push(c);\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281013,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n\\n        //push the a and b into the stack\\n        //when ever you get c  make sure you have b at the top and next a\\n        //if not return false;\\n        stack<char> stk;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' || s[i]==\\'b\\')\\n                stk.push(s[i]);\\n            else \\n            {\\n                //if it is a \\'c\\'\\n                if(stk.size()<2)\\n                    return false;\\n                if(stk.top()!=\\'b\\')\\n                    return false;\\n                stk.pop();\\n                if(stk.top()!=\\'a\\')\\n                    return false;\\n                stk.pop();\\n                \\n            }\\n        }\\n        return (stk.empty());\\n    }\\n};\\n```\\n**Upvote if this helps you :)**",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n\\n        //push the a and b into the stack\\n        //when ever you get c  make sure you have b at the top and next a\\n        //if not return false;\\n        stack<char> stk;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]==\\'a\\' || s[i]==\\'b\\')\\n                stk.push(s[i]);\\n            else \\n            {\\n                //if it is a \\'c\\'\\n                if(stk.size()<2)\\n                    return false;\\n                if(stk.top()!=\\'b\\')\\n                    return false;\\n                stk.pop();\\n                if(stk.top()!=\\'a\\')\\n                    return false;\\n                stk.pop();\\n                \\n            }\\n        }\\n        return (stk.empty());\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1271956,
                "title": "very-easy-code-using-stack",
                "content": "Here any time if we see abc sequence we will simply pop it from the stack\\nand at the end if the stack becomes empty we will return true else false\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n        \\n        for(int i =0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch==\\'c\\'){\\n                if(st.size()>=2  && st.pop()==\\'b\\' && st.pop()==\\'a\\'){\\n                    //paired\\n                }else{\\n                    return false;\\n                }\\n            }else{\\n                st.push(ch);\\n            }\\n        }\\n        return st.size()==0;\\n    }\\n}",
                "solutionTags": [
                    "Stack"
                ],
                "code": "class Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> st = new Stack<>();\\n        \\n        for(int i =0;i<s.length();i++){\\n            char ch = s.charAt(i);\\n            if(ch==\\'c\\'){\\n                if(st.size()>=2  && st.pop()==\\'b\\' && st.pop()==\\'a\\'){\\n                    //paired\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1260993,
                "title": "java-easy-stack",
                "content": "*This problem is literally a cake walk if you asssume that  by using the given string, if you are able to make a \"\" (blank string) of it than simply return true at last otherwise return false*\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n          Stack<Character> stack = new Stack<>();\\n          \\n          for(int i = 0 ; i<s.length() ; i++ ){\\n               if(s.charAt(i)==\\'c\\'){\\n                 if(stack.size() >=2 && stack.pop()==\\'b\\' && stack.peek()==\\'a\\'){\\n                      stack.pop();\\n                 }\\n                 else{\\n                      return false;\\n                 }\\n               }\\n               else{\\n                 stack.push(s.charAt(i));\\n               }\\n          }\\n      return stack.size() == 0 ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n          Stack<Character> stack = new Stack<>();\\n          \\n          for(int i = 0 ; i<s.length() ; i++ ){\\n               if(s.charAt(i)==\\'c\\'){\\n                 if(stack.size() >=2 && stack.pop()==\\'b\\' && stack.peek()==\\'a\\'){\\n                      stack.pop();\\n                 }\\n                 else{\\n                      return false;\\n                 }\\n               }\\n               else{\\n                 stack.push(s.charAt(i));\\n               }\\n          }\\n      return stack.size() == 0 ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1253192,
                "title": "c-simple-solution-using-stack-please-upvote-if-you-like",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n=s.length();\\n        stack<char> s1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                s1.push(s[i]);\\n            }\\n            else if(s[i]==\\'b\\')\\n            {\\n                if(s1.empty() || s1.top()!=\\'a\\')\\n                {\\n                    return false;\\n                }\\n                s1.push(s[i]);\\n            }\\n            else if(s[i]==\\'c\\')\\n            {\\n                if(s1.empty() || s1.top()!=\\'b\\')\\n                {\\n                    return false;\\n                }\\n                if(s1.top()==\\'b\\')\\n                {\\n                    s1.pop();\\n                    if(s1.empty() || s1.top()!=\\'a\\')\\n                    {\\n                        return false;\\n                    }\\n                    s1.pop();\\n                }\\n            }\\n        }\\n        if(s1.empty())\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n=s.length();\\n        stack<char> s1;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                s1.push(s[i]);\\n            }\\n            else if(s[i]==\\'b\\')\\n            {\\n                if(s1.empty() || s1.top()!=\\'a\\')\\n                {\\n                    return false;\\n                }\\n                s1.push(s[i]);\\n            }\\n            else if(s[i]==\\'c\\')\\n            {\\n                if(s1.empty() || s1.top()!=\\'b\\')\\n                {\\n                    return false;\\n                }\\n                if(s1.top()==\\'b\\')\\n                {\\n                    s1.pop();\\n                    if(s1.empty() || s1.top()!=\\'a\\')\\n                    {\\n                        return false;\\n                    }\\n                    s1.pop();\\n                }\\n            }\\n        }\\n        if(s1.empty())\\n            return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1249317,
                "title": "c-fastest-using-stack-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n  int n = s.size();\\n  if (n % 3 != 0)return false;\\n  stack<char> st;\\n\\n  for (int i = 0; i < n; i++) {\\n    if (s[i] != \\'c\\') {st.push(s[i]);}\\n    else {\\n        if(st.empty() || st.top()!=\\'b\\')return false;\\n      st.pop();\\n        if(st.empty() || st.top()!=\\'a\\')return false;\\n      st.pop();\\n    }\\n  }\\n\\n  if (st.empty())return true;\\n  else return false;\\n}\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n  int n = s.size();\\n  if (n % 3 != 0)return false;\\n  stack<char> st;\\n\\n  for (int i = 0; i < n; i++) {\\n    if (s[i] != \\'c\\') {st.push(s[i]);}\\n    else {\\n        if(st.empty() || st.top()!=\\'b\\')return false;\\n      st.pop();\\n        if(st.empty() || st.top()!=\\'a\\')return false;\\n      st.pop();\\n    }\\n  }\\n\\n  if (st.empty())return true;\\n  else return false;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1236791,
                "title": "c-fastest-solution-o-n-time-and-o-n-space",
                "content": "```\\nbool isValid(string s) {\\n        stack<char>st;\\n        \\n        for(char ch : s){\\n            if(!st.empty() && ch == \\'c\\'){\\n                char ch2 = st.top();\\n                st.pop();\\n                if(!st.empty() && ch2 == \\'b\\' && st.top() == \\'a\\')\\n                    st.pop();\\n                \\n                else{\\n                    st.push(ch2);\\n                    st.push(ch);\\n                }\\n            }\\n            \\n            else\\n                st.push(ch);\\n        }\\n        \\n        if(!st.empty())\\n            return false;\\n        \\n        return true;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nbool isValid(string s) {\\n        stack<char>st;\\n        \\n        for(char ch : s){\\n            if(!st.empty() && ch == \\'c\\'){\\n                char ch2 = st.top();\\n                st.pop();\\n                if(!st.empty() && ch2 == \\'b\\' && st.top() == \\'a\\')\\n                    st.pop();\\n                \\n                else{\\n                    st.push(ch2);\\n                    st.push(ch);\\n                }\\n            }\\n            \\n            else\\n                st.push(ch);\\n        }\\n        \\n        if(!st.empty())\\n            return false;\\n        \\n        return true;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1222134,
                "title": "java-solution-takes-6ms",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if(s == null || s.length() < 3 || s.charAt(0) != \\'a\\' || s.charAt(s.length()-1) != \\'c\\'){\\n            return false;\\n        }\\n        Stack<Character> stack = new Stack<>();\\n        for(char c:s.toCharArray()){\\n            if(c == \\'c\\'){\\n                if(stack.isEmpty() || stack.pop() != \\'b\\' || stack.isEmpty() || stack.pop() != \\'a\\'){\\n                    return false;\\n                }\\n                continue;\\n            }\\n            stack.push(c);\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if(s == null || s.length() < 3 || s.charAt(0) != \\'a\\' || s.charAt(s.length()-1) != \\'c\\'){\\n            return false;\\n        }\\n        Stack<Character> stack = new Stack<>();\\n        for(char c:s.toCharArray()){\\n            if(c == \\'c\\'){\\n                if(stack.isEmpty() || stack.pop() != \\'b\\' || stack.isEmpty() || stack.pop() != \\'a\\'){\\n                    return false;\\n                }\\n                continue;\\n            }\\n            stack.push(c);\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1166596,
                "title": "using-string-as-stack-and-stl-c",
                "content": "```\\nbool isValid(string s) {\\n        string s1=\"\";\\n        for(char ele:s)\\n        {\\n            if(ele==\\'c\\'&&s1.length()>1)\\n            {\\n                s1+=ele;\\n                if(s1.substr(s1.size()-3,3)==\"abc\")\\n                {\\n                    int k=3;\\n                    while(k--)\\n                        s1.pop_back();\\n                }\\n                continue;\\n            }\\n            s1+=ele;\\n        }\\n        return s1.size()==0;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\nbool isValid(string s) {\\n        string s1=\"\";\\n        for(char ele:s)\\n        {\\n            if(ele==\\'c\\'&&s1.length()>1)\\n            {\\n                s1+=ele;\\n                if(s1.substr(s1.size()-3,3)==\"abc\")\\n                {\\n                    int k=3;\\n                    while(k--)\\n                        s1.pop_back();\\n                }\\n                continue;\\n            }\\n            s1+=ele;\\n        }\\n        return s1.size()==0;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1120410,
                "title": "using-stack-is-slower-that-replace-6-vs-96-speed",
                "content": "I tried three different solutions: built-in replace, re.sub(), stack. The replace was faster than re.sub() and way faster than stack (24 ms, 28 ms, 240 ms)\\n\\nDoes anybody know why stack is slower than built-in replace?\\n\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while \"abc\" in s:\\n            s = s.replace(\"abc\", \"\")\\n        return not s\\n\\nfrom re import search, sub\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while search(r\"abc\", s):\\n            s = sub(\"abc\", \"\", s)\\n        return not s\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack = []\\n        for c in s:\\n            if (len(stack) > 2 and stack[-3] == \"a\" and stack[-2] == \"b\" and\\n                    stack[-1] == \"c\"):\\n                stack = stack[:-3]\\n            stack.append(c)\\n        return stack == [\\'a\\', \\'b\\', \\'c\\']\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while \"abc\" in s:\\n            s = s.replace(\"abc\", \"\")\\n        return not s\\n\\nfrom re import search, sub\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while search(r\"abc\", s):\\n            s = sub(\"abc\", \"\", s)\\n        return not s\\n\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        stack = []\\n        for c in s:\\n            if (len(stack) > 2 and stack[-3] == \"a\" and stack[-2] == \"b\" and\\n                    stack[-1] == \"c\"):\\n                stack = stack[:-3]\\n            stack.append(c)\\n        return stack == [\\'a\\', \\'b\\', \\'c\\']\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1104473,
                "title": "easiest-of-solutions-must-see-c",
                "content": "\\'\\'\\'\\n bool isValid(string s) {\\n\\n        int i =0;\\n        while(s.size()>3 and i<s.size())\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                if(s[i+1] == \\'b\\')\\n                {\\n                    if(s[i+2]==\\'c\\')\\n                    {\\n                        s.erase(s.begin() +i,s.begin()+i+3);\\n                        i=0;\\n                    }\\n                }\\n            }\\n            i++;\\n        }\\n        \\n        if(s ==  \"abc\")\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n\\'\\'\\'\\n",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n bool isValid(string s) {\\n\\n        int i =0;\\n        while(s.size()>3 and i<s.size())\\n        {\\n            if(s[i]==\\'a\\')\\n            {\\n                if(s[i+1] == \\'b\\')\\n                {\\n                    if(s[i+2]==\\'c\\')\\n                    {\\n                        s.erase(s.begin() +i,s.begin()+i+3);\\n                        i=0;\\n                    }\\n                }\\n            }\\n            i++;\\n        }\\n        \\n        if(s ==  \"abc\")\\n            return true;\\n        \\n        return false;\\n        \\n    }\\n\\'\\'\\'\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1061610,
                "title": "easy-to-understand-java-stack-implementation",
                "content": "```\\nclass Solution {\\n    \\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<Character>();\\n        for(char ch: s.toCharArray())\\n        {\\n            if(ch == \\'a\\' || ch == \\'b\\')\\n                stack.push(ch);\\n            else\\n            {\\n                if(stack.isEmpty() || stack.peek()!=\\'b\\')\\n                    return false;\\n                stack.pop();\\n                if(stack.isEmpty() || stack.peek()!=\\'a\\')\\n                    return false;\\n                stack.pop();\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<Character>();\\n        for(char ch: s.toCharArray())\\n        {\\n            if(ch == \\'a\\' || ch == \\'b\\')\\n                stack.push(ch);\\n            else\\n            {\\n                if(stack.isEmpty() || stack.peek()!=\\'b\\')\\n                    return false;\\n                stack.pop();\\n                if(stack.isEmpty() || stack.peek()!=\\'a\\')\\n                    return false;\\n                stack.pop();\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1057096,
                "title": "easy-and-fast-js-solution",
                "content": "```\\nvar isValid = function(s) {\\n    let subS = s.split(\\'abc\\').join(\\'\\');\\n    while(subS.length < s.length){\\n         s = subS;\\n         subS = s.split(\\'abc\\').join(\\'\\') ;\\n    }\\n    \\n    return s.length === 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar isValid = function(s) {\\n    let subS = s.split(\\'abc\\').join(\\'\\');\\n    while(subS.length < s.length){\\n         s = subS;\\n         subS = s.split(\\'abc\\').join(\\'\\') ;\\n    }\\n    \\n    return s.length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1053275,
                "title": "python-easy-solution",
                "content": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while len(s) != 0:\\n            s = s.replace(\\'abc\\', \\'\\')\\n            if (len(s) != 0) and (len(s) == len(s.replace(\\'abc\\', \\'\\'))):\\n                return False\\n        return True \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while len(s) != 0:\\n            s = s.replace(\\'abc\\', \\'\\')\\n            if (len(s) != 0) and (len(s) == len(s.replace(\\'abc\\', \\'\\'))):\\n                return False\\n        return True \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1050023,
                "title": "c-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        // Wipe out \\'abc\\' in s, and then wipe out \\'abc\\' in the new string, recursively doing this until there is\\n        // no more \\'abc\\' in the string. If the string is empty, return true, otherwise return false.\\n        if (s.empty())\\n        {\\n            return true;\\n        }\\n        \\n        if (s.find(\"abc\") == string::npos)\\n        {\\n            return false;\\n        }\\n        \\n        string res;\\n        int size = s.size();\\n        for (int i = 0; i < size;)\\n        {\\n            char c1 = s[i], c2 = i + 1 < size ? s[i + 1] : \\' \\';\\n            char c3 = i + 2 < size ? s[i + 2] : \\' \\';\\n            if (c1 == \\'a\\' && c2 == \\'b\\' && c3 == \\'c\\')\\n            {\\n                i += 3;\\n            }\\n            else\\n            {\\n                res += s[i];\\n                ++i;\\n            }\\n        }\\n        \\n        return isValid(res);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        // Wipe out \\'abc\\' in s, and then wipe out \\'abc\\' in the new string, recursively doing this until there is\\n        // no more \\'abc\\' in the string. If the string is empty, return true, otherwise return false.\\n        if (s.empty())\\n        {\\n            return true;\\n        }\\n        \\n        if (s.find(\"abc\") == string::npos)\\n        {\\n            return false;\\n        }\\n        \\n        string res;\\n        int size = s.size();\\n        for (int i = 0; i < size;)\\n        {\\n            char c1 = s[i], c2 = i + 1 < size ? s[i + 1] : \\' \\';\\n            char c3 = i + 2 < size ? s[i + 2] : \\' \\';\\n            if (c1 == \\'a\\' && c2 == \\'b\\' && c3 == \\'c\\')\\n            {\\n                i += 3;\\n            }\\n            else\\n            {\\n                res += s[i];\\n                ++i;\\n            }\\n        }\\n        \\n        return isValid(res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1033109,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    boolean flag=false;\\n    public boolean isValid(String s) {\\n        if(s.length()%3!=0)\\n            return false;\\n        reduce(s);\\n        return flag;\\n        \\n    }\\n    void reduce(String s)\\n    {\\n        if(s.equals(\"\"))\\n        {\\n            flag=true;\\n            return;\\n        }\\n        for(int i=0;i<s.length()-2;i++)\\n        {\\n            \\n            if(s.charAt(i)==\\'a\\'&&s.charAt(i+1)==\\'b\\'&&s.charAt(i+2)==\\'c\\')\\n            {\\n                 if(i+3<s.length())\\n                s=s.substring(0,i)+s.substring(i+3);\\n                else\\n                    s=s.substring(0,i);\\n                reduce(s);\\n                break;\\n               \\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    boolean flag=false;\\n    public boolean isValid(String s) {\\n        if(s.length()%3!=0)\\n            return false;\\n        reduce(s);\\n        return flag;\\n        \\n    }\\n    void reduce(String s)\\n    {\\n        if(s.equals(\"\"))\\n        {\\n            flag=true;\\n            return;\\n        }\\n        for(int i=0;i<s.length()-2;i++)\\n        {\\n            \\n            if(s.charAt(i)==\\'a\\'&&s.charAt(i+1)==\\'b\\'&&s.charAt(i+2)==\\'c\\')\\n            {\\n                 if(i+3<s.length())\\n                s=s.substring(0,i)+s.substring(i+3);\\n                else\\n                    s=s.substring(0,i);\\n                reduce(s);\\n                break;\\n               \\n            }\\n        }\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1007884,
                "title": "java-88-stack-with-detailed-comments",
                "content": "Summary: similar to checking valid parentheses with a stack, linear scan left to right, \\'a\\', \\'b\\' get pushed to the stack. \\'c\\' will try to pop \\'b\\', \\'a\\' from the stack, early return false if popping failed. Make sure stack is empty at the end. Linear space and time.\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if (s.length() % 3 != 0) return false; //small optimization\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s.toCharArray()){\\n            if (c != \\'c\\'){\\n                stack.push(c); //push \\'a\\', \\'b\\'\\n            } else {\\n                if (stack.size() < 2 || stack.pop() != \\'b\\' || stack.pop() != \\'a\\') return false; //try to pop \\'b\\', \\'a\\' in that order\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        if (s.length() % 3 != 0) return false; //small optimization\\n        Stack<Character> stack = new Stack<>();\\n        for (char c : s.toCharArray()){\\n            if (c != \\'c\\'){\\n                stack.push(c); //push \\'a\\', \\'b\\'\\n            } else {\\n                if (stack.size() < 2 || stack.pop() != \\'b\\' || stack.pop() != \\'a\\') return false; //try to pop \\'b\\', \\'a\\' in that order\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 902322,
                "title": "java-easy-to-understand",
                "content": "\\t public boolean isValid(String s) {\\n        String abc = \"abc\";\\n        StringBuilder builder = new StringBuilder();\\n        while(s.indexOf(abc) >= 0){\\n            builder = new StringBuilder();\\n            int index = s.indexOf(abc);\\n            builder.append(s.substring(0, index)).append(s.substring(index + 3));\\n            s = builder.toString();\\n        }\\n        return s.isEmpty();\\n    }",
                "solutionTags": [],
                "code": "\\t public boolean isValid(String s) {\\n        String abc = \"abc\";\\n        StringBuilder builder = new StringBuilder();\\n        while(s.indexOf(abc) >= 0){\\n            builder = new StringBuilder();\\n            int index = s.indexOf(abc);\\n            builder.append(s.substring(0, index)).append(s.substring(index + 3));\\n            s = builder.toString();\\n        }\\n        return s.isEmpty();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 890708,
                "title": "easy-c-solution-using-string-find",
                "content": "Just find \"abc\" and remove until there is no abc remains.Then check if string is empty return true otherwise return false.\\n\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        \\n        int startingPoint;\\n        while(s.length()!=0)\\n        {\\n            startingPoint=s.find(\"abc\");\\n            if(startingPoint==string::npos)\\n            {\\n                if(s.length()!=0)return false;\\n            }\\n            else\\n            {\\n            s.erase(startingPoint,3);\\n            }\\n            \\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        \\n        int startingPoint;\\n        while(s.length()!=0)\\n        {\\n            startingPoint=s.find(\"abc\");\\n            if(startingPoint==string::npos)\\n            {\\n                if(s.length()!=0)return false;\\n            }\\n            else\\n            {\\n            s.erase(startingPoint,3);\\n            }\\n            \\n        }\\n        \\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 882965,
                "title": "easy-c-solution-100-fast",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> S;\\n        for(char i:s){\\n            if(i==\\'c\\'){\\n                if(S.empty() || S.top()!=\\'b\\')return false;\\n                S.pop();\\n                if(S.empty() || S.top()!=\\'a\\')return false;\\n                S.pop();\\n            \\n            }else{\\n                S.push(i);\\n            }\\n        }\\n        if(!S.empty()) return false;\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> S;\\n        for(char i:s){\\n            if(i==\\'c\\'){\\n                if(S.empty() || S.top()!=\\'b\\')return false;\\n                S.pop();\\n                if(S.empty() || S.top()!=\\'a\\')return false;\\n                S.pop();\\n            \\n            }else{\\n                S.push(i);\\n            }\\n        }\\n        if(!S.empty()) return false;\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 824818,
                "title": "stack-c-simple-code-with-explanation",
                "content": "Whenever we encounter a \\'c\\' we check if the last two elements inserted in stack are \\'a\\' & \\'b\\'. If not return false. \\nThe logic behind this is that we will always have a \\'abc\\' string in input, after recursively removing \\'abc\\' from the string if we are left with an empty stack, then the string is valid. Otherwise its not.\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char>st;\\n        int n = s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.empty() || s[i]!=\\'c\\')\\n               st.push(s[i]);\\n            else if(s[i]==\\'c\\')\\n            {\\n                if(st.empty())\\n                    return false;\\n                char b = st.top();\\n                st.pop();\\n                if(st.empty())\\n                    return false;\\n                char a = st.top();\\n                if(a==\\'a\\' && b==\\'b\\')\\n                    st.pop();\\n                else return false;\\n            }\\n        }\\n        if(st.empty())\\n            return true;\\n        return false;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char>st;\\n        int n = s.length();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(st.empty() || s[i]!=\\'c\\')\\n               st.push(s[i]);\\n            else if(s[i]==\\'c\\')\\n            {\\n                if(st.empty())\\n                    return false;\\n                char b = st.top();\\n                st.pop();\\n                if(st.empty())\\n                    return false;\\n                char a = st.top();\\n                if(a==\\'a\\' && b==\\'b\\')\\n                    st.pop();\\n                else return false;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 824816,
                "title": "c-simple-stack-solution-o-n",
                "content": "If c comes you check the top 2 elements if they are not equal to a and b then return false or if the stack is empty or if in the end stack is not empty.\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]!=\\'c\\'){\\n                st.push(s[i]);\\n            }else{\\n                if(st.empty()){\\n                    return false;\\n                }\\n                char a;\\n                if(!st.empty()){\\n                    a=st.top();\\n                    st.pop();\\n                }\\n                if(st.empty() || st.top()!=\\'a\\' || a!=\\'b\\'){\\n                    return false;\\n                }else{\\n                    st.pop();\\n                }\\n            }\\n        }\\n        if(!st.empty()){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++){\\n            if(s[i]!=\\'c\\'){\\n                st.push(s[i]);\\n            }else{\\n                if(st.empty()){\\n                    return false;\\n                }\\n                char a;\\n                if(!st.empty()){\\n                    a=st.top();\\n                    st.pop();\\n                }\\n                if(st.empty() || st.top()!=\\'a\\' || a!=\\'b\\'){\\n                    return false;\\n                }else{\\n                    st.pop();\\n                }\\n            }\\n        }\\n        if(!st.empty()){\\n            return false;\\n        }\\n        return true;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 687050,
                "title": "using-repetitive-split-and-join",
                "content": "Here is my solution relying heavily on Python\\'s built-in string manipulation methods:\\nWe split an input string on valid string and join the remainder and repeat the split-join cycle until we get empty string, at the moment we don\\'t get a string split in at least 2, we return false.\\n```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        valid_str = \\'abc\\'\\n        while 1:\\n            split = S.split(valid_str)\\n            if len(split) == 1:\\n                return False\\n            S = \\'\\'.join(split)\\n            if S == \\'\\':\\n                return True\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        valid_str = \\'abc\\'\\n        while 1:\\n            split = S.split(valid_str)\\n            if len(split) == 1:\\n                return False\\n            S = \\'\\'.join(split)\\n            if S == \\'\\':\\n                return True\\n```",
                "codeTag": "Java"
            },
            {
                "id": 634612,
                "title": "python-simple",
                "content": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        stk = []\\n        for c in S:\\n            if c == \\'a\\' or c == \\'b\\':\\n                stk.append(c)\\n            if c == \\'c\\':\\n                if len(stk) < 2:\\n                    return False\\n                if stk[-2] != \\'a\\' or stk[-1] != \\'b\\':\\n                    return False\\n                stk.pop()\\n                stk.pop()\\n        return len(stk) == 0\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        stk = []\\n        for c in S:\\n            if c == \\'a\\' or c == \\'b\\':\\n                stk.append(c)\\n            if c == \\'c\\':\\n                if len(stk) < 2:\\n                    return False\\n                if stk[-2] != \\'a\\' or stk[-1] != \\'b\\':\\n                    return False\\n                stk.pop()\\n                stk.pop()\\n        return len(stk) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 593417,
                "title": "2-pointer-solution-o-n-time-o-1-space-very-few-lines-c-solution",
                "content": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n    \\n       int i = 0, n = s.length();\\n        for (int j = 0; j < n; ++j, ++i) {\\n            s[i] = s[j];\\n            if (i >1 && s[i - 1] == \\'b\\'&&s[i-2]==\\'a\\'&&s[i]==\\'c\\')\\n                i -= 3;\\n        }\\n        return !i;\\n\\n    }\\n};\\n",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "class Solution {\\npublic:\\n    bool isValid(string s) {\\n    \\n       int i = 0, n = s.length();\\n        for (int j = 0; j < n; ++j, ++i) {\\n            s[i] = s[j];\\n            if (i >1 && s[i - 1] == \\'b\\'&&s[i-2]==\\'a\\'&&s[i]==\\'c\\')\\n                i -= 3;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 577829,
                "title": "java-replace",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        if (S == null) return false;\\n        S = S.replaceAll(\"abc\", \"\");\\n        S = S.replace(\"abc\", \"\");\\n        return S.equals(\"abc\") || S.equals(\"\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        if (S == null) return false;\\n        S = S.replaceAll(\"abc\", \"\");\\n        S = S.replace(\"abc\", \"\");\\n        return S.equals(\"abc\") || S.equals(\"\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 570741,
                "title": "faster-than-98-02-of-python3-online-submissions",
                "content": "I proposed a string replace implementation algorithm which is faster than 98.02% Python3 submissions.\\n\\n```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        while \\'abc\\' in S:\\n            S = S.replace(\\'abc\\', \\'\\')\\n        return not S\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        while \\'abc\\' in S:\\n            S = S.replace(\\'abc\\', \\'\\')\\n        return not S\\n```",
                "codeTag": "Java"
            },
            {
                "id": 556413,
                "title": "java-easy-3-line-solution",
                "content": "Intuition : The String S is built this way : \"abc\" --> some transformations --> S. \\nWe can reverse engineer this, and removing \"abc\" repeatedly till we do not find any more \"abc\"s as substring. Every iteration step should lead us to another substring which has \"abc\" as a substring (As they are all of the form X + \"abc\" + Y). Now as X + Y in turn is \"abc\" itself, the end result for a valid string, thus, is an empty string.\\n```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        while(S.contains(\"abc\"))\\n            S = S.replace(\"abc\", \"\");\\n        return S.length() == 0;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        while(S.contains(\"abc\"))\\n            S = S.replace(\"abc\", \"\");\\n        return S.length() == 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 551732,
                "title": "python-3-solution-using-replace-and-stack",
                "content": "**Using replace()**\\n```python\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        while \\'abc\\' in S:\\n            S = S.replace(\\'abc\\',\\'\\',S.count(\\'abc\\'))\\n        return len(S)==0\\n```\\n\\n**Using Stack**\\n```python\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        stack = []\\n        for i in S:\\n            if i == \\'c\\':\\n                if stack[-2:] != [\\'a\\', \\'b\\']:\\n                    return False\\n                stack.pop()\\n                stack.pop()\\n            else:\\n                stack.append(i)\\n        return not stack",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        while \\'abc\\' in S:\\n            S = S.replace(\\'abc\\',\\'\\',S.count(\\'abc\\'))\\n        return len(S)==0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 534081,
                "title": "super-simple-javascript-solution",
                "content": "```\\n/**\\n * @param {string} S\\n * @return {boolean}\\n */\\nvar isValid = function(S) {\\n    while(S.indexOf(\\'abc\\')>=0) {\\n        S=S.split(\\'abc\\').join(\\'\\');\\n    }\\n    return S.length === 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} S\\n * @return {boolean}\\n */\\nvar isValid = function(S) {\\n    while(S.indexOf(\\'abc\\')>=0) {\\n        S=S.split(\\'abc\\').join(\\'\\');\\n    }\\n    return S.length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 506273,
                "title": "javascript-o-1",
                "content": "```\\n/**\\n * @param {string} S\\n * @return {boolean}\\n */\\nconst isValid = (S) => {\\n  let i = 0;\\n  const st = [];\\n  while (i < S.length) {\\n    const ch = S.charAt(i++);\\n    if (ch !== \\'c\\') {\\n        st.push(ch);\\n    } else {\\n      if (!(st.pop() === \\'b\\' && st.pop() === \\'a\\')) {\\n        return false;\\n      }        \\n    }\\n  }\\n\\n  return st.length === 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} S\\n * @return {boolean}\\n */\\nconst isValid = (S) => {\\n  let i = 0;\\n  const st = [];\\n  while (i < S.length) {\\n    const ch = S.charAt(i++);\\n    if (ch !== \\'c\\') {\\n        st.push(ch);\\n    } else {\\n      if (!(st.pop() === \\'b\\' && st.pop() === \\'a\\')) {\\n        return false;\\n      }        \\n    }\\n  }\\n\\n  return st.length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 459055,
                "title": "simple-java-solution-excellent-memory-usage-no-string-replacement-required",
                "content": "1 on top of stack -> a was last seen\\n2 on top of stack -> b was last seen\\nNo need to add 3 for \\'c\\' since \\'c\\' is the end of a block/region\\n\\n```\\n\\tpublic boolean isValid(String s) {\\n        \\n        if(s == null || s.isEmpty()) {\\n            return false;\\n        }\\n        \\n        s = s.toLowerCase();\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            char c = s.charAt(i);\\n            if(c == \\'a\\') {\\n                stack.push(1);\\n            }\\n            else if(c == \\'b\\') {\\n                if(stack.isEmpty() || stack.peek() != 1) {\\n                    return false;\\n                }\\n                stack.pop();\\n                stack.push(2);\\n            }\\n            else if(c == \\'c\\') {\\n                if(stack.isEmpty() || stack.peek() != 2) {\\n                    return false;\\n                }\\n                stack.pop();\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        \\n        return stack.isEmpty();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n\\tpublic boolean isValid(String s) {\\n        \\n        if(s == null || s.isEmpty()) {\\n            return false;\\n        }\\n        \\n        s = s.toLowerCase();\\n        \\n        Stack<Integer> stack = new Stack<>();\\n        for(int i=0; i<s.length(); i++) {\\n            char c = s.charAt(i);\\n            if(c == \\'a\\') {\\n                stack.push(1);\\n            }\\n            else if(c == \\'b\\') {\\n                if(stack.isEmpty() || stack.peek() != 1) {\\n                    return false;\\n                }\\n                stack.pop();\\n                stack.push(2);\\n            }\\n            else if(c == \\'c\\') {\\n                if(stack.isEmpty() || stack.peek() != 2) {\\n                    return false;\\n                }\\n                stack.pop();\\n            }\\n            else {\\n                return false;\\n            }\\n        }\\n        \\n        return stack.isEmpty();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 405645,
                "title": "simple-python",
                "content": "```\\nclass Solution(object):\\n    def isValid(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: bool\\n        \"\"\"\\n        stack = []\\n        \\n        for char in S:\\n            stack.append(char)\\n            \\n            if len(stack) >= 3 and stack[-3] + stack[-2] + stack[-1] == \\'abc\\':\\n                for i in range(3):\\n                    stack.pop()\\n            \\n        return not stack",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isValid(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: bool\\n        \"\"\"\\n        stack = []\\n        \\n        for char in S:\\n            stack.append(char)\\n            \\n            if len(stack) >= 3 and stack[-3] + stack[-2] + stack[-1] == \\'abc\\':\\n                for i in range(3):\\n                    stack.pop()\\n            \\n        return not stack",
                "codeTag": "Java"
            },
            {
                "id": 390642,
                "title": "python-3-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef isValid(self, S: str) -> bool:\\n\\t\\t\\twhile \"abc\" in S:\\n\\t\\t\\t\\tidx = S.index(\"abc\")\\n\\t\\t\\t\\tS = S[:idx] + S[idx + 3:]\\n\\t\\t\\treturn not S",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef isValid(self, S: str) -> bool:\\n\\t\\t\\twhile \"abc\" in S:\\n\\t\\t\\t\\tidx = S.index(\"abc\")\\n\\t\\t\\t\\tS = S[:idx] + S[idx + 3:]\\n\\t\\t\\treturn not S",
                "codeTag": "Java"
            },
            {
                "id": 384915,
                "title": "java-1-stringbuilder-indexof-delete-2-using-stack",
                "content": "```\\n    public boolean isValid(String S) {\\n        Stack<Character> stack = new Stack<Character>();\\n        for(char ch : S.toCharArray()){\\n            if(ch!=\\'c\\')\\n                stack.push(ch);\\n            else if(!stack.isEmpty() && stack.pop()==\\'b\\' && !stack.isEmpty() && stack.pop()==\\'a\\')\\n                continue;\\n            else\\n                return false;\\n\\n        }\\n\\n        return stack.isEmpty();\\n    }\\n```\\n```\\n    public boolean isValid(String S) {\\n        StringBuilder sb = new StringBuilder(S);\\n        while(true){\\n            int ind = sb.indexOf(\"abc\");\\n            if(ind < 0)\\n                break;\\n\\n            sb.delete(ind, ind+3);\\n        }\\n\\n        return sb.length()==0 ? true : false;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isValid(String S) {\\n        Stack<Character> stack = new Stack<Character>();\\n        for(char ch : S.toCharArray()){\\n            if(ch!=\\'c\\')\\n                stack.push(ch);\\n            else if(!stack.isEmpty() && stack.pop()==\\'b\\' && !stack.isEmpty() && stack.pop()==\\'a\\')\\n                continue;\\n            else\\n                return false;\\n\\n        }\\n\\n        return stack.isEmpty();\\n    }\\n```\n```\\n    public boolean isValid(String S) {\\n        StringBuilder sb = new StringBuilder(S);\\n        while(true){\\n            int ind = sb.indexOf(\"abc\");\\n            if(ind < 0)\\n                break;\\n\\n            sb.delete(ind, ind+3);\\n        }\\n\\n        return sb.length()==0 ? true : false;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 375441,
                "title": "python-100-solution-in-time-and-96-in-space",
                "content": "For Time\\n        while S.__contains__(\\'abc\\') and S:\\n            S = \\'\\'.join(S.split(\\'abc\\'))\\n        return False if S else True\\n\\t\\t\\nFor Space\\n\\t\\t        stack = []\\n        for ch in S:\\n            if ch in (\\'a\\', \\'b\\'):\\n                stack.append(ch)\\n            else:\\n                import pdb;\\n                pdb.set_trace()\\n                if not(len(stack)>=2 and stack.pop()== \\'b\\' and stack.pop() == \\'a\\'):\\n                    return False\\n        return False if stack else True",
                "solutionTags": [],
                "code": "For Time\\n        while S.__contains__(\\'abc\\') and S:\\n            S = \\'\\'.join(S.split(\\'abc\\'))\\n        return False if S else True\\n\\t\\t\\nFor Space\\n\\t\\t        stack = []\\n        for ch in S:\\n            if ch in (\\'a\\', \\'b\\'):\\n                stack.append(ch)\\n            else:\\n                import pdb;\\n                pdb.set_trace()\\n                if not(len(stack)>=2 and stack.pop()== \\'b\\' and stack.pop() == \\'a\\'):\\n                    return False\\n        return False if stack else True",
                "codeTag": "Python3"
            },
            {
                "id": 352625,
                "title": "python-stack",
                "content": "```python\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        \\n        N = len(S)\\n        if N % 3 or N == 0:\\n            return False\\n        \\n        arr = [None] * N\\n        arri = 0\\n        for c in S:\\n            arr[arri] = c\\n            arri += 1\\n            if arri >= 3 and arr[arri-3] == \\'a\\' and arr[arri-2] == \\'b\\' and arr[arri-1] == \\'c\\':\\n                arri -= 3\\n        return arri == 0\\n```\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        \\n        N = len(S)\\n        if N % 3 or N == 0:\\n            return False\\n        \\n        arr = [None] * N\\n        arri = 0\\n        for c in S:\\n            arr[arri] = c\\n            arri += 1\\n            if arri >= 3 and arr[arri-3] == \\'a\\' and arr[arri-2] == \\'b\\' and arr[arri-1] == \\'c\\':\\n                arri -= 3\\n        return arri == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 335431,
                "title": "3-lines-c",
                "content": "```\\npublic bool IsValid(string S)\\n{\\n\\twhile (S.Contains(\"abc\"))\\n\\t\\tS = S.Replace(\"abc\", \"\");\\n\\treturn S.Length == 0;\\n}",
                "solutionTags": [],
                "code": "```\\npublic bool IsValid(string S)\\n{\\n\\twhile (S.Contains(\"abc\"))\\n\\t\\tS = S.Replace(\"abc\", \"\");\\n\\treturn S.Length == 0;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 319907,
                "title": "3-lines-python3-solution",
                "content": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        while S and \\'abc\\' in S:\\n            S = re.sub(\\'abc\\', \\'\\', S)\\n        return not S\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        while S and \\'abc\\' in S:\\n            S = re.sub(\\'abc\\', \\'\\', S)\\n        return not S\\n```",
                "codeTag": "Java"
            },
            {
                "id": 307447,
                "title": "very-simple-regex-solution",
                "content": "It\\'s more of a hack than a valid interview solution; but oh well. :D\\n```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        if (S == null) return false;\\n        while (S.contains(\"abc\")) {\\n            S = S.replaceAll(\"abc\", \"\");\\n        }\\n        return S.isEmpty();\\n    } \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        if (S == null) return false;\\n        while (S.contains(\"abc\")) {\\n            S = S.replaceAll(\"abc\", \"\");\\n        }\\n        return S.isEmpty();\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 279868,
                "title": "5-line-super-simple-java-solution",
                "content": "The idea is that if the string contains \"abc\" then it will keep replacing \"abc\" with \"\" until the replacing operation cannot be done. Hope this helps! :)\\n```\\n    public boolean isValid(String S) {\\n        while(S.contains(\"abc\")){\\n            S = S.replace(\"abc\",\"\");\\n            if(S.equals(\"\"))\\n                return true;\\n        }return false;\\n    }",
                "solutionTags": [],
                "code": "The idea is that if the string contains \"abc\" then it will keep replacing \"abc\" with \"\" until the replacing operation cannot be done. Hope this helps! :)\\n```\\n    public boolean isValid(String S) {\\n        while(S.contains(\"abc\")){\\n            S = S.replace(\"abc\",\"\");\\n            if(S.equals(\"\"))\\n                return true;\\n        }return false;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 266825,
                "title": "c-constant-space-simple-with-explanation",
                "content": "The idea is simple, if a ``Word`` is valid after substitution, then erasing substring ``\"abc\"`` each time to either **empty string** OR ``\"abc\"`` substr.\\nAt each iteration, I am deleting substr ``\"abc\"``.\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string S) {\\n        if(S.empty()) return false;\\n        if(S==\"abc\") return true;\\n        while(!S.empty()){\\n            size_t f = S.find(\"abc\");\\n            if(f==std::string::npos) return false; // no \"abc\" substr\\n            S.erase(S.begin()+f,S.begin()+f+3);    // remove \"abc\"\\n            if(S==\"abc\") return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string S) {\\n        if(S.empty()) return false;\\n        if(S==\"abc\") return true;\\n        while(!S.empty()){\\n            size_t f = S.find(\"abc\");\\n            if(f==std::string::npos) return false; // no \"abc\" substr\\n            S.erase(S.begin()+f,S.begin()+f+3);    // remove \"abc\"\\n            if(S==\"abc\") return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 265113,
                "title": "c-easy-solution-beat-99-using-recursive",
                "content": "```\\n#pragma GCC optimize(\"Ofast\")\\n#pragma GCC target(\"avx,avx2,fma\")\\nstatic const int _ = [](){\\n\\tios::sync_with_stdio(false);\\n\\tcin.sync_with_stdio(false);\\n\\tcout.sync_with_stdio(false);\\n\\tcin.tie(nullptr);\\n\\tcout.tie(nullptr);\\n\\treturn 0;\\n}();\\n\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s == \"\") return true;\\n        if(s.size() < 3) return false;\\n        \\n        bool ans = false;\\n        size_t pos = s.find(\"abc\", 0);\\n        size_t i = 0, diff = 0;\\n        if(pos == string::npos) return ans;\\n        \\n        string helper;\\n        \\n        for(; pos != string::npos ; pos = s.find(\"abc\", i)) {\\n        \\t//cout << \"i: \" << i << \" pos: \" << pos << endl;\\n        \\tif(pos != i) {\\n        \\t\\tdiff = pos - i;\\n        \\t\\thelper += s.substr(i, diff);\\n        \\t\\t//cout << \"helper: \" << helper << endl;\\n\\t\\t\\t}\\n        \\tpos += 2;\\n        \\ti = pos + 1;\\n\\t\\t}\\n        \\n        diff = s.size() - i;\\n        helper += s.substr(i, diff);\\n        //cout << \"last helper: \" << helper << endl;\\n        \\n        if(isValid(helper))\\n        \\tans = true;\\n        \\t\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#pragma GCC optimize(\"Ofast\")\\n#pragma GCC target(\"avx,avx2,fma\")\\nstatic const int _ = [](){\\n\\tios::sync_with_stdio(false);\\n\\tcin.sync_with_stdio(false);\\n\\tcout.sync_with_stdio(false);\\n\\tcin.tie(nullptr);\\n\\tcout.tie(nullptr);\\n\\treturn 0;\\n}();\\n\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s == \"\") return true;\\n        if(s.size() < 3) return false;\\n        \\n        bool ans = false;\\n        size_t pos = s.find(\"abc\", 0);\\n        size_t i = 0, diff = 0;\\n        if(pos == string::npos) return ans;\\n        \\n        string helper;\\n        \\n        for(; pos != string::npos ; pos = s.find(\"abc\", i)) {\\n        \\t//cout << \"i: \" << i << \" pos: \" << pos << endl;\\n        \\tif(pos != i) {\\n        \\t\\tdiff = pos - i;\\n        \\t\\thelper += s.substr(i, diff);\\n        \\t\\t//cout << \"helper: \" << helper << endl;\\n\\t\\t\\t}\\n        \\tpos += 2;\\n        \\ti = pos + 1;\\n\\t\\t}\\n        \\n        diff = s.size() - i;\\n        helper += s.substr(i, diff);\\n        //cout << \"last helper: \" << helper << endl;\\n        \\n        if(isValid(helper))\\n        \\tans = true;\\n        \\t\\n\\t\\treturn ans;\\n\\t}\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 254728,
                "title": "c-both-100-stack-o-n-time-space",
                "content": "```\\npublic bool IsValid(string S) {\\n        Stack<char> stack = new Stack<char>();\\n        foreach(char i in S){\\n            switch (i){\\n                case \\'a\\':\\n                    stack.Push(i);\\n                    break;\\n                case \\'b\\':\\n                    if(stack.Count == 0 || stack.Peek() == \\'c\\') return false;\\n                    stack.Push(i);\\n                    break;\\n                case \\'c\\':\\n                    if(stack.Count == 0 || stack.Peek() != \\'b\\') return false;\\n                    stack.Pop();\\n\\t\\t\\t\\t\\tif(stack.Count == 0 || stack.Peek() != \\'a\\') return false;\\n                    stack.Pop();\\n                    break;\\n            }\\n        }\\n        if(stack.Count > 0) return false;\\n        return true;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic bool IsValid(string S) {\\n        Stack<char> stack = new Stack<char>();\\n        foreach(char i in S){\\n            switch (i){\\n                case \\'a\\':\\n                    stack.Push(i);\\n                    break;\\n                case \\'b\\':\\n                    if(stack.Count == 0 || stack.Peek() == \\'c\\') return false;\\n                    stack.Push(i);\\n                    break;\\n                case \\'c\\':\\n                    if(stack.Count == 0 || stack.Peek() != \\'b\\') return false;\\n                    stack.Pop();\\n\\t\\t\\t\\t\\tif(stack.Count == 0 || stack.Peek() != \\'a\\') return false;\\n                    stack.Pop();\\n                    break;\\n            }\\n        }\\n        if(stack.Count > 0) return false;\\n        return true;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 253549,
                "title": "python-o-n-solution-with-idea-of-valid-parentheses",
                "content": "let\\'s think about how to slove [valid parentheses](https://leetcode.com/problems/valid-parentheses/), where \"(\" needs to follow by \")\"/\"(\". where if we have \")\" and the last element in the stack is \"(\" we can go ahead and remove it. \\n\\nif the stack is empty at the end then it is valid else not.\\n\\n----------------------\\n\"a\" can be treat as one kind of Parentheses where it closed by \"b\", and \"b\" close by \"c\".\\nif we find \"b\" and the last element in stack is \"a\", we can pop \"a\", where \"b\" should wait for it\\'s close patentheese \"c\". \\n\\n\\n\\n```\\nclass Solution(object):\\n    def isValid(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: bool\\n        \"\"\"\\n        if not S:\\n            return False\\n        s = []\\n        for char in S:\\n            if char == \"a\":\\n                s.append(char)\\n            if char == \"b\":\\n                if not s:\\n                    return False\\n                if s[-1] == \"a\":\\n                    s.pop()\\n                    s.append(char)\\n            if char == \"c\":\\n                if not s:\\n                    return False\\n                if s[-1] == \\'b\\':\\n                    s.pop()\\n        return len(s) == 0\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isValid(self, S):\\n        \"\"\"\\n        :type S: str\\n        :rtype: bool\\n        \"\"\"\\n        if not S:\\n            return False\\n        s = []\\n        for char in S:\\n            if char == \"a\":\\n                s.append(char)\\n            if char == \"b\":\\n                if not s:\\n                    return False\\n                if s[-1] == \"a\":\\n                    s.pop()\\n                    s.append(char)\\n            if char == \"c\":\\n                if not s:\\n                    return False\\n                if s[-1] == \\'b\\':\\n                    s.pop()\\n        return len(s) == 0\\n```",
                "codeTag": "Java"
            },
            {
                "id": 251273,
                "title": "simple-and-easy-to-understand-but-less-efficient",
                "content": "Basically, just keeps removing \"abc\" and check if the string can be empty after that.\\n\\n```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        while (S.contains(\"abc\")) {\\n            S = S.replace(\"abc\", \"\");\\n        }\\n        return S.length() == 0 ;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String S) {\\n        while (S.contains(\"abc\")) {\\n            S = S.replace(\"abc\", \"\");\\n        }\\n        return S.length() == 0 ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 249711,
                "title": "java-3-line-stack-solution-o-n-time-space",
                "content": "```\\n    public boolean isValid(String S) {\\n        Deque<Character> d = new ArrayDeque<Character>();\\n        for( char c : S.toCharArray() ) if( c!=\\'c\\' ) d.push(c); else if( d.isEmpty() || d.pop()!=\\'b\\' || d.isEmpty() || d.pop()!=\\'a\\' ) return false;\\n        return d.isEmpty();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public boolean isValid(String S) {\\n        Deque<Character> d = new ArrayDeque<Character>();\\n        for( char c : S.toCharArray() ) if( c!=\\'c\\' ) d.push(c); else if( d.isEmpty() || d.pop()!=\\'b\\' || d.isEmpty() || d.pop()!=\\'a\\' ) return false;\\n        return d.isEmpty();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 249412,
                "title": "c-simplest-solution-with-0-n-time-complexity-and-0-1-space-complexity",
                "content": "A count should always be higher or equal than b and c .\\nSimilarly B count should always be higher than c.\\nIf this condition doesnot hold true we will return false;\\nelse\\nif count of a ,b and c is equal than return true otherwise return false;\\n[class Solution {\\npublic:\\n    bool isValid(string S) {\\n        int n=S.length();\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<n;i++){\\n            if(S[i]==\\'a\\')a++;\\n            else if(S[i]==\\'b\\')b++;\\n            else if(S[i]==\\'c\\')c++;\\n            if(a<b||b<c||a<c){\\n                return 0;\\n            }\\n        }\\n        if(a==b&&a==c)return 1;\\n        return 0;\\n    }\\n};](http://)",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    bool isValid(string S) {\\n        int n=S.length();\\n        int a=0,b=0,c=0;\\n        for(int i=0;i<n;i++){\\n            if(S[i]==\\'a\\')a++;\\n            else if(S[i]==\\'b\\')b++;\\n            else if(S[i]==\\'c\\')c++;\\n            if(a<b||b<c||a<c){\\n                return 0;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 249287,
                "title": "java-super-easy-and-fast-o-n-solution-beats-100-time-and-100-space",
                "content": "```\\n    public boolean isValid(String S) {\\n        Stack<Character> stk=new Stack<>();\\n        for(int i=0;i<S.length();i++) {\\n            if(S.charAt(i)==\\'c\\'&&!stk.isEmpty()) {\\n                char tmp=stk.pop();\\n                if(!stk.isEmpty()&&tmp==\\'b\\'&&stk.peek()==\\'a\\') {\\n                    stk.pop();\\n                    continue;\\n                }\\n                else stk.push(tmp);\\n            }\\n            stk.push(S.charAt(i));\\n        } \\n        return stk.isEmpty();\\n    }",
                "solutionTags": [],
                "code": "```\\n    public boolean isValid(String S) {\\n        Stack<Character> stk=new Stack<>();\\n        for(int i=0;i<S.length();i++) {\\n            if(S.charAt(i)==\\'c\\'&&!stk.isEmpty()) {\\n                char tmp=stk.pop();\\n                if(!stk.isEmpty()&&tmp==\\'b\\'&&stk.peek()==\\'a\\') {\\n                    stk.pop();\\n                    continue;\\n                }\\n                else stk.push(tmp);\\n            }\\n            stk.push(S.charAt(i));\\n        } \\n        return stk.isEmpty();\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 248843,
                "title": "why-is-aabcbabcc-is-valid",
                "content": "The idea would be compare S to \\'abc\\' from left to right; remove any matched letter and continue this process until nothing can be matched; then try the other direction. If finally we go an empty string, then return True, otherwise False.\\n\\n```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        \"\"\"\\n        The idea would be compare S to \\'abc\\' from left to right; remove any matched letter and continue this process until nothing can be matched; then try the other direction. If finally we go an empty string, then return True, otherwise False.\\n        \"\"\"\\n        T = \\'abc\\'\\n        if S is None or len(S) < len(T):\\n            return False\\n        # matching from left first\\n        left = 0\\n        right = len(S)\\n        while left < right:\\n            i = 0\\n            while i < len(T) and left + i < right and S[left + i] == T[i]:\\n                i += 1\\n            if i == 0:\\n                # nothing can be matched from left any more\\n                break\\n            left += i\\n        while left < right:\\n            i = 0\\n            while i < len(T) and left + i < right and S[right - i - 1] == T[-i - 1]:\\n                i += 1\\n            if i == 0:\\n                # nothing can be matched from tight any more\\n                break\\n            right -= i\\n        return left >= right\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def isValid(self, S: str) -> bool:\\n        \"\"\"\\n        The idea would be compare S to \\'abc\\' from left to right; remove any matched letter and continue this process until nothing can be matched; then try the other direction. If finally we go an empty string, then return True, otherwise False.\\n        \"\"\"\\n        T = \\'abc\\'\\n        if S is None or len(S) < len(T):\\n            return False\\n        # matching from left first\\n        left = 0\\n        right = len(S)\\n        while left < right:\\n            i = 0\\n            while i < len(T) and left + i < right and S[left + i] == T[i]:\\n                i += 1\\n            if i == 0:\\n                # nothing can be matched from left any more\\n                break\\n            left += i\\n        while left < right:\\n            i = 0\\n            while i < len(T) and left + i < right and S[right - i - 1] == T[-i - 1]:\\n                i += 1\\n            if i == 0:\\n                # nothing can be matched from tight any more\\n                break\\n            right -= i\\n        return left >= right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 248748,
                "title": "java-o-n",
                "content": "Starting from the left, the amount of \\'c\\' can not exceed that of \\'b\\', and so can\\'t \\'b\\' exceed \\'a\\'\\n```\\npublic boolean isValid(String S) {\\n        int[] nums = new int[3];\\n        for(char c:S.toCharArray()){\\n            int n = c-\\'a\\';nums[n]++;\\n            for(int i=n-1;i>=0;i--)\\n                if(nums[n]>nums[i]) return false;\\n        }\\n        return nums[0]==nums[1] && nums[1]==nums[2];\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isValid(String S) {\\n        int[] nums = new int[3];\\n        for(char c:S.toCharArray()){\\n            int n = c-\\'a\\';nums[n]++;\\n            for(int i=n-1;i>=0;i--)\\n                if(nums[n]>nums[i]) return false;\\n        }\\n        return nums[0]==nums[1] && nums[1]==nums[2];\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 248718,
                "title": "javascript-replace-solution",
                "content": "```js\\nconst isValid = (S) => {\\n    if (S.length < 3) return false;\\n    let current = S, replaced = S.replace(/abc/g, \\'\\');\\n    while (current !== replaced) {\\n        current = replaced;\\n        replaced = replaced.replace(/abc/g, \\'\\');\\n    }\\n    return replaced.length === 0;\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\nconst isValid = (S) => {\\n    if (S.length < 3) return false;\\n    let current = S, replaced = S.replace(/abc/g, \\'\\');\\n    while (current !== replaced) {\\n        current = replaced;\\n        replaced = replaced.replace(/abc/g, \\'\\');\\n    }\\n    return replaced.length === 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 248547,
                "title": "stack-o-n-c",
                "content": "``` bool isValid(string S) {\\n        vector<char> v;\\n        for (auto x : S) {\\n            if (x == \\'a\\' || x == \\'b\\') {\\n                v.push_back(x);\\n                continue;\\n            } else if (x == \\'c\\') {\\n                int n = v.size();\\n                if (n >= 2 && v[n-1] == \\'b\\' && v[n-2] == \\'a\\') {\\n                    v.pop_back();\\n                    v.pop_back();\\n                    continue;\\n                }\\n            } \\n            return false;  \\n        }\\n        return v.empty();\\n    }\\n\\n```",
                "solutionTags": [],
                "code": "``` bool isValid(string S) {\\n        vector<char> v;\\n        for (auto x : S) {\\n            if (x == \\'a\\' || x == \\'b\\') {\\n                v.push_back(x);\\n                continue;\\n            } else if (x == \\'c\\') {\\n                int n = v.size();\\n                if (n >= 2 && v[n-1] == \\'b\\' && v[n-2] == \\'a\\') {\\n                    v.pop_back();\\n                    v.pop_back();\\n                    continue;\\n                }\\n            } \\n            return false;  \\n        }\\n        return v.empty();\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 248329,
                "title": "w-java-stupid-question",
                "content": "Just did a replace for abc and keep looping the same till any occurence of \"abc\" is present.\\n```\\npublic boolean isValid(String S) {\\n        while(S.contains(\"abc\")) {\\n            S = S.replace(\"abc\", \"\");\\n        }\\n        return S.length() == 0; \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isValid(String S) {\\n        while(S.contains(\"abc\")) {\\n            S = S.replace(\"abc\", \"\");\\n        }\\n        return S.length() == 0; \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 248236,
                "title": "java-solution-using-stack-with-explanation",
                "content": "We always push \\'a\\' to the stack, no matter what is on the top of the stack. For \\'b\\' we have to check that the stack is not empty and the top item is \"a\", then we pop \"a\" and push \"ab\" to the stack. For \\'c\\' we have to check that the stack is not empty and the top item is \"ab\", then we pop this item because we have just encountered a valid string \"abc\" and we have to remove it. At the end we check whether the stack is empty, because for a valid string, all the \"abc\" strings have to be popped from the stack.\\n\\n```\\npublic boolean isValid(String S) {\\n    Stack<String> stack = new Stack<>();\\n    for (char ch : S.toCharArray()) {\\n        switch (ch) {\\n            case \\'a\\':\\n                stack.push(\"a\");\\n                break;\\n            case \\'b\\':\\n                if (stack.isEmpty() || !stack.peek().equals(\"a\")) {\\n                    return false;\\n                }\\n                stack.push(stack.pop() + \"b\");\\n                break;\\n            case \\'c\\':\\n                if (stack.isEmpty() || !stack.peek().equals(\"ab\")) {\\n                    return false;\\n                }\\n                stack.pop();\\n                break;\\n            default:\\n                throw new IllegalArgumentException(\"Not possible!\");\\n        }\\n    }\\n    return stack.isEmpty();\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic boolean isValid(String S) {\\n    Stack<String> stack = new Stack<>();\\n    for (char ch : S.toCharArray()) {\\n        switch (ch) {\\n            case \\'a\\':\\n                stack.push(\"a\");\\n                break;\\n            case \\'b\\':\\n                if (stack.isEmpty() || !stack.peek().equals(\"a\")) {\\n                    return false;\\n                }\\n                stack.push(stack.pop() + \"b\");\\n                break;\\n            case \\'c\\':\\n                if (stack.isEmpty() || !stack.peek().equals(\"ab\")) {\\n                    return false;\\n                }\\n                stack.pop();\\n                break;\\n            default:\\n                throw new IllegalArgumentException(\"Not possible!\");\\n        }\\n    }\\n    return stack.isEmpty();\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 247824,
                "title": "java-stack-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char cur = s.charAt(i);\\n            if (cur == \\'a\\' || cur == \\'b\\') stack.push(cur);\\n            else {\\n                if (stack.isEmpty() || stack.peek() != \\'b\\') return false;\\n                stack.pop();\\n                if (stack.isEmpty() || stack.peek() != \\'a\\') return false;\\n                stack.pop();\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character> stack = new Stack<>();\\n        for (int i = 0; i < s.length(); i++) {\\n            char cur = s.charAt(i);\\n            if (cur == \\'a\\' || cur == \\'b\\') stack.push(cur);\\n            else {\\n                if (stack.isEmpty() || stack.peek() != \\'b\\') return false;\\n                stack.pop();\\n                if (stack.isEmpty() || stack.peek() != \\'a\\') return false;\\n                stack.pop();\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 247666,
                "title": "python-solution-o-n-time-o-1-space-easy-to-understand",
                "content": "```\\nclass Solution(object):\\n    def isValid(self, S):\\n        if len(S) <3:\\n            return False\\n        \\n        na = nb = nc = 0\\n        for c in S:\\n            if c == \\'a\\':\\n                na += 1\\n            elif c == \\'b\\':\\n                nb += 1\\n            else:\\n                nc += 1\\n            \\n            if nb > na or nc > na or nc > nb:\\n                return False\\n        return na == nb == nc\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def isValid(self, S):\\n        if len(S) <3:\\n            return False\\n        \\n        na = nb = nc = 0\\n        for c in S:\\n            if c == \\'a\\':\\n                na += 1\\n            elif c == \\'b\\':\\n                nb += 1\\n            else:\\n                nc += 1\\n            \\n            if nb > na or nc > na or nc > nb:\\n                return False\\n        return na == nb == nc\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4097834,
                "title": "simple-python-3-line-solution-beats-99-68-users-in-memory-and-89-59-users-in-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while(\"abc\" in s):\\n            s=s.replace(\"abc\",\"\")\\n        return True if len(s)==0 else False\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def isValid(self, s: str) -> bool:\\n        while(\"abc\" in s):\\n            s=s.replace(\"abc\",\"\")\\n        return True if len(s)==0 else False\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4076776,
                "title": "beats-95-5-simple-approach",
                "content": "# Intuition\\nThis code is designed to check if a given string s follows a specific pattern. The pattern consists of \"a\"s followed by \"b\"s, and each \"b\" is preceded by an \"a\". The code uses a stack data structure to keep track of the characters in the string while processing it.\\n\\n# Approach\\nThe code starts by checking if the first character of the string s is \\'a\\'. If it\\'s not, the function returns false immediately.\\n\\nIt then initializes an empty stack st to help keep track of the characters as it processes the string.\\n\\nIt iterates through each character ch in the string:\\n\\nIf ch is \\'a\\', it pushes \\'a\\' onto the stack.\\nIf ch is \\'b\\', it checks if the stack is not empty and the top of the stack is \\'a\\'. If so, it pushes \\'b\\' onto the stack.\\nIf ch is neither \\'a\\' nor \\'b\\', it returns false because the string contains invalid characters.\\nAfter processing all characters, the code checks if the stack is empty. If the stack is empty, it means that the string has been properly matched according to the pattern, and the function returns true. Otherwise, it returns false.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        \\n        if(s[0]!= \\'a\\') return false;\\n\\n        stack<char> st;\\n\\n        for(char ch:s) {\\n            if(ch == \\'a\\') {\\n                st.push(ch);\\n            }\\n            else if(ch == \\'b\\') {\\n                if(!st.empty() && st.top() == \\'a\\') {\\n                    st.push(ch);\\n                } \\n                else {\\n                    return false;\\n                }\\n            }\\n            else {\\n                if(!st.empty() && st.top() == \\'b\\') {\\n                    st.pop();\\n                    if(!st.empty() && st.top() == \\'a\\') {\\n                        st.pop();\\n                    }\\n                    else {\\n                        return false;\\n                    }\\n                }\\n                else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        \\n        if(s[0]!= \\'a\\') return false;\\n\\n        stack<char> st;\\n\\n        for(char ch:s) {\\n            if(ch == \\'a\\') {\\n                st.push(ch);\\n            }\\n            else if(ch == \\'b\\') {\\n                if(!st.empty() && st.top() == \\'a\\') {\\n                    st.push(ch);\\n                } \\n                else {\\n                    return false;\\n                }\\n            }\\n            else {\\n                if(!st.empty() && st.top() == \\'b\\') {\\n                    st.pop();\\n                    if(!st.empty() && st.top() == \\'a\\') {\\n                        st.pop();\\n                    }\\n                    else {\\n                        return false;\\n                    }\\n                }\\n                else {\\n                    return false;\\n                }\\n            }\\n        }\\n        return st.empty();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070854,
                "title": "vector-simple-fast-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\ntake one vector to check last element is present or not ,\\nif char is c then it means there are a and b are present if they are not consecutive to c -b then it is not valid ,\\nif during pop operation of b and c if vector is empty then it it is not valid \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\no(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\no(n) for worst case ,else o(1);\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nbool isValid(string s) {\\n    int n=s.size();\\n    if(n%3!=0) return false;\\n\\n    // stack<char>st;\\n    vector<char>st;\\n    for(int i=0;i<n;i++){\\n        if(s[i]==\\'c\\' && !st.empty()) {\\n            char top1=st.back();st.pop_back();\\n            if(st.empty()) return false;\\n            char top2=st.back();st.pop_back();\\n\\n            if(top1==\\'b\\' && top2==\\'a\\') continue;\\n            else return false;\\n        }\\n        else st.push_back(s[i]);\\n    }\\n    if(!st.empty())return false;\\n    return true;\\n}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool isValid(string s) {\\n    int n=s.size();\\n    if(n%3!=0) return false;\\n\\n    // stack<char>st;\\n    vector<char>st;\\n    for(int i=0;i<n;i++){\\n        if(s[i]==\\'c\\' && !st.empty()) {\\n            char top1=st.back();st.pop_back();\\n            if(st.empty()) return false;\\n            char top2=st.back();st.pop_back();\\n\\n            if(top1==\\'b\\' && top2==\\'a\\') continue;\\n            else return false;\\n        }\\n        else st.push_back(s[i]);\\n    }\\n    if(!st.empty())return false;\\n    return true;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4063688,
                "title": "golang-stack-implementation",
                "content": "# Code\\n```\\nimport \"unicode/utf8\"\\n\\ntype Stack struct {\\n\\ttop  int\\n\\tdata []rune\\n}\\n\\nfunc NewStack(maxSize int) *Stack {\\n\\tdata := make([]rune, maxSize)\\n\\treturn &Stack{\\n\\t\\ttop:  -1,\\n\\t\\tdata: data,\\n\\t}\\n}\\n\\nfunc (s *Stack) push(ch rune) {\\n\\ts.data[s.top+1] = ch\\n\\ts.top++\\n\\n}\\n\\nfunc (s *Stack) peek(depth int) rune {\\n\\treturn s.data[s.top-depth]\\n}\\n\\nfunc (s *Stack) pop() rune {\\n\\tdefer func() {\\n\\t\\ts.top--\\n\\t}()\\n\\treturn s.data[s.top]\\n}\\n\\nfunc (s *Stack) isEmpty() bool {\\n\\treturn s.top == -1\\n}\\n\\nfunc (s *Stack) size() int {\\n\\treturn s.top + 1\\n}\\n\\nfunc isValid(s string) bool {\\n\\tn := utf8.RuneCountInString(s) // len(s) can also be used in this case as the characters are known at compile time. But len(s) may give unexpected results sometimes.\\n    // For example : s = \"\\xA3\", then len(s) returns 2, whereas RuneCountInString(s) returns 1\\n\\n\\tif s[0] != \\'a\\' || s[n-1] != \\'c\\' {\\n\\t\\treturn false\\n\\t}\\n\\n\\tstack := NewStack(n)\\n\\tinput := []rune(s)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\t\\n\\t\\t// if the char is \\'a\\' or \\'b\\'\\n\\t\\tif input[i] == \\'a\\' || input[i] == \\'b\\' {\\n\\t\\t\\tstack.push(input[i])\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\t// if the char is \\'c\\'\\n\\t\\t\\n\\t\\tif stack.size() < 2 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\tif stack.peek(0) != \\'b\\' || stack.peek(1) != \\'a\\' {\\n\\t\\t\\treturn false\\n\\t\\t} \\n\\t\\t\\n\\t\\tstack.pop()\\n\\t\\tstack.pop()\\n\\t}\\n\\n\\treturn stack.isEmpty()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nimport \"unicode/utf8\"\\n\\ntype Stack struct {\\n\\ttop  int\\n\\tdata []rune\\n}\\n\\nfunc NewStack(maxSize int) *Stack {\\n\\tdata := make([]rune, maxSize)\\n\\treturn &Stack{\\n\\t\\ttop:  -1,\\n\\t\\tdata: data,\\n\\t}\\n}\\n\\nfunc (s *Stack) push(ch rune) {\\n\\ts.data[s.top+1] = ch\\n\\ts.top++\\n\\n}\\n\\nfunc (s *Stack) peek(depth int) rune {\\n\\treturn s.data[s.top-depth]\\n}\\n\\nfunc (s *Stack) pop() rune {\\n\\tdefer func() {\\n\\t\\ts.top--\\n\\t}()\\n\\treturn s.data[s.top]\\n}\\n\\nfunc (s *Stack) isEmpty() bool {\\n\\treturn s.top == -1\\n}\\n\\nfunc (s *Stack) size() int {\\n\\treturn s.top + 1\\n}\\n\\nfunc isValid(s string) bool {\\n\\tn := utf8.RuneCountInString(s) // len(s) can also be used in this case as the characters are known at compile time. But len(s) may give unexpected results sometimes.\\n    // For example : s = \"\\xA3\", then len(s) returns 2, whereas RuneCountInString(s) returns 1\\n\\n\\tif s[0] != \\'a\\' || s[n-1] != \\'c\\' {\\n\\t\\treturn false\\n\\t}\\n\\n\\tstack := NewStack(n)\\n\\tinput := []rune(s)\\n\\tfor i := 0; i < n; i++ {\\n\\t\\t\\n\\t\\t// if the char is \\'a\\' or \\'b\\'\\n\\t\\tif input[i] == \\'a\\' || input[i] == \\'b\\' {\\n\\t\\t\\tstack.push(input[i])\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\n\\t\\t// if the char is \\'c\\'\\n\\t\\t\\n\\t\\tif stack.size() < 2 {\\n\\t\\t\\treturn false\\n\\t\\t}\\n\\n\\t\\tif stack.peek(0) != \\'b\\' || stack.peek(1) != \\'a\\' {\\n\\t\\t\\treturn false\\n\\t\\t} \\n\\t\\t\\n\\t\\tstack.pop()\\n\\t\\tstack.pop()\\n\\t}\\n\\n\\treturn stack.isEmpty()\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4050775,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s.length()<3)\\n        {\\n            return false;\\n        }\\n        else if(s.length()==3)\\n        {\\n            if(s==\"abc\")\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\' or s[i]==\\'b\\')\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                if(st.size()<2)\\n                {\\n                    st.push(s[i]);\\n                }\\n                else\\n                {\\n                    char c1=st.top();\\n                    st.pop();\\n                    char c2=st.top();\\n                    st.pop();\\n                    if(c1==\\'b\\' and c2==\\'a\\')\\n                    {\\n                        continue;\\n                    }\\n                    else\\n                    {\\n                        st.push(c2);\\n                        st.push(c1);\\n                        st.push(s[i]);\\n                    }\\n                }\\n            }\\n        }\\n        if(st.empty())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s.length()<3)\\n        {\\n            return false;\\n        }\\n        else if(s.length()==3)\\n        {\\n            if(s==\"abc\")\\n            {\\n                return true;\\n            }\\n            else\\n            {\\n                return false;\\n            }\\n        }\\n        stack<char>st;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(s[i]==\\'a\\' or s[i]==\\'b\\')\\n            {\\n                st.push(s[i]);\\n            }\\n            else\\n            {\\n                if(st.size()<2)\\n                {\\n                    st.push(s[i]);\\n                }\\n                else\\n                {\\n                    char c1=st.top();\\n                    st.pop();\\n                    char c2=st.top();\\n                    st.pop();\\n                    if(c1==\\'b\\' and c2==\\'a\\')\\n                    {\\n                        continue;\\n                    }\\n                    else\\n                    {\\n                        st.push(c2);\\n                        st.push(c1);\\n                        st.push(s[i]);\\n                    }\\n                }\\n            }\\n        }\\n        if(st.empty())\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4040725,
                "title": "simple-stack-intuitive-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char>st;\\n\\n        for(auto it:s)\\n        {   st.push(it);\\n            if(it==\\'c\\')\\n            {\\n                if(st.size()>=3)\\n                {\\n                    char x=st.top();\\n                    st.pop();\\n                     char y=st.top();\\n                    st.pop();\\n                     char z=st.top();\\n                    st.pop();\\n\\n                    if(y==\\'b\\' && z==\\'a\\')\\n                    continue;\\n                    else\\n                    return false;\\n                }\\n                else\\n                return false;\\n            }\\n        }\\n\\n        return st.size()==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char>st;\\n\\n        for(auto it:s)\\n        {   st.push(it);\\n            if(it==\\'c\\')\\n            {\\n                if(st.size()>=3)\\n                {\\n                    char x=st.top();\\n                    st.pop();\\n                     char y=st.top();\\n                    st.pop();\\n                     char z=st.top();\\n                    st.pop();\\n\\n                    if(y==\\'b\\' && z==\\'a\\')\\n                    continue;\\n                    else\\n                    return false;\\n                }\\n                else\\n                return false;\\n            }\\n        }\\n\\n        return st.size()==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4025340,
                "title": "c-easy-brute-force-approach-just-do-what-ask",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n      int sz=s.size();\\n      \\n        for(int i=sz-1;i>=0;i--)\\n         {\\n            //if it is \\'a\\' then we can start extracting \"abc\"from string\\n              if(s[i]==\\'a\\')\\n                {\\n                  //we exctract 3 character from \\'a\\' \\n                     string str1=s.substr(i,3);\\n                    //if it not \"abc\" then we return false becuase in the question it is given that string is concat of \"abc\"\\n                       if(str1!=\"abc\")\\n                                 return false;\\n                                 //otherwise we reduce out string and erase \"abc\" from it\\n                    s=s.substr(0,i)+s.substr(i+3);\\n                    \\n                \\n                }\\n         }\\n         //if the string is greater then 0 then we return false othwerise we return true string is empty \"\" and we reach result\\n       \\n         return s.size()==0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n      int sz=s.size();\\n      \\n        for(int i=sz-1;i>=0;i--)\\n         {\\n            //if it is \\'a\\' then we can start extracting \"abc\"from string\\n              if(s[i]==\\'a\\')\\n                {\\n                  //we exctract 3 character from \\'a\\' \\n                     string str1=s.substr(i,3);\\n                    //if it not \"abc\" then we return false becuase in the question it is given that string is concat of \"abc\"\\n                       if(str1!=\"abc\")\\n                                 return false;\\n                                 //otherwise we reduce out string and erase \"abc\" from it\\n                    s=s.substr(0,i)+s.substr(i+3);\\n                    \\n                \\n                }\\n         }\\n         //if the string is greater then 0 then we return false othwerise we return true string is empty \"\" and we reach result\\n       \\n         return s.size()==0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4021586,
                "title": "easy-beginner-friendly-recursion-naive-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRemove all occurances of abc from given string.\\nBasically transform s into t ie...convert given string into empty string.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse STL find() to get the first occurance of \"abc\". Now divide the string into 2 parts. First part before the starting index of \"abc\" and the second part after \"abc\". \\nNow call recursion for our new string without \"abc\". If string size becomes 0, then return true.\\n\\n\\n# Complexity\\n- Time complexity: O(N*N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: O(N) -> recursive space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s.size()==0)\\n            return true;\\n        \\n        int n = s.length();\\n        int find = s.find(\"abc\");\\n        if(find != string :: npos)\\n        {\\n            string t1 = s.substr(0, find); //1st part before \"abc\"\\n            string t2 = s.substr(find+3, n); //2nd part after \"abc\"\\n\\n            return isValid(t1+t2); \\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        if(s.size()==0)\\n            return true;\\n        \\n        int n = s.length();\\n        int find = s.find(\"abc\");\\n        if(find != string :: npos)\\n        {\\n            string t1 = s.substr(0, find); //1st part before \"abc\"\\n            string t2 = s.substr(find+3, n); //2nd part after \"abc\"\\n\\n            return isValid(t1+t2); \\n        }\\n\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4017601,
                "title": "swift-optimal-beating-50-users",
                "content": "# Intuition\\nTo replace the occurences of \"abc\" and finally check the given string.\\n\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func isValid(_ s: String) -> Bool {\\n        // ss is a copy of s that can be modified\\n        var ss = s\\n        // as long as ss has \"abc\"\\n        while ss.contains(\"abc\"){\\n            if ss.contains(\"abc\"){\\n                // replacing \"abc\"s with blanks as many times found\\n                ss = ss.replacingOccurrences(of: \"abc\", with: \"\")\\n            }\\n        }\\n        // returning an emoty (true) ss means the format was valid, else invalid\\n        return ss.isEmpty\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    func isValid(_ s: String) -> Bool {\\n        // ss is a copy of s that can be modified\\n        var ss = s\\n        // as long as ss has \"abc\"\\n        while ss.contains(\"abc\"){\\n            if ss.contains(\"abc\"){\\n                // replacing \"abc\"s with blanks as many times found\\n                ss = ss.replacingOccurrences(of: \"abc\", with: \"\")\\n            }\\n        }\\n        // returning an emoty (true) ss means the format was valid, else invalid\\n        return ss.isEmpty\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011372,
                "title": "c-easy-memory-beating-98-users-with-comments",
                "content": "# Intuition\\nTo check the given string multiple times and manipulate to see if the \"abc\" pattern still exists.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        // as long as s has \\'abc\\'\\n        while(s.find(\"abc\") != string::npos){\\n            if(s.find(\"abc\") != string::npos){\\n                // replacing the \\'abc\\' of s with blank space every time found\\n                s = s.replace(s.find(\"abc\"), sizeof(\"abc\") - 1, \"\");\\n            }\\n        }\\n        // finally checking if s was supposed to remain valid after replacing those \\'abc\\'s (one or more as given inside s)\\n        return s.empty();\\n            }\\n    };\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        // as long as s has \\'abc\\'\\n        while(s.find(\"abc\") != string::npos){\\n            if(s.find(\"abc\") != string::npos){\\n                // replacing the \\'abc\\' of s with blank space every time found\\n                s = s.replace(s.find(\"abc\"), sizeof(\"abc\") - 1, \"\");\\n            }\\n        }\\n        // finally checking if s was supposed to remain valid after replacing those \\'abc\\'s (one or more as given inside s)\\n        return s.empty();\\n            }\\n    };\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011049,
                "title": "c-stack-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n = s.size();\\n        stack<char> st;\\n        for(int i=0;i<n;i++){\\n            if(!st.empty() && s[i]==\\'c\\' && st.top()==\\'b\\'){\\n                st.pop();\\n                if(st.empty()){\\n                    st.push(\\'b\\');\\n                    st.push(\\'c\\');\\n                }\\n                else{\\n                    char ch = st.top();\\n                    st.pop();\\n                    if(ch !=\\'a\\'){\\n                        st.push(ch);\\n                        st.push(\\'b\\');\\n                        st.push(\\'c\\');\\n                    }\\n                }\\n            }\\n            else{\\n            st.push(s[i]);\\n            }\\n        }\\n        if(st.empty()) return true;\\n        return false;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        int n = s.size();\\n        stack<char> st;\\n        for(int i=0;i<n;i++){\\n            if(!st.empty() && s[i]==\\'c\\' && st.top()==\\'b\\'){\\n                st.pop();\\n                if(st.empty()){\\n                    st.push(\\'b\\');\\n                    st.push(\\'c\\');\\n                }\\n                else{\\n                    char ch = st.top();\\n                    st.pop();\\n                    if(ch !=\\'a\\'){\\n                        st.push(ch);\\n                        st.push(\\'b\\');\\n                        st.push(\\'c\\');\\n                    }\\n                }\\n            }\\n            else{\\n            st.push(s[i]);\\n            }\\n        }\\n        if(st.empty()) return true;\\n        return false;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4002844,
                "title": "concise-and-clear-code-using-stack-in-java",
                "content": "# Intuition\\nJust a simple approach man we need to check for the string \"abc\" so keep storing \\'a\\' and \\'b\\' in stack but as soon as you get \\'c\\' , pop \\'b\\' and \\'a\\' from the stack and if you finds that the top of the stack doesn\\'t have \\'b\\' and \\'a\\' at the top or the stack is empty then simply return false and at the end if the stack is not empty return false otherwise return true.\\n\\n# Complexity\\n- Time complexity:\\n  O(n)\\n\\n- Space complexity:\\n  O(n)\\n\\n# Code\\n```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character>stack = new Stack<>();\\n        for(char ch:s.toCharArray()){\\n            if(ch!=\\'c\\') stack.push(ch);\\n            else{\\n                if(stack.isEmpty() || stack.pop()!=\\'b\\') return false;\\n                if(stack.isEmpty() || stack.pop()!=\\'a\\') return false;\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "String",
                    "Stack"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) {\\n        Stack<Character>stack = new Stack<>();\\n        for(char ch:s.toCharArray()){\\n            if(ch!=\\'c\\') stack.push(ch);\\n            else{\\n                if(stack.isEmpty() || stack.pop()!=\\'b\\') return false;\\n                if(stack.isEmpty() || stack.pop()!=\\'a\\') return false;\\n            }\\n        }\\n        return stack.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4000091,
                "title": "easy-brute-force-java-solution",
                "content": "```\\nclass Solution {\\n    public boolean isValid(String s) \\n    {\\n     Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(st.size()<=1)\\n            {\\n                st.push(s.charAt(i));\\n            }\\n            else\\n            {\\n                char c=s.charAt(i);\\n                char b=st.pop();\\n                char a=st.pop();\\n                String temp=a+\"\"+b+\"\"+c+\"\";\\n                if(temp.equals(\"abc\")==false)\\n                {\\n                    st.push(a);\\n                    st.push(b);\\n                    st.push(c);\\n                }\\n                \\n            }\\n                \\n        }\\n        // System.out.println(st);\\n        return st.isEmpty();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public boolean isValid(String s) \\n    {\\n     Stack<Character> st=new Stack<>();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(st.size()<=1)\\n            {\\n                st.push(s.charAt(i));\\n            }\\n            else\\n            {\\n                char c=s.charAt(i);\\n                char b=st.pop();\\n                char a=st.pop();\\n                String temp=a+\"\"+b+\"\"+c+\"\";\\n                if(temp.equals(\"abc\")==false)\\n                {\\n                    st.push(a);\\n                    st.push(b);\\n                    st.push(c);\\n                }\\n                \\n            }\\n                \\n        }\\n        // System.out.println(st);\\n        return st.isEmpty();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998418,
                "title": "check-if-word-is-valid-after-substitutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n-  A naive approach to validating a string involves repeatedly removing \\'abc\\' triplets from the string until no more can be removed.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Brute Force Approach (O(N^2)): A naive approach to validating a string involves repeatedly removing \\'abc\\' triplets from the string until no more can be removed. This method has a time complexity of O(N^2), as it may require multiple passes through the string, with each pass potentially removing one or more triplets.\\n\\n\\n- Optimal Approach (O(N)): The optimal solution uses a stack to efficiently validate the string in a single pass. It checks each character against the \\'abc\\' pattern, popping \\'ba\\' when \\'c\\' is encountered. This approach has a linear time complexity of O(N), where N is the length of the input string, making it more efficient and scalable than the brute force method.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- n\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st; // Initialize a stack to keep track of characters.\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'c\\') { // If the current character is \\'c\\'.\\n                if (st.size() >= 2 && st.top() == \\'b\\') { // Check if there are at least two characters in the stack and the top character is \\'b\\'.\\n                    st.pop(); // Pop \\'b\\'.\\n                    if (st.top() == \\'a\\') { // Check if the character before \\'b\\' is \\'a\\'.\\n                        st.pop(); // Pop \\'a\\'.\\n                    } else {\\n                        return false; // Invalid sequence if \\'a\\' is not before \\'b\\'.\\n                    }\\n                } else {\\n                    return false; // Invalid sequence if \\'b\\' is not on top of the stack or there are fewer than two characters in the stack.\\n                }\\n            } else {\\n                st.push(s[i]); // Push characters other than \\'c\\' onto the stack.\\n            }\\n        }\\n\\n        return st.empty(); // If the stack is empty at the end, the string is valid; otherwise, it\\'s not valid.\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Stack"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    bool isValid(string s) {\\n        stack<char> st; // Initialize a stack to keep track of characters.\\n\\n        for (int i = 0; i < s.size(); i++) {\\n            if (s[i] == \\'c\\') { // If the current character is \\'c\\'.\\n                if (st.size() >= 2 && st.top() == \\'b\\') { // Check if there are at least two characters in the stack and the top character is \\'b\\'.\\n                    st.pop(); // Pop \\'b\\'.\\n                    if (st.top() == \\'a\\') { // Check if the character before \\'b\\' is \\'a\\'.\\n                        st.pop(); // Pop \\'a\\'.\\n                    } else {\\n                        return false; // Invalid sequence if \\'a\\' is not before \\'b\\'.\\n                    }\\n                } else {\\n                    return false; // Invalid sequence if \\'b\\' is not on top of the stack or there are fewer than two characters in the stack.\\n                }\\n            } else {\\n                st.push(s[i]); // Push characters other than \\'c\\' onto the stack.\\n            }\\n        }\\n\\n        return st.empty(); // If the stack is empty at the end, the string is valid; otherwise, it\\'s not valid.\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1570083,
                "content": [
                    {
                        "username": "karthikn82P",
                        "content": "bool isValid(string S) {\\n\\twhile (S.size() != 0) {\\n\\t\\tint rPos = S.find(\"abc\");\\n\\t\\tif (rPos == std::string::npos) return false;\\n\\t\\tS.replace(rPos, 3, \"\");\\n\\t}\\n\\treturn true;\\n\\n}"
                    },
                    {
                        "username": "Msey",
                        "content": "If I can make it then it means the problem is easy"
                    },
                    {
                        "username": "francechaipeelo",
                        "content": "We can split it to \\n\"a\" + \"ab\" + \"bc\" + \"c\"\\n\\nThe first and third are valid splits and second and third are valid."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Its time to revise your stl functions guys"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Took a bit of thinking, problem turned out easier than it appeared."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This should be marked as easy, there are no advanced skills required. And the time constraint is easy not difficult either."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "I don\\'t think this problem is easy."
                    }
                ]
            },
            {
                "id": 1849248,
                "content": [
                    {
                        "username": "karthikn82P",
                        "content": "bool isValid(string S) {\\n\\twhile (S.size() != 0) {\\n\\t\\tint rPos = S.find(\"abc\");\\n\\t\\tif (rPos == std::string::npos) return false;\\n\\t\\tS.replace(rPos, 3, \"\");\\n\\t}\\n\\treturn true;\\n\\n}"
                    },
                    {
                        "username": "Msey",
                        "content": "If I can make it then it means the problem is easy"
                    },
                    {
                        "username": "francechaipeelo",
                        "content": "We can split it to \\n\"a\" + \"ab\" + \"bc\" + \"c\"\\n\\nThe first and third are valid splits and second and third are valid."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Its time to revise your stl functions guys"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Took a bit of thinking, problem turned out easier than it appeared."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This should be marked as easy, there are no advanced skills required. And the time constraint is easy not difficult either."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "I don\\'t think this problem is easy."
                    }
                ]
            },
            {
                "id": 1572504,
                "content": [
                    {
                        "username": "karthikn82P",
                        "content": "bool isValid(string S) {\\n\\twhile (S.size() != 0) {\\n\\t\\tint rPos = S.find(\"abc\");\\n\\t\\tif (rPos == std::string::npos) return false;\\n\\t\\tS.replace(rPos, 3, \"\");\\n\\t}\\n\\treturn true;\\n\\n}"
                    },
                    {
                        "username": "Msey",
                        "content": "If I can make it then it means the problem is easy"
                    },
                    {
                        "username": "francechaipeelo",
                        "content": "We can split it to \\n\"a\" + \"ab\" + \"bc\" + \"c\"\\n\\nThe first and third are valid splits and second and third are valid."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Its time to revise your stl functions guys"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Took a bit of thinking, problem turned out easier than it appeared."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This should be marked as easy, there are no advanced skills required. And the time constraint is easy not difficult either."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "I don\\'t think this problem is easy."
                    }
                ]
            },
            {
                "id": 1948758,
                "content": [
                    {
                        "username": "karthikn82P",
                        "content": "bool isValid(string S) {\\n\\twhile (S.size() != 0) {\\n\\t\\tint rPos = S.find(\"abc\");\\n\\t\\tif (rPos == std::string::npos) return false;\\n\\t\\tS.replace(rPos, 3, \"\");\\n\\t}\\n\\treturn true;\\n\\n}"
                    },
                    {
                        "username": "Msey",
                        "content": "If I can make it then it means the problem is easy"
                    },
                    {
                        "username": "francechaipeelo",
                        "content": "We can split it to \\n\"a\" + \"ab\" + \"bc\" + \"c\"\\n\\nThe first and third are valid splits and second and third are valid."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Its time to revise your stl functions guys"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Took a bit of thinking, problem turned out easier than it appeared."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This should be marked as easy, there are no advanced skills required. And the time constraint is easy not difficult either."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "I don\\'t think this problem is easy."
                    }
                ]
            },
            {
                "id": 1947358,
                "content": [
                    {
                        "username": "karthikn82P",
                        "content": "bool isValid(string S) {\\n\\twhile (S.size() != 0) {\\n\\t\\tint rPos = S.find(\"abc\");\\n\\t\\tif (rPos == std::string::npos) return false;\\n\\t\\tS.replace(rPos, 3, \"\");\\n\\t}\\n\\treturn true;\\n\\n}"
                    },
                    {
                        "username": "Msey",
                        "content": "If I can make it then it means the problem is easy"
                    },
                    {
                        "username": "francechaipeelo",
                        "content": "We can split it to \\n\"a\" + \"ab\" + \"bc\" + \"c\"\\n\\nThe first and third are valid splits and second and third are valid."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Its time to revise your stl functions guys"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Took a bit of thinking, problem turned out easier than it appeared."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This should be marked as easy, there are no advanced skills required. And the time constraint is easy not difficult either."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "I don\\'t think this problem is easy."
                    }
                ]
            },
            {
                "id": 1821995,
                "content": [
                    {
                        "username": "karthikn82P",
                        "content": "bool isValid(string S) {\\n\\twhile (S.size() != 0) {\\n\\t\\tint rPos = S.find(\"abc\");\\n\\t\\tif (rPos == std::string::npos) return false;\\n\\t\\tS.replace(rPos, 3, \"\");\\n\\t}\\n\\treturn true;\\n\\n}"
                    },
                    {
                        "username": "Msey",
                        "content": "If I can make it then it means the problem is easy"
                    },
                    {
                        "username": "francechaipeelo",
                        "content": "We can split it to \\n\"a\" + \"ab\" + \"bc\" + \"c\"\\n\\nThe first and third are valid splits and second and third are valid."
                    },
                    {
                        "username": "geekyshark",
                        "content": "Its time to revise your stl functions guys"
                    },
                    {
                        "username": "yeedaKing",
                        "content": "Took a bit of thinking, problem turned out easier than it appeared."
                    },
                    {
                        "username": "Mister_CK",
                        "content": "This should be marked as easy, there are no advanced skills required. And the time constraint is easy not difficult either."
                    },
                    {
                        "username": "Jason-Law",
                        "content": "I don\\'t think this problem is easy."
                    }
                ]
            }
        ]
    },
    {
        "title": "Shuffle the Array",
        "question_content": "<p>Given the array <code>nums</code> consisting of <code>2n</code> elements in the form <code>[x<sub>1</sub>,x<sub>2</sub>,...,x<sub>n</sub>,y<sub>1</sub>,y<sub>2</sub>,...,y<sub>n</sub>]</code>.</p>\r\n\r\n<p><em>Return the array in the form</em> <code>[x<sub>1</sub>,y<sub>1</sub>,x<sub>2</sub>,y<sub>2</sub>,...,x<sub>n</sub>,y<sub>n</sub>]</code>.</p>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong class=\"example\">Example 1:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [2,5,1,3,4,7], n = 3\r\n<strong>Output:</strong> [2,3,5,4,1,7] \r\n<strong>Explanation:</strong> Since x<sub>1</sub>=2, x<sub>2</sub>=5, x<sub>3</sub>=1, y<sub>1</sub>=3, y<sub>2</sub>=4, y<sub>3</sub>=7 then the answer is [2,3,5,4,1,7].\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 2:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,2,3,4,4,3,2,1], n = 4\r\n<strong>Output:</strong> [1,4,2,3,3,2,4,1]\r\n</pre>\r\n\r\n<p><strong class=\"example\">Example 3:</strong></p>\r\n\r\n<pre>\r\n<strong>Input:</strong> nums = [1,1,2,2], n = 2\r\n<strong>Output:</strong> [1,2,1,2]\r\n</pre>\r\n\r\n<p>&nbsp;</p>\r\n<p><strong>Constraints:</strong></p>\r\n\r\n<ul>\r\n\t<li><code>1 &lt;= n &lt;= 500</code></li>\r\n\t<li><code>nums.length == 2n</code></li>\r\n\t<li><code>1 &lt;= nums[i] &lt;= 10^3</code></li>\r\n</ul>",
        "solutions": [
            {
                "id": 675956,
                "title": "in-place-o-n-time-o-1-space-with-explanation-analysis",
                "content": "**COMPLEXITY:**\\n* Time: O(n) where n = nums.length\\n* Space: O(1)\\n\\n<hr>\\n\\n**EXPLANATION:**\\n\\n**Prerequisites:**\\nSome bit manipulation knowledge will be helpful in understanding this algorithm. This algorithm uses:\\n* Bitwise AND ```&```\\n* Bitwise OR ```|```\\n* Left Shift ```<<```\\n* Right Shift ```>>```\\n* Binary Representations of Numbers\\n\\n\\n**Intuition:**\\n* This in-place algorithm relies on the constraint ```1 <= nums[i] <= 10^3```. This means the largest possible number in the nums array is ```1000```. \\n* The binary representation of ```1000``` is ```1111101000```.\\n* If we count the number of bits in ```1111101000``` we get 10.\\n* Because the largest possible number only uses 10 bits, we can fit two numbers into one 32-bit binary representation.\\n* This means we can store pairs of numbers in one binary representation without fear of overwriting a number.\\n\\n**Implementation:**\\nAs shown in the description of the problem, the array starts in the form ```[x1,x2,...,xn,y1,y2,...,yn]```\\n\\nThis algorithm will use two loops:\\n1. **Loop 1** will group the numbers into pairs ```[x1, y1], [x2, y2]... [xn,yn]``` by storing both numbers ```xn``` and ```yn``` in one binary representation.\\n2. **Loop 2** will then place these pairs in their final position.\\n\\n**How do we store two numbers in one binary representation?**\\n\\nWe will use two pointers ```i``` and ```j```:\\n```i``` will traverse backwards from ```n``` to ```0```.\\n```j``` will traverse backwards from the end of the array to ```n```.\\n\\nStore both ```nums[i]``` and ```nums[j]``` in ```nums[j]```.\\n\\n1. Because ```nums[j]``` is already storing its number we do not need to add it. Instead we need to left shift this number over by ```10``` bits to make room to add the second number ```nums[i]```. We shift it over by ```10``` bits because the largest possible number is ```1000``` which uses ```10``` bits.\\n```\\nnums[j] <<= 10\\n```\\n2. To add nums[i] we can Bitwise OR ```nums[i]``` with ```nums[j]```: \\n```\\nnums[j] |= nums[i]\\n```\\n\\n**Loop 1:**\\n\\nWhen using the following input, Loop 1 will look like the example below:\\n```nums = [1,2,3,4,4,3,2,1]```, ```n = 4```\\n\\nNotes:\\n* In the below example ```[2,3]``` represents the two numbers ```2``` and ```3``` stored in one binary representation.\\n* The reason we traverse backwards and store the pairs in the last n numbers is so that when we do a forward traversal for Loop 2 to place numbers in their final place we do not overwrite numbers along the way.\\n```\\n      i       j\\n1 2 3 4 4 3 2 1\\n\\n    i       j\\n1 2 3 4 4 3 2 [1,4]\\n\\n\\n  i       j\\n1 2 3 4 4 3 [2,3] [1,4]\\n\\ni       j\\n1 2 3 4 4 [3,2] [2,3] [1,4]\\n\\n1 2 3 4 [4,1] [3,2] [2,3] [1,4]\\n```\\n\\n\\n**Loop 2:**\\nLoop 2 will now place numbers in the final position.\\n\\nWe will use two pointers ```i``` and ```j```.\\n```i``` will traverse forwards from 0 to n.\\n```j``` will traverse forwards from n to the end of the array.\\n\\nThe final numbers for positions``` nums[i]``` and ```nums[i + 1]``` can be found in the binary representation at ```nums[j]```.\\n* Get both numbers from ```nums[j]``` and update ```nums[i]``` and ```nums[i + 1]```\\n* Increment ```i``` by ```2``` to place the next pair.\\n* Increment ```j``` by ```1``` to get the numbers for the next two positions ```nums[i]``` and ```nums[i + 1]```\\n\\n**How do we get the two numbers out of ```nums[j]```?**\\n1. To get the first number we will Bitwise AND ```nums[j]``` with ```1023```. We use ```1023``` because the largest possible number is ```1000``` which uses ```10``` bits. ```10``` bits of all 1s is ```1111111111``` which is the binary representation of ```1023```. Bitwise AND with ```1023``` will cancel out any number after the first ```10``` bits and we\\'ll be left with the first number only.\\n```\\nconst num1 = nums[j] & 1023\\n```\\n2. To get the second number we right shift the number back over 10 places.      \\n```\\nconst num2 = nums[j] >> 10\\n```\\n\\n<hr>\\n\\n**SOLUTION:**\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    let i = n - 1\\n    for (let j = nums.length - 1; j >= n; j--) {\\n        nums[j] <<= 10\\n        nums[j] |= nums[i]\\n        i--\\n    }\\n    \\n    i = 0\\n    for (let j = n; j < nums.length; j++) {\\n        const num1 = nums[j] & 1023\\n        const num2 = nums[j] >> 10\\n        nums[i] = num1\\n        nums[i + 1] = num2\\n        i += 2    \\n    }\\n    \\n    return nums\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```&```\n```|```\n```<<```\n```>>```\n```1 <= nums[i] <= 10^3```\n```1000```\n```1000```\n```1111101000```\n```1111101000```\n```[x1,x2,...,xn,y1,y2,...,yn]```\n```[x1, y1], [x2, y2]... [xn,yn]```\n```xn```\n```yn```\n```i```\n```j```\n```i```\n```n```\n```0```\n```j```\n```n```\n```nums[i]```\n```nums[j]```\n```nums[j]```\n```nums[j]```\n```10```\n```nums[i]```\n```10```\n```1000```\n```10```\n```\\nnums[j] <<= 10\\n```\n```nums[i]```\n```nums[j]```\n```\\nnums[j] |= nums[i]\\n```\n```nums = [1,2,3,4,4,3,2,1]```\n```n = 4```\n```[2,3]```\n```2```\n```3```\n```\\n      i       j\\n1 2 3 4 4 3 2 1\\n\\n    i       j\\n1 2 3 4 4 3 2 [1,4]\\n\\n\\n  i       j\\n1 2 3 4 4 3 [2,3] [1,4]\\n\\ni       j\\n1 2 3 4 4 [3,2] [2,3] [1,4]\\n\\n1 2 3 4 [4,1] [3,2] [2,3] [1,4]\\n```\n```i```\n```j```\n```i```\n```j```\n``` nums[i]```\n```nums[i + 1]```\n```nums[j]```\n```nums[j]```\n```nums[i]```\n```nums[i + 1]```\n```i```\n```2```\n```j```\n```1```\n```nums[i]```\n```nums[i + 1]```\n```nums[j]```\n```nums[j]```\n```1023```\n```1023```\n```1000```\n```10```\n```10```\n```1111111111```\n```1023```\n```1023```\n```10```\n```\\nconst num1 = nums[j] & 1023\\n```\n```\\nconst num2 = nums[j] >> 10\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    let i = n - 1\\n    for (let j = nums.length - 1; j >= n; j--) {\\n        nums[j] <<= 10\\n        nums[j] |= nums[i]\\n        i--\\n    }\\n    \\n    i = 0\\n    for (let j = n; j < nums.length; j++) {\\n        const num1 = nums[j] & 1023\\n        const num2 = nums[j] >> 10\\n        nums[i] = num1\\n        nums[i + 1] = num2\\n        i += 2    \\n    }\\n    \\n    return nums\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1314638,
                "title": "java-c-simple-o-1-space-in-place-100-faster-efficient-explained",
                "content": "<u>**BASIC IDEA:**</u>\\n1. **Store the pair of numbers** and then\\n2. **Retreive each number,** from that pair where they were stored, **one by one** and place them at their desired positions.\\n\\n<u>**GENERAL EXAMPLE:**</u>\\n*Suppose, you are performing a task and someone gives you another task, in order to avoid disturbance in the flow of previous task, you can keep both the tasks on one side and complete the task one by one according to the requirement.*\\n\\n<u>**SAME CONCEPT FOR ARRAYS:**</u>\\n*In order to avoid overwriting values, store the \"pair of numbers\" in the right half of the array and retrieve the numbers by one according to the requirement.*\\n\\n**#  <u>DETAILED EXPLANATION IS GIVEN BELOW THE CODE</u> #**\\n\\n<u>**NOTE:**</u>  --> Runtime Fluctuates a lot in case of C++(0ms to 4ms)\\n\\n<u>**C++ / JAVA CODE**</u>\\n\\n<iframe src=\"https://leetcode.com/playground/arHM8WHa/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\n<hr>\\n\\n**Using Bitwise Operator to make it a bit faster**<br>\\n\\n<u>**NOTE:**</u>  --> Runtime Fluctuates a lot in case of C++(0ms to 4ms)\\n\\n<u>**C++ / JAVA CODE**</u>\\n\\n<iframe src=\"https://leetcode.com/playground/QHAeabD9/shared\" frameBorder=\"0\" width=\"100%\" height=\"350\"></iframe>\\n\\n<hr>\\n\\n<u>**EXPLANATION:**</u>\\n\\n**Let\\'s understand in general term:**\\n\\nSuppose we have 2 numbers `num1 = 4` and `num2 = 9` and `maxValue = 10`\\n**Formula:**\\n**to store** -> pair = (num2 &times; maxValue) + num1\\n**to retrieve** -> pair % maxValue and pair / maxValue\\n\\n1. **Storing the pair of numbers**\\n\\n\\t(9 &times; 10) + 4 = 94 --> from above formula (num2 &times; maxValue) + num1\\n\\t**94 is stored**\\n\\n2. **Retrieving each number one by one**\\n\\n\\t94 % 10 = 4\\n\\t**we got first number as 4**\\n\\n\\t94 / 10 = 9\\n\\t**we got second number as 9**\\n\\nSame idea goes for large cases and array as well but instead of 10, we will take 1024 to store pairs and retrieve each number\\n**<u>NOTE:</u> Here, we will take 1024 because of the given constraints `1 <= nums[i] <= 10^3` i.e. the largest number in the array will be 1000**\\n\\nNow, \\n**Binary representation** of **1000** is **1111101000**, consisting of total **10 bits**\\n**Binary representation** of **1024** is **10000000000**, consisting of total **11 bits**\\nand if we multiply 1000 with 1024 i.e. **(1000 * 1024)**, we will get **1024000**\\n**Binary representation** of **1024000** is **11111010000000000000**, consisting of total **20 bits** which is less than the number of bits **(32bits)** of int data type, so we can store the number pairs(by multiplying one number with 1024 and adding another number to it) to retrieve each indivisual number later on(by taking out the remainder and the quotient).\\neg: suppose we have an **`array of length 4`** and **`n is 2`**\\n`nums = [5, 2, 1000, 3]` and `n = 2`\\n\\n1. **We will store the pair of numbers first**\\n\\n\\tAccording to algorithm\\n\\t\\n\\t```\\n\\t// to store the pair of numbers in right half of the original array\\n\\tfor(int i = n; i < len; i++)\\n\\tnums[i] = (nums[i] * 1024) + nums[i - n];\\n\\t```\\n\\t* \\t**Iteration 1:**\\n\\t\\twhen i = 2, (i = 2 because value of n is 2)\\n\\t\\tnums[2] = (1000 &times; 1024) + 5 \\n\\t\\tso, nums[2] = 1024005\\n\\n\\t* \\t**Iteration 2:**\\n\\t\\twhen i = 3,\\n\\t\\tnums[3] = (3 &times; 1024) + 2\\n\\t\\tso, nums[3] = 3074\\n\\n\\t**Now, the original array**\\n\\t[5, 2, 1000, 3]\\n\\t&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;<-- Indexes\\n\\t**becomes**\\n\\t[5, 2, 1024005, 3074]\\n\\t&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;<-- Indexes\\n\\n2. **We will retrieve the numbers one by one from the pairs which we have stored at 2nd and 3rd index**\\n\\n\\tAccording to algorithm\\n\\t```\\n\\t// to retrive values from the pair of numbers and placing those retrieved value at their desired position\\n\\tint index = 0;\\n\\tfor(int i = n; i < len; i++, index += 2){\\n\\t\\tnums[index] = nums[i] % 1024;\\n\\t\\tnums[index + 1] = nums[i] / 1024;\\n\\t}\\n\\t```\\n\\n\\t* \\t**Iteration 1:**\\n\\t\\twhen index = 0 and i = 2, (i = 2 because value of n is 2)\\n\\t\\tnums[0] = 1024005 % 1024 = 5\\n\\t\\tnums[1] = 1024005 / 1024 = 1000\\n\\t\\tnow, index = 2 (from index += 2)\\n\\n\\t* \\t**Iteration 2:**\\n\\t\\twhen index = 2, i = 3,\\n\\t\\tnums[2] = 3074 % 1024 = 2\\n\\t\\tnums[3] = 3074 / 1024 = 3\\n\\n\\tIteration will be stopped now as the condition become false and we got the array as following\\n\\t**[5, 1000, 2, 3]  <-- Desired Output**\\n\\t&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;<-- Indexes\\n<hr>\\n\\n<u>**COMPLEXITY:**</u>\\n* **Time: O(n)**, where n is the given number, which is half of the length of the array\\n* **Space: O(1)**, in-place<br>\\n\\nSince we need to solve it in 0(1) space or **in-place**, we will use the original array.\\n<hr>\\n\\n**You might be wondering why I took** `1024`\\nLet\\'s understand why\\n\\n**One Line answer**\\nMultiply by number which is greater than both of num1 and num2(max num1 or num2 can be 1000 or 10 ^ 3)\\n\\n**Long answer**\\nLet\\'s understand in general term i.e. 1 <= num1,  num2 <= 10 i.e. min value of num1 and num2 can be 1 and max value can be 10\\n\\nNow, suppose 2 numbers num1 = 10 and num2 = 4 and maxValue = 10\\n**Formula:**\\n**to store** -> pair = (num2 * maxValue) + num1\\n**to retrieve** -> pair % maxValue and pair / maxValue\\n\\n1. **Storing the pair of numbers**\\n\\n\\t4 * 10 + 10 = 50 --> from above formula (num2 * maxValue) + num1\\n\\t**50 is stored**\\n\\n2. **Retrieving each number one by one**\\n\\n\\t50 % 10 = 0 \\n\\t**we got first number as 0** -- > not what we wanted\\n\\n\\t50 / 10 = 5 \\n\\t**we got second number as 5** -- > not what we wanted\\n\\nNow, suppose 2 numbers num1 = 10 and num2 = 4 and maxValue = 11(here max value is different from above)\\n1. **Storing the pair of numbers**\\n\\n\\t4 * 11 + 10 = 54 --> from above formula (num2 * maxValue) + num1\\n\\t**54 is stored**\\n\\n2. **Retrieving each number one by one**\\n\\n\\t54 % 11 = 10\\n\\t**we got first number as 10** -- > what we wanted\\n\\n\\t54 / 11 = 4\\n\\t**we got second number as 4** -- > what we wanted\\n\\nSo, we can conclude that **multiply by number which is greater than both of num1 and num2.**\\neg:\\nfor(0 to 9) take 10(i.e. greater than 0 and 9)\\nfor(0 to 19) take 20(i.e. greater than 0 and 19)\\nfor(0 to 29) take 30(i.e. greater than 0 and 29) and so on\\n\\nSame idea goes for large cases and array as well but instead of 10, we will take 1024(as max value can be 1000 according to constraints) to store pairs and retrieve each number.\\n\\nHere, we are taking 1024 because of the given constraints **1 <= nums[i] <= 10^3** i.e. the largest number in the array will be `1000`.\\n**NOTE: we could have taken `1001`(according to constraints) instead of `1024` but took `1024` because 2<sup>10</sup> will give 1024 and will be easier to use this value(1024) while performing bitwise operation as 1024 is a power of 2 and multiplying 1024 * 1000(max value according to constraint) fits in 32 bits of int and there will be no overflow.**\\n\\n<strong>Try taking 1001 (will give desired output)</strong>\\n![image](https://assets.leetcode.com/users/images/4077adb7-92eb-4df4-bc01-e57048f6facc_1629368199.7840974.png)\\n<hr>\\n<br>\\n\\n<strong>And now try taking 1000 (will not give desired output)</strong>\\n![image](https://assets.leetcode.com/users/images/9dc75c5d-42e3-47ec-9b37-4abbcef021f4_1629368059.1304839.png)\\n\\n<strong>Multiplying with 1000 and retrieving values by nums[i] % 1000 and nums[i] / 1000 will not give you the desired output</strong>\\n<hr>\\n\\n<u><strong>Refer to the following github repsitory for more leetcode solutions<strong></u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n<hr>\\n\\n# **Please Upvote If you got any help from the provided solution!!!**\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n\\t// to store the pair of numbers in right half of the original array\\n\\tfor(int i = n; i < len; i++)\\n\\tnums[i] = (nums[i] * 1024) + nums[i - n];\\n\\t```\n```\\n\\t// to retrive values from the pair of numbers and placing those retrieved value at their desired position\\n\\tint index = 0;\\n\\tfor(int i = n; i < len; i++, index += 2){\\n\\t\\tnums[index] = nums[i] % 1024;\\n\\t\\tnums[index + 1] = nums[i] / 1024;\\n\\t}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 674309,
                "title": "java-straightforward-1-loop",
                "content": "No need to explain, right?\\n```\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res = new int[2 * n];\\n        for (int i = 0, j = n, idx = 0; idx < res.length; i++, j++) {\\n            res[idx++] = nums[i];\\n            res[idx++] = nums[j];\\n        } \\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res = new int[2 * n];\\n        for (int i = 0, j = n, idx = 0; idx < res.length; i++, j++) {\\n            res[idx++] = nums[i];\\n            res[idx++] = nums[j];\\n        } \\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 675007,
                "title": "python-o-n-time-o-1-space-detailed-explanation",
                "content": "1. Each \"nums[i]\" has a \"desired\" index. \\ne.g. for an array of 8 numbers, nums[0] wants to go to index \"0\", nums[4] wants to go to index \"1\", nums[1] wants to go to index \"2\", nums[5] wants to go to index \"3\", nums[2] wants to go to index \"4\"... \\nThe target index of nums[i] is nums[i]\\'s \"desired index\".\\n2. We loop through all nums and swap each nums[i] into its \"desired\" index. As soon as a number is placed into its \"desired\" place, we mark it as \"negative\", so that it won\\'t be processed again when we see it later (yes, because nums[i]\\'s desired index might be after itself, we might see it agian later). \\n3. Now nums[i] is in its desired place, but how about another number that \"is swapped\" by nums[i]? That number is currently in position \"i\" now because of the swap. We recursively put that number into its \"desired\" place too, until all the \"be-swapped\" numbers are also in their desired place. \\n4. After that, we can move to the next index \"i\" and do the same thing.\\n5. Don\\'t forget to change all numbers back to positive value after all finsihed.\\n\\n```\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        getDesireIdx = lambda i: i*2 if i<n else (i-n)*2+1\\n        for i in range(2*n):\\n            j=i\\n            while nums[i]>=0:\\n                j=getDesireIdx(j)\\n                nums[i],nums[j]=nums[j],-nums[i]\\n        for i in range(2*n):\\n            nums[i]=-nums[i]\\n        return nums\\n```",
                "solutionTags": [],
                "code": "```\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        getDesireIdx = lambda i: i*2 if i<n else (i-n)*2+1\\n        for i in range(2*n):\\n            j=i\\n            while nums[i]>=0:\\n                j=getDesireIdx(j)\\n                nums[i],nums[j]=nums[j],-nums[i]\\n        for i in range(2*n):\\n            nums[i]=-nums[i]\\n        return nums\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 675110,
                "title": "easiest-python-solution-with-zip-o-n-time",
                "content": "I divide the array into two parts, iterate items in one loop and return the result.\\n \\n```\\ndef shuffle(self, nums: List[int], n: int) -> List[int]:\\n \\xA0 \\xA0 \\xA0 \\xA0res = []\\n \\xA0 \\xA0 \\xA0 \\xA0for i, j in zip(nums[:n],nums[n:]):\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0res += [i,j]\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef shuffle(self, nums: List[int], n: int) -> List[int]:\\n \\xA0 \\xA0 \\xA0 \\xA0res = []\\n \\xA0 \\xA0 \\xA0 \\xA0for i, j in zip(nums[:n],nums[n:]):\\n \\xA0 \\xA0 \\xA0 \\xA0 \\xA0 \\xA0res += [i,j]\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 865924,
                "title": "in-place-o-n-time-o-1-ultimate-simple-java-solution",
                "content": "Just use the assumption that the numbers are less than 1000. So we can save the pairs together.\\n\\n```\\n\\npublic int[] shuffle(int[] nums, int n) {\\n        for(int i = 0; i < n; i++){\\n            nums[i] += nums[n + i] * 10000;\\n        }\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            nums[2 * i + 1] = nums[i] / 10000;\\n            nums[2 * i] = nums[i] % 10000;\\n        }\\n        \\n        return nums;\\n    }",
                "solutionTags": [],
                "code": "Just use the assumption that the numbers are less than 1000. So we can save the pairs together.\\n\\n```\\n\\npublic int[] shuffle(int[] nums, int n) {\\n        for(int i = 0; i < n; i++){\\n            nums[i] += nums[n + i] * 10000;\\n        }\\n        \\n        for(int i = n - 1; i >= 0; i--){\\n            nums[2 * i + 1] = nums[i] / 10000;\\n            nums[2 * i] = nums[i] % 10000;\\n        }\\n        \\n        return nums;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2710721,
                "title": "java-0-ms-faster-than-100-00-o-n",
                "content": "**Upvote if you like my solution! I\\'ll be happy :)**\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] result = new int[2*n];\\n        for (int i = 0; i < n; i++) {\\n            result[2 * i] = nums[i];\\n            result[2 * i + 1] = nums[n + i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] result = new int[2*n];\\n        for (int i = 0; i < n; i++) {\\n            result[2 * i] = nums[i];\\n            result[2 * i + 1] = nums[n + i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 720690,
                "title": "easy-js-solution",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    let res = [];\\n    for (i = 0; i < n; i++) {\\n        res.push(nums[i],nums[i+n]);\\n    }\\n    return res;\\n};\\n```\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    let res = [];\\n    for (i = 0; i < n; i++) {\\n        res.push(nums[i],nums[i+n]);\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 674947,
                "title": "o-1-space-o-n-time-detailed-explanation",
                "content": "*(Please stop downvoating only because of a paper that solves a completely different problem!)*\\n\\n\\n## **Explanation**\\n----\\nUse the negative sign as a flag for the number that is already in its final place. Once a number is in its final place, we do not move it anymore.\\n\\nThe for-loop goes through every number. If the number is already in its final place, leave it as it is.\\n\\nOtherwise if the number is not in its final place, use a static index `i` to permanently mark its current place.\\nKeep in mind: `nums[i]` will change. **Do not imagine it is certain number. Imagine `nums[i]` as a slot.** The number in the slot may change. It is just a slot as a temporary buffer to temporarily store the number that is not in its final place. Let\\'s call the number as **_the buffered number_**.\\n\\nUse another dynamic index `j` to indicate the final place for the number that is currently in the buffer slot `nums[i]`.\\n\\nIn the while-loop, we find the correct final place for the buffered number. Kick out the number that is currently in `nums[j]` because it is not the correct final place for it. `nums[j]` is the final slot for the buffered number. OK, now the buffered number finds its final place, but how about the number that was just kicked out from `nums[j]`? No worries, longly kid, we will find a temporary shelter for you -- that is the slot `nums[i]`. We already found the final place for the buffered number, so it doesn\\'t have to be buffered any more. `nums[i]` now buffers the kicked-out number.\\n\\nThen we continue help the new buffered to find its final place. Until the buffered number\\'s final place is `nums[i]` it self.\\n\\n## **Time Complexity Analysis**\\n----\\n\\nThis algorithm time complexity is O(n), because every run of the while-loop body will find out the final place for one number. There are O(n) numbers, so the algorithm time complexity is O(n).\\n\\n\\n## **Ruby Code**\\n----\\n```\\n# @param {Integer[]} nums\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef shuffle(nums, n)\\n    for i in (0...nums.size)\\n        j = i\\n        while nums[i] >= 0\\n            j = j < n ? j * 2 : (j - n) * 2 + 1\\n            nums[i], nums[j] = nums[j], -nums[i]\\n        end\\n    end\\n    for i in (0...nums.size)\\n        nums[i] = -nums[i]\\n    end\\n    nums\\nend\\n```\\n\\n## **JavaScript Code**\\n----\\nIf the trick imagining `nums[i]` as a buffer slot still doesn\\'t make much sense to you, let\\'s explicitly allocate one more O(1) space `buffer`.\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    for (var i = 0; i < nums.length; i++) {\\n        var j = i;\\n        var buffer = nums[i];\\n        while (buffer >= 0) {\\n            j = j < n ? j * 2 : (j - n) * 2 + 1;\\n            var tmp = buffer; buffer = nums[j]; nums[j] = -tmp;\\n        }\\n    }\\n    for (var i = 0; i < nums.length; i++) {\\n        nums[i] *= -1;\\n    }\\n    return nums;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n# @param {Integer[]} nums\\n# @param {Integer} n\\n# @return {Integer[]}\\ndef shuffle(nums, n)\\n    for i in (0...nums.size)\\n        j = i\\n        while nums[i] >= 0\\n            j = j < n ? j * 2 : (j - n) * 2 + 1\\n            nums[i], nums[j] = nums[j], -nums[i]\\n        end\\n    end\\n    for i in (0...nums.size)\\n        nums[i] = -nums[i]\\n    end\\n    nums\\nend\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    for (var i = 0; i < nums.length; i++) {\\n        var j = i;\\n        var buffer = nums[i];\\n        while (buffer >= 0) {\\n            j = j < n ? j * 2 : (j - n) * 2 + 1;\\n            var tmp = buffer; buffer = nums[j]; nums[j] = -tmp;\\n        }\\n    }\\n    for (var i = 0; i < nums.length; i++) {\\n        nums[i] *= -1;\\n    }\\n    return nums;\\n};\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3127426,
                "title": "o-1-sc-o-n-tc-c-easy-multiplication-and-modular-tricks",
                "content": "# Intuition\\nThe idea is to use multiplication and modular tricks to store two elements at the same index. \\nObserve the below example :\\n\\n![image.png](https://assets.leetcode.com/users/images/2feef461-e5fc-4552-81ab-9b9c84860169_1675261153.952608.png)\\n\\nWe will use the same approach to solve the problem.\\n\\n# Approach\\n- Initialize two pointers first = 0 and second = n , where N is the size of the array.\\n- Initialise an element max equal to 1 + maximum element of the array and since it is given that maximum value can be 10^3 so we can use 1001. \\n- Note: You can initialise max to any integer greater than 1000. \\n- Iterate over the array and perform the following operations:\\n- - If the current index is even:\\n- - - Update A[i] = A[i] + (A[first] % mx) * mx\\n- - - Increment first by 1.\\n- - If the current index is odd:\\n- - - Update A[i] = A[i] + (A[second] % mx) * mx\\n- - - Increment second by 1.\\n- To update the array element back to its original form, divide A[i] by max.\\n\\n# Complexity\\n- Time complexity : O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity : O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int first = 0, second = n, max = 1001;\\n        for(int i=0;i<2*n;i++)\\n        {\\n            if(i%2==0)\\n            nums[i]=(nums[first++]%max)*max + nums[i];\\n            else\\n            nums[i]=(nums[second++]%max)*max + nums[i];\\n        }\\n        for(int i=0;i<2*n;i++)\\n        nums[i]/=max;\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int first = 0, second = n, max = 1001;\\n        for(int i=0;i<2*n;i++)\\n        {\\n            if(i%2==0)\\n            nums[i]=(nums[first++]%max)*max + nums[i];\\n            else\\n            nums[i]=(nums[second++]%max)*max + nums[i];\\n        }\\n        for(int i=0;i<2*n;i++)\\n        nums[i]/=max;\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684649,
                "title": "o-n-time-o-1-space-no-bitwise-cheating-beats-99-7-time-and-beats-100-space",
                "content": "Two rules: \\nith element  -> 2ith element in new array\\ni + n th element -> 2i + 1 th element in the new array\\n\\nAdjust the array backwards,\\nFor each step, consider ith element\\nBefore the ith element, the array is ordered by orgianial order\\nAfter the ith element, the array is ordered by new order\\nFor the ith element, find the proper element using the two rules\\n\\nC++ version\\n```\\n\\nclass Solution {\\npublic:\\n   vector<int> shuffle(vector<int>& nums, int n) {\\n       for (int i = 2*n-1; i > 0; i--) {\\n           int k = i;\\n           do {\\n               if (k % 2 == 1)\\n                   k = k/2 + n;\\n               else\\n                   k = k/2;\\n           } while (k > i);\\n           swap(nums[i], nums[k]);\\n       }\\n       return nums;\\n   }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n   vector<int> shuffle(vector<int>& nums, int n) {\\n       for (int i = 2*n-1; i > 0; i--) {\\n           int k = i;\\n           do {\\n               if (k % 2 == 1)\\n                   k = k/2 + n;\\n               else\\n                   k = k/2;\\n           } while (k > i);\\n           swap(nums[i], nums[k]);\\n       }\\n       return nums;\\n   }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1532727,
                "title": "easy-c-solution-with-few-lines-of-code",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistakes please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n## Code:\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector <int> ans;\\n        for(int i=0; i<n; i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n---\\n***Please upvote if it was helpful for you, thank you!***",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector <int> ans;\\n        for(int i=0; i<n; i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 909259,
                "title": "java-in-place-o-n-time-and-o-1-space",
                "content": "Intuition: Store the number pairs in the right half of the array. Iterate and put pairs in proper positions.\\n\\nQ) How to store 2 numbers in the same array cell?\\nA) If there are two numbers n1 and n2, one could come up with a larger number M (greater than both n1 and n2) and store a single number having value V = M\\\\*n1+n2. Later on, if we want to extract the 2 numbers from V, we can do so like so,\\n\\n```\\nn1 = V/M\\nn2 = V%M\\n```\\n\\nSince given array numbers are between 1 and 1000, this method won\\'t give an overflow.\\n\\nCode:\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int max = 1001; // M in the above explanation\\n        \\n\\t\\t//Store number pairs in right half\\n        for(int i=n;i<nums.length;i++){\\n            nums[i] = max*nums[i]+nums[i-n];\\n        }\\n        \\n\\t\\t//Put pairs in proper positions\\n        int ind = 0;\\n        for(int i=n;i<nums.length;i++){\\n            nums[ind] = nums[i]%max;\\n            nums[ind+1] = nums[i]/max;\\n            ind+=2;\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nn1 = V/M\\nn2 = V%M\\n```\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int max = 1001; // M in the above explanation\\n        \\n\\t\\t//Store number pairs in right half\\n        for(int i=n;i<nums.length;i++){\\n            nums[i] = max*nums[i]+nums[i-n];\\n        }\\n        \\n\\t\\t//Put pairs in proper positions\\n        int ind = 0;\\n        for(int i=n;i<nums.length;i++){\\n            nums[ind] = nums[i]%max;\\n            nums[ind+1] = nums[i]/max;\\n            ind+=2;\\n        }\\n        \\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 674426,
                "title": "python-very-simple-solution",
                "content": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        ## APPROACH : GREEDY ##\\n        ans = []\\n        for i in range(n):\\n            ans.append(nums[i])\\n            ans.append(nums[i+n])\\n        return ans\\n            \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        ## APPROACH : GREEDY ##\\n        ans = []\\n        for i in range(n):\\n            ans.append(nums[i])\\n            ans.append(nums[i+n])\\n        return ans\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 674400,
                "title": "java-python-3-straight-forward-code",
                "content": "Pattern: `i -> 2 * i`, `i + n -> 2 * i + 1`\\n\\n```java\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[ 2 * n];\\n        for (int i = 0; i < n; ++i) {\\n            ans[2 * i] = nums[i];\\n            ans[2 * i + 1] = nums[i + n];\\n        }\\n        return ans;\\n    }\\n```\\nOr\\n```java\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2 * n];\\n        for (int i = 0; i < 2 * n; ++i) {\\n            ans[i] = nums[i / 2 + i % 2 * n];\\n        }\\n        return ans;\\n    }\\n```\\nOr\\n```java\\n    public int[] shuffle(int[] nums, int n) {\\n        return IntStream.range(0, 2 * n).map(i -> nums[i / 2 + i % 2 * n]).toArray();\\n    }\\n```\\n\\n```python\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return [nums[i // 2 + i % 2 * n] for i in range(2 * n)]\\n```\\nOr better readability at a cost of space O(n): - credit to **@ggplay**\\n\\n```python\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return [num for tup in zip(nums[: n], nums[n :]) for num in tup]\\n```",
                "solutionTags": [],
                "code": "```java\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[ 2 * n];\\n        for (int i = 0; i < n; ++i) {\\n            ans[2 * i] = nums[i];\\n            ans[2 * i + 1] = nums[i + n];\\n        }\\n        return ans;\\n    }\\n```\n```java\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2 * n];\\n        for (int i = 0; i < 2 * n; ++i) {\\n            ans[i] = nums[i / 2 + i % 2 * n];\\n        }\\n        return ans;\\n    }\\n```\n```java\\n    public int[] shuffle(int[] nums, int n) {\\n        return IntStream.range(0, 2 * n).map(i -> nums[i / 2 + i % 2 * n]).toArray();\\n    }\\n```\n```python\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return [nums[i // 2 + i % 2 * n] for i in range(2 * n)]\\n```\n```python\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return [num for tup in zip(nums[: n], nums[n :]) for num in tup]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1620167,
                "title": "java-easy-solution-o-n",
                "content": "**Upvote! If you like the solution**\\n\\nisn\\'t it easy?\\n\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       \\n        int[] ans = new int[2*n];\\n        \\n        for(int i=0;i<n;i++){\\n            ans[2*i]=nums[i];\\n            ans[2*i+1]=nums[i+n];\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       \\n        int[] ans = new int[2*n];\\n        \\n        for(int i=0;i<n;i++){\\n            ans[2*i]=nums[i];\\n            ans[2*i+1]=nums[i+n];\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 831420,
                "title": "python-3-2-solutions-with-slight-change",
                "content": "**Suggestions to make it better are always welcomed.**\\n\\nWe traverse the list till the for n elements. Time = O(n) = O(N/2) = O(N)\\n\\n**Solution 1:**\\n```\\ndef shuffle(self, nums: List[int], n: int) -> List[int]:\\n\\tresult = [float(\"-inf\") for i in range(2*n)]        \\n\\tfor i in range(n):\\n\\t\\tresult[(2*i)] = nums[i]\\n\\t\\tresult[(2*i)+1] = nums[n+i]\\n\\treturn result\\n```\\n\\n**Solution 2:**\\n```\\t\\ndef shuffle(self, nums: List[int], n: int) -> List[int]:\\n\\tresult = []\\n\\tfor i in range(n):\\n\\t\\tresult.append(nums[i])\\n\\t\\tresult.append(nums[n+i])\\n\\treturn result\\t\\n```\\n\\n**I hope that you\\'ve found this useful.\\nIn that case, please upvote. It only motivates me to write more such posts\\uD83D\\uDE03**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef shuffle(self, nums: List[int], n: int) -> List[int]:\\n\\tresult = [float(\"-inf\") for i in range(2*n)]        \\n\\tfor i in range(n):\\n\\t\\tresult[(2*i)] = nums[i]\\n\\t\\tresult[(2*i)+1] = nums[n+i]\\n\\treturn result\\n```\n```\\t\\ndef shuffle(self, nums: List[int], n: int) -> List[int]:\\n\\tresult = []\\n\\tfor i in range(n):\\n\\t\\tresult.append(nums[i])\\n\\t\\tresult.append(nums[n+i])\\n\\treturn result\\t\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1104446,
                "title": "javascript-faster-than-98-99-simple",
                "content": "```\\nvar shuffle = function(nums, n) {\\n    let res = []\\n    for(let i=0; i < n; i++){  \\n        res.push(nums[i])\\n        res.push(nums[i+n])\\n    }\\n    return res \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shuffle = function(nums, n) {\\n    let res = []\\n    for(let i=0; i < n; i++){  \\n        res.push(nums[i])\\n        res.push(nums[i+n])\\n    }\\n    return res \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3149340,
                "title": "putta-easy-solution-c-o-1-space-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1b)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        \\n    for(int i=0;i<n;i++){\\n        nums[i] = nums[i]<<10; // Left shifting xi by 10 bits \\n        nums[i] = nums[i] | nums[i+n]; //Adding yi to xi \\n    }\\n    int j = 2*n-1;\\n    for(int i = n-1;i>-1;i--,j = j-2)\\n    {\\n        int x = nums[i] >> 10; // Extracting xi by Right shifting 10 bits \\n        int y = nums[i] & ((1024) -1); // Extracting yi by & on LSB 10 bits \\n        nums[j] = y;\\n        nums[j-1] = x;\\n      \\n    }\\n    return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        \\n    for(int i=0;i<n;i++){\\n        nums[i] = nums[i]<<10; // Left shifting xi by 10 bits \\n        nums[i] = nums[i] | nums[i+n]; //Adding yi to xi \\n    }\\n    int j = 2*n-1;\\n    for(int i = n-1;i>-1;i--,j = j-2)\\n    {\\n        int x = nums[i] >> 10; // Extracting xi by Right shifting 10 bits \\n        int y = nums[i] & ((1024) -1); // Extracting yi by & on LSB 10 bits \\n        nums[j] = y;\\n        nums[j-1] = x;\\n      \\n    }\\n    return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 865856,
                "title": "java-two-pointer-verbose-code",
                "content": "* **Please upvote if helpful!!**\\n\\n```\\npublic int[] shuffle(int[] nums, int n) {\\n\\n        int[] result = new int[nums.length];\\n\\n        int leftPointer = 0;\\n        int rightPointer = n;\\n\\n        int index = 0;\\n\\n        while (rightPointer < nums.length) {\\n\\n            result[index] = nums[leftPointer];\\n            result[index + 1] = nums[rightPointer];\\n\\n            leftPointer++;\\n            rightPointer++;\\n            index = index + 2;\\n\\n\\n        }\\n\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] shuffle(int[] nums, int n) {\\n\\n        int[] result = new int[nums.length];\\n\\n        int leftPointer = 0;\\n        int rightPointer = n;\\n\\n        int index = 0;\\n\\n        while (rightPointer < nums.length) {\\n\\n            result[index] = nums[leftPointer];\\n            result[index + 1] = nums[rightPointer];\\n\\n            leftPointer++;\\n            rightPointer++;\\n            index = index + 2;\\n\\n\\n        }\\n\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3148790,
                "title": "python-3-1-line-sorry-but-w-detailed-example-t-m-98-44",
                "content": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n                                                        #  Example: [2,5,1,3,4,7      n = 3\\n        \\n        return list(chain(*zip(nums[:n],nums[n:])))     # list(chain(*zip([2,5,1],nums[3,4,7])))\\n                                                        # list(chain(*[(2,3), (5,4), (1,7)])\\n                                                        # list(chain((2,3), (5,4), (1,7))\\n                                                        # list(2,3, 5,4, 1,7)\\n                                                        # [2,3,5,4,1,7]\\n```\\n[https://leetcode.com/problems/shuffle-the-array/submissions/892368758/](http://)\\n\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n                                                        #  Example: [2,5,1,3,4,7      n = 3\\n        \\n        return list(chain(*zip(nums[:n],nums[n:])))     # list(chain(*zip([2,5,1],nums[3,4,7])))\\n                                                        # list(chain(*[(2,3), (5,4), (1,7)])\\n                                                        # list(chain((2,3), (5,4), (1,7))\\n                                                        # list(2,3, 5,4, 1,7)\\n                                                        # [2,3,5,4,1,7]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1025666,
                "title": "simple-1-liner-in-python-faster-than-99",
                "content": "#### Code\\n\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return [j for i in zip(nums[:n], nums[n:]) for j in i]\\n```\\n\\n#### Explanation:\\n\\n- `zip(nums[:n], nums[n:]` will return `[(x1, y1), (x2, y2), ...]`.\\n- `[j for i in two_dimensional_list for j in i]` will flatten the 2d array to give `[x1, y1, x2, y2, ...]`.",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return [j for i in zip(nums[:n], nums[n:]) for j in i]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1153854,
                "title": "swift-shuffle-the-array",
                "content": "**Well, it\\'s a classic.**\\n**If you have a solution easier than this, please share :)**\\n\\n```swift\\nclass Solution {\\n    func shuffle(_ nums: [Int], _ n: Int) -> [Int] {\\n        var res = [Int]()\\n        for i in 0..<n {\\n            res.append(nums[i])\\n            res.append(nums[i + n])\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func shuffle(_ nums: [Int], _ n: Int) -> [Int] {\\n        var res = [Int]()\\n        for i in 0..<n {\\n            res.append(nums[i])\\n            res.append(nums[i + n])\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 941186,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(nums[i]);\\n            v.push_back(nums[n+i]);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> v;\\n        for(int i=0;i<n;i++)\\n        {\\n            v.push_back(nums[i]);\\n            v.push_back(nums[n+i]);\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148543,
                "title": "beats-100-simple-and-in-place-with-video-java-c-python",
                "content": "# Simple Approach\\n1. Create a new array of size 2n.\\n2. The first half of the array is taking even places i.e res[2*i] = A[i]\\n3. The second half of the array is taking odd places i.e res[2*i+1]=A[n+i]\\n\\n![image](https://assets.leetcode.com/users/images/71a69a22-faed-4f9b-8f07-383b71a19832_1675647440.577359.jpeg)\\n\\n\\n```\\n\\tpublic int[] shuffle(int[] nums, int n) {\\n        int[] result = new int[2 * n];\\n        for (int i = 0; i < n; ++i) {\\n            result[2 * i] = nums[i];\\n            result[2 * i + 1] = nums[n + i];\\n        }\\n        return result;\\n    }\\n```\\n\\nHowever if you are preparing for intense Interviews. \\n\\n# In Place Hashing\\nThe core idea of this algorithm is to store 2 numbers together and extract them later. \\n\\n![image](https://assets.leetcode.com/users/images/c3b8e6e8-d1b0-4743-ae35-39e3c0dfdc36_1675647493.4934015.jpeg)\\n\\n5 and 3 for example: 3*10 +5 = 35 so whenever we want 5 its 35%5 and whenever we want 3 its 35/3.\\n\\nBut 10 is a small number and the given range is 1000, so we can use 10000 in place of 10.\\n\\n1. Have 2 pointers first = 0 and second = n Iterate over the array.\\n2.  if i is even nums[i]=(nums[first++]%max)*max + nums[i];\\n3.  if i is odd nums[i]=(nums[second++]%max)*max + nums[i];\\n4. . Divide the entire array by 10000\\n\\n\\n\\nhttps://youtu.be/sSW_MZZXIDY\\n\\n![image](https://assets.leetcode.com/users/images/0c94cf04-382e-4de0-b162-1a1fcfa2450a_1675647862.7321172.jpeg)\\n\\n\\n```\\npublic int[] shuffle(int[] nums, int n) {\\n        int first = 0, second = n, max = 10000;\\n        for(int i=0;i<2*n;i++)\\n        {\\n            if(i%2==0)\\n            nums[i]=(nums[first++]%max)*max + nums[i];\\n            else\\n            nums[i]=(nums[second++]%max)*max + nums[i];\\n        }\\n        for(int i=0;i<2*n;i++)\\n        nums[i]/=max;\\n        return nums;\\n    }\\n```\\n\\n```\\nvector<int> shuffle(vector<int>& nums, int n) {\\n    int first = 0, second = n, max = 10000;\\n    for(int i=0;i<2*n;i++) {\\n        if(i%2==0)\\n        nums[i]= (nums[first++]%max)*max + nums[i];\\n        else\\n        nums[i]= (nums[second++]%max)*max + nums[i];\\n    }\\n    for(int i=0;i<2*n;i++)\\n        nums[i]/=max;\\n    return nums;\\n}\\n```\\n\\n```\\nclass Solution:\\n    def shuffle(self, nums, n):\\n        first = 0\\n        second = n\\n        max_val = 10000\\n        for i in range(2 * n):\\n            if i % 2 == 0:\\n                nums[i] = (nums[first] % max_val) * max_val + nums[i]\\n                first += 1\\n            else:\\n                nums[i] = (nums[second] % max_val) * max_val + nums[i]\\n                second += 1\\n        for i in range(2 * n):\\n            nums[i] = nums[i] // max_val\\n        return nums\\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\n\\tpublic int[] shuffle(int[] nums, int n) {\\n        int[] result = new int[2 * n];\\n        for (int i = 0; i < n; ++i) {\\n            result[2 * i] = nums[i];\\n            result[2 * i + 1] = nums[n + i];\\n        }\\n        return result;\\n    }\\n```\n```\\npublic int[] shuffle(int[] nums, int n) {\\n        int first = 0, second = n, max = 10000;\\n        for(int i=0;i<2*n;i++)\\n        {\\n            if(i%2==0)\\n            nums[i]=(nums[first++]%max)*max + nums[i];\\n            else\\n            nums[i]=(nums[second++]%max)*max + nums[i];\\n        }\\n        for(int i=0;i<2*n;i++)\\n        nums[i]/=max;\\n        return nums;\\n    }\\n```\n```\\nvector<int> shuffle(vector<int>& nums, int n) {\\n    int first = 0, second = n, max = 10000;\\n    for(int i=0;i<2*n;i++) {\\n        if(i%2==0)\\n        nums[i]= (nums[first++]%max)*max + nums[i];\\n        else\\n        nums[i]= (nums[second++]%max)*max + nums[i];\\n    }\\n    for(int i=0;i<2*n;i++)\\n        nums[i]/=max;\\n    return nums;\\n}\\n```\n```\\nclass Solution:\\n    def shuffle(self, nums, n):\\n        first = 0\\n        second = n\\n        max_val = 10000\\n        for i in range(2 * n):\\n            if i % 2 == 0:\\n                nums[i] = (nums[first] % max_val) * max_val + nums[i]\\n                first += 1\\n            else:\\n                nums[i] = (nums[second] % max_val) * max_val + nums[i]\\n                second += 1\\n        for i in range(2 * n):\\n            nums[i] = nums[i] // max_val\\n        return nums\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1099699,
                "title": "without-extra-space-93-less-space-python-3",
                "content": "I think this was asked in facebook once. \\nHere TC is not that important. SC is what matters.\\nLogic: \\nWe need to store 2 numbers in one place. the actual number and the shuffled number. \\nBut if we directly shuffle, we will lose the actual number. So we can multiple the actual with a factor and add shuffled to it. \\nActual = a1\\nShuffled = a2\\nWe take some multiplication factor that\\'s greater than maximum limit of num[i]\\nso here in this case take 1001.\\nTo store both numbers use x[i] = a1* 1001  + a2\\nto find a1 we take x[i]//1001 (or take the number as it is , if its havent been changed yet)\\nfinally we retrieve the result using  a2 = x[i]%1001\\n\\n\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        maximum = 1001\\n        i ,j, k = 0, n, 0\\n\\t\\t#update the array to convert nums[i] to x[i]\\n        while k<len(nums):\\n            a1 = nums[k] if nums[k]//maximum == 0 else nums[k]//maximum\\n            if k&1:\\n                a2 = nums[j] if nums[j]//maximum == 0 else nums[j]//maximum\\n                j+=1\\n            else:\\n                a2 = nums[i] if nums[i]//maximum == 0 else nums[i]//maximum\\n                i+=1\\n            nums[k] = a1* maximum + a2\\n            k+=1\\n\\t\\t#convert x[i] to shuffled\\n        for i in range(len(nums)):\\n            nums[i]= nums[i]%maximum\\n        return nums\\n                \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        maximum = 1001\\n        i ,j, k = 0, n, 0\\n\\t\\t#update the array to convert nums[i] to x[i]\\n        while k<len(nums):\\n            a1 = nums[k] if nums[k]//maximum == 0 else nums[k]//maximum\\n            if k&1:\\n                a2 = nums[j] if nums[j]//maximum == 0 else nums[j]//maximum\\n                j+=1\\n            else:\\n                a2 = nums[i] if nums[i]//maximum == 0 else nums[i]//maximum\\n                i+=1\\n            nums[k] = a1* maximum + a2\\n            k+=1\\n\\t\\t#convert x[i] to shuffled\\n        for i in range(len(nums)):\\n            nums[i]= nums[i]%maximum\\n        return nums\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 840292,
                "title": "rust-solution",
                "content": "```rust\\nimpl Solution {\\n    pub fn shuffle(nums: Vec<i32>, n: i32) -> Vec<i32> {\\n        nums[..n as usize]\\n            .iter()\\n            .zip(nums[n as usize..].iter())\\n            .flat_map(|(&x, &y)| vec![x, y])\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn shuffle(nums: Vec<i32>, n: i32) -> Vec<i32> {\\n        nums[..n as usize]\\n            .iter()\\n            .zip(nums[n as usize..].iter())\\n            .flat_map(|(&x, &y)| vec![x, y])\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 736116,
                "title": "javascript-solution",
                "content": "This is my Javascript solution:\\n\\n```\\nvar shuffle = function(nums, n) {\\n    let result = [];\\n    for(let i = 0; i < n; i++){\\n        result.push(nums[i]);\\n        result.push(nums[i+n]);   \\n    }\\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar shuffle = function(nums, n) {\\n    let result = [];\\n    for(let i = 0; i < n; i++){\\n        result.push(nums[i]);\\n        result.push(nums[i+n]);   \\n    }\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 677669,
                "title": "javascript-one-liner-with-map",
                "content": "```\\n(nums, n) => nums.map((x, i) => i % 2 === 0 ? nums[i / 2] : nums[n + (i - 1) / 2])\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n(nums, n) => nums.map((x, i) => i % 2 === 0 ? nums[i / 2] : nums[n + (i - 1) / 2])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 982795,
                "title": "coderaky-soultion",
                "content": "Leetcode c++ Solutions \\uD83D\\uDE4C\\nhttps://github.com/coderaky/leetcoder\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> res;\\n        for(int i=0;i<n;i++){\\n            res.push_back(nums[i]);\\n            res.push_back(nums[n+i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> res;\\n        for(int i=0;i<n;i++){\\n            res.push_back(nums[i]);\\n            res.push_back(nums[n+i]);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 815592,
                "title": "in-place-time-o-n-memory-o-1",
                "content": "\\n\\n***Packing***:  in the upper 16 bits of the first N elements we put the original value Xi , and in the lower 16 bits - Yi, where  i = 0, ... , N\\n```\\nnums: |  X1   |  X2   |  X3   |  X4   |  Y1   |   Y2   |    Y3   |   Y4   |\\n =>   | x1 y1 | x2 y2 | x3 y3 | x4 y4 |  Y1   |   Y2   |    Y3   |   Y4   |\\n```\\n***Unpacking***: starting from position N, we perform bitwise operations (& and >>) for the first N elements, and the resulting pair values are entered into the current end. After processing each element from the first half of the array, we update the corresponding end indices.\\n\\n\\n```\\nstd::vector<int> shuffle(std::vector<int>& nums, int n) {\\n\\tint endY = 2 * n - 1;\\n\\tint endX = n - 1;\\n\\n\\tfor (int i = endX, j = endY; i >= 0; i--, j--) {\\n\\t\\tnums[i] <<= 0x10;   // shl on 16 bits\\n\\t\\tnums[i] |= nums[j];\\n\\t}\\n\\t\\n\\tfor (int i = endX, j = endY; i >= 0; i--, j -= 2) {        \\n\\t\\tnums[j]     = nums[i] & 0xFFFF;  // x & mask, where mask is 1111 1111 1111 1111 \\n\\t\\tnums[j - 1] = nums[i] >> 0x10;   // shr on 16 bits\\n\\t}\\n\\treturn nums;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nnums: |  X1   |  X2   |  X3   |  X4   |  Y1   |   Y2   |    Y3   |   Y4   |\\n =>   | x1 y1 | x2 y2 | x3 y3 | x4 y4 |  Y1   |   Y2   |    Y3   |   Y4   |\\n```\n```\\nstd::vector<int> shuffle(std::vector<int>& nums, int n) {\\n\\tint endY = 2 * n - 1;\\n\\tint endX = n - 1;\\n\\n\\tfor (int i = endX, j = endY; i >= 0; i--, j--) {\\n\\t\\tnums[i] <<= 0x10;   // shl on 16 bits\\n\\t\\tnums[i] |= nums[j];\\n\\t}\\n\\t\\n\\tfor (int i = endX, j = endY; i >= 0; i--, j -= 2) {        \\n\\t\\tnums[j]     = nums[i] & 0xFFFF;  // x & mask, where mask is 1111 1111 1111 1111 \\n\\t\\tnums[j - 1] = nums[i] >> 0x10;   // shr on 16 bits\\n\\t}\\n\\treturn nums;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 674365,
                "title": "clean-python-3-generator-and-one-liner",
                "content": "Time: `O(N)`\\nSpace: `O(N)` for output list\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        def gen(A):\\n            for i in range(n): \\n                yield from (A[i], A[i+n])\\n        return list(gen(nums))\\n```\\n\\nOne liner:\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return sum(([nums[i], nums[i+n]] for i in range(n)), [])\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        def gen(A):\\n            for i in range(n): \\n                yield from (A[i], A[i+n])\\n        return list(gen(nums))\\n```\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return sum(([nums[i], nums[i+n]] for i in range(n)), [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1471154,
                "title": "c-in-place-o-1-example-added",
                "content": "I got this solution from one of the most upvoted solutions, and I must say that person has amazing observation skills, using one of the constaraints that no element > 1000 to devise the solution, is honestly beyond my intelligence as of now. I have included the result of dry run as comments.\\n\\n```\\nvector<int> shuffle(vector<int> nums, int val) {\\n        // nums = [2,5,1,3,4,7], n=3\\n        \\n        for(int i = 0; i < val; i++)  nums[i] += nums[val + i] * 10000;\\n        \\n        //After 1st loop: [30002,40005,70001,3,4,7]\\n       \\n        for(int i = val - 1; i >= 0; i--){\\n            //i starts at i=2\\n            \\n            nums[2 * i + 1] = nums[i] / 10000;\\n            //nums[5] = nums[2]/10000 = 70001/10000 = 7\\n\\t\\t\\t//nums[3] = 4\\n\\t\\t\\t//nums[1] = 3\\n            \\n            nums[2 * i] = nums[i] % 10000;\\n            //nums[4] = nums[2]/10000 = 70001 % 10000 = 1 \\n\\t\\t\\t//nums[2] = 5\\n\\t\\t\\t//nums[0] = 2\\n        }\\n        return nums;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvector<int> shuffle(vector<int> nums, int val) {\\n        // nums = [2,5,1,3,4,7], n=3\\n        \\n        for(int i = 0; i < val; i++)  nums[i] += nums[val + i] * 10000;\\n        \\n        //After 1st loop: [30002,40005,70001,3,4,7]\\n       \\n        for(int i = val - 1; i >= 0; i--){\\n            //i starts at i=2\\n            \\n            nums[2 * i + 1] = nums[i] / 10000;\\n            //nums[5] = nums[2]/10000 = 70001/10000 = 7\\n\\t\\t\\t//nums[3] = 4\\n\\t\\t\\t//nums[1] = 3\\n            \\n            nums[2 * i] = nums[i] % 10000;\\n            //nums[4] = nums[2]/10000 = 70001 % 10000 = 1 \\n\\t\\t\\t//nums[2] = 5\\n\\t\\t\\t//nums[0] = 2\\n        }\\n        return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1393426,
                "title": "c-pure-logic-6lines",
                "content": "///\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n\\t\\n        vector<int> res(nums.size());\\n        int i=0,j=n;\\n        for(int k=0;k<nums.size();k++){\\n            if(k%2==0)\\n                res[k]=nums[i++];\\n            else\\n                res[k]=nums[j++];\\n        }\\n        return res;\\n        \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n\\t\\n        vector<int> res(nums.size());\\n        int i=0,j=n;\\n        for(int k=0;k<nums.size();k++){\\n            if(k%2==0)\\n                res[k]=nums[i++];\\n            else\\n                res[k]=nums[j++];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 691824,
                "title": "java-runtime-0-ms-100-faster",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int num = nums.length;\\n        int[] a = new int[num];\\n        int index = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n           a[index] = nums[i];\\n           index++;\\n           a[index] = nums[i+n];\\n           index++; \\n       }\\n        return a;\\n    }\\n}\\n\\nP.S If you find it helpful do upvote.\\n:)",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int num = nums.length;\\n        int[] a = new int[num];\\n        int index = 0;\\n        for(int i = 0; i < n; i++)\\n        {\\n           a[index] = nums[i];\\n           index++;\\n           a[index] = nums[i+n];\\n           index++; \\n       }",
                "codeTag": "Java"
            },
            {
                "id": 3148452,
                "title": "python3-56-ms-faster-than-94-54-of-python3",
                "content": "![image](https://assets.leetcode.com/users/images/9b4c5457-47dd-42a3-9a62-b4bd318df0fc_1675644643.8485587.png)\\n\\n```\\ndef shuffle(self, nums: List[int], n: int) -> List[int]:\\n        ls=[]\\n        for i in range(n):\\n            ls+=[nums[i]]\\n            ls+=[nums[i+n]]\\n        return ls\\n```\\nHere\\'s a step by step description of the code:\\n1. Initialize an empty list ls to store the shuffled elements.\\n1. Loop through nums by incrementing the index i from 0 to n-1.\\n1. For each iteration of the loop, add the element at index i in nums to ls using ls += [nums[i]].\\n1. After that, add the element at index i + n in nums to ls using ls += [nums[i + n]].\\n1. Repeat steps 3 and 4 for all iterations of the loop until i is equal to n-1.\\n1. After the loop, return the ls list as the shuffled result in the form [x1, y1, x2, y2, ..., xn, yn].",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef shuffle(self, nums: List[int], n: int) -> List[int]:\\n        ls=[]\\n        for i in range(n):\\n            ls+=[nums[i]]\\n            ls+=[nums[i+n]]\\n        return ls\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3149696,
                "title": "bitmasking-approach-to-solve-1470-shuffle-the-array",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(N)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Approach\\n We will encode the y(i) and x(i) with in first n number of places via bitmusking . Then will decode them in there exact places \\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int tenBitNum = pow(2,10)-1;  // Geting a 10 bit number to extract the First encoded number \\n        for(int i=0;i<n;i++){   // encoding the the y(i) and x(i) number in the i th index \\n            int secNum = nums[n+i] << 10 ;\\n             nums[i] = nums[i] | secNum ; \\n        }\\n        for(int i = n - 1  ; i >= 0 ; i-- ){   // decoding the the y(i) and x(i) number in the i th index \\n            nums[2*i + 1] = nums[i] >> 10 ;\\n            nums[2*i] =  nums[i] & tenBitNum ;\\n        }\\n        return nums ;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int tenBitNum = pow(2,10)-1;  // Geting a 10 bit number to extract the First encoded number \\n        for(int i=0;i<n;i++){   // encoding the the y(i) and x(i) number in the i th index \\n            int secNum = nums[n+i] << 10 ;\\n             nums[i] = nums[i] | secNum ; \\n        }\\n        for(int i = n - 1  ; i >= 0 ; i-- ){   // decoding the the y(i) and x(i) number in the i th index \\n            nums[2*i + 1] = nums[i] >> 10 ;\\n            nums[2*i] =  nums[i] & tenBitNum ;\\n        }\\n        return nums ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148580,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "<iframe src=\"https://leetcode.com/playground/kFBKTVFH/shared\" frameBorder=\"0\" width=\"100%\" height=\"350\"></iframe>",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "<iframe src=\"https://leetcode.com/playground/kFBKTVFH/shared\" frameBorder=\"0\" width=\"100%\" height=\"350\"></iframe>",
                "codeTag": "Unknown"
            },
            {
                "id": 2667752,
                "title": "java-beginner-easy-to-understand",
                "content": "upvote if this code helped\\n\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n        for(int i=0;i<n;i++){\\n            \\n            ans[2*i]= nums[i];\\n            ans[2*i+1]=nums[i+n];\\n        }\\n        return ans;\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n        for(int i=0;i<n;i++){\\n            \\n            ans[2*i]= nums[i];\\n            ans[2*i+1]=nums[i+n];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2192036,
                "title": "java-easy-solution",
                "content": "plz upvote if u like the solution\\n\\n\\t\\n\\t\\t\\t\\tclass Solution {\\n\\t\\t\\t\\t\\tpublic int[] shuffle(int[] nums, int n) {\\n\\t\\t\\t\\t\\t\\tint [] ans = new int[2*n];\\n\\t\\t\\t\\t\\tint i = 0;\\n\\t\\t\\t\\t\\t int left = 0;\\n\\t\\t\\t\\t\\tint right = n;\\n\\n\\t\\t\\t\\t\\twhile(left < n){\\n\\t\\t\\t\\t\\t\\tans[i++] = nums[left++];\\n\\t\\t\\t\\t\\t\\tans[i++] = nums[right++];\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\treturn ans;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n\\t\\t\\t\\t\\tpublic int[] shuffle(int[] nums, int n) {\\n\\t\\t\\t\\t\\t\\tint [] ans = new int[2*n];\\n\\t\\t\\t\\t\\tint i = 0;\\n\\t\\t\\t\\t\\t int left = 0;\\n\\t\\t\\t\\t\\tint right = n;\\n\\n\\t\\t\\t\\t\\twhile(left < n){\\n\\t\\t\\t\\t\\t\\tans[i++] = nums[left++];\\n\\t\\t\\t\\t\\t\\tans[i++] = nums[right++];\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 941189,
                "title": "simple-python-solution",
                "content": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        l=[]\\n        for i in range(n):\\n            l.append(nums[i])\\n\\t\\t\\tl.append(nums[n+i])\\n        return l\\n```\\n\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        l=[]\\n        for i in range(n):\\n            l.extend([nums[i],nums[i+1]])\\n        return l\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        l=[]\\n        for i in range(n):\\n            l.append(nums[i])\\n\\t\\t\\tl.append(nums[n+i])\\n        return l\\n```\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        l=[]\\n        for i in range(n):\\n            l.extend([nums[i],nums[i+1]])\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 723993,
                "title": "java-in-place-swap-without-using-additional-array",
                "content": "```\\npublic int[] shuffle(int[] nums, int n) {\\n        //No additional memory, swap the elements\\n        \\n\\t\\t//1st loop \\n\\t\\t//First & last elements in correct poistion. Go from 2nd till Nth element  i.e. loop will execute N-1 times. \\n\\t\\t//Swap ith element with Nth element. For N=5, Swap element at i=1 with element at i=5 element.\\n        \\n\\t\\t//2nd loop\\n\\t\\t//First two and last two elements in correct position. Go from 3rd element till till Nth element  i.e. loop will execute N-2 times.\\n\\t\\t//Swap ith element with Nth element. For N=5, Swap i=2 with i=5 element.\\n        \\n\\t\\t//Go on ... till no more swaps are needed\\n        \\n        for(int i=1; i<n; i++) {\\n            for(int j=i, k=n; j<n; j++,k++) {\\n                int temp = nums[j];\\n                nums[j] = nums[k];\\n                nums[k] = temp;    \\n            }\\n        }\\n        return nums;\\n        \\n        //Simple solution - Using a new array\\n        /*int[] toRet = new int[nums.length];\\n        for(int i=0, j=n, k=0; i < n; i++, j++) {\\n            toRet[k++] = nums[i];\\n            toRet[k++] = nums[j];\\n        }\\n        return toRet;*/\\n    }\\n```\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] shuffle(int[] nums, int n) {\\n        //No additional memory, swap the elements\\n        \\n\\t\\t//1st loop \\n\\t\\t//First & last elements in correct poistion. Go from 2nd till Nth element  i.e. loop will execute N-1 times. \\n\\t\\t//Swap ith element with Nth element. For N=5, Swap element at i=1 with element at i=5 element.\\n        \\n\\t\\t//2nd loop\\n\\t\\t//First two and last two elements in correct position. Go from 3rd element till till Nth element  i.e. loop will execute N-2 times.\\n\\t\\t//Swap ith element with Nth element. For N=5, Swap i=2 with i=5 element.\\n        \\n\\t\\t//Go on ... till no more swaps are needed\\n        \\n        for(int i=1; i<n; i++) {\\n            for(int j=i, k=n; j<n; j++,k++) {\\n                int temp = nums[j];\\n                nums[j] = nums[k];\\n                nums[k] = temp;    \\n            }\\n        }\\n        return nums;\\n        \\n        //Simple solution - Using a new array\\n        /*int[] toRet = new int[nums.length];\\n        for(int i=0, j=n, k=0; i < n; i++, j++) {\\n            toRet[k++] = nums[i];\\n            toRet[k++] = nums[j];\\n        }\\n        return toRet;*/\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3150071,
                "title": "c-easy-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimple taverse from 0 to n and push i,i+n as adjacent elemnts.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$--> not taking answer vector\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& arr, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(arr[i]);\\n            ans.push_back(arr[i+n]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Math",
                    "Bit Manipulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& arr, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(arr[i]);\\n            ans.push_back(arr[i+n]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148478,
                "title": "98-javascript-very-very-easy-to-understand-solution-with-video-explanation-en-kr",
                "content": "If you like my video and explanation, Subscribe please!!! Thank you!!\\n\\nEnglish video!\\n\\nhttps://youtu.be/eh0oJfhEX_M\\n\\nKorean video!\\n\\nhttps://youtu.be/zUqYU6WXYpw\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    let res = []\\n\\n    for(let i =0; i<nums.length/2;i++){\\n        res.push(nums[i],nums[i+n])\\n    }\\n\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    let res = []\\n\\n    for(let i =0; i<nums.length/2;i++){\\n        res.push(nums[i],nums[i+n])\\n    }\\n\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3148370,
                "title": "daily-leetcoding-challenge-february-day-6",
                "content": "This problem is the Daily LeetCoding Challenge for February, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/shuffle-the-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/shuffle-the-array/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1107174,
                "title": "inplace-solution-without-temp-variable-in-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int max_num = *max_element(nums.begin(), nums.end()) + 1;\\n        for (int i = 0; i < 2 * n; i++) {\\n            nums[i] *= max_num;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            nums[2 * i] += nums[i] / max_num;\\n        }\\n        for (int i = n; i < 2 * n; i++) {\\n            nums[2 * (i - n) + 1] += nums[i] / max_num;\\n        }\\n        for (int i = 0; i < 2 * n; i++) {\\n            nums[i] %= max_num;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int max_num = *max_element(nums.begin(), nums.end()) + 1;\\n        for (int i = 0; i < 2 * n; i++) {\\n            nums[i] *= max_num;\\n        }\\n        for (int i = 0; i < n; i++) {\\n            nums[2 * i] += nums[i] / max_num;\\n        }\\n        for (int i = n; i < 2 * n; i++) {\\n            nums[2 * (i - n) + 1] += nums[i] / max_num;\\n        }\\n        for (int i = 0; i < 2 * n; i++) {\\n            nums[i] %= max_num;\\n        }\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1093724,
                "title": "java-easy-self-explanatory-solution",
                "content": "```\\npublic int[] shuffle(int[] nums, int n) {\\n        int[] shuffled = new int[nums.length];\\n        for(int i=0;i<n;i++){\\n            shuffled[i*2] = nums[i];\\n            shuffled[i*2+1] = nums[i+n];\\n\\n        }\\n        return shuffled;\\n    }",
                "solutionTags": [],
                "code": "```\\npublic int[] shuffle(int[] nums, int n) {\\n        int[] shuffled = new int[nums.length];\\n        for(int i=0;i<n;i++){\\n            shuffled[i*2] = nums[i];\\n            shuffled[i*2+1] = nums[i+n];\\n\\n        }\\n        return shuffled;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3345446,
                "title": "the-best-solution-time-complexity-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nconst shuffle = (nums, n) => {\\n  const result = new Array(2 * n);\\n  let j = 0;\\n  for (let i = 0; i < n; i++) {\\n    result[j++] = nums[i];\\n    result[j++] = nums[i + n];\\n  }\\n  return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nconst shuffle = (nums, n) => {\\n  const result = new Array(2 * n);\\n  let j = 0;\\n  for (let i = 0; i < n; i++) {\\n    result[j++] = nums[i];\\n    result[j++] = nums[i + n];\\n  }\\n  return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2586868,
                "title": "java-beats-100-simple",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int res[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n;i++) {\\n            res[j++]=nums[i]; \\n            res[j++]=nums[i+n];\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int res[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n;i++) {\\n            res[j++]=nums[i]; \\n            res[j++]=nums[i+n];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1045198,
                "title": "javascript-onliner-flatmap-solution",
                "content": "```\\nconst shuffle = (nums, n) => nums.slice(0, n).flatMap((x, i) => [x, nums[i + n]])\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst shuffle = (nums, n) => nums.slice(0, n).flatMap((x, i) => [x, nums[i + n]])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 911668,
                "title": "clean-javascript-solution",
                "content": "```\\n// time O(n) space O(n)\\nvar shuffle = function(nums, n) {\\n    const result = []\\n    \\n    for(let i=0; i<n; i++) {\\n        result.push(nums[i])            \\n        result.push(nums[i+n])\\n    }\\n    \\n    return result\\n};\\n```\\n\\n```\\n// time O(n) space O(n)\\nvar shuffle = function(nums, n) {\\n    const result = []\\n    let isEvenIndex = true\\n    \\n    for(let i=0; i<n; i++) {\\n        if(isEvenIndex) {\\n            result.push(nums[i])\\n            i--\\n        } else {\\n            result.push(nums[i+n])\\n        }\\n        \\n        isEvenIndex = !isEvenIndex\\n    }\\n    \\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time O(n) space O(n)\\nvar shuffle = function(nums, n) {\\n    const result = []\\n    \\n    for(let i=0; i<n; i++) {\\n        result.push(nums[i])            \\n        result.push(nums[i+n])\\n    }\\n    \\n    return result\\n};\\n```\n```\\n// time O(n) space O(n)\\nvar shuffle = function(nums, n) {\\n    const result = []\\n    let isEvenIndex = true\\n    \\n    for(let i=0; i<n; i++) {\\n        if(isEvenIndex) {\\n            result.push(nums[i])\\n            i--\\n        } else {\\n            result.push(nums[i+n])\\n        }\\n        \\n        isEvenIndex = !isEvenIndex\\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 732995,
                "title": "swift-solution",
                "content": "\\n```\\nclass Solution {\\n    func shuffle(_ nums: [Int], _ n: Int) -> [Int] {\\n        var result: [Int] = []\\n        for i in (0..<n){\\n            result.append(nums[i])\\n            result.append(nums[i+n])\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func shuffle(_ nums: [Int], _ n: Int) -> [Int] {\\n        var result: [Int] = []\\n        for i in (0..<n){\\n            result.append(nums[i])\\n            result.append(nums[i+n])\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 676054,
                "title": "a-k-k-1-nums-j-nums-i",
                "content": "```\\nvector<int> shuffle(vector<int>& nums, int we_dont_care_XD) {\\n        \\n        int i=0 , j=nums.size()/2 , k=0;\\n\\t\\t\\n        vector<int> a(nums.size());\\n\\t\\t\\n        while(k < nums.size())\\n            a[k++] = k&1 ? nums[j++] : nums[i++];\\n        return a;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python"
                ],
                "code": "```\\nvector<int> shuffle(vector<int>& nums, int we_dont_care_XD) {\\n        \\n        int i=0 , j=nums.size()/2 , k=0;\\n\\t\\t\\n        vector<int> a(nums.size());\\n\\t\\t\\n        while(k < nums.size())\\n            a[k++] = k&1 ? nums[j++] : nums[i++];\\n        return a;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 674374,
                "title": "python-1-liner-easy-fast-using-zip-chain",
                "content": "```\\nclass Solution:\\n    def shuffle(self, nums, n):\\n        return list(chain.from_iterable(zip(nums[:n], nums[n:])))",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums, n):\\n        return list(chain.from_iterable(zip(nums[:n], nums[n:])))",
                "codeTag": "Java"
            },
            {
                "id": 3148945,
                "title": "c-2-pointer-comments-added-easy",
                "content": "# Complexity\\n- Time complexity:\\n**O(N)**\\n\\n- Space complexity:\\n**O(N)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) \\n    {\\n        vector<int> ans;       // for storing final answer\\n\\n        // 2 pointer Approach\\n        int l = 0;\\n        int r = n;\\n\\n        while(r<2*n)\\n        {\\n            ans.push_back(nums[l++]);       // taking X\\n            ans.push_back(nums[r++]);       // taking Y\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) \\n    {\\n        vector<int> ans;       // for storing final answer\\n\\n        // 2 pointer Approach\\n        int l = 0;\\n        int r = n;\\n\\n        while(r<2*n)\\n        {\\n            ans.push_back(nums[l++]);       // taking X\\n            ans.push_back(nums[r++]);       // taking Y\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148725,
                "title": "two-pointers-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n/*\\n\\nSolution :\\n   Using two pointers.\\n\\n   For eg. nums = [2,5,1,3,4,7]\\n              \\n     i] [2,5,1,3,4,7]\\n         i     j\\n     ii] [2,5,1,3,4,7]\\n            i     j\\n     i] [2,5,1,3,4,7]\\n             i     j\\n\\n*/\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        int i=0;\\n        int j=nums.size()/2;\\n        for(;j<nums.size();i++,j++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[j]);\\n        }\\n\\nreturn ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n/*\\n\\nSolution :\\n   Using two pointers.\\n\\n   For eg. nums = [2,5,1,3,4,7]\\n              \\n     i] [2,5,1,3,4,7]\\n         i     j\\n     ii] [2,5,1,3,4,7]\\n            i     j\\n     i] [2,5,1,3,4,7]\\n             i     j\\n\\n*/\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        int i=0;\\n        int j=nums.size()/2;\\n        for(;j<nums.size();i++,j++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[j]);\\n        }\\n\\nreturn ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148631,
                "title": "day-37-easiest-beginner-friendly-sol-o-n-time",
                "content": "# Intuition of this Problem:\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**NOTE - PLEASE READ APPROACH FIRST THEN SEE THE CODE. YOU WILL DEFINITELY UNDERSTAND THE CODE LINE BY LINE AFTER SEEING THE APPROACH.**\\n\\n# Approach for this Problem:\\n1. Initialize an empty vector \"shuffleArray\" with a size of 2 * n.\\n2. For a loop that starts from i=0, j=n and continues until i<n and j<2n, do the following:\\n    - a. Assign nums[i] to shuffleArray[i2].\\n    - b. Assign nums[j] to shuffleArray[i*2+1].\\n1. Return the \"shuffleArray\".\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Humble Request:\\n- If my solution is helpful to you then please **UPVOTE** my solution, your **UPVOTE** motivates me to post such kind of solution.\\n- Please let me know in comments if there is need to do any improvement in my approach, code....anything.\\n- **Let\\'s connect on** https://www.linkedin.com/in/abhinash-singh-1b851b188\\n\\n![57jfh9.jpg](https://assets.leetcode.com/users/images/c2826b72-fb1c-464c-9f95-d9e578abcaf3_1674104075.4732099.jpeg)\\n\\n# Code:\\n```C++ []\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> shuffleArray(2*n);\\n        for(int i = 0; i < n; i++){\\n            shuffleArray[i*2] = nums[i];\\n            shuffleArray[i*2+1] = nums[i+n];\\n        }\\n        return shuffleArray;\\n    }\\n};\\n//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> shuffleArray(2*n);\\n        for(int i = 0, j = n; i < n, j < 2*n; i++, j++){\\n            shuffleArray[i*2] = nums[i];\\n            shuffleArray[i*2+1] = nums[j];\\n        }\\n        return shuffleArray;\\n    }\\n};\\n```\\n```Java []\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] shuffleArray = new int[2*n];\\n        for(int i = 0, j = n; i < n && j < 2*n; i++, j++){\\n            shuffleArray[i*2] = nums[i];\\n            shuffleArray[i*2+1] = nums[j];\\n        }\\n        return shuffleArray;\\n    }\\n}\\n\\n```\\n```Python []\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        shuffleArray = [0] * (2 * n)\\n        for i in range(n):\\n            shuffleArray[2 * i] = nums[i]\\n            shuffleArray[2 * i + 1] = nums[i + n]\\n        return shuffleArray\\n\\n```\\n\\n# Time Complexity and Space Complexity:\\n- Time complexity: **O(n)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(2*n)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3",
                    "Array"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> shuffleArray(2*n);\\n        for(int i = 0; i < n; i++){\\n            shuffleArray[i*2] = nums[i];\\n            shuffleArray[i*2+1] = nums[i+n];\\n        }\\n        return shuffleArray;\\n    }\\n};\\n//++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> shuffleArray(2*n);\\n        for(int i = 0, j = n; i < n, j < 2*n; i++, j++){\\n            shuffleArray[i*2] = nums[i];\\n            shuffleArray[i*2+1] = nums[j];\\n        }\\n        return shuffleArray;\\n    }\\n};\\n```\n```Java []\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] shuffleArray = new int[2*n];\\n        for(int i = 0, j = n; i < n && j < 2*n; i++, j++){\\n            shuffleArray[i*2] = nums[i];\\n            shuffleArray[i*2+1] = nums[j];\\n        }\\n        return shuffleArray;\\n    }\\n}\\n\\n```\n```Python []\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        shuffleArray = [0] * (2 * n)\\n        for i in range(n):\\n            shuffleArray[2 * i] = nums[i]\\n            shuffleArray[2 * i + 1] = nums[i + n]\\n        return shuffleArray\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148587,
                "title": "java-o-n-time-6-lines-beats-100",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int[] shuffle(int[] nums, int n) {\\n    var ans = new int[2*n];\\n    var j = 0;\\n\\n    for (var i=0; i<n; i++) {\\n      ans[j++] = nums[i];\\n      ans[j++] = nums[i+n];\\n    }\\n    return ans;\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n  public int[] shuffle(int[] nums, int n) {\\n    var ans = new int[2*n];\\n    var j = 0;\\n\\n    for (var i=0; i<n; i++) {\\n      ans[j++] = nums[i];\\n      ans[j++] = nums[i+n];\\n    }\\n    return ans;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2772874,
                "title": "c-easy-to-understand-tc-o-1-sc-o-1-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int j = n;\\n        vector<int>ans;\\n        for(int  i = 0; i<n; i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[j]);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n**# Complexity :\\nTime complexity: O(n) --- > Linear time complexity\\nSpace complexity:O(n) ----> Linear space complexity as we used the vector**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int j = n;\\n        vector<int>ans;\\n        for(int  i = 0; i<n; i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[j]);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958308,
                "title": "c-easy-solution-without-using-built-in-functions",
                "content": "```\\npublic int[] Shuffle(int[] nums, int n)\\n    {\\n        int x = 0;\\n        int[] result = new int[nums.Length];\\n        for (int i = 0; i < result.Length; i++)\\n        {\\n            if (i % 2 == 0)\\n            {\\n                result[i] = nums[x];\\n                x++;\\n            }\\n            else\\n            {\\n                result[i] = nums[n];\\n                n++;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "C#"
                ],
                "code": "```\\npublic int[] Shuffle(int[] nums, int n)\\n    {\\n        int x = 0;\\n        int[] result = new int[nums.Length];\\n        for (int i = 0; i < result.Length; i++)\\n        {\\n            if (i % 2 == 0)\\n            {\\n                result[i] = nums[x];\\n                x++;\\n            }\\n            else\\n            {\\n                result[i] = nums[n];\\n                n++;\\n            }\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 884982,
                "title": "simple-ruby-solution",
                "content": "```\\ndef shuffle(nums, n)\\n    result = []\\n    \\n    n.times do |i|\\n       result << nums[i]\\n        result << nums[i+n]\\n    end\\n    \\n    result\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef shuffle(nums, n)\\n    result = []\\n    \\n    n.times do |i|\\n       result << nums[i]\\n        result << nums[i+n]\\n    end\\n    \\n    result\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 768319,
                "title": "c-o-n-solutions",
                "content": "**Solution1: two-index**\\n\\nHave two pointers (idx1 and idx2) pointing at the beginning of the 1st half and 2nd half of the input array respectively, then fill in the result array by moving idx1 and idx2 rightward alternatly. \\n\\nTime complexity and space complexity are both O(n).\\n\\n```\\npublic class Solution {\\n    public int[] Shuffle(int[] nums, int n) {\\n     \\n        if(nums == null || nums.Length == 0)\\n            return nums;\\n        \\n        int[] res = new int[2 * n];\\n        int idx1 = 0, idx2 = n;\\n        \\n        for(int i = 0; i < 2 * n; i++)\\n        {\\n            if(i % 2 == 0)\\n                res[i] = nums[idx1++];\\n            else\\n                res[i] = nums[idx2++];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\\n\\n\\n**Solution2: one-index**\\n\\nMap nums[i] to res[2 * i], nums[n + i] to res[2 * i + 1]. Every iteration within the for loop fills in two cells of the result array.\\n\\nTime complexity and space complexity are both O(n).\\n\\n```\\npublic class Solution{\\n    public int[] Shuffle(int[] nums, int n){\\n\\t\\n        if (nums == null || nums.Length == 0)\\n            return nums;\\n\\n        int[] res = new int[2 * n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            res[2 * i] = nums[i];\\n            res[2 * i + 1] = nums[n + i];\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] Shuffle(int[] nums, int n) {\\n     \\n        if(nums == null || nums.Length == 0)\\n            return nums;\\n        \\n        int[] res = new int[2 * n];\\n        int idx1 = 0, idx2 = n;\\n        \\n        for(int i = 0; i < 2 * n; i++)\\n        {\\n            if(i % 2 == 0)\\n                res[i] = nums[idx1++];\\n            else\\n                res[i] = nums[idx2++];\\n        }\\n        \\n        return res;\\n    }\\n}\\n```\n```\\npublic class Solution{\\n    public int[] Shuffle(int[] nums, int n){\\n\\t\\n        if (nums == null || nums.Length == 0)\\n            return nums;\\n\\n        int[] res = new int[2 * n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            res[2 * i] = nums[i];\\n            res[2 * i + 1] = nums[n + i];\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 740333,
                "title": "c-one-liner",
                "content": "```\\npublic int[] Shuffle(int[] nums, int n) => nums\\n\\t.Select((x, i) => (i: i < n ? 2 * i : 2 * (i - n) + 1, x))\\n\\t.OrderBy(x => x.i)\\n\\t.Select(x => x.x)\\n\\t.ToArray();\\n```",
                "solutionTags": [],
                "code": "```\\npublic int[] Shuffle(int[] nums, int n) => nums\\n\\t.Select((x, i) => (i: i < n ? 2 * i : 2 * (i - n) + 1, x))\\n\\t.OrderBy(x => x.i)\\n\\t.Select(x => x.x)\\n\\t.ToArray();\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 729048,
                "title": "python-in-place-memory-usage-less-than-100",
                "content": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n          \\n        for i in range(n, 2*n):\\n            nums[i] = (nums[i] << 10) | nums[i-n]\\n        \\n        for i in range(n, 2*n):\\n            nums[(i-n)*2] = nums[i] & (2 ** 10 - 1)\\n            nums[(i-n)*2+1] = nums[i] >> 10\\n        \\n        return nums\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n          \\n        for i in range(n, 2*n):\\n            nums[i] = (nums[i] << 10) | nums[i-n]\\n        \\n        for i in range(n, 2*n):\\n            nums[(i-n)*2] = nums[i] & (2 ** 10 - 1)\\n            nums[(i-n)*2+1] = nums[i] >> 10\\n        \\n        return nums\\n```",
                "codeTag": "Java"
            },
            {
                "id": 684920,
                "title": "java-simple-and-easy-solution-100-faster-and-100-less-space",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int left=0,mid=n;\\n        int b[]= new int[2*n];\\n        for(int i=0;i<2*n;i=i+2)\\n        {\\n            b[i] = nums[left++];\\n            b[i+1] = nums[mid++];\\n        }\\n        return b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int left=0,mid=n;\\n        int b[]= new int[2*n];\\n        for(int i=0;i<2*n;i=i+2)\\n        {\\n            b[i] = nums[left++];\\n            b[i+1] = nums[mid++];\\n        }\\n        return b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 674302,
                "title": "c-iteration-with-offset-explained-100-speed-100-memory",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        \\n        //Alternately add x (first half numbers) and y to populate ans\\n        for (int i = 0; i < n; i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[n+i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        \\n        //Alternately add x (first half numbers) and y to populate ans\\n        for (int i = 0; i < n; i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[n+i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149603,
                "title": "easy-c-solution-using-two-queues",
                "content": "In the first loop, I am storing two half contents of vector in two different queues.\\nIn the second loop, I am rewriting the stored values of queues back into the vector alternatively.\\n\\n```\\n#include <queue>\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        queue<int> p,q;\\n        std::vector<int>::iterator itr1=nums.begin(),itr2=nums.begin()+nums.size()/2;\\n        while(itr2!=nums.end())\\n        {\\n            p.push(*itr1);\\n            q.push(*itr2);\\n            itr1++;\\n            itr2++;\\n        }\\n        itr1=nums.begin();\\n        itr2=nums.begin()+1;\\n        while(itr2!=nums.end()&&itr1!=nums.end())\\n        {\\n            *itr1=p.front();\\n            p.pop();\\n            *itr2=q.front();\\n            q.pop();\\n            itr1+=2;\\n            itr2+=2;\\n        }\\n        return nums;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        queue<int> p,q;\\n        std::vector<int>::iterator itr1=nums.begin(),itr2=nums.begin()+nums.size()/2;\\n        while(itr2!=nums.end())\\n        {\\n            p.push(*itr1);\\n            q.push(*itr2);\\n            itr1++;\\n            itr2++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3149513,
                "title": "java-solution-easy-method-0ms-runtime-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis program comes with a pattern to follow. The array must look like 0,n+0,1,n+1 ....\\nSo lets get started...\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nHere lets simply initialize an array of length `2n` because total size of given array `nums` is `2n`\\nNow iterating all the elements till nth. We store `i`th and `i+n`th element to the array. This way we store 2 elements in one iteration upto `n`. So total `2n` elements stored.\\nWe got our result.\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int ans[] = new int[2*n];\\n        int k = 0;\\n        for(int i = 0; i < n; i++){\\n            ans[k++] = nums[i];\\n            ans[k++] = nums[i+n];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n\\nI Hope the approach is clear to you.\\n\\nPLEASE DO UPVOTE!!!\\n\\nThank You",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int ans[] = new int[2*n];\\n        int k = 0;\\n        for(int i = 0; i < n; i++){\\n            ans[k++] = nums[i];\\n            ans[k++] = nums[i+n];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148896,
                "title": "easy-c-beginner-friendly-understandable",
                "content": "# Complexity\\n- Time complexity:$$O(N)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(N)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148483,
                "title": "python-solution-reduce",
                "content": "\\n```python\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return reduce(lambda x, y: x + [nums[y], nums[y + n]], range(n), [])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return reduce(lambda x, y: x + [nums[y], nums[y + n]], range(n), [])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111192,
                "title": "java-best-solution-o-n-time-complexity",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Seperate the Halfs in different arrays.\\n- Then Combine According to the Pattern.\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int size = 2*n;\\n        ArrayList<Integer> a = new ArrayList<>();\\n        ArrayList<Integer> b = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            a.add(nums[i]);\\n            b.add(nums[n +i]);\\n        }\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for (int j = 0; j < n; j++) {\\n            list.add(a.get(j));\\n            list.add(b.get(j));\\n        }\\n        int[] arr = new int[size];\\n        for (int k = 0; k < size; k++) {\\n            arr[k] = list.get(k).intValue();\\n        }\\n        return arr;\\n    }\\n}\\n```\\n![please-upvote-and.jpg](https://assets.leetcode.com/users/images/e4f1e2a8-b10b-46db-9ce6-9c2562a1a933_1674945307.2145095.jpeg)\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.ArrayList;\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int size = 2*n;\\n        ArrayList<Integer> a = new ArrayList<>();\\n        ArrayList<Integer> b = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            a.add(nums[i]);\\n            b.add(nums[n +i]);\\n        }\\n        ArrayList<Integer> list = new ArrayList<>();\\n        for (int j = 0; j < n; j++) {\\n            list.add(a.get(j));\\n            list.add(b.get(j));\\n        }\\n        int[] arr = new int[size];\\n        for (int k = 0; k < size; k++) {\\n            arr[k] = list.get(k).intValue();\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2717036,
                "title": "python-simple-solution-in-4-lines-faster-than-98-85",
                "content": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        a,n=[],len(nums)//2\\n        for i in range(n):\\n            a.extend([nums[i],nums[n+i]])\\n        return a\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        a,n=[],len(nums)//2\\n        for i in range(n):\\n            a.extend([nums[i],nums[n+i]])\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2579034,
                "title": "java-100-00-faster-solution-with-explanation",
                "content": "##### **If the solution was helpful don\\'t forget to vote**\\nRuntime: 0 ms, faster than 100.00% to Runtime: 1 ms, faster than 67.58%\\n![image](https://assets.leetcode.com/users/images/d9f00fe3-c554-42d7-94c8-b832918b2660_1663236617.6566644.jpeg)\\n\\n\\n1. [x1,x2,x3,y1,y2,y3]->[x1,y1,x2,y2,x3,y3], n = 3 - half of array(pointer)\\n1. mentally divide the array into two parts before and after the pointer\\n1. [x1,x2,x3] [pointer -> (y1),y2,y3]\\n1. create an empty array with nums.length [0, 0, 0, 0, 0, 0]\\n1. put elements form nums[leftPartStartIndex] to all even positions of result[] and increase leftPartStartIndex to 1\\n1. put elements form nums[rightPartStartIndex] to all odd positions of result[] and increase rightPartStartIndex to 1\\n1. this is because all X are on the left part and should take all even positions in result[] and all Y should take odd\\n\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n\\n        int[] result = new int[nums.length];\\n        int leftPartStartIndex = 0;\\n        int rightPartStartIndex = n;\\n\\n        for (int i = 0; i < result.length; i += 2) {\\n            result[i] = nums[leftPartStartIndex];\\n            leftPartStartIndex++;\\n        }\\n        \\n        for (int i = 1; i <= result.length; i += 2) {\\n            result[i] = nums[rightPartStartIndex];\\n            rightPartStartIndex++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n\\n        int[] result = new int[nums.length];\\n        int leftPartStartIndex = 0;\\n        int rightPartStartIndex = n;\\n\\n        for (int i = 0; i < result.length; i += 2) {\\n            result[i] = nums[leftPartStartIndex];\\n            leftPartStartIndex++;\\n        }\\n        \\n        for (int i = 1; i <= result.length; i += 2) {\\n            result[i] = nums[rightPartStartIndex];\\n            rightPartStartIndex++;\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1697309,
                "title": "python-code-shuffle-the-array",
                "content": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        c=[]\\n        for i in range(n):\\n            c.append(nums[i])\\n            c.append(nums[n+i])\\n        return c\\n```",
                "solutionTags": [
                    "Python3",
                    "Array"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        c=[]\\n        for i in range(n):\\n            c.append(nums[i])\\n            c.append(nums[n+i])\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588502,
                "title": "python-easiest-solution",
                "content": "```\\neasy python solution\\n```class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        k=[]\\n        for i in range(len(nums)):\\n            if i+n<=len(nums)-1:\\n                k.append(nums[i])\\n                k.append(nums[i+n])\\n        return k\\n\\t\\t```\\n\\t\\t\\n\\t\\t\\n\\nPlease UPVOTE if you like the Solution",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\neasy python solution\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1204621,
                "title": "java-very-simple-approach",
                "content": "public int[] shuffle(int[] nums, int n)\\n    {\\n        int[] res = new int[nums.length];\\n        int  j =0;\\n        for(int i =0;i<n;i++)\\n        {\\n            res[j++] = nums[i];\\n            res[j++] = nums[i+n];\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "public int[] shuffle(int[] nums, int n)\\n    {\\n        int[] res = new int[nums.length];\\n        int  j =0;\\n        for(int i =0;i<n;i++)\\n        {\\n            res[j++] = nums[i];\\n            res[j++] = nums[i+n];\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1043705,
                "title": "best-java-solution",
                "content": "Faster than 100%\\n\\nint[] result = new int[2 * n];\\n        \\n        int counter = 0;\\n        for (int i = 0; i < n; i++) {\\n           result[counter] = nums[i];\\n           result[counter + 1] = nums[i + n];\\n           counter = counter + 2;\\n        }\\n        \\n        return result;",
                "solutionTags": [],
                "code": "Faster than 100%\\n\\nint[] result = new int[2 * n];\\n        \\n        int counter = 0;\\n        for (int i = 0; i < n; i++) {\\n           result[counter] = nums[i];\\n           result[counter + 1] = nums[i + n];\\n           counter = counter + 2;\\n        }\\n        \\n        return result;",
                "codeTag": "Unknown"
            },
            {
                "id": 683160,
                "title": "python-3-easy-to-understand",
                "content": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n\\t\\tresult = []\\n\\t\\tfor i in range(n):\\n\\t\\t\\tresult += nums[i::n]\\n\\t\\treturn result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n\\t\\tresult = []\\n\\t\\tfor i in range(n):\\n\\t\\t\\tresult += nums[i::n]\\n\\t\\treturn result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 677223,
                "title": "javascript-1-line-recursive-solution",
                "content": "_Runtime: 100 ms, faster than 53.00% of JavaScript online submissions_\\n_Memory Usage: 50.5 MB, less than 100.00% of JavaScript online submissions_\\n\\n```javascript\\nconst shuffle = (nums, n, a = []) =>\\n  !nums.length\\n    ? a\\n    : shuffle(\\n        nums,\\n        n - 1,\\n        a.concat(nums.splice(0, 1), nums.splice(1 * n - 1, 1)),\\n      );\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```javascript\\nconst shuffle = (nums, n, a = []) =>\\n  !nums.length\\n    ? a\\n    : shuffle(\\n        nums,\\n        n - 1,\\n        a.concat(nums.splice(0, 1), nums.splice(1 * n - 1, 1)),\\n      );\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3908058,
                "title": "java-100-beat-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        \\n        int[] temp = new int[nums.length];\\n        int mid = nums.length/2;\\n        int i = 0; //iterator for left half\\n        int j = mid; //iterator for right half\\n        int k = 0; //iterator for temp array\\n        while(i<mid && j < nums.length){\\n            temp[k] = nums[i];\\n            i++;\\n            k++;\\n            temp[k] = nums[j];\\n            j++;\\n            k++;\\n        } \\n        return temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        \\n        int[] temp = new int[nums.length];\\n        int mid = nums.length/2;\\n        int i = 0; //iterator for left half\\n        int j = mid; //iterator for right half\\n        int k = 0; //iterator for temp array\\n        while(i<mid && j < nums.length){\\n            temp[k] = nums[i];\\n            i++;\\n            k++;\\n            temp[k] = nums[j];\\n            j++;\\n            k++;\\n        } \\n        return temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3636383,
                "title": "beats-in-runtime-only-in-one-loop",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res = new int[nums.length];\\n        for(int i = 0, j = 0; j < n; i++) {\\n            if(i % 2 == 0) {\\n                res[i] = nums[j];\\n            } else {\\n                res[i] = nums[j+n];\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res = new int[nums.length];\\n        for(int i = 0, j = 0; j < n; i++) {\\n            if(i % 2 == 0) {\\n                res[i] = nums[j];\\n            } else {\\n                res[i] = nums[j+n];\\n                j++;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3503509,
                "title": "100-fast-and-efficient-code-for-beginner",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp = 2 * n;\\n        int [] arr = new int[temp];\\n        for(int i = 0; i < n; i++) {\\n            arr[2 * i] = nums[i];\\n            arr[(2 * i )+ 1] = nums[i + n];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp = 2 * n;\\n        int [] arr = new int[temp];\\n        for(int i = 0; i < n; i++) {\\n            arr[2 * i] = nums[i];\\n            arr[(2 * i )+ 1] = nums[i + n];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3152283,
                "title": "golang-simple-one-pass",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(N)$$\\n\\n# Code\\n```\\nfunc shuffle(nums []int, n int) []int {\\n    res := []int{}\\n\\n    for i := 0; i < n; i++ {\\n        res = append(res, nums[i], nums[i + n])\\n    }\\n\\n    return res\\n}   \\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc shuffle(nums []int, n int) []int {\\n    res := []int{}\\n\\n    for i := 0; i < n; i++ {\\n        res = append(res, nums[i], nums[i + n])\\n    }\\n\\n    return res\\n}   \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3150985,
                "title": "java-100-faster-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(N)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/be70a16d-ea9b-4127-9f55-d19353f060e1_1675690966.5966349.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n\\n        //Take two variables i and j start i from 0 and j from n\\n        int i = 0;\\n        int j = n;\\n\\n        int ans[] = new int[nums.length];//to store the suffled array\\n\\n        int k = 0;//to traverse in ans array\\n\\n        while(k < nums.length){\\n\\n            //If K is even than copy the element on the i\\'th index in nums array to ans array \\n            if(k % 2 == 0){\\n                ans[k] = nums[i];\\n                 i++;\\n                 k++;\\n            }\\n            else{\\n                //If K is odd than copy the element on the j\\'th index in nums array to ans array\\n                ans[k] = nums[j];\\n                 k++;\\n                 j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Two Pointers"
                ],
                "code": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n\\n        //Take two variables i and j start i from 0 and j from n\\n        int i = 0;\\n        int j = n;\\n\\n        int ans[] = new int[nums.length];//to store the suffled array\\n\\n        int k = 0;//to traverse in ans array\\n\\n        while(k < nums.length){\\n\\n            //If K is even than copy the element on the i\\'th index in nums array to ans array \\n            if(k % 2 == 0){\\n                ans[k] = nums[i];\\n                 i++;\\n                 k++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3150716,
                "title": "c-beats-95-of-submissions",
                "content": "# Intuition\\n- Easy and super simple !!!\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Get the length of the nums array.\\n- Traverse the array (len/2) times, where you\\'ll be able to append current element and (current element + nth) element simultaneously.\\n- Return the res array.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) \\n    {\\n        int len = nums.size();\\n        vector <int> res;\\n\\n        for(int i = 0; i < len/2; i++)\\n        {\\n            res.push_back(nums[i]);\\n            res.push_back(nums[n++]);\\n        }\\n\\n        return res;\\n    }   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) \\n    {\\n        int len = nums.size();\\n        vector <int> res;\\n\\n        for(int i = 0; i < len/2; i++)\\n        {\\n            res.push_back(nums[i]);\\n            res.push_back(nums[n++]);\\n        }\\n\\n        return res;\\n    }   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149288,
                "title": "beginner-friendly-solution-easy",
                "content": "# Intuition\\nSimple Loop\\n\\n# Approach\\n- Make an array of 2n size \\n- use for loop from 0 to n\\n- store at i and (i+n) index in array\\n- return array\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(2n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n vector<int>arr;\\n        for(int i=0;i<n;i++){\\n        arr.push_back(nums[i]);\\n            arr.push_back(nums[i+n]);\\n        }\\n        return arr;}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n vector<int>arr;\\n        for(int i=0;i<n;i++){\\n        arr.push_back(nums[i]);\\n            arr.push_back(nums[i+n]);\\n        }\\n        return arr;}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149191,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans(2*n);\\n        for(int i=0;i<n;i++){\\n            ans[2*i]=nums[i];\\n            ans[2*i+1]=nums[n+i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans(2*n);\\n        for(int i=0;i<n;i++){\\n            ans[2*i]=nums[i];\\n            ans[2*i+1]=nums[n+i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148912,
                "title": "fast-c-solution",
                "content": "# Solution in C++\\n\\n<iframe src=\"https://leetcode.com/playground/2wKHrGhQ/shared\" frameBorder=\"0\" width=\"600\" height=\"450\"></iframe>\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/f3cc070c-d1eb-44ea-a848-7e67e76f2290_1675656196.263727.jpeg)\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "# Solution in C++\\n\\n<iframe src=\"https://leetcode.com/playground/2wKHrGhQ/shared\" frameBorder=\"0\" width=\"600\" height=\"450\"></iframe>\\n\\n![kitty.jpeg](https://assets.leetcode.com/users/images/f3cc070c-d1eb-44ea-a848-7e67e76f2290_1675656196.263727.jpeg)\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 3148905,
                "title": "python-1-liner",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$ including output space, else $$O(1)$$\\n\\n# Code\\n```python\\nclass Solution:\\n    def shuffle(self, nums: list[int], n: int) -> list[int]:\\n        return [nums[j] for i in range(n) for j in (i, i + n)]\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array"
                ],
                "code": "```python\\nclass Solution:\\n    def shuffle(self, nums: list[int], n: int) -> list[int]:\\n        return [nums[j] for i in range(n) for j in (i, i + n)]\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148557,
                "title": "java-one-liner-streams",
                "content": "# Code\\n```\\nclass Solution {\\n\\tpublic static int[] shuffle(int[] nums, int n) {\\n\\t\\treturn IntStream.range(0, n).flatMap(i -> IntStream.of(nums[i], nums[i + n])).toArray();\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Data Stream"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic static int[] shuffle(int[] nums, int n) {\\n\\t\\treturn IntStream.range(0, n).flatMap(i -> IntStream.of(nums[i], nums[i + n])).toArray();\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148491,
                "title": "python-1-itertools-chain-2-numpy-3-conventional-for-loop",
                "content": "**Solution 1: itertools.chain(), zip()**\\nhttps://leetcode.com/submissions/detail/892325819/   \\nRuntime: **60 ms**, faster than 84.21% of Python3 online submissions for Shuffle the Array.   \\nMemory Usage: 14.1 MB, less than 86.30% of Python3 online submissions for Shuffle the Array.    \\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return list(chain(*[[x,y] for x,y in zip(nums[:n], nums[n:])]))\\n```\\n\\n**Solution 2: numpy**  \\nhttps://leetcode.com/submissions/detail/892330831/  \\nRuntime: **127 ms**, faster than 16.21% of Python3 online submissions for Shuffle the Array.   \\nMemory Usage: 32.1 MB, less than 33.52% of Python3 online submissions for Shuffle the Array.   \\n```\\nimport numpy as np\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return np.array(nums).reshape(2,-1).transpose().reshape(1,-1).squeeze().tolist()\\n```\\n\\n**Solution 3: conventional for-loop, O(n)**  \\nhttps://leetcode.com/submissions/detail/892331780/ \\nRuntime: **61 ms**, faster than 79.49% of Python3 online submissions for Shuffle the Array.\\nMemory Usage: 14.2 MB, less than 33.52% of Python3 online submissions for Shuffle the Array.\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        l = []\\n        for i in range(n):\\n            l.append(nums[i])\\n            l.append(nums[i+n])\\n        return l\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return list(chain(*[[x,y] for x,y in zip(nums[:n], nums[n:])]))\\n```\n```\\nimport numpy as np\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return np.array(nums).reshape(2,-1).transpose().reshape(1,-1).squeeze().tolist()\\n```\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        l = []\\n        for i in range(n):\\n            l.append(nums[i])\\n            l.append(nums[i+n])\\n        return l\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148480,
                "title": "o-1-in-space",
                "content": "# Intuition\\nMoves each element in the array to its target position. Repeat the process for the replaced element.\\n\\n# Approach\\nFor each element in the array, move it to its final position, then repeat the process for the replaced element. Multiply the value in the position by -1 so we know when to stop the process (completed the cycle in the graph).\\n\\nThen iterate over each element to restore the original value.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        nums[0] *= -1;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            int j = i;\\n            int currentNumber = nums[i];\\n            while (nums[j] > 0) {\\n                int target;\\n                if (j < n) {\\n                    target = j * 2;\\n                } else {\\n                    target = (j - n) * 2 + 1;\\n                }\\n                var temp = nums[target];\\n                nums[target] = currentNumber;\\n                currentNumber = temp;\\n                nums[j] *= -1;\\n                j = target;\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = Math.abs(nums[i]);\\n        }\\n\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        nums[0] *= -1;\\n\\n        for (int i = 1; i < nums.length; i++) {\\n            int j = i;\\n            int currentNumber = nums[i];\\n            while (nums[j] > 0) {\\n                int target;\\n                if (j < n) {\\n                    target = j * 2;\\n                } else {\\n                    target = (j - n) * 2 + 1;\\n                }\\n                var temp = nums[target];\\n                nums[target] = currentNumber;\\n                currentNumber = temp;\\n                nums[j] *= -1;\\n                j = target;\\n            }\\n        }\\n        for (int i = 0; i < nums.length; i++) {\\n            nums[i] = Math.abs(nums[i]);\\n        }\\n\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148402,
                "title": "python-single-line-list-comprehension",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return [nums[x + n * y] for x in range(n) for y in range(2)]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        return [nums[x + n * y] for x in range(n) for y in range(2)]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2800328,
                "title": "c-easy-approach",
                "content": "Here is my c++ code for this problem\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> shuffle(vector<int>& nums, int n) {\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\tans.push_back(nums[i]);\\n\\t\\t\\t\\tans.push_back(nums[n+i]);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> shuffle(vector<int>& nums, int n) {\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tfor(int i=0; i<n; i++){\\n\\t\\t\\t\\tans.push_back(nums[i]);\\n\\t\\t\\t\\tans.push_back(nums[n+i]);\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2450292,
                "title": "java-easy-2-lines",
                "content": "```\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int na[] = new int[2*n];\\n        for(int i =0;i<2*n;i++){\\n            na[i]= (i%2==0) ? nums[i/2] : nums[n + i/2];\\n        }\\n        return na;   \\n    } \\n   \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int na[] = new int[2*n];\\n        for(int i =0;i<2*n;i++){\\n            na[i]= (i%2==0) ? nums[i/2] : nums[n + i/2];\\n        }\\n        return na;   \\n    } \\n   \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2269850,
                "title": "python-3-simple-solution",
                "content": "Here is my simple solution:\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        a = []\\n        for x in range(n):\\n            a.append(nums[x])\\n            a.append(nums[x+n])\\n        return a\\n",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "Here is my simple solution:\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        a = []\\n        for x in range(n):\\n            a.append(nums[x])\\n            a.append(nums[x+n])\\n        return a\\n",
                "codeTag": "Java"
            },
            {
                "id": 2062844,
                "title": "100-faster-java-easy-approach",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int ans[] = new int[2*n];\\n        int k=0;\\n        for(int i=0;i<ans.length;i+=2){\\n            ans[i] = nums[k];\\n            ans[i+1] = nums[k+n];\\n            k++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int ans[] = new int[2*n];\\n        int k=0;\\n        for(int i=0;i<ans.length;i+=2){\\n            ans[i] = nums[k];\\n            ans[i+1] = nums[k+n];\\n            k++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2060992,
                "title": "easiest-two-pointer-approach-space-complexity-o-n",
                "content": "```\\npublic int[] shuffle(int[] nums, int n) {\\n        \\n        // i -->  0 1 2 3 4 5 \\n        // val--> 2,5,1,3,4,7\\n        // out--> \\n        // i = 0 --> nums[0],nums[3] || res[2,3] resIndex = 0, 1,\\n        // i = 1 --> nums[1],nums[4] || res[2,3, 5,4] resIndex = 2, 3, \\n        // i = 2 --> nums[2],nums[5] || res[2,3, 5,4, 1,7] resIndex = 4, 5\\n        // nums[i], nums[i+n]\\n        // resIndex++ assign(0) and increment(0+1) ==> 1\\n        int[] result = new int[nums.length];\\n        int resIndex = 0;\\n        for(int i=0; i<n; i++) {\\n            result[resIndex++] = nums[i];\\n            result[resIndex++] = nums[i+n];\\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\npublic int[] shuffle(int[] nums, int n) {\\n        \\n        // i -->  0 1 2 3 4 5 \\n        // val--> 2,5,1,3,4,7\\n        // out--> \\n        // i = 0 --> nums[0],nums[3] || res[2,3] resIndex = 0, 1,\\n        // i = 1 --> nums[1],nums[4] || res[2,3, 5,4] resIndex = 2, 3, \\n        // i = 2 --> nums[2],nums[5] || res[2,3, 5,4, 1,7] resIndex = 4, 5\\n        // nums[i], nums[i+n]\\n        // resIndex++ assign(0) and increment(0+1) ==> 1\\n        int[] result = new int[nums.length];\\n        int resIndex = 0;\\n        for(int i=0; i<n; i++) {\\n            result[resIndex++] = nums[i];\\n            result[resIndex++] = nums[i+n];\\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1811742,
                "title": "java-space-o-1-time-o-n-solved-without-taking-extra-array",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int size = nums.length;\\n        for(int i=n;i<size;i++){\\n            nums[i]=(nums[i]*10000)+nums[i-n];\\n        }\\n        for(int i=0;i<size;i=i+2){\\n            nums[i]=nums[n]%10000;\\n            nums[i+1]=nums[n]/10000;\\n            n++;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int size = nums.length;\\n        for(int i=n;i<size;i++){\\n            nums[i]=(nums[i]*10000)+nums[i-n];\\n        }\\n        for(int i=0;i<size;i=i+2){\\n            nums[i]=nums[n]%10000;\\n            nums[i+1]=nums[n]/10000;\\n            n++;\\n        }\\n        return nums;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1752042,
                "title": "python-beautiful-o-n-time-o-1-space-with-explanation",
                "content": "```\\ndef shuffle(self, nums: List[int], n: int) -> List[int]:\\n        \\n        for i in range(n):\\n            nums[i] = nums[i] * 10000 + nums[n + i]\\n        \\n        for i in range(n-1,-1,-1):\\n            \\n            nums[2 * i + 1] = nums[i] % 10000\\n            nums[2 * i] = nums[i] // 10000\\n        \\n        return nums\\n            \\n```\\n\\nConsider the example: [2,5,1,3,4,7]. Output should be [2,3,5,4,1,7].\\n\\nIn the first for loop we kinda hide two numbers inside one. After doing this loop the array will be [20003,50004,10007,3,4,7]. Look at the first half of the array, it contains all numbers in desired order! Compare the first half of the array with the output we want to get.\\n\\nNow we just need to extract these numbers from this combined form. That\\'s exactly what the second loop does. It starts from the end of the array and one by one extracts combined numbers and puts them into the correct positions.\\n\\nThis trick of multiplying by 10000 only possible because of the constraint 1 <= nums[i] <= 10^3. So if the upper bound is larger we have to change 10000 to a larger number. This is not a universal solution, but I like it\\'s smartness. \\n\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef shuffle(self, nums: List[int], n: int) -> List[int]:\\n        \\n        for i in range(n):\\n            nums[i] = nums[i] * 10000 + nums[n + i]\\n        \\n        for i in range(n-1,-1,-1):\\n            \\n            nums[2 * i + 1] = nums[i] % 10000\\n            nums[2 * i] = nums[i] // 10000\\n        \\n        return nums\\n            \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1641213,
                "title": "java-c-simple-o-1-space-in-place-100-faster-efficient-explained",
                "content": "# **Please Upvote If you got any help from the provided solution!!!**\\n\\n<u><strong>Refer to the following github repsitory for more leetcode solutions<strong></u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n**COMPLEXITY:**\\n* **Time: O(n)**, where n is the given number, which is half of the length of the array\\n* **Space: O(1)**, in-place<br>\\n\\n\\nSince we need to solve it in 0(1) space or **in-place**, we will use the original array.\\n\\n**BASIC IDEA:**\\n1. **Store the pair of numbers** and then\\n2. **Retreive each number,** from that pair where they were stored, **one by one** and place them at their desired positions.\\n<br>\\n\\n**GENERAL EXAMPLE:**\\n*Suppose, you are performing a task and someone gives you another task, in order to avoid disturbance in the flow of previous task, you can keep both the tasks on one side and complete the task one by one according to the requirement.*\\n\\n**SAME CONCEPT FOR ARRAYS:**\\n*In order to avoid overwriting values, store the \"pair of numbers\" in the right half of the array and retrieve the numbers by one according to the requirement.*\\n<br>\\n**#  <u>DETAILED EXPLANATION IS GIVEN BELOW THE CODE</u> #**\\n<br>\\n\\n<u>**NOTE:**</u>  --> Runtime Fluctuates a lot in case of C++(0ms to 4ms)\\n\\n<u>**C++ / JAVA CODE**</u>\\n\\n<iframe src=\"https://leetcode.com/playground/arHM8WHa/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\n<hr>\\n\\n**Using Bitwise Operator to make it a bit faster**<br>\\n\\n<u>**NOTE:**</u>  --> Runtime Fluctuates a lot in case of C++(0ms to 4ms)\\n\\n<u>**C++ / JAVA CODE**</u>\\n\\n<iframe src=\"https://leetcode.com/playground/QHAeabD9/shared\" frameBorder=\"0\" width=\"100%\" height=\"350\"></iframe>\\n\\n<hr>\\n\\n<u>**EXPLANATION:**</u>\\n\\n**Let\\'s understand in general term:**\\n\\nSuppose we have 2 numbers `num1 = 4` and `num2 = 9` and `maxValue = 10`\\n**Formula:**\\n**to store** -> pair = (num2 &times; maxValue) + num1\\n**to retrieve** -> pair % maxValue and pair / maxValue\\n\\n1. **Storing the pair of numbers**\\n\\n\\t(9 &times; 10) + 4 = 94 --> from above formula (num2 &times; maxValue) + num1\\n\\t**94 is stored**\\n\\n2. **Retrieving each number one by one**\\n\\n\\t94 % 10 = 4\\n\\t**we got first number as 4**\\n\\n\\t94 / 10 = 9\\n\\t**we got second number as 9**\\n\\nSame idea goes for large cases and array as well but instead of 10, we will take 1024 to store pairs and retrieve each number\\n**<u>NOTE:</u> Here, we will take 1024 because of the given constraints `1 <= nums[i] <= 10^3` i.e. the largest number in the array will be 1000**\\n\\nNow, \\n**Binary representation** of **1000** is **1111101000**, consisting of total **10 bits**\\n**Binary representation** of **1024** is **10000000000**, consisting of total **11 bits**\\nand if we multiply 1000 with 1024 i.e. **(1000 * 1024)**, we will get **1024000**\\n**Binary representation** of **1024000** is **11111010000000000000**, consisting of total **20 bits** which is less than the number of bits **(32bits)** of int data type, so we can store the number pairs(by multiplying one number with 1024 and adding another number to it) to retrieve each indivisual number later on(by taking out the remainder and the quotient).\\neg: suppose we have an **`array of length 4`** and **`n is 2`**\\n`nums = [5, 2, 1000, 3]` and `n = 2`\\n\\n1. **We will store the pair of numbers first**\\n\\n\\tAccording to algorithm\\n\\t\\n\\t```\\n\\t// to store the pair of numbers in right half of the original array\\n\\tfor(int i = n; i < len; i++)\\n\\tnums[i] = (nums[i] * 1024) + nums[i - n];\\n\\t```\\n\\t* \\t**Iteration 1:**\\n\\t\\twhen i = 2, (i = 2 because value of n is 2)\\n\\t\\tnums[2] = (1000 &times; 1024) + 5 \\n\\t\\tso, nums[2] = 1024005\\n\\n\\t* \\t**Iteration 2:**\\n\\t\\twhen i = 3,\\n\\t\\tnums[3] = (3 &times; 1024) + 2\\n\\t\\tso, nums[3] = 3074\\n\\n\\t**Now, the original array**\\n\\t[5, 2, 1000, 3]\\n\\t&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;<-- Indexes\\n\\t**becomes**\\n\\t[5, 2, 1024005, 3074]\\n\\t&nbsp;0&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;3 &nbsp;&nbsp;<-- Indexes\\n\\n2. **We will retrieve the numbers one by one from the pairs which we have stored at 2nd and 3rd index**\\n\\n\\tAccording to algorithm\\n\\t```\\n\\t// to retrive values from the pair of numbers and placing those retrieved value at their desired position\\n\\tint index = 0;\\n\\tfor(int i = n; i < len; i++, index += 2){\\n\\t\\tnums[index] = nums[i] % 1024;\\n\\t\\tnums[index + 1] = nums[i] / 1024;\\n\\t}\\n\\t```\\n\\n\\t* \\t**Iteration 1:**\\n\\t\\twhen index = 0 and i = 2, (i = 2 because value of n is 2)\\n\\t\\tnums[0] = 1024005 % 1024 = 5\\n\\t\\tnums[1] = 1024005 / 1024 = 1000\\n\\t\\tnow, index = 2 (from index += 2)\\n\\n\\t* \\t**Iteration 2:**\\n\\t\\twhen index = 2, i = 3,\\n\\t\\tnums[2] = 3074 % 1024 = 2\\n\\t\\tnums[3] = 3074 / 1024 = 3\\n\\n\\tIteration will be stopped now as the condition become false and we got the array as following\\n\\t**[5, 1000, 2, 3]  <-- Desired Output**\\n\\t&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2&nbsp;&nbsp;3&nbsp;&nbsp;<-- Indexes\\n<hr>\\n\\n<u><strong>Refer to the following github repsitory for more leetcode solutions<strong></u>\\nhttps://github.com/Akshaya-Amar/LeetCodeSolutions\\n\\n<hr>\\n\\n# **Please Upvote If you got any help from the provided solution!!!**\\n",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\n\\t// to store the pair of numbers in right half of the original array\\n\\tfor(int i = n; i < len; i++)\\n\\tnums[i] = (nums[i] * 1024) + nums[i - n];\\n\\t```\n```\\n\\t// to retrive values from the pair of numbers and placing those retrieved value at their desired position\\n\\tint index = 0;\\n\\tfor(int i = n; i < len; i++, index += 2){\\n\\t\\tnums[index] = nums[i] % 1024;\\n\\t\\tnums[index + 1] = nums[i] / 1024;\\n\\t}\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1552721,
                "title": "c-5line-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int index=0;index<n;index++)\\n        {\\n            ans.push_back(nums[index]);\\n            ans.push_back(nums[n+index]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int index=0;index<n;index++)\\n        {\\n            ans.push_back(nums[index]);\\n            ans.push_back(nums[n+index]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1363983,
                "title": "java-0ms-100-fast",
                "content": "```\\npublic int[] shuffle(int[] nums, int n) {\\n        int[] numsResult = nums.clone();\\n        int currentIndex = 0;\\n        for(int i = 0; i < nums.length - n; i++) { // from index 0 to array length - n\\n            numsResult[currentIndex] = nums[i];\\n            numsResult[currentIndex + 1] = nums[i + n];\\n            currentIndex += 2; // increase current index by 2\\n        }\\n        return numsResult;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] shuffle(int[] nums, int n) {\\n        int[] numsResult = nums.clone();\\n        int currentIndex = 0;\\n        for(int i = 0; i < nums.length - n; i++) { // from index 0 to array length - n\\n            numsResult[currentIndex] = nums[i];\\n            numsResult[currentIndex + 1] = nums[i + n];\\n            currentIndex += 2; // increase current index by 2\\n        }\\n        return numsResult;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1261684,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "Take 2 pointers, start 1 from zero and second from n. initialise an array and add values with the help of both pointers.\\n\\n\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[n*2];\\n        int c = 0;\\n        for(int i = 0; i < n; i++){\\n            if(i % 2 == 0){\\n                newArr[i] = nums[c];\\n                c++;\\n            }\\n            else{\\n                newArr[i]= nums[n];\\n                n++;\\n            }\\n        }\\n        newArr[n] = nums[n];\\n        return newArr;\\n    }\\n}\\n```\\n\\nUpvote if it helped.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[n*2];\\n        int c = 0;\\n        for(int i = 0; i < n; i++){\\n            if(i % 2 == 0){\\n                newArr[i] = nums[c];\\n                c++;\\n            }\\n            else{\\n                newArr[i]= nums[n];\\n                n++;\\n            }\\n        }\\n        newArr[n] = nums[n];\\n        return newArr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1242662,
                "title": "java-2-line-code-faster-then-100",
                "content": "public int[] shuffle(int[] nums, int n) {\\n      int answer[]=new int[nums.length];\\n      int index=0,j=n;\\n        for(int i=0;i<n;i++){\\n            answer[index++]=nums[i];\\n            answer[index++]=nums[j++];\\n        }\\n        return answer;\\n    }",
                "solutionTags": [],
                "code": "public int[] shuffle(int[] nums, int n) {\\n      int answer[]=new int[nums.length];\\n      int index=0,j=n;\\n        for(int i=0;i<n;i++){\\n            answer[index++]=nums[i];\\n            answer[index++]=nums[j++];\\n        }\\n        return answer;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1180919,
                "title": "go-easy",
                "content": "Do upvote if you like it! :)\\n```\\nfunc shuffle(nums []int, n int) []int {\\n     var res []int\\n    for i:=0;i<n;i++{\\n        res=append(res,nums[i])\\n        res=append(res,nums[i+n])\\n    }\\n     return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc shuffle(nums []int, n int) []int {\\n     var res []int\\n    for i:=0;i<n;i++{\\n        res=append(res,nums[i])\\n        res=append(res,nums[i+n])\\n    }\\n     return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1158747,
                "title": "python-solution-99-18",
                "content": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        \\n        result = []\\n        for i in range(n):\\n            result.append(nums[i])\\n            result.append(nums[n+i])\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        \\n        result = []\\n        for i in range(n):\\n            result.append(nums[i])\\n            result.append(nums[n+i])\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1116865,
                "title": "runtime-0-ms-faster-than-100-00-of-java-online-submissions",
                "content": "```\\nint[] result = new int[nums.length];\\n        int x=0;\\n        int y =n;\\n        for(int i = 0;i<nums.length;i++){\\n            if(i%2==0) result[i]= nums[x++];\\n            else result[i]=nums[y++];\\n            \\n        }\\n        return result;\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint[] result = new int[nums.length];\\n        int x=0;\\n        int y =n;\\n        for(int i = 0;i<nums.length;i++){\\n            if(i%2==0) result[i]= nums[x++];\\n            else result[i]=nums[y++];\\n            \\n        }\\n        return result;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 784709,
                "title": "javascript-76ms",
                "content": "```\\nvar shuffle = function(nums, n) {\\n    let arr= []\\n    for(let i=0; i< n; i++){\\n        arr.push(nums[i])\\n        arr.push(nums[n+i])\\n    }\\n    return arr\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar shuffle = function(nums, n) {\\n    let arr= []\\n    for(let i=0; i< n; i++){\\n        arr.push(nums[i])\\n        arr.push(nums[n+i])\\n    }\\n    return arr\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 747439,
                "title": "straightforward-go-solution",
                "content": "```\\nfunc shuffle(nums []int, n int) []int {\\n    x := nums[:n]\\n    y := nums[n:]\\n    \\n    var retVal []int\\n    \\n    for i := 0; i < len(x); i++ {\\n        retVal = append(retVal, x[i]);\\n        retVal = append(retVal, y[i]);\\n    }\\n    \\n    return retVal\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc shuffle(nums []int, n int) []int {\\n    x := nums[:n]\\n    y := nums[n:]\\n    \\n    var retVal []int\\n    \\n    for i := 0; i < len(x); i++ {\\n        retVal = append(retVal, x[i]);\\n        retVal = append(retVal, y[i]);\\n    }\\n    \\n    return retVal\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 717900,
                "title": "c-solution",
                "content": "```\\nint* shuffle(int* nums, int numsSize, int n, int* returnSize){\\n    *returnSize = numsSize;\\n    int i, j=0;\\n    int *shufflenums;\\n    shufflenums = (int*)malloc(sizeof(int)*numsSize);\\n    for(i=0;i<n;i++){\\n        shufflenums[j++] = nums[i];\\n        shufflenums[j++] = nums[i+n];\\n    }\\n    return shufflenums;\\n}\\n``",
                "solutionTags": [],
                "code": "```\\nint* shuffle(int* nums, int numsSize, int n, int* returnSize){\\n    *returnSize = numsSize;\\n    int i, j=0;\\n    int *shufflenums;\\n    shufflenums = (int*)malloc(sizeof(int)*numsSize);\\n    for(i=0;i<n;i++){\\n        shufflenums[j++] = nums[i];\\n        shufflenums[j++] = nums[i+n];\\n    }\\n    return shufflenums;\\n}\\n``",
                "codeTag": "Unknown"
            },
            {
                "id": 707179,
                "title": "javascript-solution-faster-than-93",
                "content": "```\\nvar shuffle = function(nums, n) {\\n    let arr = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        arr.push(nums[i]);\\n        arr.push(nums[i + n]);\\n    }\\n    return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shuffle = function(nums, n) {\\n    let arr = [];\\n    \\n    for (let i = 0; i < n; i++) {\\n        arr.push(nums[i]);\\n        arr.push(nums[i + n]);\\n    }\\n    return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 703905,
                "title": "basic-generator-based-python-3-solution-95-100",
                "content": "I went through most of the Python solutions, but I haven\\'t seen any that used the generator pattern. It\\'s relatively fast, running at 56 ms at times (faster than 95.42% at the time of writing), and doesn\\'t use a lot of memory (13.8 MB, less than 100%). \\n\\nIt\\'s just a simple, no-nonsense solution. No allocating of additional lists, no list comprehensions, no usage of itertools. Just an easy to understand `for` loop making use of the provided `n`. Ideally you\\'d also change the return type to `Generator`,  but this works.\\n\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        for i in range(n):\\n            yield nums[i]\\n            yield nums[i+n]\\n```\\n\\nEdit: Apparently I missed two solutions that take a similar approach: [#1](https://leetcode.com/problems/shuffle-the-array/discuss/674365/Clean-Python-3-generator-and-one-liner) and [#2](https://leetcode.com/problems/shuffle-the-array/discuss/690596/Less-memory-than-100-of-Python3-solutions-faster-than-96).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        for i in range(n):\\n            yield nums[i]\\n            yield nums[i+n]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 703501,
                "title": "java-100-faster-and-100-lesser-memory",
                "content": "```\\nclass Solution {\\n    \\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res = new int[2*n];\\n        for(int i = 0; i < n; i++) {\\n            res[2* i] = nums[i];\\n            res[(2 * i) + 1] = nums[i + n];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res = new int[2*n];\\n        for(int i = 0; i < n; i++) {\\n            res[2* i] = nums[i];\\n            res[(2 * i) + 1] = nums[i + n];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 695039,
                "title": "simple-java-solution-o-n-time-6-lines-of-code-100-faster",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] op = new int[2*n];\\n        for(int i=0,c=0;i<n;i++){\\n            op[c++]=nums[i];            \\n            op[c++]=nums[i+n];\\n        }\\n        return op;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] op = new int[2*n];\\n        for(int i=0,c=0;i<n;i++){\\n            op[c++]=nums[i];            \\n            op[c++]=nums[i+n];\\n        }\\n        return op;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 679886,
                "title": "in-place-o-n-time-o-1-space-using-continuous-swap",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        for(int i=1;i<n;++i){\\n            if(nums[i]>0){\\n                int next = i<<1;\\n                while(next!=i){\\n                    int tem = nums[next];\\n                    nums[next] = -nums[i];\\n                    nums[i]=tem;\\n                    if(next<n)next=next<<1;\\n                    else next=((next-n)<<1)+1;\\n                }\\n            }\\n        }\\n        for(int i=2;i<nums.length-1;++i)if(nums[i]<0)nums[i]=-nums[i];\\n        return nums;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        for(int i=1;i<n;++i){\\n            if(nums[i]>0){\\n                int next = i<<1;\\n                while(next!=i){\\n                    int tem = nums[next];\\n                    nums[next] = -nums[i];\\n                    nums[i]=tem;\\n                    if(next<n)next=next<<1;\\n                    else next=((next-n)<<1)+1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 675537,
                "title": "simple-c-code-faster-than-100",
                "content": "```\\nint* shuffle(int* nums, int numsSize, int n, int* returnSize){\\n    int *dst = (int*)malloc(numsSize*sizeof(int));\\n    int i;\\n    for(i=0; i<n; i++){\\n        dst[2*i] = nums[i];\\n        dst[2*i+1] = nums[n+i];\\n    }\\n    *returnSize = numsSize;\\n    return dst;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint* shuffle(int* nums, int numsSize, int n, int* returnSize){\\n    int *dst = (int*)malloc(numsSize*sizeof(int));\\n    int i;\\n    for(i=0; i<n; i++){\\n        dst[2*i] = nums[i];\\n        dst[2*i+1] = nums[n+i];\\n    }\\n    *returnSize = numsSize;\\n    return dst;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 675172,
                "title": "c-shuffling-in-place-with-auxiliary-vector",
                "content": "**Without auxiliary vector** - Runtime - 20 ms, Memory - 9.8 MB\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int offset = 1, index = n;\\n        for(int i = 0; i < n; i++) {\\n            nums.insert(nums.begin()+offset, nums[index++]);\\n            nums.erase(nums.begin()+index);\\n            offset += 2;\\n        }\\n        return nums;\\n    }\\n};\\n```\\n\\n**With auxiliary vector** - Runtime - 12 ms, Memory - 10 MB\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& v, int n) {\\n        vector<int> res;\\n        int f = 0, s = n, c = 1;\\n        for(int i = 0; i < v.size(); i++) {\\n            res.emplace_back(c ? v[f++] : v[s++]);\\n            c ^= 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int offset = 1, index = n;\\n        for(int i = 0; i < n; i++) {\\n            nums.insert(nums.begin()+offset, nums[index++]);\\n            nums.erase(nums.begin()+index);\\n            offset += 2;\\n        }\\n        return nums;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& v, int n) {\\n        vector<int> res;\\n        int f = 0, s = n, c = 1;\\n        for(int i = 0; i < v.size(); i++) {\\n            res.emplace_back(c ? v[f++] : v[s++]);\\n            c ^= 1;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 674777,
                "title": "c-o-1-space-in-place-hint-all-numbers-are-positive",
                "content": "Use negative numbers to flag the right-placed positions.\\n\\n```cpp\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        auto _map = [&](int i) { return (i < n) ? (i<<1) : (((i-n)<<1) + 1); };\\n        auto _swap = [&](int i, int j) {\\n            swap(nums[i], nums[j]);\\n            nums[j] = -nums[j];\\n        };\\n        \\n        for (int i = 0; i < 2*n; ++i) {\\n            if (nums[i] < 0) continue;\\n            \\n            int j = i;\\n            do {\\n                j = _map(j);\\n                _swap(i, j);\\n            } while (j != i);\\n        }\\n        \\n        for (auto& v : nums) v = -v;\\n        \\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        auto _map = [&](int i) { return (i < n) ? (i<<1) : (((i-n)<<1) + 1); };\\n        auto _swap = [&](int i, int j) {\\n            swap(nums[i], nums[j]);\\n            nums[j] = -nums[j];\\n        };\\n        \\n        for (int i = 0; i < 2*n; ++i) {\\n            if (nums[i] < 0) continue;\\n            \\n            int j = i;\\n            do {\\n                j = _map(j);\\n                _swap(i, j);\\n            } while (j != i);\\n        }\\n        \\n        for (auto& v : nums) v = -v;\\n        \\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4072467,
                "title": "hey-i-am-here",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    let res = [];\\n    let m = 0;\\n    for(let i=0; i<n; i++) {\\n        res[m] = nums[i];\\n        res[m+1] = nums[i+n];\\n        m+=2;\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    let res = [];\\n    let m = 0;\\n    for(let i=0; i<n; i++) {\\n        res[m] = nums[i];\\n        res[m+1] = nums[i+n];\\n        m+=2;\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4022367,
                "title": "beats-100-00-and-90-97-of-runtime",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int result[]=new int[nums.length];\\n\\t\\tfor(int i=0;i<nums.length;i+=2)\\n\\t\\t{\\n\\t\\t\\tresult[i]=nums[i/2];\\n\\t\\t\\tresult[i+1]=nums[nums.length-n];\\n\\t\\t\\tn=n-1;\\n\\t\\t\\n\\t\\t}\\t\\n\\t\\treturn result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int result[]=new int[nums.length];\\n\\t\\tfor(int i=0;i<nums.length;i+=2)\\n\\t\\t{\\n\\t\\t\\tresult[i]=nums[i/2];\\n\\t\\t\\tresult[i+1]=nums[nums.length-n];\\n\\t\\t\\tn=n-1;\\n\\t\\t\\n\\t\\t}\\t\\n\\t\\treturn result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3658432,
                "title": "c-beats-56-97-runtime-99-74-memory-tc-o-n-sc-o-1",
                "content": "# can you do it in inplace ?\\n\\n# Intuition\\nsince 1 <= nums[i] <= 1000\\n\\nAnd we know that using const(any number > 1000, in this case),\\nwe can encode encode num as-\\n**num = (const * a) + b**\\nand we can get a & b from num as-\\n**a = num/const\\nb = num%const**\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n**Example**:-\\nwe have to convert {a,c,e,g,i|b,d,f,h,j} ---> {a,b,c,d,e|f,g,h,i,j}\\n\\nstep-1: {a,c,e,g,i|b,d,f,h,j}\\nEncode using **num = (const * a) + b** for n to 2*n-1 indices of array\\n\\nstep-2: {a,c,e,g,i|(a+b),(c+d),(e+f),(g+h),(i+j)}\\nDecode a & b as-\\n**a = num/const\\nb = num%const**\\n\\nstep-3: {a,b,c,d,e|f,g,h,i,j}\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int k = 1001;\\n        int i,j;\\n        \\n        i = 0;\\n        for(j = n; j < 2*n; j++) { // TC: O(n)\\n            nums[j] = (nums[i] * k) + nums[j];\\n            i++;\\n        }\\n\\n        i = 0;\\n        for(j = n; j < 2*n; j++) { // TC: O(n)\\n            nums[i] = nums[j]/k;\\n            nums[i+1] = nums[j]%k;\\n            i += 2;\\n        }\\n\\n        return nums;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int k = 1001;\\n        int i,j;\\n        \\n        i = 0;\\n        for(j = n; j < 2*n; j++) { // TC: O(n)\\n            nums[j] = (nums[i] * k) + nums[j];\\n            i++;\\n        }\\n\\n        i = 0;\\n        for(j = n; j < 2*n; j++) { // TC: O(n)\\n            nums[i] = nums[j]/k;\\n            nums[i+1] = nums[j]%k;\\n            i += 2;\\n        }\\n\\n        return nums;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418893,
                "title": "java-100-faster-0-ms-easy-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] a = new int[2*n];\\n        int i=0,j;\\n        for(j=0; j<2*n; j+=2){\\n            a[j] = nums[i];\\n            a[j+1] = nums[i+n];\\n            i++;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] a = new int[2*n];\\n        int i=0,j;\\n        for(j=0; j<2*n; j+=2){\\n            a[j] = nums[i];\\n            a[j+1] = nums[i+n];\\n            i++;\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344398,
                "title": "even-and-odd-indices-are-kept-track-of-using-even-and-odd-variables",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe approach used in this function is to iterate through the elements of nums and place them in out according to their position in the shuffled sequence. The positions of the even and odd indices are kept track of using even and odd variables, respectively.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFor each element of nums, the function checks whether the index is less than n. If it is, then the element is placed at the current odd index of out and odd is incremented by 2 to prepare for the next odd index. Otherwise, the element is placed at the current even index of out and even is incremented by 2 to prepare for the next even index.\\n# Complexity\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe time complexity of this function is O(n), where n is the length of nums. This is because the function iterates through all elements of nums exactly once. The space complexity is also O(n), because the size of out is the same as the size of nums. However, the actual space used by out may be slightly larger due to the use of reserve and the allocation of memory in multiples of the vector\\'s capacity.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        size_t even(1);\\n        size_t odd(0);\\n        vector<int> out(nums.size(), 0);\\n\\n        for (size_t i = 0; i < nums.size(); i++) {\\n            if (static_cast<int>(i) < n) {\\n                out[odd] = nums[i];\\n                odd += 2;\\n            } else {\\n                out[even] = nums[i];\\n                even += 2;\\n            }\\n        }\\n\\n        return (out);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        size_t even(1);\\n        size_t odd(0);\\n        vector<int> out(nums.size(), 0);\\n\\n        for (size_t i = 0; i < nums.size(); i++) {\\n            if (static_cast<int>(i) < n) {\\n                out[odd] = nums[i];\\n                odd += 2;\\n            } else {\\n                out[even] = nums[i];\\n                even += 2;\\n            }\\n        }\\n\\n        return (out);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315646,
                "title": "100-beat-easiest-method-using-for-loop-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEven and Odd position \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n--> Let\\'s first create an answer array to which we will insert the resulted array.\\n--> Add elements to even position from given array nums.\\n--> Add elements on odd position from n to length of the nums.\\n--> In this way shuffle can be easily done.\\n--> If you like it please upvote.\\uD83D\\uDE0A Happy coding!\\n\\n\\n# Complexity\\n- Time complexity: 0 ms\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:42.8 Mb\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) \\n    {\\n        int[] ans = new int[nums.length];\\n        int k=0;\\n        int j=0;\\n        for(int i=0; i<nums.length ;i++)\\n        {\\n            \\n           if(i==0 || i % 2==0)\\n           {\\n               ans[k] = nums[j];\\n               k++;\\n               j++;\\n           }\\n           else\\n           {\\n               ans[k] = nums[n];\\n               n++;\\n               k++;\\n           }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) \\n    {\\n        int[] ans = new int[nums.length];\\n        int k=0;\\n        int j=0;\\n        for(int i=0; i<nums.length ;i++)\\n        {\\n            \\n           if(i==0 || i % 2==0)\\n           {\\n               ans[k] = nums[j];\\n               k++;\\n               j++;\\n           }\\n           else\\n           {\\n               ans[k] = nums[n];\\n               n++;\\n               k++;\\n           }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172547,
                "title": "js-runtime-91-58-memory-94-48",
                "content": "# Code\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    const arr1 = nums.slice(0, n).reverse();\\n    const arr2 = nums.slice(n).reverse();\\n\\n    for( let i=0; i< nums.length; i++ ) {\\n        if( i%2 === 0 ) {\\n            nums[i] = arr1.pop()\\n        } else {\\n            nums[i] = arr2.pop()\\n        }\\n    }\\n\\n    return nums;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number} n\\n * @return {number[]}\\n */\\nvar shuffle = function(nums, n) {\\n    const arr1 = nums.slice(0, n).reverse();\\n    const arr2 = nums.slice(n).reverse();\\n\\n    for( let i=0; i< nums.length; i++ ) {\\n        if( i%2 === 0 ) {\\n            nums[i] = arr1.pop()\\n        } else {\\n            nums[i] = arr2.pop()\\n        }\\n    }\\n\\n    return nums;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3152962,
                "title": "easy-solution-o-1-space",
                "content": "\\n\\n# Approach\\nThe first and the last numbers do not change. \\ninput:[1,2,3,4,4,3,2,1]\\noutput:[1,4,2,3,3,2,4,1]\\n\\nindex 0 and index length-1 have the desired elements.\\nSTEP1: index 1 is swapped with index n\\n        index 2 is swapped with n+1\\n        index 3 is swapped with n+2\\nNow if you check, index 1 and index length-2 have the desired element.\\ni.e [1,4,3,2,2,3,4,1]\\nSTEP2: Now start with index 2\\n        index 2 is swapped n\\n        index 3 is swapped with n+1\\ni.e [1,4,2,3,3,2,4,1]\\nAs you can see index 2 and index length-3 have the correct elements\\n\\nSTEP3: Start with index 3\\n    Index 3 is swapped with index n\\nThus we get the desired output.\\nie: [1,4,2,3,3,2,4,1]\\n    \\n\\n\\n# Code\\n```\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n      int low = 0;\\n      int high = n;  \\n      int temp = 0;\\n      for(int i = 1; i<n;i++)\\n      {\\n          low = i;\\n          high = n;\\n          for(int j=i; j<n;j++)\\n          {\\n                \\n                temp = nums[low];\\n                nums[low] = nums[high];\\n                nums[high] = temp;\\n                low++;\\n                high++;\\n\\n          }\\n      }\\n      return nums;\\n    \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n      int low = 0;\\n      int high = n;  \\n      int temp = 0;\\n      for(int i = 1; i<n;i++)\\n      {\\n          low = i;\\n          high = n;\\n          for(int j=i; j<n;j++)\\n          {\\n                \\n                temp = nums[low];\\n                nums[low] = nums[high];\\n                nums[high] = temp;\\n                low++;\\n                high++;\\n\\n          }\\n      }\\n      return nums;\\n    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151802,
                "title": "two-pointers-easy-understanding-python-3",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        l = 0\\n        r = n\\n        res = []\\n        while l < n:\\n            res.append(nums[l])\\n            res.append(nums[r])\\n            l+=1\\n            r+=1\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        l = 0\\n        r = n\\n        res = []\\n        while l < n:\\n            res.append(nums[l])\\n            res.append(nums[r])\\n            l+=1\\n            r+=1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3151714,
                "title": "simplest-solution-java",
                "content": "# Intuition\\nDivide the array into two half and alternatively merge the elements.\\n\\n# Approach\\nEvery element to be merged is at a distance of n.\\n\\n# Complexity\\n- Time complexity:\\nO(n/2)\\n\\n- Space complexity:\\nO(2n)\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int ans[]=new int [2*n];\\n        int k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans[k++]=nums[i];\\n            ans[k++]=nums[i+n];\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int ans[]=new int [2*n];\\n        int k=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans[k++]=nums[i];\\n            ans[k++]=nums[i+n];\\n        }\\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3150908,
                "title": "simple-java-c-2-lines-code-with-comments-readable-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        // Method - 1\\n\\n        // int [] arr = new int[nums.length];\\n        // int k = 0;\\n        // for(int i = 0, j = n; i < n; i ++,  j ++) {\\n        //     arr[k] = nums[i];\\n        //     k ++;\\n        //     arr[k] = nums[j];\\n        //     k ++;\\n        // }\\n        // return arr;\\n\\n        // Method - 2\\n\\n        int arr[] = new int[2 * n];\\n        for(int i = 0; i < n; i ++) {\\n            arr[i * 2] = nums[i];\\n            arr[i * 2 + 1] = nums[n + i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        // Method - 1\\n\\n        // int [] arr = new int[nums.length];\\n        // int k = 0;\\n        // for(int i = 0, j = n; i < n; i ++,  j ++) {\\n        //     arr[k] = nums[i];\\n        //     k ++;\\n        //     arr[k] = nums[j];\\n        //     k ++;\\n        // }\\n        // return arr;\\n\\n        // Method - 2\\n\\n        int arr[] = new int[2 * n];\\n        for(int i = 0; i < n; i ++) {\\n            arr[i * 2] = nums[i];\\n            arr[i * 2 + 1] = nums[n + i];\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149883,
                "title": "in-place-o-1-bit-wise-dry-run-explained-3-ways-meme",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nLet\\'s understand in general term:\\n\\nSuppose we have 2 numbers num1 = 4 and num2 = 9 and maxValue = 10\\nFormula:\\nto store -> pair = (num2 \\xD7 maxValue) + num1\\nto retrieve -> pair % maxValue and pair / maxValue\\n\\nStoring the pair of numbers\\n\\n(9 \\xD7 10) + 4 = 94 --> from above formula (num2 \\xD7 maxValue) + num1\\n94 is stored\\n\\nRetrieving each number one by one\\n\\n94 % 10 = 4\\nwe got first number as 4\\n\\n94 / 10 = 9\\nwe got second number as 9\\n\\nSame idea goes for large cases and array as well but instead of 10, we will take 1024 to store pairs and retrieve each number\\nNOTE: Here, we will take 1024 because of the given constraints 1 <= nums[i] <= 10^3 i.e. the largest number in the array will be 1000\\n\\nNow,\\nBinary representation of 1000 is 1111101000, consisting of total 10 bits\\nBinary representation of 1024 is 10000000000, consisting of total 11 bits\\nand if we multiply 1000 with 1024 i.e. (1000 * 1024), we will get 1024000\\nBinary representation of 1024000 is 11111010000000000000, consisting of total 20 bits which is less than the number of bits (32bits) of int data type, so we can store the number pairs(by multiplying one number with 1024 and adding another number to it) to retrieve each indivisual number later on(by taking out the remainder and the quotient).\\neg: suppose we have an array of length 4 and n is 2\\nnums = [5, 2, 1000, 3] and n = 2\\n\\nWe will store the pair of numbers first\\n\\n# According to algorithm\\n```\\n// to store the pair of numbers in right half of the original array\\nfor(int i = n; i < len; i++)\\nnums[i] = (nums[i] * 1024) + nums[i - n];\\n```\\n# Iteration 1:\\nwhen i = 2, (i = 2 because value of n is 2)\\nnums[2] = (1000 \\xD7 1024) + 5\\nso, nums[2] = 1024005\\n\\n# Iteration 2:\\nwhen i = 3,\\nnums[3] = (3 \\xD7 1024) + 2\\nso, nums[3] = 3074\\n\\nNow, the original array\\n[5, 2, 1000, 3]\\n0  1     2     3   <-- Indexes\\nbecomes\\n[5, 2, 1024005, 3074]\\n0  1        2          3   <-- Indexes\\n\\nWe will retrieve the numbers one by one from the pairs which we have stored at 2nd and 3rd index\\n\\n# According to algorithm\\n```\\n// to retrive values from the pair of numbers and placing those retrieved value at their desired position\\nint index = 0;\\nfor(int i = n; i < len; i++, index += 2){\\n\\tnums[index] = nums[i] % 1024;\\n\\tnums[index + 1] = nums[i] / 1024;\\n}\\n```\\n# Iteration 1:\\nwhen index = 0 and i = 2, (i = 2 because value of n is 2)\\nnums[0] = 1024005 % 1024 = 5\\nnums[1] = 1024005 / 1024 = 1000\\nnow, index = 2 (from index += 2)\\n\\n# Iteration 2:\\nwhen index = 2, i = 3,\\nnums[2] = 3074 % 1024 = 2\\nnums[3] = 3074 / 1024 = 3\\n\\nIteration will be stopped now as the condition become false and we got the array as following\\n[5, 1000, 2, 3] <-- Desired Output\\n0     1     2  3  <-- Indexes\\n\\n# COMPLEXITY:\\n\\nTime: O(n), where n is the given number, which is half of the length of the array\\nSpace: O(1), in-place\\nSince we need to solve it in 0(1) space or in-place, we will use the original array.\\n\\n# Code\\n```\\npublic int[] shuffle(int[] nums, int n) {\\n        int totalLength = nums.length, index = 0;\\n        for (int i = n; i < totalLength; i++) nums[i] = (nums[i] << 10) | nums[i - n];\\n        for (int i = n; i < totalLength; i++, index += 2) {\\n            nums[index] = nums[i] & 1023;\\n            nums[index + 1] = nums[i] >>> 10;\\n        } return nums;\\n    }\\n```\\n```\\npublic int[] shuffle(int[] nums, int n) {\\n         int j=0,A[] = new int[2*n];\\n        for(int i=0;i<n;i++){\\n             A[j++]=nums[i];\\n             A[j++]=nums[n+i];\\n        }return A;\\n}\\n```\\n\\n```\\npublic int[] shuffle(int[] nums, int n) {\\n        int len = nums.length,index = 0;\\n\\t\\t// to store the pair of numbers in right half of the original array\\n        for(int i = n; i < len; i++) nums[i] = (nums[i] * 1024) + nums[i - n];\\n\\t\\t// to retrive values from the pair of numbers and placing those retrieved value at their desired position\\n        for(int i = n; i < len; i++, index += 2) {\\n            nums[index] = nums[i] % 1024;\\n            nums[index + 1] = nums[i] / 1024;\\n        } return nums;\\n    }\\n```\\n![mem2.png](https://assets.leetcode.com/users/images/94667c14-d084-4538-bd5f-8c945ed69fdb_1675669826.456102.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\n// to store the pair of numbers in right half of the original array\\nfor(int i = n; i < len; i++)\\nnums[i] = (nums[i] * 1024) + nums[i - n];\\n```\n```\\n// to retrive values from the pair of numbers and placing those retrieved value at their desired position\\nint index = 0;\\nfor(int i = n; i < len; i++, index += 2){\\n\\tnums[index] = nums[i] % 1024;\\n\\tnums[index + 1] = nums[i] / 1024;\\n}\\n```\n```\\npublic int[] shuffle(int[] nums, int n) {\\n        int totalLength = nums.length, index = 0;\\n        for (int i = n; i < totalLength; i++) nums[i] = (nums[i] << 10) | nums[i - n];\\n        for (int i = n; i < totalLength; i++, index += 2) {\\n            nums[index] = nums[i] & 1023;\\n            nums[index + 1] = nums[i] >>> 10;\\n        } return nums;\\n    }\\n```\n```\\npublic int[] shuffle(int[] nums, int n) {\\n         int j=0,A[] = new int[2*n];\\n        for(int i=0;i<n;i++){\\n             A[j++]=nums[i];\\n             A[j++]=nums[n+i];\\n        }return A;\\n}\\n```\n```\\npublic int[] shuffle(int[] nums, int n) {\\n        int len = nums.length,index = 0;\\n\\t\\t// to store the pair of numbers in right half of the original array\\n        for(int i = n; i < len; i++) nums[i] = (nums[i] * 1024) + nums[i - n];\\n\\t\\t// to retrive values from the pair of numbers and placing those retrieved value at their desired position\\n        for(int i = n; i < len; i++, index += 2) {\\n            nums[index] = nums[i] % 1024;\\n            nums[index + 1] = nums[i] / 1024;\\n        } return nums;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3149840,
                "title": "easiest-way-c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& arr, int n) {\\n        vector<int> ans; // initialze for storing the suffled elements of given array\\n        for(int i = 0, j  = n; i < n && j < 2*n;i++,j++){ // first index starting from 0, and second index starting from middle of the array and at each iteration we have to move both by one, till the end\\n            ans.emplace_back(arr[i]);\\n            ans.emplace_back(arr[j]);\\n        }\\n        return ans;\\n    }\\n};\\n/* If you like it please do upvote */\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& arr, int n) {\\n        vector<int> ans; // initialze for storing the suffled elements of given array\\n        for(int i = 0, j  = n; i < n && j < 2*n;i++,j++){ // first index starting from 0, and second index starting from middle of the array and at each iteration we have to move both by one, till the end\\n            ans.emplace_back(arr[i]);\\n            ans.emplace_back(arr[j]);\\n        }\\n        return ans;\\n    }\\n};\\n/* If you like it please do upvote */\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149656,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>y,z,ans;\\n        for(int i=0;i<2*n;i++)\\n        {\\n            if(i<n) y.push_back(nums[i]);\\n            else z.push_back(nums[i]);\\n        }\\n        \\n        for(int i=0;i<y.size();i++)\\n        {\\n            ans.push_back(y[i]);\\n            ans.push_back(z[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>y,z,ans;\\n        for(int i=0;i<2*n;i++)\\n        {\\n            if(i<n) y.push_back(nums[i]);\\n            else z.push_back(nums[i]);\\n        }\\n        \\n        for(int i=0;i<y.size();i++)\\n        {\\n            ans.push_back(y[i]);\\n            ans.push_back(z[i]);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149299,
                "title": "short-simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) \\n    {\\n        int arr[]=new int[nums.length];\\n            int c=0;\\n        for (int i=0;i<arr.length;i=i+2)\\n        {\\n            arr[i]=nums[c];\\n            arr[i+1]=nums[n];\\n            c++;\\n            n++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) \\n    {\\n        int arr[]=new int[nums.length];\\n            int c=0;\\n        for (int i=0;i<arr.length;i=i+2)\\n        {\\n            arr[i]=nums[c];\\n            arr[i+1]=nums[n];\\n            c++;\\n            n++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149275,
                "title": "python-shortest-and-fastest-solution-explained-in-detail",
                "content": "**\\uD83D\\uDD3C IF YOU FIND THIS POST HELPFUL PLEASE UPVOTE \\uD83D\\uDC4D**\\n\\n**For Detailed Explaination Read this Blog:**\\nhttps://www.python-techs.com/2023/02/shuffle-array.html\\n\\n**Solution:**\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        # create an empty list to store the shuffled elements\\n        res = [] \\n        \\n        # loop through the first half of the elements (n elements)\\n        for i in range(n): \\n            # add the current element and the corresponding element from the \\n            # second half of the elements to the result list\\n            res.extend([nums[i], nums[i+n]])\\n        \\n        # return the shuffled list\\n        return res\\n```\\n**Thank you for reading! \\uD83D\\uDE04 Comment if you have any questions or feedback.**",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        # create an empty list to store the shuffled elements\\n        res = [] \\n        \\n        # loop through the first half of the elements (n elements)\\n        for i in range(n): \\n            # add the current element and the corresponding element from the \\n            # second half of the elements to the result list\\n            res.extend([nums[i], nums[i+n]])\\n        \\n        # return the shuffled list\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3149202,
                "title": "100-fast-simple-java-solution-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n           \\n           int []a =new int[2*n];\\n           int ind=0;\\n        for(int i=0;i<nums.length;i+=2){\\n            a[i]=nums[ind++];\\n            a[i+1]=nums[n++];\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n           \\n           int []a =new int[2*n];\\n           int ind=0;\\n        for(int i=0;i<nums.length;i+=2){\\n            a[i]=nums[ind++];\\n            a[i+1]=nums[n++];\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148915,
                "title": "python3-beginner-friendly-time-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis code is a Python implementation of a function that takes in two parameters: an array of integers nums and an integer n. The function shuffles the elements in nums and returns the shuffled array.\\n\\nThe shuffling is done by iterating over nums in steps of n, and appending the current element and the next element after n to the target array. The final target array is then returned as the result.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Create an empty list target to store the shuffled elements.\\n- Use a for loop to iterate over nums in steps of n.\\n- On each iteration, append the current element and the next element after n to the target list.\\n- Return the target list as the result.\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        target = []\\n        for i in range(0 , n ) :\\n            target.append(nums[i])\\n            target.append(nums[n + i ] )\\n        return target\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        target = []\\n        for i in range(0 , n ) :\\n            target.append(nums[i])\\n            target.append(nums[n + i ] )\\n        return target\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148880,
                "title": "python3-o-n-n-64ms-easiest-explaination-in-details",
                "content": "![Capture.PNG](https://assets.leetcode.com/users/images/9b08f84a-3862-48db-b425-3be774557967_1675655484.3949604.png)\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nwe want $$(0,n-1)$$ array **zipped** with $$(n, length(nums))$$ array. So we can use **two pointer** method.\\n\\n```\\n```\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- for combining left and right pointer pointed element $$initialise$$ $$left$$ and $$right$$ pointer with $$0$$ and $$n$$ value.\\n- our **left end** is where we **cross right** pointer initial position.\\n- our **right end** is where we **cross end of nums** array.\\n- now all values in place $$iterate$$ over array till $$left<n$$ and $$right<end$$.\\n- **append** element of left pointer array and right pointer array to answer array.\\n- **return $$answer$$**.\\n```\\n```\\n\\n\\n\\n# Complexity\\n- Time complexity: O(N-n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n```\\n```\\n\\n# Code\\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        ans = []\\n        left = 0\\n        right = n\\n        end = len(nums)\\n        while(left < n and right < end):\\n            ans.append(nums[left])\\n            ans.append(nums[right])\\n            left += 1\\n            right += 1\\n        return ans\\n```\\n# **Feel free to comment and suggest me anything, and doupvote this solution. ( \\u0361\\uD83D\\uDD25\\u202F\\u035C\\u0296 \\u0361\\uD83D\\uDD25) \\uD83D\\uDC49**\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Two Pointers"
                ],
                "code": "```\\n```\n```\\n```\n```\\n```\n```\\nclass Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        ans = []\\n        left = 0\\n        right = n\\n        end = len(nums)\\n        while(left < n and right < end):\\n            ans.append(nums[left])\\n            ans.append(nums[right])\\n            left += 1\\n            right += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148836,
                "title": "c-two-pointer-faster-easy-to-understand",
                "content": "* ***Using Two Pointer***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        \\n        // declare a res array\\n        \\n        vector<int> res;\\n        \\n        // use two pointers\\n        \\n        int i = 0;\\n        \\n        int j = n;\\n        \\n        // fill the res array according to condition\\n        \\n        while(i < n)\\n        {\\n            res.push_back(nums[i]);\\n            \\n            res.push_back(nums[j]);\\n            \\n            i++;\\n            \\n            j++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        \\n        // declare a res array\\n        \\n        vector<int> res;\\n        \\n        // use two pointers\\n        \\n        int i = 0;\\n        \\n        int j = n;\\n        \\n        // fill the res array according to condition\\n        \\n        while(i < n)\\n        {\\n            res.push_back(nums[i]);\\n            \\n            res.push_back(nums[j]);\\n            \\n            i++;\\n            \\n            j++;\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3148698,
                "title": "python-generators",
                "content": "```\\nreturn (nums[j] for i in range(n) for j in range(i, i + n + 1, n))\\n```\\n*Generators are special iterators in Python which returns the generator object. The point of using it, is to generate a sequence of items without having to store them in memory and this is why you can use Generator only once.*",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nreturn (nums[j] for i in range(n) for j in range(i, i + n + 1, n))\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3148573,
                "title": "0ms-easy-to-read-understand",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn shuffle(nums: Vec<i32>, n: i32) -> Vec<i32> {\\n        let n = n as usize;\\n        let mut result:Vec<i32> = vec![0;nums.len()];\\n\\n        for index in 0..n {\\n            let x_index = index *2;\\n            result[x_index] = nums[index];\\n            result[x_index + 1] = nums[index + n];\\n        }\\n        result\\n    }\\n}\\n```\\n# Iterators\\n```\\nimpl Solution {\\n    pub fn shuffle(nums: Vec<i32>, n: i32) -> Vec<i32> {\\n        let n = n as usize;\\n        (0..n).map(|i| ([nums[i],nums[i+n]]) ).flatten().collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn shuffle(nums: Vec<i32>, n: i32) -> Vec<i32> {\\n        let n = n as usize;\\n        let mut result:Vec<i32> = vec![0;nums.len()];\\n\\n        for index in 0..n {\\n            let x_index = index *2;\\n            result[x_index] = nums[index];\\n            result[x_index + 1] = nums[index + n];\\n        }\\n        result\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn shuffle(nums: Vec<i32>, n: i32) -> Vec<i32> {\\n        let n = n as usize;\\n        (0..n).map(|i| ([nums[i],nums[i+n]]) ).flatten().collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3148425,
                "title": "java-simple-approach",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] array=new int[nums.length];\\n        int index=0;\\n        for(int i=0; i<nums.length/2; i++){\\n            array[index]=nums[i];\\n            index++;\\n            array[index]=nums[array.length/2+i];\\n            index++;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] array=new int[nums.length];\\n        int index=0;\\n        for(int i=0; i<nums.length/2; i++){\\n            array[index]=nums[i];\\n            index++;\\n            array[index]=nums[array.length/2+i];\\n            index++;\\n        }\\n        return array;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130074,
                "title": "j",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] a=new int[nums.length];\\n        int t=0;\\n        for(int i=0,j=n;i<n&&j<nums.length;i++,j++){\\n            a[t++]=nums[i];\\n            a[t++]=nums[j];\\n            //System.out.println(nums[i]+\" \"+nums[j]);\\n        }\\n        return a;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] a=new int[nums.length];\\n        int t=0;\\n        for(int i=0,j=n;i<n&&j<nums.length;i++,j++){\\n            a[t++]=nums[i];\\n            a[t++]=nums[j];\\n            //System.out.println(nums[i]+\" \"+nums[j]);\\n        }\\n        return a;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2808217,
                "title": "java-easy-solution-o-n",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] arr=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k=k+2){\\n            arr[k]=nums[i];\\n            arr[k+1]=nums[j];\\n            i++;\\n            j++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] arr=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k=k+2){\\n            arr[k]=nums[i];\\n            arr[k+1]=nums[j];\\n            i++;\\n            j++;\\n        }\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707599,
                "title": "java-0-ms-faster-than-100-00-of-java-online-submissions-for-shuffle-the-array",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int fistPart = 0;\\n        int secondPart = n;\\n        int[] res = new int[nums.length];\\n\\n        for (int i = 0; i < nums.length; ) {\\n            res[i++] = nums[fistPart++];\\n            res[i++] = nums[secondPart++];\\n        }\\n        return res;\\n   \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int fistPart = 0;\\n        int secondPart = n;\\n        int[] res = new int[nums.length];\\n\\n        for (int i = 0; i < nums.length; ) {\\n            res[i++] = nums[fistPart++];\\n            res[i++] = nums[secondPart++];\\n        }\\n        return res;\\n   \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2697447,
                "title": "js-very-easy-solution",
                "content": "![image](https://assets.leetcode.com/users/images/973c2781-8ad1-4682-924d-9b8cf7f40101_1665645082.7997556.png)\\n\\n```\\nvar shuffle = function(nums, n) {\\n    const output = new Array(2*n);\\n    for (let i = 0; i < n; i++) {\\n        output[2*i] = nums[i];\\n        output[2*i+1] = nums[n+i];\\n    }\\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shuffle = function(nums, n) {\\n    const output = new Array(2*n);\\n    for (let i = 0; i < n; i++) {\\n        output[2*i] = nums[i];\\n        output[2*i+1] = nums[n+i];\\n    }\\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2548250,
                "title": "easy-to-understand-java-solution-simple-while-loop",
                "content": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] arr = new int[nums.length];\\n        int i=0;\\n\\t    int j=0;\\n        while(i<n) {\\n                arr[i] = nums[j];\\n                i++;\\n                j++;\\n                arr[i] = nums[n];\\n                i++;\\n                n++;\\n            }\\n\\n        \\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] arr = new int[nums.length];\\n        int i=0;\\n\\t    int j=0;\\n        while(i<n) {\\n                arr[i] = nums[j];\\n                i++;\\n                j++;\\n                arr[i] = nums[n];\\n                i++;\\n                n++;\\n            }\\n\\n        \\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470030,
                "title": "java-easy-solution-0ms-100-faster",
                "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n\\t\\n        int[] ans = new int[n*2]; //creating 2n length of array\\n        for(int i=0; i<n; i++) {\\n            ans[i*2] = nums[i]; // ans[i(0,1,2) * 2]=nums[0,1,2]   //[2,_,5,_,1,_]  \\n            ans[i*2+1] = nums[i+n];// ans[i(0,1,2) * 2 + 1]=nums[0,1,2 + 1]  // [2,3,5,4,1,7]\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n\\t\\n        int[] ans = new int[n*2]; //creating 2n length of array\\n        for(int i=0; i<n; i++) {\\n            ans[i*2] = nums[i]; // ans[i(0,1,2) * 2]=nums[0,1,2]   //[2,_,5,_,1,_]  \\n            ans[i*2+1] = nums[i+n];// ans[i(0,1,2) * 2 + 1]=nums[0,1,2 + 1]  // [2,3,5,4,1,7]\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2406866,
                "title": "simple-python-code-with-explanation",
                "content": "```\\nclass Solution:\\n        #two pointers approach\\n        def shuffle(self, nums: List[int], n: int) -> List[int]:\\n                #initialise the l pointer to 0th index\\n                l = 0 \\n                #initialise the r pointer to middle index\\n                r = len(nums)//2\\n                #create the new list (res)\\n                res = []\\n                #condition breaks when l pointer reaches middle index \\n                #and r pointer reaches the last index\\n                while l < len(nums)//2 and r < len(nums):\\n                        #add the element at l pointer to res -->list\\n                        res.append(nums[l])\\n                        #after adding increase the l pointer by 1\\n                        l = l + 1\\n                        #add the element at r pointer to res-->list\\n                        res.append(nums[r])\\n                        #after adding increase the r pointer by 1\\n                        r = r +1\\n        \\n                #after breaking while loop return res--> list        \\n                return res\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n        #two pointers approach\\n        def shuffle(self, nums: List[int], n: int) -> List[int]:\\n                #initialise the l pointer to 0th index\\n                l = 0 \\n                #initialise the r pointer to middle index\\n                r = len(nums)//2\\n                #create the new list (res)\\n                res = []\\n                #condition breaks when l pointer reaches middle index \\n                #and r pointer reaches the last index\\n                while l < len(nums)//2 and r < len(nums):\\n                        #add the element at l pointer to res -->list\\n                        res.append(nums[l])\\n                        #after adding increase the l pointer by 1\\n                        l = l + 1\\n                        #add the element at r pointer to res-->list\\n                        res.append(nums[r])\\n                        #after adding increase the r pointer by 1\\n                        r = r +1\\n        \\n                #after breaking while loop return res--> list        \\n                return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352824,
                "title": "java-100-faster-0ms",
                "content": "If you like this solution, Upvote it.\\n```\\nint[] arr = new int[2*n];  // new array of 2*n size.\\n        for(int i=0;i<n;i++){\\n            arr[i*2] = nums[i];       // even index elements.\\n            arr[(i*2)+1] = nums[i+n]; // odd index elements.\\n        }\\n        return arr;\\n```\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint[] arr = new int[2*n];  // new array of 2*n size.\\n        for(int i=0;i<n;i++){\\n            arr[i*2] = nums[i];       // even index elements.\\n            arr[(i*2)+1] = nums[i+n]; // odd index elements.\\n        }\\n        return arr;\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1790015,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1789812,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1661982,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1566949,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1790271,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1782376,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1790161,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1569985,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1789903,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1635681,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1790015,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1789812,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1661982,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1566949,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1790271,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1782376,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1790161,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1569985,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1789903,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1635681,
                "content": [
                    {
                        "username": "thakurpriyansh019",
                        "content": "It\\'s an easy question if you are taking space (extra array) but it\\'s a very decent medium level question if interviewer asks you to make changes in original array without taking extra space... One of the trickiest question I\\'ve ever come across"
                    },
                    {
                        "username": "Abhijit_the_coder_123",
                        "content": "[@Finesse](/Finesse) please can you tall me about this formula "
                    },
                    {
                        "username": "theAchiever",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019)  Hey can you tell how to store 2 values in the same index.\\n"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "[@thakurpriyansh019](/thakurpriyansh019) Are you talking about XOR?"
                    },
                    {
                        "username": "thakurpriyansh019",
                        "content": "[@haibrenner](/haibrenner) there is a way of storing 2 values in one index.... Try to figure out else comment me back"
                    },
                    {
                        "username": "Finesse",
                        "content": "[@haibrenner](/haibrenner) Since the value range is very limited, you can use the greater 2 bytes of the `nums` values to store the result.\n\nMathematically speaking, you use an extra space, but technically you allocate no extra memory."
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@haibrenner](/haibrenner) one method uses nested loops. You can use a trick to mark \\'correct\\' values when you know they are in the right place, so its still O(n) time despite nesting loops.\\n\\nThe given answer is a frustrating \"clever\" trick: ie, cheating with bit manipulation. Note the size of the possible input values. "
                    },
                    {
                        "username": "haibrenner",
                        "content": "Any hints on how to do it in O(1) extra space?"
                    },
                    {
                        "username": "vedmidu4asi",
                        "content": "I guess this is top 2nd simplest problem on leetcode after adding two numbers."
                    },
                    {
                        "username": "tobilarry",
                        "content": "only easy if you introduce a new array. \\nif you are modifying existing array, it is not"
                    },
                    {
                        "username": "muneerwani78",
                        "content": "dont post useless stuff if its easy for you u can shut your mouth some find it diificult and lose confidence type helpfull things"
                    },
                    {
                        "username": "Isha307",
                        "content": "only if you are using extra space, without extra space it\\'s a medium level problem."
                    },
                    {
                        "username": "giriraj97",
                        "content": "try doing without extra space"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "May seem so but in my opinion thinking about an in-place algorithm is a challenge ."
                    },
                    {
                        "username": "Bobzero",
                        "content": "CAREFUL.. The \"n\" inside the parameter is not an element of the array, it is an index of the array.\nDO NOT DO THE SAME MISTAKE I DID."
                    },
                    {
                        "username": "Knight-03",
                        "content": "that means you haven\\'t read the problem properly. \\uD83D\\uDE05"
                    },
                    {
                        "username": "Manci-Ayman",
                        "content": "[@yxzhang135](/yxzhang135) Yes!"
                    },
                    {
                        "username": "WhatTheFuzz",
                        "content": "[@yxzhang135](/yxzhang135) You could consider it the middle of the array (with a one-based index). Another way to look at is the index at which Y starts in the original way. Yet another way to look at it is the number of XY pairs in the original array. I hope that helps!"
                    },
                    {
                        "username": "yxzhang135",
                        "content": "is \"n\" the middle index of the array?"
                    },
                    {
                        "username": "tuttlepower",
                        "content": "You would think they would have made at least one of the examples not be the value AND the index lol "
                    },
                    {
                        "username": "ps_why",
                        "content": "All I see here is O(n) space. \\nThe question is Easy tagged so O(n) should be suffice, but I either want to know if an in-place algorithm exists, or, if not - how to give myself a short but convincing proof that constant space is not possible"
                    },
                    {
                        "username": "priyankajhamb",
                        "content": "yes, it exists:\nfor(int i=n-1; i>=1; i--){\n            for(int j=i; j<i+i; j++ ){\n                swap (jth element with (j+1)th element)\n            }\n        }\n// for example\n// if n=4\n        // swapping done from the index\n        // 3-6 firstly\n        // 2-4 secondly\n        // 1-2 thirdly"
                    },
                    {
                        "username": "cswartzell",
                        "content": "[@PAIN_an_c](/PAIN_an_c) In Big O notation we drop constants, so 2*n  = n. Big O is kind of a hazy \"class of problem\" rather than an exact number of steps or whatever. A poorly written O(n) solution *can* perform worse than a well written O(n**2) solution, if the O(n) involves say recreating giant data structures over and over. But thats assuming a realistic or small n. Given a large enough n, O(n**2) will always perform worse, and when talking about big O we assume n is large."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "i think it is o(2*n)"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "vishwa10032003",
                        "content": "The problem \"Shuffle the Array\" is a simple array manipulation problem where the goal is to shuffle an array in a particular manner. Given an array nums consisting of 2n elements in the form [x1,x2,...,xn,y1,y2,...,yn] and an integer n, the task is to return the array in the form [x1,y1,x2,y2,...,xn,yn].\\n\\nFor example, consider the input array nums = [2,5,1,3,4,7] and n = 3. Here x1=2, x2=5, x3=1, y1=3, y2=4, y3=7. The expected output is [2,3,5,4,1,7].\\n\\nTo solve this problem, one can simply loop through the array nums and place the elements at alternate positions in a new array. For example, nums[0] should be placed at position 0, nums[n] should be placed at position 1, nums[1] should be placed at position 2 and so on.                                                                                                 \\n                                                                          \\n It\\'s important to note that the constraints given in the problem (1 <= n <= 500 and 1 <= nums[i] <= 10^3)                                                             allow for an efficient solution with linear time complexity O(n)."
                    },
                    {
                        "username": "Kalpit_Rathi",
                        "content": "100% faster solution in java || Very easy\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] ans = new int[2*n];\\n\\n        for (int i = 0; i < n; i++)\\n        {\\n            ans[2*i] = nums[i];\\n            ans[(2*i) + 1] = nums[i + n];\\n        }\\n\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "duncandmp12",
                        "content": "u spoiled me :(((((((((("
                    },
                    {
                        "username": "barunchaudhury1",
                        "content": "This is not solution tab"
                    },
                    {
                        "username": "rammanoj",
                        "content": "Please do not post your solution here. It violates the rule. Also, this is not as easy as it looks. Try using O(1) space to solve this."
                    },
                    {
                        "username": "Def8",
                        "content": "Kindly do not post solutions here."
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "Venki_Reddy",
                        "content": "Good Question if asked to solve without using any Extra Space."
                    },
                    {
                        "username": "Gias_uddin_vuiya",
                        "content": "At first you have to solve it without extra space"
                    },
                    {
                        "username": "fatalalexa",
                        "content": "\\'\\'\\'\\nn1 = nums[0:n]\\nn2 = nums[n:]\\nn3 = []\\nfor i in range(n):\\n    n3.append(n1[i])\\n    n3.append(n2[i])\\nreturn n3\\n\\'\\'\\'"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!\\n"
                    },
                    {
                        "username": "AdityaBhate",
                        "content": "https://leetcode.com/problems/shuffle-the-array/solutions/2168062/100-fast-0ms-optimal-ez-code/"
                    },
                    {
                        "username": "sasukesharma",
                        "content": "happy EASY monday"
                    },
                    {
                        "username": "Shivam_verma24",
                        "content": "Solve without using auxiliary space to ruin your monday"
                    },
                    {
                        "username": "sAd_sOuL",
                        "content": "Indeed it is ;)"
                    },
                    {
                        "username": "Damiya",
                        "content": "What is n here? the index  of the array or the value where the shuffling will start?"
                    },
                    {
                        "username": "402Coder",
                        "content": "n represents the number of x, y pairs there will be in the array.  2n is the total number of individual elements."
                    },
                    {
                        "username": "Keshav_Lard",
                        "content": "you can consider it as an index"
                    }
                ]
            },
            {
                "id": 1575283,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/9d8000e0-2999-4894-846e-ab5a5daa93ab_1621490968.1599236.png)\\n"
                    },
                    {
                        "username": "Def8",
                        "content": "You may not post solutions here."
                    },
                    {
                        "username": "longdogialong123",
                        "content": "why do you have to use two for? "
                    },
                    {
                        "username": "mdcse",
                        "content": "You should not post solution here.\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is an easy problem if you use extra space. But in order to do without extra space you need to use the technique of encoding two numbers in one. For this technique to work, the numbers should be positive and should be under a certain limit.\n\n<details>\n<summary>Spoiler Alert</summary>\n\n ```cpp\n class Solution {\n public:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int max_val = INT_MIN;\n        for(int val: nums) \n            max_val = max(max_val, val);\n        max_val++;\n        for(int i=0; i<(2*n); i++) {\n            int val = (i&1) ? nums[n+(i/2)] : nums[i/2];\n            nums[i] += (val%max_val) * max_val;\n        }\n        for(int i=0; i<(2*n); i++)\n            nums[i] /= max_val;\n        return nums;\n     }\n };\n```\n</details>"
                    },
                    {
                        "username": "the_eagle02",
                        "content": "`Just Maths Puzzle... Interesting when you solved problem without using extra array... Remember you are going to do your first try to solve but after some time you see its also easy and fun to do without extra new array...\\nHappy LeetCoding!!```"
                    },
                    {
                        "username": "zaureqs",
                        "content": "too lazy to write code \\ncopied submission from my girlfriend\\'s account \\uD83D\\uDE05 \\nstill runtime is 93% \\uD83D\\uDE0C "
                    },
                    {
                        "username": "Knight-03",
                        "content": ": ) noice beta "
                    },
                    {
                        "username": "govindamandal",
                        "content": "In the case using C++ STL\\n\\nCreate a new vector arr of int which you will return and then apply the loop through i = 0 to n\\n\\n        for (int i = 0; i < n; i ++) {\\n            arr.push_back(nums.at(i));\\n            arr.push_back(nums.at(n + i));\\n        }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "kd_5304",
                        "content": "This problem is easy to solve in O(n) space. The real challenge is to solve it in O(1) space. Any ideas how?"
                    },
                    {
                        "username": "igorRC",
                        "content": "Solution in Java with runtime : 0 ms\\n    public int[] shuffle(int[] nums, int n) {\\n        int combinacion []= new int[nums.length]; \\n        for(int i = 0 , j = 1 , k = 0 ; n < nums.length; i=i+2 , j=j+2){\\n            combinacion[i] = nums[k++];\\n            combinacion[j] = nums[n++];\\n        }\\n        return combinacion;\\n    }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "klu_2100031265",
                        "content": "simple and easy java technique\\n\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int b[]=new int[n*2];\\n\\t\\tint f=0,s=1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tb[f]=nums[i];\\n\\t\\t\\tb[s]=nums[i+n];\\n\\t\\t\\tf+=2;\\n\\t\\t\\ts+=2;\\n\\t\\t}\\n        return b;\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "excellent !!\\n"
                    },
                    {
                        "username": "vijaychaudharivc",
                        "content": "Algorithm :\\n1) take two interator, one starts from begin and second from nth position\\n2)  put these interator values from nums array to new arr \\n3) increase these interator\\n4) reapeat step from 1 to 3 until   first_interator != second_interator\\n--------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int mid = n;\\n        int [] arr = new int[nums.length];\\n        // put two element inside arr array at a time so maintaining index we use array_index\\n        int array_index = 0;\\n\\n        for(int i=0;i != n;i++){\\n           arr[array_index] = nums[i];\\n           array_index++;\\n\\n           arr[array_index] = nums[mid];\\n           array_index++;\\n           \\n           mid++;\\n          \\n        }\\n\\n        return arr;\\n\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Shrayash_17",
                        "content": "if u r beginner \\nuse this approach \\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp[]=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                temp[k]=nums[i++];\\n            }\\n            else \\n            {\\n                temp[k]=nums[j++];\\n            }\\n        }\\n        return temp;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1790718,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/9d8000e0-2999-4894-846e-ab5a5daa93ab_1621490968.1599236.png)\\n"
                    },
                    {
                        "username": "Def8",
                        "content": "You may not post solutions here."
                    },
                    {
                        "username": "longdogialong123",
                        "content": "why do you have to use two for? "
                    },
                    {
                        "username": "mdcse",
                        "content": "You should not post solution here.\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is an easy problem if you use extra space. But in order to do without extra space you need to use the technique of encoding two numbers in one. For this technique to work, the numbers should be positive and should be under a certain limit.\n\n<details>\n<summary>Spoiler Alert</summary>\n\n ```cpp\n class Solution {\n public:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int max_val = INT_MIN;\n        for(int val: nums) \n            max_val = max(max_val, val);\n        max_val++;\n        for(int i=0; i<(2*n); i++) {\n            int val = (i&1) ? nums[n+(i/2)] : nums[i/2];\n            nums[i] += (val%max_val) * max_val;\n        }\n        for(int i=0; i<(2*n); i++)\n            nums[i] /= max_val;\n        return nums;\n     }\n };\n```\n</details>"
                    },
                    {
                        "username": "the_eagle02",
                        "content": "`Just Maths Puzzle... Interesting when you solved problem without using extra array... Remember you are going to do your first try to solve but after some time you see its also easy and fun to do without extra new array...\\nHappy LeetCoding!!```"
                    },
                    {
                        "username": "zaureqs",
                        "content": "too lazy to write code \\ncopied submission from my girlfriend\\'s account \\uD83D\\uDE05 \\nstill runtime is 93% \\uD83D\\uDE0C "
                    },
                    {
                        "username": "Knight-03",
                        "content": ": ) noice beta "
                    },
                    {
                        "username": "govindamandal",
                        "content": "In the case using C++ STL\\n\\nCreate a new vector arr of int which you will return and then apply the loop through i = 0 to n\\n\\n        for (int i = 0; i < n; i ++) {\\n            arr.push_back(nums.at(i));\\n            arr.push_back(nums.at(n + i));\\n        }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "kd_5304",
                        "content": "This problem is easy to solve in O(n) space. The real challenge is to solve it in O(1) space. Any ideas how?"
                    },
                    {
                        "username": "igorRC",
                        "content": "Solution in Java with runtime : 0 ms\\n    public int[] shuffle(int[] nums, int n) {\\n        int combinacion []= new int[nums.length]; \\n        for(int i = 0 , j = 1 , k = 0 ; n < nums.length; i=i+2 , j=j+2){\\n            combinacion[i] = nums[k++];\\n            combinacion[j] = nums[n++];\\n        }\\n        return combinacion;\\n    }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "klu_2100031265",
                        "content": "simple and easy java technique\\n\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int b[]=new int[n*2];\\n\\t\\tint f=0,s=1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tb[f]=nums[i];\\n\\t\\t\\tb[s]=nums[i+n];\\n\\t\\t\\tf+=2;\\n\\t\\t\\ts+=2;\\n\\t\\t}\\n        return b;\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "excellent !!\\n"
                    },
                    {
                        "username": "vijaychaudharivc",
                        "content": "Algorithm :\\n1) take two interator, one starts from begin and second from nth position\\n2)  put these interator values from nums array to new arr \\n3) increase these interator\\n4) reapeat step from 1 to 3 until   first_interator != second_interator\\n--------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int mid = n;\\n        int [] arr = new int[nums.length];\\n        // put two element inside arr array at a time so maintaining index we use array_index\\n        int array_index = 0;\\n\\n        for(int i=0;i != n;i++){\\n           arr[array_index] = nums[i];\\n           array_index++;\\n\\n           arr[array_index] = nums[mid];\\n           array_index++;\\n           \\n           mid++;\\n          \\n        }\\n\\n        return arr;\\n\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Shrayash_17",
                        "content": "if u r beginner \\nuse this approach \\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp[]=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                temp[k]=nums[i++];\\n            }\\n            else \\n            {\\n                temp[k]=nums[j++];\\n            }\\n        }\\n        return temp;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1790398,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/9d8000e0-2999-4894-846e-ab5a5daa93ab_1621490968.1599236.png)\\n"
                    },
                    {
                        "username": "Def8",
                        "content": "You may not post solutions here."
                    },
                    {
                        "username": "longdogialong123",
                        "content": "why do you have to use two for? "
                    },
                    {
                        "username": "mdcse",
                        "content": "You should not post solution here.\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is an easy problem if you use extra space. But in order to do without extra space you need to use the technique of encoding two numbers in one. For this technique to work, the numbers should be positive and should be under a certain limit.\n\n<details>\n<summary>Spoiler Alert</summary>\n\n ```cpp\n class Solution {\n public:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int max_val = INT_MIN;\n        for(int val: nums) \n            max_val = max(max_val, val);\n        max_val++;\n        for(int i=0; i<(2*n); i++) {\n            int val = (i&1) ? nums[n+(i/2)] : nums[i/2];\n            nums[i] += (val%max_val) * max_val;\n        }\n        for(int i=0; i<(2*n); i++)\n            nums[i] /= max_val;\n        return nums;\n     }\n };\n```\n</details>"
                    },
                    {
                        "username": "the_eagle02",
                        "content": "`Just Maths Puzzle... Interesting when you solved problem without using extra array... Remember you are going to do your first try to solve but after some time you see its also easy and fun to do without extra new array...\\nHappy LeetCoding!!```"
                    },
                    {
                        "username": "zaureqs",
                        "content": "too lazy to write code \\ncopied submission from my girlfriend\\'s account \\uD83D\\uDE05 \\nstill runtime is 93% \\uD83D\\uDE0C "
                    },
                    {
                        "username": "Knight-03",
                        "content": ": ) noice beta "
                    },
                    {
                        "username": "govindamandal",
                        "content": "In the case using C++ STL\\n\\nCreate a new vector arr of int which you will return and then apply the loop through i = 0 to n\\n\\n        for (int i = 0; i < n; i ++) {\\n            arr.push_back(nums.at(i));\\n            arr.push_back(nums.at(n + i));\\n        }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "kd_5304",
                        "content": "This problem is easy to solve in O(n) space. The real challenge is to solve it in O(1) space. Any ideas how?"
                    },
                    {
                        "username": "igorRC",
                        "content": "Solution in Java with runtime : 0 ms\\n    public int[] shuffle(int[] nums, int n) {\\n        int combinacion []= new int[nums.length]; \\n        for(int i = 0 , j = 1 , k = 0 ; n < nums.length; i=i+2 , j=j+2){\\n            combinacion[i] = nums[k++];\\n            combinacion[j] = nums[n++];\\n        }\\n        return combinacion;\\n    }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "klu_2100031265",
                        "content": "simple and easy java technique\\n\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int b[]=new int[n*2];\\n\\t\\tint f=0,s=1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tb[f]=nums[i];\\n\\t\\t\\tb[s]=nums[i+n];\\n\\t\\t\\tf+=2;\\n\\t\\t\\ts+=2;\\n\\t\\t}\\n        return b;\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "excellent !!\\n"
                    },
                    {
                        "username": "vijaychaudharivc",
                        "content": "Algorithm :\\n1) take two interator, one starts from begin and second from nth position\\n2)  put these interator values from nums array to new arr \\n3) increase these interator\\n4) reapeat step from 1 to 3 until   first_interator != second_interator\\n--------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int mid = n;\\n        int [] arr = new int[nums.length];\\n        // put two element inside arr array at a time so maintaining index we use array_index\\n        int array_index = 0;\\n\\n        for(int i=0;i != n;i++){\\n           arr[array_index] = nums[i];\\n           array_index++;\\n\\n           arr[array_index] = nums[mid];\\n           array_index++;\\n           \\n           mid++;\\n          \\n        }\\n\\n        return arr;\\n\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Shrayash_17",
                        "content": "if u r beginner \\nuse this approach \\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp[]=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                temp[k]=nums[i++];\\n            }\\n            else \\n            {\\n                temp[k]=nums[j++];\\n            }\\n        }\\n        return temp;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1789917,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/9d8000e0-2999-4894-846e-ab5a5daa93ab_1621490968.1599236.png)\\n"
                    },
                    {
                        "username": "Def8",
                        "content": "You may not post solutions here."
                    },
                    {
                        "username": "longdogialong123",
                        "content": "why do you have to use two for? "
                    },
                    {
                        "username": "mdcse",
                        "content": "You should not post solution here.\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is an easy problem if you use extra space. But in order to do without extra space you need to use the technique of encoding two numbers in one. For this technique to work, the numbers should be positive and should be under a certain limit.\n\n<details>\n<summary>Spoiler Alert</summary>\n\n ```cpp\n class Solution {\n public:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int max_val = INT_MIN;\n        for(int val: nums) \n            max_val = max(max_val, val);\n        max_val++;\n        for(int i=0; i<(2*n); i++) {\n            int val = (i&1) ? nums[n+(i/2)] : nums[i/2];\n            nums[i] += (val%max_val) * max_val;\n        }\n        for(int i=0; i<(2*n); i++)\n            nums[i] /= max_val;\n        return nums;\n     }\n };\n```\n</details>"
                    },
                    {
                        "username": "the_eagle02",
                        "content": "`Just Maths Puzzle... Interesting when you solved problem without using extra array... Remember you are going to do your first try to solve but after some time you see its also easy and fun to do without extra new array...\\nHappy LeetCoding!!```"
                    },
                    {
                        "username": "zaureqs",
                        "content": "too lazy to write code \\ncopied submission from my girlfriend\\'s account \\uD83D\\uDE05 \\nstill runtime is 93% \\uD83D\\uDE0C "
                    },
                    {
                        "username": "Knight-03",
                        "content": ": ) noice beta "
                    },
                    {
                        "username": "govindamandal",
                        "content": "In the case using C++ STL\\n\\nCreate a new vector arr of int which you will return and then apply the loop through i = 0 to n\\n\\n        for (int i = 0; i < n; i ++) {\\n            arr.push_back(nums.at(i));\\n            arr.push_back(nums.at(n + i));\\n        }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "kd_5304",
                        "content": "This problem is easy to solve in O(n) space. The real challenge is to solve it in O(1) space. Any ideas how?"
                    },
                    {
                        "username": "igorRC",
                        "content": "Solution in Java with runtime : 0 ms\\n    public int[] shuffle(int[] nums, int n) {\\n        int combinacion []= new int[nums.length]; \\n        for(int i = 0 , j = 1 , k = 0 ; n < nums.length; i=i+2 , j=j+2){\\n            combinacion[i] = nums[k++];\\n            combinacion[j] = nums[n++];\\n        }\\n        return combinacion;\\n    }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "klu_2100031265",
                        "content": "simple and easy java technique\\n\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int b[]=new int[n*2];\\n\\t\\tint f=0,s=1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tb[f]=nums[i];\\n\\t\\t\\tb[s]=nums[i+n];\\n\\t\\t\\tf+=2;\\n\\t\\t\\ts+=2;\\n\\t\\t}\\n        return b;\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "excellent !!\\n"
                    },
                    {
                        "username": "vijaychaudharivc",
                        "content": "Algorithm :\\n1) take two interator, one starts from begin and second from nth position\\n2)  put these interator values from nums array to new arr \\n3) increase these interator\\n4) reapeat step from 1 to 3 until   first_interator != second_interator\\n--------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int mid = n;\\n        int [] arr = new int[nums.length];\\n        // put two element inside arr array at a time so maintaining index we use array_index\\n        int array_index = 0;\\n\\n        for(int i=0;i != n;i++){\\n           arr[array_index] = nums[i];\\n           array_index++;\\n\\n           arr[array_index] = nums[mid];\\n           array_index++;\\n           \\n           mid++;\\n          \\n        }\\n\\n        return arr;\\n\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Shrayash_17",
                        "content": "if u r beginner \\nuse this approach \\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp[]=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                temp[k]=nums[i++];\\n            }\\n            else \\n            {\\n                temp[k]=nums[j++];\\n            }\\n        }\\n        return temp;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1756307,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/9d8000e0-2999-4894-846e-ab5a5daa93ab_1621490968.1599236.png)\\n"
                    },
                    {
                        "username": "Def8",
                        "content": "You may not post solutions here."
                    },
                    {
                        "username": "longdogialong123",
                        "content": "why do you have to use two for? "
                    },
                    {
                        "username": "mdcse",
                        "content": "You should not post solution here.\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is an easy problem if you use extra space. But in order to do without extra space you need to use the technique of encoding two numbers in one. For this technique to work, the numbers should be positive and should be under a certain limit.\n\n<details>\n<summary>Spoiler Alert</summary>\n\n ```cpp\n class Solution {\n public:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int max_val = INT_MIN;\n        for(int val: nums) \n            max_val = max(max_val, val);\n        max_val++;\n        for(int i=0; i<(2*n); i++) {\n            int val = (i&1) ? nums[n+(i/2)] : nums[i/2];\n            nums[i] += (val%max_val) * max_val;\n        }\n        for(int i=0; i<(2*n); i++)\n            nums[i] /= max_val;\n        return nums;\n     }\n };\n```\n</details>"
                    },
                    {
                        "username": "the_eagle02",
                        "content": "`Just Maths Puzzle... Interesting when you solved problem without using extra array... Remember you are going to do your first try to solve but after some time you see its also easy and fun to do without extra new array...\\nHappy LeetCoding!!```"
                    },
                    {
                        "username": "zaureqs",
                        "content": "too lazy to write code \\ncopied submission from my girlfriend\\'s account \\uD83D\\uDE05 \\nstill runtime is 93% \\uD83D\\uDE0C "
                    },
                    {
                        "username": "Knight-03",
                        "content": ": ) noice beta "
                    },
                    {
                        "username": "govindamandal",
                        "content": "In the case using C++ STL\\n\\nCreate a new vector arr of int which you will return and then apply the loop through i = 0 to n\\n\\n        for (int i = 0; i < n; i ++) {\\n            arr.push_back(nums.at(i));\\n            arr.push_back(nums.at(n + i));\\n        }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "kd_5304",
                        "content": "This problem is easy to solve in O(n) space. The real challenge is to solve it in O(1) space. Any ideas how?"
                    },
                    {
                        "username": "igorRC",
                        "content": "Solution in Java with runtime : 0 ms\\n    public int[] shuffle(int[] nums, int n) {\\n        int combinacion []= new int[nums.length]; \\n        for(int i = 0 , j = 1 , k = 0 ; n < nums.length; i=i+2 , j=j+2){\\n            combinacion[i] = nums[k++];\\n            combinacion[j] = nums[n++];\\n        }\\n        return combinacion;\\n    }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "klu_2100031265",
                        "content": "simple and easy java technique\\n\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int b[]=new int[n*2];\\n\\t\\tint f=0,s=1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tb[f]=nums[i];\\n\\t\\t\\tb[s]=nums[i+n];\\n\\t\\t\\tf+=2;\\n\\t\\t\\ts+=2;\\n\\t\\t}\\n        return b;\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "excellent !!\\n"
                    },
                    {
                        "username": "vijaychaudharivc",
                        "content": "Algorithm :\\n1) take two interator, one starts from begin and second from nth position\\n2)  put these interator values from nums array to new arr \\n3) increase these interator\\n4) reapeat step from 1 to 3 until   first_interator != second_interator\\n--------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int mid = n;\\n        int [] arr = new int[nums.length];\\n        // put two element inside arr array at a time so maintaining index we use array_index\\n        int array_index = 0;\\n\\n        for(int i=0;i != n;i++){\\n           arr[array_index] = nums[i];\\n           array_index++;\\n\\n           arr[array_index] = nums[mid];\\n           array_index++;\\n           \\n           mid++;\\n          \\n        }\\n\\n        return arr;\\n\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Shrayash_17",
                        "content": "if u r beginner \\nuse this approach \\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp[]=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                temp[k]=nums[i++];\\n            }\\n            else \\n            {\\n                temp[k]=nums[j++];\\n            }\\n        }\\n        return temp;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1745882,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/9d8000e0-2999-4894-846e-ab5a5daa93ab_1621490968.1599236.png)\\n"
                    },
                    {
                        "username": "Def8",
                        "content": "You may not post solutions here."
                    },
                    {
                        "username": "longdogialong123",
                        "content": "why do you have to use two for? "
                    },
                    {
                        "username": "mdcse",
                        "content": "You should not post solution here.\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is an easy problem if you use extra space. But in order to do without extra space you need to use the technique of encoding two numbers in one. For this technique to work, the numbers should be positive and should be under a certain limit.\n\n<details>\n<summary>Spoiler Alert</summary>\n\n ```cpp\n class Solution {\n public:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int max_val = INT_MIN;\n        for(int val: nums) \n            max_val = max(max_val, val);\n        max_val++;\n        for(int i=0; i<(2*n); i++) {\n            int val = (i&1) ? nums[n+(i/2)] : nums[i/2];\n            nums[i] += (val%max_val) * max_val;\n        }\n        for(int i=0; i<(2*n); i++)\n            nums[i] /= max_val;\n        return nums;\n     }\n };\n```\n</details>"
                    },
                    {
                        "username": "the_eagle02",
                        "content": "`Just Maths Puzzle... Interesting when you solved problem without using extra array... Remember you are going to do your first try to solve but after some time you see its also easy and fun to do without extra new array...\\nHappy LeetCoding!!```"
                    },
                    {
                        "username": "zaureqs",
                        "content": "too lazy to write code \\ncopied submission from my girlfriend\\'s account \\uD83D\\uDE05 \\nstill runtime is 93% \\uD83D\\uDE0C "
                    },
                    {
                        "username": "Knight-03",
                        "content": ": ) noice beta "
                    },
                    {
                        "username": "govindamandal",
                        "content": "In the case using C++ STL\\n\\nCreate a new vector arr of int which you will return and then apply the loop through i = 0 to n\\n\\n        for (int i = 0; i < n; i ++) {\\n            arr.push_back(nums.at(i));\\n            arr.push_back(nums.at(n + i));\\n        }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "kd_5304",
                        "content": "This problem is easy to solve in O(n) space. The real challenge is to solve it in O(1) space. Any ideas how?"
                    },
                    {
                        "username": "igorRC",
                        "content": "Solution in Java with runtime : 0 ms\\n    public int[] shuffle(int[] nums, int n) {\\n        int combinacion []= new int[nums.length]; \\n        for(int i = 0 , j = 1 , k = 0 ; n < nums.length; i=i+2 , j=j+2){\\n            combinacion[i] = nums[k++];\\n            combinacion[j] = nums[n++];\\n        }\\n        return combinacion;\\n    }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "klu_2100031265",
                        "content": "simple and easy java technique\\n\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int b[]=new int[n*2];\\n\\t\\tint f=0,s=1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tb[f]=nums[i];\\n\\t\\t\\tb[s]=nums[i+n];\\n\\t\\t\\tf+=2;\\n\\t\\t\\ts+=2;\\n\\t\\t}\\n        return b;\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "excellent !!\\n"
                    },
                    {
                        "username": "vijaychaudharivc",
                        "content": "Algorithm :\\n1) take two interator, one starts from begin and second from nth position\\n2)  put these interator values from nums array to new arr \\n3) increase these interator\\n4) reapeat step from 1 to 3 until   first_interator != second_interator\\n--------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int mid = n;\\n        int [] arr = new int[nums.length];\\n        // put two element inside arr array at a time so maintaining index we use array_index\\n        int array_index = 0;\\n\\n        for(int i=0;i != n;i++){\\n           arr[array_index] = nums[i];\\n           array_index++;\\n\\n           arr[array_index] = nums[mid];\\n           array_index++;\\n           \\n           mid++;\\n          \\n        }\\n\\n        return arr;\\n\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Shrayash_17",
                        "content": "if u r beginner \\nuse this approach \\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp[]=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                temp[k]=nums[i++];\\n            }\\n            else \\n            {\\n                temp[k]=nums[j++];\\n            }\\n        }\\n        return temp;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1734974,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/9d8000e0-2999-4894-846e-ab5a5daa93ab_1621490968.1599236.png)\\n"
                    },
                    {
                        "username": "Def8",
                        "content": "You may not post solutions here."
                    },
                    {
                        "username": "longdogialong123",
                        "content": "why do you have to use two for? "
                    },
                    {
                        "username": "mdcse",
                        "content": "You should not post solution here.\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is an easy problem if you use extra space. But in order to do without extra space you need to use the technique of encoding two numbers in one. For this technique to work, the numbers should be positive and should be under a certain limit.\n\n<details>\n<summary>Spoiler Alert</summary>\n\n ```cpp\n class Solution {\n public:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int max_val = INT_MIN;\n        for(int val: nums) \n            max_val = max(max_val, val);\n        max_val++;\n        for(int i=0; i<(2*n); i++) {\n            int val = (i&1) ? nums[n+(i/2)] : nums[i/2];\n            nums[i] += (val%max_val) * max_val;\n        }\n        for(int i=0; i<(2*n); i++)\n            nums[i] /= max_val;\n        return nums;\n     }\n };\n```\n</details>"
                    },
                    {
                        "username": "the_eagle02",
                        "content": "`Just Maths Puzzle... Interesting when you solved problem without using extra array... Remember you are going to do your first try to solve but after some time you see its also easy and fun to do without extra new array...\\nHappy LeetCoding!!```"
                    },
                    {
                        "username": "zaureqs",
                        "content": "too lazy to write code \\ncopied submission from my girlfriend\\'s account \\uD83D\\uDE05 \\nstill runtime is 93% \\uD83D\\uDE0C "
                    },
                    {
                        "username": "Knight-03",
                        "content": ": ) noice beta "
                    },
                    {
                        "username": "govindamandal",
                        "content": "In the case using C++ STL\\n\\nCreate a new vector arr of int which you will return and then apply the loop through i = 0 to n\\n\\n        for (int i = 0; i < n; i ++) {\\n            arr.push_back(nums.at(i));\\n            arr.push_back(nums.at(n + i));\\n        }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "kd_5304",
                        "content": "This problem is easy to solve in O(n) space. The real challenge is to solve it in O(1) space. Any ideas how?"
                    },
                    {
                        "username": "igorRC",
                        "content": "Solution in Java with runtime : 0 ms\\n    public int[] shuffle(int[] nums, int n) {\\n        int combinacion []= new int[nums.length]; \\n        for(int i = 0 , j = 1 , k = 0 ; n < nums.length; i=i+2 , j=j+2){\\n            combinacion[i] = nums[k++];\\n            combinacion[j] = nums[n++];\\n        }\\n        return combinacion;\\n    }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "klu_2100031265",
                        "content": "simple and easy java technique\\n\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int b[]=new int[n*2];\\n\\t\\tint f=0,s=1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tb[f]=nums[i];\\n\\t\\t\\tb[s]=nums[i+n];\\n\\t\\t\\tf+=2;\\n\\t\\t\\ts+=2;\\n\\t\\t}\\n        return b;\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "excellent !!\\n"
                    },
                    {
                        "username": "vijaychaudharivc",
                        "content": "Algorithm :\\n1) take two interator, one starts from begin and second from nth position\\n2)  put these interator values from nums array to new arr \\n3) increase these interator\\n4) reapeat step from 1 to 3 until   first_interator != second_interator\\n--------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int mid = n;\\n        int [] arr = new int[nums.length];\\n        // put two element inside arr array at a time so maintaining index we use array_index\\n        int array_index = 0;\\n\\n        for(int i=0;i != n;i++){\\n           arr[array_index] = nums[i];\\n           array_index++;\\n\\n           arr[array_index] = nums[mid];\\n           array_index++;\\n           \\n           mid++;\\n          \\n        }\\n\\n        return arr;\\n\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Shrayash_17",
                        "content": "if u r beginner \\nuse this approach \\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp[]=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                temp[k]=nums[i++];\\n            }\\n            else \\n            {\\n                temp[k]=nums[j++];\\n            }\\n        }\\n        return temp;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1728968,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/9d8000e0-2999-4894-846e-ab5a5daa93ab_1621490968.1599236.png)\\n"
                    },
                    {
                        "username": "Def8",
                        "content": "You may not post solutions here."
                    },
                    {
                        "username": "longdogialong123",
                        "content": "why do you have to use two for? "
                    },
                    {
                        "username": "mdcse",
                        "content": "You should not post solution here.\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is an easy problem if you use extra space. But in order to do without extra space you need to use the technique of encoding two numbers in one. For this technique to work, the numbers should be positive and should be under a certain limit.\n\n<details>\n<summary>Spoiler Alert</summary>\n\n ```cpp\n class Solution {\n public:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int max_val = INT_MIN;\n        for(int val: nums) \n            max_val = max(max_val, val);\n        max_val++;\n        for(int i=0; i<(2*n); i++) {\n            int val = (i&1) ? nums[n+(i/2)] : nums[i/2];\n            nums[i] += (val%max_val) * max_val;\n        }\n        for(int i=0; i<(2*n); i++)\n            nums[i] /= max_val;\n        return nums;\n     }\n };\n```\n</details>"
                    },
                    {
                        "username": "the_eagle02",
                        "content": "`Just Maths Puzzle... Interesting when you solved problem without using extra array... Remember you are going to do your first try to solve but after some time you see its also easy and fun to do without extra new array...\\nHappy LeetCoding!!```"
                    },
                    {
                        "username": "zaureqs",
                        "content": "too lazy to write code \\ncopied submission from my girlfriend\\'s account \\uD83D\\uDE05 \\nstill runtime is 93% \\uD83D\\uDE0C "
                    },
                    {
                        "username": "Knight-03",
                        "content": ": ) noice beta "
                    },
                    {
                        "username": "govindamandal",
                        "content": "In the case using C++ STL\\n\\nCreate a new vector arr of int which you will return and then apply the loop through i = 0 to n\\n\\n        for (int i = 0; i < n; i ++) {\\n            arr.push_back(nums.at(i));\\n            arr.push_back(nums.at(n + i));\\n        }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "kd_5304",
                        "content": "This problem is easy to solve in O(n) space. The real challenge is to solve it in O(1) space. Any ideas how?"
                    },
                    {
                        "username": "igorRC",
                        "content": "Solution in Java with runtime : 0 ms\\n    public int[] shuffle(int[] nums, int n) {\\n        int combinacion []= new int[nums.length]; \\n        for(int i = 0 , j = 1 , k = 0 ; n < nums.length; i=i+2 , j=j+2){\\n            combinacion[i] = nums[k++];\\n            combinacion[j] = nums[n++];\\n        }\\n        return combinacion;\\n    }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "klu_2100031265",
                        "content": "simple and easy java technique\\n\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int b[]=new int[n*2];\\n\\t\\tint f=0,s=1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tb[f]=nums[i];\\n\\t\\t\\tb[s]=nums[i+n];\\n\\t\\t\\tf+=2;\\n\\t\\t\\ts+=2;\\n\\t\\t}\\n        return b;\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "excellent !!\\n"
                    },
                    {
                        "username": "vijaychaudharivc",
                        "content": "Algorithm :\\n1) take two interator, one starts from begin and second from nth position\\n2)  put these interator values from nums array to new arr \\n3) increase these interator\\n4) reapeat step from 1 to 3 until   first_interator != second_interator\\n--------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int mid = n;\\n        int [] arr = new int[nums.length];\\n        // put two element inside arr array at a time so maintaining index we use array_index\\n        int array_index = 0;\\n\\n        for(int i=0;i != n;i++){\\n           arr[array_index] = nums[i];\\n           array_index++;\\n\\n           arr[array_index] = nums[mid];\\n           array_index++;\\n           \\n           mid++;\\n          \\n        }\\n\\n        return arr;\\n\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Shrayash_17",
                        "content": "if u r beginner \\nuse this approach \\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp[]=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                temp[k]=nums[i++];\\n            }\\n            else \\n            {\\n                temp[k]=nums[j++];\\n            }\\n        }\\n        return temp;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1694138,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/9d8000e0-2999-4894-846e-ab5a5daa93ab_1621490968.1599236.png)\\n"
                    },
                    {
                        "username": "Def8",
                        "content": "You may not post solutions here."
                    },
                    {
                        "username": "longdogialong123",
                        "content": "why do you have to use two for? "
                    },
                    {
                        "username": "mdcse",
                        "content": "You should not post solution here.\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is an easy problem if you use extra space. But in order to do without extra space you need to use the technique of encoding two numbers in one. For this technique to work, the numbers should be positive and should be under a certain limit.\n\n<details>\n<summary>Spoiler Alert</summary>\n\n ```cpp\n class Solution {\n public:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int max_val = INT_MIN;\n        for(int val: nums) \n            max_val = max(max_val, val);\n        max_val++;\n        for(int i=0; i<(2*n); i++) {\n            int val = (i&1) ? nums[n+(i/2)] : nums[i/2];\n            nums[i] += (val%max_val) * max_val;\n        }\n        for(int i=0; i<(2*n); i++)\n            nums[i] /= max_val;\n        return nums;\n     }\n };\n```\n</details>"
                    },
                    {
                        "username": "the_eagle02",
                        "content": "`Just Maths Puzzle... Interesting when you solved problem without using extra array... Remember you are going to do your first try to solve but after some time you see its also easy and fun to do without extra new array...\\nHappy LeetCoding!!```"
                    },
                    {
                        "username": "zaureqs",
                        "content": "too lazy to write code \\ncopied submission from my girlfriend\\'s account \\uD83D\\uDE05 \\nstill runtime is 93% \\uD83D\\uDE0C "
                    },
                    {
                        "username": "Knight-03",
                        "content": ": ) noice beta "
                    },
                    {
                        "username": "govindamandal",
                        "content": "In the case using C++ STL\\n\\nCreate a new vector arr of int which you will return and then apply the loop through i = 0 to n\\n\\n        for (int i = 0; i < n; i ++) {\\n            arr.push_back(nums.at(i));\\n            arr.push_back(nums.at(n + i));\\n        }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "kd_5304",
                        "content": "This problem is easy to solve in O(n) space. The real challenge is to solve it in O(1) space. Any ideas how?"
                    },
                    {
                        "username": "igorRC",
                        "content": "Solution in Java with runtime : 0 ms\\n    public int[] shuffle(int[] nums, int n) {\\n        int combinacion []= new int[nums.length]; \\n        for(int i = 0 , j = 1 , k = 0 ; n < nums.length; i=i+2 , j=j+2){\\n            combinacion[i] = nums[k++];\\n            combinacion[j] = nums[n++];\\n        }\\n        return combinacion;\\n    }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "klu_2100031265",
                        "content": "simple and easy java technique\\n\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int b[]=new int[n*2];\\n\\t\\tint f=0,s=1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tb[f]=nums[i];\\n\\t\\t\\tb[s]=nums[i+n];\\n\\t\\t\\tf+=2;\\n\\t\\t\\ts+=2;\\n\\t\\t}\\n        return b;\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "excellent !!\\n"
                    },
                    {
                        "username": "vijaychaudharivc",
                        "content": "Algorithm :\\n1) take two interator, one starts from begin and second from nth position\\n2)  put these interator values from nums array to new arr \\n3) increase these interator\\n4) reapeat step from 1 to 3 until   first_interator != second_interator\\n--------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int mid = n;\\n        int [] arr = new int[nums.length];\\n        // put two element inside arr array at a time so maintaining index we use array_index\\n        int array_index = 0;\\n\\n        for(int i=0;i != n;i++){\\n           arr[array_index] = nums[i];\\n           array_index++;\\n\\n           arr[array_index] = nums[mid];\\n           array_index++;\\n           \\n           mid++;\\n          \\n        }\\n\\n        return arr;\\n\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Shrayash_17",
                        "content": "if u r beginner \\nuse this approach \\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp[]=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                temp[k]=nums[i++];\\n            }\\n            else \\n            {\\n                temp[k]=nums[j++];\\n            }\\n        }\\n        return temp;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 2058344,
                "content": [
                    {
                        "username": "inmymind801",
                        "content": "![image](https://assets.leetcode.com/users/images/9d8000e0-2999-4894-846e-ab5a5daa93ab_1621490968.1599236.png)\\n"
                    },
                    {
                        "username": "Def8",
                        "content": "You may not post solutions here."
                    },
                    {
                        "username": "longdogialong123",
                        "content": "why do you have to use two for? "
                    },
                    {
                        "username": "mdcse",
                        "content": "You should not post solution here.\\n"
                    },
                    {
                        "username": "kumaraashish118",
                        "content": "This is an easy problem if you use extra space. But in order to do without extra space you need to use the technique of encoding two numbers in one. For this technique to work, the numbers should be positive and should be under a certain limit.\n\n<details>\n<summary>Spoiler Alert</summary>\n\n ```cpp\n class Solution {\n public:\n    vector<int> shuffle(vector<int>& nums, int n) {\n        int max_val = INT_MIN;\n        for(int val: nums) \n            max_val = max(max_val, val);\n        max_val++;\n        for(int i=0; i<(2*n); i++) {\n            int val = (i&1) ? nums[n+(i/2)] : nums[i/2];\n            nums[i] += (val%max_val) * max_val;\n        }\n        for(int i=0; i<(2*n); i++)\n            nums[i] /= max_val;\n        return nums;\n     }\n };\n```\n</details>"
                    },
                    {
                        "username": "the_eagle02",
                        "content": "`Just Maths Puzzle... Interesting when you solved problem without using extra array... Remember you are going to do your first try to solve but after some time you see its also easy and fun to do without extra new array...\\nHappy LeetCoding!!```"
                    },
                    {
                        "username": "zaureqs",
                        "content": "too lazy to write code \\ncopied submission from my girlfriend\\'s account \\uD83D\\uDE05 \\nstill runtime is 93% \\uD83D\\uDE0C "
                    },
                    {
                        "username": "Knight-03",
                        "content": ": ) noice beta "
                    },
                    {
                        "username": "govindamandal",
                        "content": "In the case using C++ STL\\n\\nCreate a new vector arr of int which you will return and then apply the loop through i = 0 to n\\n\\n        for (int i = 0; i < n; i ++) {\\n            arr.push_back(nums.at(i));\\n            arr.push_back(nums.at(n + i));\\n        }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "kd_5304",
                        "content": "This problem is easy to solve in O(n) space. The real challenge is to solve it in O(1) space. Any ideas how?"
                    },
                    {
                        "username": "igorRC",
                        "content": "Solution in Java with runtime : 0 ms\\n    public int[] shuffle(int[] nums, int n) {\\n        int combinacion []= new int[nums.length]; \\n        for(int i = 0 , j = 1 , k = 0 ; n < nums.length; i=i+2 , j=j+2){\\n            combinacion[i] = nums[k++];\\n            combinacion[j] = nums[n++];\\n        }\\n        return combinacion;\\n    }"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "klu_2100031265",
                        "content": "simple and easy java technique\\n\\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int b[]=new int[n*2];\\n\\t\\tint f=0,s=1;\\n\\t\\tfor(int i=0;i<n;i++)\\n\\t\\t{\\n\\t\\t\\tb[f]=nums[i];\\n\\t\\t\\tb[s]=nums[i+n];\\n\\t\\t\\tf+=2;\\n\\t\\t\\ts+=2;\\n\\t\\t}\\n        return b;\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Pradheesh_26",
                        "content": "excellent !!\\n"
                    },
                    {
                        "username": "vijaychaudharivc",
                        "content": "Algorithm :\\n1) take two interator, one starts from begin and second from nth position\\n2)  put these interator values from nums array to new arr \\n3) increase these interator\\n4) reapeat step from 1 to 3 until   first_interator != second_interator\\n--------------------------------------------------------------------------------------\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int mid = n;\\n        int [] arr = new int[nums.length];\\n        // put two element inside arr array at a time so maintaining index we use array_index\\n        int array_index = 0;\\n\\n        for(int i=0;i != n;i++){\\n           arr[array_index] = nums[i];\\n           array_index++;\\n\\n           arr[array_index] = nums[mid];\\n           array_index++;\\n           \\n           mid++;\\n          \\n        }\\n\\n        return arr;\\n\\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Shrayash_17",
                        "content": "if u r beginner \\nuse this approach \\n\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int temp[]=new int[2*n];\\n        int i=0;\\n        int j=n;\\n        for(int k=0;k<2*n;k++)\\n        {\\n            if(k%2==0)\\n            {\\n                temp[k]=nums[i++];\\n            }\\n            else \\n            {\\n                temp[k]=nums[j++];\\n            }\\n        }\\n        return temp;\\n        \\n    }\\n}"
                    }
                ]
            },
            {
                "id": 2018385,
                "content": [
                    {
                        "username": "Aditya4455",
                        "content": "//beats 100 %users\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> temp;\\n        int l=nums.size();\\n        for(int i=0;i<l/2;i++)\\n        {\\n            temp1.push_back(nums[i]);\\n            temp2.push_back(nums[n+i]);\\n        }\\n        int k=0,m=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(i==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else if(i%2==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else{\\n                temp.push_back(temp2[m]);\\n                m++;\\n            }\\n        }\\n        return temp;\\n    }\\n};"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.toMutableList().chunked(n).let {it-> it.first().zip(it.last()) }\\n            .flatMap { listOf(it.first, it.second) }.toIntArray()"
                    },
                    {
                        "username": "EvilGriffith",
                        "content": "WHY array.filter(Boolean) IS NOT FUNCTION????"
                    },
                    {
                        "username": "bharsa09",
                        "content": "(number1 * 1001 +number2)%1001===>number2\nand   \n(number1 * 1001 +number2)/1001===>number1\n\nMay this help you :-)\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Is there a in-place solution? I\\'ve been trying to work on one for the past hour with no luck."
                    },
                    {
                        "username": "kirtisalini",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int k[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n-1;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        int i=0;\\n        j=1;\\n        for(i=n;i<nums.length;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        return k;\\n    }\\n}\\n\\nPlease help me to detect the error"
                    },
                    {
                        "username": "prasukjain_12",
                        "content": "vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> nums2;\n        int i=0,j=n;\n        while(i<n){\n            nums2.push_back(nums.at(i));\n            nums2.push_back(nums.at(j));\n            i++;\n            j++;\n        }\n        return nums2;\n    }"
                    },
                    {
                        "username": "sri_sudharshan",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res=new int[nums.length];\\n        int i=0;int index=0;\\n        int j=n;\\n        while(i<n){\\n            res[index]=nums[i];\\n            res[index+1]=nums[j];\\n            index=index+2;\\n            i++;\\n            j++;\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        list_ = []\n        t1 = nums[0:n]\n        t2 = nums[n::]\n        for i in range(len(t1)):\n            list_.append(t1[i])\n           list_.append(t2[i])\n        return list_`\n"
                    },
                    {
                        "username": "Lawrence2398",
                        "content": " \\n \\n class Solution { \\n     \\n \\n    public int[] shuffle(int[] nums, int n) {\\n           int[] ans = new int[nums.length] ; \\n            var start = 0 ;  \\n             for (int i = 0; i < nums.length; i++) {  \\n                 if(i%2 == 0) { \\n                      ans[i] = nums[start] ; \\n                       start++ ; \\n                 } \\n                  else { \\n                       ans[i] = nums[n] ; \\n                       n++ ; \\n                  }\\n          \\n    } \\n     return ans ; \\n} \\n} "
                    }
                ]
            },
            {
                "id": 2010722,
                "content": [
                    {
                        "username": "Aditya4455",
                        "content": "//beats 100 %users\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> temp;\\n        int l=nums.size();\\n        for(int i=0;i<l/2;i++)\\n        {\\n            temp1.push_back(nums[i]);\\n            temp2.push_back(nums[n+i]);\\n        }\\n        int k=0,m=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(i==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else if(i%2==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else{\\n                temp.push_back(temp2[m]);\\n                m++;\\n            }\\n        }\\n        return temp;\\n    }\\n};"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.toMutableList().chunked(n).let {it-> it.first().zip(it.last()) }\\n            .flatMap { listOf(it.first, it.second) }.toIntArray()"
                    },
                    {
                        "username": "EvilGriffith",
                        "content": "WHY array.filter(Boolean) IS NOT FUNCTION????"
                    },
                    {
                        "username": "bharsa09",
                        "content": "(number1 * 1001 +number2)%1001===>number2\nand   \n(number1 * 1001 +number2)/1001===>number1\n\nMay this help you :-)\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Is there a in-place solution? I\\'ve been trying to work on one for the past hour with no luck."
                    },
                    {
                        "username": "kirtisalini",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int k[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n-1;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        int i=0;\\n        j=1;\\n        for(i=n;i<nums.length;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        return k;\\n    }\\n}\\n\\nPlease help me to detect the error"
                    },
                    {
                        "username": "prasukjain_12",
                        "content": "vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> nums2;\n        int i=0,j=n;\n        while(i<n){\n            nums2.push_back(nums.at(i));\n            nums2.push_back(nums.at(j));\n            i++;\n            j++;\n        }\n        return nums2;\n    }"
                    },
                    {
                        "username": "sri_sudharshan",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res=new int[nums.length];\\n        int i=0;int index=0;\\n        int j=n;\\n        while(i<n){\\n            res[index]=nums[i];\\n            res[index+1]=nums[j];\\n            index=index+2;\\n            i++;\\n            j++;\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        list_ = []\n        t1 = nums[0:n]\n        t2 = nums[n::]\n        for i in range(len(t1)):\n            list_.append(t1[i])\n           list_.append(t2[i])\n        return list_`\n"
                    },
                    {
                        "username": "Lawrence2398",
                        "content": " \\n \\n class Solution { \\n     \\n \\n    public int[] shuffle(int[] nums, int n) {\\n           int[] ans = new int[nums.length] ; \\n            var start = 0 ;  \\n             for (int i = 0; i < nums.length; i++) {  \\n                 if(i%2 == 0) { \\n                      ans[i] = nums[start] ; \\n                       start++ ; \\n                 } \\n                  else { \\n                       ans[i] = nums[n] ; \\n                       n++ ; \\n                  }\\n          \\n    } \\n     return ans ; \\n} \\n} "
                    }
                ]
            },
            {
                "id": 2003805,
                "content": [
                    {
                        "username": "Aditya4455",
                        "content": "//beats 100 %users\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> temp;\\n        int l=nums.size();\\n        for(int i=0;i<l/2;i++)\\n        {\\n            temp1.push_back(nums[i]);\\n            temp2.push_back(nums[n+i]);\\n        }\\n        int k=0,m=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(i==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else if(i%2==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else{\\n                temp.push_back(temp2[m]);\\n                m++;\\n            }\\n        }\\n        return temp;\\n    }\\n};"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.toMutableList().chunked(n).let {it-> it.first().zip(it.last()) }\\n            .flatMap { listOf(it.first, it.second) }.toIntArray()"
                    },
                    {
                        "username": "EvilGriffith",
                        "content": "WHY array.filter(Boolean) IS NOT FUNCTION????"
                    },
                    {
                        "username": "bharsa09",
                        "content": "(number1 * 1001 +number2)%1001===>number2\nand   \n(number1 * 1001 +number2)/1001===>number1\n\nMay this help you :-)\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Is there a in-place solution? I\\'ve been trying to work on one for the past hour with no luck."
                    },
                    {
                        "username": "kirtisalini",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int k[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n-1;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        int i=0;\\n        j=1;\\n        for(i=n;i<nums.length;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        return k;\\n    }\\n}\\n\\nPlease help me to detect the error"
                    },
                    {
                        "username": "prasukjain_12",
                        "content": "vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> nums2;\n        int i=0,j=n;\n        while(i<n){\n            nums2.push_back(nums.at(i));\n            nums2.push_back(nums.at(j));\n            i++;\n            j++;\n        }\n        return nums2;\n    }"
                    },
                    {
                        "username": "sri_sudharshan",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res=new int[nums.length];\\n        int i=0;int index=0;\\n        int j=n;\\n        while(i<n){\\n            res[index]=nums[i];\\n            res[index+1]=nums[j];\\n            index=index+2;\\n            i++;\\n            j++;\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        list_ = []\n        t1 = nums[0:n]\n        t2 = nums[n::]\n        for i in range(len(t1)):\n            list_.append(t1[i])\n           list_.append(t2[i])\n        return list_`\n"
                    },
                    {
                        "username": "Lawrence2398",
                        "content": " \\n \\n class Solution { \\n     \\n \\n    public int[] shuffle(int[] nums, int n) {\\n           int[] ans = new int[nums.length] ; \\n            var start = 0 ;  \\n             for (int i = 0; i < nums.length; i++) {  \\n                 if(i%2 == 0) { \\n                      ans[i] = nums[start] ; \\n                       start++ ; \\n                 } \\n                  else { \\n                       ans[i] = nums[n] ; \\n                       n++ ; \\n                  }\\n          \\n    } \\n     return ans ; \\n} \\n} "
                    }
                ]
            },
            {
                "id": 1976928,
                "content": [
                    {
                        "username": "Aditya4455",
                        "content": "//beats 100 %users\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> temp;\\n        int l=nums.size();\\n        for(int i=0;i<l/2;i++)\\n        {\\n            temp1.push_back(nums[i]);\\n            temp2.push_back(nums[n+i]);\\n        }\\n        int k=0,m=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(i==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else if(i%2==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else{\\n                temp.push_back(temp2[m]);\\n                m++;\\n            }\\n        }\\n        return temp;\\n    }\\n};"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.toMutableList().chunked(n).let {it-> it.first().zip(it.last()) }\\n            .flatMap { listOf(it.first, it.second) }.toIntArray()"
                    },
                    {
                        "username": "EvilGriffith",
                        "content": "WHY array.filter(Boolean) IS NOT FUNCTION????"
                    },
                    {
                        "username": "bharsa09",
                        "content": "(number1 * 1001 +number2)%1001===>number2\nand   \n(number1 * 1001 +number2)/1001===>number1\n\nMay this help you :-)\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Is there a in-place solution? I\\'ve been trying to work on one for the past hour with no luck."
                    },
                    {
                        "username": "kirtisalini",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int k[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n-1;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        int i=0;\\n        j=1;\\n        for(i=n;i<nums.length;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        return k;\\n    }\\n}\\n\\nPlease help me to detect the error"
                    },
                    {
                        "username": "prasukjain_12",
                        "content": "vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> nums2;\n        int i=0,j=n;\n        while(i<n){\n            nums2.push_back(nums.at(i));\n            nums2.push_back(nums.at(j));\n            i++;\n            j++;\n        }\n        return nums2;\n    }"
                    },
                    {
                        "username": "sri_sudharshan",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res=new int[nums.length];\\n        int i=0;int index=0;\\n        int j=n;\\n        while(i<n){\\n            res[index]=nums[i];\\n            res[index+1]=nums[j];\\n            index=index+2;\\n            i++;\\n            j++;\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        list_ = []\n        t1 = nums[0:n]\n        t2 = nums[n::]\n        for i in range(len(t1)):\n            list_.append(t1[i])\n           list_.append(t2[i])\n        return list_`\n"
                    },
                    {
                        "username": "Lawrence2398",
                        "content": " \\n \\n class Solution { \\n     \\n \\n    public int[] shuffle(int[] nums, int n) {\\n           int[] ans = new int[nums.length] ; \\n            var start = 0 ;  \\n             for (int i = 0; i < nums.length; i++) {  \\n                 if(i%2 == 0) { \\n                      ans[i] = nums[start] ; \\n                       start++ ; \\n                 } \\n                  else { \\n                       ans[i] = nums[n] ; \\n                       n++ ; \\n                  }\\n          \\n    } \\n     return ans ; \\n} \\n} "
                    }
                ]
            },
            {
                "id": 1957922,
                "content": [
                    {
                        "username": "Aditya4455",
                        "content": "//beats 100 %users\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> temp;\\n        int l=nums.size();\\n        for(int i=0;i<l/2;i++)\\n        {\\n            temp1.push_back(nums[i]);\\n            temp2.push_back(nums[n+i]);\\n        }\\n        int k=0,m=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(i==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else if(i%2==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else{\\n                temp.push_back(temp2[m]);\\n                m++;\\n            }\\n        }\\n        return temp;\\n    }\\n};"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.toMutableList().chunked(n).let {it-> it.first().zip(it.last()) }\\n            .flatMap { listOf(it.first, it.second) }.toIntArray()"
                    },
                    {
                        "username": "EvilGriffith",
                        "content": "WHY array.filter(Boolean) IS NOT FUNCTION????"
                    },
                    {
                        "username": "bharsa09",
                        "content": "(number1 * 1001 +number2)%1001===>number2\nand   \n(number1 * 1001 +number2)/1001===>number1\n\nMay this help you :-)\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Is there a in-place solution? I\\'ve been trying to work on one for the past hour with no luck."
                    },
                    {
                        "username": "kirtisalini",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int k[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n-1;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        int i=0;\\n        j=1;\\n        for(i=n;i<nums.length;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        return k;\\n    }\\n}\\n\\nPlease help me to detect the error"
                    },
                    {
                        "username": "prasukjain_12",
                        "content": "vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> nums2;\n        int i=0,j=n;\n        while(i<n){\n            nums2.push_back(nums.at(i));\n            nums2.push_back(nums.at(j));\n            i++;\n            j++;\n        }\n        return nums2;\n    }"
                    },
                    {
                        "username": "sri_sudharshan",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res=new int[nums.length];\\n        int i=0;int index=0;\\n        int j=n;\\n        while(i<n){\\n            res[index]=nums[i];\\n            res[index+1]=nums[j];\\n            index=index+2;\\n            i++;\\n            j++;\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        list_ = []\n        t1 = nums[0:n]\n        t2 = nums[n::]\n        for i in range(len(t1)):\n            list_.append(t1[i])\n           list_.append(t2[i])\n        return list_`\n"
                    },
                    {
                        "username": "Lawrence2398",
                        "content": " \\n \\n class Solution { \\n     \\n \\n    public int[] shuffle(int[] nums, int n) {\\n           int[] ans = new int[nums.length] ; \\n            var start = 0 ;  \\n             for (int i = 0; i < nums.length; i++) {  \\n                 if(i%2 == 0) { \\n                      ans[i] = nums[start] ; \\n                       start++ ; \\n                 } \\n                  else { \\n                       ans[i] = nums[n] ; \\n                       n++ ; \\n                  }\\n          \\n    } \\n     return ans ; \\n} \\n} "
                    }
                ]
            },
            {
                "id": 1922691,
                "content": [
                    {
                        "username": "Aditya4455",
                        "content": "//beats 100 %users\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> temp;\\n        int l=nums.size();\\n        for(int i=0;i<l/2;i++)\\n        {\\n            temp1.push_back(nums[i]);\\n            temp2.push_back(nums[n+i]);\\n        }\\n        int k=0,m=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(i==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else if(i%2==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else{\\n                temp.push_back(temp2[m]);\\n                m++;\\n            }\\n        }\\n        return temp;\\n    }\\n};"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.toMutableList().chunked(n).let {it-> it.first().zip(it.last()) }\\n            .flatMap { listOf(it.first, it.second) }.toIntArray()"
                    },
                    {
                        "username": "EvilGriffith",
                        "content": "WHY array.filter(Boolean) IS NOT FUNCTION????"
                    },
                    {
                        "username": "bharsa09",
                        "content": "(number1 * 1001 +number2)%1001===>number2\nand   \n(number1 * 1001 +number2)/1001===>number1\n\nMay this help you :-)\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Is there a in-place solution? I\\'ve been trying to work on one for the past hour with no luck."
                    },
                    {
                        "username": "kirtisalini",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int k[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n-1;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        int i=0;\\n        j=1;\\n        for(i=n;i<nums.length;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        return k;\\n    }\\n}\\n\\nPlease help me to detect the error"
                    },
                    {
                        "username": "prasukjain_12",
                        "content": "vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> nums2;\n        int i=0,j=n;\n        while(i<n){\n            nums2.push_back(nums.at(i));\n            nums2.push_back(nums.at(j));\n            i++;\n            j++;\n        }\n        return nums2;\n    }"
                    },
                    {
                        "username": "sri_sudharshan",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res=new int[nums.length];\\n        int i=0;int index=0;\\n        int j=n;\\n        while(i<n){\\n            res[index]=nums[i];\\n            res[index+1]=nums[j];\\n            index=index+2;\\n            i++;\\n            j++;\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        list_ = []\n        t1 = nums[0:n]\n        t2 = nums[n::]\n        for i in range(len(t1)):\n            list_.append(t1[i])\n           list_.append(t2[i])\n        return list_`\n"
                    },
                    {
                        "username": "Lawrence2398",
                        "content": " \\n \\n class Solution { \\n     \\n \\n    public int[] shuffle(int[] nums, int n) {\\n           int[] ans = new int[nums.length] ; \\n            var start = 0 ;  \\n             for (int i = 0; i < nums.length; i++) {  \\n                 if(i%2 == 0) { \\n                      ans[i] = nums[start] ; \\n                       start++ ; \\n                 } \\n                  else { \\n                       ans[i] = nums[n] ; \\n                       n++ ; \\n                  }\\n          \\n    } \\n     return ans ; \\n} \\n} "
                    }
                ]
            },
            {
                "id": 1847613,
                "content": [
                    {
                        "username": "Aditya4455",
                        "content": "//beats 100 %users\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> temp;\\n        int l=nums.size();\\n        for(int i=0;i<l/2;i++)\\n        {\\n            temp1.push_back(nums[i]);\\n            temp2.push_back(nums[n+i]);\\n        }\\n        int k=0,m=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(i==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else if(i%2==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else{\\n                temp.push_back(temp2[m]);\\n                m++;\\n            }\\n        }\\n        return temp;\\n    }\\n};"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.toMutableList().chunked(n).let {it-> it.first().zip(it.last()) }\\n            .flatMap { listOf(it.first, it.second) }.toIntArray()"
                    },
                    {
                        "username": "EvilGriffith",
                        "content": "WHY array.filter(Boolean) IS NOT FUNCTION????"
                    },
                    {
                        "username": "bharsa09",
                        "content": "(number1 * 1001 +number2)%1001===>number2\nand   \n(number1 * 1001 +number2)/1001===>number1\n\nMay this help you :-)\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Is there a in-place solution? I\\'ve been trying to work on one for the past hour with no luck."
                    },
                    {
                        "username": "kirtisalini",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int k[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n-1;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        int i=0;\\n        j=1;\\n        for(i=n;i<nums.length;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        return k;\\n    }\\n}\\n\\nPlease help me to detect the error"
                    },
                    {
                        "username": "prasukjain_12",
                        "content": "vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> nums2;\n        int i=0,j=n;\n        while(i<n){\n            nums2.push_back(nums.at(i));\n            nums2.push_back(nums.at(j));\n            i++;\n            j++;\n        }\n        return nums2;\n    }"
                    },
                    {
                        "username": "sri_sudharshan",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res=new int[nums.length];\\n        int i=0;int index=0;\\n        int j=n;\\n        while(i<n){\\n            res[index]=nums[i];\\n            res[index+1]=nums[j];\\n            index=index+2;\\n            i++;\\n            j++;\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        list_ = []\n        t1 = nums[0:n]\n        t2 = nums[n::]\n        for i in range(len(t1)):\n            list_.append(t1[i])\n           list_.append(t2[i])\n        return list_`\n"
                    },
                    {
                        "username": "Lawrence2398",
                        "content": " \\n \\n class Solution { \\n     \\n \\n    public int[] shuffle(int[] nums, int n) {\\n           int[] ans = new int[nums.length] ; \\n            var start = 0 ;  \\n             for (int i = 0; i < nums.length; i++) {  \\n                 if(i%2 == 0) { \\n                      ans[i] = nums[start] ; \\n                       start++ ; \\n                 } \\n                  else { \\n                       ans[i] = nums[n] ; \\n                       n++ ; \\n                  }\\n          \\n    } \\n     return ans ; \\n} \\n} "
                    }
                ]
            },
            {
                "id": 1843398,
                "content": [
                    {
                        "username": "Aditya4455",
                        "content": "//beats 100 %users\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> temp;\\n        int l=nums.size();\\n        for(int i=0;i<l/2;i++)\\n        {\\n            temp1.push_back(nums[i]);\\n            temp2.push_back(nums[n+i]);\\n        }\\n        int k=0,m=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(i==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else if(i%2==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else{\\n                temp.push_back(temp2[m]);\\n                m++;\\n            }\\n        }\\n        return temp;\\n    }\\n};"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.toMutableList().chunked(n).let {it-> it.first().zip(it.last()) }\\n            .flatMap { listOf(it.first, it.second) }.toIntArray()"
                    },
                    {
                        "username": "EvilGriffith",
                        "content": "WHY array.filter(Boolean) IS NOT FUNCTION????"
                    },
                    {
                        "username": "bharsa09",
                        "content": "(number1 * 1001 +number2)%1001===>number2\nand   \n(number1 * 1001 +number2)/1001===>number1\n\nMay this help you :-)\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Is there a in-place solution? I\\'ve been trying to work on one for the past hour with no luck."
                    },
                    {
                        "username": "kirtisalini",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int k[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n-1;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        int i=0;\\n        j=1;\\n        for(i=n;i<nums.length;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        return k;\\n    }\\n}\\n\\nPlease help me to detect the error"
                    },
                    {
                        "username": "prasukjain_12",
                        "content": "vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> nums2;\n        int i=0,j=n;\n        while(i<n){\n            nums2.push_back(nums.at(i));\n            nums2.push_back(nums.at(j));\n            i++;\n            j++;\n        }\n        return nums2;\n    }"
                    },
                    {
                        "username": "sri_sudharshan",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res=new int[nums.length];\\n        int i=0;int index=0;\\n        int j=n;\\n        while(i<n){\\n            res[index]=nums[i];\\n            res[index+1]=nums[j];\\n            index=index+2;\\n            i++;\\n            j++;\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        list_ = []\n        t1 = nums[0:n]\n        t2 = nums[n::]\n        for i in range(len(t1)):\n            list_.append(t1[i])\n           list_.append(t2[i])\n        return list_`\n"
                    },
                    {
                        "username": "Lawrence2398",
                        "content": " \\n \\n class Solution { \\n     \\n \\n    public int[] shuffle(int[] nums, int n) {\\n           int[] ans = new int[nums.length] ; \\n            var start = 0 ;  \\n             for (int i = 0; i < nums.length; i++) {  \\n                 if(i%2 == 0) { \\n                      ans[i] = nums[start] ; \\n                       start++ ; \\n                 } \\n                  else { \\n                       ans[i] = nums[n] ; \\n                       n++ ; \\n                  }\\n          \\n    } \\n     return ans ; \\n} \\n} "
                    }
                ]
            },
            {
                "id": 1842216,
                "content": [
                    {
                        "username": "Aditya4455",
                        "content": "//beats 100 %users\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> temp;\\n        int l=nums.size();\\n        for(int i=0;i<l/2;i++)\\n        {\\n            temp1.push_back(nums[i]);\\n            temp2.push_back(nums[n+i]);\\n        }\\n        int k=0,m=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(i==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else if(i%2==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else{\\n                temp.push_back(temp2[m]);\\n                m++;\\n            }\\n        }\\n        return temp;\\n    }\\n};"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.toMutableList().chunked(n).let {it-> it.first().zip(it.last()) }\\n            .flatMap { listOf(it.first, it.second) }.toIntArray()"
                    },
                    {
                        "username": "EvilGriffith",
                        "content": "WHY array.filter(Boolean) IS NOT FUNCTION????"
                    },
                    {
                        "username": "bharsa09",
                        "content": "(number1 * 1001 +number2)%1001===>number2\nand   \n(number1 * 1001 +number2)/1001===>number1\n\nMay this help you :-)\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Is there a in-place solution? I\\'ve been trying to work on one for the past hour with no luck."
                    },
                    {
                        "username": "kirtisalini",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int k[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n-1;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        int i=0;\\n        j=1;\\n        for(i=n;i<nums.length;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        return k;\\n    }\\n}\\n\\nPlease help me to detect the error"
                    },
                    {
                        "username": "prasukjain_12",
                        "content": "vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> nums2;\n        int i=0,j=n;\n        while(i<n){\n            nums2.push_back(nums.at(i));\n            nums2.push_back(nums.at(j));\n            i++;\n            j++;\n        }\n        return nums2;\n    }"
                    },
                    {
                        "username": "sri_sudharshan",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res=new int[nums.length];\\n        int i=0;int index=0;\\n        int j=n;\\n        while(i<n){\\n            res[index]=nums[i];\\n            res[index+1]=nums[j];\\n            index=index+2;\\n            i++;\\n            j++;\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        list_ = []\n        t1 = nums[0:n]\n        t2 = nums[n::]\n        for i in range(len(t1)):\n            list_.append(t1[i])\n           list_.append(t2[i])\n        return list_`\n"
                    },
                    {
                        "username": "Lawrence2398",
                        "content": " \\n \\n class Solution { \\n     \\n \\n    public int[] shuffle(int[] nums, int n) {\\n           int[] ans = new int[nums.length] ; \\n            var start = 0 ;  \\n             for (int i = 0; i < nums.length; i++) {  \\n                 if(i%2 == 0) { \\n                      ans[i] = nums[start] ; \\n                       start++ ; \\n                 } \\n                  else { \\n                       ans[i] = nums[n] ; \\n                       n++ ; \\n                  }\\n          \\n    } \\n     return ans ; \\n} \\n} "
                    }
                ]
            },
            {
                "id": 1805398,
                "content": [
                    {
                        "username": "Aditya4455",
                        "content": "//beats 100 %users\\n\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> temp1;\\n        vector<int> temp2;\\n        vector<int> temp;\\n        int l=nums.size();\\n        for(int i=0;i<l/2;i++)\\n        {\\n            temp1.push_back(nums[i]);\\n            temp2.push_back(nums[n+i]);\\n        }\\n        int k=0,m=0;\\n        for(int i=0;i<l;i++)\\n        {\\n            if(i==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else if(i%2==0)\\n            {\\n                temp.push_back(temp1[k]);\\n                k++;\\n            }\\n            else{\\n                temp.push_back(temp2[m]);\\n                m++;\\n            }\\n        }\\n        return temp;\\n    }\\n};"
                    },
                    {
                        "username": "Fedorov_Andrii",
                        "content": "return nums.toMutableList().chunked(n).let {it-> it.first().zip(it.last()) }\\n            .flatMap { listOf(it.first, it.second) }.toIntArray()"
                    },
                    {
                        "username": "EvilGriffith",
                        "content": "WHY array.filter(Boolean) IS NOT FUNCTION????"
                    },
                    {
                        "username": "bharsa09",
                        "content": "(number1 * 1001 +number2)%1001===>number2\nand   \n(number1 * 1001 +number2)/1001===>number1\n\nMay this help you :-)\n"
                    },
                    {
                        "username": "deleted_user",
                        "content": "Is there a in-place solution? I\\'ve been trying to work on one for the past hour with no luck."
                    },
                    {
                        "username": "kirtisalini",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int k[]=new int[nums.length];\\n        int j=0;\\n        for(int i=0;i<n-1;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        int i=0;\\n        j=1;\\n        for(i=n;i<nums.length;i++){\\n            k[j]=nums[i];\\n            j=j+2;\\n\\n        }\\n        return k;\\n    }\\n}\\n\\nPlease help me to detect the error"
                    },
                    {
                        "username": "prasukjain_12",
                        "content": "vector<int> shuffle(vector<int>& nums, int n) {\n        vector<int> nums2;\n        int i=0,j=n;\n        while(i<n){\n            nums2.push_back(nums.at(i));\n            nums2.push_back(nums.at(j));\n            i++;\n            j++;\n        }\n        return nums2;\n    }"
                    },
                    {
                        "username": "sri_sudharshan",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] res=new int[nums.length];\\n        int i=0;int index=0;\\n        int j=n;\\n        while(i<n){\\n            res[index]=nums[i];\\n            res[index+1]=nums[j];\\n            index=index+2;\\n            i++;\\n            j++;\\n\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "Razzzzzzzzz",
                        "content": "`class Solution:\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\n        list_ = []\n        t1 = nums[0:n]\n        t2 = nums[n::]\n        for i in range(len(t1)):\n            list_.append(t1[i])\n           list_.append(t2[i])\n        return list_`\n"
                    },
                    {
                        "username": "Lawrence2398",
                        "content": " \\n \\n class Solution { \\n     \\n \\n    public int[] shuffle(int[] nums, int n) {\\n           int[] ans = new int[nums.length] ; \\n            var start = 0 ;  \\n             for (int i = 0; i < nums.length; i++) {  \\n                 if(i%2 == 0) { \\n                      ans[i] = nums[start] ; \\n                       start++ ; \\n                 } \\n                  else { \\n                       ans[i] = nums[n] ; \\n                       n++ ; \\n                  }\\n          \\n    } \\n     return ans ; \\n} \\n} "
                    }
                ]
            },
            {
                "id": 1801801,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int x=0;\\n        int y=n;//3\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)//[2,3,5,4,1,7] \\n        {\\n            if(i%2==0)//\\n            {\\n                arr[i]=nums[x];//2\\n                x++;//1\\n\\n            }\\n            else\\n            {\\n               arr[i]=nums[y];//3\\n               y++;//4\\n            }\\n\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        if(n==1)\\n            return nums;\\n        \\n        int firstPointer=0,secondPointer=n;\\n        int[] arr= new int[nums.length];\\n        for(int i=0;i<2*n;i++)\\n        {   if(i%2==0){\\n            arr[i]=nums[firstPointer];\\n            firstPointer++;\\n            }\\n         else{\\n                arr[i]=nums[secondPointer];\\n                secondPointer++;\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "shonu72",
                        "content": "brute force approach - JAVA\\n `int[] ans = new int[2*n];\\n        int j=0;\\n        for(int i = 0; i < 2*n; i =i+2){\\n            ans[i] = nums[j];\\n            ans[i+1] = nums[j+n];\\n            j++;\\n        }\\n        return ans;`\\n\\noptimized approach - \\n\\n`\\nfor(int i=0; i<n;i++){\\nnums[i+n] += nums[i]*1005;\\n}\\nfor(int i=0; i<n;i++){\\nnums[2*i] = nums[i+n]/1005;\\nnums[2*i+1] = nums[i+n]%1005;\\n}\\nreturn nums;\\n`"
                    },
                    {
                        "username": "ketan_2707",
                        "content": "using Bitwise operator we will reduce the space complexity.\\n `     \\n\\n        for(int i=0; i<n; i++){\\n            nums[i+n] += nums[i]*10000;\\n        }\\n\\n       for(int i=0; i<n; i++){\\n            nums[2*i] = nums[i+n]/10000;\\n            nums[(2*i)+1] = nums[i+n]%10000;\\n        }\\n        return nums;\\n`"
                    },
                    {
                        "username": "f1channelfirst",
                        "content": "can anyone explain the question i m not getting what question is saying"
                    },
                    {
                        "username": "cortexauth",
                        "content": "The official solution is pure hack. I think this can be done in O(n lg n) without using that extra space. Think of it like this\\n\\nYou break sequence into four parts, and swap inner two parts, then do same for half left and half right portions. I think this will reach a valid solution"
                    },
                    {
                        "username": "elhack999",
                        "content": "I\\'m still a bit confused to be honest\\n"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int [] ans = new int[nums.length];\\n        int index = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[index++] = nums[i];\\n            ans[index++] = nums[n + i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[2*n];  here we taking the length double of (n) given in our question\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[nums.length];\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1801122,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int x=0;\\n        int y=n;//3\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)//[2,3,5,4,1,7] \\n        {\\n            if(i%2==0)//\\n            {\\n                arr[i]=nums[x];//2\\n                x++;//1\\n\\n            }\\n            else\\n            {\\n               arr[i]=nums[y];//3\\n               y++;//4\\n            }\\n\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        if(n==1)\\n            return nums;\\n        \\n        int firstPointer=0,secondPointer=n;\\n        int[] arr= new int[nums.length];\\n        for(int i=0;i<2*n;i++)\\n        {   if(i%2==0){\\n            arr[i]=nums[firstPointer];\\n            firstPointer++;\\n            }\\n         else{\\n                arr[i]=nums[secondPointer];\\n                secondPointer++;\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "shonu72",
                        "content": "brute force approach - JAVA\\n `int[] ans = new int[2*n];\\n        int j=0;\\n        for(int i = 0; i < 2*n; i =i+2){\\n            ans[i] = nums[j];\\n            ans[i+1] = nums[j+n];\\n            j++;\\n        }\\n        return ans;`\\n\\noptimized approach - \\n\\n`\\nfor(int i=0; i<n;i++){\\nnums[i+n] += nums[i]*1005;\\n}\\nfor(int i=0; i<n;i++){\\nnums[2*i] = nums[i+n]/1005;\\nnums[2*i+1] = nums[i+n]%1005;\\n}\\nreturn nums;\\n`"
                    },
                    {
                        "username": "ketan_2707",
                        "content": "using Bitwise operator we will reduce the space complexity.\\n `     \\n\\n        for(int i=0; i<n; i++){\\n            nums[i+n] += nums[i]*10000;\\n        }\\n\\n       for(int i=0; i<n; i++){\\n            nums[2*i] = nums[i+n]/10000;\\n            nums[(2*i)+1] = nums[i+n]%10000;\\n        }\\n        return nums;\\n`"
                    },
                    {
                        "username": "f1channelfirst",
                        "content": "can anyone explain the question i m not getting what question is saying"
                    },
                    {
                        "username": "cortexauth",
                        "content": "The official solution is pure hack. I think this can be done in O(n lg n) without using that extra space. Think of it like this\\n\\nYou break sequence into four parts, and swap inner two parts, then do same for half left and half right portions. I think this will reach a valid solution"
                    },
                    {
                        "username": "elhack999",
                        "content": "I\\'m still a bit confused to be honest\\n"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int [] ans = new int[nums.length];\\n        int index = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[index++] = nums[i];\\n            ans[index++] = nums[n + i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[2*n];  here we taking the length double of (n) given in our question\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[nums.length];\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1797869,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int x=0;\\n        int y=n;//3\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)//[2,3,5,4,1,7] \\n        {\\n            if(i%2==0)//\\n            {\\n                arr[i]=nums[x];//2\\n                x++;//1\\n\\n            }\\n            else\\n            {\\n               arr[i]=nums[y];//3\\n               y++;//4\\n            }\\n\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        if(n==1)\\n            return nums;\\n        \\n        int firstPointer=0,secondPointer=n;\\n        int[] arr= new int[nums.length];\\n        for(int i=0;i<2*n;i++)\\n        {   if(i%2==0){\\n            arr[i]=nums[firstPointer];\\n            firstPointer++;\\n            }\\n         else{\\n                arr[i]=nums[secondPointer];\\n                secondPointer++;\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "shonu72",
                        "content": "brute force approach - JAVA\\n `int[] ans = new int[2*n];\\n        int j=0;\\n        for(int i = 0; i < 2*n; i =i+2){\\n            ans[i] = nums[j];\\n            ans[i+1] = nums[j+n];\\n            j++;\\n        }\\n        return ans;`\\n\\noptimized approach - \\n\\n`\\nfor(int i=0; i<n;i++){\\nnums[i+n] += nums[i]*1005;\\n}\\nfor(int i=0; i<n;i++){\\nnums[2*i] = nums[i+n]/1005;\\nnums[2*i+1] = nums[i+n]%1005;\\n}\\nreturn nums;\\n`"
                    },
                    {
                        "username": "ketan_2707",
                        "content": "using Bitwise operator we will reduce the space complexity.\\n `     \\n\\n        for(int i=0; i<n; i++){\\n            nums[i+n] += nums[i]*10000;\\n        }\\n\\n       for(int i=0; i<n; i++){\\n            nums[2*i] = nums[i+n]/10000;\\n            nums[(2*i)+1] = nums[i+n]%10000;\\n        }\\n        return nums;\\n`"
                    },
                    {
                        "username": "f1channelfirst",
                        "content": "can anyone explain the question i m not getting what question is saying"
                    },
                    {
                        "username": "cortexauth",
                        "content": "The official solution is pure hack. I think this can be done in O(n lg n) without using that extra space. Think of it like this\\n\\nYou break sequence into four parts, and swap inner two parts, then do same for half left and half right portions. I think this will reach a valid solution"
                    },
                    {
                        "username": "elhack999",
                        "content": "I\\'m still a bit confused to be honest\\n"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int [] ans = new int[nums.length];\\n        int index = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[index++] = nums[i];\\n            ans[index++] = nums[n + i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[2*n];  here we taking the length double of (n) given in our question\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[nums.length];\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1797597,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int x=0;\\n        int y=n;//3\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)//[2,3,5,4,1,7] \\n        {\\n            if(i%2==0)//\\n            {\\n                arr[i]=nums[x];//2\\n                x++;//1\\n\\n            }\\n            else\\n            {\\n               arr[i]=nums[y];//3\\n               y++;//4\\n            }\\n\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        if(n==1)\\n            return nums;\\n        \\n        int firstPointer=0,secondPointer=n;\\n        int[] arr= new int[nums.length];\\n        for(int i=0;i<2*n;i++)\\n        {   if(i%2==0){\\n            arr[i]=nums[firstPointer];\\n            firstPointer++;\\n            }\\n         else{\\n                arr[i]=nums[secondPointer];\\n                secondPointer++;\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "shonu72",
                        "content": "brute force approach - JAVA\\n `int[] ans = new int[2*n];\\n        int j=0;\\n        for(int i = 0; i < 2*n; i =i+2){\\n            ans[i] = nums[j];\\n            ans[i+1] = nums[j+n];\\n            j++;\\n        }\\n        return ans;`\\n\\noptimized approach - \\n\\n`\\nfor(int i=0; i<n;i++){\\nnums[i+n] += nums[i]*1005;\\n}\\nfor(int i=0; i<n;i++){\\nnums[2*i] = nums[i+n]/1005;\\nnums[2*i+1] = nums[i+n]%1005;\\n}\\nreturn nums;\\n`"
                    },
                    {
                        "username": "ketan_2707",
                        "content": "using Bitwise operator we will reduce the space complexity.\\n `     \\n\\n        for(int i=0; i<n; i++){\\n            nums[i+n] += nums[i]*10000;\\n        }\\n\\n       for(int i=0; i<n; i++){\\n            nums[2*i] = nums[i+n]/10000;\\n            nums[(2*i)+1] = nums[i+n]%10000;\\n        }\\n        return nums;\\n`"
                    },
                    {
                        "username": "f1channelfirst",
                        "content": "can anyone explain the question i m not getting what question is saying"
                    },
                    {
                        "username": "cortexauth",
                        "content": "The official solution is pure hack. I think this can be done in O(n lg n) without using that extra space. Think of it like this\\n\\nYou break sequence into four parts, and swap inner two parts, then do same for half left and half right portions. I think this will reach a valid solution"
                    },
                    {
                        "username": "elhack999",
                        "content": "I\\'m still a bit confused to be honest\\n"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int [] ans = new int[nums.length];\\n        int index = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[index++] = nums[i];\\n            ans[index++] = nums[n + i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[2*n];  here we taking the length double of (n) given in our question\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[nums.length];\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1796936,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int x=0;\\n        int y=n;//3\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)//[2,3,5,4,1,7] \\n        {\\n            if(i%2==0)//\\n            {\\n                arr[i]=nums[x];//2\\n                x++;//1\\n\\n            }\\n            else\\n            {\\n               arr[i]=nums[y];//3\\n               y++;//4\\n            }\\n\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        if(n==1)\\n            return nums;\\n        \\n        int firstPointer=0,secondPointer=n;\\n        int[] arr= new int[nums.length];\\n        for(int i=0;i<2*n;i++)\\n        {   if(i%2==0){\\n            arr[i]=nums[firstPointer];\\n            firstPointer++;\\n            }\\n         else{\\n                arr[i]=nums[secondPointer];\\n                secondPointer++;\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "shonu72",
                        "content": "brute force approach - JAVA\\n `int[] ans = new int[2*n];\\n        int j=0;\\n        for(int i = 0; i < 2*n; i =i+2){\\n            ans[i] = nums[j];\\n            ans[i+1] = nums[j+n];\\n            j++;\\n        }\\n        return ans;`\\n\\noptimized approach - \\n\\n`\\nfor(int i=0; i<n;i++){\\nnums[i+n] += nums[i]*1005;\\n}\\nfor(int i=0; i<n;i++){\\nnums[2*i] = nums[i+n]/1005;\\nnums[2*i+1] = nums[i+n]%1005;\\n}\\nreturn nums;\\n`"
                    },
                    {
                        "username": "ketan_2707",
                        "content": "using Bitwise operator we will reduce the space complexity.\\n `     \\n\\n        for(int i=0; i<n; i++){\\n            nums[i+n] += nums[i]*10000;\\n        }\\n\\n       for(int i=0; i<n; i++){\\n            nums[2*i] = nums[i+n]/10000;\\n            nums[(2*i)+1] = nums[i+n]%10000;\\n        }\\n        return nums;\\n`"
                    },
                    {
                        "username": "f1channelfirst",
                        "content": "can anyone explain the question i m not getting what question is saying"
                    },
                    {
                        "username": "cortexauth",
                        "content": "The official solution is pure hack. I think this can be done in O(n lg n) without using that extra space. Think of it like this\\n\\nYou break sequence into four parts, and swap inner two parts, then do same for half left and half right portions. I think this will reach a valid solution"
                    },
                    {
                        "username": "elhack999",
                        "content": "I\\'m still a bit confused to be honest\\n"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int [] ans = new int[nums.length];\\n        int index = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[index++] = nums[i];\\n            ans[index++] = nums[n + i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[2*n];  here we taking the length double of (n) given in our question\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[nums.length];\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1791116,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int x=0;\\n        int y=n;//3\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)//[2,3,5,4,1,7] \\n        {\\n            if(i%2==0)//\\n            {\\n                arr[i]=nums[x];//2\\n                x++;//1\\n\\n            }\\n            else\\n            {\\n               arr[i]=nums[y];//3\\n               y++;//4\\n            }\\n\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        if(n==1)\\n            return nums;\\n        \\n        int firstPointer=0,secondPointer=n;\\n        int[] arr= new int[nums.length];\\n        for(int i=0;i<2*n;i++)\\n        {   if(i%2==0){\\n            arr[i]=nums[firstPointer];\\n            firstPointer++;\\n            }\\n         else{\\n                arr[i]=nums[secondPointer];\\n                secondPointer++;\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "shonu72",
                        "content": "brute force approach - JAVA\\n `int[] ans = new int[2*n];\\n        int j=0;\\n        for(int i = 0; i < 2*n; i =i+2){\\n            ans[i] = nums[j];\\n            ans[i+1] = nums[j+n];\\n            j++;\\n        }\\n        return ans;`\\n\\noptimized approach - \\n\\n`\\nfor(int i=0; i<n;i++){\\nnums[i+n] += nums[i]*1005;\\n}\\nfor(int i=0; i<n;i++){\\nnums[2*i] = nums[i+n]/1005;\\nnums[2*i+1] = nums[i+n]%1005;\\n}\\nreturn nums;\\n`"
                    },
                    {
                        "username": "ketan_2707",
                        "content": "using Bitwise operator we will reduce the space complexity.\\n `     \\n\\n        for(int i=0; i<n; i++){\\n            nums[i+n] += nums[i]*10000;\\n        }\\n\\n       for(int i=0; i<n; i++){\\n            nums[2*i] = nums[i+n]/10000;\\n            nums[(2*i)+1] = nums[i+n]%10000;\\n        }\\n        return nums;\\n`"
                    },
                    {
                        "username": "f1channelfirst",
                        "content": "can anyone explain the question i m not getting what question is saying"
                    },
                    {
                        "username": "cortexauth",
                        "content": "The official solution is pure hack. I think this can be done in O(n lg n) without using that extra space. Think of it like this\\n\\nYou break sequence into four parts, and swap inner two parts, then do same for half left and half right portions. I think this will reach a valid solution"
                    },
                    {
                        "username": "elhack999",
                        "content": "I\\'m still a bit confused to be honest\\n"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int [] ans = new int[nums.length];\\n        int index = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[index++] = nums[i];\\n            ans[index++] = nums[n + i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[2*n];  here we taking the length double of (n) given in our question\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[nums.length];\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1790977,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int x=0;\\n        int y=n;//3\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)//[2,3,5,4,1,7] \\n        {\\n            if(i%2==0)//\\n            {\\n                arr[i]=nums[x];//2\\n                x++;//1\\n\\n            }\\n            else\\n            {\\n               arr[i]=nums[y];//3\\n               y++;//4\\n            }\\n\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        if(n==1)\\n            return nums;\\n        \\n        int firstPointer=0,secondPointer=n;\\n        int[] arr= new int[nums.length];\\n        for(int i=0;i<2*n;i++)\\n        {   if(i%2==0){\\n            arr[i]=nums[firstPointer];\\n            firstPointer++;\\n            }\\n         else{\\n                arr[i]=nums[secondPointer];\\n                secondPointer++;\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "shonu72",
                        "content": "brute force approach - JAVA\\n `int[] ans = new int[2*n];\\n        int j=0;\\n        for(int i = 0; i < 2*n; i =i+2){\\n            ans[i] = nums[j];\\n            ans[i+1] = nums[j+n];\\n            j++;\\n        }\\n        return ans;`\\n\\noptimized approach - \\n\\n`\\nfor(int i=0; i<n;i++){\\nnums[i+n] += nums[i]*1005;\\n}\\nfor(int i=0; i<n;i++){\\nnums[2*i] = nums[i+n]/1005;\\nnums[2*i+1] = nums[i+n]%1005;\\n}\\nreturn nums;\\n`"
                    },
                    {
                        "username": "ketan_2707",
                        "content": "using Bitwise operator we will reduce the space complexity.\\n `     \\n\\n        for(int i=0; i<n; i++){\\n            nums[i+n] += nums[i]*10000;\\n        }\\n\\n       for(int i=0; i<n; i++){\\n            nums[2*i] = nums[i+n]/10000;\\n            nums[(2*i)+1] = nums[i+n]%10000;\\n        }\\n        return nums;\\n`"
                    },
                    {
                        "username": "f1channelfirst",
                        "content": "can anyone explain the question i m not getting what question is saying"
                    },
                    {
                        "username": "cortexauth",
                        "content": "The official solution is pure hack. I think this can be done in O(n lg n) without using that extra space. Think of it like this\\n\\nYou break sequence into four parts, and swap inner two parts, then do same for half left and half right portions. I think this will reach a valid solution"
                    },
                    {
                        "username": "elhack999",
                        "content": "I\\'m still a bit confused to be honest\\n"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int [] ans = new int[nums.length];\\n        int index = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[index++] = nums[i];\\n            ans[index++] = nums[n + i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[2*n];  here we taking the length double of (n) given in our question\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[nums.length];\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1790956,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int x=0;\\n        int y=n;//3\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)//[2,3,5,4,1,7] \\n        {\\n            if(i%2==0)//\\n            {\\n                arr[i]=nums[x];//2\\n                x++;//1\\n\\n            }\\n            else\\n            {\\n               arr[i]=nums[y];//3\\n               y++;//4\\n            }\\n\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        if(n==1)\\n            return nums;\\n        \\n        int firstPointer=0,secondPointer=n;\\n        int[] arr= new int[nums.length];\\n        for(int i=0;i<2*n;i++)\\n        {   if(i%2==0){\\n            arr[i]=nums[firstPointer];\\n            firstPointer++;\\n            }\\n         else{\\n                arr[i]=nums[secondPointer];\\n                secondPointer++;\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "shonu72",
                        "content": "brute force approach - JAVA\\n `int[] ans = new int[2*n];\\n        int j=0;\\n        for(int i = 0; i < 2*n; i =i+2){\\n            ans[i] = nums[j];\\n            ans[i+1] = nums[j+n];\\n            j++;\\n        }\\n        return ans;`\\n\\noptimized approach - \\n\\n`\\nfor(int i=0; i<n;i++){\\nnums[i+n] += nums[i]*1005;\\n}\\nfor(int i=0; i<n;i++){\\nnums[2*i] = nums[i+n]/1005;\\nnums[2*i+1] = nums[i+n]%1005;\\n}\\nreturn nums;\\n`"
                    },
                    {
                        "username": "ketan_2707",
                        "content": "using Bitwise operator we will reduce the space complexity.\\n `     \\n\\n        for(int i=0; i<n; i++){\\n            nums[i+n] += nums[i]*10000;\\n        }\\n\\n       for(int i=0; i<n; i++){\\n            nums[2*i] = nums[i+n]/10000;\\n            nums[(2*i)+1] = nums[i+n]%10000;\\n        }\\n        return nums;\\n`"
                    },
                    {
                        "username": "f1channelfirst",
                        "content": "can anyone explain the question i m not getting what question is saying"
                    },
                    {
                        "username": "cortexauth",
                        "content": "The official solution is pure hack. I think this can be done in O(n lg n) without using that extra space. Think of it like this\\n\\nYou break sequence into four parts, and swap inner two parts, then do same for half left and half right portions. I think this will reach a valid solution"
                    },
                    {
                        "username": "elhack999",
                        "content": "I\\'m still a bit confused to be honest\\n"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int [] ans = new int[nums.length];\\n        int index = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[index++] = nums[i];\\n            ans[index++] = nums[n + i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[2*n];  here we taking the length double of (n) given in our question\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[nums.length];\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1790954,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int x=0;\\n        int y=n;//3\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)//[2,3,5,4,1,7] \\n        {\\n            if(i%2==0)//\\n            {\\n                arr[i]=nums[x];//2\\n                x++;//1\\n\\n            }\\n            else\\n            {\\n               arr[i]=nums[y];//3\\n               y++;//4\\n            }\\n\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        if(n==1)\\n            return nums;\\n        \\n        int firstPointer=0,secondPointer=n;\\n        int[] arr= new int[nums.length];\\n        for(int i=0;i<2*n;i++)\\n        {   if(i%2==0){\\n            arr[i]=nums[firstPointer];\\n            firstPointer++;\\n            }\\n         else{\\n                arr[i]=nums[secondPointer];\\n                secondPointer++;\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "shonu72",
                        "content": "brute force approach - JAVA\\n `int[] ans = new int[2*n];\\n        int j=0;\\n        for(int i = 0; i < 2*n; i =i+2){\\n            ans[i] = nums[j];\\n            ans[i+1] = nums[j+n];\\n            j++;\\n        }\\n        return ans;`\\n\\noptimized approach - \\n\\n`\\nfor(int i=0; i<n;i++){\\nnums[i+n] += nums[i]*1005;\\n}\\nfor(int i=0; i<n;i++){\\nnums[2*i] = nums[i+n]/1005;\\nnums[2*i+1] = nums[i+n]%1005;\\n}\\nreturn nums;\\n`"
                    },
                    {
                        "username": "ketan_2707",
                        "content": "using Bitwise operator we will reduce the space complexity.\\n `     \\n\\n        for(int i=0; i<n; i++){\\n            nums[i+n] += nums[i]*10000;\\n        }\\n\\n       for(int i=0; i<n; i++){\\n            nums[2*i] = nums[i+n]/10000;\\n            nums[(2*i)+1] = nums[i+n]%10000;\\n        }\\n        return nums;\\n`"
                    },
                    {
                        "username": "f1channelfirst",
                        "content": "can anyone explain the question i m not getting what question is saying"
                    },
                    {
                        "username": "cortexauth",
                        "content": "The official solution is pure hack. I think this can be done in O(n lg n) without using that extra space. Think of it like this\\n\\nYou break sequence into four parts, and swap inner two parts, then do same for half left and half right portions. I think this will reach a valid solution"
                    },
                    {
                        "username": "elhack999",
                        "content": "I\\'m still a bit confused to be honest\\n"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int [] ans = new int[nums.length];\\n        int index = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[index++] = nums[i];\\n            ans[index++] = nums[n + i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[2*n];  here we taking the length double of (n) given in our question\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[nums.length];\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1790951,
                "content": [
                    {
                        "username": "imranansari9835",
                        "content": "Java:\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int x=0;\\n        int y=n;//3\\n        int arr[]=new int[nums.length];\\n        for(int i=0;i<nums.length;i++)//[2,3,5,4,1,7] \\n        {\\n            if(i%2==0)//\\n            {\\n                arr[i]=nums[x];//2\\n                x++;//1\\n\\n            }\\n            else\\n            {\\n               arr[i]=nums[y];//3\\n               y++;//4\\n            }\\n\\n        }\\n        return arr;\\n    }\\n}"
                    },
                    {
                        "username": "imranansari9835",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        if(n==1)\\n            return nums;\\n        \\n        int firstPointer=0,secondPointer=n;\\n        int[] arr= new int[nums.length];\\n        for(int i=0;i<2*n;i++)\\n        {   if(i%2==0){\\n            arr[i]=nums[firstPointer];\\n            firstPointer++;\\n            }\\n         else{\\n                arr[i]=nums[secondPointer];\\n                secondPointer++;\\n            }\\n        }\\n        return arr;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "shonu72",
                        "content": "brute force approach - JAVA\\n `int[] ans = new int[2*n];\\n        int j=0;\\n        for(int i = 0; i < 2*n; i =i+2){\\n            ans[i] = nums[j];\\n            ans[i+1] = nums[j+n];\\n            j++;\\n        }\\n        return ans;`\\n\\noptimized approach - \\n\\n`\\nfor(int i=0; i<n;i++){\\nnums[i+n] += nums[i]*1005;\\n}\\nfor(int i=0; i<n;i++){\\nnums[2*i] = nums[i+n]/1005;\\nnums[2*i+1] = nums[i+n]%1005;\\n}\\nreturn nums;\\n`"
                    },
                    {
                        "username": "ketan_2707",
                        "content": "using Bitwise operator we will reduce the space complexity.\\n `     \\n\\n        for(int i=0; i<n; i++){\\n            nums[i+n] += nums[i]*10000;\\n        }\\n\\n       for(int i=0; i<n; i++){\\n            nums[2*i] = nums[i+n]/10000;\\n            nums[(2*i)+1] = nums[i+n]%10000;\\n        }\\n        return nums;\\n`"
                    },
                    {
                        "username": "f1channelfirst",
                        "content": "can anyone explain the question i m not getting what question is saying"
                    },
                    {
                        "username": "cortexauth",
                        "content": "The official solution is pure hack. I think this can be done in O(n lg n) without using that extra space. Think of it like this\\n\\nYou break sequence into four parts, and swap inner two parts, then do same for half left and half right portions. I think this will reach a valid solution"
                    },
                    {
                        "username": "elhack999",
                        "content": "I\\'m still a bit confused to be honest\\n"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int [] ans = new int[nums.length];\\n        int index = 0;\\n\\n        for(int i = 0; i < n; i++) {\\n            ans[index++] = nums[i];\\n            ans[index++] = nums[n + i];\\n        }\\n        return ans;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[2*n];  here we taking the length double of (n) given in our question\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    },
                    {
                        "username": "Kumarsinha",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArray = new int[nums.length];\\n        int x = 0;\\n        int y = n;\\n        int z = 0;\\n\\n        while(x < n) {\\n            newArray[z++] = nums[x++];\\n            newArray[z++] = nums[y++];\\n        } \\n        return newArray;\\n    }\\n}"
                    }
                ]
            },
            {
                "id": 1790931,
                "content": [
                    {
                        "username": "dawar_tanishq",
                        "content": "thee questionn is veryy easyy   code == [https://leetcode.com/problems/shuffle-the-array/solutions/3152519/easiest-approch-detail-explination-c-best-solution/](https://leetcode.com)\\ngiven----array =[x1,x2,x3,y1,y2,y3]\\n              output----[x1,y1,x2,y2,x3,y3]\\n\\nthe best approch is \\ncreate a for loop as array is of size 2*n  we have to make a loop till half of the array n\\n\\nalso create a vector<int>ans;\\n\\nthen --- push_back the value of  array as \\n   ans.push_back(x); //index of x element is i\\n\\nans.push_back(y); // index of y element is i+n\\n "
                    },
                    {
                        "username": "i13e",
                        "content": "In python, would solving this question with `zip(range(n), range(n, 2n)` and `yield` be considered O(1) space in an interview?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "i cannot understand the question clearly,, could anyone help me?"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "in this problem we have an array contains 2*n numbers [x1, x2,.............,y1, y2,......] so we need to reorder it in this form [x1, y1, x2, y2, ................]    so we will create a new array and add element at position=0 then add element at position=n then we will add element at position= 1 and element at position= n+1 and so on\n\n\n\nif n = 4 and we have an array [1, 2, 3, 4]\n\nso steps to add elements to ans array is:\n[1]\n[1, 3]\n[1, 3, 2]\n[1, 3, 2, 4]\n\nso answer will be like that [1, 3, 2, 4]\n\n\nfor more explanation show that https://leetcode.com/problems/shuffle-the-array/solutions/3151761/simple-c-solution/"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "it should be classified also as a two pointers problem"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "They should atleast tag this as a bit manipulation problem."
                    },
                    {
                        "username": "Shreeraj_Kadam1999",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int[] nums1 = new int[n];\\nint[] nums2 = new int[n*2];\\n       int x = 0;\\n        for (int i = n; i <(n*2); i++){\\n            nums1[x] = nums[i];\\n            x= x +1;\\n        }\\n        int x1 = 0;\\n        for (int j =0 ; j < n ; j++){\\n            nums2[x1] = nums[j] ;\\n            x1 = x1 +1;\\n            nums2[x1]= nums1[j];\\n            x1 = x1 +1;\\n\\n        }\\n        return nums2;\\n    }\\n}"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lakshmi_Kattula",
                        "content": "class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        len_of_each_list = len(nums)//2\\n        list1 = nums[:len_of_each_list]\\n        list2 = nums[len_of_each_list:]\\n\\n        res_list = []\\n \\n        for each in range(len_of_each_list):\\n            res_list.append(list1[each])\\n            res_list.append(list2[each])\\n        \\n        return res_list"
                    },
                    {
                        "username": "ritu7999",
                        "content": "easiest one"
                    },
                    {
                        "username": "Def8",
                        "content": "What is the lowest time complexity you have achieved for this problem? Mine is O(2n)."
                    }
                ]
            },
            {
                "id": 1790874,
                "content": [
                    {
                        "username": "dawar_tanishq",
                        "content": "thee questionn is veryy easyy   code == [https://leetcode.com/problems/shuffle-the-array/solutions/3152519/easiest-approch-detail-explination-c-best-solution/](https://leetcode.com)\\ngiven----array =[x1,x2,x3,y1,y2,y3]\\n              output----[x1,y1,x2,y2,x3,y3]\\n\\nthe best approch is \\ncreate a for loop as array is of size 2*n  we have to make a loop till half of the array n\\n\\nalso create a vector<int>ans;\\n\\nthen --- push_back the value of  array as \\n   ans.push_back(x); //index of x element is i\\n\\nans.push_back(y); // index of y element is i+n\\n "
                    },
                    {
                        "username": "i13e",
                        "content": "In python, would solving this question with `zip(range(n), range(n, 2n)` and `yield` be considered O(1) space in an interview?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "i cannot understand the question clearly,, could anyone help me?"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "in this problem we have an array contains 2*n numbers [x1, x2,.............,y1, y2,......] so we need to reorder it in this form [x1, y1, x2, y2, ................]    so we will create a new array and add element at position=0 then add element at position=n then we will add element at position= 1 and element at position= n+1 and so on\n\n\n\nif n = 4 and we have an array [1, 2, 3, 4]\n\nso steps to add elements to ans array is:\n[1]\n[1, 3]\n[1, 3, 2]\n[1, 3, 2, 4]\n\nso answer will be like that [1, 3, 2, 4]\n\n\nfor more explanation show that https://leetcode.com/problems/shuffle-the-array/solutions/3151761/simple-c-solution/"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "it should be classified also as a two pointers problem"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "They should atleast tag this as a bit manipulation problem."
                    },
                    {
                        "username": "Shreeraj_Kadam1999",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int[] nums1 = new int[n];\\nint[] nums2 = new int[n*2];\\n       int x = 0;\\n        for (int i = n; i <(n*2); i++){\\n            nums1[x] = nums[i];\\n            x= x +1;\\n        }\\n        int x1 = 0;\\n        for (int j =0 ; j < n ; j++){\\n            nums2[x1] = nums[j] ;\\n            x1 = x1 +1;\\n            nums2[x1]= nums1[j];\\n            x1 = x1 +1;\\n\\n        }\\n        return nums2;\\n    }\\n}"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lakshmi_Kattula",
                        "content": "class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        len_of_each_list = len(nums)//2\\n        list1 = nums[:len_of_each_list]\\n        list2 = nums[len_of_each_list:]\\n\\n        res_list = []\\n \\n        for each in range(len_of_each_list):\\n            res_list.append(list1[each])\\n            res_list.append(list2[each])\\n        \\n        return res_list"
                    },
                    {
                        "username": "ritu7999",
                        "content": "easiest one"
                    },
                    {
                        "username": "Def8",
                        "content": "What is the lowest time complexity you have achieved for this problem? Mine is O(2n)."
                    }
                ]
            },
            {
                "id": 1790771,
                "content": [
                    {
                        "username": "dawar_tanishq",
                        "content": "thee questionn is veryy easyy   code == [https://leetcode.com/problems/shuffle-the-array/solutions/3152519/easiest-approch-detail-explination-c-best-solution/](https://leetcode.com)\\ngiven----array =[x1,x2,x3,y1,y2,y3]\\n              output----[x1,y1,x2,y2,x3,y3]\\n\\nthe best approch is \\ncreate a for loop as array is of size 2*n  we have to make a loop till half of the array n\\n\\nalso create a vector<int>ans;\\n\\nthen --- push_back the value of  array as \\n   ans.push_back(x); //index of x element is i\\n\\nans.push_back(y); // index of y element is i+n\\n "
                    },
                    {
                        "username": "i13e",
                        "content": "In python, would solving this question with `zip(range(n), range(n, 2n)` and `yield` be considered O(1) space in an interview?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "i cannot understand the question clearly,, could anyone help me?"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "in this problem we have an array contains 2*n numbers [x1, x2,.............,y1, y2,......] so we need to reorder it in this form [x1, y1, x2, y2, ................]    so we will create a new array and add element at position=0 then add element at position=n then we will add element at position= 1 and element at position= n+1 and so on\n\n\n\nif n = 4 and we have an array [1, 2, 3, 4]\n\nso steps to add elements to ans array is:\n[1]\n[1, 3]\n[1, 3, 2]\n[1, 3, 2, 4]\n\nso answer will be like that [1, 3, 2, 4]\n\n\nfor more explanation show that https://leetcode.com/problems/shuffle-the-array/solutions/3151761/simple-c-solution/"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "it should be classified also as a two pointers problem"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "They should atleast tag this as a bit manipulation problem."
                    },
                    {
                        "username": "Shreeraj_Kadam1999",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int[] nums1 = new int[n];\\nint[] nums2 = new int[n*2];\\n       int x = 0;\\n        for (int i = n; i <(n*2); i++){\\n            nums1[x] = nums[i];\\n            x= x +1;\\n        }\\n        int x1 = 0;\\n        for (int j =0 ; j < n ; j++){\\n            nums2[x1] = nums[j] ;\\n            x1 = x1 +1;\\n            nums2[x1]= nums1[j];\\n            x1 = x1 +1;\\n\\n        }\\n        return nums2;\\n    }\\n}"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lakshmi_Kattula",
                        "content": "class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        len_of_each_list = len(nums)//2\\n        list1 = nums[:len_of_each_list]\\n        list2 = nums[len_of_each_list:]\\n\\n        res_list = []\\n \\n        for each in range(len_of_each_list):\\n            res_list.append(list1[each])\\n            res_list.append(list2[each])\\n        \\n        return res_list"
                    },
                    {
                        "username": "ritu7999",
                        "content": "easiest one"
                    },
                    {
                        "username": "Def8",
                        "content": "What is the lowest time complexity you have achieved for this problem? Mine is O(2n)."
                    }
                ]
            },
            {
                "id": 1790722,
                "content": [
                    {
                        "username": "dawar_tanishq",
                        "content": "thee questionn is veryy easyy   code == [https://leetcode.com/problems/shuffle-the-array/solutions/3152519/easiest-approch-detail-explination-c-best-solution/](https://leetcode.com)\\ngiven----array =[x1,x2,x3,y1,y2,y3]\\n              output----[x1,y1,x2,y2,x3,y3]\\n\\nthe best approch is \\ncreate a for loop as array is of size 2*n  we have to make a loop till half of the array n\\n\\nalso create a vector<int>ans;\\n\\nthen --- push_back the value of  array as \\n   ans.push_back(x); //index of x element is i\\n\\nans.push_back(y); // index of y element is i+n\\n "
                    },
                    {
                        "username": "i13e",
                        "content": "In python, would solving this question with `zip(range(n), range(n, 2n)` and `yield` be considered O(1) space in an interview?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "i cannot understand the question clearly,, could anyone help me?"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "in this problem we have an array contains 2*n numbers [x1, x2,.............,y1, y2,......] so we need to reorder it in this form [x1, y1, x2, y2, ................]    so we will create a new array and add element at position=0 then add element at position=n then we will add element at position= 1 and element at position= n+1 and so on\n\n\n\nif n = 4 and we have an array [1, 2, 3, 4]\n\nso steps to add elements to ans array is:\n[1]\n[1, 3]\n[1, 3, 2]\n[1, 3, 2, 4]\n\nso answer will be like that [1, 3, 2, 4]\n\n\nfor more explanation show that https://leetcode.com/problems/shuffle-the-array/solutions/3151761/simple-c-solution/"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "it should be classified also as a two pointers problem"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "They should atleast tag this as a bit manipulation problem."
                    },
                    {
                        "username": "Shreeraj_Kadam1999",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int[] nums1 = new int[n];\\nint[] nums2 = new int[n*2];\\n       int x = 0;\\n        for (int i = n; i <(n*2); i++){\\n            nums1[x] = nums[i];\\n            x= x +1;\\n        }\\n        int x1 = 0;\\n        for (int j =0 ; j < n ; j++){\\n            nums2[x1] = nums[j] ;\\n            x1 = x1 +1;\\n            nums2[x1]= nums1[j];\\n            x1 = x1 +1;\\n\\n        }\\n        return nums2;\\n    }\\n}"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lakshmi_Kattula",
                        "content": "class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        len_of_each_list = len(nums)//2\\n        list1 = nums[:len_of_each_list]\\n        list2 = nums[len_of_each_list:]\\n\\n        res_list = []\\n \\n        for each in range(len_of_each_list):\\n            res_list.append(list1[each])\\n            res_list.append(list2[each])\\n        \\n        return res_list"
                    },
                    {
                        "username": "ritu7999",
                        "content": "easiest one"
                    },
                    {
                        "username": "Def8",
                        "content": "What is the lowest time complexity you have achieved for this problem? Mine is O(2n)."
                    }
                ]
            },
            {
                "id": 1790714,
                "content": [
                    {
                        "username": "dawar_tanishq",
                        "content": "thee questionn is veryy easyy   code == [https://leetcode.com/problems/shuffle-the-array/solutions/3152519/easiest-approch-detail-explination-c-best-solution/](https://leetcode.com)\\ngiven----array =[x1,x2,x3,y1,y2,y3]\\n              output----[x1,y1,x2,y2,x3,y3]\\n\\nthe best approch is \\ncreate a for loop as array is of size 2*n  we have to make a loop till half of the array n\\n\\nalso create a vector<int>ans;\\n\\nthen --- push_back the value of  array as \\n   ans.push_back(x); //index of x element is i\\n\\nans.push_back(y); // index of y element is i+n\\n "
                    },
                    {
                        "username": "i13e",
                        "content": "In python, would solving this question with `zip(range(n), range(n, 2n)` and `yield` be considered O(1) space in an interview?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "i cannot understand the question clearly,, could anyone help me?"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "in this problem we have an array contains 2*n numbers [x1, x2,.............,y1, y2,......] so we need to reorder it in this form [x1, y1, x2, y2, ................]    so we will create a new array and add element at position=0 then add element at position=n then we will add element at position= 1 and element at position= n+1 and so on\n\n\n\nif n = 4 and we have an array [1, 2, 3, 4]\n\nso steps to add elements to ans array is:\n[1]\n[1, 3]\n[1, 3, 2]\n[1, 3, 2, 4]\n\nso answer will be like that [1, 3, 2, 4]\n\n\nfor more explanation show that https://leetcode.com/problems/shuffle-the-array/solutions/3151761/simple-c-solution/"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "it should be classified also as a two pointers problem"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "They should atleast tag this as a bit manipulation problem."
                    },
                    {
                        "username": "Shreeraj_Kadam1999",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int[] nums1 = new int[n];\\nint[] nums2 = new int[n*2];\\n       int x = 0;\\n        for (int i = n; i <(n*2); i++){\\n            nums1[x] = nums[i];\\n            x= x +1;\\n        }\\n        int x1 = 0;\\n        for (int j =0 ; j < n ; j++){\\n            nums2[x1] = nums[j] ;\\n            x1 = x1 +1;\\n            nums2[x1]= nums1[j];\\n            x1 = x1 +1;\\n\\n        }\\n        return nums2;\\n    }\\n}"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lakshmi_Kattula",
                        "content": "class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        len_of_each_list = len(nums)//2\\n        list1 = nums[:len_of_each_list]\\n        list2 = nums[len_of_each_list:]\\n\\n        res_list = []\\n \\n        for each in range(len_of_each_list):\\n            res_list.append(list1[each])\\n            res_list.append(list2[each])\\n        \\n        return res_list"
                    },
                    {
                        "username": "ritu7999",
                        "content": "easiest one"
                    },
                    {
                        "username": "Def8",
                        "content": "What is the lowest time complexity you have achieved for this problem? Mine is O(2n)."
                    }
                ]
            },
            {
                "id": 1790634,
                "content": [
                    {
                        "username": "dawar_tanishq",
                        "content": "thee questionn is veryy easyy   code == [https://leetcode.com/problems/shuffle-the-array/solutions/3152519/easiest-approch-detail-explination-c-best-solution/](https://leetcode.com)\\ngiven----array =[x1,x2,x3,y1,y2,y3]\\n              output----[x1,y1,x2,y2,x3,y3]\\n\\nthe best approch is \\ncreate a for loop as array is of size 2*n  we have to make a loop till half of the array n\\n\\nalso create a vector<int>ans;\\n\\nthen --- push_back the value of  array as \\n   ans.push_back(x); //index of x element is i\\n\\nans.push_back(y); // index of y element is i+n\\n "
                    },
                    {
                        "username": "i13e",
                        "content": "In python, would solving this question with `zip(range(n), range(n, 2n)` and `yield` be considered O(1) space in an interview?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "i cannot understand the question clearly,, could anyone help me?"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "in this problem we have an array contains 2*n numbers [x1, x2,.............,y1, y2,......] so we need to reorder it in this form [x1, y1, x2, y2, ................]    so we will create a new array and add element at position=0 then add element at position=n then we will add element at position= 1 and element at position= n+1 and so on\n\n\n\nif n = 4 and we have an array [1, 2, 3, 4]\n\nso steps to add elements to ans array is:\n[1]\n[1, 3]\n[1, 3, 2]\n[1, 3, 2, 4]\n\nso answer will be like that [1, 3, 2, 4]\n\n\nfor more explanation show that https://leetcode.com/problems/shuffle-the-array/solutions/3151761/simple-c-solution/"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "it should be classified also as a two pointers problem"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "They should atleast tag this as a bit manipulation problem."
                    },
                    {
                        "username": "Shreeraj_Kadam1999",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int[] nums1 = new int[n];\\nint[] nums2 = new int[n*2];\\n       int x = 0;\\n        for (int i = n; i <(n*2); i++){\\n            nums1[x] = nums[i];\\n            x= x +1;\\n        }\\n        int x1 = 0;\\n        for (int j =0 ; j < n ; j++){\\n            nums2[x1] = nums[j] ;\\n            x1 = x1 +1;\\n            nums2[x1]= nums1[j];\\n            x1 = x1 +1;\\n\\n        }\\n        return nums2;\\n    }\\n}"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lakshmi_Kattula",
                        "content": "class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        len_of_each_list = len(nums)//2\\n        list1 = nums[:len_of_each_list]\\n        list2 = nums[len_of_each_list:]\\n\\n        res_list = []\\n \\n        for each in range(len_of_each_list):\\n            res_list.append(list1[each])\\n            res_list.append(list2[each])\\n        \\n        return res_list"
                    },
                    {
                        "username": "ritu7999",
                        "content": "easiest one"
                    },
                    {
                        "username": "Def8",
                        "content": "What is the lowest time complexity you have achieved for this problem? Mine is O(2n)."
                    }
                ]
            },
            {
                "id": 1790631,
                "content": [
                    {
                        "username": "dawar_tanishq",
                        "content": "thee questionn is veryy easyy   code == [https://leetcode.com/problems/shuffle-the-array/solutions/3152519/easiest-approch-detail-explination-c-best-solution/](https://leetcode.com)\\ngiven----array =[x1,x2,x3,y1,y2,y3]\\n              output----[x1,y1,x2,y2,x3,y3]\\n\\nthe best approch is \\ncreate a for loop as array is of size 2*n  we have to make a loop till half of the array n\\n\\nalso create a vector<int>ans;\\n\\nthen --- push_back the value of  array as \\n   ans.push_back(x); //index of x element is i\\n\\nans.push_back(y); // index of y element is i+n\\n "
                    },
                    {
                        "username": "i13e",
                        "content": "In python, would solving this question with `zip(range(n), range(n, 2n)` and `yield` be considered O(1) space in an interview?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "i cannot understand the question clearly,, could anyone help me?"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "in this problem we have an array contains 2*n numbers [x1, x2,.............,y1, y2,......] so we need to reorder it in this form [x1, y1, x2, y2, ................]    so we will create a new array and add element at position=0 then add element at position=n then we will add element at position= 1 and element at position= n+1 and so on\n\n\n\nif n = 4 and we have an array [1, 2, 3, 4]\n\nso steps to add elements to ans array is:\n[1]\n[1, 3]\n[1, 3, 2]\n[1, 3, 2, 4]\n\nso answer will be like that [1, 3, 2, 4]\n\n\nfor more explanation show that https://leetcode.com/problems/shuffle-the-array/solutions/3151761/simple-c-solution/"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "it should be classified also as a two pointers problem"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "They should atleast tag this as a bit manipulation problem."
                    },
                    {
                        "username": "Shreeraj_Kadam1999",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int[] nums1 = new int[n];\\nint[] nums2 = new int[n*2];\\n       int x = 0;\\n        for (int i = n; i <(n*2); i++){\\n            nums1[x] = nums[i];\\n            x= x +1;\\n        }\\n        int x1 = 0;\\n        for (int j =0 ; j < n ; j++){\\n            nums2[x1] = nums[j] ;\\n            x1 = x1 +1;\\n            nums2[x1]= nums1[j];\\n            x1 = x1 +1;\\n\\n        }\\n        return nums2;\\n    }\\n}"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lakshmi_Kattula",
                        "content": "class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        len_of_each_list = len(nums)//2\\n        list1 = nums[:len_of_each_list]\\n        list2 = nums[len_of_each_list:]\\n\\n        res_list = []\\n \\n        for each in range(len_of_each_list):\\n            res_list.append(list1[each])\\n            res_list.append(list2[each])\\n        \\n        return res_list"
                    },
                    {
                        "username": "ritu7999",
                        "content": "easiest one"
                    },
                    {
                        "username": "Def8",
                        "content": "What is the lowest time complexity you have achieved for this problem? Mine is O(2n)."
                    }
                ]
            },
            {
                "id": 1790587,
                "content": [
                    {
                        "username": "dawar_tanishq",
                        "content": "thee questionn is veryy easyy   code == [https://leetcode.com/problems/shuffle-the-array/solutions/3152519/easiest-approch-detail-explination-c-best-solution/](https://leetcode.com)\\ngiven----array =[x1,x2,x3,y1,y2,y3]\\n              output----[x1,y1,x2,y2,x3,y3]\\n\\nthe best approch is \\ncreate a for loop as array is of size 2*n  we have to make a loop till half of the array n\\n\\nalso create a vector<int>ans;\\n\\nthen --- push_back the value of  array as \\n   ans.push_back(x); //index of x element is i\\n\\nans.push_back(y); // index of y element is i+n\\n "
                    },
                    {
                        "username": "i13e",
                        "content": "In python, would solving this question with `zip(range(n), range(n, 2n)` and `yield` be considered O(1) space in an interview?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "i cannot understand the question clearly,, could anyone help me?"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "in this problem we have an array contains 2*n numbers [x1, x2,.............,y1, y2,......] so we need to reorder it in this form [x1, y1, x2, y2, ................]    so we will create a new array and add element at position=0 then add element at position=n then we will add element at position= 1 and element at position= n+1 and so on\n\n\n\nif n = 4 and we have an array [1, 2, 3, 4]\n\nso steps to add elements to ans array is:\n[1]\n[1, 3]\n[1, 3, 2]\n[1, 3, 2, 4]\n\nso answer will be like that [1, 3, 2, 4]\n\n\nfor more explanation show that https://leetcode.com/problems/shuffle-the-array/solutions/3151761/simple-c-solution/"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "it should be classified also as a two pointers problem"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "They should atleast tag this as a bit manipulation problem."
                    },
                    {
                        "username": "Shreeraj_Kadam1999",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int[] nums1 = new int[n];\\nint[] nums2 = new int[n*2];\\n       int x = 0;\\n        for (int i = n; i <(n*2); i++){\\n            nums1[x] = nums[i];\\n            x= x +1;\\n        }\\n        int x1 = 0;\\n        for (int j =0 ; j < n ; j++){\\n            nums2[x1] = nums[j] ;\\n            x1 = x1 +1;\\n            nums2[x1]= nums1[j];\\n            x1 = x1 +1;\\n\\n        }\\n        return nums2;\\n    }\\n}"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lakshmi_Kattula",
                        "content": "class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        len_of_each_list = len(nums)//2\\n        list1 = nums[:len_of_each_list]\\n        list2 = nums[len_of_each_list:]\\n\\n        res_list = []\\n \\n        for each in range(len_of_each_list):\\n            res_list.append(list1[each])\\n            res_list.append(list2[each])\\n        \\n        return res_list"
                    },
                    {
                        "username": "ritu7999",
                        "content": "easiest one"
                    },
                    {
                        "username": "Def8",
                        "content": "What is the lowest time complexity you have achieved for this problem? Mine is O(2n)."
                    }
                ]
            },
            {
                "id": 1790540,
                "content": [
                    {
                        "username": "dawar_tanishq",
                        "content": "thee questionn is veryy easyy   code == [https://leetcode.com/problems/shuffle-the-array/solutions/3152519/easiest-approch-detail-explination-c-best-solution/](https://leetcode.com)\\ngiven----array =[x1,x2,x3,y1,y2,y3]\\n              output----[x1,y1,x2,y2,x3,y3]\\n\\nthe best approch is \\ncreate a for loop as array is of size 2*n  we have to make a loop till half of the array n\\n\\nalso create a vector<int>ans;\\n\\nthen --- push_back the value of  array as \\n   ans.push_back(x); //index of x element is i\\n\\nans.push_back(y); // index of y element is i+n\\n "
                    },
                    {
                        "username": "i13e",
                        "content": "In python, would solving this question with `zip(range(n), range(n, 2n)` and `yield` be considered O(1) space in an interview?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "i cannot understand the question clearly,, could anyone help me?"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "in this problem we have an array contains 2*n numbers [x1, x2,.............,y1, y2,......] so we need to reorder it in this form [x1, y1, x2, y2, ................]    so we will create a new array and add element at position=0 then add element at position=n then we will add element at position= 1 and element at position= n+1 and so on\n\n\n\nif n = 4 and we have an array [1, 2, 3, 4]\n\nso steps to add elements to ans array is:\n[1]\n[1, 3]\n[1, 3, 2]\n[1, 3, 2, 4]\n\nso answer will be like that [1, 3, 2, 4]\n\n\nfor more explanation show that https://leetcode.com/problems/shuffle-the-array/solutions/3151761/simple-c-solution/"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "it should be classified also as a two pointers problem"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "They should atleast tag this as a bit manipulation problem."
                    },
                    {
                        "username": "Shreeraj_Kadam1999",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int[] nums1 = new int[n];\\nint[] nums2 = new int[n*2];\\n       int x = 0;\\n        for (int i = n; i <(n*2); i++){\\n            nums1[x] = nums[i];\\n            x= x +1;\\n        }\\n        int x1 = 0;\\n        for (int j =0 ; j < n ; j++){\\n            nums2[x1] = nums[j] ;\\n            x1 = x1 +1;\\n            nums2[x1]= nums1[j];\\n            x1 = x1 +1;\\n\\n        }\\n        return nums2;\\n    }\\n}"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lakshmi_Kattula",
                        "content": "class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        len_of_each_list = len(nums)//2\\n        list1 = nums[:len_of_each_list]\\n        list2 = nums[len_of_each_list:]\\n\\n        res_list = []\\n \\n        for each in range(len_of_each_list):\\n            res_list.append(list1[each])\\n            res_list.append(list2[each])\\n        \\n        return res_list"
                    },
                    {
                        "username": "ritu7999",
                        "content": "easiest one"
                    },
                    {
                        "username": "Def8",
                        "content": "What is the lowest time complexity you have achieved for this problem? Mine is O(2n)."
                    }
                ]
            },
            {
                "id": 1790522,
                "content": [
                    {
                        "username": "dawar_tanishq",
                        "content": "thee questionn is veryy easyy   code == [https://leetcode.com/problems/shuffle-the-array/solutions/3152519/easiest-approch-detail-explination-c-best-solution/](https://leetcode.com)\\ngiven----array =[x1,x2,x3,y1,y2,y3]\\n              output----[x1,y1,x2,y2,x3,y3]\\n\\nthe best approch is \\ncreate a for loop as array is of size 2*n  we have to make a loop till half of the array n\\n\\nalso create a vector<int>ans;\\n\\nthen --- push_back the value of  array as \\n   ans.push_back(x); //index of x element is i\\n\\nans.push_back(y); // index of y element is i+n\\n "
                    },
                    {
                        "username": "i13e",
                        "content": "In python, would solving this question with `zip(range(n), range(n, 2n)` and `yield` be considered O(1) space in an interview?"
                    },
                    {
                        "username": "Vasanthviviz",
                        "content": "i cannot understand the question clearly,, could anyone help me?"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "in this problem we have an array contains 2*n numbers [x1, x2,.............,y1, y2,......] so we need to reorder it in this form [x1, y1, x2, y2, ................]    so we will create a new array and add element at position=0 then add element at position=n then we will add element at position= 1 and element at position= n+1 and so on\n\n\n\nif n = 4 and we have an array [1, 2, 3, 4]\n\nso steps to add elements to ans array is:\n[1]\n[1, 3]\n[1, 3, 2]\n[1, 3, 2, 4]\n\nso answer will be like that [1, 3, 2, 4]\n\n\nfor more explanation show that https://leetcode.com/problems/shuffle-the-array/solutions/3151761/simple-c-solution/"
                    },
                    {
                        "username": "m7moudGadallah",
                        "content": "it should be classified also as a two pointers problem"
                    },
                    {
                        "username": "vinayagarwal360",
                        "content": "They should atleast tag this as a bit manipulation problem."
                    },
                    {
                        "username": "Shreeraj_Kadam1999",
                        "content": "class Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n       int[] nums1 = new int[n];\\nint[] nums2 = new int[n*2];\\n       int x = 0;\\n        for (int i = n; i <(n*2); i++){\\n            nums1[x] = nums[i];\\n            x= x +1;\\n        }\\n        int x1 = 0;\\n        for (int j =0 ; j < n ; j++){\\n            nums2[x1] = nums[j] ;\\n            x1 = x1 +1;\\n            nums2[x1]= nums1[j];\\n            x1 = x1 +1;\\n\\n        }\\n        return nums2;\\n    }\\n}"
                    },
                    {
                        "username": "Deepak_8811",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "Lakshmi_Kattula",
                        "content": "class Solution:\\n    def shuffle(self, nums: List[int], n: int) -> List[int]:\\n        len_of_each_list = len(nums)//2\\n        list1 = nums[:len_of_each_list]\\n        list2 = nums[len_of_each_list:]\\n\\n        res_list = []\\n \\n        for each in range(len_of_each_list):\\n            res_list.append(list1[each])\\n            res_list.append(list2[each])\\n        \\n        return res_list"
                    },
                    {
                        "username": "ritu7999",
                        "content": "easiest one"
                    },
                    {
                        "username": "Def8",
                        "content": "What is the lowest time complexity you have achieved for this problem? Mine is O(2n)."
                    }
                ]
            },
            {
                "id": 1790479,
                "content": [
                    {
                        "username": "gbbest15",
                        "content": "hello, i am getting the output right but is saying wrong answer\\n\\n`var shuffle = function(nums, n) {\\n    var avg = nums.length/ 2;\\n    var v = avg;\\n    var ans = [];\\n        for(let i=0; i < avg; i++){\\n                ans.push(nums[i]);\\n                for(let j=v; j<nums.length; j++){ \\n                    ans.push(nums[v]);\\n                    v++;\\n                    break;\\n                }\\n        }\\n         console.log(ans);\\n      \\n}`;"
                    },
                    {
                        "username": "gbbest15",
                        "content": "oh i am to return the array..Done"
                    },
                    {
                        "username": "rahul_raj13",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n            \\n        }\\n        return ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "The hint given says the right pointer should start from n+1,should be n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "This operation is usually called interleaving"
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "Basic question on array but still my solution only beats 92 %  in cpp.\\n `your inline code...\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n         vector<int> result(2 * n);\\n        for (int i = 0, j = 0; i < n; i++) {\\n            result[j++] = nums[i];\\n            result[j++] = nums[i + n];\\n        }\\n        return result;\\n    }\\n};\\nyour inline code...`"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is a piece of cake its take less time  to me actually in this i take the array size as the double the given n and also taking the even and the odd indices and also the even indices in which separating the indices .... "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easiest question\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "O(1) space is possible but it would take O(n^2) time complexity as it would require shifting n elements for replacing n elements. Its easy either way."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "O(n) time is possible with the constraint of this problem."
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Easy Days !"
                    },
                    {
                        "username": "Bary010",
                        "content": "I am new here. I have a question, how to know if my solution has decent runtime, memory uses?"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "when you submit code it will tell rms which is time require for completing your code and purple number on rigth will tell space ,you can compare it with others subission codes if your rms time much larger than others means your approach is not optimize enough"
                    }
                ]
            },
            {
                "id": 1790462,
                "content": [
                    {
                        "username": "gbbest15",
                        "content": "hello, i am getting the output right but is saying wrong answer\\n\\n`var shuffle = function(nums, n) {\\n    var avg = nums.length/ 2;\\n    var v = avg;\\n    var ans = [];\\n        for(let i=0; i < avg; i++){\\n                ans.push(nums[i]);\\n                for(let j=v; j<nums.length; j++){ \\n                    ans.push(nums[v]);\\n                    v++;\\n                    break;\\n                }\\n        }\\n         console.log(ans);\\n      \\n}`;"
                    },
                    {
                        "username": "gbbest15",
                        "content": "oh i am to return the array..Done"
                    },
                    {
                        "username": "rahul_raj13",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n            \\n        }\\n        return ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "The hint given says the right pointer should start from n+1,should be n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "This operation is usually called interleaving"
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "Basic question on array but still my solution only beats 92 %  in cpp.\\n `your inline code...\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n         vector<int> result(2 * n);\\n        for (int i = 0, j = 0; i < n; i++) {\\n            result[j++] = nums[i];\\n            result[j++] = nums[i + n];\\n        }\\n        return result;\\n    }\\n};\\nyour inline code...`"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is a piece of cake its take less time  to me actually in this i take the array size as the double the given n and also taking the even and the odd indices and also the even indices in which separating the indices .... "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easiest question\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "O(1) space is possible but it would take O(n^2) time complexity as it would require shifting n elements for replacing n elements. Its easy either way."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "O(n) time is possible with the constraint of this problem."
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Easy Days !"
                    },
                    {
                        "username": "Bary010",
                        "content": "I am new here. I have a question, how to know if my solution has decent runtime, memory uses?"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "when you submit code it will tell rms which is time require for completing your code and purple number on rigth will tell space ,you can compare it with others subission codes if your rms time much larger than others means your approach is not optimize enough"
                    }
                ]
            },
            {
                "id": 1790403,
                "content": [
                    {
                        "username": "gbbest15",
                        "content": "hello, i am getting the output right but is saying wrong answer\\n\\n`var shuffle = function(nums, n) {\\n    var avg = nums.length/ 2;\\n    var v = avg;\\n    var ans = [];\\n        for(let i=0; i < avg; i++){\\n                ans.push(nums[i]);\\n                for(let j=v; j<nums.length; j++){ \\n                    ans.push(nums[v]);\\n                    v++;\\n                    break;\\n                }\\n        }\\n         console.log(ans);\\n      \\n}`;"
                    },
                    {
                        "username": "gbbest15",
                        "content": "oh i am to return the array..Done"
                    },
                    {
                        "username": "rahul_raj13",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n            \\n        }\\n        return ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "The hint given says the right pointer should start from n+1,should be n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "This operation is usually called interleaving"
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "Basic question on array but still my solution only beats 92 %  in cpp.\\n `your inline code...\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n         vector<int> result(2 * n);\\n        for (int i = 0, j = 0; i < n; i++) {\\n            result[j++] = nums[i];\\n            result[j++] = nums[i + n];\\n        }\\n        return result;\\n    }\\n};\\nyour inline code...`"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is a piece of cake its take less time  to me actually in this i take the array size as the double the given n and also taking the even and the odd indices and also the even indices in which separating the indices .... "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easiest question\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "O(1) space is possible but it would take O(n^2) time complexity as it would require shifting n elements for replacing n elements. Its easy either way."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "O(n) time is possible with the constraint of this problem."
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Easy Days !"
                    },
                    {
                        "username": "Bary010",
                        "content": "I am new here. I have a question, how to know if my solution has decent runtime, memory uses?"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "when you submit code it will tell rms which is time require for completing your code and purple number on rigth will tell space ,you can compare it with others subission codes if your rms time much larger than others means your approach is not optimize enough"
                    }
                ]
            },
            {
                "id": 1790379,
                "content": [
                    {
                        "username": "gbbest15",
                        "content": "hello, i am getting the output right but is saying wrong answer\\n\\n`var shuffle = function(nums, n) {\\n    var avg = nums.length/ 2;\\n    var v = avg;\\n    var ans = [];\\n        for(let i=0; i < avg; i++){\\n                ans.push(nums[i]);\\n                for(let j=v; j<nums.length; j++){ \\n                    ans.push(nums[v]);\\n                    v++;\\n                    break;\\n                }\\n        }\\n         console.log(ans);\\n      \\n}`;"
                    },
                    {
                        "username": "gbbest15",
                        "content": "oh i am to return the array..Done"
                    },
                    {
                        "username": "rahul_raj13",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n            \\n        }\\n        return ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "The hint given says the right pointer should start from n+1,should be n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "This operation is usually called interleaving"
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "Basic question on array but still my solution only beats 92 %  in cpp.\\n `your inline code...\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n         vector<int> result(2 * n);\\n        for (int i = 0, j = 0; i < n; i++) {\\n            result[j++] = nums[i];\\n            result[j++] = nums[i + n];\\n        }\\n        return result;\\n    }\\n};\\nyour inline code...`"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is a piece of cake its take less time  to me actually in this i take the array size as the double the given n and also taking the even and the odd indices and also the even indices in which separating the indices .... "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easiest question\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "O(1) space is possible but it would take O(n^2) time complexity as it would require shifting n elements for replacing n elements. Its easy either way."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "O(n) time is possible with the constraint of this problem."
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Easy Days !"
                    },
                    {
                        "username": "Bary010",
                        "content": "I am new here. I have a question, how to know if my solution has decent runtime, memory uses?"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "when you submit code it will tell rms which is time require for completing your code and purple number on rigth will tell space ,you can compare it with others subission codes if your rms time much larger than others means your approach is not optimize enough"
                    }
                ]
            },
            {
                "id": 1790346,
                "content": [
                    {
                        "username": "gbbest15",
                        "content": "hello, i am getting the output right but is saying wrong answer\\n\\n`var shuffle = function(nums, n) {\\n    var avg = nums.length/ 2;\\n    var v = avg;\\n    var ans = [];\\n        for(let i=0; i < avg; i++){\\n                ans.push(nums[i]);\\n                for(let j=v; j<nums.length; j++){ \\n                    ans.push(nums[v]);\\n                    v++;\\n                    break;\\n                }\\n        }\\n         console.log(ans);\\n      \\n}`;"
                    },
                    {
                        "username": "gbbest15",
                        "content": "oh i am to return the array..Done"
                    },
                    {
                        "username": "rahul_raj13",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n            \\n        }\\n        return ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "The hint given says the right pointer should start from n+1,should be n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "This operation is usually called interleaving"
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "Basic question on array but still my solution only beats 92 %  in cpp.\\n `your inline code...\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n         vector<int> result(2 * n);\\n        for (int i = 0, j = 0; i < n; i++) {\\n            result[j++] = nums[i];\\n            result[j++] = nums[i + n];\\n        }\\n        return result;\\n    }\\n};\\nyour inline code...`"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is a piece of cake its take less time  to me actually in this i take the array size as the double the given n and also taking the even and the odd indices and also the even indices in which separating the indices .... "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easiest question\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "O(1) space is possible but it would take O(n^2) time complexity as it would require shifting n elements for replacing n elements. Its easy either way."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "O(n) time is possible with the constraint of this problem."
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Easy Days !"
                    },
                    {
                        "username": "Bary010",
                        "content": "I am new here. I have a question, how to know if my solution has decent runtime, memory uses?"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "when you submit code it will tell rms which is time require for completing your code and purple number on rigth will tell space ,you can compare it with others subission codes if your rms time much larger than others means your approach is not optimize enough"
                    }
                ]
            },
            {
                "id": 1790314,
                "content": [
                    {
                        "username": "gbbest15",
                        "content": "hello, i am getting the output right but is saying wrong answer\\n\\n`var shuffle = function(nums, n) {\\n    var avg = nums.length/ 2;\\n    var v = avg;\\n    var ans = [];\\n        for(let i=0; i < avg; i++){\\n                ans.push(nums[i]);\\n                for(let j=v; j<nums.length; j++){ \\n                    ans.push(nums[v]);\\n                    v++;\\n                    break;\\n                }\\n        }\\n         console.log(ans);\\n      \\n}`;"
                    },
                    {
                        "username": "gbbest15",
                        "content": "oh i am to return the array..Done"
                    },
                    {
                        "username": "rahul_raj13",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n            \\n        }\\n        return ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "The hint given says the right pointer should start from n+1,should be n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "This operation is usually called interleaving"
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "Basic question on array but still my solution only beats 92 %  in cpp.\\n `your inline code...\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n         vector<int> result(2 * n);\\n        for (int i = 0, j = 0; i < n; i++) {\\n            result[j++] = nums[i];\\n            result[j++] = nums[i + n];\\n        }\\n        return result;\\n    }\\n};\\nyour inline code...`"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is a piece of cake its take less time  to me actually in this i take the array size as the double the given n and also taking the even and the odd indices and also the even indices in which separating the indices .... "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easiest question\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "O(1) space is possible but it would take O(n^2) time complexity as it would require shifting n elements for replacing n elements. Its easy either way."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "O(n) time is possible with the constraint of this problem."
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Easy Days !"
                    },
                    {
                        "username": "Bary010",
                        "content": "I am new here. I have a question, how to know if my solution has decent runtime, memory uses?"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "when you submit code it will tell rms which is time require for completing your code and purple number on rigth will tell space ,you can compare it with others subission codes if your rms time much larger than others means your approach is not optimize enough"
                    }
                ]
            },
            {
                "id": 1790273,
                "content": [
                    {
                        "username": "gbbest15",
                        "content": "hello, i am getting the output right but is saying wrong answer\\n\\n`var shuffle = function(nums, n) {\\n    var avg = nums.length/ 2;\\n    var v = avg;\\n    var ans = [];\\n        for(let i=0; i < avg; i++){\\n                ans.push(nums[i]);\\n                for(let j=v; j<nums.length; j++){ \\n                    ans.push(nums[v]);\\n                    v++;\\n                    break;\\n                }\\n        }\\n         console.log(ans);\\n      \\n}`;"
                    },
                    {
                        "username": "gbbest15",
                        "content": "oh i am to return the array..Done"
                    },
                    {
                        "username": "rahul_raj13",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n            \\n        }\\n        return ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "The hint given says the right pointer should start from n+1,should be n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "This operation is usually called interleaving"
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "Basic question on array but still my solution only beats 92 %  in cpp.\\n `your inline code...\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n         vector<int> result(2 * n);\\n        for (int i = 0, j = 0; i < n; i++) {\\n            result[j++] = nums[i];\\n            result[j++] = nums[i + n];\\n        }\\n        return result;\\n    }\\n};\\nyour inline code...`"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is a piece of cake its take less time  to me actually in this i take the array size as the double the given n and also taking the even and the odd indices and also the even indices in which separating the indices .... "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easiest question\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "O(1) space is possible but it would take O(n^2) time complexity as it would require shifting n elements for replacing n elements. Its easy either way."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "O(n) time is possible with the constraint of this problem."
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Easy Days !"
                    },
                    {
                        "username": "Bary010",
                        "content": "I am new here. I have a question, how to know if my solution has decent runtime, memory uses?"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "when you submit code it will tell rms which is time require for completing your code and purple number on rigth will tell space ,you can compare it with others subission codes if your rms time much larger than others means your approach is not optimize enough"
                    }
                ]
            },
            {
                "id": 1790268,
                "content": [
                    {
                        "username": "gbbest15",
                        "content": "hello, i am getting the output right but is saying wrong answer\\n\\n`var shuffle = function(nums, n) {\\n    var avg = nums.length/ 2;\\n    var v = avg;\\n    var ans = [];\\n        for(let i=0; i < avg; i++){\\n                ans.push(nums[i]);\\n                for(let j=v; j<nums.length; j++){ \\n                    ans.push(nums[v]);\\n                    v++;\\n                    break;\\n                }\\n        }\\n         console.log(ans);\\n      \\n}`;"
                    },
                    {
                        "username": "gbbest15",
                        "content": "oh i am to return the array..Done"
                    },
                    {
                        "username": "rahul_raj13",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n            \\n        }\\n        return ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "The hint given says the right pointer should start from n+1,should be n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "This operation is usually called interleaving"
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "Basic question on array but still my solution only beats 92 %  in cpp.\\n `your inline code...\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n         vector<int> result(2 * n);\\n        for (int i = 0, j = 0; i < n; i++) {\\n            result[j++] = nums[i];\\n            result[j++] = nums[i + n];\\n        }\\n        return result;\\n    }\\n};\\nyour inline code...`"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is a piece of cake its take less time  to me actually in this i take the array size as the double the given n and also taking the even and the odd indices and also the even indices in which separating the indices .... "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easiest question\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "O(1) space is possible but it would take O(n^2) time complexity as it would require shifting n elements for replacing n elements. Its easy either way."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "O(n) time is possible with the constraint of this problem."
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Easy Days !"
                    },
                    {
                        "username": "Bary010",
                        "content": "I am new here. I have a question, how to know if my solution has decent runtime, memory uses?"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "when you submit code it will tell rms which is time require for completing your code and purple number on rigth will tell space ,you can compare it with others subission codes if your rms time much larger than others means your approach is not optimize enough"
                    }
                ]
            },
            {
                "id": 1790210,
                "content": [
                    {
                        "username": "gbbest15",
                        "content": "hello, i am getting the output right but is saying wrong answer\\n\\n`var shuffle = function(nums, n) {\\n    var avg = nums.length/ 2;\\n    var v = avg;\\n    var ans = [];\\n        for(let i=0; i < avg; i++){\\n                ans.push(nums[i]);\\n                for(let j=v; j<nums.length; j++){ \\n                    ans.push(nums[v]);\\n                    v++;\\n                    break;\\n                }\\n        }\\n         console.log(ans);\\n      \\n}`;"
                    },
                    {
                        "username": "gbbest15",
                        "content": "oh i am to return the array..Done"
                    },
                    {
                        "username": "rahul_raj13",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n            \\n        }\\n        return ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "The hint given says the right pointer should start from n+1,should be n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "This operation is usually called interleaving"
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "Basic question on array but still my solution only beats 92 %  in cpp.\\n `your inline code...\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n         vector<int> result(2 * n);\\n        for (int i = 0, j = 0; i < n; i++) {\\n            result[j++] = nums[i];\\n            result[j++] = nums[i + n];\\n        }\\n        return result;\\n    }\\n};\\nyour inline code...`"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is a piece of cake its take less time  to me actually in this i take the array size as the double the given n and also taking the even and the odd indices and also the even indices in which separating the indices .... "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easiest question\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "O(1) space is possible but it would take O(n^2) time complexity as it would require shifting n elements for replacing n elements. Its easy either way."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "O(n) time is possible with the constraint of this problem."
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Easy Days !"
                    },
                    {
                        "username": "Bary010",
                        "content": "I am new here. I have a question, how to know if my solution has decent runtime, memory uses?"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "when you submit code it will tell rms which is time require for completing your code and purple number on rigth will tell space ,you can compare it with others subission codes if your rms time much larger than others means your approach is not optimize enough"
                    }
                ]
            },
            {
                "id": 1790148,
                "content": [
                    {
                        "username": "gbbest15",
                        "content": "hello, i am getting the output right but is saying wrong answer\\n\\n`var shuffle = function(nums, n) {\\n    var avg = nums.length/ 2;\\n    var v = avg;\\n    var ans = [];\\n        for(let i=0; i < avg; i++){\\n                ans.push(nums[i]);\\n                for(let j=v; j<nums.length; j++){ \\n                    ans.push(nums[v]);\\n                    v++;\\n                    break;\\n                }\\n        }\\n         console.log(ans);\\n      \\n}`;"
                    },
                    {
                        "username": "gbbest15",
                        "content": "oh i am to return the array..Done"
                    },
                    {
                        "username": "rahul_raj13",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++)\\n        {\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n            \\n        }\\n        return ans;\\n\\n        \\n    }\\n};"
                    },
                    {
                        "username": "ironmonger1",
                        "content": "The hint given says the right pointer should start from n+1,should be n"
                    },
                    {
                        "username": "Electron1997",
                        "content": "This operation is usually called interleaving"
                    },
                    {
                        "username": "Shaurya_Keshari",
                        "content": "Basic question on array but still my solution only beats 92 %  in cpp.\\n `your inline code...\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n         vector<int> result(2 * n);\\n        for (int i = 0, j = 0; i < n; i++) {\\n            result[j++] = nums[i];\\n            result[j++] = nums[i + n];\\n        }\\n        return result;\\n    }\\n};\\nyour inline code...`"
                    },
                    {
                        "username": "Sri_Ram_194",
                        "content": "I think it is a piece of cake its take less time  to me actually in this i take the array size as the double the given n and also taking the even and the odd indices and also the even indices in which separating the indices .... "
                    },
                    {
                        "username": "Evil_123",
                        "content": "//easiest question\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>ans;\\n        for(int i=0;i<n;i++){\\n            ans.push_back(nums[i]);\\n            ans.push_back(nums[i+n]);\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "THRILLMONGER",
                        "content": "O(1) space is possible but it would take O(n^2) time complexity as it would require shifting n elements for replacing n elements. Its easy either way."
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "O(n) time is possible with the constraint of this problem."
                    },
                    {
                        "username": "RahulSingh358",
                        "content": "Easy Days !"
                    },
                    {
                        "username": "Bary010",
                        "content": "I am new here. I have a question, how to know if my solution has decent runtime, memory uses?"
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "when you submit code it will tell rms which is time require for completing your code and purple number on rigth will tell space ,you can compare it with others subission codes if your rms time much larger than others means your approach is not optimize enough"
                    }
                ]
            },
            {
                "id": 1790139,
                "content": [
                    {
                        "username": "aryamangodara",
                        "content": "It is the easiest problem in first glance, and the harder in O(1) Space"
                    },
                    {
                        "username": "chetannada",
                        "content": "It's very easy question of 06 February 2023 leetcode challenge. \nYou have to use `two for loop` and for `first loop` start from `i=0` and go through `n` only and second loop start from `j=n` and go through `nums.length` and set condition like, `if((j - i) === n)` then push the `nums[i] and nums[j]` in `result array`. \nI'm using `Javscript` for the code."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "you can directly run in one loop as push num[i]  and nums[i+n] wherer i<n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This has to be the easiest question ever to appear in the daily coding challenge."
                    },
                    {
                        "username": "koonuss",
                        "content": "This problem can be made more challenging by adding the only constraint of \"in place\".  I think it can be a good example for an interview problem as it can verify a candidate\\'s skills in a short time."
                    },
                    {
                        "username": "sushi27",
                        "content": "I think the solution with O(n) space complexity easy and if someone wondering an approach with less complexity exists than YES.\\nWe will save two number in one position with help of BIT MANIPULATION.\\nNote - The constraints are nums[i] < 10^3, that will take 10 bit to store a number and we can store another number in next 10 bit.\\nThis approach is only follow up because of the constraint"
                    },
                    {
                        "username": "Ninja_1006",
                        "content": "For better Approach firstly you made a vector A intializing with zero and one integer k assigning to 0.\\nThen looping is starting with 0 to n and that number of indexing of vector nums is assigning to vector A but now it\\'s index is k and increment k by 2 is is so on conditionate to n.\\nnow k=1\\nabove method is same now but now looping is starting with n to nums.size()-1. and that indexing value of nums is assigned to A and also k is incremented by 2.\\nsimply return a."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a o(1) space solution?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "nice two pointer problem,\\n"
                    },
                    {
                        "username": "sunny54321",
                        "content": "Here is a very easy and simple to understand solution .\\n\\nGiven in the problem an array \\' nums \\' of size \\' n \\' and we have to shuffle in a way that array should look like (x1, y1, x2, y2, x3, y3, ......) and so on.\\nfor example :  \\ninput :-  [1,1,2,2] , n = 2\\nexpected output is  [ 1, 2, 1, 2]\\nwe simply create a new array \\'ans\\'.\\nrun a for loop form \\' 0 \\' to \\' n \\'.\\nand push elements in order 0 and 0+n.\\nand copy the ans array to nums array.\\n\\n\\ncode :- \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        for( int i = 0; i < nums.size()/2; i++ ){\\n            ans.push_back(nums[i] );\\n            ans.push_back( nums[i+n] );\\n        }\\n        nums = ans;\\n        return nums;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "the good days of LeetCode \\uD83D\\uDE05\\nLeetcode be like .... Picture abhi baki h mere dost \\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1790111,
                "content": [
                    {
                        "username": "aryamangodara",
                        "content": "It is the easiest problem in first glance, and the harder in O(1) Space"
                    },
                    {
                        "username": "chetannada",
                        "content": "It's very easy question of 06 February 2023 leetcode challenge. \nYou have to use `two for loop` and for `first loop` start from `i=0` and go through `n` only and second loop start from `j=n` and go through `nums.length` and set condition like, `if((j - i) === n)` then push the `nums[i] and nums[j]` in `result array`. \nI'm using `Javscript` for the code."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "you can directly run in one loop as push num[i]  and nums[i+n] wherer i<n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This has to be the easiest question ever to appear in the daily coding challenge."
                    },
                    {
                        "username": "koonuss",
                        "content": "This problem can be made more challenging by adding the only constraint of \"in place\".  I think it can be a good example for an interview problem as it can verify a candidate\\'s skills in a short time."
                    },
                    {
                        "username": "sushi27",
                        "content": "I think the solution with O(n) space complexity easy and if someone wondering an approach with less complexity exists than YES.\\nWe will save two number in one position with help of BIT MANIPULATION.\\nNote - The constraints are nums[i] < 10^3, that will take 10 bit to store a number and we can store another number in next 10 bit.\\nThis approach is only follow up because of the constraint"
                    },
                    {
                        "username": "Ninja_1006",
                        "content": "For better Approach firstly you made a vector A intializing with zero and one integer k assigning to 0.\\nThen looping is starting with 0 to n and that number of indexing of vector nums is assigning to vector A but now it\\'s index is k and increment k by 2 is is so on conditionate to n.\\nnow k=1\\nabove method is same now but now looping is starting with n to nums.size()-1. and that indexing value of nums is assigned to A and also k is incremented by 2.\\nsimply return a."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a o(1) space solution?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "nice two pointer problem,\\n"
                    },
                    {
                        "username": "sunny54321",
                        "content": "Here is a very easy and simple to understand solution .\\n\\nGiven in the problem an array \\' nums \\' of size \\' n \\' and we have to shuffle in a way that array should look like (x1, y1, x2, y2, x3, y3, ......) and so on.\\nfor example :  \\ninput :-  [1,1,2,2] , n = 2\\nexpected output is  [ 1, 2, 1, 2]\\nwe simply create a new array \\'ans\\'.\\nrun a for loop form \\' 0 \\' to \\' n \\'.\\nand push elements in order 0 and 0+n.\\nand copy the ans array to nums array.\\n\\n\\ncode :- \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        for( int i = 0; i < nums.size()/2; i++ ){\\n            ans.push_back(nums[i] );\\n            ans.push_back( nums[i+n] );\\n        }\\n        nums = ans;\\n        return nums;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "the good days of LeetCode \\uD83D\\uDE05\\nLeetcode be like .... Picture abhi baki h mere dost \\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1790044,
                "content": [
                    {
                        "username": "aryamangodara",
                        "content": "It is the easiest problem in first glance, and the harder in O(1) Space"
                    },
                    {
                        "username": "chetannada",
                        "content": "It's very easy question of 06 February 2023 leetcode challenge. \nYou have to use `two for loop` and for `first loop` start from `i=0` and go through `n` only and second loop start from `j=n` and go through `nums.length` and set condition like, `if((j - i) === n)` then push the `nums[i] and nums[j]` in `result array`. \nI'm using `Javscript` for the code."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "you can directly run in one loop as push num[i]  and nums[i+n] wherer i<n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This has to be the easiest question ever to appear in the daily coding challenge."
                    },
                    {
                        "username": "koonuss",
                        "content": "This problem can be made more challenging by adding the only constraint of \"in place\".  I think it can be a good example for an interview problem as it can verify a candidate\\'s skills in a short time."
                    },
                    {
                        "username": "sushi27",
                        "content": "I think the solution with O(n) space complexity easy and if someone wondering an approach with less complexity exists than YES.\\nWe will save two number in one position with help of BIT MANIPULATION.\\nNote - The constraints are nums[i] < 10^3, that will take 10 bit to store a number and we can store another number in next 10 bit.\\nThis approach is only follow up because of the constraint"
                    },
                    {
                        "username": "Ninja_1006",
                        "content": "For better Approach firstly you made a vector A intializing with zero and one integer k assigning to 0.\\nThen looping is starting with 0 to n and that number of indexing of vector nums is assigning to vector A but now it\\'s index is k and increment k by 2 is is so on conditionate to n.\\nnow k=1\\nabove method is same now but now looping is starting with n to nums.size()-1. and that indexing value of nums is assigned to A and also k is incremented by 2.\\nsimply return a."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a o(1) space solution?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "nice two pointer problem,\\n"
                    },
                    {
                        "username": "sunny54321",
                        "content": "Here is a very easy and simple to understand solution .\\n\\nGiven in the problem an array \\' nums \\' of size \\' n \\' and we have to shuffle in a way that array should look like (x1, y1, x2, y2, x3, y3, ......) and so on.\\nfor example :  \\ninput :-  [1,1,2,2] , n = 2\\nexpected output is  [ 1, 2, 1, 2]\\nwe simply create a new array \\'ans\\'.\\nrun a for loop form \\' 0 \\' to \\' n \\'.\\nand push elements in order 0 and 0+n.\\nand copy the ans array to nums array.\\n\\n\\ncode :- \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        for( int i = 0; i < nums.size()/2; i++ ){\\n            ans.push_back(nums[i] );\\n            ans.push_back( nums[i+n] );\\n        }\\n        nums = ans;\\n        return nums;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "the good days of LeetCode \\uD83D\\uDE05\\nLeetcode be like .... Picture abhi baki h mere dost \\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1790039,
                "content": [
                    {
                        "username": "aryamangodara",
                        "content": "It is the easiest problem in first glance, and the harder in O(1) Space"
                    },
                    {
                        "username": "chetannada",
                        "content": "It's very easy question of 06 February 2023 leetcode challenge. \nYou have to use `two for loop` and for `first loop` start from `i=0` and go through `n` only and second loop start from `j=n` and go through `nums.length` and set condition like, `if((j - i) === n)` then push the `nums[i] and nums[j]` in `result array`. \nI'm using `Javscript` for the code."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "you can directly run in one loop as push num[i]  and nums[i+n] wherer i<n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This has to be the easiest question ever to appear in the daily coding challenge."
                    },
                    {
                        "username": "koonuss",
                        "content": "This problem can be made more challenging by adding the only constraint of \"in place\".  I think it can be a good example for an interview problem as it can verify a candidate\\'s skills in a short time."
                    },
                    {
                        "username": "sushi27",
                        "content": "I think the solution with O(n) space complexity easy and if someone wondering an approach with less complexity exists than YES.\\nWe will save two number in one position with help of BIT MANIPULATION.\\nNote - The constraints are nums[i] < 10^3, that will take 10 bit to store a number and we can store another number in next 10 bit.\\nThis approach is only follow up because of the constraint"
                    },
                    {
                        "username": "Ninja_1006",
                        "content": "For better Approach firstly you made a vector A intializing with zero and one integer k assigning to 0.\\nThen looping is starting with 0 to n and that number of indexing of vector nums is assigning to vector A but now it\\'s index is k and increment k by 2 is is so on conditionate to n.\\nnow k=1\\nabove method is same now but now looping is starting with n to nums.size()-1. and that indexing value of nums is assigned to A and also k is incremented by 2.\\nsimply return a."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a o(1) space solution?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "nice two pointer problem,\\n"
                    },
                    {
                        "username": "sunny54321",
                        "content": "Here is a very easy and simple to understand solution .\\n\\nGiven in the problem an array \\' nums \\' of size \\' n \\' and we have to shuffle in a way that array should look like (x1, y1, x2, y2, x3, y3, ......) and so on.\\nfor example :  \\ninput :-  [1,1,2,2] , n = 2\\nexpected output is  [ 1, 2, 1, 2]\\nwe simply create a new array \\'ans\\'.\\nrun a for loop form \\' 0 \\' to \\' n \\'.\\nand push elements in order 0 and 0+n.\\nand copy the ans array to nums array.\\n\\n\\ncode :- \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        for( int i = 0; i < nums.size()/2; i++ ){\\n            ans.push_back(nums[i] );\\n            ans.push_back( nums[i+n] );\\n        }\\n        nums = ans;\\n        return nums;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "the good days of LeetCode \\uD83D\\uDE05\\nLeetcode be like .... Picture abhi baki h mere dost \\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1790033,
                "content": [
                    {
                        "username": "aryamangodara",
                        "content": "It is the easiest problem in first glance, and the harder in O(1) Space"
                    },
                    {
                        "username": "chetannada",
                        "content": "It's very easy question of 06 February 2023 leetcode challenge. \nYou have to use `two for loop` and for `first loop` start from `i=0` and go through `n` only and second loop start from `j=n` and go through `nums.length` and set condition like, `if((j - i) === n)` then push the `nums[i] and nums[j]` in `result array`. \nI'm using `Javscript` for the code."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "you can directly run in one loop as push num[i]  and nums[i+n] wherer i<n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This has to be the easiest question ever to appear in the daily coding challenge."
                    },
                    {
                        "username": "koonuss",
                        "content": "This problem can be made more challenging by adding the only constraint of \"in place\".  I think it can be a good example for an interview problem as it can verify a candidate\\'s skills in a short time."
                    },
                    {
                        "username": "sushi27",
                        "content": "I think the solution with O(n) space complexity easy and if someone wondering an approach with less complexity exists than YES.\\nWe will save two number in one position with help of BIT MANIPULATION.\\nNote - The constraints are nums[i] < 10^3, that will take 10 bit to store a number and we can store another number in next 10 bit.\\nThis approach is only follow up because of the constraint"
                    },
                    {
                        "username": "Ninja_1006",
                        "content": "For better Approach firstly you made a vector A intializing with zero and one integer k assigning to 0.\\nThen looping is starting with 0 to n and that number of indexing of vector nums is assigning to vector A but now it\\'s index is k and increment k by 2 is is so on conditionate to n.\\nnow k=1\\nabove method is same now but now looping is starting with n to nums.size()-1. and that indexing value of nums is assigned to A and also k is incremented by 2.\\nsimply return a."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a o(1) space solution?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "nice two pointer problem,\\n"
                    },
                    {
                        "username": "sunny54321",
                        "content": "Here is a very easy and simple to understand solution .\\n\\nGiven in the problem an array \\' nums \\' of size \\' n \\' and we have to shuffle in a way that array should look like (x1, y1, x2, y2, x3, y3, ......) and so on.\\nfor example :  \\ninput :-  [1,1,2,2] , n = 2\\nexpected output is  [ 1, 2, 1, 2]\\nwe simply create a new array \\'ans\\'.\\nrun a for loop form \\' 0 \\' to \\' n \\'.\\nand push elements in order 0 and 0+n.\\nand copy the ans array to nums array.\\n\\n\\ncode :- \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        for( int i = 0; i < nums.size()/2; i++ ){\\n            ans.push_back(nums[i] );\\n            ans.push_back( nums[i+n] );\\n        }\\n        nums = ans;\\n        return nums;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "the good days of LeetCode \\uD83D\\uDE05\\nLeetcode be like .... Picture abhi baki h mere dost \\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1789887,
                "content": [
                    {
                        "username": "aryamangodara",
                        "content": "It is the easiest problem in first glance, and the harder in O(1) Space"
                    },
                    {
                        "username": "chetannada",
                        "content": "It's very easy question of 06 February 2023 leetcode challenge. \nYou have to use `two for loop` and for `first loop` start from `i=0` and go through `n` only and second loop start from `j=n` and go through `nums.length` and set condition like, `if((j - i) === n)` then push the `nums[i] and nums[j]` in `result array`. \nI'm using `Javscript` for the code."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "you can directly run in one loop as push num[i]  and nums[i+n] wherer i<n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This has to be the easiest question ever to appear in the daily coding challenge."
                    },
                    {
                        "username": "koonuss",
                        "content": "This problem can be made more challenging by adding the only constraint of \"in place\".  I think it can be a good example for an interview problem as it can verify a candidate\\'s skills in a short time."
                    },
                    {
                        "username": "sushi27",
                        "content": "I think the solution with O(n) space complexity easy and if someone wondering an approach with less complexity exists than YES.\\nWe will save two number in one position with help of BIT MANIPULATION.\\nNote - The constraints are nums[i] < 10^3, that will take 10 bit to store a number and we can store another number in next 10 bit.\\nThis approach is only follow up because of the constraint"
                    },
                    {
                        "username": "Ninja_1006",
                        "content": "For better Approach firstly you made a vector A intializing with zero and one integer k assigning to 0.\\nThen looping is starting with 0 to n and that number of indexing of vector nums is assigning to vector A but now it\\'s index is k and increment k by 2 is is so on conditionate to n.\\nnow k=1\\nabove method is same now but now looping is starting with n to nums.size()-1. and that indexing value of nums is assigned to A and also k is incremented by 2.\\nsimply return a."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a o(1) space solution?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "nice two pointer problem,\\n"
                    },
                    {
                        "username": "sunny54321",
                        "content": "Here is a very easy and simple to understand solution .\\n\\nGiven in the problem an array \\' nums \\' of size \\' n \\' and we have to shuffle in a way that array should look like (x1, y1, x2, y2, x3, y3, ......) and so on.\\nfor example :  \\ninput :-  [1,1,2,2] , n = 2\\nexpected output is  [ 1, 2, 1, 2]\\nwe simply create a new array \\'ans\\'.\\nrun a for loop form \\' 0 \\' to \\' n \\'.\\nand push elements in order 0 and 0+n.\\nand copy the ans array to nums array.\\n\\n\\ncode :- \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        for( int i = 0; i < nums.size()/2; i++ ){\\n            ans.push_back(nums[i] );\\n            ans.push_back( nums[i+n] );\\n        }\\n        nums = ans;\\n        return nums;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "the good days of LeetCode \\uD83D\\uDE05\\nLeetcode be like .... Picture abhi baki h mere dost \\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1789883,
                "content": [
                    {
                        "username": "aryamangodara",
                        "content": "It is the easiest problem in first glance, and the harder in O(1) Space"
                    },
                    {
                        "username": "chetannada",
                        "content": "It's very easy question of 06 February 2023 leetcode challenge. \nYou have to use `two for loop` and for `first loop` start from `i=0` and go through `n` only and second loop start from `j=n` and go through `nums.length` and set condition like, `if((j - i) === n)` then push the `nums[i] and nums[j]` in `result array`. \nI'm using `Javscript` for the code."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "you can directly run in one loop as push num[i]  and nums[i+n] wherer i<n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This has to be the easiest question ever to appear in the daily coding challenge."
                    },
                    {
                        "username": "koonuss",
                        "content": "This problem can be made more challenging by adding the only constraint of \"in place\".  I think it can be a good example for an interview problem as it can verify a candidate\\'s skills in a short time."
                    },
                    {
                        "username": "sushi27",
                        "content": "I think the solution with O(n) space complexity easy and if someone wondering an approach with less complexity exists than YES.\\nWe will save two number in one position with help of BIT MANIPULATION.\\nNote - The constraints are nums[i] < 10^3, that will take 10 bit to store a number and we can store another number in next 10 bit.\\nThis approach is only follow up because of the constraint"
                    },
                    {
                        "username": "Ninja_1006",
                        "content": "For better Approach firstly you made a vector A intializing with zero and one integer k assigning to 0.\\nThen looping is starting with 0 to n and that number of indexing of vector nums is assigning to vector A but now it\\'s index is k and increment k by 2 is is so on conditionate to n.\\nnow k=1\\nabove method is same now but now looping is starting with n to nums.size()-1. and that indexing value of nums is assigned to A and also k is incremented by 2.\\nsimply return a."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a o(1) space solution?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "nice two pointer problem,\\n"
                    },
                    {
                        "username": "sunny54321",
                        "content": "Here is a very easy and simple to understand solution .\\n\\nGiven in the problem an array \\' nums \\' of size \\' n \\' and we have to shuffle in a way that array should look like (x1, y1, x2, y2, x3, y3, ......) and so on.\\nfor example :  \\ninput :-  [1,1,2,2] , n = 2\\nexpected output is  [ 1, 2, 1, 2]\\nwe simply create a new array \\'ans\\'.\\nrun a for loop form \\' 0 \\' to \\' n \\'.\\nand push elements in order 0 and 0+n.\\nand copy the ans array to nums array.\\n\\n\\ncode :- \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        for( int i = 0; i < nums.size()/2; i++ ){\\n            ans.push_back(nums[i] );\\n            ans.push_back( nums[i+n] );\\n        }\\n        nums = ans;\\n        return nums;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "the good days of LeetCode \\uD83D\\uDE05\\nLeetcode be like .... Picture abhi baki h mere dost \\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1789881,
                "content": [
                    {
                        "username": "aryamangodara",
                        "content": "It is the easiest problem in first glance, and the harder in O(1) Space"
                    },
                    {
                        "username": "chetannada",
                        "content": "It's very easy question of 06 February 2023 leetcode challenge. \nYou have to use `two for loop` and for `first loop` start from `i=0` and go through `n` only and second loop start from `j=n` and go through `nums.length` and set condition like, `if((j - i) === n)` then push the `nums[i] and nums[j]` in `result array`. \nI'm using `Javscript` for the code."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "you can directly run in one loop as push num[i]  and nums[i+n] wherer i<n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This has to be the easiest question ever to appear in the daily coding challenge."
                    },
                    {
                        "username": "koonuss",
                        "content": "This problem can be made more challenging by adding the only constraint of \"in place\".  I think it can be a good example for an interview problem as it can verify a candidate\\'s skills in a short time."
                    },
                    {
                        "username": "sushi27",
                        "content": "I think the solution with O(n) space complexity easy and if someone wondering an approach with less complexity exists than YES.\\nWe will save two number in one position with help of BIT MANIPULATION.\\nNote - The constraints are nums[i] < 10^3, that will take 10 bit to store a number and we can store another number in next 10 bit.\\nThis approach is only follow up because of the constraint"
                    },
                    {
                        "username": "Ninja_1006",
                        "content": "For better Approach firstly you made a vector A intializing with zero and one integer k assigning to 0.\\nThen looping is starting with 0 to n and that number of indexing of vector nums is assigning to vector A but now it\\'s index is k and increment k by 2 is is so on conditionate to n.\\nnow k=1\\nabove method is same now but now looping is starting with n to nums.size()-1. and that indexing value of nums is assigned to A and also k is incremented by 2.\\nsimply return a."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a o(1) space solution?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "nice two pointer problem,\\n"
                    },
                    {
                        "username": "sunny54321",
                        "content": "Here is a very easy and simple to understand solution .\\n\\nGiven in the problem an array \\' nums \\' of size \\' n \\' and we have to shuffle in a way that array should look like (x1, y1, x2, y2, x3, y3, ......) and so on.\\nfor example :  \\ninput :-  [1,1,2,2] , n = 2\\nexpected output is  [ 1, 2, 1, 2]\\nwe simply create a new array \\'ans\\'.\\nrun a for loop form \\' 0 \\' to \\' n \\'.\\nand push elements in order 0 and 0+n.\\nand copy the ans array to nums array.\\n\\n\\ncode :- \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        for( int i = 0; i < nums.size()/2; i++ ){\\n            ans.push_back(nums[i] );\\n            ans.push_back( nums[i+n] );\\n        }\\n        nums = ans;\\n        return nums;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "the good days of LeetCode \\uD83D\\uDE05\\nLeetcode be like .... Picture abhi baki h mere dost \\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1789878,
                "content": [
                    {
                        "username": "aryamangodara",
                        "content": "It is the easiest problem in first glance, and the harder in O(1) Space"
                    },
                    {
                        "username": "chetannada",
                        "content": "It's very easy question of 06 February 2023 leetcode challenge. \nYou have to use `two for loop` and for `first loop` start from `i=0` and go through `n` only and second loop start from `j=n` and go through `nums.length` and set condition like, `if((j - i) === n)` then push the `nums[i] and nums[j]` in `result array`. \nI'm using `Javscript` for the code."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "you can directly run in one loop as push num[i]  and nums[i+n] wherer i<n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This has to be the easiest question ever to appear in the daily coding challenge."
                    },
                    {
                        "username": "koonuss",
                        "content": "This problem can be made more challenging by adding the only constraint of \"in place\".  I think it can be a good example for an interview problem as it can verify a candidate\\'s skills in a short time."
                    },
                    {
                        "username": "sushi27",
                        "content": "I think the solution with O(n) space complexity easy and if someone wondering an approach with less complexity exists than YES.\\nWe will save two number in one position with help of BIT MANIPULATION.\\nNote - The constraints are nums[i] < 10^3, that will take 10 bit to store a number and we can store another number in next 10 bit.\\nThis approach is only follow up because of the constraint"
                    },
                    {
                        "username": "Ninja_1006",
                        "content": "For better Approach firstly you made a vector A intializing with zero and one integer k assigning to 0.\\nThen looping is starting with 0 to n and that number of indexing of vector nums is assigning to vector A but now it\\'s index is k and increment k by 2 is is so on conditionate to n.\\nnow k=1\\nabove method is same now but now looping is starting with n to nums.size()-1. and that indexing value of nums is assigned to A and also k is incremented by 2.\\nsimply return a."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a o(1) space solution?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "nice two pointer problem,\\n"
                    },
                    {
                        "username": "sunny54321",
                        "content": "Here is a very easy and simple to understand solution .\\n\\nGiven in the problem an array \\' nums \\' of size \\' n \\' and we have to shuffle in a way that array should look like (x1, y1, x2, y2, x3, y3, ......) and so on.\\nfor example :  \\ninput :-  [1,1,2,2] , n = 2\\nexpected output is  [ 1, 2, 1, 2]\\nwe simply create a new array \\'ans\\'.\\nrun a for loop form \\' 0 \\' to \\' n \\'.\\nand push elements in order 0 and 0+n.\\nand copy the ans array to nums array.\\n\\n\\ncode :- \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        for( int i = 0; i < nums.size()/2; i++ ){\\n            ans.push_back(nums[i] );\\n            ans.push_back( nums[i+n] );\\n        }\\n        nums = ans;\\n        return nums;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "the good days of LeetCode \\uD83D\\uDE05\\nLeetcode be like .... Picture abhi baki h mere dost \\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1789877,
                "content": [
                    {
                        "username": "aryamangodara",
                        "content": "It is the easiest problem in first glance, and the harder in O(1) Space"
                    },
                    {
                        "username": "chetannada",
                        "content": "It's very easy question of 06 February 2023 leetcode challenge. \nYou have to use `two for loop` and for `first loop` start from `i=0` and go through `n` only and second loop start from `j=n` and go through `nums.length` and set condition like, `if((j - i) === n)` then push the `nums[i] and nums[j]` in `result array`. \nI'm using `Javscript` for the code."
                    },
                    {
                        "username": "PAIN_an_c",
                        "content": "you can directly run in one loop as push num[i]  and nums[i+n] wherer i<n"
                    },
                    {
                        "username": "satyam_rai15",
                        "content": "This has to be the easiest question ever to appear in the daily coding challenge."
                    },
                    {
                        "username": "koonuss",
                        "content": "This problem can be made more challenging by adding the only constraint of \"in place\".  I think it can be a good example for an interview problem as it can verify a candidate\\'s skills in a short time."
                    },
                    {
                        "username": "sushi27",
                        "content": "I think the solution with O(n) space complexity easy and if someone wondering an approach with less complexity exists than YES.\\nWe will save two number in one position with help of BIT MANIPULATION.\\nNote - The constraints are nums[i] < 10^3, that will take 10 bit to store a number and we can store another number in next 10 bit.\\nThis approach is only follow up because of the constraint"
                    },
                    {
                        "username": "Ninja_1006",
                        "content": "For better Approach firstly you made a vector A intializing with zero and one integer k assigning to 0.\\nThen looping is starting with 0 to n and that number of indexing of vector nums is assigning to vector A but now it\\'s index is k and increment k by 2 is is so on conditionate to n.\\nnow k=1\\nabove method is same now but now looping is starting with n to nums.size()-1. and that indexing value of nums is assigned to A and also k is incremented by 2.\\nsimply return a."
                    },
                    {
                        "username": "JiayingGao",
                        "content": "Is there a o(1) space solution?"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "nice two pointer problem,\\n"
                    },
                    {
                        "username": "sunny54321",
                        "content": "Here is a very easy and simple to understand solution .\\n\\nGiven in the problem an array \\' nums \\' of size \\' n \\' and we have to shuffle in a way that array should look like (x1, y1, x2, y2, x3, y3, ......) and so on.\\nfor example :  \\ninput :-  [1,1,2,2] , n = 2\\nexpected output is  [ 1, 2, 1, 2]\\nwe simply create a new array \\'ans\\'.\\nrun a for loop form \\' 0 \\' to \\' n \\'.\\nand push elements in order 0 and 0+n.\\nand copy the ans array to nums array.\\n\\n\\ncode :- \\n\\n\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int> ans;\\n        for( int i = 0; i < nums.size()/2; i++ ){\\n            ans.push_back(nums[i] );\\n            ans.push_back( nums[i+n] );\\n        }\\n        nums = ans;\\n        return nums;\\n    }\\n};\\n\\n"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "Knight-03",
                        "content": "the good days of LeetCode \\uD83D\\uDE05\\nLeetcode be like .... Picture abhi baki h mere dost \\uD83D\\uDE02\\uD83D\\uDE02"
                    }
                ]
            },
            {
                "id": 1789843,
                "content": [
                    {
                        "username": "TsuruLee",
                        "content": "nice problem to practice your new programming language."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": " This is the first problem where I would say: Do not give the optimal solution in an interview. There is NO WAY that someone could just \"problem solve\" their way to the constant space solution lmao. The interviewer will immediately know you\\'ve seen this before and just give you a different problem or mark you down as \"nuetral\""
                    },
                    {
                        "username": "rushi_4123",
                        "content": "3 days of EASY LeetCode!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "is there any algo to do it inplace??\\n"
                    },
                    {
                        "username": "oliverdowling",
                        "content": "You could do it with an in-place sort, based on the original indexes. JavaScript doesn\\'t have the index or actually sort in-place, but here is a working solution that demonstrates the idea:\\n\\n```javascript\\nreturn nums\\n    .map((val, index) => new Object({ val, index }))\\n    .sort((first, second) => {\\n        if (first.index >= n) {\\n            if (second.index >= n) return first.index - second.index;\\n            else return (first.index - n) - second.index;\\n        } else {\\n            if (second.index >= n) return first.index - (second.index - n);\\n            else return first.index - second.index;\\n        }\\n    })\\n    .map(elem => elem.val);\\n```"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Done"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "I have been trying to get this question done with binary search in order to reduce the time and space complexity and even tho the logic works on paper with multiple test cases, my array keeps returning as it is. please check and let me know my mistake..\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int count=0;\\n        int s;\\n        int end;\\n        int  mid=(s+end)/2;\\n        for(s=1;end<nums.size()-1;end--)\\n        {\\n            if(count==n)\\n            {\\n                break;\\n            }\\n            mid=(s+end)/2;\\n            swap(mid,end);\\n            count++;\\n            \\n        }\\n        swap(s,mid);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "user2094wl",
                        "content": "I dont know about the time and space complexity, can anyone tell me?\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[2*n];\\n        int a = n;\\n        for(int i=0; i<2*n; i++){\\n            if(i%2==0){\\n                newArr[i] = nums[i/2];\\n            }else{\\n                newArr[i] = nums[a];\\n                a++;\\n            }\\n        }\\n        return newArr;\\n    }\\n}"
                    },
                    {
                        "username": "vivekchau123",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>v;\\n        int count=0 , off=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                v.push_back(nums[count]);\\n                count++;\\n            }\\n            else{\\n                v.push_back(nums[n+off]);\\n                off++;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "sonu36437",
                        "content": "use two pointer approach as the hint is given :\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int newarray[]=new int[2*n];\\n        int xpart=0;\\n        int ypart =n;\\n        int i=0;\\n        while(i<=2*n-1){\\n            newarray[i]=nums[xpart];\\n            i++;\\n            xpart++;\\n            newarray[i]=nums[ypart];\\n            ypart++;\\n            i++;\\n\\n\\n        } \\n        return newarray;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "chrihop",
                        "content": "Could someone write an answer with O(1) space complexity and O(n) time complexity?\\n"
                    }
                ]
            },
            {
                "id": 1789826,
                "content": [
                    {
                        "username": "TsuruLee",
                        "content": "nice problem to practice your new programming language."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": " This is the first problem where I would say: Do not give the optimal solution in an interview. There is NO WAY that someone could just \"problem solve\" their way to the constant space solution lmao. The interviewer will immediately know you\\'ve seen this before and just give you a different problem or mark you down as \"nuetral\""
                    },
                    {
                        "username": "rushi_4123",
                        "content": "3 days of EASY LeetCode!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "is there any algo to do it inplace??\\n"
                    },
                    {
                        "username": "oliverdowling",
                        "content": "You could do it with an in-place sort, based on the original indexes. JavaScript doesn\\'t have the index or actually sort in-place, but here is a working solution that demonstrates the idea:\\n\\n```javascript\\nreturn nums\\n    .map((val, index) => new Object({ val, index }))\\n    .sort((first, second) => {\\n        if (first.index >= n) {\\n            if (second.index >= n) return first.index - second.index;\\n            else return (first.index - n) - second.index;\\n        } else {\\n            if (second.index >= n) return first.index - (second.index - n);\\n            else return first.index - second.index;\\n        }\\n    })\\n    .map(elem => elem.val);\\n```"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Done"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "I have been trying to get this question done with binary search in order to reduce the time and space complexity and even tho the logic works on paper with multiple test cases, my array keeps returning as it is. please check and let me know my mistake..\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int count=0;\\n        int s;\\n        int end;\\n        int  mid=(s+end)/2;\\n        for(s=1;end<nums.size()-1;end--)\\n        {\\n            if(count==n)\\n            {\\n                break;\\n            }\\n            mid=(s+end)/2;\\n            swap(mid,end);\\n            count++;\\n            \\n        }\\n        swap(s,mid);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "user2094wl",
                        "content": "I dont know about the time and space complexity, can anyone tell me?\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[2*n];\\n        int a = n;\\n        for(int i=0; i<2*n; i++){\\n            if(i%2==0){\\n                newArr[i] = nums[i/2];\\n            }else{\\n                newArr[i] = nums[a];\\n                a++;\\n            }\\n        }\\n        return newArr;\\n    }\\n}"
                    },
                    {
                        "username": "vivekchau123",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>v;\\n        int count=0 , off=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                v.push_back(nums[count]);\\n                count++;\\n            }\\n            else{\\n                v.push_back(nums[n+off]);\\n                off++;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "sonu36437",
                        "content": "use two pointer approach as the hint is given :\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int newarray[]=new int[2*n];\\n        int xpart=0;\\n        int ypart =n;\\n        int i=0;\\n        while(i<=2*n-1){\\n            newarray[i]=nums[xpart];\\n            i++;\\n            xpart++;\\n            newarray[i]=nums[ypart];\\n            ypart++;\\n            i++;\\n\\n\\n        } \\n        return newarray;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "chrihop",
                        "content": "Could someone write an answer with O(1) space complexity and O(n) time complexity?\\n"
                    }
                ]
            },
            {
                "id": 1789823,
                "content": [
                    {
                        "username": "TsuruLee",
                        "content": "nice problem to practice your new programming language."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": " This is the first problem where I would say: Do not give the optimal solution in an interview. There is NO WAY that someone could just \"problem solve\" their way to the constant space solution lmao. The interviewer will immediately know you\\'ve seen this before and just give you a different problem or mark you down as \"nuetral\""
                    },
                    {
                        "username": "rushi_4123",
                        "content": "3 days of EASY LeetCode!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "is there any algo to do it inplace??\\n"
                    },
                    {
                        "username": "oliverdowling",
                        "content": "You could do it with an in-place sort, based on the original indexes. JavaScript doesn\\'t have the index or actually sort in-place, but here is a working solution that demonstrates the idea:\\n\\n```javascript\\nreturn nums\\n    .map((val, index) => new Object({ val, index }))\\n    .sort((first, second) => {\\n        if (first.index >= n) {\\n            if (second.index >= n) return first.index - second.index;\\n            else return (first.index - n) - second.index;\\n        } else {\\n            if (second.index >= n) return first.index - (second.index - n);\\n            else return first.index - second.index;\\n        }\\n    })\\n    .map(elem => elem.val);\\n```"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Done"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "I have been trying to get this question done with binary search in order to reduce the time and space complexity and even tho the logic works on paper with multiple test cases, my array keeps returning as it is. please check and let me know my mistake..\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int count=0;\\n        int s;\\n        int end;\\n        int  mid=(s+end)/2;\\n        for(s=1;end<nums.size()-1;end--)\\n        {\\n            if(count==n)\\n            {\\n                break;\\n            }\\n            mid=(s+end)/2;\\n            swap(mid,end);\\n            count++;\\n            \\n        }\\n        swap(s,mid);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "user2094wl",
                        "content": "I dont know about the time and space complexity, can anyone tell me?\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[2*n];\\n        int a = n;\\n        for(int i=0; i<2*n; i++){\\n            if(i%2==0){\\n                newArr[i] = nums[i/2];\\n            }else{\\n                newArr[i] = nums[a];\\n                a++;\\n            }\\n        }\\n        return newArr;\\n    }\\n}"
                    },
                    {
                        "username": "vivekchau123",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>v;\\n        int count=0 , off=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                v.push_back(nums[count]);\\n                count++;\\n            }\\n            else{\\n                v.push_back(nums[n+off]);\\n                off++;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "sonu36437",
                        "content": "use two pointer approach as the hint is given :\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int newarray[]=new int[2*n];\\n        int xpart=0;\\n        int ypart =n;\\n        int i=0;\\n        while(i<=2*n-1){\\n            newarray[i]=nums[xpart];\\n            i++;\\n            xpart++;\\n            newarray[i]=nums[ypart];\\n            ypart++;\\n            i++;\\n\\n\\n        } \\n        return newarray;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "chrihop",
                        "content": "Could someone write an answer with O(1) space complexity and O(n) time complexity?\\n"
                    }
                ]
            },
            {
                "id": 1789822,
                "content": [
                    {
                        "username": "TsuruLee",
                        "content": "nice problem to practice your new programming language."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": " This is the first problem where I would say: Do not give the optimal solution in an interview. There is NO WAY that someone could just \"problem solve\" their way to the constant space solution lmao. The interviewer will immediately know you\\'ve seen this before and just give you a different problem or mark you down as \"nuetral\""
                    },
                    {
                        "username": "rushi_4123",
                        "content": "3 days of EASY LeetCode!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "is there any algo to do it inplace??\\n"
                    },
                    {
                        "username": "oliverdowling",
                        "content": "You could do it with an in-place sort, based on the original indexes. JavaScript doesn\\'t have the index or actually sort in-place, but here is a working solution that demonstrates the idea:\\n\\n```javascript\\nreturn nums\\n    .map((val, index) => new Object({ val, index }))\\n    .sort((first, second) => {\\n        if (first.index >= n) {\\n            if (second.index >= n) return first.index - second.index;\\n            else return (first.index - n) - second.index;\\n        } else {\\n            if (second.index >= n) return first.index - (second.index - n);\\n            else return first.index - second.index;\\n        }\\n    })\\n    .map(elem => elem.val);\\n```"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Done"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "I have been trying to get this question done with binary search in order to reduce the time and space complexity and even tho the logic works on paper with multiple test cases, my array keeps returning as it is. please check and let me know my mistake..\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int count=0;\\n        int s;\\n        int end;\\n        int  mid=(s+end)/2;\\n        for(s=1;end<nums.size()-1;end--)\\n        {\\n            if(count==n)\\n            {\\n                break;\\n            }\\n            mid=(s+end)/2;\\n            swap(mid,end);\\n            count++;\\n            \\n        }\\n        swap(s,mid);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "user2094wl",
                        "content": "I dont know about the time and space complexity, can anyone tell me?\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[2*n];\\n        int a = n;\\n        for(int i=0; i<2*n; i++){\\n            if(i%2==0){\\n                newArr[i] = nums[i/2];\\n            }else{\\n                newArr[i] = nums[a];\\n                a++;\\n            }\\n        }\\n        return newArr;\\n    }\\n}"
                    },
                    {
                        "username": "vivekchau123",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>v;\\n        int count=0 , off=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                v.push_back(nums[count]);\\n                count++;\\n            }\\n            else{\\n                v.push_back(nums[n+off]);\\n                off++;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "sonu36437",
                        "content": "use two pointer approach as the hint is given :\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int newarray[]=new int[2*n];\\n        int xpart=0;\\n        int ypart =n;\\n        int i=0;\\n        while(i<=2*n-1){\\n            newarray[i]=nums[xpart];\\n            i++;\\n            xpart++;\\n            newarray[i]=nums[ypart];\\n            ypart++;\\n            i++;\\n\\n\\n        } \\n        return newarray;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "chrihop",
                        "content": "Could someone write an answer with O(1) space complexity and O(n) time complexity?\\n"
                    }
                ]
            },
            {
                "id": 1789809,
                "content": [
                    {
                        "username": "TsuruLee",
                        "content": "nice problem to practice your new programming language."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": " This is the first problem where I would say: Do not give the optimal solution in an interview. There is NO WAY that someone could just \"problem solve\" their way to the constant space solution lmao. The interviewer will immediately know you\\'ve seen this before and just give you a different problem or mark you down as \"nuetral\""
                    },
                    {
                        "username": "rushi_4123",
                        "content": "3 days of EASY LeetCode!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "is there any algo to do it inplace??\\n"
                    },
                    {
                        "username": "oliverdowling",
                        "content": "You could do it with an in-place sort, based on the original indexes. JavaScript doesn\\'t have the index or actually sort in-place, but here is a working solution that demonstrates the idea:\\n\\n```javascript\\nreturn nums\\n    .map((val, index) => new Object({ val, index }))\\n    .sort((first, second) => {\\n        if (first.index >= n) {\\n            if (second.index >= n) return first.index - second.index;\\n            else return (first.index - n) - second.index;\\n        } else {\\n            if (second.index >= n) return first.index - (second.index - n);\\n            else return first.index - second.index;\\n        }\\n    })\\n    .map(elem => elem.val);\\n```"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Done"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "I have been trying to get this question done with binary search in order to reduce the time and space complexity and even tho the logic works on paper with multiple test cases, my array keeps returning as it is. please check and let me know my mistake..\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int count=0;\\n        int s;\\n        int end;\\n        int  mid=(s+end)/2;\\n        for(s=1;end<nums.size()-1;end--)\\n        {\\n            if(count==n)\\n            {\\n                break;\\n            }\\n            mid=(s+end)/2;\\n            swap(mid,end);\\n            count++;\\n            \\n        }\\n        swap(s,mid);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "user2094wl",
                        "content": "I dont know about the time and space complexity, can anyone tell me?\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[2*n];\\n        int a = n;\\n        for(int i=0; i<2*n; i++){\\n            if(i%2==0){\\n                newArr[i] = nums[i/2];\\n            }else{\\n                newArr[i] = nums[a];\\n                a++;\\n            }\\n        }\\n        return newArr;\\n    }\\n}"
                    },
                    {
                        "username": "vivekchau123",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>v;\\n        int count=0 , off=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                v.push_back(nums[count]);\\n                count++;\\n            }\\n            else{\\n                v.push_back(nums[n+off]);\\n                off++;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "sonu36437",
                        "content": "use two pointer approach as the hint is given :\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int newarray[]=new int[2*n];\\n        int xpart=0;\\n        int ypart =n;\\n        int i=0;\\n        while(i<=2*n-1){\\n            newarray[i]=nums[xpart];\\n            i++;\\n            xpart++;\\n            newarray[i]=nums[ypart];\\n            ypart++;\\n            i++;\\n\\n\\n        } \\n        return newarray;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "chrihop",
                        "content": "Could someone write an answer with O(1) space complexity and O(n) time complexity?\\n"
                    }
                ]
            },
            {
                "id": 1775038,
                "content": [
                    {
                        "username": "TsuruLee",
                        "content": "nice problem to practice your new programming language."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": " This is the first problem where I would say: Do not give the optimal solution in an interview. There is NO WAY that someone could just \"problem solve\" their way to the constant space solution lmao. The interviewer will immediately know you\\'ve seen this before and just give you a different problem or mark you down as \"nuetral\""
                    },
                    {
                        "username": "rushi_4123",
                        "content": "3 days of EASY LeetCode!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "is there any algo to do it inplace??\\n"
                    },
                    {
                        "username": "oliverdowling",
                        "content": "You could do it with an in-place sort, based on the original indexes. JavaScript doesn\\'t have the index or actually sort in-place, but here is a working solution that demonstrates the idea:\\n\\n```javascript\\nreturn nums\\n    .map((val, index) => new Object({ val, index }))\\n    .sort((first, second) => {\\n        if (first.index >= n) {\\n            if (second.index >= n) return first.index - second.index;\\n            else return (first.index - n) - second.index;\\n        } else {\\n            if (second.index >= n) return first.index - (second.index - n);\\n            else return first.index - second.index;\\n        }\\n    })\\n    .map(elem => elem.val);\\n```"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Done"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "I have been trying to get this question done with binary search in order to reduce the time and space complexity and even tho the logic works on paper with multiple test cases, my array keeps returning as it is. please check and let me know my mistake..\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int count=0;\\n        int s;\\n        int end;\\n        int  mid=(s+end)/2;\\n        for(s=1;end<nums.size()-1;end--)\\n        {\\n            if(count==n)\\n            {\\n                break;\\n            }\\n            mid=(s+end)/2;\\n            swap(mid,end);\\n            count++;\\n            \\n        }\\n        swap(s,mid);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "user2094wl",
                        "content": "I dont know about the time and space complexity, can anyone tell me?\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[2*n];\\n        int a = n;\\n        for(int i=0; i<2*n; i++){\\n            if(i%2==0){\\n                newArr[i] = nums[i/2];\\n            }else{\\n                newArr[i] = nums[a];\\n                a++;\\n            }\\n        }\\n        return newArr;\\n    }\\n}"
                    },
                    {
                        "username": "vivekchau123",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>v;\\n        int count=0 , off=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                v.push_back(nums[count]);\\n                count++;\\n            }\\n            else{\\n                v.push_back(nums[n+off]);\\n                off++;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "sonu36437",
                        "content": "use two pointer approach as the hint is given :\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int newarray[]=new int[2*n];\\n        int xpart=0;\\n        int ypart =n;\\n        int i=0;\\n        while(i<=2*n-1){\\n            newarray[i]=nums[xpart];\\n            i++;\\n            xpart++;\\n            newarray[i]=nums[ypart];\\n            ypart++;\\n            i++;\\n\\n\\n        } \\n        return newarray;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "chrihop",
                        "content": "Could someone write an answer with O(1) space complexity and O(n) time complexity?\\n"
                    }
                ]
            },
            {
                "id": 1770750,
                "content": [
                    {
                        "username": "TsuruLee",
                        "content": "nice problem to practice your new programming language."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": " This is the first problem where I would say: Do not give the optimal solution in an interview. There is NO WAY that someone could just \"problem solve\" their way to the constant space solution lmao. The interviewer will immediately know you\\'ve seen this before and just give you a different problem or mark you down as \"nuetral\""
                    },
                    {
                        "username": "rushi_4123",
                        "content": "3 days of EASY LeetCode!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "is there any algo to do it inplace??\\n"
                    },
                    {
                        "username": "oliverdowling",
                        "content": "You could do it with an in-place sort, based on the original indexes. JavaScript doesn\\'t have the index or actually sort in-place, but here is a working solution that demonstrates the idea:\\n\\n```javascript\\nreturn nums\\n    .map((val, index) => new Object({ val, index }))\\n    .sort((first, second) => {\\n        if (first.index >= n) {\\n            if (second.index >= n) return first.index - second.index;\\n            else return (first.index - n) - second.index;\\n        } else {\\n            if (second.index >= n) return first.index - (second.index - n);\\n            else return first.index - second.index;\\n        }\\n    })\\n    .map(elem => elem.val);\\n```"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Done"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "I have been trying to get this question done with binary search in order to reduce the time and space complexity and even tho the logic works on paper with multiple test cases, my array keeps returning as it is. please check and let me know my mistake..\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int count=0;\\n        int s;\\n        int end;\\n        int  mid=(s+end)/2;\\n        for(s=1;end<nums.size()-1;end--)\\n        {\\n            if(count==n)\\n            {\\n                break;\\n            }\\n            mid=(s+end)/2;\\n            swap(mid,end);\\n            count++;\\n            \\n        }\\n        swap(s,mid);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "user2094wl",
                        "content": "I dont know about the time and space complexity, can anyone tell me?\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[2*n];\\n        int a = n;\\n        for(int i=0; i<2*n; i++){\\n            if(i%2==0){\\n                newArr[i] = nums[i/2];\\n            }else{\\n                newArr[i] = nums[a];\\n                a++;\\n            }\\n        }\\n        return newArr;\\n    }\\n}"
                    },
                    {
                        "username": "vivekchau123",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>v;\\n        int count=0 , off=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                v.push_back(nums[count]);\\n                count++;\\n            }\\n            else{\\n                v.push_back(nums[n+off]);\\n                off++;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "sonu36437",
                        "content": "use two pointer approach as the hint is given :\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int newarray[]=new int[2*n];\\n        int xpart=0;\\n        int ypart =n;\\n        int i=0;\\n        while(i<=2*n-1){\\n            newarray[i]=nums[xpart];\\n            i++;\\n            xpart++;\\n            newarray[i]=nums[ypart];\\n            ypart++;\\n            i++;\\n\\n\\n        } \\n        return newarray;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "chrihop",
                        "content": "Could someone write an answer with O(1) space complexity and O(n) time complexity?\\n"
                    }
                ]
            },
            {
                "id": 1752275,
                "content": [
                    {
                        "username": "TsuruLee",
                        "content": "nice problem to practice your new programming language."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": " This is the first problem where I would say: Do not give the optimal solution in an interview. There is NO WAY that someone could just \"problem solve\" their way to the constant space solution lmao. The interviewer will immediately know you\\'ve seen this before and just give you a different problem or mark you down as \"nuetral\""
                    },
                    {
                        "username": "rushi_4123",
                        "content": "3 days of EASY LeetCode!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "is there any algo to do it inplace??\\n"
                    },
                    {
                        "username": "oliverdowling",
                        "content": "You could do it with an in-place sort, based on the original indexes. JavaScript doesn\\'t have the index or actually sort in-place, but here is a working solution that demonstrates the idea:\\n\\n```javascript\\nreturn nums\\n    .map((val, index) => new Object({ val, index }))\\n    .sort((first, second) => {\\n        if (first.index >= n) {\\n            if (second.index >= n) return first.index - second.index;\\n            else return (first.index - n) - second.index;\\n        } else {\\n            if (second.index >= n) return first.index - (second.index - n);\\n            else return first.index - second.index;\\n        }\\n    })\\n    .map(elem => elem.val);\\n```"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Done"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "I have been trying to get this question done with binary search in order to reduce the time and space complexity and even tho the logic works on paper with multiple test cases, my array keeps returning as it is. please check and let me know my mistake..\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int count=0;\\n        int s;\\n        int end;\\n        int  mid=(s+end)/2;\\n        for(s=1;end<nums.size()-1;end--)\\n        {\\n            if(count==n)\\n            {\\n                break;\\n            }\\n            mid=(s+end)/2;\\n            swap(mid,end);\\n            count++;\\n            \\n        }\\n        swap(s,mid);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "user2094wl",
                        "content": "I dont know about the time and space complexity, can anyone tell me?\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[2*n];\\n        int a = n;\\n        for(int i=0; i<2*n; i++){\\n            if(i%2==0){\\n                newArr[i] = nums[i/2];\\n            }else{\\n                newArr[i] = nums[a];\\n                a++;\\n            }\\n        }\\n        return newArr;\\n    }\\n}"
                    },
                    {
                        "username": "vivekchau123",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>v;\\n        int count=0 , off=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                v.push_back(nums[count]);\\n                count++;\\n            }\\n            else{\\n                v.push_back(nums[n+off]);\\n                off++;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "sonu36437",
                        "content": "use two pointer approach as the hint is given :\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int newarray[]=new int[2*n];\\n        int xpart=0;\\n        int ypart =n;\\n        int i=0;\\n        while(i<=2*n-1){\\n            newarray[i]=nums[xpart];\\n            i++;\\n            xpart++;\\n            newarray[i]=nums[ypart];\\n            ypart++;\\n            i++;\\n\\n\\n        } \\n        return newarray;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "chrihop",
                        "content": "Could someone write an answer with O(1) space complexity and O(n) time complexity?\\n"
                    }
                ]
            },
            {
                "id": 1727197,
                "content": [
                    {
                        "username": "TsuruLee",
                        "content": "nice problem to practice your new programming language."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": " This is the first problem where I would say: Do not give the optimal solution in an interview. There is NO WAY that someone could just \"problem solve\" their way to the constant space solution lmao. The interviewer will immediately know you\\'ve seen this before and just give you a different problem or mark you down as \"nuetral\""
                    },
                    {
                        "username": "rushi_4123",
                        "content": "3 days of EASY LeetCode!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "is there any algo to do it inplace??\\n"
                    },
                    {
                        "username": "oliverdowling",
                        "content": "You could do it with an in-place sort, based on the original indexes. JavaScript doesn\\'t have the index or actually sort in-place, but here is a working solution that demonstrates the idea:\\n\\n```javascript\\nreturn nums\\n    .map((val, index) => new Object({ val, index }))\\n    .sort((first, second) => {\\n        if (first.index >= n) {\\n            if (second.index >= n) return first.index - second.index;\\n            else return (first.index - n) - second.index;\\n        } else {\\n            if (second.index >= n) return first.index - (second.index - n);\\n            else return first.index - second.index;\\n        }\\n    })\\n    .map(elem => elem.val);\\n```"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Done"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "I have been trying to get this question done with binary search in order to reduce the time and space complexity and even tho the logic works on paper with multiple test cases, my array keeps returning as it is. please check and let me know my mistake..\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int count=0;\\n        int s;\\n        int end;\\n        int  mid=(s+end)/2;\\n        for(s=1;end<nums.size()-1;end--)\\n        {\\n            if(count==n)\\n            {\\n                break;\\n            }\\n            mid=(s+end)/2;\\n            swap(mid,end);\\n            count++;\\n            \\n        }\\n        swap(s,mid);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "user2094wl",
                        "content": "I dont know about the time and space complexity, can anyone tell me?\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[2*n];\\n        int a = n;\\n        for(int i=0; i<2*n; i++){\\n            if(i%2==0){\\n                newArr[i] = nums[i/2];\\n            }else{\\n                newArr[i] = nums[a];\\n                a++;\\n            }\\n        }\\n        return newArr;\\n    }\\n}"
                    },
                    {
                        "username": "vivekchau123",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>v;\\n        int count=0 , off=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                v.push_back(nums[count]);\\n                count++;\\n            }\\n            else{\\n                v.push_back(nums[n+off]);\\n                off++;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "sonu36437",
                        "content": "use two pointer approach as the hint is given :\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int newarray[]=new int[2*n];\\n        int xpart=0;\\n        int ypart =n;\\n        int i=0;\\n        while(i<=2*n-1){\\n            newarray[i]=nums[xpart];\\n            i++;\\n            xpart++;\\n            newarray[i]=nums[ypart];\\n            ypart++;\\n            i++;\\n\\n\\n        } \\n        return newarray;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "chrihop",
                        "content": "Could someone write an answer with O(1) space complexity and O(n) time complexity?\\n"
                    }
                ]
            },
            {
                "id": 1722989,
                "content": [
                    {
                        "username": "TsuruLee",
                        "content": "nice problem to practice your new programming language."
                    },
                    {
                        "username": "aleckerrigan",
                        "content": " This is the first problem where I would say: Do not give the optimal solution in an interview. There is NO WAY that someone could just \"problem solve\" their way to the constant space solution lmao. The interviewer will immediately know you\\'ve seen this before and just give you a different problem or mark you down as \"nuetral\""
                    },
                    {
                        "username": "rushi_4123",
                        "content": "3 days of EASY LeetCode!!"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "is there any algo to do it inplace??\\n"
                    },
                    {
                        "username": "oliverdowling",
                        "content": "You could do it with an in-place sort, based on the original indexes. JavaScript doesn\\'t have the index or actually sort in-place, but here is a working solution that demonstrates the idea:\\n\\n```javascript\\nreturn nums\\n    .map((val, index) => new Object({ val, index }))\\n    .sort((first, second) => {\\n        if (first.index >= n) {\\n            if (second.index >= n) return first.index - second.index;\\n            else return (first.index - n) - second.index;\\n        } else {\\n            if (second.index >= n) return first.index - (second.index - n);\\n            else return first.index - second.index;\\n        }\\n    })\\n    .map(elem => elem.val);\\n```"
                    },
                    {
                        "username": "cecilia5",
                        "content": "Done"
                    },
                    {
                        "username": "Nitkapur30",
                        "content": "I have been trying to get this question done with binary search in order to reduce the time and space complexity and even tho the logic works on paper with multiple test cases, my array keeps returning as it is. please check and let me know my mistake..\\nclass Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        int count=0;\\n        int s;\\n        int end;\\n        int  mid=(s+end)/2;\\n        for(s=1;end<nums.size()-1;end--)\\n        {\\n            if(count==n)\\n            {\\n                break;\\n            }\\n            mid=(s+end)/2;\\n            swap(mid,end);\\n            count++;\\n            \\n        }\\n        swap(s,mid);\\n        return nums;\\n    }\\n};"
                    },
                    {
                        "username": "user2094wl",
                        "content": "I dont know about the time and space complexity, can anyone tell me?\\n\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int[] newArr = new int[2*n];\\n        int a = n;\\n        for(int i=0; i<2*n; i++){\\n            if(i%2==0){\\n                newArr[i] = nums[i/2];\\n            }else{\\n                newArr[i] = nums[a];\\n                a++;\\n            }\\n        }\\n        return newArr;\\n    }\\n}"
                    },
                    {
                        "username": "vivekchau123",
                        "content": "class Solution {\\npublic:\\n    vector<int> shuffle(vector<int>& nums, int n) {\\n        vector<int>v;\\n        int count=0 , off=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(i%2==0){\\n                v.push_back(nums[count]);\\n                count++;\\n            }\\n            else{\\n                v.push_back(nums[n+off]);\\n                off++;\\n            }\\n        }\\n        return v;\\n    }\\n};"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "sonu36437",
                        "content": "use two pointer approach as the hint is given :\\nclass Solution {\\n    public int[] shuffle(int[] nums, int n) {\\n        int newarray[]=new int[2*n];\\n        int xpart=0;\\n        int ypart =n;\\n        int i=0;\\n        while(i<=2*n-1){\\n            newarray[i]=nums[xpart];\\n            i++;\\n            xpart++;\\n            newarray[i]=nums[ypart];\\n            ypart++;\\n            i++;\\n\\n\\n        } \\n        return newarray;\\n        \\n    }\\n}"
                    },
                    {
                        "username": "haibrenner",
                        "content": "No solutions in the discussion section!"
                    },
                    {
                        "username": "chrihop",
                        "content": "Could someone write an answer with O(1) space complexity and O(n) time complexity?\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Ice Cream Bars",
        "question_content": "<p>It is a sweltering summer day, and a boy wants to buy some ice cream bars.</p>\n\n<p>At the store, there are <code>n</code> ice cream bars. You are given an array <code>costs</code> of length <code>n</code>, where <code>costs[i]</code> is the price of the <code>i<sup>th</sup></code> ice cream bar in coins. The boy initially has <code>coins</code> coins to spend, and he wants to buy as many ice cream bars as possible.&nbsp;</p>\n\n<p><strong>Note:</strong> The boy can buy the ice cream bars in any order.</p>\n\n<p>Return <em>the <strong>maximum</strong> number of ice cream bars the boy can buy with </em><code>coins</code><em> coins.</em></p>\n\n<p>You must solve the problem by counting sort.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> costs = [1,3,2,4,1], coins = 7\n<strong>Output:</strong> 4\n<strong>Explanation: </strong>The boy can buy ice cream bars at indices 0,1,2,4 for a total price of 1 + 3 + 2 + 1 = 7.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> costs = [10,6,8,7,7,8], coins = 5\n<strong>Output:</strong> 0\n<strong>Explanation: </strong>The boy cannot afford any of the ice cream bars.\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> costs = [1,6,3,1,2,5], coins = 20\n<strong>Output:</strong> 6\n<strong>Explanation: </strong>The boy can buy all the ice cream bars for a total price of 1 + 6 + 3 + 1 + 2 + 5 = 18.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>costs.length == n</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= costs[i] &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= coins &lt;= 10<sup>8</sup></code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 3006299,
                "title": "3-java-codes-with-explanation",
                "content": "## ******If you find it useful please upvote it means a lot to me \\uD83D\\uDE0A******\\n# Approach 1 (Greedy)\\n\\n![Greedy Approach.png](https://assets.leetcode.com/users/images/48b84f68-f897-46cf-9ad0-81f4e48b3881_1672982508.7633991.png)\\n\\n# Code \\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        // Store ice cream costs in increasing order.\\n        Arrays.sort(costs);\\n        int n = costs.length;\\n        int answer = 0;\\n        // Pick ice creams till we can.\\n        while (answer < n && costs[answer] <= coins) {\\n            // We can buy this icecream, reduce the cost from the coins. \\n            coins -= costs[answer];\\n            answer += 1;\\n        }\\n        return answer;\\n    }\\n}\\n```\\n\\n# Approach 2 (Bucket Sort)\\n![Bucket Sort.png](https://assets.leetcode.com/users/images/4fec0b2f-b2cc-4c5d-a10f-5c66b5006b31_1672982822.273559.png)\\n# Code \\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        \\n        // get the maximum cost available\\n        int max = costs[0];\\n        for (int i = 0; i < costs.length; i++) {\\n            max = Math.max(costs[i], max);\\n        }\\n        // create the bucket array of size of maximum_cost + 1\\n            // and keep the frequencies of the cost\\n        int[] buckets = new int[max + 1];\\n        for (int p : costs) {\\n            buckets[p]++;\\n        }\\n\\n        // keep the track of maximum ice-creams can be bought\\n        int ans = 0;\\n        for (int i = 0; i < buckets.length; i++) {\\n            if (coins < i) {\\n                break;\\n            }\\n            if (buckets[i] > 0) {\\n                ans += Math.min(buckets[i], coins/i);\\n                coins -= Math.min(coins, i * buckets[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n# Approach 3 (DP)\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int maxc = 0;\\n\\n        for(int i = 0; i < costs.length; i++){\\n            if(costs[i] > maxc){\\n                maxc = costs[i];\\n            }\\n        }\\n\\n        int[] cc = new int[maxc + 1];\\n\\n        for(int i = 0; i < costs.length; i++){\\n            cc[costs[i]]++;\\n        }\\n\\n        int c = 0;\\n\\n        for(int i = 1; i <= maxc; i++){\\n            if(cc[i] == 0){\\n                continue;\\n            }\\n            if(coins < i){\\n                break;\\n            }\\n\\n            for(int j = 0; j < cc[i]; j++){\\n                if(coins >= i){\\n                    coins -= i;\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```\\nPhoto Explanation Credit : Aditya Shidlyali\\nMake sure to Vote up to keep me motivated\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        // Store ice cream costs in increasing order.\\n        Arrays.sort(costs);\\n        int n = costs.length;\\n        int answer = 0;\\n        // Pick ice creams till we can.\\n        while (answer < n && costs[answer] <= coins) {\\n            // We can buy this icecream, reduce the cost from the coins. \\n            coins -= costs[answer];\\n            answer += 1;\\n        }\\n        return answer;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        \\n        // get the maximum cost available\\n        int max = costs[0];\\n        for (int i = 0; i < costs.length; i++) {\\n            max = Math.max(costs[i], max);\\n        }\\n        // create the bucket array of size of maximum_cost + 1\\n            // and keep the frequencies of the cost\\n        int[] buckets = new int[max + 1];\\n        for (int p : costs) {\\n            buckets[p]++;\\n        }\\n\\n        // keep the track of maximum ice-creams can be bought\\n        int ans = 0;\\n        for (int i = 0; i < buckets.length; i++) {\\n            if (coins < i) {\\n                break;\\n            }\\n            if (buckets[i] > 0) {\\n                ans += Math.min(buckets[i], coins/i);\\n                coins -= Math.min(coins, i * buckets[i]);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int maxc = 0;\\n\\n        for(int i = 0; i < costs.length; i++){\\n            if(costs[i] > maxc){\\n                maxc = costs[i];\\n            }\\n        }\\n\\n        int[] cc = new int[maxc + 1];\\n\\n        for(int i = 0; i < costs.length; i++){\\n            cc[costs[i]]++;\\n        }\\n\\n        int c = 0;\\n\\n        for(int i = 1; i <= maxc; i++){\\n            if(cc[i] == 0){\\n                continue;\\n            }\\n            if(coins < i){\\n                break;\\n            }\\n\\n            for(int j = 0; j < cc[i]; j++){\\n                if(coins >= i){\\n                    coins -= i;\\n                    c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005153,
                "title": "python3-greedy-approach-explained",
                "content": "**Intuition:**\\nYou are poor but a very kind person, you adopted many dogs, you need to feed them to keep them alive. How would you chose the dog food to buy? A common sense would be buy the cheapest one, and buy as many as you can with the mony you have. So you need to first sort the products by their price, then greedily buy as much as you can until you can\\'t afford.\\n\\n**Algortihm:**\\n - Sort ```costs```.\\n - For each price, simply buy it (increase the result) if ```price <= coins```.\\n - Don\\'t look farther if you can\\'t even afford the current price, because it will be more expensive (```costs``` is sorted).\\n\\n**Time Complexity: O(NlogN)** because of sorting.\\n\\n**Solution 1:**\\n```python\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        \\n        costs.sort()\\n        res = 0\\n        for price in costs:\\n            if price<=coins:\\n                res += 1\\n                coins -= price\\n            else:\\n                break\\n        return res\\n```\\n\\n**Solution 2:** using bucket sort to bring the **Time Complexity** to **O(N)**, bucket sort is good in this problem because of the constraints: 1 <= n <= 10^5 and 1 <= costs[i] <= 10^5\\n\\n```python\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        buckets = [0] * (max(costs)+1)\\n        for p in costs:\\n            buckets[p] += 1\\n        \\n        res = 0\\n        for price, count in enumerate(buckets):\\n            if coins < price:\\n                break\\n            if count > 0:\\n                res += min(count, coins//price)\\n                coins -= min(coins, price * count)\\n        return res\\n```\\n\\n**Solution 3:** One-liner from [soyel](https://leetcode.com/problems/maximum-ice-cream-bars/discuss/1181373/python-one-liner)\\n```python\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        return sum(1 for ice in sorted(costs) if (coins:= coins-ice) >= 0)\\n```\\n\\n**Upvote** if you like this post.\\n\\n**Connect with me on [LinkedIn](https://www.linkedin.com/in/meida-chen-938a265b/)** if you\\'d like to discuss other related topics\\n\\nJust in case if you are working on **ML/DL 3D data-related projects** or are interested in the topic, please check out our project **[HERE](https://github.com/meidachen/STPLS3D)**",
                "solutionTags": [],
                "code": "```costs```\n```price <= coins```\n```costs```\n```python\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        \\n        costs.sort()\\n        res = 0\\n        for price in costs:\\n            if price<=coins:\\n                res += 1\\n                coins -= price\\n            else:\\n                break\\n        return res\\n```\n```python\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        buckets = [0] * (max(costs)+1)\\n        for p in costs:\\n            buckets[p] += 1\\n        \\n        res = 0\\n        for price, count in enumerate(buckets):\\n            if coins < price:\\n                break\\n            if count > 0:\\n                res += min(count, coins//price)\\n                coins -= min(coins, price * count)\\n        return res\\n```\n```python\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        return sum(1 for ice in sorted(costs) if (coins:= coins-ice) >= 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005121,
                "title": "c-greedy-approach-beats-100-solution",
                "content": "# Intuition\\nTo buy maximum number of Ice Creams you should start buying with cheapest cost.\\n\\n# Approach\\nsort the costs in ascending order and then count the ice cream until the current costs is greater than remaining coins.\\n\\n# Complexity\\n- Time complexity:\\nO(nlog(n))\\n\\n- Space complexity:\\n O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int count = 0;\\n        sort(costs.begin(),costs.end());\\n        for(int i=0;i<costs.size();i++){\\n            if(costs[i]>coins)break;\\n            coins -= costs[i];\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int count = 0;\\n        sort(costs.begin(),costs.end());\\n        for(int i=0;i<costs.size();i++){\\n            if(costs[i]>coins)break;\\n            coins -= costs[i];\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164058,
                "title": "c-java-greedy",
                "content": "Buy the cheapest bar, repeat until you cannot buy anymore: not enough coins or you\\'ve bought all bars.\\n\\n**C++**\\n```cpp\\nint maxIceCream(vector<int>& costs, int coins) {\\n    sort(begin(costs), end(costs));\\n    for (int i = 0; i < costs.size(); ++i)\\n        if (coins >= costs[i])\\n            coins -= costs[i];\\n        else\\n            return i;\\n    return costs.size();\\n}\\n```\\n**Java**\\n```java\\npublic int maxIceCream(int[] costs, int coins) {\\n    Arrays.sort(costs);\\n    for (int i = 0; i < costs.length; ++i)\\n        if (coins >= costs[i])\\n            coins -= costs[i];\\n        else\\n            return i;\\n    return costs.length;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint maxIceCream(vector<int>& costs, int coins) {\\n    sort(begin(costs), end(costs));\\n    for (int i = 0; i < costs.size(); ++i)\\n        if (coins >= costs[i])\\n            coins -= costs[i];\\n        else\\n            return i;\\n    return costs.size();\\n}\\n```\n```java\\npublic int maxIceCream(int[] costs, int coins) {\\n    Arrays.sort(costs);\\n    for (int i = 0; i < costs.length; ++i)\\n        if (coins >= costs[i])\\n            coins -= costs[i];\\n        else\\n            return i;\\n    return costs.length;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3006334,
                "title": "java-solution-with-comments",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    // This function finds the maximum number of ice cream cones\\n    // that can be bought with the given amount of money.\\n    public int maxIceCream(int[] costs, int coins) {\\n        // Sort the costs in ascending order.\\n        Arrays.sort(costs);\\n        \\n        // Initialize the answer to 0 and the index to 0.\\n        int answer = 0, i = 0;\\n        \\n        // Loop while we can still afford to buy more ice cream cones.\\n        while(i < costs.length && coins >= costs[i]){\\n            // Reduce the amount of money we have left by the cost of the current ice cream cone.\\n            coins -= costs[i];\\n            // Increment the number of ice cream cones bought.\\n            answer++;\\n            // Move on to the next ice cream cone.\\n            i++;\\n        }\\n        \\n        // Return the final answer.\\n        return answer;\\n    }\\n}\\n```\\n```\\n\\n\\nclass Solution {\\n// This method takes an array of ice cream costs and an amount of coins as input\\n// and returns the maximum number of ice creams that can be bought with the given coins\\npublic int maxIceCream(int[] costs, int coins) {\\n    // Initialize an array \"count\" to store the frequency of each cost in the input array\\n    int[] count = new int[100001];\\n    // Iterate through the input array and increment the count of each cost\\n    for(int i = 0 ; i < costs.length ; i++){ \\n         count[costs[i]]++;\\n    }\\n    // Initialize the answer (number of ice creams bought) to 0\\n    int answer = 0;\\n    // Iterate through the count array and try to buy as many ice creams of each cost as possible\\n    \\n    for(int i = 1 ; i < 100001 ; i++) {\\n        // If there are ice creams of this cost available\\n        if(count[i] > 0) {\\n            // Calculate the maximum number of ice creams of this cost that can be bought\\n            //if coins are sufficient to buy all the ice cream at ith index then we can buy all the ice cream at ith index else we can only buy coins / i ice cream\\n            int use = Math.min(coins / i, count[i]);\\n            // Subtract the cost of the ice creams from the coins\\n            coins -= use * i;\\n            // Add the number of ice creams bought to the answer\\n            answer += use;\\n        }\\n    }\\n    // Return the final answer\\n    return answer;\\n}\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    // This function finds the maximum number of ice cream cones\\n    // that can be bought with the given amount of money.\\n    public int maxIceCream(int[] costs, int coins) {\\n        // Sort the costs in ascending order.\\n        Arrays.sort(costs);\\n        \\n        // Initialize the answer to 0 and the index to 0.\\n        int answer = 0, i = 0;\\n        \\n        // Loop while we can still afford to buy more ice cream cones.\\n        while(i < costs.length && coins >= costs[i]){\\n            // Reduce the amount of money we have left by the cost of the current ice cream cone.\\n            coins -= costs[i];\\n            // Increment the number of ice cream cones bought.\\n            answer++;\\n            // Move on to the next ice cream cone.\\n            i++;\\n        }\\n        \\n        // Return the final answer.\\n        return answer;\\n    }\\n}\\n```\n```\\n\\n\\nclass Solution {\\n// This method takes an array of ice cream costs and an amount of coins as input\\n// and returns the maximum number of ice creams that can be bought with the given coins\\npublic int maxIceCream(int[] costs, int coins) {\\n    // Initialize an array \"count\" to store the frequency of each cost in the input array\\n    int[] count = new int[100001];\\n    // Iterate through the input array and increment the count of each cost\\n    for(int i = 0 ; i < costs.length ; i++){ \\n         count[costs[i]]++;\\n    }\\n    // Initialize the answer (number of ice creams bought) to 0\\n    int answer = 0;\\n    // Iterate through the count array and try to buy as many ice creams of each cost as possible\\n    \\n    for(int i = 1 ; i < 100001 ; i++) {\\n        // If there are ice creams of this cost available\\n        if(count[i] > 0) {\\n            // Calculate the maximum number of ice creams of this cost that can be bought\\n            //if coins are sufficient to buy all the ice cream at ith index then we can buy all the ice cream at ith index else we can only buy coins / i ice cream\\n            int use = Math.min(coins / i, count[i]);\\n            // Subtract the cost of the ice creams from the coins\\n            coins -= use * i;\\n            // Add the number of ice creams bought to the answer\\n            answer += use;\\n        }\\n    }\\n    // Return the final answer\\n    return answer;\\n}\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164029,
                "title": "java-c-python-sort-soluiton",
                "content": "# **Explanation**\\nSort the cost array `A`.\\nIterate `A[i]` from the small to big,\\nand update `coins -= A[i]`.\\nIf `coin < 0`, we don\\'t have enough for this ice cream bar,\\nand we have bought `i` ice cream bars before this one,\\nso we return the result `i`.\\n\\nIf we finish the loop,\\nit means we can buy all ice cream bars,\\nreturn the lenght of `A`.\\n<br>\\n\\n# **Complexity**\\nTime `O(sort)`\\nSpace `O(sort)`\\n<br>\\n\\n**Java**\\n```java\\n    public int maxIceCream(int[] A, int coins) {\\n        Arrays.sort(A);\\n        for (int i = 0; i < A.length; ++i)\\n            if ((coins -= A[i]) < 0)\\n                return i;\\n        return A.length;\\n    }\\n```\\n\\n**C++**\\n```cpp\\n    int maxIceCream(vector<int>& A, int coins) {\\n        sort(A.begin(), A.end());\\n        for (int i = 0; i < A.size(); ++i)\\n            if ((coins -= A[i]) < 0)\\n                return i;\\n        return A.size();\\n    }\\n```\\n\\n**Python**\\n```py\\n    def maxIceCream(self, A, coins):\\n        A.sort()\\n        for i, a in enumerate(A):\\n            coins -= a\\n            if coins < 0:\\n                return i\\n        return len(A)\\n```\\n",
                "solutionTags": [],
                "code": "```java\\n    public int maxIceCream(int[] A, int coins) {\\n        Arrays.sort(A);\\n        for (int i = 0; i < A.length; ++i)\\n            if ((coins -= A[i]) < 0)\\n                return i;\\n        return A.length;\\n    }\\n```\n```cpp\\n    int maxIceCream(vector<int>& A, int coins) {\\n        sort(A.begin(), A.end());\\n        for (int i = 0; i < A.size(); ++i)\\n            if ((coins -= A[i]) < 0)\\n                return i;\\n        return A.size();\\n    }\\n```\n```py\\n    def maxIceCream(self, A, coins):\\n        A.sort()\\n        for i, a in enumerate(A):\\n            coins -= a\\n            if coins < 0:\\n                return i\\n        return len(A)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3005195,
                "title": "c-short-and-easy-explained-with-comment",
                "content": "\\uD83C\\uDFA5\\uD83D\\uDD25 Exciting News! Join my Coding Journey! Subscribe Now! \\uD83D\\uDD25\\uD83C\\uDFA5\\n\\n\\uD83D\\uDD17 Link in the leetcode profile \\n\\nNew coding channel alert! \\uD83D\\uDE80\\uD83D\\uDCBB Subscribe to unlock amazing coding content and tutorials. Help me reach 1K subs to start posting more videos! Join now! \\uD83C\\uDF1F\\uD83D\\uDCAA\\n\\nThanks for your support! \\uD83D\\uDE4F\\n# Approach\\nwe want to by maximum number of Bar for that\\n- we will sort according low cost to high cost\\n- we will Buy the cheapest bar first because we want to maximize the answer\\n- repeat this process until we\\'ve not enough coins or we\\'ve bought all bars.\\n- if we can\\'t buy new bar will return our answer\\n- if we bought all bar then we will return size of costs\\n# Complexity\\n- Time complexity:O(NLogN)\\n- space complexity:O(1)\\n\\n# Code(C++)\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n    sort(costs.begin(),costs.end());\\n    int n=costs.size();\\n    for (int i = 0; i <n;i++)\\n    //we will check we can buy ice bar or not\\n        if (coins >= costs[i])\\n            coins -= costs[i];//update the coins value\\n        else\\n            return i;//we can\\'t purchase anymore so will return ans\\n    return n;\\n       }\\n};\\n```\\n***IF YOU LIKE THE SOLUTION PLEASE UPVOTE.***\\n# Code(JAVA)\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n     Arrays.sort(costs);\\n    int n=costs.length;\\n    for (int i = 0; i <n;i++)\\n    //we will check we can buy bar or not\\n        if (coins >= costs[i])\\n            coins -= costs[i];//update the coins value\\n        else\\n            return i;//we can\\'t purchase anymore\\n    return n; \\n    }\\n}\\n```\\n***If you really found my solution helpful please upvote it, as it motivates me to post such kind of codes and help the coding community, if you have some queries or some improvements please feel free to comment and share your views.***",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n    sort(costs.begin(),costs.end());\\n    int n=costs.size();\\n    for (int i = 0; i <n;i++)\\n    //we will check we can buy ice bar or not\\n        if (coins >= costs[i])\\n            coins -= costs[i];//update the coins value\\n        else\\n            return i;//we can\\'t purchase anymore so will return ans\\n    return n;\\n       }\\n};\\n```\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n     Arrays.sort(costs);\\n    int n=costs.length;\\n    for (int i = 0; i <n;i++)\\n    //we will check we can buy bar or not\\n        if (coins >= costs[i])\\n            coins -= costs[i];//update the coins value\\n        else\\n            return i;//we can\\'t purchase anymore\\n    return n; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006016,
                "title": "simplest-python-py",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        cn=0\\n        for i in sorted(costs):\\n            if i<=coins:\\n                cn+=1\\n                coins-=i\\n        return cn\\n```\\n![ alt text for screen readers](https://i.imgflip.com/2ly29v.jpg \"Text to show on mouseover\")",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        cn=0\\n        for i in sorted(costs):\\n            if i<=coins:\\n                cn+=1\\n                coins-=i\\n        return cn\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006098,
                "title": "java-o-n-easy",
                "content": "# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int [] arr = new int [100001];\\n        for(int x : costs)arr[x]++;\\n        int count = 0;\\n        int index = 1;\\n//If coins can buy all the ice-cream at ith index.\\n        while(index<100001 && coins>=index*arr[index]){\\n            coins-=index*arr[index];\\n            count+=arr[index];\\n            index++;\\n        }\\n//If coins can buy onyl some of the ice-creams at ith index.\\n        while(index<100001 && coins>=index){\\n            coins-=index;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n# Using priority Queue\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int sum = 0;\\n        for(int x : costs){\\n            if(sum<=coins){\\n                sum+=x;\\n                pq.add(x);\\n            }else if(pq.peek()>x){\\n                sum = sum - pq.poll() + x;\\n                pq.add(x);\\n            }\\n        }\\n        while(sum>coins){\\n            sum-=pq.poll();\\n        }\\n        return pq.size();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int [] arr = new int [100001];\\n        for(int x : costs)arr[x]++;\\n        int count = 0;\\n        int index = 1;\\n//If coins can buy all the ice-cream at ith index.\\n        while(index<100001 && coins>=index*arr[index]){\\n            coins-=index*arr[index];\\n            count+=arr[index];\\n            index++;\\n        }\\n//If coins can buy onyl some of the ice-creams at ith index.\\n        while(index<100001 && coins>=index){\\n            coins-=index;\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        PriorityQueue<Integer> pq = new PriorityQueue<Integer>(Collections.reverseOrder());\\n        int sum = 0;\\n        for(int x : costs){\\n            if(sum<=coins){\\n                sum+=x;\\n                pq.add(x);\\n            }else if(pq.peek()>x){\\n                sum = sum - pq.poll() + x;\\n                pq.add(x);\\n            }\\n        }\\n        while(sum>coins){\\n            sum-=pq.poll();\\n        }\\n        return pq.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164231,
                "title": "java-simple-and-easy-to-understand-solution-greedy-solution-clean-code-with-comments",
                "content": "**PLEASE UPVOTE IF YOU LIKE THIS SOLUTION**\\n\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        \\n        //Greedy Approach\\n        //a. sort cost in increasing order\\n        \\n        Arrays.sort(costs);\\n        \\n        int count = 0;\\n        for(int cost : costs){\\n            \\n            //b. check remainig coin is greater or equal than cuurent ice - cream cost\\n            if(coins - cost >= 0) {\\n                coins -= cost;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        \\n        //Greedy Approach\\n        //a. sort cost in increasing order\\n        \\n        Arrays.sort(costs);\\n        \\n        int count = 0;\\n        for(int cost : costs){\\n            \\n            //b. check remainig coin is greater or equal than cuurent ice - cream cost\\n            if(coins - cost >= 0) {\\n                coins -= cost;\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005858,
                "title": "c-solution-with-detailed-explanations",
                "content": "## Explanation:\\n\\n### Solution 01\\n\\n- First sort the array.\\n- Compare every element if coins are less or equal we\\u2019ll increase the count.\\n- Decrease coin value to the element & if the value is less than 0 return count.\\n- **Time complexity:** O(nlogn).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) \\n    {\\n        int cnt=0;\\n        sort(costs.begin(),costs.end());\\n\\n        for(int i=0; i<costs.size(); i++)\\n        {\\n            if(costs[i]<=coins)\\n            {\\n                cnt++;\\n                coins=coins-costs[i];\\n            }\\n\\t\\t\\t\\t\\t\\tif(coins<=0)\\n\\t\\t\\t\\t\\t\\t\\t\\treturn cnt;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) \\n    {\\n        int cnt=0;\\n        sort(costs.begin(),costs.end());\\n\\n        for(int i=0; i<costs.size(); i++)\\n        {\\n            if(costs[i]<=coins)\\n            {\\n                cnt++;\\n                coins=coins-costs[i];\\n            }\\n\\t\\t\\t\\t\\t\\tif(coins<=0)\\n\\t\\t\\t\\t\\t\\t\\t\\treturn cnt;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005307,
                "title": "simple-recursive-and-greedy-approach-c",
                "content": "# Intuition\\n1. Simple we have two choices at a particular instance either to take the item or leave it .\\n2. Greedy approach is simple that we sort it and then keep on adding untill we can.\\n\\n# Approach\\n### Recursive \\n1. sort the costs , then simply at a particular instance you can either take or leave the value according to your coins.\\n### Greedy\\n1. Run a loop for 0 to n and keep adding the values until they are smaller than your available coins and keep incrementing count.\\n\\n# Complexity\\n### Recursive \\n- Time complexity:  O(NLogN)\\n- Space complexity: O(N)\\n### Greedy\\n- Time complexity:  O(NLogN)\\n- Space complexity: O(1)\\n\\n# Recursive Code\\n```\\nclass Solution {\\npublic:\\n    int dfs(vector<int>& dp,vector<int>& nums , int coins , int i , int n){\\n        if(coins <= 0){\\n            return 0;\\n        }\\n        if(i == n-1){\\n            if(nums[i] <= coins){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int can = 0 , cant = 0;\\n        if(nums[i] <= coins){\\n            can = 1 + dfs(dp , nums , coins - nums[i] , i + 1 , n);\\n        }\\n        cant = dfs(dp , nums , coins , i + 1 , n);\\n        return dp[i] = max(can , cant);\\n    }\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        vector<int> dp(n+1 , -1);\\n        sort(costs.begin() , costs.end());\\n        return dfs(dp , costs , coins , 0 , n);\\n    }\\n};\\n```\\n# Greedy Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin() , costs.end());\\n        int ans = 0 , n = costs.size();\\n        for(int i = 0 ; i < n ; i++){\\n            if(costs[i] <= coins){\\n                ans++;\\n                coins -= costs[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(vector<int>& dp,vector<int>& nums , int coins , int i , int n){\\n        if(coins <= 0){\\n            return 0;\\n        }\\n        if(i == n-1){\\n            if(nums[i] <= coins){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        if(dp[i] != -1){\\n            return dp[i];\\n        }\\n        int can = 0 , cant = 0;\\n        if(nums[i] <= coins){\\n            can = 1 + dfs(dp , nums , coins - nums[i] , i + 1 , n);\\n        }\\n        cant = dfs(dp , nums , coins , i + 1 , n);\\n        return dp[i] = max(can , cant);\\n    }\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        vector<int> dp(n+1 , -1);\\n        sort(costs.begin() , costs.end());\\n        return dfs(dp , costs , coins , 0 , n);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin() , costs.end());\\n        int ans = 0 , n = costs.size();\\n        for(int i = 0 ; i < n ; i++){\\n            if(costs[i] <= coins){\\n                ans++;\\n                coins -= costs[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1172865,
                "title": "deceivingly-greedy-a-special-case-of-the-0-1-knapsack-problem",
                "content": "**This is a special case of the 0/1 knapsack problem where the value of every item is uniform. In such a case, dynamic programming is simply time consuming. Sorting is clearly the better option.  Given the constraints of the question, dp would either have a complexity of O(NW) or O(NV), where W = maximum weight of the knapsack, and V is the total sum of all the values. This greedy solution is however simply O(Nlogn)**\\n```\\nint cmpFunc (const void * a, const void * b) \\n{\\n   return ( *(int*)a - *(int*)b );\\n}\\n\\nint maxIceCream(int* costs, int costsSize, int coins)\\n{\\n    qsort(costs, costsSize, sizeof(int), cmpFunc);\\n    int ans = 0, i;\\n    for(i = 0; i < costsSize; i++)\\n    {\\n        if(costs[i] > coins)\\n            return ans;\\n        ans += 1;\\n        coins -= costs[i];\\n    }\\n    return ans;\\n}\\n```\\n***This is however the modified knapsack formulation that will result in a TLE.***\\n```\\n// Inspired by the AtCoder Dynamic Programming stream by Errichto\\n// Change the dp table definition of a classical knapsack problem\\n// dp[i][j] stores the minimum number of coins required to buy exactly j bars upto index i\\n\\n#define INF 9999999\\nint max(int a, int b)\\n{\\n    return (a > b)? a : b;\\n}\\n\\nint min(int a, int b)\\n{\\n    return (a < b)? a : b;\\n}\\n\\nvoid fillArray(int* arr, int arrLength, int fill)\\n{\\n    int i;\\n    for(i = 0; i < arrLength; i++)\\n        arr[i] = fill;\\n    arr[0] = 0;\\n}\\n\\nvoid display(int** arr, int r, int c)\\n{\\n    int i, j;\\n    for(i = 0; i < r; i++)\\n    {\\n        for(j = 0; j < c; j++)\\n            printf(\"%d \", arr[i][j]);\\n        printf(\"\\\\n\");\\n    }\\n}\\n\\nint maxIceCream(int* costs, int costsSize, int coins)\\n{\\n    int** dp = (int**)malloc(sizeof(int*) * costsSize);\\n    int i, j;\\n    for(i = 0; i < costsSize; i++)\\n    {\\n        dp[i] = (int*)malloc(sizeof(int) * (costsSize + 1));\\n        fillArray(dp[i], costsSize + 1, INF);\\n    }\\n    \\n    // display(dp, costsSize, costsSize + 1);\\n    \\n    for(i = 0; i < costsSize; i++)\\n        for(j = 1; j <= costsSize; j++)\\n            if(i > 0)\\n                dp[i][j] = min(min(dp[i][j], dp[i - 1][j]), dp[i - 1][j - 1] + costs[i]);\\n            else\\n                dp[i][j] = (j == 1)? costs[0] : INF;\\n    // display(dp, costsSize, costsSize + 1);        \\n    int ans = 0;\\n    for(i = 0; i < costsSize; i++)\\n        for(j = 0; j <= costsSize; j++)\\n            if(dp[i][j] <= coins)\\n                ans = max(ans, j);\\n                \\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint cmpFunc (const void * a, const void * b) \\n{\\n   return ( *(int*)a - *(int*)b );\\n}\\n\\nint maxIceCream(int* costs, int costsSize, int coins)\\n{\\n    qsort(costs, costsSize, sizeof(int), cmpFunc);\\n    int ans = 0, i;\\n    for(i = 0; i < costsSize; i++)\\n    {\\n        if(costs[i] > coins)\\n            return ans;\\n        ans += 1;\\n        coins -= costs[i];\\n    }\\n    return ans;\\n}\\n```\n```\\n// Inspired by the AtCoder Dynamic Programming stream by Errichto\\n// Change the dp table definition of a classical knapsack problem\\n// dp[i][j] stores the minimum number of coins required to buy exactly j bars upto index i\\n\\n#define INF 9999999\\nint max(int a, int b)\\n{\\n    return (a > b)? a : b;\\n}\\n\\nint min(int a, int b)\\n{\\n    return (a < b)? a : b;\\n}\\n\\nvoid fillArray(int* arr, int arrLength, int fill)\\n{\\n    int i;\\n    for(i = 0; i < arrLength; i++)\\n        arr[i] = fill;\\n    arr[0] = 0;\\n}\\n\\nvoid display(int** arr, int r, int c)\\n{\\n    int i, j;\\n    for(i = 0; i < r; i++)\\n    {\\n        for(j = 0; j < c; j++)\\n            printf(\"%d \", arr[i][j]);\\n        printf(\"\\\\n\");\\n    }\\n}\\n\\nint maxIceCream(int* costs, int costsSize, int coins)\\n{\\n    int** dp = (int**)malloc(sizeof(int*) * costsSize);\\n    int i, j;\\n    for(i = 0; i < costsSize; i++)\\n    {\\n        dp[i] = (int*)malloc(sizeof(int) * (costsSize + 1));\\n        fillArray(dp[i], costsSize + 1, INF);\\n    }\\n    \\n    // display(dp, costsSize, costsSize + 1);\\n    \\n    for(i = 0; i < costsSize; i++)\\n        for(j = 1; j <= costsSize; j++)\\n            if(i > 0)\\n                dp[i][j] = min(min(dp[i][j], dp[i - 1][j]), dp[i - 1][j - 1] + costs[i]);\\n            else\\n                dp[i][j] = (j == 1)? costs[0] : INF;\\n    // display(dp, costsSize, costsSize + 1);        \\n    int ans = 0;\\n    for(i = 0; i < costsSize; i++)\\n        for(j = 0; j <= costsSize; j++)\\n            if(dp[i][j] <= coins)\\n                ans = max(ans, j);\\n                \\n    return ans;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009054,
                "title": "3-liner-code-fast-using-c",
                "content": "# Intuition\\nWe will increment the count after purchasing the cheapest ice cream available until coins are sufficient to buy the cheapest unpurchased ice-cream and decrement the value of coins by the amount of purchased ice-cream.\\n\\n# Approach\\n1. Sort the vector.\\n2. Purchase the cheapest ice-cream if coins>=cheapest, i.e. coins-cheapest>=0 and if true then decrement the coins as coins=coins-costs[i].\\n3. Repeat step 2 until the all the ice-purschased or coins are sufficient.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n logn): because of sorting.\\n\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        int ans=0;\\n        for(int i=0; i<costs.size(); i++){\\n            coins-=costs[i];\\n            if(coins>=0) ans++;\\n            else return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        int ans=0;\\n        for(int i=0; i<costs.size(); i++){\\n            coins-=costs[i];\\n            if(coins>=0) ans++;\\n            else return ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005125,
                "title": "c-java-c-python-explained-beats-100",
                "content": "## Logic\\n- To buy The maximum amount of icecream, we need to buy the cheapest ones first.\\n## Approach\\n1. Sort costs from cheapest to most expensive.\\n2. Buy the cheapest icecream & Update Coins `coins -= cost`\\n3. Repeat until ``coins <= 0`` OR all icecreams are bought.(\\u02F5 \\u0361\\xB0 \\u035C\\u0296 \\u0361\\xB0\\u02F5)\\n\\n[+] Update coins while comparing it with cost\\n\\n    instead of :\\n        coins -= costs[i]\\n        if(coins < 0) Break\\n    Do :\\n        if( (coins-= costs[i]) <0 ) Break\\n## Explained Code\\n```c++ []\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end()); // Sort Costs\\n\\n        for(int i=0 ;i<costs.size(); ++i)\\n            if( (coins-=costs[i])<0) //Update && check\\n                return i; \\n\\n        //if we still have coins after buying all the icecream :\\n        return costs.size(); \\n    }\\n```\\n```java []\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs); // Sort costs\\n\\n        for(int i=0 ;i<costs.length;++i)\\n            if( (coins-=costs[i])<0) // Update && check\\n                return i; \\n\\n        //if we still have coins after buying all the icecream :\\n        return costs.length;\\n    }\\n```\\n```C []\\nint comparator(const void *p, const void *q) // used in qsort\\n    {return (*(int*)p-*(int*)q);} \\n\\nint maxIceCream(int* costs, int size, int coins){\\n    qsort((void*)costs, size, sizeof(costs[0]), comparator);\\n\\n    for(int i=0 ;i<size; ++i)\\n        if((coins-=costs[i])<0) return i;\\n    return size;\\n}\\n```\\n```Python3 []\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        costs.sort()\\n        for i in range(len(costs)):\\n            coins -= costs[i] # Buy the ith iceream\\n            if coins < 0: # check if we can afford more\\n                return i\\n        #if we bought all icecreams and still got coins\\n        return len(costs)\\n```\\n```python []\\n    def maxIceCream(self, costs, coins):\\n        costs.sort()\\n        for i in range(len(costs)):\\n            coins -= costs[i] # Buy the ith iceream\\n            if coins < 0: # check if we can afford more\\n                return i\\n        #if we bought all icecreams and still got coins\\n        return len(costs)\\n```\\n## Raw Code\\n```c++ []\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end()); \\n        for(int i=0 ;i<costs.size(); ++i)\\n            if( (coins-=costs[i])<0) return i; \\n        return costs.size(); \\n    }\\n```\\n```java []\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        for(int i=0 ;i<costs.length;++i)\\n            if( (coins-=costs[i])<0) return i;\\n        return costs.length;\\n    }\\n```\\n```C []\\nint comparator(const void *p, const void *q)\\n    {return (*(int*)p-*(int*)q);} \\n\\nint maxIceCream(int* costs, int size, int coins){\\n    qsort((void*)costs, size, sizeof(costs[0]), comparator);\\n\\n    for(int i=0 ;i<size; ++i)\\n        if((coins-=costs[i])<0) return i;\\n    return size;\\n}\\n```\\n```Python3 []\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        costs.sort()\\n        for i in range(len(costs)):\\n            coins -= costs[i]\\n            if coins < 0: \\n                return i\\n        return len(costs)\\n```\\n```python []\\n    def maxIceCream(self, costs, coins):\\n        costs.sort()\\n        for i in range(len(costs)):\\n            coins -= costs[i]\\n            if coins < 0:\\n                return i\\n        return len(costs)\\n```\\nTime Complexity  : $$O(nlogn)$$\\nSpace Complexity : $$O(1)$$\\n\\n![image.png](https://assets.leetcode.com/users/images/7cfef8aa-bf42-46ee-adfb-235b332b943b_1672965329.7899134.png)\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "Greedy"
                ],
                "code": "```c++ []\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end()); // Sort Costs\\n\\n        for(int i=0 ;i<costs.size(); ++i)\\n            if( (coins-=costs[i])<0) //Update && check\\n                return i; \\n\\n        //if we still have coins after buying all the icecream :\\n        return costs.size(); \\n    }\\n```\n```java []\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs); // Sort costs\\n\\n        for(int i=0 ;i<costs.length;++i)\\n            if( (coins-=costs[i])<0) // Update && check\\n                return i; \\n\\n        //if we still have coins after buying all the icecream :\\n        return costs.length;\\n    }\\n```\n```C []\\nint comparator(const void *p, const void *q) // used in qsort\\n    {return (*(int*)p-*(int*)q);} \\n\\nint maxIceCream(int* costs, int size, int coins){\\n    qsort((void*)costs, size, sizeof(costs[0]), comparator);\\n\\n    for(int i=0 ;i<size; ++i)\\n        if((coins-=costs[i])<0) return i;\\n    return size;\\n}\\n```\n```Python3 []\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        costs.sort()\\n        for i in range(len(costs)):\\n            coins -= costs[i] # Buy the ith iceream\\n            if coins < 0: # check if we can afford more\\n                return i\\n        #if we bought all icecreams and still got coins\\n        return len(costs)\\n```\n```python []\\n    def maxIceCream(self, costs, coins):\\n        costs.sort()\\n        for i in range(len(costs)):\\n            coins -= costs[i] # Buy the ith iceream\\n            if coins < 0: # check if we can afford more\\n                return i\\n        #if we bought all icecreams and still got coins\\n        return len(costs)\\n```\n```c++ []\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end()); \\n        for(int i=0 ;i<costs.size(); ++i)\\n            if( (coins-=costs[i])<0) return i; \\n        return costs.size(); \\n    }\\n```\n```java []\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        for(int i=0 ;i<costs.length;++i)\\n            if( (coins-=costs[i])<0) return i;\\n        return costs.length;\\n    }\\n```\n```C []\\nint comparator(const void *p, const void *q)\\n    {return (*(int*)p-*(int*)q);} \\n\\nint maxIceCream(int* costs, int size, int coins){\\n    qsort((void*)costs, size, sizeof(costs[0]), comparator);\\n\\n    for(int i=0 ;i<size; ++i)\\n        if((coins-=costs[i])<0) return i;\\n    return size;\\n}\\n```\n```Python3 []\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        costs.sort()\\n        for i in range(len(costs)):\\n            coins -= costs[i]\\n            if coins < 0: \\n                return i\\n        return len(costs)\\n```\n```python []\\n    def maxIceCream(self, costs, coins):\\n        costs.sort()\\n        for i in range(len(costs)):\\n            coins -= costs[i]\\n            if coins < 0:\\n                return i\\n        return len(costs)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3005418,
                "title": "leetcode-the-hard-way-explained-line-by-line",
                "content": "\\uD83D\\uDD34 Check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. \\n\\uD83D\\uDFE0 Check out our [Discord](https://discord.gg/Nqm4jJcyBf) for live discussion.\\n\\uD83D\\uDFE2 Give a star on [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way) and upvote this post if you like it.\\n\\uD83D\\uDD35 Check out [Screencast](https://www.youtube.com/watch?v=CXJvDk4plVw&list=PLBu4Bche1aEWMj1TdpymXbD8Tn8xKVYwj&index=6) if you are interested.\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        // greedy\\n        // buy the cheapest ice cream bar first\\n        int ans = 0;\\n        sort(costs.begin(), costs.end());\\n        for (auto c : costs) {\\n            // if we don\\'t have enough coins,\\n            // then break it\\n            if (coins - c < 0) break;\\n            // buy one\\n            ans += 1;\\n            // update coins\\n            coins -= c;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        // greedy\\n        // buy the cheapest ice cream bar first\\n        int ans = 0;\\n        sort(costs.begin(), costs.end());\\n        for (auto c : costs) {\\n            // if we don\\'t have enough coins,\\n            // then break it\\n            if (coins - c < 0) break;\\n            // buy one\\n            ans += 1;\\n            // update coins\\n            coins -= c;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006933,
                "title": "c-solution-without-sort",
                "content": "Complexity\\nTime complexity:O(n)\\nSpace complexity:O(1)\\n\\nCode\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int freq[100000+1]={0};\\n        for(int &e :costs)\\n            freq[e]++;\\n        \\n        int cnt=0;\\n        for(int i=1;i<=100000;++i)\\n        {\\n            if(freq[i])\\n            {\\n                int curr=1LL*i*freq[i];\\n                if(curr<=coins)\\n                {\\n                    cnt+=freq[i];\\n                    coins-=curr;\\n                }\\n                else\\n                {\\n                    cnt+=(coins/i);\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\nPlease do upvote guys if you find it useful \\nHappy Coding ..",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int freq[100000+1]={0};\\n        for(int &e :costs)\\n            freq[e]++;\\n        \\n        int cnt=0;\\n        for(int i=1;i<=100000;++i)\\n        {\\n            if(freq[i])\\n            {\\n                int curr=1LL*i*freq[i];\\n                if(curr<=coins)\\n                {\\n                    cnt+=freq[i];\\n                    coins-=curr;\\n                }\\n                else\\n                {\\n                    cnt+=(coins/i);\\n                    break;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164109,
                "title": "java-python-3-sort-and-apply-greedy-algorithm",
                "content": "```java\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        for (int i = 0; i < costs.length; ++i) {\\n            coins -= costs[i];\\n            if (coins < 0) {\\n                return i;\\n            }\\n        }\\n        return costs.length;\\n    }\\n```\\n```python\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        for i, c in enumerate(sorted(costs)):\\n            coins -= c\\n            if coins < 0:\\n                return i\\n        return len(costs)\\n```\\n**Analysis:**\\n\\nTime: `O(nlogn)`.",
                "solutionTags": [],
                "code": "```java\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        for (int i = 0; i < costs.length; ++i) {\\n            coins -= costs[i];\\n            if (coins < 0) {\\n                return i;\\n            }\\n        }\\n        return costs.length;\\n    }\\n```\n```python\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        for i, c in enumerate(sorted(costs)):\\n            coins -= c\\n            if coins < 0:\\n                return i\\n        return len(costs)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3006541,
                "title": "c-easiest-explanation-greedy-approach-short-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int count=0;\\n        sort(costs.begin(),costs.end());\\n        for(int i=0;i<costs.size();i++){\\n            if(costs[i] <= coins){\\n                coins-=costs[i];\\n                count++;\\n            }\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int count=0;\\n        sort(costs.begin(),costs.end());\\n        for(int i=0;i<costs.size();i++){\\n            if(costs[i] <= coins){\\n                coins-=costs[i];\\n                count++;\\n            }\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006066,
                "title": "one-liner-py",
                "content": "# Code\\n```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        return sum(1 for icecream in sorted(costs) if (coins:= coins-icecream) >= 0)\\n```\\n![ alt text for screen readers](https://media.istockphoto.com/id/487506120/photo/reticulated-python.jpg?s=612x612&w=0&k=20&c=Kiq69SnelQIakIoNWrmUD0jTmVKkG2KAarG3JYHLBw0= \"Text to show on mouseover\")",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        return sum(1 for icecream in sorted(costs) if (coins:= coins-icecream) >= 0)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005081,
                "title": "daily-leetcoding-challenge-january-day-6",
                "content": "This problem is the Daily LeetCoding Challenge for January, Day 6.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-ice-cream-bars/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain this 0 approach in the official solution</summary>\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/maximum-ice-cream-bars/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1173170,
                "title": "simple-easy-c-solution",
                "content": "**AN UPVOTE WOULD BE HIGHLY APPRECIATED** \\n\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        \\n        int n = costs.size();\\n        \\n        if(n<=1) {\\n            if(costs[0]<coins) {\\n                return 1;\\n            }\\n            else {\\n                return 0;\\n            }\\n        }\\n        \\n        int i=0;\\n        \\n        while(costs[i]<=coins and i<n) {\\n            coins = coins - costs[i];\\n            i++;\\n        }\\n        \\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        \\n        int n = costs.size();\\n        \\n        if(n<=1) {\\n            if(costs[0]<coins) {\\n                return 1;\\n            }\\n            else {\\n                return 0;\\n            }\\n        }\\n        \\n        int i=0;\\n        \\n        while(costs[i]<=coins and i<n) {\\n            coins = coins - costs[i];\\n            i++;\\n        }\\n        \\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006651,
                "title": "2-ways-short-and-explained-java",
                "content": "# 1. Solution 1: Sorting Greedily\\n\\n## Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sort the costs array in ascending order (Low to High) using `Arrays.sort()`.\\n\\n2. Initialize variable `iceBars`, integer to denote the count of ice cream bars.\\n\\n3. Iterate through the sorted costs array of ice cream:\\n   - If `current cost > remaining coins`, break the loop.\\n   - Else, do the following:\\n        - Deduct the cost of current ice cream from our coins.\\n        - Increment `iceBars` by 1 as we already bought this icecream with our coins.\\n4. Return `iceBars`, which denotes the number of ice creams we bought.\\n\\n<hr>\\n\\n# 2. Solution 2: Counting Sort\\n\\n## Approach\\n<!-- Describe your approach to solving the problem. -->\\nCounting sort algorithm finds the maximum count from the array, then creates a new array and puts the contents into it.\\n\\n1. We first need the maximum cost from the costs array. We store it in variable `m`.\\n2. We initialize an array `costFreq`, to store the frequency of each cost from the costs array.\\n3. Iterate over the `costs` array and store each element\\'s frequency `costFreq`.\\n4. Initialize variable `iceBars`, number of ice creams we picked.\\n5. Iterate over each cost from 1 to m. For each cost,\\n    - if the freq is 0, continue looping.\\n    - if the current `cost > coins`, break the loop.\\n    - Get the minimum number of icecreams we can buy with our coin. `count = Math.min(freq, coins/cost)`. Because, there might be freq = 3 and cost = 1. But we have coins = 2. So, we can only buy 2 out of 3 icecreams. That\\'s why we need this minimum value.\\n    - Reduce the cost of those picked ice creams from our coins.\\n    - Add the count of those picked ice creams in the iceBars variable.\\n\\n6. Return the number of ice creams we picked, i.e. the icecreams variable.\\n\\n# 3. Complexity Analysis and Code:\\n\\n## Solution 1: Sorting Greedily:\\n- ### Complexity Analysis:\\n\\n1. Time complexity: $$O(n\\\\log n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n   - We sort the costs array, which will take $$O(n\\\\log\\u2061n)$$ time, and then iterate over it, in worst-case which may take $$O(n)$$ time.\\n\\n   - Thus, overall we take $$O(n\\\\log\\u2061n+n)=O(n\\\\log\\u2061n)$$ time.\\n\\n2. Space complexity: $$O(logn)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n   - In Java, `Arrays.sort()` is implemented using a variant of the **Quick Sort** algorithm which has a space complexity of $$O(log\\u2061n)$$.\\n\\n### Code:\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int iceBars = 0;\\n        for(int cost : costs){\\n            if(cost>coins){\\n                break;\\n            }\\n            iceBars++;\\n            coins -= cost;\\n        }\\n        return iceBars;\\n    }\\n}\\n```\\n\\n\\n## Solution 2: Counting Sort:\\n- ### Complexity Analysis:\\n\\n1. Time complexity: $$O(n+m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n   - Let $$n$$ be the length of the `costs` array, and $$m$$ be the maximum cost in it.\\n   - We once iterate on the input array to find the maximum cost and then iterate once again to store the frequencies of its elements in `costFreq` array, thus it takes $$O(n+n) = O(2n)$$ time.\\n   - We then iterate over the whole `costFreq` array which in the worst case can take $$O(m)$$ time.\\n   - Thus, overall we take $$O(2n+m)=O(n+m)$$ time.\\n\\n2. Space complexity: $$O(m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n   - We use an additional array costFreq of size $$m$$.\\n\\n### Code:\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int m = costs[0];\\n        for(int cost : costs){\\n            m = Math.max(m, cost);\\n        }\\n\\n        int[] costFreq = new int[m+1];\\n\\n        for(int cost : costs){\\n            costFreq[cost]++;\\n        }\\n\\n        int iceBars = 0;\\n\\n        for(int cost=1; cost<=m; cost++){\\n            int freq = costFreq[cost];\\n            if(freq==0){\\n                continue;\\n            }\\n\\n            if(cost>coins){\\n                break;\\n            }\\n\\n            int count = Math.min(freq, coins/cost);\\n            coins -= cost*count;\\n            iceBars += count;\\n        }\\n        return iceBars;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int iceBars = 0;\\n        for(int cost : costs){\\n            if(cost>coins){\\n                break;\\n            }\\n            iceBars++;\\n            coins -= cost;\\n        }\\n        return iceBars;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int m = costs[0];\\n        for(int cost : costs){\\n            m = Math.max(m, cost);\\n        }\\n\\n        int[] costFreq = new int[m+1];\\n\\n        for(int cost : costs){\\n            costFreq[cost]++;\\n        }\\n\\n        int iceBars = 0;\\n\\n        for(int cost=1; cost<=m; cost++){\\n            int freq = costFreq[cost];\\n            if(freq==0){\\n                continue;\\n            }\\n\\n            if(cost>coins){\\n                break;\\n            }\\n\\n            int count = Math.min(freq, coins/cost);\\n            coins -= cost*count;\\n            iceBars += count;\\n        }\\n        return iceBars;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006561,
                "title": "recursion-tle-memoization-tle-tabulation-tle-greedy-ac-5-solutions-tc-sc",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**Why Greedy doesn\\'t work in 0/1 Knapsack?**\\n-> Knapsack problem has two values i.e (value, weight). We can\\'t just simply take the items with greater value, coz we\\'ve to take the weight into consideration too. The weights of the items are not uniform.\\n**Why Greedy works in this problem?**\\n-> Here we don\\'t have the weights of the items. We only have the values. We\\'ve to consider the weights of the bars as uniform weights. Hence we can greedily pick the items based on value. \\n\\n# 5 Approaches\\n- Recursion\\n- Memoization\\n- Tabulation\\n- Greedy - Sorting\\n- Greedy - Heap\\n# 1. Recursion\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(2^(N*C))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N * C) [Auxiliary Space]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int countBars(int index, int coins, vector<int>& prices) {\\n        if(index == 0){\\n            if(coins >= prices[0]) return 1;\\n            return 0;\\n        }\\n\\n        int pick = 0;\\n        int notPick = countBars(index-1, coins, prices);\\n        if(coins >= prices[index])pick = 1 + countBars(index-1, coins-prices[index], prices);\\n\\n        return max(pick, notPick);\\n    }\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        return countBars(n-1, coins, costs);\\n    }\\n};\\n```\\n\\n# 2. Memoization\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(N*C)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N * C) [DP vector] + O(N * C) [Auxiliary Space]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    int countBars(int index, int coins, vector<int>& prices, vector<vector<int>>& dp) {\\n        if(index == 0){\\n            if(coins >= prices[0]) return 1;\\n            return 0;\\n        }\\n\\n        if(dp[index][coins] != -1) return dp[index][coins];\\n\\n        int pick = 0;\\n        int notPick = countBars(index-1, coins, prices, dp);\\n        if(coins >= prices[index])pick = 1 + countBars(index-1, coins-prices[index], prices, dp);\\n\\n        return dp[index][coins] = max(pick, notPick);\\n    }\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        vector<vector<int>> dp(n, vector<int>(coins+1, -1));\\n        return countBars(n-1, coins, costs, dp);\\n    }\\n};\\n```\\n\\n# 3. Tabulation\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(N*C)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N * C) [DP vector]\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        vector<vector<int>> dp(n, vector<int>(coins+1, 0));\\n\\n        for(int i=0;i<=coins;i++){\\n            if(i >= costs[0]) dp[0][i] = 1;\\n            else dp[0][i] = 0;\\n        }\\n\\n        for(int index = 1; index < n; index++){\\n            for(int coin = 0; coin <= coins; coin++){\\n                int pick = 0;\\n                int notPick = dp[index-1][coin];\\n                if(coin >= costs[index]) pick = 1 + dp[index-1][coin - costs[index]];\\n\\n                dp[index][coin] = max(pick, notPick);\\n            }\\n        }\\n\\n        return dp[n-1][coins];\\n    }\\n};\\n```\\n\\n# 4. Greedy Approach - Sorting\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(N logN)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        sort(costs.begin(), costs.end());\\n\\n        int i = 0;\\n        int count = 0;\\n        while(i < n && coins >= costs[i]){\\n            count++;\\n            coins -= costs[i++];\\n        }\\n\\n        return count;\\n    }\\n};\\n```\\n\\n# 5. Greedy Approach - Using Heap\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n\\n        for(auto &it: costs) pq.push(it);\\n\\n        int count = 0;\\n        while(!pq.empty() && coins >= pq.top()){\\n            count++;\\n            coins -= pq.top();\\n            pq.pop();\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Greedy",
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    int countBars(int index, int coins, vector<int>& prices) {\\n        if(index == 0){\\n            if(coins >= prices[0]) return 1;\\n            return 0;\\n        }\\n\\n        int pick = 0;\\n        int notPick = countBars(index-1, coins, prices);\\n        if(coins >= prices[index])pick = 1 + countBars(index-1, coins-prices[index], prices);\\n\\n        return max(pick, notPick);\\n    }\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        return countBars(n-1, coins, costs);\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    int countBars(int index, int coins, vector<int>& prices, vector<vector<int>>& dp) {\\n        if(index == 0){\\n            if(coins >= prices[0]) return 1;\\n            return 0;\\n        }\\n\\n        if(dp[index][coins] != -1) return dp[index][coins];\\n\\n        int pick = 0;\\n        int notPick = countBars(index-1, coins, prices, dp);\\n        if(coins >= prices[index])pick = 1 + countBars(index-1, coins-prices[index], prices, dp);\\n\\n        return dp[index][coins] = max(pick, notPick);\\n    }\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        vector<vector<int>> dp(n, vector<int>(coins+1, -1));\\n        return countBars(n-1, coins, costs, dp);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        vector<vector<int>> dp(n, vector<int>(coins+1, 0));\\n\\n        for(int i=0;i<=coins;i++){\\n            if(i >= costs[0]) dp[0][i] = 1;\\n            else dp[0][i] = 0;\\n        }\\n\\n        for(int index = 1; index < n; index++){\\n            for(int coin = 0; coin <= coins; coin++){\\n                int pick = 0;\\n                int notPick = dp[index-1][coin];\\n                if(coin >= costs[index]) pick = 1 + dp[index-1][coin - costs[index]];\\n\\n                dp[index][coin] = max(pick, notPick);\\n            }\\n        }\\n\\n        return dp[n-1][coins];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        sort(costs.begin(), costs.end());\\n\\n        int i = 0;\\n        int count = 0;\\n        while(i < n && coins >= costs[i]){\\n            count++;\\n            coins -= costs[i++];\\n        }\\n\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        priority_queue<int, vector<int>, greater<int>> pq;\\n\\n        for(auto &it: costs) pq.push(it);\\n\\n        int count = 0;\\n        while(!pq.empty() && coins >= pq.top()){\\n            count++;\\n            coins -= pq.top();\\n            pq.pop();\\n        }\\n\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005439,
                "title": "java-easy-to-understand-solution-with-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst i have delcared a count variable which is helpfull to get the number of ice-cream bars purchased. Arrays.sort() is used to sort the given array which is helpfull for sorting in ascending order. using for loop i have checked whether the current bar is able to purchase or not if yes then count will be incremented and the number of coins decreased. finnaly returned the number of coins\\n\\n# Complexity\\n- Time complexity:O(n log n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int count = 0;\\n        Arrays.sort(costs);\\n        for(int i=0;i<costs.length;i++) {\\n        \\tif(costs[i]<=coins) {\\n        \\t\\tcount++;\\n        \\t\\tcoins -= costs[i];\\n        \\t}else{\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int count = 0;\\n        Arrays.sort(costs);\\n        for(int i=0;i<costs.length;i++) {\\n        \\tif(costs[i]<=coins) {\\n        \\t\\tcount++;\\n        \\t\\tcoins -= costs[i];\\n        \\t}else{\\n                return count;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1225194,
                "title": "java-o-n-98-26-count-sort",
                "content": "The logic is pretty simple:\\n\\n1. Count the number of ice-creams which have a given cost, for all costs from 1 to 10^5.\\n2. Starting with the cheapest ice-creams, identify the maximum number you can buy without crossing your limit.\\n3. Adjust the limit that you have left, and update the answer.\\n\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int[] counter = new int[100001];\\n        for(int i = 0 ; i < costs.length ; i++) counter[costs[i]]++;\\n        int answer = 0;\\n        for(int i = 1 ; i < 100001 ; i++) {\\n            if(counter[i] > 0) {\\n                int toUse = Math.min(coins / i, counter[i]);\\n                coins -= toUse * i;\\n                answer += toUse;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int[] counter = new int[100001];\\n        for(int i = 0 ; i < costs.length ; i++) counter[costs[i]]++;\\n        int answer = 0;\\n        for(int i = 1 ; i < 100001 ; i++) {\\n            if(counter[i] > 0) {\\n                int toUse = Math.min(coins / i, counter[i]);\\n                coins -= toUse * i;\\n                answer += toUse;\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1176893,
                "title": "4ms-100-java",
                "content": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int[] arrayMap = new int[100001];\\n        for(int i=0;i<costs.length;i++){\\n            arrayMap[costs[i]] ++;\\n        }\\n        int count = 0;\\n        for(int j=0;j<arrayMap.length;j++){\\n\\n            if(arrayMap[j]>0){\\n                int n = 0;\\n                while(n < arrayMap[j]){\\n                    if(coins - j>=0){\\n                        coins = coins -j;\\n                        n++;\\n                        count++;\\n                    }else{\\n                        return count;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int[] arrayMap = new int[100001];\\n        for(int i=0;i<costs.length;i++){\\n            arrayMap[costs[i]] ++;\\n        }\\n        int count = 0;\\n        for(int j=0;j<arrayMap.length;j++){\\n\\n            if(arrayMap[j]>0){\\n                int n = 0;\\n                while(n < arrayMap[j]){\\n                    if(coins - j>=0){\\n                        coins = coins -j;\\n                        n++;\\n                        count++;\\n                    }else{\\n                        return count;\\n                    }\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173056,
                "title": "python-accumulate",
                "content": "If we first sort the array, we can then use `accumulate`. This is sum all of the numbers consecutively, like so:\\n\\n`[1,2,3] -> [1, 3, 6]`\\n\\nThen, we can just figure out the number of items that are less than or equal to our amount!\\n\\n```python\\nreturn len([i for i in itertools.accumulate(sorted(costs)) if i <= coins])\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sorting"
                ],
                "code": "```python\\nreturn len([i for i in itertools.accumulate(sorted(costs)) if i <= coins])\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3007872,
                "title": "two-greedy-solutions-very-simple",
                "content": "The idea behind a greedy algorithm: Take the cheapest bar while there is some money left.\\n\\nMin Heap (basically a hidden sorting):\\n```csharp\\npublic class Solution\\n{\\n    public int MaxIceCream(int[] costs, int coins)\\n    {\\n        int res = 0;\\n        PriorityQueue<int, int> q = new(costs.Select(x => (x, x)));\\n\\n        while (q.Count > 0 && coins >= q.Peek())\\n        {\\n            coins -= q.Dequeue();\\n            res++;\\n        }\\n\\n        return res;\\n    }\\n}\\n```\\n\\nSorting:\\n```csharp\\npublic class Solution\\n{\\n    public int MaxIceCream(int[] costs, int coins)\\n    {\\n        int res = 0;\\n\\n        foreach (int cost in costs.OrderBy(x => x))\\n        {\\n            if (cost > coins) break;\\n            coins -= cost;\\n            res++;\\n        }\\n\\n        return res;        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```csharp\\npublic class Solution\\n{\\n    public int MaxIceCream(int[] costs, int coins)\\n    {\\n        int res = 0;\\n        PriorityQueue<int, int> q = new(costs.Select(x => (x, x)));\\n\\n        while (q.Count > 0 && coins >= q.Peek())\\n        {\\n            coins -= q.Dequeue();\\n            res++;\\n        }\\n\\n        return res;\\n    }\\n}\\n```\n```csharp\\npublic class Solution\\n{\\n    public int MaxIceCream(int[] costs, int coins)\\n    {\\n        int res = 0;\\n\\n        foreach (int cost in costs.OrderBy(x => x))\\n        {\\n            if (cost > coins) break;\\n            coins -= cost;\\n            res++;\\n        }\\n\\n        return res;        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006837,
                "title": "python-easiest-solution-using-heap",
                "content": "# Intuition\\nGet the minimum element one-by-one by popping so that we can buy more bars\\n# Approach\\n- Find the minimum element\\n- Pop that element\\n- check if that is lesser than current coins\\n- Increase the count\\n\\n# Complexity\\n- Time complexity: **O(N*log(N))**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        heapq.heapify(costs)\\n        count = 0\\n        while(coins>0 and costs):\\n            min_el = heapq.heappop(costs)\\n            if min_el <= coins:\\n                coins -= min_el\\n                count += 1\\n            else:\\n                break\\n        return count\\n```\\n\\n```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        costs.sort()\\n        count = 0\\n        for cost in costs:\\n            if (cost>coins):\\n                break\\n            coins -= cost\\n            count += 1\\n        return count\\n```\\n",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        heapq.heapify(costs)\\n        count = 0\\n        while(coins>0 and costs):\\n            min_el = heapq.heappop(costs)\\n            if min_el <= coins:\\n                coins -= min_el\\n                count += 1\\n            else:\\n                break\\n        return count\\n```\n```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        costs.sort()\\n        count = 0\\n        for cost in costs:\\n            if (cost>coins):\\n                break\\n            coins -= cost\\n            count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006322,
                "title": "simple-c-greedy-sorting",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nSimpply sort the array and check if sum of costs of ice creams is less than or equal to coins that we have .\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nGreedy Appraoch just sort the array and check sum of costs stored in cnt varaible with the coins having . If it is less then cnt++ else break;\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& arr, int coins) {\\n        sort(arr.begin(),arr.end());\\n        int cnt=arr[0];\\n        int ans=0;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            if(coins>=cnt and i<n-1)ans++,cnt+=arr[i+1];\\n             if(i==n-1 and coins>=cnt)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& arr, int coins) {\\n        sort(arr.begin(),arr.end());\\n        int cnt=arr[0];\\n        int ans=0;\\n        int n=arr.size();\\n        for(int i=0;i<n;i++){\\n            if(coins>=cnt and i<n-1)ans++,cnt+=arr[i+1];\\n             if(i==n-1 and coins>=cnt)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008125,
                "title": "easiest-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int count = 0;\\n        int sum = 0;\\n        for(int i=0;i<costs.length;i++){\\n            if(costs[i] <= coins){\\n                coins = coins - costs[i];\\n                count++;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int count = 0;\\n        int sum = 0;\\n        for(int i=0;i<costs.length;i++){\\n            if(costs[i] <= coins){\\n                coins = coins - costs[i];\\n                count++;\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006966,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int sum=0;\\n        int count=0;\\n        sort(costs.begin(),costs.end());\\n        for(int i=0;i<costs.size();i++){\\n            sum+=costs[i];\\n            count++;\\n            if(sum==coins)return count;\\n            if(sum>coins)return count-1;\\n        }\\n        return count; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int sum=0;\\n        int count=0;\\n        sort(costs.begin(),costs.end());\\n        for(int i=0;i<costs.size();i++){\\n            sum+=costs[i];\\n            count++;\\n            if(sum==coins)return count;\\n            if(sum>coins)return count-1;\\n        }\\n        return count; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006177,
                "title": "c-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nfirst of all sort the array and check for total sum <=coins during each iteration\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        \\n        sort(costs.begin(),costs.end());\\n        int ans=0,sum=0;\\n        if(coins<costs[0])\\n        return 0;\\n        else\\n        {\\n        for(int i=0;i<costs.size();i++)\\n        {\\n            sum+=costs[i];\\n             if(sum<=coins)\\n             {\\n                 \\n                 ans++;\\n             }\\n             else\\n             break;\\n        }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        \\n        sort(costs.begin(),costs.end());\\n        int ans=0,sum=0;\\n        if(coins<costs[0])\\n        return 0;\\n        else\\n        {\\n        for(int i=0;i<costs.size();i++)\\n        {\\n            sum+=costs[i];\\n             if(sum<=coins)\\n             {\\n                 \\n                 ans++;\\n             }\\n             else\\n             break;\\n        }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006176,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n    1)First sort the given array\\n    2)Run a loop through entire and subtract the coins spent!\\n    3)Keep a count after every coins spent\\n    4)return count!!\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int count=0,i=0;\\n        sort(costs.begin(),costs.end());\\n        for(i=0;i<costs.size();i++)\\n        {\\n            if(coins>=costs[i])\\n            {\\n                count++;\\n                coins-=costs[i];\\n            }\\n            if(coins<=0)\\n                return count;\\n        }\\n        return\\xA0count;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int count=0,i=0;\\n        sort(costs.begin(),costs.end());\\n        for(i=0;i<costs.size();i++)\\n        {\\n            if(coins>=costs[i])\\n            {\\n                count++;\\n                coins-=costs[i];\\n            }\\n            if(coins<=0)\\n                return count;\\n        }\\n        return\\xA0count;\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005462,
                "title": "c-java-easiest-explanation-95-memory-efficient",
                "content": "# Please upvote, if you find this helpful\\n##### Thank you in advance ;)\\n<B></B>\\n# Explanation:\\n```\\nStart with the cheapest item if you wish to increase your items.\\n\\nSo, we sorted the array in accordance with the aforementioned requirement.\\n\\nproceed by iterating from 0 index and increasing your count if cost[i]<coins; \\nyou must also remove this cost from the total number of coins available \\nbecause some of them have already been spent.\\n```\\n<B></B>\\n<B></B>\\n<B></B>\\n\\n# C++\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int count=0;\\n        for(int i=0;i<costs.size();i++){\\n            if(costs[i]<=coins){\\n                count++;\\n                coins -= costs[i];\\n            }else\\n                break;\\n        }\\n        return count;\\n    }\\n};\\n```\\n<B></B>\\n# Java\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int ans=0;\\n        for(int i=0;i<costs.length;i++){\\n            if(costs[i]>coins)\\n                break;\\n            ans++;\\n            coins -= costs[i];\\n        }\\n        return ans;\\n    }\\n}\\n```\\n<B></B>\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nStart with the cheapest item if you wish to increase your items.\\n\\nSo, we sorted the array in accordance with the aforementioned requirement.\\n\\nproceed by iterating from 0 index and increasing your count if cost[i]<coins; \\nyou must also remove this cost from the total number of coins available \\nbecause some of them have already been spent.\\n```\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int count=0;\\n        for(int i=0;i<costs.size();i++){\\n            if(costs[i]<=coins){\\n                count++;\\n                coins -= costs[i];\\n            }else\\n                break;\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int ans=0;\\n        for(int i=0;i<costs.length;i++){\\n            if(costs[i]>coins)\\n                break;\\n            ans++;\\n            coins -= costs[i];\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005218,
                "title": "easiest-java-solution-simplest-explanation",
                "content": "\\n# The only rules -> \\n***1. To have maximum buy as many minimum ones***\\n***2. When broke, stop buying***\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        //Sorting in Ascending order\\n        Arrays.sort(costs);\\n        int maxCost = 0;\\n        for(int i=0; i<costs.length; i++){\\n            //returning when we\\'ve exhausted all coins\\n            if(maxCost + costs[i] > coins) return i;\\n            maxCost += costs[i];\\n        }\\n        return costs.length;\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        //Sorting in Ascending order\\n        Arrays.sort(costs);\\n        int maxCost = 0;\\n        for(int i=0; i<costs.length; i++){\\n            //returning when we\\'ve exhausted all coins\\n            if(maxCost + costs[i] > coins) return i;\\n            maxCost += costs[i];\\n        }\\n        return costs.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005199,
                "title": "python-1-line",
                "content": "```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        return bisect_right(list(accumulate(sorted(costs))), coins)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        return bisect_right(list(accumulate(sorted(costs))), coins)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005145,
                "title": "most-easy-and-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs i saw the boy can purchase ice-creams in any order, instant i thought of sorting and then the rest is just the formality.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the Array and then subtract arr[i] from coins, cause we have to buy maximum ice-creams and meanwhile we check if there is enough coin to buy that particular ice-cream or not, if it is then subtract the price of that particular ice-cream from the coins and increase the count of ice-creams else break the loop and return the no. of ice-creams the boy has purchase.\\n\\n\\nLeave an Upvote\\u261D\\uFE0F, if it helps\\uD83D\\uDE07\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->  O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->  O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int iceCream = 0;\\n        for(int i = 0; i<costs.length; i++){\\n            if(coins-costs[i] >= 0){\\n                coins-=costs[i];\\n                iceCream++;\\n            }else\\n                break;\\n        }\\n        return iceCream;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int iceCream = 0;\\n        for(int i = 0; i<costs.length; i++){\\n            if(coins-costs[i] >= 0){\\n                coins-=costs[i];\\n                iceCream++;\\n            }else\\n                break;\\n        }\\n        return iceCream;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005140,
                "title": "most-easy-and-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAs i saw the boy can purchase ice-creams in any order, instant i thought of sorting and then the rest is just the formality.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the Array and then subtract arr[i] from coins, cause we have to buy maximum ice-creams and meanwhile we check if there is enough coin to buy that particular ice-cream or not, if it is then subtract the price of that particular ice-cream from the coins and increase the count of ice-creams else break the loop and return the no. of ice-creams the boy has purchase.\\n\\n\\nLeave an Upvote\\u261D\\uFE0F, if it helps\\uD83D\\uDE07\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int iceCream = 0;\\n        for(int i = 0; i<costs.length; i++){\\n            if(coins-costs[i] >= 0){\\n                coins-=costs[i];\\n                iceCream++;\\n            }else\\n                break;\\n        }\\n        return iceCream;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int iceCream = 0;\\n        for(int i = 0; i<costs.length; i++){\\n            if(coins-costs[i] >= 0){\\n                coins-=costs[i];\\n                iceCream++;\\n            }else\\n                break;\\n        }\\n        return iceCream;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2842145,
                "title": "java-easy-counting-beats-98-35",
                "content": "# Approach\\nfirst **sorting the array**,because here we want maximum number of icecream, because the more the icecream is cheap the more we can buy, then traverse a loop until the coin is in negative number. and count the operation.\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int count = 0;\\n        Arrays.sort(costs);\\n        for (int j : costs) {\\n            coins = coins - j;\\n            if (coins < 0) {\\n                break;\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int count = 0;\\n        Arrays.sort(costs);\\n        for (int j : costs) {\\n            coins = coins - j;\\n            if (coins < 0) {\\n                break;\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1393788,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins)\\n    {\\n        Arrays.sort(costs);\\n        if(costs[0] > coins)\\n            return 0;   \\n        int ans = 0;\\n        for(int i=0; i<costs.length && coins > 0; i++)\\n        {\\n            if(costs[i] > coins)\\n                break;\\n            coins -= costs[i];\\n            ans++;\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins)\\n    {\\n        Arrays.sort(costs);\\n        if(costs[0] > coins)\\n            return 0;   \\n        int ans = 0;\\n        for(int i=0; i<costs.length && coins > 0; i++)\\n        {\\n            if(costs[i] > coins)\\n                break;\\n            coins -= costs[i];\\n            ans++;\\n        }\\n        return ans; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181373,
                "title": "python-one-liner",
                "content": "```\\nreturn sum(1 for ice in sorted(costs) if (coins:= coins-ice) >= 0)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nreturn sum(1 for ice in sorted(costs) if (coins:= coins-ice) >= 0)\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1166815,
                "title": "python-easy-solution-faster-than-100",
                "content": "```\\ncosts.sort() //sorting cost array\\ncount = 0  //tracker of candy bars count\\nfor i in costs: //iterating through array\\n    if(coins-i>=0):  // count is increased only if deduction of cost from coin is more than 0 or 0.\\n          coins -= i \\n          count +=1\\nreturn count\\n```\\n\\nKindly Upvote if you liked it!",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ncosts.sort() //sorting cost array\\ncount = 0  //tracker of candy bars count\\nfor i in costs: //iterating through array\\n    if(coins-i>=0):  // count is increased only if deduction of cost from coin is more than 0 or 0.\\n          coins -= i \\n          count +=1\\nreturn count\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1163996,
                "title": "java-greedy-solution-works-here",
                "content": "Intuitively, if we want the max amout of ice cream, we can buy from the cheapest one. \\n\\n**Java:**\\n\\n```\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int res = 0;\\n        for (int i : costs) {\\n            if (coins >= i) {\\n                res++;\\n                coins -= i;\\n            }\\n        }\\n        return res;\\n    }\\n```\\n\\n**Python:**\\n\\n```\\n    def maxIceCream(self, costs, coins):\\n        \"\"\"\\n        :type costs: List[int]\\n        :type coins: int\\n        :rtype: int\\n        \"\"\"\\n        costs.sort()\\n        for i, c in enumerate(costs):\\n            coins -= c\\n            if coins < 0:\\n                return i\\n        return len(costs)\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int res = 0;\\n        for (int i : costs) {\\n            if (coins >= i) {\\n                res++;\\n                coins -= i;\\n            }\\n        }\\n        return res;\\n    }\\n```\n```\\n    def maxIceCream(self, costs, coins):\\n        \"\"\"\\n        :type costs: List[int]\\n        :type coins: int\\n        :rtype: int\\n        \"\"\"\\n        costs.sort()\\n        for i, c in enumerate(costs):\\n            coins -= c\\n            if coins < 0:\\n                return i\\n        return len(costs)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3008478,
                "title": "c-easiest-solution-with-detailed-explaination",
                "content": "**DO UPVOTE IF YOU FIND THIS APPROACH HELPFUL :)**\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTo buy the maximum number of icecreams boy should start buying icecreams with less cost.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Sorting the costs array will do the work and sort the icecreams with lowest to highest prices.\\n2. Now start traversing the vector from left and each time boy buys a icecream, decrease the coins he have and increase the number of icecreams he have.\\n3. Once he left with coins less than cost of icecream, loop breaks and return maximum number of icecream he can have.\\n\\n# Complexity\\n- Time complexity: `O(nlogn)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int icecreams = 0;\\n        sort(costs.begin(), costs.end());\\n        for(int i=0; i<costs.size(); i++){\\n            if(coins >= costs[i]){\\n                coins = coins - costs[i];\\n                icecreams++;\\n            }\\n        }\\n        return icecreams;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int icecreams = 0;\\n        sort(costs.begin(), costs.end());\\n        for(int i=0; i<costs.size(); i++){\\n            if(coins >= costs[i]){\\n                coins = coins - costs[i];\\n                icecreams++;\\n            }\\n        }\\n        return icecreams;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008405,
                "title": "super-easy-approach-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int total=0; int count=0;\\n        for(int i=0;i<costs.size();i++){\\n            if(costs[i]+total<=coins && costs[i]<=coins) {\\n                total += costs[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\nPlease upvote to motivate me to write more solutions\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int total=0; int count=0;\\n        for(int i=0;i<costs.size();i++){\\n            if(costs[i]+total<=coins && costs[i]<=coins) {\\n                total += costs[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008386,
                "title": "python-easy-to-unserstand",
                "content": "\\n\\n# Approach\\n    Sorting\\n\\n# Complexity\\n- Time complexity:\\n    O(n)\\n\\n- Space complexity:\\n    O(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        #sorting costs in ascending order\\n        costs = sorted(costs)\\n        num = 0\\n        for i in range(len(costs)):\\n            if coins >0 and coins >= costs[i]:\\n                coins -= costs[i] \\n                num+=1\\n        return num\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        #sorting costs in ascending order\\n        costs = sorted(costs)\\n        num = 0\\n        for i in range(len(costs)):\\n            if coins >0 and coins >= costs[i]:\\n                coins -= costs[i] \\n                num+=1\\n        return num\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007596,
                "title": "c-greedy-short-and-easy-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int cnt=0;\\n        for(int i=0;i<costs.size();i++){\\n            if(coins<costs[i]){\\n                break;\\n            }\\n            coins-=costs[i];\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int cnt=0;\\n        for(int i=0;i<costs.size();i++){\\n            if(coins<costs[i]){\\n                break;\\n            }\\n            coins-=costs[i];\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006669,
                "title": "easy-java-solution-sort-greedy-beginner-friendly",
                "content": "# Intuition\\n1. Sort the array so that you can choose ice cream of lessor price before.\\n2. Reduce the coin with price of ice creaem bar\\n3. Repeat this for all ice cream.\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int result = 0;\\n        for(int cost: costs) {\\n            if(cost <= coins){\\n                coins = coins - cost;\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int result = 0;\\n        for(int cost: costs) {\\n            if(cost <= coins){\\n                coins = coins - cost;\\n                result++;\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006599,
                "title": "simple-easy-c-solution",
                "content": "# Approach\\nSort the costs array.\\nIf costs[i] is less than coins then decrement the coins\\nwith costs[i] and increment the counter.\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int ans=0;\\n        for(int i=0;i<costs.size();i++){\\n            if(costs[i]<=coins){\\n                ans++;\\n                coins-=costs[i];\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int ans=0;\\n        for(int i=0;i<costs.size();i++){\\n            if(costs[i]<=coins){\\n                ans++;\\n                coins-=costs[i];\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006199,
                "title": "easy-c-solution",
                "content": "Here is the C++ solution.\\n\\nWe first sort the array, and keep subtracting the cost from the coins as long as we can do so:\\n\\n``` C++ []\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(begin(costs), end(costs));\\n        for (int i = 0; i < costs.size(); ++i)\\n            if (coins >= costs[i])\\n                coins -= costs[i];\\n            else\\n                return i;\\n        return costs.size();\\n    }\\n};\\n```\\n\\n*If thee solution helped please upvote it*",
                "solutionTags": [
                    "C++"
                ],
                "code": "``` C++ []\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(begin(costs), end(costs));\\n        for (int i = 0; i < costs.size(); ++i)\\n            if (coins >= costs[i])\\n                coins -= costs[i];\\n            else\\n                return i;\\n        return costs.size();\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006073,
                "title": "c-shouldn-t-be-a-med-que-easy-short-clean-code",
                "content": "![image](https://assets.leetcode.com/users/images/76dd258e-8fed-4296-8bd8-4f176a78cc90_1672979336.0421722.png)\\n\\n**T-> O(nlogn) && S->O(1)**\\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint maxIceCream(vector<int>& costs, int coins) {\\n\\t\\t\\t\\tint n = costs.size();\\n\\t\\t\\t\\tint count = 0;\\n\\n\\t\\t\\t\\tsort(costs.begin(),costs.end());\\n\\n\\t\\t\\t\\tfor(int i = 0 ; i < n ; i++){\\n\\t\\t\\t\\t\\tif(costs[i] <= coins){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\tcoins -= costs[i];\\n\\t\\t\\t\\t\\t} \\n\\t\\t\\t\\t\\telse break;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn count;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint maxIceCream(vector<int>& costs, int coins) {\\n\\t\\t\\t\\tint n = costs.size();\\n\\t\\t\\t\\tint count = 0;\\n\\n\\t\\t\\t\\tsort(costs.begin(),costs.end());\\n\\n\\t\\t\\t\\tfor(int i = 0 ; i < n ; i++){\\n\\t\\t\\t\\t\\tif(costs[i] <= coins){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t\\tcoins -= costs[i];\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3006001,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int ans = 0;\\n        for(int i = 0; i<costs.size(); i++)\\n        {\\n            if(costs[i]<=coins)\\n            {\\n                coins = coins - costs[i];\\n                ans++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int ans = 0;\\n        for(int i = 0; i<costs.size(); i++)\\n        {\\n            if(costs[i]<=coins)\\n            {\\n                coins = coins - costs[i];\\n                ans++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005855,
                "title": "c-easy-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst I sort the costs than take every ice cream if I have that much money.\\n# Complexity\\n- Time complexity:O(nlog(n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        int ans = 0;\\n        for(int i=0; i<costs.size(); i++){\\n            if(costs[i] <= coins){\\n                ans++;\\n                coins -= costs[i];\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        int ans = 0;\\n        for(int i=0; i<costs.size(); i++){\\n            if(costs[i] <= coins){\\n                ans++;\\n                coins -= costs[i];\\n            }\\n            else{\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005302,
                "title": "trynna-be-greedy",
                "content": "![image](https://assets.leetcode.com/users/images/c64c6558-0f68-4068-87f2-08af34e919f2_1672968706.9650457.png)\\n\\n\\n```class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int ans=0;\\n        for(int x:costs){\\n            if(x<=coins){\\n                ans++;\\n                coins-=x;\\n            }\\n            else break;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int ans=0;\\n        for(int x:costs){\\n            if(x<=coins){\\n                ans++;\\n                coins-=x;\\n            }\\n            else break;\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005284,
                "title": "c-solution-intuition-approach-complexity-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n$$1$$) sort the array\\n$$2$$) traverse the array (costs)\\n$$3$$) check condition if we can that costs[idx] or not\\n$$4$$) if yes then cnt++ and subtract that value from coins\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSorting, Greedy\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        sort(costs.begin(),costs.end());\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(costs[i]<=coins){\\n                cnt++;\\n                coins = coins - costs[i];\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        sort(costs.begin(),costs.end());\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(costs[i]<=coins){\\n                cnt++;\\n                coins = coins - costs[i];\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005224,
                "title": "rust-simple-18ms",
                "content": "# Intuition\\nThe price range is small enough to make using [counting sort](https://en.wikipedia.org/wiki/Counting_sort) a good option for performing an $$O(n)$$ sort. The smallest array that can hold the price range and $$n<=10^5$$ bars is 400KB.\\n\\nAside from the advantage of sorting in $$O(n)$$, counting sort also has the advantage that its array can fit nicely in L1/L2 cache and reduce memory read overhead, especially since most elements are compactly represented by the count values (the counts can be held in a register and don\\'t require memory accesses to iterate over each element they represent). This can offset the wasted cycles for array elements with counts of 0.\\n\\n# Approach\\nThe counting sort array, `bars` is populated by scanning `costs` once in linear time. Then `price` indexes into `bars` to get the number of bars available at each price.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$ *auxiliary* space. The `bars` array size is constant and doesn\\'t vary with input.\\n\\n# Code\\n```rust\\nimpl Solution {\\n    pub fn max_ice_cream(costs: Vec<i32>, coins: i32) -> i32 {\\n        let mut bars  = [0_u32; 100_001];\\n        let mut coins = coins;\\n        let mut price = 1;\\n        let mut count = 0;\\n\\n        costs.into_iter().for_each(|c| bars[c as usize] += 1);\\n\\n        while coins >= price && price <= 100_000 {\\n            while bars[price as usize] > 0 && coins >= price {\\n                bars[price as usize] -= 1;\\n                coins -= price;\\n                count += 1;\\n            }\\n            price += 1;\\n        }\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Counting Sort"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn max_ice_cream(costs: Vec<i32>, coins: i32) -> i32 {\\n        let mut bars  = [0_u32; 100_001];\\n        let mut coins = coins;\\n        let mut price = 1;\\n        let mut count = 0;\\n\\n        costs.into_iter().for_each(|c| bars[c as usize] += 1);\\n\\n        while coins >= price && price <= 100_000 {\\n            while bars[price as usize] > 0 && coins >= price {\\n                bars[price as usize] -= 1;\\n                coins -= price;\\n                count += 1;\\n            }\\n            price += 1;\\n        }\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3005133,
                "title": "python3-838-ms-faster-than-92-67-of-python3-clean-and-easy-to-understand",
                "content": "**Logic**\\n*1. Sort the Cost array so that we can buy maximum low cost Ice Cream Bars*\\n*2. Buy the low cost Ice Cream Bars and reduce the coins as you buy*\\n```\\ndef maxIceCream(self, costs: List[int], coins: int) -> int:\\n        result=0\\n        costs.sort()\\n        for x,y in enumerate(costs):\\n            if coins<y:\\n                break\\n            result = result + 1\\n            coins = coins - y\\n        return result\\n```\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\ndef maxIceCream(self, costs: List[int], coins: int) -> int:\\n        result=0\\n        costs.sort()\\n        for x,y in enumerate(costs):\\n            if coins<y:\\n                break\\n            result = result + 1\\n            coins = coins - y\\n        return result\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2789516,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int count = 0;\\n        int length = costs.length;\\n        for (int i = 0; i < length; i++) {\\n            int cost = costs[i];\\n            if (coins >= cost) {\\n                coins -= cost;\\n                count++;\\n            } else\\n                break;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int count = 0;\\n        int length = costs.length;\\n        for (int i = 0; i < length; i++) {\\n            int cost = costs[i];\\n            if (coins >= cost) {\\n                coins -= cost;\\n                count++;\\n            } else\\n                break;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2640689,
                "title": "python-binary-search-98",
                "content": "```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        acc = list(accumulate([0] + sorted(costs)))\\n        count = bisect_left(acc, coins)\\n        try: return count if acc[count] == coins else count - 1\\n        except IndexError: return count - 1\\n```",
                "solutionTags": [
                    "Python",
                    "Sorting"
                ],
                "code": "```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        acc = list(accumulate([0] + sorted(costs)))\\n        count = bisect_left(acc, coins)\\n        try: return count if acc[count] == coins else count - 1\\n        except IndexError: return count - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1169495,
                "title": "c-greedy-beginner-friendly-short-code",
                "content": "**PLZ UPVOTE IF YOU LIKED IT**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n=costs.size();\\n\\n        sort(costs.begin(),costs.end());\\n        \\n        int i=0;\\n        for(;i<n && coins>=costs[i];i++){\\n            coins-=costs[i];\\n        }\\n        \\n        return i;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n=costs.size();\\n\\n        sort(costs.begin(),costs.end());\\n        \\n        int i=0;\\n        for(;i<n && coins>=costs[i];i++){\\n            coins-=costs[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1165500,
                "title": "python3-with-explanation-100-faster-and-100-memory-efficient",
                "content": "```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        \\'\\'\\'\\n        1. If the minimum of all costs is greater than amount of coins, the boy can\\'t buy any bar, return 0\\n        2. Else, sort the list of costs in a non-decreasing order\\n        3. For each \\'cost\\' in costs, if the cost is less than current coins\\n                -increase the count of ice cream bars that can be bought by 1\\n                -decrease the current coins amount by \\'cost\\'\\n        4. If the cost is greater than current coins, return the ice cream bar count value\\n        \\'\\'\\'\\n        \\n        if min(costs)>coins:        #minimum cost is greater than the coins available        \\n            return 0                #can\\'t buy any ice cream bar\\n        \\n        costs=sorted(costs)         #sort the list of costs in a non-decreasing order\\n        res = 0                     #the resultant count of ice cream bars that can be bought\\n        for cost in costs:\\n            if cost<=coins:         #in this case, the boy can buy the ice cream bar\\n                res+=1              #increase the ice cream bar count\\n                coins-=cost         #spent an amount equal to \\'cost\\', decrease current coins amount by cost\\n            else:\\n                break               #not enough coins, return the bars count\\n            \\n        return res",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        \\'\\'\\'\\n        1. If the minimum of all costs is greater than amount of coins, the boy can\\'t buy any bar, return 0\\n        2. Else, sort the list of costs in a non-decreasing order\\n        3. For each \\'cost\\' in costs, if the cost is less than current coins\\n                -increase the count of ice cream bars that can be bought by 1\\n                -decrease the current coins amount by \\'cost\\'\\n        4. If the cost is greater than current coins, return the ice cream bar count value\\n        \\'\\'\\'\\n        \\n        if min(costs)>coins:        #minimum cost is greater than the coins available        \\n            return 0                #can\\'t buy any ice cream bar\\n        \\n        costs=sorted(costs)         #sort the list of costs in a non-decreasing order\\n        res = 0                     #the resultant count of ice cream bars that can be bought\\n        for cost in costs:\\n            if cost<=coins:         #in this case, the boy can buy the ice cream bar\\n                res+=1              #increase the ice cream bar count\\n                coins-=cost         #spent an amount equal to \\'cost\\', decrease current coins amount by cost\\n            else:\\n                break               #not enough coins, return the bars count\\n            \\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 1164502,
                "title": "javascript-es6-sort-solution",
                "content": "*Explanation* \\nIf we sort the array beforehand, we can buy from left to right until we can\\'t afford anymore ice cream bars.\\n1. Sort the `costs` array\\n2. Keep a `count` of each ice cream bars bought\\n3. Iterate the `costs` array from left to right, \\n\\ta. If the `cost` is `less than or equal` to the `coins` we have, then buy it and add it to the `count`. \\n\\tb. And substract the `cost` from our `coins`. \\n6. If we can\\'t purchase the next ice cream bar then break out of loop and return the `count`\\n\\n\\n```\\nvar maxIceCream = function(costs, coins) {\\n  costs.sort((a, b) => a - b); \\n  let count = 0;\\n  \\n  for (let i = 0; i < costs.length; i++) {\\n    if (costs[i] <= coins) {\\n      count++;\\n      coins -= costs[i]\\n    } else {\\n      break;  // a small optimization, end the loop early if coins go down to zero before we reach end of the length of costs.\\n    }\\n  }\\n  return count;\\n};\\n```\\n\\nTime complexity: O(sort)\\nSpace complexity: O(1)",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nvar maxIceCream = function(costs, coins) {\\n  costs.sort((a, b) => a - b); \\n  let count = 0;\\n  \\n  for (let i = 0; i < costs.length; i++) {\\n    if (costs[i] <= coins) {\\n      count++;\\n      coins -= costs[i]\\n    } else {\\n      break;  // a small optimization, end the loop early if coins go down to zero before we reach end of the length of costs.\\n    }\\n  }\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3009560,
                "title": "easy-solution-in-java-using-sorting",
                "content": "\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIt sorts the array of costs in ascending order. Then, starting from the first element, it subtracts each cost from the amount of money until there is no more money left or all elements have been checked. The number of ice creams that can be bought is equal to the index of the last element that was subtracted.\\n\\n# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int n = costs.length;\\n        Arrays.sort(costs);\\n        int i=0;\\n     while(i<n && costs[i]<=coins) {\\n         coins-=costs[i];\\n         i++;\\n     }          \\n        return i;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int n = costs.length;\\n        Arrays.sort(costs);\\n        int i=0;\\n     while(i<n && costs[i]<=coins) {\\n         coins-=costs[i];\\n         i++;\\n     }          \\n        return i;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009487,
                "title": "c-easy-to-understand-easy-to-code-greedy-array",
                "content": "# Please upvote if you like this solution, it meant a lot to me.\\n# Approach\\n\\n- We will sort according low cost to high cost.\\n- We will Buy the cheapest bar first because we want to maximize the answer.\\n- Repeat this process until we\\'ve not enough coins or we\\'ve bought all bars.\\n- If we can\\'t buy new bar will return our answer.\\n- If we bought all bar then we will return size of costs.\\n\\n# Complexity\\n- Time complexity:\\nO(NLogN).\\n\\n- Space complexity:\\nO(1).\\n\\n# Code\\n```\\nint maxIceCream(vector<int> &costs, int coins)\\n{\\n    sort(costs.begin(), costs.end());\\n    int no = 0;\\n\\n    for (int i = 0; i < costs.size(); i++)\\n    {\\n        if (coins >= costs[i])\\n        {\\n            coins -= costs[i];\\n            no++;\\n        }\\n        else\\n        {\\n           break;\\n        }\\n    }\\n\\n    return no;\\n}\\n```\\n![tp.png](https://assets.leetcode.com/users/images/c824c199-ddbe-49b7-b885-d95cb03da158_1673020566.748259.png)\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nint maxIceCream(vector<int> &costs, int coins)\\n{\\n    sort(costs.begin(), costs.end());\\n    int no = 0;\\n\\n    for (int i = 0; i < costs.size(); i++)\\n    {\\n        if (coins >= costs[i])\\n        {\\n            coins -= costs[i];\\n            no++;\\n        }\\n        else\\n        {\\n           break;\\n        }\\n    }\\n\\n    return no;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3009474,
                "title": "super-easily-understandable-java-sol",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n      Arrays.sort(costs);\\n      int sum=0,count=0;\\n      for(int i=0;i<costs.length;i++){\\n       \\n       if(sum<=coins && sum+costs[i]<=coins){\\n      sum+=costs[i];\\n      count++;\\n       } } return count; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n      Arrays.sort(costs);\\n      int sum=0,count=0;\\n      for(int i=0;i<costs.length;i++){\\n       \\n       if(sum<=coins && sum+costs[i]<=coins){\\n      sum+=costs[i];\\n      count++;\\n       } } return count; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009288,
                "title": "all-approaches-java-solution",
                "content": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) \\n    {\\n        // Arrays.sort(costs);\\n        // int ans=0;\\n        // for(int i=0;i<costs.length;i++)\\n        // {\\n        //     if(coins>=costs[i])\\n        //     {\\n        //         coins-=costs[i];\\n        //         ans++;\\n        //     }\\n        //     else\\n        //     {\\n        //         break ;\\n        //     }\\n        // }\\n        // return ans;\\n        \\n        TreeMap<Integer,Integer> map=new TreeMap<>();\\n        for(int i=0;i<costs.length;i++)\\n        {\\n            map.put(costs[i],map.getOrDefault(costs[i],0)+1);\\n        }\\n        int ans=0;\\n        for(Map.Entry<Integer,Integer> mE: map.entrySet())\\n        {\\n            if(mE.getKey()*mE.getValue() <= coins)\\n            {\\n                ans+=mE.getValue();\\n                coins-=mE.getKey()*mE.getValue();\\n            }\\n            else\\n            {\\n                if(coins/mE.getKey()>=1)\\n                {\\n                    ans+=coins/mE.getKey();\\n                    break;\\n                }\\n                else\\n                    break;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) \\n    {\\n        // Arrays.sort(costs);\\n        // int ans=0;\\n        // for(int i=0;i<costs.length;i++)\\n        // {\\n        //     if(coins>=costs[i])\\n        //     {\\n        //         coins-=costs[i];\\n        //         ans++;\\n        //     }\\n        //     else\\n        //     {\\n        //         break ;\\n        //     }\\n        // }\\n        // return ans;\\n        \\n        TreeMap<Integer,Integer> map=new TreeMap<>();\\n        for(int i=0;i<costs.length;i++)\\n        {\\n            map.put(costs[i],map.getOrDefault(costs[i],0)+1);\\n        }\\n        int ans=0;\\n        for(Map.Entry<Integer,Integer> mE: map.entrySet())\\n        {\\n            if(mE.getKey()*mE.getValue() <= coins)\\n            {\\n                ans+=mE.getValue();\\n                coins-=mE.getKey()*mE.getValue();\\n            }\\n            else\\n            {\\n                if(coins/mE.getKey()>=1)\\n                {\\n                    ans+=coins/mE.getKey();\\n                    break;\\n                }\\n                else\\n                    break;\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009274,
                "title": "simple-c-greedy-solution-sorting-easy-to-beginner",
                "content": "\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& cs, int coins) {\\n           \\n            sort(cs.begin(),cs.end());\\n            int ans=0;\\n\\n              for(auto it: cs){\\n                  if(it<=coins){\\n                      coins=coins-it;\\n                      ans++;\\n                  }\\n                   \\n              }\\n              return ans;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& cs, int coins) {\\n           \\n            sort(cs.begin(),cs.end());\\n            int ans=0;\\n\\n              for(auto it: cs){\\n                  if(it<=coins){\\n                      coins=coins-it;\\n                      ans++;\\n                  }\\n                   \\n              }\\n              return ans;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3009173,
                "title": "java-easy-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n\\t// Sort the costs in ascending order.\\n        Arrays.sort(costs);\\n         int k =0;\\n\\t// if after sort costs[0] > coins soo return 0.\\n        if(coins < costs[k]) return 0;\\n        int ans = 0;\\n    // Loop while we can still afford to buy more ice cream cones.\\n        for(int i =0; i<costs.length; i++){\\n            if(coins >= costs[i]){\\n\\t// Subtract the amount of coins by the cost of the current ice cream cone.\\n              coins = coins - costs[i];\\n\\t // Increment the number of ice cream cones bought.\\n                ans++;\\n            }\\n        }\\n       return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n\\t// Sort the costs in ascending order.\\n        Arrays.sort(costs);\\n         int k =0;\\n\\t// if after sort costs[0] > coins soo return 0.\\n        if(coins < costs[k]) return 0;\\n        int ans = 0;\\n    // Loop while we can still afford to buy more ice cream cones.\\n        for(int i =0; i<costs.length; i++){\\n            if(coins >= costs[i]){\\n\\t// Subtract the amount of coins by the cost of the current ice cream cone.\\n              coins = coins - costs[i];\\n\\t // Increment the number of ice cream cones bought.\\n                ans++;\\n            }\\n        }\\n       return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008974,
                "title": "maximum-ice-cream-bars-in-go",
                "content": "# Intuition\\nTo solve this problem, I would first think about how to identify the maximum number of ice creams that can be bought with a given number of coins.\\n\\n# Approach\\nOne approach to do this would be to sort the costs of the ice creams in ascending order, and then iterate through the sorted list of costs. For each cost, I would check if the current number of coins is greater than or equal to the cost of the current ice cream. If it is, I would buy the ice cream and decrement the number of coins by the cost of the ice cream. If the number of coins is less than the cost of the ice cream, I would stop iterating and return the total number of ice creams that were bought.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this function is $$O(n \\\\log n)$$, where $$n$$ is the number of elements in the costs array. This is because the function first sorts the costs array using the sort() method, which has a time complexity of $$O(n \\\\log n)$$ for arrays with $$n$$ elements. The function then iterates through the sorted array and performs a constant-time operation for each element, resulting in a time complexity of $$O(n)$$ for the loop. The overall time complexity of the function is therefore $$O(n \\\\log n + n)$$, which can be simplified to $$O(n \\\\log n)$$.\\n\\n- Space complexity:\\nThe space complexity of this function is $$O(1)$$.\\n\\nThis is because the function only uses a constant amount of space regardless of the size of the input. The space used by the function is primarily for the variables numIceCreams and coins, which are both numbers and therefore take up a fixed amount of space. The costs array is not modified in the function, so it does not contribute to the space complexity.\\n\\nAs a result, the space complexity of this function is $$O(1)$$.\\n\\n# Code\\n```\\nfunc maxIceCream(costs []int, coins int) int {\\n    // Initialize a variable to keep track of the number of ice creams\\n    // that can be bought with the given number of coins\\n    numIceCreams := 0\\n\\n    // Sort the costs in ascending order\\n    sort.Ints(costs)\\n\\n    // Iterate through the costs\\n    for _, cost := range costs {\\n        // If we have enough coins to buy the current ice cream,\\n        // buy it and decrement the number of coins by the cost\\n        // of the ice cream\\n        if coins >= cost {\\n            numIceCreams++\\n            coins -= cost\\n        } else {\\n            // If we don\\'t have enough coins to buy the current ice cream,\\n            // stop iterating\\n            break\\n        }\\n    }\\n\\n    // Return the number of ice creams that were bought\\n    return numIceCreams\\n}\\n\\n```\\n# Code\\n```\\nfunc maxIceCream(costs []int, coins int) int {\\n    // Sort the costs in ascending order\\n    sort.Ints(costs)\\n\\n    // Initialize a variable to keep track of the number of ice creams\\n    // that can be bought with the given number of coins\\n    iceCreams := 0\\n\\n    // Iterate through the costs\\n    for _, ice := range costs {\\n        // If we have enough coins to buy the current ice cream,\\n        // buy it and decrement the number of coins by the cost\\n        // of the ice cream\\n        if coins -= ice; coins >= 0 {\\n            iceCreams++\\n        }\\n    }\\n\\n    // Return the number of ice creams that were bought\\n    return iceCreams\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc maxIceCream(costs []int, coins int) int {\\n    // Initialize a variable to keep track of the number of ice creams\\n    // that can be bought with the given number of coins\\n    numIceCreams := 0\\n\\n    // Sort the costs in ascending order\\n    sort.Ints(costs)\\n\\n    // Iterate through the costs\\n    for _, cost := range costs {\\n        // If we have enough coins to buy the current ice cream,\\n        // buy it and decrement the number of coins by the cost\\n        // of the ice cream\\n        if coins >= cost {\\n            numIceCreams++\\n            coins -= cost\\n        } else {\\n            // If we don\\'t have enough coins to buy the current ice cream,\\n            // stop iterating\\n            break\\n        }\\n    }\\n\\n    // Return the number of ice creams that were bought\\n    return numIceCreams\\n}\\n\\n```\n```\\nfunc maxIceCream(costs []int, coins int) int {\\n    // Sort the costs in ascending order\\n    sort.Ints(costs)\\n\\n    // Initialize a variable to keep track of the number of ice creams\\n    // that can be bought with the given number of coins\\n    iceCreams := 0\\n\\n    // Iterate through the costs\\n    for _, ice := range costs {\\n        // If we have enough coins to buy the current ice cream,\\n        // buy it and decrement the number of coins by the cost\\n        // of the ice cream\\n        if coins -= ice; coins >= 0 {\\n            iceCreams++\\n        }\\n    }\\n\\n    // Return the number of ice creams that were bought\\n    return iceCreams\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3008610,
                "title": "simple-java-solution",
                "content": "# Complexity\\n- Time complexity: O(n log n)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int s=0,i=0;\\n        while(coins>=costs[i])\\n        {\\n            s++;\\n            coins-=costs[i];\\n            i++;\\n            if(i==costs.length)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int s=0,i=0;\\n        while(coins>=costs[i])\\n        {\\n            s++;\\n            coins-=costs[i];\\n            i++;\\n            if(i==costs.length)\\n            {\\n                break;\\n            }\\n        }\\n        return s;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008568,
                "title": "c-simple-short-solution-d",
                "content": "# Approach\\nIt\\'s a **greedy** algorithm. **Greedy algorithms are usually paired with sorting**. Hence, we sort the ice-creams and start to sum up their price. The algorithm finishes if we have brought all the ice creams or we have spend all of our coins. \\n\\n# Complexity\\n- Time complexity: O(n), where n is the number of ice-creamms (costs.size()) because we need to traverse the vector. However the sorting takes O(n.log(n)) time. Then **the whole algorithm is O(n.log(n))**\\n\\n- Space complexity: O(1) since we need two additional variables :D\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n\\n        int coinsSpend = 0;\\n        int currentIceCream = 0;\\n\\n        while(currentIceCream < costs.size() && coinsSpend <= coins)\\n             coinsSpend += costs[currentIceCream++];\\n               \\n        return coinsSpend > coins ? currentIceCream- 1 : currentIceCream;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n\\n        int coinsSpend = 0;\\n        int currentIceCream = 0;\\n\\n        while(currentIceCream < costs.size() && coinsSpend <= coins)\\n             coinsSpend += costs[currentIceCream++];\\n               \\n        return coinsSpend > coins ? currentIceCream- 1 : currentIceCream;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008381,
                "title": "priority-queue",
                "content": "# Intuition\\nIntuition is the same as intuition of the [official Sorting(Greedy) solution](https://leetcode.com/problems/maximum-ice-cream-bars/solutions/2885725/maximum-ice-cream-bars/). But, as we can see, the bottleneck of this solution is sorting.\\nCan we improve it? I think we can. We don\\'t need to sort the entire `costs` array, it\\'s enough to sort only \"used\" costs, and when total used cost becomes greater than the available `coins` remove the most expensive item.\\n\\n# Approach\\nThere is one very suitable data structure to complete the task, this is `PriorityQueue`. So let\\'s use `PriorityQueue` with the `Comparator` that arranges costs from most expensive to cheapest.\\nWe\\'ll iterate over all items in `costs` array. On each step we\\'ll add the cost to `queue` and `totalCost`. When `totalCost` becomes greater than `coins` we\\'ll remove most expensive (first) cost from `queue` and `totalCost`.\\n\\n# Complexity\\n- Time complexity: `O(n * log(r))`, where `r` is the result count, which is always less than or equeal to `n`\\n- Space complexity: `O(r)`\\n\\nThis solution is better than the official solution in cases when the result is significantly less than the input (`costs` size).\\n\\n# Code\\n```\\nimport java.util.*\\n\\nclass Solution {\\n\\n    fun maxIceCream(costs: IntArray, coins: Int): Int {\\n        val queue = PriorityQueue<Int>(Comparator.reverseOrder())\\n        var totalCost = 0\\n\\n        costs.forEach { cost ->\\n            queue.add(cost)\\n            totalCost += cost\\n\\n            if (totalCost > coins) {\\n                totalCost -= queue.remove()\\n            }\\n        }\\n\\n        return queue.size\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nimport java.util.*\\n\\nclass Solution {\\n\\n    fun maxIceCream(costs: IntArray, coins: Int): Int {\\n        val queue = PriorityQueue<Int>(Comparator.reverseOrder())\\n        var totalCost = 0\\n\\n        costs.forEach { cost ->\\n            queue.add(cost)\\n            totalCost += cost\\n\\n            if (totalCost > coins) {\\n                totalCost -= queue.remove()\\n            }\\n        }\\n\\n        return queue.size\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008320,
                "title": "99-9-1ms-simple-easy-dp-proof",
                "content": "# UPVOTE PLS\\n![image.png](https://assets.leetcode.com/users/images/aa5d9956-4f14-4132-ad34-cea839c78aea_1673005572.4854023.png)\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(k)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] A, int C) {\\n        int maxc = 0, r=0;\\n        for(int i = 0; i < A.length; i++)\\n            if(A[i] > maxc) maxc = A[i];\\n        int[] F = new int[maxc + 1];\\n        for(var v:A)F[v]++;\\n        for(int i=1;i<=maxc &&C>=i && C-i>=0;i++)\\n            if (F[i] > 0) {\\n                r += Math.min(F[i], C/i);\\n                C -= Math.min(C, i * F[i]);\\n            }\\n        return r;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] A, int C) {\\n        int maxc = 0, r=0;\\n        for(int i = 0; i < A.length; i++)\\n            if(A[i] > maxc) maxc = A[i];\\n        int[] F = new int[maxc + 1];\\n        for(var v:A)F[v]++;\\n        for(int i=1;i<=maxc &&C>=i && C-i>=0;i++)\\n            if (F[i] > 0) {\\n                r += Math.min(F[i], C/i);\\n                C -= Math.min(C, i * F[i]);\\n            }\\n        return r;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3008150,
                "title": "2-solutions-c-greedy-beginner-s-friendly-explanation",
                "content": "# Method - 1 (Sorting)\\n## Explanation\\n\\nThe Solution class has a single public method called `maxIceCream`. This method takes in two arguments:\\n\\n1. `costs`: A vector of integers representing the costs of each ice cream bar.\\n2. `coins`: an integer representing the number of coins that you have.\\n\\n\\nThe method first sorts the `costs` vector in ascending order. Then, it initializes a variable `bars` to 0. This variable will keep track of the maximum number of ice cream bars that can be bought.\\n\\nNext, the method uses a range-based `for` loop to iterate through each element in the `costs` vector. For each iteration, the method checks whether `coins` is less than the current cost of the ice cream bar. If it is, the loop breaks and the method moves on to the next step. Otherwise, the method subtracts the cost of the ice cream bar from `coins` and increments `bars` by `1`.\\n\\nFinally, the method returns the value of `bars`, which is the maximum number of ice cream bars that can be bought.\\n\\n## Complexity\\n- Time complexity:\\n`O(N * log N)`, where N is the total number of ice-cream bars available in the shop.\\n\\n- Space complexity:\\n`O(1)`\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        int bars = 0;\\n\\n        for (int cost : costs) {\\n            if (coins < cost)\\n                break;\\n\\n            coins -= cost;\\n            bars++;\\n        }\\n\\n        return bars;\\n    }\\n};\\n```\\n\\n# Method - 2 (No sorting, counting the bars)\\n\\n## Explanation\\nThe `Solution` class has a single public method called `maxIceCream`. This method takes in two arguments:\\n\\n1. `costs`: a vector of integers representing the costs of each ice cream bar.\\n2. `coins`: an integer representing the number of coins that you have.\\n\\nThe method begins by finding the maximum element in the `costs` vector using the `max_element` function, which has a time complexity of `O(N)`, where N is the number of elements in the vector. It then initializes a new vector `count` with `N + 1` elements, all initialized to 0. This vector will keep track of the number of ice cream bars with each possible cost.\\n\\nNext, the method uses a range-based `for` loop to iterate through each element in the `costs` vector. For each iteration, it increments the element in the `count` vector at the index corresponding to the cost of the current ice cream bar.\\n\\nAfter this, the method uses another `for` loop to iterate through each element in the `count` vector. For each iteration, it checks whether the element at the current index is 0 (meaning there are no ice cream bars with that cost). If it is, the loop continues to the next iteration. Otherwise, the method checks whether `coins` is less than the current cost. If it is, the loop breaks and the method moves on to the next step. Otherwise, the method calculates the minimum of the number of ice cream bars with the current cost and the maximum number of ice cream bars that the user can afford based on the number of coins they have. It then subtracts the cost of this number of ice cream bars from `coins` and increments `bars` by the number of bars purchased.\\n\\nFinally, the method returns the value of `bars`, which is the maximum number of ice cream bars that can be bought.\\n\\n## Complexity\\n- Time complexity:\\n`O(N + M)`, where N is the total number of ice-cream bars available in the shop and M is the maximum cost of an arbitrary ice-cream bar present in the shop.\\n\\n- Space complexity:\\n`O(M)`\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int maxEl = *max_element(costs.begin(), costs.end()); // O(N)\\n        vector<int> count(maxEl + 1, 0); // O(N)\\n        int bars = 0;\\n\\n        // O(N)\\n        for (int cost : costs)\\n            count[cost]++;\\n\\n        // O(N)\\n        for (int cost = 1; cost <= maxEl; cost++) {\\n            if (count[cost] == 0)\\n                continue;\\n\\n            if (coins < cost)\\n                break;\\n            \\n            // min(max available bars in the shop, max bars that the user can afford based on the coins available)\\n            int barsQty = min(count[cost], coins / cost);\\n            coins -= cost * barsQty;\\n            bars += barsQty;\\n        }\\n\\n        return bars;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        int bars = 0;\\n\\n        for (int cost : costs) {\\n            if (coins < cost)\\n                break;\\n\\n            coins -= cost;\\n            bars++;\\n        }\\n\\n        return bars;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int maxEl = *max_element(costs.begin(), costs.end()); // O(N)\\n        vector<int> count(maxEl + 1, 0); // O(N)\\n        int bars = 0;\\n\\n        // O(N)\\n        for (int cost : costs)\\n            count[cost]++;\\n\\n        // O(N)\\n        for (int cost = 1; cost <= maxEl; cost++) {\\n            if (count[cost] == 0)\\n                continue;\\n\\n            if (coins < cost)\\n                break;\\n            \\n            // min(max available bars in the shop, max bars that the user can afford based on the coins available)\\n            int barsQty = min(count[cost], coins / cost);\\n            coins -= cost * barsQty;\\n            bars += barsQty;\\n        }\\n\\n        return bars;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007594,
                "title": "simplest-solution-with-easy-understanding-and-comments",
                "content": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        //sorting the Cost array\\n        Arrays.sort(costs);\\n        //Initialization\\n        int maxCost = 0;\\n        //returning max number of ice cream after all the cost exhausts\\n        for(int i=0; i<costs.length; i++){\\n            if(maxCost + costs[i] > coins) \\n\\t\\t\\t\\treturn i;\\n            maxCost += costs[i];\\n        }\\n        return costs.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        //sorting the Cost array\\n        Arrays.sort(costs);\\n        //Initialization\\n        int maxCost = 0;\\n        //returning max number of ice cream after all the cost exhausts\\n        for(int i=0; i<costs.length; i++){\\n            if(maxCost + costs[i] > coins) \\n\\t\\t\\t\\treturn i;\\n            maxCost += costs[i];\\n        }\\n        return costs.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007386,
                "title": "java-2-methods-sorting-stack-non-stack-approach",
                "content": "# Non Stack Approach : Using a simple counter variable -->\\n# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        if(coins < costs[0]){\\n            return 0;\\n        }\\n        int i = 0, count = 0;\\n        for(int p : costs){\\n            if(coins - p < 0){\\n                break;\\n            }\\n            else{\\n                count++;\\n                coins -= p;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n# Stack Approach\\n\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        //int count = 0;\\n        Stack<Integer> st = new Stack<>();\\n        for(int p : costs){\\n            if(coins < p){\\n                break;\\n            }\\n            else{\\n                st.push(p);\\n                coins -= p;\\n            }\\n        }\\n        return st.size();\\n    }\\n}\\n```\\n\\n# Please upvote if you like the solution \\uD83D\\uDE03",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        if(coins < costs[0]){\\n            return 0;\\n        }\\n        int i = 0, count = 0;\\n        for(int p : costs){\\n            if(coins - p < 0){\\n                break;\\n            }\\n            else{\\n                count++;\\n                coins -= p;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        //int count = 0;\\n        Stack<Integer> st = new Stack<>();\\n        for(int p : costs){\\n            if(coins < p){\\n                break;\\n            }\\n            else{\\n                st.push(p);\\n                coins -= p;\\n            }\\n        }\\n        return st.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007343,
                "title": "c-easy-code-with-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        int count = 0 ;\\n        // Sort the costs vector to purchase the cheapest items first\\n        sort (costs.begin(), costs.end());\\n        for (int i = 0 ; i<n ; i++)\\n        {\\n            // keep iterating till available coins are greater than or equal to cost of ice cream\\n            if(coins>=costs[i])\\n            {\\n                count++;\\n                coins-=costs[i];\\n                continue;\\n            }\\n            else\\n            {\\n                // if coins we have are less than cost of next ice cream break the loop and return the count \\n                break;\\n            }\\n        }\\n        return count ; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        int count = 0 ;\\n        // Sort the costs vector to purchase the cheapest items first\\n        sort (costs.begin(), costs.end());\\n        for (int i = 0 ; i<n ; i++)\\n        {\\n            // keep iterating till available coins are greater than or equal to cost of ice cream\\n            if(coins>=costs[i])\\n            {\\n                count++;\\n                coins-=costs[i];\\n                continue;\\n            }\\n            else\\n            {\\n                // if coins we have are less than cost of next ice cream break the loop and return the count \\n                break;\\n            }\\n        }\\n        return count ; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007237,
                "title": "c-easy-solution-for-beginners",
                "content": "# **C++ Easy Solution for Beginners**\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int ans=0;\\n        for(int i=0;i<costs.size();i++){\\n            if(coins>=costs[i]){\\n                ans++;\\n                coins-=costs[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n# **Please Upvote it really Motivates me\\uD83D\\uDE0A**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int ans=0;\\n        for(int i=0;i<costs.size();i++){\\n            if(coins>=costs[i]){\\n                ans++;\\n                coins-=costs[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007221,
                "title": "java-solution",
                "content": "# Intuition \\nSort the array to maximize types of ice -creams that could be bought.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply sort the array and run the loop until last, keep on adding the cost as soon as the total cost becomes greater than coins. Lets take example:\\nInput: costs = [1,3,2,4,1], coins = 7\\nOutput: 4\\nIn this case the array after sorting becomes [1,1,2,3,4].Run the loop to calculate total cost and increase the count (count variable for number of types bought)as soon as the cost becomes greater than the coins i.e in this case --> \\n0+1=1 count=1\\n1+1=2 count=2\\n2+2=4 count=3\\n4+3=7 count=4\\n7+4=11 count=5\\nSince, 11>7 break the loop and decrease count by 1.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n// Sorting the array using Arrays.sort function.\\n        int total_cost=0;int c=0;\\n        if(costs[0]>coins)return 0;\\n//if the first element of array costs is greater than available coins then no ice-cream bars can be brought.\\n        for(int i=0;i<costs.length;i++)\\n        {\\n            total_cost=total_cost+costs[i];\\n            c++;\\n//increasing the count by 1 every time cost of ice cream bar is added\\n            if(total_cost>coins)\\n           {\\n//checking if the total_cost is greater than available coins.\\n               c=c-1; \\n               break;\\n\\n\\n           } \\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n// Sorting the array using Arrays.sort function.\\n        int total_cost=0;int c=0;\\n        if(costs[0]>coins)return 0;\\n//if the first element of array costs is greater than available coins then no ice-cream bars can be brought.\\n        for(int i=0;i<costs.length;i++)\\n        {\\n            total_cost=total_cost+costs[i];\\n            c++;\\n//increasing the count by 1 every time cost of ice cream bar is added\\n            if(total_cost>coins)\\n           {\\n//checking if the total_cost is greater than available coins.\\n               c=c-1; \\n               break;\\n\\n\\n           } \\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007082,
                "title": "python-3-solution-using-greedy-t-97-s-61-memoization-tle",
                "content": "# Intuition\\nAs it\\'s an optimization problem, we can solve this either using DP or Greedy method. ****However, the constraints given here suggests that we need to implement a Greedy approch, as DP will give TLE.****\\n\\n# Approach\\n1. #### Memoization (DP)\\n    a. We need to find the recursive function.\\n    b. Base case of the recusion\\n    c. Storing the solved sub-problems.\\n    *Note : This works because we are trying all the possibilites and taking the best one out of it.*\\n2. #### Greedy\\n    a. We need to sort the costs array (ascending).\\n    b. Buy all the ice-cream bars untill we can buy no more.\\n    *Note : This is works because we want to maximize the no. of bars bought, and lower the cost of bar more more coins are left to buy rest of the bars.*\\n\\n# Complexity for Memoization\\n- n = len(costs)\\n- Time complexity: $$O(n * coins)$$\\n- Space complexity: $$O(n * coins) + O(n)$$\\n\\n# Code Memoization (TLE)\\n```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        @cache\\n        def dfs(ind, coinLeft) :\\n            if coinLeft == 0 :      # can\\'t buy more bars\\n                return 0\\n            if ind == 0 :\\n                # will buy the first bar if price <= coins left\\n                if costs[ind] <= coinLeft :   \\n                    return 1\\n                else :\\n                    return 0\\n            \\n            # not buying \\n            notTake = 0 + dfs(ind - 1, coinLeft)   \\n            take = -1 * float(\\'inf\\')\\n            # buying if we have sufficient coins left\\n            if costs[ind] <= coinLeft :\\n                take = 1 + dfs(ind - 1, coinLeft - costs[ind]) \\n\\n            return max(take, notTake)\\n\\n        return dfs(len(costs)\\xA0-\\xA01,\\xA0coins)\\n```\\n\\n# Complexity for Greedy\\n- n = len(costs)\\n- Time complexity: $$O(nlogn)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code Greedy\\n```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        costs.sort()\\n        for i, cost in enumerate(costs):\\n            # print(f\"i = {i} cost = {cost}\")\\n            coins -= cost\\n            if coins < 0:\\n                return i     # index will repesent the count of bars bought\\n        return len(costs)    # when all ice-cream bar can be bought\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Greedy",
                    "Memoization"
                ],
                "code": "```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        @cache\\n        def dfs(ind, coinLeft) :\\n            if coinLeft == 0 :      # can\\'t buy more bars\\n                return 0\\n            if ind == 0 :\\n                # will buy the first bar if price <= coins left\\n                if costs[ind] <= coinLeft :   \\n                    return 1\\n                else :\\n                    return 0\\n            \\n            # not buying \\n            notTake = 0 + dfs(ind - 1, coinLeft)   \\n            take = -1 * float(\\'inf\\')\\n            # buying if we have sufficient coins left\\n            if costs[ind] <= coinLeft :\\n                take = 1 + dfs(ind - 1, coinLeft - costs[ind]) \\n\\n            return max(take, notTake)\\n\\n        return dfs(len(costs)\\xA0-\\xA01,\\xA0coins)\\n```\n```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        costs.sort()\\n        for i, cost in enumerate(costs):\\n            # print(f\"i = {i} cost = {cost}\")\\n            coins -= cost\\n            if coins < 0:\\n                return i     # index will repesent the count of bars bought\\n        return len(costs)    # when all ice-cream bar can be bought\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3007031,
                "title": "rust-functional-style-with-comments",
                "content": "# Intuition\\nIf we only have enough money for the cheapest ice cream `i` out of `n`, then we would of course buy that one. This leaves us with a reduced problem with `n - 1` ice creams and `coins - costs[i]` to spend. In other words, we should consider the ice creams in ascending cost order.\\n\\n# Approach\\nWe use `scan` with the number of coins `left` as the algorithm state in order to have a compact functional style implementation where we reinvent the wheel as little as possible. The `.then` trick here is nice to yield `Some(())` as long as we have a positive amount of coins `left`, and `None`, terminating the iterator, when we run out of money. That way, we can simply `count` the number of ice creams that we can afford.\\n\\n# Complexity\\n- Time complexity: $$O(n \\\\log n)$$ - the sorting dominates the time complexity.\\n\\n- Space complexity: $$O(1)$$ - unstable sorts in Rust do not allocate extra space, and the algorithm state uses a single variable.\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn max_ice_cream(mut costs: Vec<i32>, coins: i32) -> i32 {\\n        costs.sort_unstable();\\n        costs.into_iter().scan(coins, |left, cost| { *left -= cost; (*left >= 0).then(|| ()) }).count() as _\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn max_ice_cream(mut costs: Vec<i32>, coins: i32) -> i32 {\\n        costs.sort_unstable();\\n        costs.into_iter().scan(coins, |left, cost| { *left -= cost; (*left >= 0).then(|| ()) }).count() as _\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3006708,
                "title": "very-easy-concept-basics-logic-c",
                "content": "\\t\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint maxIceCream(vector<int>& v, int coins) {\\n        \\n\\t\\t\\t\\tsort(v.begin(),v.end());\\n\\t\\t\\t\\t// initializing\\n\\t\\t\\t\\tint i=0;\\n\\t\\t\\t\\t//    upper_base condition\\n\\t\\t\\t\\tif(v[0]>coins){\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\twhile(coins>0&&i<v.size()){\\n\\t\\t\\t\\t\\tcoins=coins-v[i];\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t//    lower_base condition\\n\\t\\t\\t\\tif(coins<0){\\n\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn i;\\n\\t\\t\\t}\\n\\t\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint maxIceCream(vector<int>& v, int coins) {\\n        \\n\\t\\t\\t\\tsort(v.begin(),v.end());\\n\\t\\t\\t\\t// initializing\\n\\t\\t\\t\\tint i=0;\\n\\t\\t\\t\\t//    upper_base condition\\n\\t\\t\\t\\tif(v[0]>coins){\\n\\t\\t\\t\\t\\treturn 0;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 3006673,
                "title": "c-greedy-easy-clean-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt is a simple greedy problem. The idea is to pick the cheapest item first.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSort the cost array and pick the items until you run out of coins.\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int ans{};\\n        sort(begin(costs), end(costs));\\n        for(int i=0; i<costs.size(); i++){\\n            if(costs[i] <= coins){\\n                ans++;\\n                coins -= costs[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int ans{};\\n        sort(begin(costs), end(costs));\\n        for(int i=0; i<costs.size(); i++){\\n            if(costs[i] <= coins){\\n                ans++;\\n                coins -= costs[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006592,
                "title": "c-beats-100-not-sort-tc-o-n-s-c-o-n",
                "content": "Since the **constraints are not that large**, we can implement something similar to counting sort in **O(n) time** by creating a ordered associative map. But since the STL `map`  uses a self-balancing binary tree behind the scenes, **insertion operations are computationally expensive**. So, we use a **vector** instead.\\n\\n**Time Complexity: O(n)**  \\n**Space Complexity: O(n)**  \\n\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        vector<int> map(100001, 0);\\n        int i, res=0;\\n        for(auto c: costs)\\n            map[c]++;\\n        for(i=1; i<=min(100000, coins); i++){\\n            int canBuy = min(map[i], coins/i);\\n            coins-=canBuy*i;\\n            res+=canBuy;\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Note** - **To optimise space**, we might as well as have found the **max element** in costs & initialized a **vector of that size** instead of 10^5+1.   \\nFor that `int size = *max_element(costs.begin(), costs.end());` can be used.\\n\\n### Kindly upvote \\u2764\\uFE0F, if you find this  useful\\n#### Feel free to read more of my solutions at [suvraneel.software/LeetCode](https://suvraneel.software/LeetCode/) & star \\u2B50 my [GitHub repository](https://github.com/Suvraneel/Leetcode)",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        vector<int> map(100001, 0);\\n        int i, res=0;\\n        for(auto c: costs)\\n            map[c]++;\\n        for(i=1; i<=min(100000, coins); i++){\\n            int canBuy = min(map[i], coins/i);\\n            coins-=canBuy*i;\\n            res+=canBuy;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006461,
                "title": "simple-and-esay-to-understand-c",
                "content": "\\n# Complexity\\n- Time complexity:\\n**O(n)**\\n\\n- Space complexity:\\n**O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int sum =0;\\n        int count=0;\\n        for(int i=0;i<costs.size();i++){\\n            if(sum+costs[i] <= coins){\\n                sum+= costs[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int sum =0;\\n        int count=0;\\n        for(int i=0;i<costs.size();i++){\\n            if(sum+costs[i] <= coins){\\n                sum+= costs[i];\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006382,
                "title": "c-begineer-friendly-easy-understanding-2-methods-video-solution",
                "content": "# Intuition && Approach\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n**C++ Clear Explaination ,Please support if you find it usefull. Can give me feedback in comment for improvement.,will be very thankfull.**\\nhttps://www.youtube.com/watch?v=r4iDxQj78xU/\\n\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\nMethod 1:\\n- Time complexity:\\n  n O(log (n))\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n log(n)\\n\\nMethod 2:\\n- Time complexity:\\n  O(n+m)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n O(m)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Method 1.\\nclass Solution {\\npublic:\\n int maxIceCream(vector<int>& costs, int coins) {\\n                // sort the costs vector\\n        sort(costs.begin(),costs.end());\\n            // to store ans;\\n           int ans = 0;\\n\\n        // traverse and deducte the coins values.\\n        for(auto x:costs)\\n        {\\n            if(x<=coins){\\n                ans++;\\n                coins-=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Method 2.\\nclass Solution {\\npublic:\\n int maxIceCream(vector<int>& costs, int coins) {\\n\\n        // to get the size of freq array.\\n        int m = *max_element(costs.begin(),costs.end());\\n        // to store frequency use extra vector\\n        vector<int>freq(m+1,0);\\n\\n        // store the freq.\\n        for(auto x:costs){\\n            freq[x]++;\\n        }\\n\\n    // to store the ans\\n    int ans =0;\\n        // traverse on cost vector and see how many coins of that cost can be used .\\n\\n        for(int cost=1;cost<=m;cost++){\\n\\n            // if freq of that cost == 0 then no coin is avaibable move on..\\n            if(freq[cost] == 0){continue;}\\n\\n            // if i > coins left so we need to break out as enough coins are not  left.\\n            if(cost>coins){break;}\\n\\n            // else reduce the coins.\\n\\n            else{\\n             int usedcoins = min(freq[cost],coins/cost);\\n                coins -= cost*usedcoins;\\n                ans += usedcoins;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n// Method 1.\\nclass Solution {\\npublic:\\n int maxIceCream(vector<int>& costs, int coins) {\\n                // sort the costs vector\\n        sort(costs.begin(),costs.end());\\n            // to store ans;\\n           int ans = 0;\\n\\n        // traverse and deducte the coins values.\\n        for(auto x:costs)\\n        {\\n            if(x<=coins){\\n                ans++;\\n                coins-=x;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n// Method 2.\\nclass Solution {\\npublic:\\n int maxIceCream(vector<int>& costs, int coins) {\\n\\n        // to get the size of freq array.\\n        int m = *max_element(costs.begin(),costs.end());\\n        // to store frequency use extra vector\\n        vector<int>freq(m+1,0);\\n\\n        // store the freq.\\n        for(auto x:costs){\\n            freq[x]++;\\n        }\\n\\n    // to store the ans\\n    int ans =0;\\n        // traverse on cost vector and see how many coins of that cost can be used .\\n\\n        for(int cost=1;cost<=m;cost++){\\n\\n            // if freq of that cost == 0 then no coin is avaibable move on..\\n            if(freq[cost] == 0){continue;}\\n\\n            // if i > coins left so we need to break out as enough coins are not  left.\\n            if(cost>coins){break;}\\n\\n            // else reduce the coins.\\n\\n            else{\\n             int usedcoins = min(freq[cost],coins/cost);\\n                coins -= cost*usedcoins;\\n                ans += usedcoins;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006370,
                "title": "c-two-approaches-sorting-counting-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n    \\n    Approach : Sorting + Greedy\\n    \\n    T.C : O(N*logN)\\n    S.C : O(1)\\n    \\n    */\\n    \\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        sort(costs.begin(),costs.end());\\n        for(int i=0;i<n;i++){\\n            coins-=costs[i];\\n            if(coins < 0) return i;\\n        }\\n        return n;\\n    }\\n    \\n    /*\\n    \\n    Approach : Counting Sort + Greedy\\n    \\n    T.C : O(N+M)\\n    S.C : O(M)\\n    \\n    where M : maximum cost of an ice-cream.\\n    \\n    */\\n    \\n    int maxIceCream2(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        int maxCost = *max_element(costs.begin(),costs.end());\\n        vector<int>freq(maxCost+1,0);\\n        for(int &ele:costs){\\n            freq[ele]++;\\n        }\\n        int pick = 0;\\n        for(int i=1;i<=maxCost;i++){\\n            int curr = coins / i;\\n            curr = min(curr,freq[i]);\\n            pick += curr;\\n            coins -= (curr*i);\\n        }\\n        return pick;\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy",
                    "Sorting",
                    "Counting Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    /*\\n    \\n    Approach : Sorting + Greedy\\n    \\n    T.C : O(N*logN)\\n    S.C : O(1)\\n    \\n    */\\n    \\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        sort(costs.begin(),costs.end());\\n        for(int i=0;i<n;i++){\\n            coins-=costs[i];\\n            if(coins < 0) return i;\\n        }\\n        return n;\\n    }\\n    \\n    /*\\n    \\n    Approach : Counting Sort + Greedy\\n    \\n    T.C : O(N+M)\\n    S.C : O(M)\\n    \\n    where M : maximum cost of an ice-cream.\\n    \\n    */\\n    \\n    int maxIceCream2(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        int maxCost = *max_element(costs.begin(),costs.end());\\n        vector<int>freq(maxCost+1,0);\\n        for(int &ele:costs){\\n            freq[ele]++;\\n        }\\n        int pick = 0;\\n        for(int i=1;i<=maxCost;i++){\\n            int curr = coins / i;\\n            curr = min(curr,freq[i]);\\n            pick += curr;\\n            coins -= (curr*i);\\n        }\\n        return pick;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006267,
                "title": "counting-sort-simple-approach",
                "content": "# Intuition\\nBuying least expensive icecreams everytime to maximize the number of icecreams.\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach1 \\nBy using **comparison based** sorting algorithms.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(TimSort)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int: \\n        return sum(i <= coins for i in accumulate(sorted(costs)))\\n```\\n# Approach2 \\nBy using **counting sort** alogrithm for solving in linear time.\\nwe find the count of those icecreams which we could buy.\\nHence making count array upto **min(coins,max(costs)).**\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(min(coins,max(costs))+1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int: \\n        count = [0] * (min(coins,max(costs))+1)\\n        for i in costs:\\n            if i <= coins:\\n                count[i] += 1\\n        \\n        ans = 0 \\n        for i,j in enumerate(count[1:],1):\\n            if j * i <= coins:\\n                ans += j \\n                coins -= j * i \\n            else:\\n                ans += coins // i\\n                break\\n        return ans  \\n\\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int: \\n        return sum(i <= coins for i in accumulate(sorted(costs)))\\n```\n```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int: \\n        count = [0] * (min(coins,max(costs))+1)\\n        for i in costs:\\n            if i <= coins:\\n                count[i] += 1\\n        \\n        ans = 0 \\n        for i,j in enumerate(count[1:],1):\\n            if j * i <= coins:\\n                ans += j \\n                coins -= j * i \\n            else:\\n                ans += coins // i\\n                break\\n        return ans  \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006215,
                "title": "c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int ans = 0;\\n        sort(costs.begin(), costs.end());\\n        for(int i=0; i<costs.size(); i++) {\\n            if(costs[i] <= coins) {\\n                coins -= costs[i];\\n                ans++;\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int ans = 0;\\n        sort(costs.begin(), costs.end());\\n        for(int i=0; i<costs.size(); i++) {\\n            if(costs[i] <= coins) {\\n                coins -= costs[i];\\n                ans++;\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006171,
                "title": "python-solution-using-for-loop-and-sorting",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* The basic Approach is that you can buy more iceCream if they are cheap and less if they are expensive. So, why don\\'t we buy the cheap one first and then check how many can we buy.\\n* So we will sort the array so that it can have cheaper ones of left side and expensive ones on right side.\\n* Then simply take a count variable and a sum variable which is used to calculate how much we have spend.\\n* Iterate over the sorted array and check if you buy the iceCream at the i-th index we can afford it or not if yes then count += 1 else return count.\\n  \\n \\n# Complexity\\n- Time complexity: O(n) : O(n log n) + O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        count = 0\\n        sum = 0\\n        costs.sort()\\n        for i in range(len(costs)):\\n            sum += costs[i]\\n            if sum > coins:\\n                return count\\n            elif sum <= coins:\\n                count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        count = 0\\n        sum = 0\\n        costs.sort()\\n        for i in range(len(costs)):\\n            sum += costs[i]\\n            if sum > coins:\\n                return count\\n            elif sum <= coins:\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006167,
                "title": "java-solution-optimized-approach-beats-100",
                "content": "# Intuition\\nHere we can see that we need to buy ice creams bars from minimum cost to maximum cost i.e. if we sort the costs array or count the frequency of the costs we can easily calculate the no. of bars we can buy with the given coins.\\n\\n# Approach\\n1. we can sort the array and count the bars we can buy and reduce the coins we have in each iteration. Time Complexity is O(nlogn).\\n2. We can count the frequency of the costs and get the no. of bars we can buy with the given coins in each iteration, also keep track of total count. Time Complexity is O(N + M). \\n\\n# Complexity\\n- Time complexity:O(N + M)\\n\\n- Space complexity: O(M) where M is maximum cost\\n\\n**Please upvote if you find this solution helpful. Thanks in Advance.**\\n# Code\\n```\\nclass Solution {\\n    public int getMaxCost(int[] costs){\\n        // initialization\\n        int max = 0;\\n\\n        // iterate over the costs\\n        for(int index = 0;index < costs.length;index++){\\n            max = Math.max(max, costs[index]);\\n        }\\n\\n        return max;\\n    }\\n    public int maxIceCream(int[] costs, int coins) {\\n       // edge cases\\n        if(costs == null || costs.length == 0){\\n            return 0;\\n        }\\n        // initialization\\n        // get the max cost\\n        int maxCost = getMaxCost(costs);\\n        int countBars = 0;\\n        int[] countCosts = new int[maxCost + 1];\\n\\n        // count the frequency of costs\\n        for(int cost : costs){\\n            countCosts[cost]++;\\n        }\\n        \\n        // iterate over the countCosts array\\n        for(int cost = 0;cost < countCosts.length;cost++){\\n            // when count is 0\\n            if(countCosts[cost] == 0){\\n                continue;\\n            }\\n            // when we have less coins\\n            if(coins < cost){\\n                break;\\n            }\\n            // buy possible no. ice cream bars\\n            int count = Math.min(countCosts[cost], coins / cost);\\n            coins -= count * cost;\\n            countBars += count;\\n        }\\n\\n        return countBars;\\n    }\\n}\\n```\\n\\n**Please upvote if you find this solution helpful. Thanks in Advance.**",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int getMaxCost(int[] costs){\\n        // initialization\\n        int max = 0;\\n\\n        // iterate over the costs\\n        for(int index = 0;index < costs.length;index++){\\n            max = Math.max(max, costs[index]);\\n        }\\n\\n        return max;\\n    }\\n    public int maxIceCream(int[] costs, int coins) {\\n       // edge cases\\n        if(costs == null || costs.length == 0){\\n            return 0;\\n        }\\n        // initialization\\n        // get the max cost\\n        int maxCost = getMaxCost(costs);\\n        int countBars = 0;\\n        int[] countCosts = new int[maxCost + 1];\\n\\n        // count the frequency of costs\\n        for(int cost : costs){\\n            countCosts[cost]++;\\n        }\\n        \\n        // iterate over the countCosts array\\n        for(int cost = 0;cost < countCosts.length;cost++){\\n            // when count is 0\\n            if(countCosts[cost] == 0){\\n                continue;\\n            }\\n            // when we have less coins\\n            if(coins < cost){\\n                break;\\n            }\\n            // buy possible no. ice cream bars\\n            int count = Math.min(countCosts[cost], coins / cost);\\n            coins -= count * cost;\\n            countBars += count;\\n        }\\n\\n        return countBars;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006039,
                "title": "simple-c-solution-easy-approach",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        int ans = 0;\\n        for(auto &i : costs){\\n            if(i > coins){return ans;}\\n            ans++;\\n            coins -= i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```\\n\\n#### *If you find it useful the do upvote! Happy Coding!!!*",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        int ans = 0;\\n        for(auto &i : costs){\\n            if(i > coins){return ans;}\\n            ans++;\\n            coins -= i;\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005923,
                "title": "fastest-java-soln",
                "content": "# Intuition\\nIf the boy wants to buy the maximum number of ice cream then he should prefer the cheaper ones first.\\n\\n# Approach\\nWe first sort he array in ascending order,hence we obtain the cheaper ones first.\\nNow,we traverse through this sorted array and check if we have enough coins to buy the icecreams at each step.\\nWe decrement the coins by the cost[i] every time the boy buys an icecream.\\nWe increment a counter variable(c) everytime we the boy buys an icecream.\\n\\n\\n# Complexity\\n- Time complexity:\\nO(nlogn)\\n\\n- Space complexity:\\nO(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n      int c=0;\\n      int l = costs.length;\\n      Arrays.sort(costs);\\n      for(int i=0;i<l;i++)\\n      {\\n          if(coins>=costs[i])\\n          {\\n              c++;\\n              coins-=costs[i];\\n          }\\n      }  \\n      return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n      int c=0;\\n      int l = costs.length;\\n      Arrays.sort(costs);\\n      for(int i=0;i<l;i++)\\n      {\\n          if(coins>=costs[i])\\n          {\\n              c++;\\n              coins-=costs[i];\\n          }\\n      }  \\n      return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005918,
                "title": "easy-greedy-approach-c-javascript-and-java",
                "content": "# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int ans=0;\\n        sort(costs.begin(),costs.end());\\n        for(auto &i:costs)\\n        {\\n            if(coins>=i)\\n            {\\n                coins-=i;\\n                ans++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n# JavaScript Code\\n```\\n/**\\n * @param {number[]} costs\\n * @param {number} coins\\n * @return {number}\\n */\\nvar maxIceCream = function(costs, coins) {\\n//comparator function because in js sorting is done lexicographically.\\n    costs.sort((a,b)=>{\\n        return a-b;\\n    });\\n    // console.log(costs);\\n    let ans=0;\\n    for(let i=0;i<costs.length;i++)\\n    {\\n        if(coins>=costs[i])\\n        {\\n            // console.log(i);\\n            coins-=costs[i];\\n            ans++;\\n        }\\n        else{\\n            break;\\n        }\\n    }\\n    return ans;\\n};\\n```\\n\\n# Java Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int ans=0;\\n        Arrays.sort(costs);\\n        for(int i:costs)\\n        {\\n            if(coins>=i)\\n            {\\n                coins-=i;\\n                ans++;\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n}\\n```\\nPS: Try this using priority queue and if possible comment your code.\\nHappy Coding \\uD83E\\uDDD1\\u200D\\uD83D\\uDCBB",
                "solutionTags": [
                    "C++",
                    "Java",
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int ans=0;\\n        sort(costs.begin(),costs.end());\\n        for(auto &i:costs)\\n        {\\n            if(coins>=i)\\n            {\\n                coins-=i;\\n                ans++;\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\n/**\\n * @param {number[]} costs\\n * @param {number} coins\\n * @return {number}\\n */\\nvar maxIceCream = function(costs, coins) {\\n//comparator function because in js sorting is done lexicographically.\\n    costs.sort((a,b)=>{\\n        return a-b;\\n    });\\n    // console.log(costs);\\n    let ans=0;\\n    for(let i=0;i<costs.length;i++)\\n    {\\n        if(coins>=costs[i])\\n        {\\n            // console.log(i);\\n            coins-=costs[i];\\n            ans++;\\n        }\\n        else{\\n            break;\\n        }\\n    }\\n    return ans;\\n};\\n```\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int ans=0;\\n        Arrays.sort(costs);\\n        for(int i:costs)\\n        {\\n            if(coins>=i)\\n            {\\n                coins-=i;\\n                ans++;\\n            }\\n            else break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005890,
                "title": "daily-leetcode-challenge-python-3",
                "content": "# Intuition\\nTo get the maximum amount of icecream in given coins the basic idea is to choose as cheap as icecreams possible.\\nFor this we will make the array sorted in increasing order first.\\nFor early return of function where it hits the base case of having less coins than req to purchase atleast one icecream compare it to first array element and if smaller return 0 as the child wont be able to buy any icecream. (though this is an optional condition)\\nNow for the main cases keep increasing the count of icecream untill and unless the sum==coins available to him.\\nThat is our required answer.\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        costs.sort() \\n        if coins < costs[0]:\\n            return 0\\n        iceCream = 0\\n        summ = 0\\n        for c in costs:\\n            summ += c\\n            if summ <= coins:\\n                iceCream += 1\\n        return iceCream\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        costs.sort() \\n        if coins < costs[0]:\\n            return 0\\n        iceCream = 0\\n        summ = 0\\n        for c in costs:\\n            summ += c\\n            if summ <= coins:\\n                iceCream += 1\\n        return iceCream\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005860,
                "title": "java-solution-3-liner-code",
                "content": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n       Arrays.sort(costs);\\n       for(int i=0;i<costs.length;i++){\\n           if ((coins -= costs[i])< 0)\\n                return i;\\n       }\\n        return costs.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n       Arrays.sort(costs);\\n       for(int i=0;i<costs.length;i++){\\n           if ((coins -= costs[i])< 0)\\n                return i;\\n       }\\n        return costs.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005781,
                "title": "c-sorting-greedy-tc-o-nlogn-sc-o-1-easy-simple",
                "content": "# Complexity\\n- Time complexity: O(nlogn) because sorting technique was used.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1) no extra space was used.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        if(costs[0]>coins)  return 0;\\n        int cnt=0;\\n        for(int i=0;i<costs.size();i++){\\n            if(coins>=costs[i]){\\n                coins-=costs[i];\\n                cnt++;\\n            }\\n            else return cnt;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        if(costs[0]>coins)  return 0;\\n        int cnt=0;\\n        for(int i=0;i<costs.size();i++){\\n            if(coins>=costs[i]){\\n                coins-=costs[i];\\n                cnt++;\\n            }\\n            else return cnt;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005654,
                "title": "daily-leetcode-challenge-day-6-detailed-expalnation-c-solution",
                "content": "# Approach\\nHere is an algorithm for the below solution:\\n\\n1. Sort the vector of costs in ascending order.\\n2. Initialize a count variable to 0. This will be used to track the number of ice cream cones that can be purchased.\\n3. Iterate through the costs vector. For each element in the vector:\\n    - a. If the current cost is less than or equal to the number of coins, increment the count variable and subtract the cost from the number of coins.\\n    - b. If the current cost is greater than the number of coins, exit the loop.\\n    - c. Return the count variable as the result.\\n    \\nThis algorithm will allow a person to purchase as many ice cream cones as possible, starting with the lowest cost cones first. Once the number of coins is insufficient to purchase the next lowest cost cone, the loop will exit and the current count will be returned as the result.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: **O(nlogn)** // where n is the size of vector\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# C++ Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        int count = 0; // it counts maximum number of ice cream bars the boy can buy with coins.\\n        for(int i = 0; i < costs.size(); i++){\\n            if(coins >= costs[i]){\\n                count++;\\n                coins = coins - costs[i];\\n            }\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        int count = 0; // it counts maximum number of ice cream bars the boy can buy with coins.\\n        for(int i = 0; i < costs.size(); i++){\\n            if(coins >= costs[i]){\\n                count++;\\n                coins = coins - costs[i];\\n            }\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005648,
                "title": "easy-and-understandable-cpp-solution-simple-solution",
                "content": "# Intuition: \\nSort the given array.\\n# Approach:\\nSort the array to get ice cream with minimum cost in the beginning so that I can buy maximum Ice cream, then I reduces the costs of each ice cream by traversing the whole array.\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//Saurav Farkade\\n//Walchand College of Engineering, Sangli\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int i=0;\\n        sort(costs.begin(), costs.end());\\n        for( i=0;i<costs.size()&&coins>=costs[i];i++)\\n            if(coins>=costs[i]) coins-=costs[i];\\n        return i;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting",
                    "Counting"
                ],
                "code": "```\\n//Saurav Farkade\\n//Walchand College of Engineering, Sangli\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int i=0;\\n        sort(costs.begin(), costs.end());\\n        for( i=0;i<costs.size()&&coins>=costs[i];i++)\\n            if(coins>=costs[i]) coins-=costs[i];\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005619,
                "title": "short-clean-sorting-easy-java",
                "content": "\\n```java []\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int ic = 0;\\n        while(coins > 0 && ic < costs.length){\\n            if(costs[ic] > coins)   return ic;\\n            coins -= costs[ic];\\n            ic++;\\n        }\\n        return ic;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java []\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int ic = 0;\\n        while(coins > 0 && ic < costs.length){\\n            if(costs[ic] > coins)   return ic;\\n            coins -= costs[ic];\\n            ic++;\\n        }\\n        return ic;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005593,
                "title": "java-simple-one",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int c=0;\\n        for(int i:costs){\\n            if(i<=coins){c++;coins-=i;}\\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int c=0;\\n        for(int i:costs){\\n            if(i<=coins){c++;coins-=i;}\\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005502,
                "title": "easy-solution",
                "content": "\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(NlogN)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int c=0;\\n        for(auto a:costs){\\n            if(coins>=a){\\n                c++;coins-=a;\\n            }\\n            else break;\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int c=0;\\n        for(auto a:costs){\\n            if(coins>=a){\\n                c++;coins-=a;\\n            }\\n            else break;\\n        }\\n        return c;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005478,
                "title": "c-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n- To buy maximum number of Ice Creams you should start buying with cheapest cost.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Sort the costs in ascending order and then count the ice cream until the current costs is greater than remaining coins.\\n\\n# Complexity\\n- Time complexity:$$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int count=0;\\n        for(int i=0;i<costs.size();i++)\\n        {\\n            if(coins-costs[i]>=0)\\n            {\\n                count++;\\n                coins-=costs[i];\\n            }\\n            else\\n                break;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int count=0;\\n        for(int i=0;i<costs.size();i++)\\n        {\\n            if(coins-costs[i]>=0)\\n            {\\n                count++;\\n                coins-=costs[i];\\n            }\\n            else\\n                break;\\n        }\\n        return count;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005443,
                "title": "c-2-approaches-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nGet the bar with minimum cost till coins are exhausted or cost of bar is greater than remaining coins \\n# Approach 1\\nSort the costs array\\nStart with minimum cost bar and check if we have enough coins to buy that bar. \\n- If yes, buy the bar , increase answer by 1 ,and reduce remaining coins by the cost of bar. \\n- If no, break the iteration as zero bars can be bought next as we have bars with higher costs later on.\\n\\n\\n# Complexity\\n- Time complexity : $$O(nlogn)$$\\n- Space complexity : $$O(1)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) \\n    {\\n        sort(costs.begin(),costs.end());\\n\\n        int ans=0;\\n        for(int index=0 ; index<costs.size() ; index++)\\n        {\\n            if(coins-costs[index]>=0) ans++ , coins-=costs[index];\\n            else break;\\n        }    \\n        return ans;\\n    }\\n};\\n```\\n# Approach 2\\nStore the frequencies of all costs in a vector.\\n- Start by checking the frequency of minimum cost ie 1.\\n- Count the maximum number of bars that can be bought with remaining coins \\n- If the cost of bar is greater than remaining coins , then break the iteration as no bar can be bought with remaining coins. \\n\\n\\n# Complexity\\n- Time complexity :  $$O(n)$$\\n- Space complexity :  $$O(n)$$\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) \\n    {\\n        auto max_ind=max_element(costs.begin(),costs.end());\\n\\n        vector<int>freq(*max_ind+1);\\n        for(int cost:costs) freq[cost]++;\\n\\n        int ans=0;\\n\\n        for(int cost=1;cost<freq.size();cost++)\\n        {\\n            if(coins<cost) break;\\n            \\n            int count=min(coins/cost,freq[i]);\\n            ans+=count;\\n            coins-=count*cost;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) \\n    {\\n        sort(costs.begin(),costs.end());\\n\\n        int ans=0;\\n        for(int index=0 ; index<costs.size() ; index++)\\n        {\\n            if(coins-costs[index]>=0) ans++ , coins-=costs[index];\\n            else break;\\n        }    \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) \\n    {\\n        auto max_ind=max_element(costs.begin(),costs.end());\\n\\n        vector<int>freq(*max_ind+1);\\n        for(int cost:costs) freq[cost]++;\\n\\n        int ans=0;\\n\\n        for(int cost=1;cost<freq.size();cost++)\\n        {\\n            if(coins<cost) break;\\n            \\n            int count=min(coins/cost,freq[i]);\\n            ans+=count;\\n            coins-=count*cost;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005383,
                "title": "c-greedy-approach-beats-100-solution",
                "content": "# Intuition\\nTo buy maximum number of Ice Creams you should start buying with cheapest cost.\\n\\n# Approach\\nSort the costs in ascending order and then count the ice cream until the current costs is less than coins given.\\n\\n# Complexity \\nTime complexity:  O(nlog(n))\\nSpace complexity: O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n\\n        int ans=0;\\n        int bars=0;\\n        for(int i=0;i<costs.size();i++){\\n            if(ans+costs[i]<=coins){\\n                ans+=costs[i];\\n                bars++;\\n            }\\n        }\\n        return bars;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n\\n        int ans=0;\\n        int bars=0;\\n        for(int i=0;i<costs.size();i++){\\n            if(ans+costs[i]<=coins){\\n                ans+=costs[i];\\n                bars++;\\n            }\\n        }\\n        return bars;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005368,
                "title": "javascript-neat-2-greedy-methods-sort-counting-sort",
                "content": "## 1. Sort\\nTime complexity: $$O(n \\\\cdot log n)$$\\n```js\\nconst maxIceCream = (costs, coins) => {\\n    costs.sort((a, b) => a - b)\\n    for (var i = 0; i < costs.length && costs[i] <= coins; ++i)\\n        coins -= costs[i]\\n    return i\\n}\\n```\\n\\n## 2. Counting sort\\nTime complexity: $$O(n)$$\\n```js\\nconst maxIceCream = (costs, coins) => {\\n    const frequencies = Array(Math.max(...costs) + 1).fill(0)\\n    for (const cost of costs)\\n        frequencies[cost] += 1\\n    let bars = 0\\n    for (let cost = 1; cost <= coins && cost < frequencies.length; ++cost) {\\n        const count = Math.min(frequencies[cost], Math.floor(coins / cost))\\n        coins -= cost * count\\n        bars += count\\n    }\\n    return bars\\n}\\n```\\nRuntime 150 ms, Beats 100%\\n\\nA variation\\n```js\\nconst maxIceCream = (costs, coins) => {\\n    const frequencies = costs.reduce((f, cost) => (f[cost] = -~f[cost], f), {})\\n    let bars = 0\\n    for (const cost in frequencies) {\\n        const count = Math.min(frequencies[cost], Math.floor(coins / cost))\\n        if (coins < count)\\n            break\\n        coins -= cost * count\\n        bars += count\\n    }\\n    return bars\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\nconst maxIceCream = (costs, coins) => {\\n    costs.sort((a, b) => a - b)\\n    for (var i = 0; i < costs.length && costs[i] <= coins; ++i)\\n        coins -= costs[i]\\n    return i\\n}\\n```\n```js\\nconst maxIceCream = (costs, coins) => {\\n    const frequencies = Array(Math.max(...costs) + 1).fill(0)\\n    for (const cost of costs)\\n        frequencies[cost] += 1\\n    let bars = 0\\n    for (let cost = 1; cost <= coins && cost < frequencies.length; ++cost) {\\n        const count = Math.min(frequencies[cost], Math.floor(coins / cost))\\n        coins -= cost * count\\n        bars += count\\n    }\\n    return bars\\n}\\n```\n```js\\nconst maxIceCream = (costs, coins) => {\\n    const frequencies = costs.reduce((f, cost) => (f[cost] = -~f[cost], f), {})\\n    let bars = 0\\n    for (const cost in frequencies) {\\n        const count = Math.min(frequencies[cost], Math.floor(coins / cost))\\n        if (coins < count)\\n            break\\n        coins -= cost * count\\n        bars += count\\n    }\\n    return bars\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3005341,
                "title": "c-greedy-detailed-explanation-o-nlogn",
                "content": "# Intuition\\n- Aim : maximum number of icecream buy but he has limited money . \\n- 10 Rs in hand \\nIce1 = Rs1   Ice-2= Rs9 \\n- Which should be buy ? Definetly Ice1 \\nbecause : \\nRs1 -> count increase by 1 \\nRs9 -> count increase by 1 \\nthis saved 9 rs may use for another cnt increase \\n\\n- SO we should buy in their incrasing order of coins Required . \\n\\n# Approach\\nAlgo : \\n1) sort the array (cost of icecream)\\n2) Traverse array 0 to n-1 : \\n   buy if possible ( cost[i] <= coins ) & incrase cnt by 1 .\\n\\n# Complexity\\n- Time complexity: O (N LogN ) ( sorting takes Nlogn + travesing N)\\n\\n- Space complexity:O(1) (constant extra space used ).\\n\\n# Plz , Upvote If Solution is helpful to You in any way . \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int cnt = 0 ;\\n        sort(costs.begin(),costs.end()); // sort \\n        for( int i = 0 ; i < costs.size() ; ++i ) // travese chepest to larger cost icecrems \\n        {\\n            if( costs[i] <= coins) // if possible then buy\\n            {\\n                ++cnt;\\n                coins -= costs[i];\\n            }\\n            else \\n            {\\n                break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int cnt = 0 ;\\n        sort(costs.begin(),costs.end()); // sort \\n        for( int i = 0 ; i < costs.size() ; ++i ) // travese chepest to larger cost icecrems \\n        {\\n            if( costs[i] <= coins) // if possible then buy\\n            {\\n                ++cnt;\\n                coins -= costs[i];\\n            }\\n            else \\n            {\\n                break;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005335,
                "title": "rust-sorting-vs-counting",
                "content": "Big-O is different, but they have nearly the same actual runtime.\\n# Sorting\\nO(n*log(n)), 28ms\\n```rust\\nimpl Solution {\\n    pub fn max_ice_cream(mut costs: Vec<i32>, mut coins: i32) -> i32 {\\n        costs.sort_unstable();\\n        let mut ans = 0;\\n        for &x in costs.iter() {\\n            if coins < x {\\n                break;\\n            }\\n            coins -= x;\\n            ans += 1;\\n        }\\n        ans\\n    }\\n}\\n```\\n# Counting\\nO(n + costs[i]), 26ms\\n```rust\\nimpl Solution {\\n    pub fn max_ice_cream(costs: Vec<i32>, mut coins: i32) -> i32 {\\n        let mut count = vec![0; 100_001];\\n        for &x in costs.iter() {\\n            count[x as usize] += 1;\\n        }\\n        let mut ans = 0;\\n        for x in 1..100_001 {\\n            if coins < x {\\n                break;\\n            }\\n            let buy = count[x as usize].min(coins / x);\\n            coins -= buy * x;\\n            ans += buy;\\n        }\\n        ans\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Greedy",
                    "Sorting",
                    "Counting"
                ],
                "code": "```rust\\nimpl Solution {\\n    pub fn max_ice_cream(mut costs: Vec<i32>, mut coins: i32) -> i32 {\\n        costs.sort_unstable();\\n        let mut ans = 0;\\n        for &x in costs.iter() {\\n            if coins < x {\\n                break;\\n            }\\n            coins -= x;\\n            ans += 1;\\n        }\\n        ans\\n    }\\n}\\n```\n```rust\\nimpl Solution {\\n    pub fn max_ice_cream(costs: Vec<i32>, mut coins: i32) -> i32 {\\n        let mut count = vec![0; 100_001];\\n        for &x in costs.iter() {\\n            count[x as usize] += 1;\\n        }\\n        let mut ans = 0;\\n        for x in 1..100_001 {\\n            if coins < x {\\n                break;\\n            }\\n            let buy = count[x as usize].min(coins / x);\\n            coins -= buy * x;\\n            ans += buy;\\n        }\\n        ans\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3005270,
                "title": "simple-solution-using-greedy-algorithm",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst we will sort the given list `costs` in ascending order, then check if the value of `coins` is strictly less than the 1st element of the sorted `costs` list, If yes then the boy can not buy any ice cream.\\n\\nIf No, then we will iterate through the list and consider an element by subtracting subsequent costs from the coins and increment the count variable every time we consider an element from  the sorted array. We will stop iterating if we reach the end of the list or value of `coins` becomes 0, or else we stop iterating if at any point value of `coins` becomes less than `costs[i]`.\\n\\nAfter iteration is over we simply return the count.\\nThis is Greedy approach beacuse we try to get the correct answer in only one iteration by selecting the lowest costing icecream first.\\n# Code\\n```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        costs.sort()\\n        count = 0\\n        if costs[0] > coins:\\n            return 0\\n        i = 0\\n        while coins > 0 and i < len(costs):\\n            if coins < costs[i]:\\n                break\\n            coins -= costs[i]\\n            count+=1\\n            i+=1\\n        return count\\n```",
                "solutionTags": [
                    "Python3",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        costs.sort()\\n        count = 0\\n        if costs[0] > coins:\\n            return 0\\n        i = 0\\n        while coins > 0 and i < len(costs):\\n            if coins < costs[i]:\\n                break\\n            coins -= costs[i]\\n            count+=1\\n            i+=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3005149,
                "title": "js-easiest-medium-2-solutions-o-n-logn-and-o-n-commented",
                "content": "# Complexity\\n- Time complexity:\\nO(n log n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Comment\\nEach step of loop. We buy the cheapest first, if it\\'s out of\\nbudget, return :) Please upvote if you found this is helpful.\\n\\n# Code\\n```\\nvar maxIceCream = function (costs, coins) {\\n  costs.sort((a, b) => a - b);\\n  let res = 0;\\n  for (let bar of costs) {\\n    if (coins >= bar) {res++; coins -= bar;} \\n    else {break;}\\n  }\\n  return res;\\n};\\n```\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Comment\\nThis solution does not require sorting, instead we use\\nan array to count each bar\\'s amount and cost. It looks\\nmuch faster then sorting solution.\\n\\n![1.jpg](https://assets.leetcode.com/users/images/c8a6d042-1653-4c3f-a55b-38cbaf2d4fe5_1672965647.2790637.jpeg)\\n\\n\\n\\n# Code\\n```\\nvar maxIceCream = function (costs, coins) {\\n  let arr = [],res = 0;\\n  for (let i of costs) { arr[i] = (arr[i] || 0) + 1;}\\n  for (let i = 1; i < arr.length; i++) {\\n    if (coins < i) break;\\n    while (coins >= i && arr[i] > 0) {\\n      res++;\\n      coins -= i;\\n      arr[i]--;\\n    }\\n  }\\n  return res;\\n};\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxIceCream = function (costs, coins) {\\n  costs.sort((a, b) => a - b);\\n  let res = 0;\\n  for (let bar of costs) {\\n    if (coins >= bar) {res++; coins -= bar;} \\n    else {break;}\\n  }\\n  return res;\\n};\\n```\n```\\nvar maxIceCream = function (costs, coins) {\\n  let arr = [],res = 0;\\n  for (let i of costs) { arr[i] = (arr[i] || 0) + 1;}\\n  for (let i = 1; i < arr.length; i++) {\\n    if (coins < i) break;\\n    while (coins >= i && arr[i] > 0) {\\n      res++;\\n      coins -= i;\\n      arr[i]--;\\n    }\\n  }\\n  return res;\\n};\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2743750,
                "title": "c-beginner-friendly-solution-easy-optimized",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int cnt = 0;\\n        sort(costs.begin(), costs.end());\\n        for(int i = 0 ; i < costs.size() ; i++)\\n        {\\n          if(coins < costs[i]) return cnt;\\n          coins -= costs[i];\\n          cnt++;\\n        }\\n      return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int cnt = 0;\\n        sort(costs.begin(), costs.end());\\n        for(int i = 0 ; i < costs.size() ; i++)\\n        {\\n          if(coins < costs[i]) return cnt;\\n          coins -= costs[i];\\n          cnt++;\\n        }\\n      return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2632262,
                "title": "just-forgot-this-was-easy-problem",
                "content": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        for(int i=0,val=0,n=costs.length;i<n;i++){\\n            val+=costs[i];\\n            if(val>coins)return i;\\n        }\\n        return costs.length;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        for(int i=0,val=0,n=costs.length;i<n;i++){\\n            val+=costs[i];\\n            if(val>coins)return i;\\n        }\\n        return costs.length;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2350152,
                "title": "solution-via-quickselect-o-n-compute-102ms-o-1-storage-via-count-sort-o-n-o-c-o-c-storage",
                "content": "# Introduction\\n\\nThere are several $O(N \\\\log N)$ solutions for this problem:\\n* Sort the whole array and choose solution in a greedy-manner\\n* Make min-heap and extract elements while their sum is less than number of coins (slightly faster, but still need to build heap for the whole array)\\n\\nHowever, problem admits two $O(N)$ solutions:\\n - Quick-select with $O(1)$ storage requirements; this solution is somewhat elaborated\\n - Count-sort with $O(C)$ storage requirements (where $C=10^5$ is the maximum cost of ice-cream bar); this solution is very simple\\n\\n# Quick-select solution\\n\\nLet us make three additional observations:\\n* If sum of $M$ smallest elements is less than number of coins $\\\\Rightarrow$ all $M$ of these elements should be included into solution\\n* If sum of $M$ smallest elements is larger than number of coins $\\\\Rightarrow$ no other elements will be included into solution\\n* When partitioning array into elements smaller / larger than pivot, sum of elements smaller than pivot can be computed with minimal computational overhead\\n\\nThose three observations allow us to construct a quick-select alike algorithm that operates as follows:\\n* Partition array into elements smaller / larger than pivot, computing sum of elements smaller than pivot\\n* If sum of smallest elements is larger, than number of coins - forget about larger values and recurse into left segment\\n* If sum of smallest elements is smaller, than number of coins - subtract that sum from number of coins and recurse into right segment\\n\\n## Tricks for faster solution\\n\\nThis gives you 100..200ms level solution, my 102ms submission: https://leetcode.com/submissions/detail/759773865/\\nAchieving lower 100ms requires some tweaking:\\n* Since there can be up to $10^8$ bars, but costs are limited to $10^5$ => there might be lots of repetitions, thus it is better to partition array into three parts:  [smaller | equal | greater], then skip elements equal to pivot completely with some basic calculations\\n* A couple of ms can be shaved off by not computing sum once it turns out to be larger, than number of coins (we still need to finish partitioning though).\\n\\n## Complexity\\n\\nTime complexity analysis is the same as a regular randomized quick-select algorithm for finding $k$-th smallest element, resulting into $O(N)$ on average.\\n\\nSpace complexity is $O(1)$ if we\\'re allowed to modify input array.\\n\\n\\n## Solution\\nSolution with all tricks included:\\n```\\nstatic int speed = [](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int solve(int* left, int* right, int coins) {\\n        int res = 0;\\n        while (coins && right > left) {\\n            const int pivot = left[rand() % (right - left)];\\n\\t\\t\\t\\n\\t\\t\\t// after end of iteration this should be the last index of values equal to pivot\\n            auto eq_r = left;\\n\\t\\t\\t// after end of iteration this should be the first index of values greater than pivot\\n            auto gt_l = right;\\n\\n\\t\\t\\t// sum of values less than pivot\\n            int left_sum = 0;\\n            auto it = left;\\n\\t\\t\\t// partition values while accumulating sum of coins with value less than pivot\\n            while (it != gt_l && left_sum <= coins) {\\n                int v = *it;\\n                if (v == pivot) {\\n                    *it++ = *eq_r++;\\n                    continue;\\n                }\\n                if (v < pivot) {\\n                    left_sum += v;\\n                    ++it;\\n                } else {\\n                    std::swap(*it, *--gt_l);\\n                }\\n            }\\n\\t\\t\\t// if sum of coins to the left is grater than target, we still need to partition the rest of values,\\n\\t\\t\\t// but can omit maintaining a correct value of the sum\\n            while (it != gt_l) {\\n                int v = *it;\\n                if (v == pivot) {\\n                    *it++ = *eq_r++;\\n                    continue;\\n                }\\n                if (v < pivot) {\\n                    ++it;\\n                } else {\\n                    std::swap(*it, *--gt_l);\\n                }\\n            }\\n        \\n            // Not enough value in smaller coins, need to either add some coins\\n\\t\\t\\t// equal to pivot, or even larger coins\\n            if (left_sum <= coins) {\\n                coins -= left_sum;\\n                int eq_cnt = coins / pivot;\\n                int real_eq = eq_r - left;\\n\\n\\t\\t\\t\\t// need at least as much coins valued as pivot as we have\\n                if (eq_cnt >= real_eq) {\\n                    coins -= real_eq * pivot;\\n                    res += gt_l - left;\\n                    if (coins <= pivot) {\\n                        coins = 0;\\n                        break;\\n                    }\\n                    left = gt_l;\\n                    continue;\\n                }\\n\\t\\t\\t\\t// we have enough pivot-valued coins to fullfill the target\\n                res += (gt_l - eq_r) + eq_cnt;\\n                coins = 0;\\n                break;\\n            }\\n\\t\\t\\t// Sum of coins with value less than pivot is larger than target,\\n\\t\\t\\t// so we need to select from them.\\n\\t\\t\\t// Since we kept coins equal to the pivot at the left side of the\\n\\t\\t\\t// array, we need to skip them\\n            left = eq_r;\\n            right = gt_l;\\n        }\\n        return res;\\n    }\\n    \\n    int maxIceCream(vector<int>& costs, int coins) {\\n        auto it = solve(costs.data(), costs.data() + costs.size(), coins);\\n        return it;\\n    }\\n};\\n```\\n\\n# Count-sort solution:\\n\\nAnother option for achieving $O(N)$ is to exploit the upper limit on cost being just $C=10^5$.\\n\\nThis allows to sort costs of ice-cream bars using count sort, followed by computing number of ice-cream bars boy can buy using given number of coins.\\n\\nThis allows one to get a simple solution with $O(N) + O(C)$ compute complexity and $O(C)$ memory consumption.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        constexpr int MAX_COST = 100001;\\n        int cnt[MAX_COST] = {0};\\n        for (auto& c: costs) {\\n            ++cnt[c];\\n        }\\n        int res = 0;\\n        for (int i = 1; i < MAX_COST && coins >= i; ++i) {\\n            if (!cnt[i]) continue;\\n            int buy = std::min(coins / i, cnt[i]);\\n            coins -= buy * i;\\n            res += buy;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstatic int speed = [](){\\n    ios::sync_with_stdio(false);\\n    cin.tie(nullptr);\\n    cout.tie(nullptr);\\n    return 0;\\n}();\\n\\nclass Solution {\\npublic:\\n    int solve(int* left, int* right, int coins) {\\n        int res = 0;\\n        while (coins && right > left) {\\n            const int pivot = left[rand() % (right - left)];\\n\\t\\t\\t\\n\\t\\t\\t// after end of iteration this should be the last index of values equal to pivot\\n            auto eq_r = left;\\n\\t\\t\\t// after end of iteration this should be the first index of values greater than pivot\\n            auto gt_l = right;\\n\\n\\t\\t\\t// sum of values less than pivot\\n            int left_sum = 0;\\n            auto it = left;\\n\\t\\t\\t// partition values while accumulating sum of coins with value less than pivot\\n            while (it != gt_l && left_sum <= coins) {\\n                int v = *it;\\n                if (v == pivot) {\\n                    *it++ = *eq_r++;\\n                    continue;\\n                }\\n                if (v < pivot) {\\n                    left_sum += v;\\n                    ++it;\\n                } else {\\n                    std::swap(*it, *--gt_l);\\n                }\\n            }\\n\\t\\t\\t// if sum of coins to the left is grater than target, we still need to partition the rest of values,\\n\\t\\t\\t// but can omit maintaining a correct value of the sum\\n            while (it != gt_l) {\\n                int v = *it;\\n                if (v == pivot) {\\n                    *it++ = *eq_r++;\\n                    continue;\\n                }\\n                if (v < pivot) {\\n                    ++it;\\n                } else {\\n                    std::swap(*it, *--gt_l);\\n                }\\n            }\\n        \\n            // Not enough value in smaller coins, need to either add some coins\\n\\t\\t\\t// equal to pivot, or even larger coins\\n            if (left_sum <= coins) {\\n                coins -= left_sum;\\n                int eq_cnt = coins / pivot;\\n                int real_eq = eq_r - left;\\n\\n\\t\\t\\t\\t// need at least as much coins valued as pivot as we have\\n                if (eq_cnt >= real_eq) {\\n                    coins -= real_eq * pivot;\\n                    res += gt_l - left;\\n                    if (coins <= pivot) {\\n                        coins = 0;\\n                        break;\\n                    }\\n                    left = gt_l;\\n                    continue;\\n                }\\n\\t\\t\\t\\t// we have enough pivot-valued coins to fullfill the target\\n                res += (gt_l - eq_r) + eq_cnt;\\n                coins = 0;\\n                break;\\n            }\\n\\t\\t\\t// Sum of coins with value less than pivot is larger than target,\\n\\t\\t\\t// so we need to select from them.\\n\\t\\t\\t// Since we kept coins equal to the pivot at the left side of the\\n\\t\\t\\t// array, we need to skip them\\n            left = eq_r;\\n            right = gt_l;\\n        }\\n        return res;\\n    }\\n    \\n    int maxIceCream(vector<int>& costs, int coins) {\\n        auto it = solve(costs.data(), costs.data() + costs.size(), coins);\\n        return it;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        constexpr int MAX_COST = 100001;\\n        int cnt[MAX_COST] = {0};\\n        for (auto& c: costs) {\\n            ++cnt[c];\\n        }\\n        int res = 0;\\n        for (int i = 1; i < MAX_COST && coins >= i; ++i) {\\n            if (!cnt[i]) continue;\\n            int buy = std::min(coins / i, cnt[i]);\\n            coins -= buy * i;\\n            res += buy;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2200861,
                "title": "c-easy-approach-beginners-friendly-sorting",
                "content": "```\\nint maxIceCream(vector<int>& costs, int coins) {\\n        int count=0;\\n        sort(costs.begin(),costs.end());\\n        for(int i=0;i<costs.size();i++){\\n            if(costs[i]<=coins){\\n                count++;\\n                coins-=costs[i];\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nint maxIceCream(vector<int>& costs, int coins) {\\n        int count=0;\\n        sort(costs.begin(),costs.end());\\n        for(int i=0;i<costs.size();i++){\\n            if(costs[i]<=coins){\\n                count++;\\n                coins-=costs[i];\\n            }\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2057941,
                "title": "java-counting-sort",
                "content": "Assuming all the ice creams have the same quality, we want to pick the cheapest ones so we can minimize our cost. Since the range is small, I used counting sort and iterating from price of 1 to 1000001.\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int[] iceCount = new int[100002];\\n        for(int cost: costs) iceCount[cost]++;\\n        \\n        int ans = 0;\\n        for(int i = 1; i < iceCount.length; i++){\\n            if(coins < i) break;\\n            int toBuy = Math.min(coins / i, iceCount[i]); // we can only buy how many we have\\n            ans += toBuy;\\n            coins -= toBuy * i;  \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int[] iceCount = new int[100002];\\n        for(int cost: costs) iceCount[cost]++;\\n        \\n        int ans = 0;\\n        for(int i = 1; i < iceCount.length; i++){\\n            if(coins < i) break;\\n            int toBuy = Math.min(coins / i, iceCount[i]); // we can only buy how many we have\\n            ans += toBuy;\\n            coins -= toBuy * i;  \\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1232735,
                "title": "python-solution",
                "content": "```class Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        if min(costs) > coins:\\n            return 0\\n        else:\\n            costs.sort()\\n            total = 0\\n            i=0\\n            while total < coins and i< len(costs) :\\n                total= total + costs[i]\\n                if total > coins:\\n                    break\\n                else:\\n                    i+=1\\n            return i\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```class Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        if min(costs) > coins:\\n            return 0\\n        else:\\n            costs.sort()\\n            total = 0\\n            i=0\\n            while total < coins and i< len(costs) :\\n                total= total + costs[i]\\n                if total > coins:\\n                    break\\n                else:\\n                    i+=1\\n            return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1173963,
                "title": "python3-o-n-solution",
                "content": "```\\ndef maxIceCream(self, costs: List[int], coins: int) -> int:\\n\\ta= [0]*100002\\n\\n\\tfor i in costs:\\n\\t\\ta[i]+=1\\n\\n\\tcnt = 0 \\n\\tfor i in range(len(a)):\\n\\t\\twhile a[i]:\\n\\t\\t\\tif coins > 0:\\n\\t\\t\\t\\tcoins -= i\\n\\t\\t\\t\\ta[i] -= 1\\n\\t\\t\\t\\tif coins >= 0:\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn cnt\\n\\treturn cnt\\n\\n```\\n\\nMy opinion is using index to store the value of array.\\nAnd using one for loop to see whenever it is over coins\\n",
                "solutionTags": [],
                "code": "```\\ndef maxIceCream(self, costs: List[int], coins: int) -> int:\\n\\ta= [0]*100002\\n\\n\\tfor i in costs:\\n\\t\\ta[i]+=1\\n\\n\\tcnt = 0 \\n\\tfor i in range(len(a)):\\n\\t\\twhile a[i]:\\n\\t\\t\\tif coins > 0:\\n\\t\\t\\t\\tcoins -= i\\n\\t\\t\\t\\ta[i] -= 1\\n\\t\\t\\t\\tif coins >= 0:\\n\\t\\t\\t\\t\\tcnt += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\treturn cnt\\n\\treturn cnt\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1173505,
                "title": "c-counting-sort",
                "content": "```\\nint max(int a, int b) { return a > b ? a : b; }\\nint min(int a, int b) { return a < b ? a : b; }\\n\\nint maxIceCream(int* costs, int costsSize, int coins){\\n    int cnt[100001] = { 0 };\\n    int max_val = 0;\\n    while (costsSize--) {\\n        ++cnt[costs[costsSize]];\\n        max_val = max(max_val, costs[costsSize]);\\n    }\\n    int res = 0;\\n    for (int i = 1; i <= max_val && coins >= i; ++i) {\\n        int k = min(cnt[i], coins / i);\\n        coins -= k * i;\\n        res += k;\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint max(int a, int b) { return a > b ? a : b; }\\nint min(int a, int b) { return a < b ? a : b; }\\n\\nint maxIceCream(int* costs, int costsSize, int coins){\\n    int cnt[100001] = { 0 };\\n    int max_val = 0;\\n    while (costsSize--) {\\n        ++cnt[costs[costsSize]];\\n        max_val = max(max_val, costs[costsSize]);\\n    }\\n    int res = 0;\\n    for (int i = 1; i <= max_val && coins >= i; ++i) {\\n        int k = min(cnt[i], coins / i);\\n        coins -= k * i;\\n        res += k;\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1172905,
                "title": "python-min-heap-approach",
                "content": "There\\'s a few ways we can solve this problem. The solution will definitely be a greedy: we always want the minimum value from costs, so long as we have enough coins. Once we run out of coins, or can\\'t afford anything else, we\\'re done.\\n\\nA great way to keep track of minimums is through a heap. If we turn the list of costs into a min heap (**O(n)**), then we just have to pop from the heap until we can\\'t afford anything else.\\n\\nEach heap-pop is **log(n)**, and in the worst case, we do **n** of them, so our running time will be **O(n log(n))**. This is the same as sorting the list first, but using the heap can be faster if we end up affording less. \\n\\n```\\nfrom heapq import heapify, heappop\\n\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        heapify(costs)\\n        bought = 0\\n        \\n        while len(costs) > 0 and coins - costs[0] >= 0:    \\n            \\n                coins -= heappop(costs)\\n                bought += 1\\n                \\n        return bought",
                "solutionTags": [],
                "code": "There\\'s a few ways we can solve this problem. The solution will definitely be a greedy: we always want the minimum value from costs, so long as we have enough coins. Once we run out of coins, or can\\'t afford anything else, we\\'re done.\\n\\nA great way to keep track of minimums is through a heap. If we turn the list of costs into a min heap (**O(n)**), then we just have to pop from the heap until we can\\'t afford anything else.\\n\\nEach heap-pop is **log(n)**, and in the worst case, we do **n** of them, so our running time will be **O(n log(n))**. This is the same as sorting the list first, but using the heap can be faster if we end up affording less. \\n\\n```\\nfrom heapq import heapify, heappop\\n\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        heapify(costs)\\n        bought = 0\\n        \\n        while len(costs) > 0 and coins - costs[0] >= 0:    \\n            \\n                coins -= heappop(costs)\\n                bought += 1\\n                \\n        return bought",
                "codeTag": "Java"
            },
            {
                "id": 1164960,
                "title": "one-line-js-faster-than-100",
                "content": "```\\nconst maxIceCream = (costs, coins) => costs.sort((a,b)=> a-b).map(e=> e<=coins ? coins = coins-e : \"N/A\").filter(e=>e!==\"N/A\").length\\n```",
                "solutionTags": [],
                "code": "```\\nconst maxIceCream = (costs, coins) => costs.sort((a,b)=> a-b).map(e=> e<=coins ? coins = coins-e : \"N/A\").filter(e=>e!==\"N/A\").length\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1164372,
                "title": "java-greedy-sort-beats-100-o-nlogn",
                "content": "\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int count = 0;\\n        for(int cost:costs){\\n            if(cost <= coins){\\n                coins -= cost;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n",
                "solutionTags": [],
                "code": "\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int count = 0;\\n        for(int cost:costs){\\n            if(cost <= coins){\\n                coins -= cost;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n    \\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1164097,
                "title": "clean-python-3-sort-o-sort-or-counting-sort-o-n",
                "content": "Time: `O(sort)`\\nSpace: `O(sort)`\\n```\\nimport itertools\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        costs.sort()\\n        for i, accu in enumerate(itertools.accumulate(costs)):\\n            if accu > coins: return i\\n        return len(costs)\\n```\\n--\\nCounting sort version\\n\\nTime: `O(N)`\\nSpace: `O(N)`\\n```\\nimport collections\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        counter = collections.Counter(costs)\\n        curr, count = 0, 0\\n        for cost in range(10**5 + 1):\\n            while counter[cost] > 0:\\n                if curr + cost > coins: return count\\n                curr += cost\\n                counter[cost] -= 1\\n                count += 1\\n        return count\\n```",
                "solutionTags": [],
                "code": "```\\nimport itertools\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        costs.sort()\\n        for i, accu in enumerate(itertools.accumulate(costs)):\\n            if accu > coins: return i\\n        return len(costs)\\n```\n```\\nimport collections\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        counter = collections.Counter(costs)\\n        curr, count = 0, 0\\n        for cost in range(10**5 + 1):\\n            while counter[cost] > 0:\\n                if curr + cost > coins: return count\\n                curr += cost\\n                counter[cost] -= 1\\n                count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164072,
                "title": "c-self-explanatory",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int count=0;\\n        for(int i: costs){\\n            if(i<=coins) coins-=i,count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Feel free to ask any question in the comment section.**\\nI hope that you\\'ve found the solution useful.\\nIn that case, **please do upvote and encourage me** to on my quest to document all leetcode problems\\uD83D\\uDE03\\nHappy Coding :)\\n",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int count=0;\\n        for(int i: costs){\\n            if(i<=coins) coins-=i,count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164025,
                "title": "c-greedy",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n\\n## Solution 1. Greedy\\n\\nGreedily take the cheapest ice cream first.\\n\\n```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-237/problems/maximum-ice-cream-bars/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& A, int B) {\\n        sort(begin(A), end(A));\\n        int ans = 0;\\n        for (int n : A) {\\n            if (B < n) break;\\n            ++ans;\\n            B -= n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/contest/weekly-contest-237/problems/maximum-ice-cream-bars/\\n// Author: github.com/lzl124631x\\n// Time: O(NlogN)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& A, int B) {\\n        sort(begin(A), end(A));\\n        int ans = 0;\\n        for (int n : A) {\\n            if (B < n) break;\\n            ++ans;\\n            B -= n;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1164019,
                "title": "c-solution-short-and-simple",
                "content": "```\\nint maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int cnt =0;\\n        for(int i:costs){\\n            if(coins-i < 0) break;\\n            coins-=i;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int cnt =0;\\n        for(int i:costs){\\n            if(coins-i < 0) break;\\n            coins-=i;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1163985,
                "title": "java-sort",
                "content": "```\\npublic int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int i=0;\\n        while(i < costs.length && coins >= costs[i]){\\n            coins -= costs[i++];\\n        }\\n        return i;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int i=0;\\n        while(i < costs.length && coins >= costs[i]){\\n            coins -= costs[i++];\\n        }\\n        return i;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3898194,
                "title": "o-n-beginner-friendly-100-beats-fully-explained",
                "content": "# Approach\\n\\n**Approach: Counting Sort**\\n\\n**Step 1: Find Maximum Cost**\\n- Iterate through the array of ice cream costs to find the maximum cost (`max`). This helps us determine the range of values for the counting sort.\\n\\n**Step 2: Count the Occurrences**\\n- Create an array called `arr` of size `max + 1` to store the count of ice cream bars at each cost value.\\n- Iterate through the ice cream costs again and update the corresponding count in the `arr` array.\\n\\n**Step 3: Count Maximum Ice Cream Bars**\\n- Initialize a variable `cnt` to keep track of the maximum number of ice cream bars the boy can buy.\\n- Iterate through the `arr` array, where the index represents the cost of the ice cream bar:\\n  - If the boy has enough coins to buy all the ice cream bars of the current cost (`arr[i] * i <= coins`), add the count of ice cream bars to `cnt` and subtract the spent coins from the available coins.\\n  - If the boy has fewer coins, but still enough to buy at least one ice cream bar of the current cost (`i <= coins`), buy ice cream bars as many times as possible until coins run out.\\n  - Exit the loop when the boy doesn\\'t have enough coins to buy even one ice cream bar of the current cost.\\n\\n**Step 4: Return the Result**\\n- Return the value of `cnt`, which represents the maximum number of ice cream bars the boy can buy within the given budget.\\n\\n**Logic:**\\n- The idea is to use counting sort to efficiently keep track of the count of ice cream bars at each cost value.\\n- Then, iteratively count how many ice cream bars of each cost can be bought within the available coins, starting from the lowest cost.\\n- This approach ensures that we maximize the number of ice cream bars bought while staying within the budget.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$ / $$O(10^5)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int max = 0;\\n\\n        for (int cost : costs) {\\n            if (max < cost) {\\n                max = cost;\\n            }\\n        }\\n\\n        int cnt = 0;\\n        int[] arr = new int[max + 1];\\n\\n        for (int c : costs) {\\n            arr[c]++;\\n        }\\n\\n        for (int i = 0; i < max + 1; i++) {\\n            if (arr[i] * i <= coins) {\\n                cnt += arr[i];\\n                coins -= arr[i] * i;\\n            } else if (i <= coins) {\\n                while (coins >= i) {\\n                    cnt++;\\n                    coins -= i;\\n                }\\n                break;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int max = 0;\\n\\n        for (int cost : costs) {\\n            if (max < cost) {\\n                max = cost;\\n            }\\n        }\\n\\n        int cnt = 0;\\n        int[] arr = new int[max + 1];\\n\\n        for (int c : costs) {\\n            arr[c]++;\\n        }\\n\\n        for (int i = 0; i < max + 1; i++) {\\n            if (arr[i] * i <= coins) {\\n                cnt += arr[i];\\n                coins -= arr[i] * i;\\n            } else if (i <= coins) {\\n                while (coins >= i) {\\n                    cnt++;\\n                    coins -= i;\\n                }\\n                break;\\n            } else {\\n                break;\\n            }\\n        }\\n\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3885311,
                "title": "easy-java-solution-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] arr, int coins) {\\n        Arrays.sort(arr);\\n\\n        int sum = 0;\\n        int ans = 0;\\n\\n        for(int i=0; i<arr.length; i++){\\n            sum = sum+arr[i];\\n            if(sum<=coins) ans++;\\n            else break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] arr, int coins) {\\n        Arrays.sort(arr);\\n\\n        int sum = 0;\\n        int ans = 0;\\n\\n        for(int i=0; i<arr.length; i++){\\n            sum = sum+arr[i];\\n            if(sum<=coins) ans++;\\n            else break;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3856806,
                "title": "o-n-c-solution",
                "content": "\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(t) where t is constant\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n=costs.size();\\n        vector<int> frequency(100001,0);\\n        for(int i=0;i<n;i++){\\n            frequency[costs[i]]+=1;\\n        }\\n        int count=0;\\n        int value=0;\\n        for(int i=0;i<100001;i++){\\n            if(value<coins && frequency[i]>0){\\n                int temp=frequency[i];\\n                while(temp>0){\\n                    value+=i;\\n                    count++;\\n                    temp--;\\n                    if(value==coins) return count;\\n                    if(value>coins) return count-1;\\n                }\\n            }\\n        }\\n        if(value<coins) return count;\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n=costs.size();\\n        vector<int> frequency(100001,0);\\n        for(int i=0;i<n;i++){\\n            frequency[costs[i]]+=1;\\n        }\\n        int count=0;\\n        int value=0;\\n        for(int i=0;i<100001;i++){\\n            if(value<coins && frequency[i]>0){\\n                int temp=frequency[i];\\n                while(temp>0){\\n                    value+=i;\\n                    count++;\\n                    temp--;\\n                    if(value==coins) return count;\\n                    if(value>coins) return count-1;\\n                }\\n            }\\n        }\\n        if(value<coins) return count;\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774320,
                "title": "maximum-ice-cream-bars",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n![image.png](https://assets.leetcode.com/users/images/b7a69cd9-20a0-4656-bcf2-6bc8b0a96203_1689522068.9014187.png)\\n\\n# Code\\n```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        if coins<min(costs):\\n            return 0\\n        ice_cream=0\\n        sum=0\\n        costs.sort()\\n        for i in costs:\\n            sum=sum+i\\n            if sum<=coins:\\n                ice_cream+=1\\n        return ice_cream\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        if coins<min(costs):\\n            return 0\\n        ice_cream=0\\n        sum=0\\n        costs.sort()\\n        for i in costs:\\n            sum=sum+i\\n            if sum<=coins:\\n                ice_cream+=1\\n        return ice_cream\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3638468,
                "title": "c-counting-sort-simple-o-n",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n counts the frequency of each cost, calculates the maximum number of ice cream cones that can be bought for each cost, and updates the answer accordingly. The intuition is to iterate through the costs, considering the available budget and the frequency of each cost, to determine the maximum number of ice cream cones that can be bought.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThe code aims to find the maximum number of ice cream cones that can be bought within the given budget (coins).\\n\\nIt first finds the maximum cost among all the ice cream cones using the max_element function from the STL. This helps determine the maximum size needed for the vector v used later.\\n\\nIt initializes a vector v of size max_no + 1, where max_no is the maximum cost. This vector will be used to count the frequency of each cost in the costs vector.\\n\\nThe code then iterates through the costs vector and increments the corresponding index in v to count the occurrences of each cost.\\n\\nNext, the code initializes a variable ans to keep track of the maximum number of ice cream cones that can be bought.\\n\\nIt then iterates through the v vector, starting from index 1, which represents the minimum cost. For each cost, it calculates the maximum number of ice cream cones that can be bought by dividing the remaining coins by the current cost (coins/i).\\n\\nThe code then takes the minimum value between the calculated maximum number of ice cream cones (can_buy) and the frequency of the current cost (v[i]). This ensures that we don\\'t exceed the available frequency or the budget.\\n\\nIt adds the calculated minimum value to the ans variable to update the maximum number of ice cream cones that can be bought.\\n\\nFinally, the code subtracts the cost of the bought ice cream cones (temp * i) from the coins variable.\\n\\nThe process continues for all costs in the v vector.\\n\\nOnce the iterations are complete, the code returns the maximum number of ice cream cones that can be bought (ans).\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n     O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n     O(max_no)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n \\n      int max_no = *max_element(costs.begin(),costs.end());\\n      vector<int> v(max_no+1);\\n      for(auto it:costs){\\n          v[it]++;\\n      }\\n      int ans = 0;\\n      for(int i  = 1;i<v.size();i++){\\n          int can_buy = coins/i;\\n          int temp = min(can_buy,v[i]);\\n          ans += temp;\\n          coins -= (temp * i);\\n\\n      }\\n      return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n \\n      int max_no = *max_element(costs.begin(),costs.end());\\n      vector<int> v(max_no+1);\\n      for(auto it:costs){\\n          v[it]++;\\n      }\\n      int ans = 0;\\n      for(int i  = 1;i<v.size();i++){\\n          int can_buy = coins/i;\\n          int temp = min(can_buy,v[i]);\\n          ans += temp;\\n          coins -= (temp * i);\\n\\n      }\\n      return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3633298,
                "title": "c-count-sort-implementation-99-faster",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        int v[(int)1e5+1] = {0};\\n        int ans = 0;\\n        for(auto i : costs) v[i]++;\\n        for(int i = 1; i <= 1e5; ++i){\\n            if(v[i] == 0) continue;\\n            int count = coins/i;\\n            if(count == 0) break;\\n            ans += min(count,v[i]);\\n            coins -= min(count,v[i])*i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        int v[(int)1e5+1] = {0};\\n        int ans = 0;\\n        for(auto i : costs) v[i]++;\\n        for(int i = 1; i <= 1e5; ++i){\\n            if(v[i] == 0) continue;\\n            int count = coins/i;\\n            if(count == 0) break;\\n            ans += min(count,v[i]);\\n            coins -= min(count,v[i])*i;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3509413,
                "title": "maximum-ice-cream-bars-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# 1. Approach\\n<!-- Describe your approach to solving the problem. -->\\n*OPTIMIZED APPROACH*\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int i, count=0;\\n        map<long long int, long long int> mp;\\n        for(i=0 ; i<costs.size() ; i++)\\n        {\\n            mp[costs[i]]++;\\n        }\\n        for(auto it:mp)\\n        {\\n            if(it.first*it.second<=coins)\\n            {\\n                coins -= it.first*it.second;\\n                count += it.second;\\n            }\\n            else if(it.first*it.second>coins)\\n            {\\n                count += coins/it.first;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n# 2. Approach\\n<!-- Describe your approach to solving the problem. -->\\n*BRUTE FORCE APPROACH -> Sorting*\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int i;\\n        sort(costs.begin(), costs.end());\\n        for(i=0 ; i<costs.size() ; i++)\\n        {\\n            if(costs[i]<=coins)\\n            {\\n                coins -= costs[i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/1c217669-a865-4ad7-afda-d495bb1ca1e3_1683736225.4770608.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int i, count=0;\\n        map<long long int, long long int> mp;\\n        for(i=0 ; i<costs.size() ; i++)\\n        {\\n            mp[costs[i]]++;\\n        }\\n        for(auto it:mp)\\n        {\\n            if(it.first*it.second<=coins)\\n            {\\n                coins -= it.first*it.second;\\n                count += it.second;\\n            }\\n            else if(it.first*it.second>coins)\\n            {\\n                count += coins/it.first;\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int i;\\n        sort(costs.begin(), costs.end());\\n        for(i=0 ; i<costs.size() ; i++)\\n        {\\n            if(costs[i]<=coins)\\n            {\\n                coins -= costs[i];\\n            }\\n            else\\n            {\\n                break;\\n            }\\n        }\\n        return i;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396397,
                "title": "simplest-python-one-liner",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        return bisect_right(list(accumulate(sorted(costs))), coins)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        return bisect_right(list(accumulate(sorted(costs))), coins)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359786,
                "title": "easy-c-sol",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int ans =0;\\n        int n=costs.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(coins<=0)break;\\n            if(costs[i]<coins){\\n                ans++;\\n                coins-=costs[i];\\n            }\\n            else if(costs[i]==coins){\\n                ans++;\\n                coins=0;\\n            }\\n            else if(costs[i]<coins)break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int ans =0;\\n        int n=costs.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(coins<=0)break;\\n            if(costs[i]<coins){\\n                ans++;\\n                coins-=costs[i];\\n            }\\n            else if(costs[i]==coins){\\n                ans++;\\n                coins=0;\\n            }\\n            else if(costs[i]<coins)break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3351361,
                "title": "python-without-sorting",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        \\n\\n        m = max(costs)\\n        ans = 0\\n        count = [0] * (m+1)\\n\\n        for i in costs:\\n            count[i] += 1\\n        \\n        \\n        \\n        for i in range(1,m+1):\\n\\n            if count[i] == 0:\\n                continue\\n            \\n            ice = min(count[i],coins//i)\\n            coins -= ice *i\\n\\n            if coins < 0:\\n                break\\n\\n            ans += ice\\n\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        \\n\\n        m = max(costs)\\n        ans = 0\\n        count = [0] * (m+1)\\n\\n        for i in costs:\\n            count[i] += 1\\n        \\n        \\n        \\n        for i in range(1,m+1):\\n\\n            if count[i] == 0:\\n                continue\\n            \\n            ice = min(count[i],coins//i)\\n            coins -= ice *i\\n\\n            if coins < 0:\\n                break\\n\\n            ans += ice\\n\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3339381,
                "title": "simple-greedy-solution-easy-problem",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        \\n        sort(costs.begin(),costs.end());\\n        \\n        int sum=0 , cnt=0;\\n        \\n      for(int i=0; i<costs.size();i++)\\n      {\\n          coins-=costs[i];\\n\\n          if(coins>=0){\\n            cnt++;\\n          }\\n          else{\\n            return cnt;\\n          }\\n      }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        \\n        sort(costs.begin(),costs.end());\\n        \\n        int sum=0 , cnt=0;\\n        \\n      for(int i=0; i<costs.size();i++)\\n      {\\n          coins-=costs[i];\\n\\n          if(coins>=0){\\n            cnt++;\\n          }\\n          else{\\n            return cnt;\\n          }\\n      }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3224854,
                "title": "java-solution-with-easy-logic",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int c=0;\\n        while(coins>0){\\n            for(int i=0;i<costs.length;++i){\\n                coins=coins-costs[i];\\n                if(coins>=0){\\n                    c++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        int maxi=Math.min(c,costs.length);\\n        return maxi;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int c=0;\\n        while(coins>0){\\n            for(int i=0;i<costs.length;++i){\\n                coins=coins-costs[i];\\n                if(coins>=0){\\n                    c++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        int maxi=Math.min(c,costs.length);\\n        return maxi;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3155302,
                "title": "python3-o-n-easiest-solution-beats-83-runtime-91-memory",
                "content": "# Approach\\n1. In order to get the maximum number of ice-cream that can be bought with given coins, the list of costs has to be sorted first.\\n2. A variable is used as counter with initial value as zero that will provide the count of ice-cream purchased.\\n3. Iterate through the costs list and if the price is less than available coins then increment the counter and subtract the price from coins. \\n4. If the price exceeds the coins the the counter value is returned.\\n\\n# Complexity\\n- Time complexity : $$O(n)$$\\n\\n- Space complexity : $$O(1)$$\\n\\n# Code\\n```python []\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        costs.sort()\\n        i= 0\\n        for price in costs:\\n            if price<= coins:\\n                i+= 1\\n                coins-= price\\n            else:\\n                break\\n        return i\\n```\\n### If this solution helped you then do consider Upvoting \\u2B06.\\n#### Also, you can check me out on LinkedIn : [Om Anand](https://www.linkedin.com/in/om-anand-38341a1ba/)",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Greedy",
                    "Sort",
                    "Sorting"
                ],
                "code": "```python []\\nclass Solution:\\n    def maxIceCream(self, costs: List[int], coins: int) -> int:\\n        costs.sort()\\n        i= 0\\n        for price in costs:\\n            if price<= coins:\\n                i+= 1\\n                coins-= price\\n            else:\\n                break\\n        return i\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020023,
                "title": "javascript-two-approaches-naive-and-optimized",
                "content": "# Naive approach\\nWe know we have to maximise the number of ice creams to buy, so initial thought is to simply sort he array and then iterate over the numbers in order subtracting the cost from couns.\\n\\n```\\nvar maxIceCream = function(costs, coins) {\\n    costs = costs.sort((a, b) => a - b)\\n    let res = 0\\n\\n    for (let i = 0; i < costs.length; i++) {\\n        coins = coins - costs[i]\\n        if (coins > -1) {\\n            res++\\n        } else {\\n            return res\\n        }\\n    }\\n    return res\\n};\\n```\\nBut this is not optimal, since sorting can take quite some time.\\n- Time complexity: O(N log N) due to sorting. \\n    - In case input array has small number of items, this could run in O(n^2) time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: This should be O(log N) again due to sorting\\n    - JS sort is somewhat optimized for smaller numbers when it should use O(1) space \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Optimized\\nLet\\'s create a helping array where we store the frequiency or count of ice creams of the same cost (`countSort`). The index will be their cost, and the value will be their count. The array has to be of the size of biggest cost of ice cream.\\n\\nExample:\\n```\\n[1,3,2,4,1]\\n```\\n\\nwould have a frequency array like:\\n```\\n[0, 2, 1, 1, 1]\\n```\\n\\nAfter we have that, we loop through frequency array. We start from index 1, since inde 0 will always have value 0 (but it\\'s possible to do some tweaks here to start from 0th index if you are really stretched for space but I find this approach more clean).\\n\\nWe can skip any step where frequency value is 0.\\nIn case we come across a point where number of couns we have is less than the cost, we came to a point where we can\\'t buy more ice cream so stop the itertion and return the result.\\n\\nIn case we can still buy more ice cream we calculate the result. \\nFirst find out how many icecreams of `cost` we can pick with our current coins. Then subtract that value from coins and increase our result with it.\\n\\n# Complexity\\n- Time complexity: O(N), we do have two loops, but they are not nested, so it\\'s linear time.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N), due to using of an array for extra space\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number[]} costs\\n * @param {number} coins\\n * @return {number}\\n */\\nvar maxIceCream = function(costs, coins) {\\n    let max = Math.max(...costs)\\n    let countSort = Array(max + 1).fill(0)\\n    let res = 0\\n\\n    for (let i of costs) {\\n        countSort[i]++\\n    }\\n\\n    for (let cost = 1; cost <= max; cost++) {\\n        if (!countSort[cost]) continue;\\n        \\n        // not enough money to buy even a single ice cream\\n        if (coins < cost) break;\\n\\n        let count = Math.min(countSort[cost], Math.floor(coins / cost))\\n        coins -= cost * count;\\n        res += count\\n\\n    }\\n\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar maxIceCream = function(costs, coins) {\\n    costs = costs.sort((a, b) => a - b)\\n    let res = 0\\n\\n    for (let i = 0; i < costs.length; i++) {\\n        coins = coins - costs[i]\\n        if (coins > -1) {\\n            res++\\n        } else {\\n            return res\\n        }\\n    }\\n    return res\\n};\\n```\n```\\n[1,3,2,4,1]\\n```\n```\\n[0, 2, 1, 1, 1]\\n```\n```\\n/**\\n * @param {number[]} costs\\n * @param {number} coins\\n * @return {number}\\n */\\nvar maxIceCream = function(costs, coins) {\\n    let max = Math.max(...costs)\\n    let countSort = Array(max + 1).fill(0)\\n    let res = 0\\n\\n    for (let i of costs) {\\n        countSort[i]++\\n    }\\n\\n    for (let cost = 1; cost <= max; cost++) {\\n        if (!countSort[cost]) continue;\\n        \\n        // not enough money to buy even a single ice cream\\n        if (coins < cost) break;\\n\\n        let count = Math.min(countSort[cost], Math.floor(coins / cost))\\n        coins -= cost * count;\\n        res += count\\n\\n    }\\n\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3014035,
                "title": "simple-java-solution",
                "content": "# Intuition\\ncost of all the icecream should be less than or eqals to given coins.\\n\\n# Approach\\nThe approach taken for this solution is to sort the array of costs in ascending order and then iterate through the array, adding up the costs of the ice cream cones as you go. If the sum of the costs exceeds the number of coins you have, the loop is terminated and the current number of ice cream cones is returned. If the loop completes, the final number of ice cream cones is returned.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n\\n        Arrays.sort(costs);\\n        int sum = 0;\\n        int maxIceCream = 0;\\n        for(int i = 0 ; i < costs.length ; i ++){\\n            sum = sum + costs[i];\\n            if(sum <= coins){\\n                maxIceCream++;\\n            }else{\\n                return maxIceCream;\\n            }\\n        }\\n        return maxIceCream;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n\\n        Arrays.sort(costs);\\n        int sum = 0;\\n        int maxIceCream = 0;\\n        for(int i = 0 ; i < costs.length ; i ++){\\n            sum = sum + costs[i];\\n            if(sum <= coins){\\n                maxIceCream++;\\n            }else{\\n                return maxIceCream;\\n            }\\n        }\\n        return maxIceCream;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3013972,
                "title": "dummy-cpp-solutions",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis problem is similar to fractional knapsack problem. \\n\\nOur requirement is to grab most number of ice creams. This can be done with cheaper ice cream bars, rather than costlier ones. So we sort it and try to grab as many cheaper ones as possible.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n logn)$$, where n is the number of input.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$, we use constant space for any input.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n\\n        int ret = 0;\\n\\n        for(auto i : costs){\\n            if(i <= coins){\\n                coins -= i;\\n                ret++;\\n            }\\n\\n            else break;\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n\\n        int ret = 0;\\n\\n        for(auto i : costs){\\n            if(i <= coins){\\n                coins -= i;\\n                ret++;\\n            }\\n\\n            else break;\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010904,
                "title": "java-solution-easy-to-understand-with-easy-approch",
                "content": "# Intuition\\n- First you sort the array in increasing order, and take out the numbers one by one from the array and check if cost is greater than or equal to then decrease cost from coins and increase the number of bars by one if coins is less than coins then return number of bars\\n\\n# Approach\\n- Greedy Approch\\n- Sorting Technique\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n \\n\\n- Space complexity: O(1)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n\\n        int count=0;\\n\\n        for(int y : costs){\\n            if(coins>=y){\\n                count++;\\n                coins-=y;\\n            } else return count;\\n        }\\n\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n\\n        int count=0;\\n\\n        for(int y : costs){\\n            if(coins>=y){\\n                count++;\\n                coins-=y;\\n            } else return count;\\n        }\\n\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010502,
                "title": "video-greedy",
                "content": "# Intuition & Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\uD835\\uDDE3\\uD835\\uDDF9\\uD835\\uDDF2\\uD835\\uDDEE\\uD835\\uDE00\\uD835\\uDDF2 \\uD835\\uDDF1\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDDFD \\uD835\\uDDF0\\uD835\\uDDFC\\uD835\\uDDFA\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\uD835\\uDE00 \\uD835\\uDDEE\\uD835\\uDDFB\\uD835\\uDDF1 \\uD835\\uDDF3\\uD835\\uDDF2\\uD835\\uDDF2\\uD835\\uDDF1\\uD835\\uDDEF\\uD835\\uDDEE\\uD835\\uDDF0\\uD835\\uDDF8 \\uD835\\uDDF3\\uD835\\uDDFC\\uD835\\uDDFF \\uD835\\uDDF6\\uD835\\uDDFA\\uD835\\uDDFD\\uD835\\uDDFF\\uD835\\uDDFC\\uD835\\uDE03\\uD835\\uDDF2\\uD835\\uDDFA\\uD835\\uDDF2\\uD835\\uDDFB\\uD835\\uDE01\\nhttps://youtu.be/ZFX3L_IZEXM\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n+m)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m)\\n# Code\\n```\\n/**\\n * @param {number[]} costs\\n * @param {number} coins\\n * @return {number}\\n */\\nvar maxIceCream = function(costs, coins) {\\n    let n = costs.length\\n    let m = 0\\n    for (let cost of costs) {\\n        m = Math.max(m, cost)\\n    }\\n\\n    let costFreq = new Array(m+1).fill(0)\\n    for (let cost of costs) {\\n        costFreq[cost]++\\n    }\\n\\n    let res = 0\\n    for (let i = 1; i <= m; i++) {\\n        if (costFreq[i] == 0) continue\\n        if (coins < i) break\\n\\n        count = Math.min(costFreq[i], Math.floor(coins/i))\\n        res += count\\n        coins -= count * i\\n    }\\n    return res\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Array",
                    "Greedy",
                    "Sorting"
                ],
                "code": "```\\n/**\\n * @param {number[]} costs\\n * @param {number} coins\\n * @return {number}\\n */\\nvar maxIceCream = function(costs, coins) {\\n    let n = costs.length\\n    let m = 0\\n    for (let cost of costs) {\\n        m = Math.max(m, cost)\\n    }\\n\\n    let costFreq = new Array(m+1).fill(0)\\n    for (let cost of costs) {\\n        costFreq[cost]++\\n    }\\n\\n    let res = 0\\n    for (let i = 1; i <= m; i++) {\\n        if (costFreq[i] == 0) continue\\n        if (coins < i) break\\n\\n        count = Math.min(costFreq[i], Math.floor(coins/i))\\n        res += count\\n        coins -= count * i\\n    }\\n    return res\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3010457,
                "title": "easy-cpp-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(nlogn)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& s, int c) {\\n        int m=0,l=0;\\nsort(s.begin(),s.end());\\n        for(auto i:s){\\n            \\n            c-=i;\\n            if(c<0)\\nbreak;\\n            m+=i;l++;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& s, int c) {\\n        int m=0,l=0;\\nsort(s.begin(),s.end());\\n        for(auto i:s){\\n            \\n            c-=i;\\n            if(c<0)\\nbreak;\\n            m+=i;l++;\\n        }\\n        return l;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010401,
                "title": "c-solution-greedy",
                "content": "\\n# Complexity\\n- Time complexity:\\n$$O(O(Nlog(N)))$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int i=0;\\n        int ans=0;\\n        while(i<costs.size() && coins>=costs[i]){\\n            if(coins-costs[i]>=0){\\n                coins-=costs[i];\\n                ans++;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int i=0;\\n        int ans=0;\\n        while(i<costs.size() && coins>=costs[i]){\\n            if(coins-costs[i]>=0){\\n                coins-=costs[i];\\n                ans++;\\n            }\\n            i++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010383,
                "title": "0-1-knapsack-approach-greedy-approach-recursion-backtracking-dp-c-solution",
                "content": "# Approaches\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThis problem is similar to 0/1 Knapsack problem but due to the constraints given in the problem statement 0/1 Knapsack approach or any other recusive/DP approach will surely give TLE. So, by considering the constrainst it is better to solve it with greedy approach. But here I am sharing my 0/1 Knapsack approach also for your knowledge.\\n\\n# 0/1 Knapsack\\n- Time complexity: O(2^N) [can be improved with DP]\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# 0/1 Knapsack Solution\\n```\\n/*\\n    W = Coins\\n    wt = costs\\n    n = indexes to iterate over costs array\\n    ans = maximum number of ice cream bars\\n*/\\nint knapSack(int W, vector<int> wt, int n, int ans){\\n\\n    // Base Case\\n    if (n == 0 || W == 0)\\n        return ans;\\n\\n    if (wt[n - 1] > W)\\n        return knapSack(W, wt, n - 1, ans);\\n    else\\n        return max(knapSack(W - wt[n - 1], wt, n - 1, ans+1), knapSack(W, wt, n - 1, ans));\\n}\\n\\nint maxIceCream(vector<int>& costs, int coins) {\\n    int ans=0;\\n    return knapSack(coins, costs, costs.size(), ans);\\n}\\n```\\nNote: We can improve the complexity with memoization and tabulation approaches.\\n\\n\\n# Greedy\\n- Time complexity: O(N log N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Greedy Solution\\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int ans=0;\\n        sort(costs.begin(), costs.end());\\n\\n        for(int i=0; i<costs.size() && coins>0; i++){\\n            if(coins>=costs[i]){\\n                coins-=costs[i];\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming",
                    "Recursion",
                    "Memoization",
                    "Sorting"
                ],
                "code": "```\\n/*\\n    W = Coins\\n    wt = costs\\n    n = indexes to iterate over costs array\\n    ans = maximum number of ice cream bars\\n*/\\nint knapSack(int W, vector<int> wt, int n, int ans){\\n\\n    // Base Case\\n    if (n == 0 || W == 0)\\n        return ans;\\n\\n    if (wt[n - 1] > W)\\n        return knapSack(W, wt, n - 1, ans);\\n    else\\n        return max(knapSack(W - wt[n - 1], wt, n - 1, ans+1), knapSack(W, wt, n - 1, ans));\\n}\\n\\nint maxIceCream(vector<int>& costs, int coins) {\\n    int ans=0;\\n    return knapSack(coins, costs, costs.size(), ans);\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int ans=0;\\n        sort(costs.begin(), costs.end());\\n\\n        for(int i=0; i<costs.size() && coins>0; i++){\\n            if(coins>=costs[i]){\\n                coins-=costs[i];\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3010220,
                "title": "java-easy",
                "content": "I sorted the costs array, Because we want max ice cream bars, so we can buy maximum if we buy the cheap ones first. \\nBelow is the code. \\n```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        \\n        Arrays.sort(costs);\\n        \\n        int count = 0;   //count of the no of ice creams\\n        for(int i = 0; i < costs.length; i++) {\\n            coins -= costs[i];   //coins left after spending it on the ith ice cream\\n            if(coins < 0) return count;\\n            else count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```\\n\\nPlease upvote if you like the ans.",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        \\n        Arrays.sort(costs);\\n        \\n        int count = 0;   //count of the no of ice creams\\n        for(int i = 0; i < costs.length; i++) {\\n            coins -= costs[i];   //coins left after spending it on the ith ice cream\\n            if(coins < 0) return count;\\n            else count++;\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1743657,
                "content": [
                    {
                        "username": "aaron2k12",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "Wanxuan_Li",
                        "content": "definitely"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Yes, I was confused expecting something tricky"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "wasn\\'t going to try this question being new on LeetCode, but this is my only question that was solved in first attempt, lol."
                    },
                    {
                        "username": "drblessing",
                        "content": "Agreed, I was confused at first why it was a Medium. "
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "yess it is very easy problem"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Yes correct this problem teach us to use right approach: \n- if we use DP it will be medium problem \n- If we use greedy its easy problem \n\nbut the point is this problem teach us to use right algorithm"
                    },
                    {
                        "username": "S_Basu",
                        "content": "True"
                    },
                    {
                        "username": "Cut",
                        "content": "My name is aaron too!"
                    },
                    {
                        "username": "Boolean_Autocrats",
                        "content": "this can be easy problem for those who know greedy but for those who don\\'t about it ,this problem is surely medium .  "
                    },
                    {
                        "username": "xeniawann",
                        "content": "Totally agree^^ many people might know how to solve it within 1 minute after reading the question."
                    },
                    {
                        "username": "Mohammed84Farouk",
                        "content": "that\\'s because its the second problem in the contest and they are usually easy, easy-medium..."
                    },
                    {
                        "username": "qiushile",
                        "content": "maybe in some languages, you need to write sort method"
                    },
                    {
                        "username": "djslim",
                        "content": "First time I agree \\uD83E\\uDD23"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I agree"
                    },
                    {
                        "username": "user9382Km",
                        "content": "`Maybe the real challenge, is realizing that there is no challenge.`"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The real challenge is to prove the solution mathematically."
                    },
                    {
                        "username": "bizco8",
                        "content": "haahaha I feel it bro"
                    },
                    {
                        "username": "drblessing",
                        "content": "hahah "
                    },
                    {
                        "username": "TakshPanchal",
                        "content": "shush... don\\'t give spoilers."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "In this case, the problem should be marked as hard."
                    },
                    {
                        "username": "omi23",
                        "content": "lol so true"
                    },
                    {
                        "username": "S_Basu",
                        "content": "\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "picksitquick",
                        "content": "this is what master Oogway would say, wise words SENSEI, lol"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "Yup, I was trying to figure out why the obvious greedy approach wouldn\\'t work and stared at it for five minutes wondering. I asked ChatGPT why a greedy approach wouldn\\'t work and it kinda broke it :)"
                    },
                    {
                        "username": "gilite",
                        "content": "Very wise."
                    },
                    {
                        "username": "valibraimi",
                        "content": "Easiest Medium ever seen "
                    },
                    {
                        "username": "pratikraj001",
                        "content": "Bro you are wrong don\\'t do it in O(nlog n) ; This is challenge . if only sort then it is  in easy section not in medium."
                    },
                    {
                        "username": "laasyalata16",
                        "content": "Indeed YES!"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@djslim](/djslim) Yes, return false"
                    },
                    {
                        "username": "djslim",
                        "content": "[@XJRr8TyB](/XJRr8TyB) is it even easier?"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "Try 2396 Strictly Palindromic Number"
                    },
                    {
                        "username": "kontsis",
                        "content": "Lets go!!!! Conquered this tough medium, now I\\'m ready for FAANG. See u losers at the top "
                    },
                    {
                        "username": "NITHESH_23",
                        "content": "lol....\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "\\uD83D\\uDE02\\uD83E\\uDD23"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Losers won\\'t be at the top. It would be lonely :/"
                    },
                    {
                        "username": "khoai345678",
                        "content": "u r funny\\n"
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Certified \\uD83C\\uDF66BING CHILLING \\uD83E\\uDD76 problem"
                    },
                    {
                        "username": "drblessing",
                        "content": "BING CHILLING \\uD83C\\uDF66"
                    },
                    {
                        "username": "kmp1084",
                        "content": "Only purpose of this question is to see how many people try to solve this using DP and get TLE."
                    },
                    {
                        "username": "mayank-01",
                        "content": "yes"
                    },
                    {
                        "username": "native_element",
                        "content": "i failed using dp. Then i realised Greedy problem."
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Afzal543](/Afzal543) Recursion \\u2620\\u2620"
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Sorry](/Sorry) Meanwhile I Don\\'t Have Good Knowledge Of DP so I Directly Solved It Using Sorting \\uD83D\\uDE0E"
                    },
                    {
                        "username": "raaj-s",
                        "content": "[@Jonatanlp](/Jonatanlp) Even I was like greedy or dp as this problem slightly reminded me of \\'minimum number of coins needed for a given total\\' problem (as the total is being divided), but then I realized that the bars themselves won\\'t be repeated and they don\\'t have any inherent value. Haha."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "if you sort the array first and do DP approach it will solve all test case"
                    },
                    {
                        "username": "a_pandagre",
                        "content": "yepp, initially thought of DP, but then thought of simply sorting it."
                    },
                    {
                        "username": "Afzal543",
                        "content": "Today while solving this question I saw I have a failed submission on Apr 2021 . Guess what I was using fucking recurrsion . Since then Improved a lot . "
                    },
                    {
                        "username": "Sorry",
                        "content": "32.3% tried DP, because the acceptance rate is 67.7%."
                    },
                    {
                        "username": "shubhankar00",
                        "content": "I spent more time contemplating what I\\'m missing than actually coding the solution. "
                    },
                    {
                        "username": "Maverick767",
                        "content": "I thought there was a trick I was missing when I saw that this was a medium, but nope it\\'s just the easiest medium on the entire website"
                    },
                    {
                        "username": "Sounita51028",
                        "content": "Same here bro XD\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Why are we here ? \\n\\nJust to suffer...."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@user1827o](/user1827o) \\uD83E\\uDEC2"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "We will all make it bro :)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Today no suffering \\uD83D\\uDE05"
                    },
                    {
                        "username": "Joseph86",
                        "content": "bro in the discussion section I always see SOME sort of depressed/meme comment  :s"
                    },
                    {
                        "username": "gullyboy007",
                        "content": "I would say they should have mentioned something about unique ice cream bars or something , otherwise he can simply buy the cheapest one as much as possible(greedy) instead of DP."
                    },
                    {
                        "username": "alexdft",
                        "content": "[@BRABURAJ](/BRABURAJ)  dynamic programming"
                    },
                    {
                        "username": "BRABURAJ",
                        "content": "what is dp?\\n"
                    },
                    {
                        "username": "ankishkhandelwalop",
                        "content": "Appreciate \\n\\neasiest  medium question ever\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did greedy : ) It passed , this should be easy I guess"
                    }
                ]
            },
            {
                "id": 1743810,
                "content": [
                    {
                        "username": "aaron2k12",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "Wanxuan_Li",
                        "content": "definitely"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Yes, I was confused expecting something tricky"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "wasn\\'t going to try this question being new on LeetCode, but this is my only question that was solved in first attempt, lol."
                    },
                    {
                        "username": "drblessing",
                        "content": "Agreed, I was confused at first why it was a Medium. "
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "yess it is very easy problem"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Yes correct this problem teach us to use right approach: \n- if we use DP it will be medium problem \n- If we use greedy its easy problem \n\nbut the point is this problem teach us to use right algorithm"
                    },
                    {
                        "username": "S_Basu",
                        "content": "True"
                    },
                    {
                        "username": "Cut",
                        "content": "My name is aaron too!"
                    },
                    {
                        "username": "Boolean_Autocrats",
                        "content": "this can be easy problem for those who know greedy but for those who don\\'t about it ,this problem is surely medium .  "
                    },
                    {
                        "username": "xeniawann",
                        "content": "Totally agree^^ many people might know how to solve it within 1 minute after reading the question."
                    },
                    {
                        "username": "Mohammed84Farouk",
                        "content": "that\\'s because its the second problem in the contest and they are usually easy, easy-medium..."
                    },
                    {
                        "username": "qiushile",
                        "content": "maybe in some languages, you need to write sort method"
                    },
                    {
                        "username": "djslim",
                        "content": "First time I agree \\uD83E\\uDD23"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I agree"
                    },
                    {
                        "username": "user9382Km",
                        "content": "`Maybe the real challenge, is realizing that there is no challenge.`"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The real challenge is to prove the solution mathematically."
                    },
                    {
                        "username": "bizco8",
                        "content": "haahaha I feel it bro"
                    },
                    {
                        "username": "drblessing",
                        "content": "hahah "
                    },
                    {
                        "username": "TakshPanchal",
                        "content": "shush... don\\'t give spoilers."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "In this case, the problem should be marked as hard."
                    },
                    {
                        "username": "omi23",
                        "content": "lol so true"
                    },
                    {
                        "username": "S_Basu",
                        "content": "\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "picksitquick",
                        "content": "this is what master Oogway would say, wise words SENSEI, lol"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "Yup, I was trying to figure out why the obvious greedy approach wouldn\\'t work and stared at it for five minutes wondering. I asked ChatGPT why a greedy approach wouldn\\'t work and it kinda broke it :)"
                    },
                    {
                        "username": "gilite",
                        "content": "Very wise."
                    },
                    {
                        "username": "valibraimi",
                        "content": "Easiest Medium ever seen "
                    },
                    {
                        "username": "pratikraj001",
                        "content": "Bro you are wrong don\\'t do it in O(nlog n) ; This is challenge . if only sort then it is  in easy section not in medium."
                    },
                    {
                        "username": "laasyalata16",
                        "content": "Indeed YES!"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@djslim](/djslim) Yes, return false"
                    },
                    {
                        "username": "djslim",
                        "content": "[@XJRr8TyB](/XJRr8TyB) is it even easier?"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "Try 2396 Strictly Palindromic Number"
                    },
                    {
                        "username": "kontsis",
                        "content": "Lets go!!!! Conquered this tough medium, now I\\'m ready for FAANG. See u losers at the top "
                    },
                    {
                        "username": "NITHESH_23",
                        "content": "lol....\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "\\uD83D\\uDE02\\uD83E\\uDD23"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Losers won\\'t be at the top. It would be lonely :/"
                    },
                    {
                        "username": "khoai345678",
                        "content": "u r funny\\n"
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Certified \\uD83C\\uDF66BING CHILLING \\uD83E\\uDD76 problem"
                    },
                    {
                        "username": "drblessing",
                        "content": "BING CHILLING \\uD83C\\uDF66"
                    },
                    {
                        "username": "kmp1084",
                        "content": "Only purpose of this question is to see how many people try to solve this using DP and get TLE."
                    },
                    {
                        "username": "mayank-01",
                        "content": "yes"
                    },
                    {
                        "username": "native_element",
                        "content": "i failed using dp. Then i realised Greedy problem."
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Afzal543](/Afzal543) Recursion \\u2620\\u2620"
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Sorry](/Sorry) Meanwhile I Don\\'t Have Good Knowledge Of DP so I Directly Solved It Using Sorting \\uD83D\\uDE0E"
                    },
                    {
                        "username": "raaj-s",
                        "content": "[@Jonatanlp](/Jonatanlp) Even I was like greedy or dp as this problem slightly reminded me of \\'minimum number of coins needed for a given total\\' problem (as the total is being divided), but then I realized that the bars themselves won\\'t be repeated and they don\\'t have any inherent value. Haha."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "if you sort the array first and do DP approach it will solve all test case"
                    },
                    {
                        "username": "a_pandagre",
                        "content": "yepp, initially thought of DP, but then thought of simply sorting it."
                    },
                    {
                        "username": "Afzal543",
                        "content": "Today while solving this question I saw I have a failed submission on Apr 2021 . Guess what I was using fucking recurrsion . Since then Improved a lot . "
                    },
                    {
                        "username": "Sorry",
                        "content": "32.3% tried DP, because the acceptance rate is 67.7%."
                    },
                    {
                        "username": "shubhankar00",
                        "content": "I spent more time contemplating what I\\'m missing than actually coding the solution. "
                    },
                    {
                        "username": "Maverick767",
                        "content": "I thought there was a trick I was missing when I saw that this was a medium, but nope it\\'s just the easiest medium on the entire website"
                    },
                    {
                        "username": "Sounita51028",
                        "content": "Same here bro XD\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Why are we here ? \\n\\nJust to suffer...."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@user1827o](/user1827o) \\uD83E\\uDEC2"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "We will all make it bro :)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Today no suffering \\uD83D\\uDE05"
                    },
                    {
                        "username": "Joseph86",
                        "content": "bro in the discussion section I always see SOME sort of depressed/meme comment  :s"
                    },
                    {
                        "username": "gullyboy007",
                        "content": "I would say they should have mentioned something about unique ice cream bars or something , otherwise he can simply buy the cheapest one as much as possible(greedy) instead of DP."
                    },
                    {
                        "username": "alexdft",
                        "content": "[@BRABURAJ](/BRABURAJ)  dynamic programming"
                    },
                    {
                        "username": "BRABURAJ",
                        "content": "what is dp?\\n"
                    },
                    {
                        "username": "ankishkhandelwalop",
                        "content": "Appreciate \\n\\neasiest  medium question ever\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did greedy : ) It passed , this should be easy I guess"
                    }
                ]
            },
            {
                "id": 1743660,
                "content": [
                    {
                        "username": "aaron2k12",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "Wanxuan_Li",
                        "content": "definitely"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Yes, I was confused expecting something tricky"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "wasn\\'t going to try this question being new on LeetCode, but this is my only question that was solved in first attempt, lol."
                    },
                    {
                        "username": "drblessing",
                        "content": "Agreed, I was confused at first why it was a Medium. "
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "yess it is very easy problem"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Yes correct this problem teach us to use right approach: \n- if we use DP it will be medium problem \n- If we use greedy its easy problem \n\nbut the point is this problem teach us to use right algorithm"
                    },
                    {
                        "username": "S_Basu",
                        "content": "True"
                    },
                    {
                        "username": "Cut",
                        "content": "My name is aaron too!"
                    },
                    {
                        "username": "Boolean_Autocrats",
                        "content": "this can be easy problem for those who know greedy but for those who don\\'t about it ,this problem is surely medium .  "
                    },
                    {
                        "username": "xeniawann",
                        "content": "Totally agree^^ many people might know how to solve it within 1 minute after reading the question."
                    },
                    {
                        "username": "Mohammed84Farouk",
                        "content": "that\\'s because its the second problem in the contest and they are usually easy, easy-medium..."
                    },
                    {
                        "username": "qiushile",
                        "content": "maybe in some languages, you need to write sort method"
                    },
                    {
                        "username": "djslim",
                        "content": "First time I agree \\uD83E\\uDD23"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I agree"
                    },
                    {
                        "username": "user9382Km",
                        "content": "`Maybe the real challenge, is realizing that there is no challenge.`"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The real challenge is to prove the solution mathematically."
                    },
                    {
                        "username": "bizco8",
                        "content": "haahaha I feel it bro"
                    },
                    {
                        "username": "drblessing",
                        "content": "hahah "
                    },
                    {
                        "username": "TakshPanchal",
                        "content": "shush... don\\'t give spoilers."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "In this case, the problem should be marked as hard."
                    },
                    {
                        "username": "omi23",
                        "content": "lol so true"
                    },
                    {
                        "username": "S_Basu",
                        "content": "\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "picksitquick",
                        "content": "this is what master Oogway would say, wise words SENSEI, lol"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "Yup, I was trying to figure out why the obvious greedy approach wouldn\\'t work and stared at it for five minutes wondering. I asked ChatGPT why a greedy approach wouldn\\'t work and it kinda broke it :)"
                    },
                    {
                        "username": "gilite",
                        "content": "Very wise."
                    },
                    {
                        "username": "valibraimi",
                        "content": "Easiest Medium ever seen "
                    },
                    {
                        "username": "pratikraj001",
                        "content": "Bro you are wrong don\\'t do it in O(nlog n) ; This is challenge . if only sort then it is  in easy section not in medium."
                    },
                    {
                        "username": "laasyalata16",
                        "content": "Indeed YES!"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@djslim](/djslim) Yes, return false"
                    },
                    {
                        "username": "djslim",
                        "content": "[@XJRr8TyB](/XJRr8TyB) is it even easier?"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "Try 2396 Strictly Palindromic Number"
                    },
                    {
                        "username": "kontsis",
                        "content": "Lets go!!!! Conquered this tough medium, now I\\'m ready for FAANG. See u losers at the top "
                    },
                    {
                        "username": "NITHESH_23",
                        "content": "lol....\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "\\uD83D\\uDE02\\uD83E\\uDD23"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Losers won\\'t be at the top. It would be lonely :/"
                    },
                    {
                        "username": "khoai345678",
                        "content": "u r funny\\n"
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Certified \\uD83C\\uDF66BING CHILLING \\uD83E\\uDD76 problem"
                    },
                    {
                        "username": "drblessing",
                        "content": "BING CHILLING \\uD83C\\uDF66"
                    },
                    {
                        "username": "kmp1084",
                        "content": "Only purpose of this question is to see how many people try to solve this using DP and get TLE."
                    },
                    {
                        "username": "mayank-01",
                        "content": "yes"
                    },
                    {
                        "username": "native_element",
                        "content": "i failed using dp. Then i realised Greedy problem."
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Afzal543](/Afzal543) Recursion \\u2620\\u2620"
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Sorry](/Sorry) Meanwhile I Don\\'t Have Good Knowledge Of DP so I Directly Solved It Using Sorting \\uD83D\\uDE0E"
                    },
                    {
                        "username": "raaj-s",
                        "content": "[@Jonatanlp](/Jonatanlp) Even I was like greedy or dp as this problem slightly reminded me of \\'minimum number of coins needed for a given total\\' problem (as the total is being divided), but then I realized that the bars themselves won\\'t be repeated and they don\\'t have any inherent value. Haha."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "if you sort the array first and do DP approach it will solve all test case"
                    },
                    {
                        "username": "a_pandagre",
                        "content": "yepp, initially thought of DP, but then thought of simply sorting it."
                    },
                    {
                        "username": "Afzal543",
                        "content": "Today while solving this question I saw I have a failed submission on Apr 2021 . Guess what I was using fucking recurrsion . Since then Improved a lot . "
                    },
                    {
                        "username": "Sorry",
                        "content": "32.3% tried DP, because the acceptance rate is 67.7%."
                    },
                    {
                        "username": "shubhankar00",
                        "content": "I spent more time contemplating what I\\'m missing than actually coding the solution. "
                    },
                    {
                        "username": "Maverick767",
                        "content": "I thought there was a trick I was missing when I saw that this was a medium, but nope it\\'s just the easiest medium on the entire website"
                    },
                    {
                        "username": "Sounita51028",
                        "content": "Same here bro XD\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Why are we here ? \\n\\nJust to suffer...."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@user1827o](/user1827o) \\uD83E\\uDEC2"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "We will all make it bro :)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Today no suffering \\uD83D\\uDE05"
                    },
                    {
                        "username": "Joseph86",
                        "content": "bro in the discussion section I always see SOME sort of depressed/meme comment  :s"
                    },
                    {
                        "username": "gullyboy007",
                        "content": "I would say they should have mentioned something about unique ice cream bars or something , otherwise he can simply buy the cheapest one as much as possible(greedy) instead of DP."
                    },
                    {
                        "username": "alexdft",
                        "content": "[@BRABURAJ](/BRABURAJ)  dynamic programming"
                    },
                    {
                        "username": "BRABURAJ",
                        "content": "what is dp?\\n"
                    },
                    {
                        "username": "ankishkhandelwalop",
                        "content": "Appreciate \\n\\neasiest  medium question ever\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did greedy : ) It passed , this should be easy I guess"
                    }
                ]
            },
            {
                "id": 1743708,
                "content": [
                    {
                        "username": "aaron2k12",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "Wanxuan_Li",
                        "content": "definitely"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Yes, I was confused expecting something tricky"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "wasn\\'t going to try this question being new on LeetCode, but this is my only question that was solved in first attempt, lol."
                    },
                    {
                        "username": "drblessing",
                        "content": "Agreed, I was confused at first why it was a Medium. "
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "yess it is very easy problem"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Yes correct this problem teach us to use right approach: \n- if we use DP it will be medium problem \n- If we use greedy its easy problem \n\nbut the point is this problem teach us to use right algorithm"
                    },
                    {
                        "username": "S_Basu",
                        "content": "True"
                    },
                    {
                        "username": "Cut",
                        "content": "My name is aaron too!"
                    },
                    {
                        "username": "Boolean_Autocrats",
                        "content": "this can be easy problem for those who know greedy but for those who don\\'t about it ,this problem is surely medium .  "
                    },
                    {
                        "username": "xeniawann",
                        "content": "Totally agree^^ many people might know how to solve it within 1 minute after reading the question."
                    },
                    {
                        "username": "Mohammed84Farouk",
                        "content": "that\\'s because its the second problem in the contest and they are usually easy, easy-medium..."
                    },
                    {
                        "username": "qiushile",
                        "content": "maybe in some languages, you need to write sort method"
                    },
                    {
                        "username": "djslim",
                        "content": "First time I agree \\uD83E\\uDD23"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I agree"
                    },
                    {
                        "username": "user9382Km",
                        "content": "`Maybe the real challenge, is realizing that there is no challenge.`"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The real challenge is to prove the solution mathematically."
                    },
                    {
                        "username": "bizco8",
                        "content": "haahaha I feel it bro"
                    },
                    {
                        "username": "drblessing",
                        "content": "hahah "
                    },
                    {
                        "username": "TakshPanchal",
                        "content": "shush... don\\'t give spoilers."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "In this case, the problem should be marked as hard."
                    },
                    {
                        "username": "omi23",
                        "content": "lol so true"
                    },
                    {
                        "username": "S_Basu",
                        "content": "\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "picksitquick",
                        "content": "this is what master Oogway would say, wise words SENSEI, lol"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "Yup, I was trying to figure out why the obvious greedy approach wouldn\\'t work and stared at it for five minutes wondering. I asked ChatGPT why a greedy approach wouldn\\'t work and it kinda broke it :)"
                    },
                    {
                        "username": "gilite",
                        "content": "Very wise."
                    },
                    {
                        "username": "valibraimi",
                        "content": "Easiest Medium ever seen "
                    },
                    {
                        "username": "pratikraj001",
                        "content": "Bro you are wrong don\\'t do it in O(nlog n) ; This is challenge . if only sort then it is  in easy section not in medium."
                    },
                    {
                        "username": "laasyalata16",
                        "content": "Indeed YES!"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@djslim](/djslim) Yes, return false"
                    },
                    {
                        "username": "djslim",
                        "content": "[@XJRr8TyB](/XJRr8TyB) is it even easier?"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "Try 2396 Strictly Palindromic Number"
                    },
                    {
                        "username": "kontsis",
                        "content": "Lets go!!!! Conquered this tough medium, now I\\'m ready for FAANG. See u losers at the top "
                    },
                    {
                        "username": "NITHESH_23",
                        "content": "lol....\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "\\uD83D\\uDE02\\uD83E\\uDD23"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Losers won\\'t be at the top. It would be lonely :/"
                    },
                    {
                        "username": "khoai345678",
                        "content": "u r funny\\n"
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Certified \\uD83C\\uDF66BING CHILLING \\uD83E\\uDD76 problem"
                    },
                    {
                        "username": "drblessing",
                        "content": "BING CHILLING \\uD83C\\uDF66"
                    },
                    {
                        "username": "kmp1084",
                        "content": "Only purpose of this question is to see how many people try to solve this using DP and get TLE."
                    },
                    {
                        "username": "mayank-01",
                        "content": "yes"
                    },
                    {
                        "username": "native_element",
                        "content": "i failed using dp. Then i realised Greedy problem."
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Afzal543](/Afzal543) Recursion \\u2620\\u2620"
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Sorry](/Sorry) Meanwhile I Don\\'t Have Good Knowledge Of DP so I Directly Solved It Using Sorting \\uD83D\\uDE0E"
                    },
                    {
                        "username": "raaj-s",
                        "content": "[@Jonatanlp](/Jonatanlp) Even I was like greedy or dp as this problem slightly reminded me of \\'minimum number of coins needed for a given total\\' problem (as the total is being divided), but then I realized that the bars themselves won\\'t be repeated and they don\\'t have any inherent value. Haha."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "if you sort the array first and do DP approach it will solve all test case"
                    },
                    {
                        "username": "a_pandagre",
                        "content": "yepp, initially thought of DP, but then thought of simply sorting it."
                    },
                    {
                        "username": "Afzal543",
                        "content": "Today while solving this question I saw I have a failed submission on Apr 2021 . Guess what I was using fucking recurrsion . Since then Improved a lot . "
                    },
                    {
                        "username": "Sorry",
                        "content": "32.3% tried DP, because the acceptance rate is 67.7%."
                    },
                    {
                        "username": "shubhankar00",
                        "content": "I spent more time contemplating what I\\'m missing than actually coding the solution. "
                    },
                    {
                        "username": "Maverick767",
                        "content": "I thought there was a trick I was missing when I saw that this was a medium, but nope it\\'s just the easiest medium on the entire website"
                    },
                    {
                        "username": "Sounita51028",
                        "content": "Same here bro XD\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Why are we here ? \\n\\nJust to suffer...."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@user1827o](/user1827o) \\uD83E\\uDEC2"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "We will all make it bro :)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Today no suffering \\uD83D\\uDE05"
                    },
                    {
                        "username": "Joseph86",
                        "content": "bro in the discussion section I always see SOME sort of depressed/meme comment  :s"
                    },
                    {
                        "username": "gullyboy007",
                        "content": "I would say they should have mentioned something about unique ice cream bars or something , otherwise he can simply buy the cheapest one as much as possible(greedy) instead of DP."
                    },
                    {
                        "username": "alexdft",
                        "content": "[@BRABURAJ](/BRABURAJ)  dynamic programming"
                    },
                    {
                        "username": "BRABURAJ",
                        "content": "what is dp?\\n"
                    },
                    {
                        "username": "ankishkhandelwalop",
                        "content": "Appreciate \\n\\neasiest  medium question ever\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did greedy : ) It passed , this should be easy I guess"
                    }
                ]
            },
            {
                "id": 1743667,
                "content": [
                    {
                        "username": "aaron2k12",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "Wanxuan_Li",
                        "content": "definitely"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Yes, I was confused expecting something tricky"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "wasn\\'t going to try this question being new on LeetCode, but this is my only question that was solved in first attempt, lol."
                    },
                    {
                        "username": "drblessing",
                        "content": "Agreed, I was confused at first why it was a Medium. "
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "yess it is very easy problem"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Yes correct this problem teach us to use right approach: \n- if we use DP it will be medium problem \n- If we use greedy its easy problem \n\nbut the point is this problem teach us to use right algorithm"
                    },
                    {
                        "username": "S_Basu",
                        "content": "True"
                    },
                    {
                        "username": "Cut",
                        "content": "My name is aaron too!"
                    },
                    {
                        "username": "Boolean_Autocrats",
                        "content": "this can be easy problem for those who know greedy but for those who don\\'t about it ,this problem is surely medium .  "
                    },
                    {
                        "username": "xeniawann",
                        "content": "Totally agree^^ many people might know how to solve it within 1 minute after reading the question."
                    },
                    {
                        "username": "Mohammed84Farouk",
                        "content": "that\\'s because its the second problem in the contest and they are usually easy, easy-medium..."
                    },
                    {
                        "username": "qiushile",
                        "content": "maybe in some languages, you need to write sort method"
                    },
                    {
                        "username": "djslim",
                        "content": "First time I agree \\uD83E\\uDD23"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I agree"
                    },
                    {
                        "username": "user9382Km",
                        "content": "`Maybe the real challenge, is realizing that there is no challenge.`"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The real challenge is to prove the solution mathematically."
                    },
                    {
                        "username": "bizco8",
                        "content": "haahaha I feel it bro"
                    },
                    {
                        "username": "drblessing",
                        "content": "hahah "
                    },
                    {
                        "username": "TakshPanchal",
                        "content": "shush... don\\'t give spoilers."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "In this case, the problem should be marked as hard."
                    },
                    {
                        "username": "omi23",
                        "content": "lol so true"
                    },
                    {
                        "username": "S_Basu",
                        "content": "\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "picksitquick",
                        "content": "this is what master Oogway would say, wise words SENSEI, lol"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "Yup, I was trying to figure out why the obvious greedy approach wouldn\\'t work and stared at it for five minutes wondering. I asked ChatGPT why a greedy approach wouldn\\'t work and it kinda broke it :)"
                    },
                    {
                        "username": "gilite",
                        "content": "Very wise."
                    },
                    {
                        "username": "valibraimi",
                        "content": "Easiest Medium ever seen "
                    },
                    {
                        "username": "pratikraj001",
                        "content": "Bro you are wrong don\\'t do it in O(nlog n) ; This is challenge . if only sort then it is  in easy section not in medium."
                    },
                    {
                        "username": "laasyalata16",
                        "content": "Indeed YES!"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@djslim](/djslim) Yes, return false"
                    },
                    {
                        "username": "djslim",
                        "content": "[@XJRr8TyB](/XJRr8TyB) is it even easier?"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "Try 2396 Strictly Palindromic Number"
                    },
                    {
                        "username": "kontsis",
                        "content": "Lets go!!!! Conquered this tough medium, now I\\'m ready for FAANG. See u losers at the top "
                    },
                    {
                        "username": "NITHESH_23",
                        "content": "lol....\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "\\uD83D\\uDE02\\uD83E\\uDD23"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Losers won\\'t be at the top. It would be lonely :/"
                    },
                    {
                        "username": "khoai345678",
                        "content": "u r funny\\n"
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Certified \\uD83C\\uDF66BING CHILLING \\uD83E\\uDD76 problem"
                    },
                    {
                        "username": "drblessing",
                        "content": "BING CHILLING \\uD83C\\uDF66"
                    },
                    {
                        "username": "kmp1084",
                        "content": "Only purpose of this question is to see how many people try to solve this using DP and get TLE."
                    },
                    {
                        "username": "mayank-01",
                        "content": "yes"
                    },
                    {
                        "username": "native_element",
                        "content": "i failed using dp. Then i realised Greedy problem."
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Afzal543](/Afzal543) Recursion \\u2620\\u2620"
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Sorry](/Sorry) Meanwhile I Don\\'t Have Good Knowledge Of DP so I Directly Solved It Using Sorting \\uD83D\\uDE0E"
                    },
                    {
                        "username": "raaj-s",
                        "content": "[@Jonatanlp](/Jonatanlp) Even I was like greedy or dp as this problem slightly reminded me of \\'minimum number of coins needed for a given total\\' problem (as the total is being divided), but then I realized that the bars themselves won\\'t be repeated and they don\\'t have any inherent value. Haha."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "if you sort the array first and do DP approach it will solve all test case"
                    },
                    {
                        "username": "a_pandagre",
                        "content": "yepp, initially thought of DP, but then thought of simply sorting it."
                    },
                    {
                        "username": "Afzal543",
                        "content": "Today while solving this question I saw I have a failed submission on Apr 2021 . Guess what I was using fucking recurrsion . Since then Improved a lot . "
                    },
                    {
                        "username": "Sorry",
                        "content": "32.3% tried DP, because the acceptance rate is 67.7%."
                    },
                    {
                        "username": "shubhankar00",
                        "content": "I spent more time contemplating what I\\'m missing than actually coding the solution. "
                    },
                    {
                        "username": "Maverick767",
                        "content": "I thought there was a trick I was missing when I saw that this was a medium, but nope it\\'s just the easiest medium on the entire website"
                    },
                    {
                        "username": "Sounita51028",
                        "content": "Same here bro XD\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Why are we here ? \\n\\nJust to suffer...."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@user1827o](/user1827o) \\uD83E\\uDEC2"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "We will all make it bro :)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Today no suffering \\uD83D\\uDE05"
                    },
                    {
                        "username": "Joseph86",
                        "content": "bro in the discussion section I always see SOME sort of depressed/meme comment  :s"
                    },
                    {
                        "username": "gullyboy007",
                        "content": "I would say they should have mentioned something about unique ice cream bars or something , otherwise he can simply buy the cheapest one as much as possible(greedy) instead of DP."
                    },
                    {
                        "username": "alexdft",
                        "content": "[@BRABURAJ](/BRABURAJ)  dynamic programming"
                    },
                    {
                        "username": "BRABURAJ",
                        "content": "what is dp?\\n"
                    },
                    {
                        "username": "ankishkhandelwalop",
                        "content": "Appreciate \\n\\neasiest  medium question ever\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did greedy : ) It passed , this should be easy I guess"
                    }
                ]
            },
            {
                "id": 1743736,
                "content": [
                    {
                        "username": "aaron2k12",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "Wanxuan_Li",
                        "content": "definitely"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Yes, I was confused expecting something tricky"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "wasn\\'t going to try this question being new on LeetCode, but this is my only question that was solved in first attempt, lol."
                    },
                    {
                        "username": "drblessing",
                        "content": "Agreed, I was confused at first why it was a Medium. "
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "yess it is very easy problem"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Yes correct this problem teach us to use right approach: \n- if we use DP it will be medium problem \n- If we use greedy its easy problem \n\nbut the point is this problem teach us to use right algorithm"
                    },
                    {
                        "username": "S_Basu",
                        "content": "True"
                    },
                    {
                        "username": "Cut",
                        "content": "My name is aaron too!"
                    },
                    {
                        "username": "Boolean_Autocrats",
                        "content": "this can be easy problem for those who know greedy but for those who don\\'t about it ,this problem is surely medium .  "
                    },
                    {
                        "username": "xeniawann",
                        "content": "Totally agree^^ many people might know how to solve it within 1 minute after reading the question."
                    },
                    {
                        "username": "Mohammed84Farouk",
                        "content": "that\\'s because its the second problem in the contest and they are usually easy, easy-medium..."
                    },
                    {
                        "username": "qiushile",
                        "content": "maybe in some languages, you need to write sort method"
                    },
                    {
                        "username": "djslim",
                        "content": "First time I agree \\uD83E\\uDD23"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I agree"
                    },
                    {
                        "username": "user9382Km",
                        "content": "`Maybe the real challenge, is realizing that there is no challenge.`"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The real challenge is to prove the solution mathematically."
                    },
                    {
                        "username": "bizco8",
                        "content": "haahaha I feel it bro"
                    },
                    {
                        "username": "drblessing",
                        "content": "hahah "
                    },
                    {
                        "username": "TakshPanchal",
                        "content": "shush... don\\'t give spoilers."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "In this case, the problem should be marked as hard."
                    },
                    {
                        "username": "omi23",
                        "content": "lol so true"
                    },
                    {
                        "username": "S_Basu",
                        "content": "\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "picksitquick",
                        "content": "this is what master Oogway would say, wise words SENSEI, lol"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "Yup, I was trying to figure out why the obvious greedy approach wouldn\\'t work and stared at it for five minutes wondering. I asked ChatGPT why a greedy approach wouldn\\'t work and it kinda broke it :)"
                    },
                    {
                        "username": "gilite",
                        "content": "Very wise."
                    },
                    {
                        "username": "valibraimi",
                        "content": "Easiest Medium ever seen "
                    },
                    {
                        "username": "pratikraj001",
                        "content": "Bro you are wrong don\\'t do it in O(nlog n) ; This is challenge . if only sort then it is  in easy section not in medium."
                    },
                    {
                        "username": "laasyalata16",
                        "content": "Indeed YES!"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@djslim](/djslim) Yes, return false"
                    },
                    {
                        "username": "djslim",
                        "content": "[@XJRr8TyB](/XJRr8TyB) is it even easier?"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "Try 2396 Strictly Palindromic Number"
                    },
                    {
                        "username": "kontsis",
                        "content": "Lets go!!!! Conquered this tough medium, now I\\'m ready for FAANG. See u losers at the top "
                    },
                    {
                        "username": "NITHESH_23",
                        "content": "lol....\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "\\uD83D\\uDE02\\uD83E\\uDD23"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Losers won\\'t be at the top. It would be lonely :/"
                    },
                    {
                        "username": "khoai345678",
                        "content": "u r funny\\n"
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Certified \\uD83C\\uDF66BING CHILLING \\uD83E\\uDD76 problem"
                    },
                    {
                        "username": "drblessing",
                        "content": "BING CHILLING \\uD83C\\uDF66"
                    },
                    {
                        "username": "kmp1084",
                        "content": "Only purpose of this question is to see how many people try to solve this using DP and get TLE."
                    },
                    {
                        "username": "mayank-01",
                        "content": "yes"
                    },
                    {
                        "username": "native_element",
                        "content": "i failed using dp. Then i realised Greedy problem."
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Afzal543](/Afzal543) Recursion \\u2620\\u2620"
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Sorry](/Sorry) Meanwhile I Don\\'t Have Good Knowledge Of DP so I Directly Solved It Using Sorting \\uD83D\\uDE0E"
                    },
                    {
                        "username": "raaj-s",
                        "content": "[@Jonatanlp](/Jonatanlp) Even I was like greedy or dp as this problem slightly reminded me of \\'minimum number of coins needed for a given total\\' problem (as the total is being divided), but then I realized that the bars themselves won\\'t be repeated and they don\\'t have any inherent value. Haha."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "if you sort the array first and do DP approach it will solve all test case"
                    },
                    {
                        "username": "a_pandagre",
                        "content": "yepp, initially thought of DP, but then thought of simply sorting it."
                    },
                    {
                        "username": "Afzal543",
                        "content": "Today while solving this question I saw I have a failed submission on Apr 2021 . Guess what I was using fucking recurrsion . Since then Improved a lot . "
                    },
                    {
                        "username": "Sorry",
                        "content": "32.3% tried DP, because the acceptance rate is 67.7%."
                    },
                    {
                        "username": "shubhankar00",
                        "content": "I spent more time contemplating what I\\'m missing than actually coding the solution. "
                    },
                    {
                        "username": "Maverick767",
                        "content": "I thought there was a trick I was missing when I saw that this was a medium, but nope it\\'s just the easiest medium on the entire website"
                    },
                    {
                        "username": "Sounita51028",
                        "content": "Same here bro XD\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Why are we here ? \\n\\nJust to suffer...."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@user1827o](/user1827o) \\uD83E\\uDEC2"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "We will all make it bro :)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Today no suffering \\uD83D\\uDE05"
                    },
                    {
                        "username": "Joseph86",
                        "content": "bro in the discussion section I always see SOME sort of depressed/meme comment  :s"
                    },
                    {
                        "username": "gullyboy007",
                        "content": "I would say they should have mentioned something about unique ice cream bars or something , otherwise he can simply buy the cheapest one as much as possible(greedy) instead of DP."
                    },
                    {
                        "username": "alexdft",
                        "content": "[@BRABURAJ](/BRABURAJ)  dynamic programming"
                    },
                    {
                        "username": "BRABURAJ",
                        "content": "what is dp?\\n"
                    },
                    {
                        "username": "ankishkhandelwalop",
                        "content": "Appreciate \\n\\neasiest  medium question ever\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did greedy : ) It passed , this should be easy I guess"
                    }
                ]
            },
            {
                "id": 1743957,
                "content": [
                    {
                        "username": "aaron2k12",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "Wanxuan_Li",
                        "content": "definitely"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Yes, I was confused expecting something tricky"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "wasn\\'t going to try this question being new on LeetCode, but this is my only question that was solved in first attempt, lol."
                    },
                    {
                        "username": "drblessing",
                        "content": "Agreed, I was confused at first why it was a Medium. "
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "yess it is very easy problem"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Yes correct this problem teach us to use right approach: \n- if we use DP it will be medium problem \n- If we use greedy its easy problem \n\nbut the point is this problem teach us to use right algorithm"
                    },
                    {
                        "username": "S_Basu",
                        "content": "True"
                    },
                    {
                        "username": "Cut",
                        "content": "My name is aaron too!"
                    },
                    {
                        "username": "Boolean_Autocrats",
                        "content": "this can be easy problem for those who know greedy but for those who don\\'t about it ,this problem is surely medium .  "
                    },
                    {
                        "username": "xeniawann",
                        "content": "Totally agree^^ many people might know how to solve it within 1 minute after reading the question."
                    },
                    {
                        "username": "Mohammed84Farouk",
                        "content": "that\\'s because its the second problem in the contest and they are usually easy, easy-medium..."
                    },
                    {
                        "username": "qiushile",
                        "content": "maybe in some languages, you need to write sort method"
                    },
                    {
                        "username": "djslim",
                        "content": "First time I agree \\uD83E\\uDD23"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I agree"
                    },
                    {
                        "username": "user9382Km",
                        "content": "`Maybe the real challenge, is realizing that there is no challenge.`"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The real challenge is to prove the solution mathematically."
                    },
                    {
                        "username": "bizco8",
                        "content": "haahaha I feel it bro"
                    },
                    {
                        "username": "drblessing",
                        "content": "hahah "
                    },
                    {
                        "username": "TakshPanchal",
                        "content": "shush... don\\'t give spoilers."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "In this case, the problem should be marked as hard."
                    },
                    {
                        "username": "omi23",
                        "content": "lol so true"
                    },
                    {
                        "username": "S_Basu",
                        "content": "\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "picksitquick",
                        "content": "this is what master Oogway would say, wise words SENSEI, lol"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "Yup, I was trying to figure out why the obvious greedy approach wouldn\\'t work and stared at it for five minutes wondering. I asked ChatGPT why a greedy approach wouldn\\'t work and it kinda broke it :)"
                    },
                    {
                        "username": "gilite",
                        "content": "Very wise."
                    },
                    {
                        "username": "valibraimi",
                        "content": "Easiest Medium ever seen "
                    },
                    {
                        "username": "pratikraj001",
                        "content": "Bro you are wrong don\\'t do it in O(nlog n) ; This is challenge . if only sort then it is  in easy section not in medium."
                    },
                    {
                        "username": "laasyalata16",
                        "content": "Indeed YES!"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@djslim](/djslim) Yes, return false"
                    },
                    {
                        "username": "djslim",
                        "content": "[@XJRr8TyB](/XJRr8TyB) is it even easier?"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "Try 2396 Strictly Palindromic Number"
                    },
                    {
                        "username": "kontsis",
                        "content": "Lets go!!!! Conquered this tough medium, now I\\'m ready for FAANG. See u losers at the top "
                    },
                    {
                        "username": "NITHESH_23",
                        "content": "lol....\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "\\uD83D\\uDE02\\uD83E\\uDD23"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Losers won\\'t be at the top. It would be lonely :/"
                    },
                    {
                        "username": "khoai345678",
                        "content": "u r funny\\n"
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Certified \\uD83C\\uDF66BING CHILLING \\uD83E\\uDD76 problem"
                    },
                    {
                        "username": "drblessing",
                        "content": "BING CHILLING \\uD83C\\uDF66"
                    },
                    {
                        "username": "kmp1084",
                        "content": "Only purpose of this question is to see how many people try to solve this using DP and get TLE."
                    },
                    {
                        "username": "mayank-01",
                        "content": "yes"
                    },
                    {
                        "username": "native_element",
                        "content": "i failed using dp. Then i realised Greedy problem."
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Afzal543](/Afzal543) Recursion \\u2620\\u2620"
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Sorry](/Sorry) Meanwhile I Don\\'t Have Good Knowledge Of DP so I Directly Solved It Using Sorting \\uD83D\\uDE0E"
                    },
                    {
                        "username": "raaj-s",
                        "content": "[@Jonatanlp](/Jonatanlp) Even I was like greedy or dp as this problem slightly reminded me of \\'minimum number of coins needed for a given total\\' problem (as the total is being divided), but then I realized that the bars themselves won\\'t be repeated and they don\\'t have any inherent value. Haha."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "if you sort the array first and do DP approach it will solve all test case"
                    },
                    {
                        "username": "a_pandagre",
                        "content": "yepp, initially thought of DP, but then thought of simply sorting it."
                    },
                    {
                        "username": "Afzal543",
                        "content": "Today while solving this question I saw I have a failed submission on Apr 2021 . Guess what I was using fucking recurrsion . Since then Improved a lot . "
                    },
                    {
                        "username": "Sorry",
                        "content": "32.3% tried DP, because the acceptance rate is 67.7%."
                    },
                    {
                        "username": "shubhankar00",
                        "content": "I spent more time contemplating what I\\'m missing than actually coding the solution. "
                    },
                    {
                        "username": "Maverick767",
                        "content": "I thought there was a trick I was missing when I saw that this was a medium, but nope it\\'s just the easiest medium on the entire website"
                    },
                    {
                        "username": "Sounita51028",
                        "content": "Same here bro XD\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Why are we here ? \\n\\nJust to suffer...."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@user1827o](/user1827o) \\uD83E\\uDEC2"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "We will all make it bro :)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Today no suffering \\uD83D\\uDE05"
                    },
                    {
                        "username": "Joseph86",
                        "content": "bro in the discussion section I always see SOME sort of depressed/meme comment  :s"
                    },
                    {
                        "username": "gullyboy007",
                        "content": "I would say they should have mentioned something about unique ice cream bars or something , otherwise he can simply buy the cheapest one as much as possible(greedy) instead of DP."
                    },
                    {
                        "username": "alexdft",
                        "content": "[@BRABURAJ](/BRABURAJ)  dynamic programming"
                    },
                    {
                        "username": "BRABURAJ",
                        "content": "what is dp?\\n"
                    },
                    {
                        "username": "ankishkhandelwalop",
                        "content": "Appreciate \\n\\neasiest  medium question ever\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did greedy : ) It passed , this should be easy I guess"
                    }
                ]
            },
            {
                "id": 1743749,
                "content": [
                    {
                        "username": "aaron2k12",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "Wanxuan_Li",
                        "content": "definitely"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Yes, I was confused expecting something tricky"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "wasn\\'t going to try this question being new on LeetCode, but this is my only question that was solved in first attempt, lol."
                    },
                    {
                        "username": "drblessing",
                        "content": "Agreed, I was confused at first why it was a Medium. "
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "yess it is very easy problem"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Yes correct this problem teach us to use right approach: \n- if we use DP it will be medium problem \n- If we use greedy its easy problem \n\nbut the point is this problem teach us to use right algorithm"
                    },
                    {
                        "username": "S_Basu",
                        "content": "True"
                    },
                    {
                        "username": "Cut",
                        "content": "My name is aaron too!"
                    },
                    {
                        "username": "Boolean_Autocrats",
                        "content": "this can be easy problem for those who know greedy but for those who don\\'t about it ,this problem is surely medium .  "
                    },
                    {
                        "username": "xeniawann",
                        "content": "Totally agree^^ many people might know how to solve it within 1 minute after reading the question."
                    },
                    {
                        "username": "Mohammed84Farouk",
                        "content": "that\\'s because its the second problem in the contest and they are usually easy, easy-medium..."
                    },
                    {
                        "username": "qiushile",
                        "content": "maybe in some languages, you need to write sort method"
                    },
                    {
                        "username": "djslim",
                        "content": "First time I agree \\uD83E\\uDD23"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I agree"
                    },
                    {
                        "username": "user9382Km",
                        "content": "`Maybe the real challenge, is realizing that there is no challenge.`"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The real challenge is to prove the solution mathematically."
                    },
                    {
                        "username": "bizco8",
                        "content": "haahaha I feel it bro"
                    },
                    {
                        "username": "drblessing",
                        "content": "hahah "
                    },
                    {
                        "username": "TakshPanchal",
                        "content": "shush... don\\'t give spoilers."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "In this case, the problem should be marked as hard."
                    },
                    {
                        "username": "omi23",
                        "content": "lol so true"
                    },
                    {
                        "username": "S_Basu",
                        "content": "\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "picksitquick",
                        "content": "this is what master Oogway would say, wise words SENSEI, lol"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "Yup, I was trying to figure out why the obvious greedy approach wouldn\\'t work and stared at it for five minutes wondering. I asked ChatGPT why a greedy approach wouldn\\'t work and it kinda broke it :)"
                    },
                    {
                        "username": "gilite",
                        "content": "Very wise."
                    },
                    {
                        "username": "valibraimi",
                        "content": "Easiest Medium ever seen "
                    },
                    {
                        "username": "pratikraj001",
                        "content": "Bro you are wrong don\\'t do it in O(nlog n) ; This is challenge . if only sort then it is  in easy section not in medium."
                    },
                    {
                        "username": "laasyalata16",
                        "content": "Indeed YES!"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@djslim](/djslim) Yes, return false"
                    },
                    {
                        "username": "djslim",
                        "content": "[@XJRr8TyB](/XJRr8TyB) is it even easier?"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "Try 2396 Strictly Palindromic Number"
                    },
                    {
                        "username": "kontsis",
                        "content": "Lets go!!!! Conquered this tough medium, now I\\'m ready for FAANG. See u losers at the top "
                    },
                    {
                        "username": "NITHESH_23",
                        "content": "lol....\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "\\uD83D\\uDE02\\uD83E\\uDD23"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Losers won\\'t be at the top. It would be lonely :/"
                    },
                    {
                        "username": "khoai345678",
                        "content": "u r funny\\n"
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Certified \\uD83C\\uDF66BING CHILLING \\uD83E\\uDD76 problem"
                    },
                    {
                        "username": "drblessing",
                        "content": "BING CHILLING \\uD83C\\uDF66"
                    },
                    {
                        "username": "kmp1084",
                        "content": "Only purpose of this question is to see how many people try to solve this using DP and get TLE."
                    },
                    {
                        "username": "mayank-01",
                        "content": "yes"
                    },
                    {
                        "username": "native_element",
                        "content": "i failed using dp. Then i realised Greedy problem."
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Afzal543](/Afzal543) Recursion \\u2620\\u2620"
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Sorry](/Sorry) Meanwhile I Don\\'t Have Good Knowledge Of DP so I Directly Solved It Using Sorting \\uD83D\\uDE0E"
                    },
                    {
                        "username": "raaj-s",
                        "content": "[@Jonatanlp](/Jonatanlp) Even I was like greedy or dp as this problem slightly reminded me of \\'minimum number of coins needed for a given total\\' problem (as the total is being divided), but then I realized that the bars themselves won\\'t be repeated and they don\\'t have any inherent value. Haha."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "if you sort the array first and do DP approach it will solve all test case"
                    },
                    {
                        "username": "a_pandagre",
                        "content": "yepp, initially thought of DP, but then thought of simply sorting it."
                    },
                    {
                        "username": "Afzal543",
                        "content": "Today while solving this question I saw I have a failed submission on Apr 2021 . Guess what I was using fucking recurrsion . Since then Improved a lot . "
                    },
                    {
                        "username": "Sorry",
                        "content": "32.3% tried DP, because the acceptance rate is 67.7%."
                    },
                    {
                        "username": "shubhankar00",
                        "content": "I spent more time contemplating what I\\'m missing than actually coding the solution. "
                    },
                    {
                        "username": "Maverick767",
                        "content": "I thought there was a trick I was missing when I saw that this was a medium, but nope it\\'s just the easiest medium on the entire website"
                    },
                    {
                        "username": "Sounita51028",
                        "content": "Same here bro XD\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Why are we here ? \\n\\nJust to suffer...."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@user1827o](/user1827o) \\uD83E\\uDEC2"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "We will all make it bro :)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Today no suffering \\uD83D\\uDE05"
                    },
                    {
                        "username": "Joseph86",
                        "content": "bro in the discussion section I always see SOME sort of depressed/meme comment  :s"
                    },
                    {
                        "username": "gullyboy007",
                        "content": "I would say they should have mentioned something about unique ice cream bars or something , otherwise he can simply buy the cheapest one as much as possible(greedy) instead of DP."
                    },
                    {
                        "username": "alexdft",
                        "content": "[@BRABURAJ](/BRABURAJ)  dynamic programming"
                    },
                    {
                        "username": "BRABURAJ",
                        "content": "what is dp?\\n"
                    },
                    {
                        "username": "ankishkhandelwalop",
                        "content": "Appreciate \\n\\neasiest  medium question ever\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did greedy : ) It passed , this should be easy I guess"
                    }
                ]
            },
            {
                "id": 1743650,
                "content": [
                    {
                        "username": "aaron2k12",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "Wanxuan_Li",
                        "content": "definitely"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Yes, I was confused expecting something tricky"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "wasn\\'t going to try this question being new on LeetCode, but this is my only question that was solved in first attempt, lol."
                    },
                    {
                        "username": "drblessing",
                        "content": "Agreed, I was confused at first why it was a Medium. "
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "yess it is very easy problem"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Yes correct this problem teach us to use right approach: \n- if we use DP it will be medium problem \n- If we use greedy its easy problem \n\nbut the point is this problem teach us to use right algorithm"
                    },
                    {
                        "username": "S_Basu",
                        "content": "True"
                    },
                    {
                        "username": "Cut",
                        "content": "My name is aaron too!"
                    },
                    {
                        "username": "Boolean_Autocrats",
                        "content": "this can be easy problem for those who know greedy but for those who don\\'t about it ,this problem is surely medium .  "
                    },
                    {
                        "username": "xeniawann",
                        "content": "Totally agree^^ many people might know how to solve it within 1 minute after reading the question."
                    },
                    {
                        "username": "Mohammed84Farouk",
                        "content": "that\\'s because its the second problem in the contest and they are usually easy, easy-medium..."
                    },
                    {
                        "username": "qiushile",
                        "content": "maybe in some languages, you need to write sort method"
                    },
                    {
                        "username": "djslim",
                        "content": "First time I agree \\uD83E\\uDD23"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I agree"
                    },
                    {
                        "username": "user9382Km",
                        "content": "`Maybe the real challenge, is realizing that there is no challenge.`"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The real challenge is to prove the solution mathematically."
                    },
                    {
                        "username": "bizco8",
                        "content": "haahaha I feel it bro"
                    },
                    {
                        "username": "drblessing",
                        "content": "hahah "
                    },
                    {
                        "username": "TakshPanchal",
                        "content": "shush... don\\'t give spoilers."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "In this case, the problem should be marked as hard."
                    },
                    {
                        "username": "omi23",
                        "content": "lol so true"
                    },
                    {
                        "username": "S_Basu",
                        "content": "\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "picksitquick",
                        "content": "this is what master Oogway would say, wise words SENSEI, lol"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "Yup, I was trying to figure out why the obvious greedy approach wouldn\\'t work and stared at it for five minutes wondering. I asked ChatGPT why a greedy approach wouldn\\'t work and it kinda broke it :)"
                    },
                    {
                        "username": "gilite",
                        "content": "Very wise."
                    },
                    {
                        "username": "valibraimi",
                        "content": "Easiest Medium ever seen "
                    },
                    {
                        "username": "pratikraj001",
                        "content": "Bro you are wrong don\\'t do it in O(nlog n) ; This is challenge . if only sort then it is  in easy section not in medium."
                    },
                    {
                        "username": "laasyalata16",
                        "content": "Indeed YES!"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@djslim](/djslim) Yes, return false"
                    },
                    {
                        "username": "djslim",
                        "content": "[@XJRr8TyB](/XJRr8TyB) is it even easier?"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "Try 2396 Strictly Palindromic Number"
                    },
                    {
                        "username": "kontsis",
                        "content": "Lets go!!!! Conquered this tough medium, now I\\'m ready for FAANG. See u losers at the top "
                    },
                    {
                        "username": "NITHESH_23",
                        "content": "lol....\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "\\uD83D\\uDE02\\uD83E\\uDD23"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Losers won\\'t be at the top. It would be lonely :/"
                    },
                    {
                        "username": "khoai345678",
                        "content": "u r funny\\n"
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Certified \\uD83C\\uDF66BING CHILLING \\uD83E\\uDD76 problem"
                    },
                    {
                        "username": "drblessing",
                        "content": "BING CHILLING \\uD83C\\uDF66"
                    },
                    {
                        "username": "kmp1084",
                        "content": "Only purpose of this question is to see how many people try to solve this using DP and get TLE."
                    },
                    {
                        "username": "mayank-01",
                        "content": "yes"
                    },
                    {
                        "username": "native_element",
                        "content": "i failed using dp. Then i realised Greedy problem."
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Afzal543](/Afzal543) Recursion \\u2620\\u2620"
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Sorry](/Sorry) Meanwhile I Don\\'t Have Good Knowledge Of DP so I Directly Solved It Using Sorting \\uD83D\\uDE0E"
                    },
                    {
                        "username": "raaj-s",
                        "content": "[@Jonatanlp](/Jonatanlp) Even I was like greedy or dp as this problem slightly reminded me of \\'minimum number of coins needed for a given total\\' problem (as the total is being divided), but then I realized that the bars themselves won\\'t be repeated and they don\\'t have any inherent value. Haha."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "if you sort the array first and do DP approach it will solve all test case"
                    },
                    {
                        "username": "a_pandagre",
                        "content": "yepp, initially thought of DP, but then thought of simply sorting it."
                    },
                    {
                        "username": "Afzal543",
                        "content": "Today while solving this question I saw I have a failed submission on Apr 2021 . Guess what I was using fucking recurrsion . Since then Improved a lot . "
                    },
                    {
                        "username": "Sorry",
                        "content": "32.3% tried DP, because the acceptance rate is 67.7%."
                    },
                    {
                        "username": "shubhankar00",
                        "content": "I spent more time contemplating what I\\'m missing than actually coding the solution. "
                    },
                    {
                        "username": "Maverick767",
                        "content": "I thought there was a trick I was missing when I saw that this was a medium, but nope it\\'s just the easiest medium on the entire website"
                    },
                    {
                        "username": "Sounita51028",
                        "content": "Same here bro XD\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Why are we here ? \\n\\nJust to suffer...."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@user1827o](/user1827o) \\uD83E\\uDEC2"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "We will all make it bro :)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Today no suffering \\uD83D\\uDE05"
                    },
                    {
                        "username": "Joseph86",
                        "content": "bro in the discussion section I always see SOME sort of depressed/meme comment  :s"
                    },
                    {
                        "username": "gullyboy007",
                        "content": "I would say they should have mentioned something about unique ice cream bars or something , otherwise he can simply buy the cheapest one as much as possible(greedy) instead of DP."
                    },
                    {
                        "username": "alexdft",
                        "content": "[@BRABURAJ](/BRABURAJ)  dynamic programming"
                    },
                    {
                        "username": "BRABURAJ",
                        "content": "what is dp?\\n"
                    },
                    {
                        "username": "ankishkhandelwalop",
                        "content": "Appreciate \\n\\neasiest  medium question ever\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did greedy : ) It passed , this should be easy I guess"
                    }
                ]
            },
            {
                "id": 1648107,
                "content": [
                    {
                        "username": "aaron2k12",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "Wanxuan_Li",
                        "content": "definitely"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Yes, I was confused expecting something tricky"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "wasn\\'t going to try this question being new on LeetCode, but this is my only question that was solved in first attempt, lol."
                    },
                    {
                        "username": "drblessing",
                        "content": "Agreed, I was confused at first why it was a Medium. "
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "yess it is very easy problem"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Yes correct this problem teach us to use right approach: \n- if we use DP it will be medium problem \n- If we use greedy its easy problem \n\nbut the point is this problem teach us to use right algorithm"
                    },
                    {
                        "username": "S_Basu",
                        "content": "True"
                    },
                    {
                        "username": "Cut",
                        "content": "My name is aaron too!"
                    },
                    {
                        "username": "Boolean_Autocrats",
                        "content": "this can be easy problem for those who know greedy but for those who don\\'t about it ,this problem is surely medium .  "
                    },
                    {
                        "username": "xeniawann",
                        "content": "Totally agree^^ many people might know how to solve it within 1 minute after reading the question."
                    },
                    {
                        "username": "Mohammed84Farouk",
                        "content": "that\\'s because its the second problem in the contest and they are usually easy, easy-medium..."
                    },
                    {
                        "username": "qiushile",
                        "content": "maybe in some languages, you need to write sort method"
                    },
                    {
                        "username": "djslim",
                        "content": "First time I agree \\uD83E\\uDD23"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I agree"
                    },
                    {
                        "username": "user9382Km",
                        "content": "`Maybe the real challenge, is realizing that there is no challenge.`"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The real challenge is to prove the solution mathematically."
                    },
                    {
                        "username": "bizco8",
                        "content": "haahaha I feel it bro"
                    },
                    {
                        "username": "drblessing",
                        "content": "hahah "
                    },
                    {
                        "username": "TakshPanchal",
                        "content": "shush... don\\'t give spoilers."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "In this case, the problem should be marked as hard."
                    },
                    {
                        "username": "omi23",
                        "content": "lol so true"
                    },
                    {
                        "username": "S_Basu",
                        "content": "\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "picksitquick",
                        "content": "this is what master Oogway would say, wise words SENSEI, lol"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "Yup, I was trying to figure out why the obvious greedy approach wouldn\\'t work and stared at it for five minutes wondering. I asked ChatGPT why a greedy approach wouldn\\'t work and it kinda broke it :)"
                    },
                    {
                        "username": "gilite",
                        "content": "Very wise."
                    },
                    {
                        "username": "valibraimi",
                        "content": "Easiest Medium ever seen "
                    },
                    {
                        "username": "pratikraj001",
                        "content": "Bro you are wrong don\\'t do it in O(nlog n) ; This is challenge . if only sort then it is  in easy section not in medium."
                    },
                    {
                        "username": "laasyalata16",
                        "content": "Indeed YES!"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@djslim](/djslim) Yes, return false"
                    },
                    {
                        "username": "djslim",
                        "content": "[@XJRr8TyB](/XJRr8TyB) is it even easier?"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "Try 2396 Strictly Palindromic Number"
                    },
                    {
                        "username": "kontsis",
                        "content": "Lets go!!!! Conquered this tough medium, now I\\'m ready for FAANG. See u losers at the top "
                    },
                    {
                        "username": "NITHESH_23",
                        "content": "lol....\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "\\uD83D\\uDE02\\uD83E\\uDD23"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Losers won\\'t be at the top. It would be lonely :/"
                    },
                    {
                        "username": "khoai345678",
                        "content": "u r funny\\n"
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Certified \\uD83C\\uDF66BING CHILLING \\uD83E\\uDD76 problem"
                    },
                    {
                        "username": "drblessing",
                        "content": "BING CHILLING \\uD83C\\uDF66"
                    },
                    {
                        "username": "kmp1084",
                        "content": "Only purpose of this question is to see how many people try to solve this using DP and get TLE."
                    },
                    {
                        "username": "mayank-01",
                        "content": "yes"
                    },
                    {
                        "username": "native_element",
                        "content": "i failed using dp. Then i realised Greedy problem."
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Afzal543](/Afzal543) Recursion \\u2620\\u2620"
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Sorry](/Sorry) Meanwhile I Don\\'t Have Good Knowledge Of DP so I Directly Solved It Using Sorting \\uD83D\\uDE0E"
                    },
                    {
                        "username": "raaj-s",
                        "content": "[@Jonatanlp](/Jonatanlp) Even I was like greedy or dp as this problem slightly reminded me of \\'minimum number of coins needed for a given total\\' problem (as the total is being divided), but then I realized that the bars themselves won\\'t be repeated and they don\\'t have any inherent value. Haha."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "if you sort the array first and do DP approach it will solve all test case"
                    },
                    {
                        "username": "a_pandagre",
                        "content": "yepp, initially thought of DP, but then thought of simply sorting it."
                    },
                    {
                        "username": "Afzal543",
                        "content": "Today while solving this question I saw I have a failed submission on Apr 2021 . Guess what I was using fucking recurrsion . Since then Improved a lot . "
                    },
                    {
                        "username": "Sorry",
                        "content": "32.3% tried DP, because the acceptance rate is 67.7%."
                    },
                    {
                        "username": "shubhankar00",
                        "content": "I spent more time contemplating what I\\'m missing than actually coding the solution. "
                    },
                    {
                        "username": "Maverick767",
                        "content": "I thought there was a trick I was missing when I saw that this was a medium, but nope it\\'s just the easiest medium on the entire website"
                    },
                    {
                        "username": "Sounita51028",
                        "content": "Same here bro XD\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Why are we here ? \\n\\nJust to suffer...."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@user1827o](/user1827o) \\uD83E\\uDEC2"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "We will all make it bro :)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Today no suffering \\uD83D\\uDE05"
                    },
                    {
                        "username": "Joseph86",
                        "content": "bro in the discussion section I always see SOME sort of depressed/meme comment  :s"
                    },
                    {
                        "username": "gullyboy007",
                        "content": "I would say they should have mentioned something about unique ice cream bars or something , otherwise he can simply buy the cheapest one as much as possible(greedy) instead of DP."
                    },
                    {
                        "username": "alexdft",
                        "content": "[@BRABURAJ](/BRABURAJ)  dynamic programming"
                    },
                    {
                        "username": "BRABURAJ",
                        "content": "what is dp?\\n"
                    },
                    {
                        "username": "ankishkhandelwalop",
                        "content": "Appreciate \\n\\neasiest  medium question ever\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did greedy : ) It passed , this should be easy I guess"
                    }
                ]
            },
            {
                "id": 1743657,
                "content": [
                    {
                        "username": "aaron2k12",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "Wanxuan_Li",
                        "content": "definitely"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Yes, I was confused expecting something tricky"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "wasn\\'t going to try this question being new on LeetCode, but this is my only question that was solved in first attempt, lol."
                    },
                    {
                        "username": "drblessing",
                        "content": "Agreed, I was confused at first why it was a Medium. "
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "yess it is very easy problem"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Yes correct this problem teach us to use right approach: \n- if we use DP it will be medium problem \n- If we use greedy its easy problem \n\nbut the point is this problem teach us to use right algorithm"
                    },
                    {
                        "username": "S_Basu",
                        "content": "True"
                    },
                    {
                        "username": "Cut",
                        "content": "My name is aaron too!"
                    },
                    {
                        "username": "Boolean_Autocrats",
                        "content": "this can be easy problem for those who know greedy but for those who don\\'t about it ,this problem is surely medium .  "
                    },
                    {
                        "username": "xeniawann",
                        "content": "Totally agree^^ many people might know how to solve it within 1 minute after reading the question."
                    },
                    {
                        "username": "Mohammed84Farouk",
                        "content": "that\\'s because its the second problem in the contest and they are usually easy, easy-medium..."
                    },
                    {
                        "username": "qiushile",
                        "content": "maybe in some languages, you need to write sort method"
                    },
                    {
                        "username": "djslim",
                        "content": "First time I agree \\uD83E\\uDD23"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I agree"
                    },
                    {
                        "username": "user9382Km",
                        "content": "`Maybe the real challenge, is realizing that there is no challenge.`"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The real challenge is to prove the solution mathematically."
                    },
                    {
                        "username": "bizco8",
                        "content": "haahaha I feel it bro"
                    },
                    {
                        "username": "drblessing",
                        "content": "hahah "
                    },
                    {
                        "username": "TakshPanchal",
                        "content": "shush... don\\'t give spoilers."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "In this case, the problem should be marked as hard."
                    },
                    {
                        "username": "omi23",
                        "content": "lol so true"
                    },
                    {
                        "username": "S_Basu",
                        "content": "\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "picksitquick",
                        "content": "this is what master Oogway would say, wise words SENSEI, lol"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "Yup, I was trying to figure out why the obvious greedy approach wouldn\\'t work and stared at it for five minutes wondering. I asked ChatGPT why a greedy approach wouldn\\'t work and it kinda broke it :)"
                    },
                    {
                        "username": "gilite",
                        "content": "Very wise."
                    },
                    {
                        "username": "valibraimi",
                        "content": "Easiest Medium ever seen "
                    },
                    {
                        "username": "pratikraj001",
                        "content": "Bro you are wrong don\\'t do it in O(nlog n) ; This is challenge . if only sort then it is  in easy section not in medium."
                    },
                    {
                        "username": "laasyalata16",
                        "content": "Indeed YES!"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@djslim](/djslim) Yes, return false"
                    },
                    {
                        "username": "djslim",
                        "content": "[@XJRr8TyB](/XJRr8TyB) is it even easier?"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "Try 2396 Strictly Palindromic Number"
                    },
                    {
                        "username": "kontsis",
                        "content": "Lets go!!!! Conquered this tough medium, now I\\'m ready for FAANG. See u losers at the top "
                    },
                    {
                        "username": "NITHESH_23",
                        "content": "lol....\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "\\uD83D\\uDE02\\uD83E\\uDD23"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Losers won\\'t be at the top. It would be lonely :/"
                    },
                    {
                        "username": "khoai345678",
                        "content": "u r funny\\n"
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Certified \\uD83C\\uDF66BING CHILLING \\uD83E\\uDD76 problem"
                    },
                    {
                        "username": "drblessing",
                        "content": "BING CHILLING \\uD83C\\uDF66"
                    },
                    {
                        "username": "kmp1084",
                        "content": "Only purpose of this question is to see how many people try to solve this using DP and get TLE."
                    },
                    {
                        "username": "mayank-01",
                        "content": "yes"
                    },
                    {
                        "username": "native_element",
                        "content": "i failed using dp. Then i realised Greedy problem."
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Afzal543](/Afzal543) Recursion \\u2620\\u2620"
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Sorry](/Sorry) Meanwhile I Don\\'t Have Good Knowledge Of DP so I Directly Solved It Using Sorting \\uD83D\\uDE0E"
                    },
                    {
                        "username": "raaj-s",
                        "content": "[@Jonatanlp](/Jonatanlp) Even I was like greedy or dp as this problem slightly reminded me of \\'minimum number of coins needed for a given total\\' problem (as the total is being divided), but then I realized that the bars themselves won\\'t be repeated and they don\\'t have any inherent value. Haha."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "if you sort the array first and do DP approach it will solve all test case"
                    },
                    {
                        "username": "a_pandagre",
                        "content": "yepp, initially thought of DP, but then thought of simply sorting it."
                    },
                    {
                        "username": "Afzal543",
                        "content": "Today while solving this question I saw I have a failed submission on Apr 2021 . Guess what I was using fucking recurrsion . Since then Improved a lot . "
                    },
                    {
                        "username": "Sorry",
                        "content": "32.3% tried DP, because the acceptance rate is 67.7%."
                    },
                    {
                        "username": "shubhankar00",
                        "content": "I spent more time contemplating what I\\'m missing than actually coding the solution. "
                    },
                    {
                        "username": "Maverick767",
                        "content": "I thought there was a trick I was missing when I saw that this was a medium, but nope it\\'s just the easiest medium on the entire website"
                    },
                    {
                        "username": "Sounita51028",
                        "content": "Same here bro XD\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Why are we here ? \\n\\nJust to suffer...."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@user1827o](/user1827o) \\uD83E\\uDEC2"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "We will all make it bro :)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Today no suffering \\uD83D\\uDE05"
                    },
                    {
                        "username": "Joseph86",
                        "content": "bro in the discussion section I always see SOME sort of depressed/meme comment  :s"
                    },
                    {
                        "username": "gullyboy007",
                        "content": "I would say they should have mentioned something about unique ice cream bars or something , otherwise he can simply buy the cheapest one as much as possible(greedy) instead of DP."
                    },
                    {
                        "username": "alexdft",
                        "content": "[@BRABURAJ](/BRABURAJ)  dynamic programming"
                    },
                    {
                        "username": "BRABURAJ",
                        "content": "what is dp?\\n"
                    },
                    {
                        "username": "ankishkhandelwalop",
                        "content": "Appreciate \\n\\neasiest  medium question ever\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did greedy : ) It passed , this should be easy I guess"
                    }
                ]
            },
            {
                "id": 1743810,
                "content": [
                    {
                        "username": "aaron2k12",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "Wanxuan_Li",
                        "content": "definitely"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Yes, I was confused expecting something tricky"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "wasn\\'t going to try this question being new on LeetCode, but this is my only question that was solved in first attempt, lol."
                    },
                    {
                        "username": "drblessing",
                        "content": "Agreed, I was confused at first why it was a Medium. "
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "yess it is very easy problem"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Yes correct this problem teach us to use right approach: \n- if we use DP it will be medium problem \n- If we use greedy its easy problem \n\nbut the point is this problem teach us to use right algorithm"
                    },
                    {
                        "username": "S_Basu",
                        "content": "True"
                    },
                    {
                        "username": "Cut",
                        "content": "My name is aaron too!"
                    },
                    {
                        "username": "Boolean_Autocrats",
                        "content": "this can be easy problem for those who know greedy but for those who don\\'t about it ,this problem is surely medium .  "
                    },
                    {
                        "username": "xeniawann",
                        "content": "Totally agree^^ many people might know how to solve it within 1 minute after reading the question."
                    },
                    {
                        "username": "Mohammed84Farouk",
                        "content": "that\\'s because its the second problem in the contest and they are usually easy, easy-medium..."
                    },
                    {
                        "username": "qiushile",
                        "content": "maybe in some languages, you need to write sort method"
                    },
                    {
                        "username": "djslim",
                        "content": "First time I agree \\uD83E\\uDD23"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I agree"
                    },
                    {
                        "username": "user9382Km",
                        "content": "`Maybe the real challenge, is realizing that there is no challenge.`"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The real challenge is to prove the solution mathematically."
                    },
                    {
                        "username": "bizco8",
                        "content": "haahaha I feel it bro"
                    },
                    {
                        "username": "drblessing",
                        "content": "hahah "
                    },
                    {
                        "username": "TakshPanchal",
                        "content": "shush... don\\'t give spoilers."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "In this case, the problem should be marked as hard."
                    },
                    {
                        "username": "omi23",
                        "content": "lol so true"
                    },
                    {
                        "username": "S_Basu",
                        "content": "\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "picksitquick",
                        "content": "this is what master Oogway would say, wise words SENSEI, lol"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "Yup, I was trying to figure out why the obvious greedy approach wouldn\\'t work and stared at it for five minutes wondering. I asked ChatGPT why a greedy approach wouldn\\'t work and it kinda broke it :)"
                    },
                    {
                        "username": "gilite",
                        "content": "Very wise."
                    },
                    {
                        "username": "valibraimi",
                        "content": "Easiest Medium ever seen "
                    },
                    {
                        "username": "pratikraj001",
                        "content": "Bro you are wrong don\\'t do it in O(nlog n) ; This is challenge . if only sort then it is  in easy section not in medium."
                    },
                    {
                        "username": "laasyalata16",
                        "content": "Indeed YES!"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@djslim](/djslim) Yes, return false"
                    },
                    {
                        "username": "djslim",
                        "content": "[@XJRr8TyB](/XJRr8TyB) is it even easier?"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "Try 2396 Strictly Palindromic Number"
                    },
                    {
                        "username": "kontsis",
                        "content": "Lets go!!!! Conquered this tough medium, now I\\'m ready for FAANG. See u losers at the top "
                    },
                    {
                        "username": "NITHESH_23",
                        "content": "lol....\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "\\uD83D\\uDE02\\uD83E\\uDD23"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Losers won\\'t be at the top. It would be lonely :/"
                    },
                    {
                        "username": "khoai345678",
                        "content": "u r funny\\n"
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Certified \\uD83C\\uDF66BING CHILLING \\uD83E\\uDD76 problem"
                    },
                    {
                        "username": "drblessing",
                        "content": "BING CHILLING \\uD83C\\uDF66"
                    },
                    {
                        "username": "kmp1084",
                        "content": "Only purpose of this question is to see how many people try to solve this using DP and get TLE."
                    },
                    {
                        "username": "mayank-01",
                        "content": "yes"
                    },
                    {
                        "username": "native_element",
                        "content": "i failed using dp. Then i realised Greedy problem."
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Afzal543](/Afzal543) Recursion \\u2620\\u2620"
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Sorry](/Sorry) Meanwhile I Don\\'t Have Good Knowledge Of DP so I Directly Solved It Using Sorting \\uD83D\\uDE0E"
                    },
                    {
                        "username": "raaj-s",
                        "content": "[@Jonatanlp](/Jonatanlp) Even I was like greedy or dp as this problem slightly reminded me of \\'minimum number of coins needed for a given total\\' problem (as the total is being divided), but then I realized that the bars themselves won\\'t be repeated and they don\\'t have any inherent value. Haha."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "if you sort the array first and do DP approach it will solve all test case"
                    },
                    {
                        "username": "a_pandagre",
                        "content": "yepp, initially thought of DP, but then thought of simply sorting it."
                    },
                    {
                        "username": "Afzal543",
                        "content": "Today while solving this question I saw I have a failed submission on Apr 2021 . Guess what I was using fucking recurrsion . Since then Improved a lot . "
                    },
                    {
                        "username": "Sorry",
                        "content": "32.3% tried DP, because the acceptance rate is 67.7%."
                    },
                    {
                        "username": "shubhankar00",
                        "content": "I spent more time contemplating what I\\'m missing than actually coding the solution. "
                    },
                    {
                        "username": "Maverick767",
                        "content": "I thought there was a trick I was missing when I saw that this was a medium, but nope it\\'s just the easiest medium on the entire website"
                    },
                    {
                        "username": "Sounita51028",
                        "content": "Same here bro XD\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Why are we here ? \\n\\nJust to suffer...."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@user1827o](/user1827o) \\uD83E\\uDEC2"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "We will all make it bro :)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Today no suffering \\uD83D\\uDE05"
                    },
                    {
                        "username": "Joseph86",
                        "content": "bro in the discussion section I always see SOME sort of depressed/meme comment  :s"
                    },
                    {
                        "username": "gullyboy007",
                        "content": "I would say they should have mentioned something about unique ice cream bars or something , otherwise he can simply buy the cheapest one as much as possible(greedy) instead of DP."
                    },
                    {
                        "username": "alexdft",
                        "content": "[@BRABURAJ](/BRABURAJ)  dynamic programming"
                    },
                    {
                        "username": "BRABURAJ",
                        "content": "what is dp?\\n"
                    },
                    {
                        "username": "ankishkhandelwalop",
                        "content": "Appreciate \\n\\neasiest  medium question ever\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did greedy : ) It passed , this should be easy I guess"
                    }
                ]
            },
            {
                "id": 1743660,
                "content": [
                    {
                        "username": "aaron2k12",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "Wanxuan_Li",
                        "content": "definitely"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Yes, I was confused expecting something tricky"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "wasn\\'t going to try this question being new on LeetCode, but this is my only question that was solved in first attempt, lol."
                    },
                    {
                        "username": "drblessing",
                        "content": "Agreed, I was confused at first why it was a Medium. "
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "yess it is very easy problem"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Yes correct this problem teach us to use right approach: \n- if we use DP it will be medium problem \n- If we use greedy its easy problem \n\nbut the point is this problem teach us to use right algorithm"
                    },
                    {
                        "username": "S_Basu",
                        "content": "True"
                    },
                    {
                        "username": "Cut",
                        "content": "My name is aaron too!"
                    },
                    {
                        "username": "Boolean_Autocrats",
                        "content": "this can be easy problem for those who know greedy but for those who don\\'t about it ,this problem is surely medium .  "
                    },
                    {
                        "username": "xeniawann",
                        "content": "Totally agree^^ many people might know how to solve it within 1 minute after reading the question."
                    },
                    {
                        "username": "Mohammed84Farouk",
                        "content": "that\\'s because its the second problem in the contest and they are usually easy, easy-medium..."
                    },
                    {
                        "username": "qiushile",
                        "content": "maybe in some languages, you need to write sort method"
                    },
                    {
                        "username": "djslim",
                        "content": "First time I agree \\uD83E\\uDD23"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I agree"
                    },
                    {
                        "username": "user9382Km",
                        "content": "`Maybe the real challenge, is realizing that there is no challenge.`"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The real challenge is to prove the solution mathematically."
                    },
                    {
                        "username": "bizco8",
                        "content": "haahaha I feel it bro"
                    },
                    {
                        "username": "drblessing",
                        "content": "hahah "
                    },
                    {
                        "username": "TakshPanchal",
                        "content": "shush... don\\'t give spoilers."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "In this case, the problem should be marked as hard."
                    },
                    {
                        "username": "omi23",
                        "content": "lol so true"
                    },
                    {
                        "username": "S_Basu",
                        "content": "\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "picksitquick",
                        "content": "this is what master Oogway would say, wise words SENSEI, lol"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "Yup, I was trying to figure out why the obvious greedy approach wouldn\\'t work and stared at it for five minutes wondering. I asked ChatGPT why a greedy approach wouldn\\'t work and it kinda broke it :)"
                    },
                    {
                        "username": "gilite",
                        "content": "Very wise."
                    },
                    {
                        "username": "valibraimi",
                        "content": "Easiest Medium ever seen "
                    },
                    {
                        "username": "pratikraj001",
                        "content": "Bro you are wrong don\\'t do it in O(nlog n) ; This is challenge . if only sort then it is  in easy section not in medium."
                    },
                    {
                        "username": "laasyalata16",
                        "content": "Indeed YES!"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@djslim](/djslim) Yes, return false"
                    },
                    {
                        "username": "djslim",
                        "content": "[@XJRr8TyB](/XJRr8TyB) is it even easier?"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "Try 2396 Strictly Palindromic Number"
                    },
                    {
                        "username": "kontsis",
                        "content": "Lets go!!!! Conquered this tough medium, now I\\'m ready for FAANG. See u losers at the top "
                    },
                    {
                        "username": "NITHESH_23",
                        "content": "lol....\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "\\uD83D\\uDE02\\uD83E\\uDD23"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Losers won\\'t be at the top. It would be lonely :/"
                    },
                    {
                        "username": "khoai345678",
                        "content": "u r funny\\n"
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Certified \\uD83C\\uDF66BING CHILLING \\uD83E\\uDD76 problem"
                    },
                    {
                        "username": "drblessing",
                        "content": "BING CHILLING \\uD83C\\uDF66"
                    },
                    {
                        "username": "kmp1084",
                        "content": "Only purpose of this question is to see how many people try to solve this using DP and get TLE."
                    },
                    {
                        "username": "mayank-01",
                        "content": "yes"
                    },
                    {
                        "username": "native_element",
                        "content": "i failed using dp. Then i realised Greedy problem."
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Afzal543](/Afzal543) Recursion \\u2620\\u2620"
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Sorry](/Sorry) Meanwhile I Don\\'t Have Good Knowledge Of DP so I Directly Solved It Using Sorting \\uD83D\\uDE0E"
                    },
                    {
                        "username": "raaj-s",
                        "content": "[@Jonatanlp](/Jonatanlp) Even I was like greedy or dp as this problem slightly reminded me of \\'minimum number of coins needed for a given total\\' problem (as the total is being divided), but then I realized that the bars themselves won\\'t be repeated and they don\\'t have any inherent value. Haha."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "if you sort the array first and do DP approach it will solve all test case"
                    },
                    {
                        "username": "a_pandagre",
                        "content": "yepp, initially thought of DP, but then thought of simply sorting it."
                    },
                    {
                        "username": "Afzal543",
                        "content": "Today while solving this question I saw I have a failed submission on Apr 2021 . Guess what I was using fucking recurrsion . Since then Improved a lot . "
                    },
                    {
                        "username": "Sorry",
                        "content": "32.3% tried DP, because the acceptance rate is 67.7%."
                    },
                    {
                        "username": "shubhankar00",
                        "content": "I spent more time contemplating what I\\'m missing than actually coding the solution. "
                    },
                    {
                        "username": "Maverick767",
                        "content": "I thought there was a trick I was missing when I saw that this was a medium, but nope it\\'s just the easiest medium on the entire website"
                    },
                    {
                        "username": "Sounita51028",
                        "content": "Same here bro XD\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Why are we here ? \\n\\nJust to suffer...."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@user1827o](/user1827o) \\uD83E\\uDEC2"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "We will all make it bro :)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Today no suffering \\uD83D\\uDE05"
                    },
                    {
                        "username": "Joseph86",
                        "content": "bro in the discussion section I always see SOME sort of depressed/meme comment  :s"
                    },
                    {
                        "username": "gullyboy007",
                        "content": "I would say they should have mentioned something about unique ice cream bars or something , otherwise he can simply buy the cheapest one as much as possible(greedy) instead of DP."
                    },
                    {
                        "username": "alexdft",
                        "content": "[@BRABURAJ](/BRABURAJ)  dynamic programming"
                    },
                    {
                        "username": "BRABURAJ",
                        "content": "what is dp?\\n"
                    },
                    {
                        "username": "ankishkhandelwalop",
                        "content": "Appreciate \\n\\neasiest  medium question ever\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did greedy : ) It passed , this should be easy I guess"
                    }
                ]
            },
            {
                "id": 1743708,
                "content": [
                    {
                        "username": "aaron2k12",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "Wanxuan_Li",
                        "content": "definitely"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Yes, I was confused expecting something tricky"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "wasn\\'t going to try this question being new on LeetCode, but this is my only question that was solved in first attempt, lol."
                    },
                    {
                        "username": "drblessing",
                        "content": "Agreed, I was confused at first why it was a Medium. "
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "yess it is very easy problem"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Yes correct this problem teach us to use right approach: \n- if we use DP it will be medium problem \n- If we use greedy its easy problem \n\nbut the point is this problem teach us to use right algorithm"
                    },
                    {
                        "username": "S_Basu",
                        "content": "True"
                    },
                    {
                        "username": "Cut",
                        "content": "My name is aaron too!"
                    },
                    {
                        "username": "Boolean_Autocrats",
                        "content": "this can be easy problem for those who know greedy but for those who don\\'t about it ,this problem is surely medium .  "
                    },
                    {
                        "username": "xeniawann",
                        "content": "Totally agree^^ many people might know how to solve it within 1 minute after reading the question."
                    },
                    {
                        "username": "Mohammed84Farouk",
                        "content": "that\\'s because its the second problem in the contest and they are usually easy, easy-medium..."
                    },
                    {
                        "username": "qiushile",
                        "content": "maybe in some languages, you need to write sort method"
                    },
                    {
                        "username": "djslim",
                        "content": "First time I agree \\uD83E\\uDD23"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I agree"
                    },
                    {
                        "username": "user9382Km",
                        "content": "`Maybe the real challenge, is realizing that there is no challenge.`"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The real challenge is to prove the solution mathematically."
                    },
                    {
                        "username": "bizco8",
                        "content": "haahaha I feel it bro"
                    },
                    {
                        "username": "drblessing",
                        "content": "hahah "
                    },
                    {
                        "username": "TakshPanchal",
                        "content": "shush... don\\'t give spoilers."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "In this case, the problem should be marked as hard."
                    },
                    {
                        "username": "omi23",
                        "content": "lol so true"
                    },
                    {
                        "username": "S_Basu",
                        "content": "\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "picksitquick",
                        "content": "this is what master Oogway would say, wise words SENSEI, lol"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "Yup, I was trying to figure out why the obvious greedy approach wouldn\\'t work and stared at it for five minutes wondering. I asked ChatGPT why a greedy approach wouldn\\'t work and it kinda broke it :)"
                    },
                    {
                        "username": "gilite",
                        "content": "Very wise."
                    },
                    {
                        "username": "valibraimi",
                        "content": "Easiest Medium ever seen "
                    },
                    {
                        "username": "pratikraj001",
                        "content": "Bro you are wrong don\\'t do it in O(nlog n) ; This is challenge . if only sort then it is  in easy section not in medium."
                    },
                    {
                        "username": "laasyalata16",
                        "content": "Indeed YES!"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@djslim](/djslim) Yes, return false"
                    },
                    {
                        "username": "djslim",
                        "content": "[@XJRr8TyB](/XJRr8TyB) is it even easier?"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "Try 2396 Strictly Palindromic Number"
                    },
                    {
                        "username": "kontsis",
                        "content": "Lets go!!!! Conquered this tough medium, now I\\'m ready for FAANG. See u losers at the top "
                    },
                    {
                        "username": "NITHESH_23",
                        "content": "lol....\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "\\uD83D\\uDE02\\uD83E\\uDD23"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Losers won\\'t be at the top. It would be lonely :/"
                    },
                    {
                        "username": "khoai345678",
                        "content": "u r funny\\n"
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Certified \\uD83C\\uDF66BING CHILLING \\uD83E\\uDD76 problem"
                    },
                    {
                        "username": "drblessing",
                        "content": "BING CHILLING \\uD83C\\uDF66"
                    },
                    {
                        "username": "kmp1084",
                        "content": "Only purpose of this question is to see how many people try to solve this using DP and get TLE."
                    },
                    {
                        "username": "mayank-01",
                        "content": "yes"
                    },
                    {
                        "username": "native_element",
                        "content": "i failed using dp. Then i realised Greedy problem."
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Afzal543](/Afzal543) Recursion \\u2620\\u2620"
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Sorry](/Sorry) Meanwhile I Don\\'t Have Good Knowledge Of DP so I Directly Solved It Using Sorting \\uD83D\\uDE0E"
                    },
                    {
                        "username": "raaj-s",
                        "content": "[@Jonatanlp](/Jonatanlp) Even I was like greedy or dp as this problem slightly reminded me of \\'minimum number of coins needed for a given total\\' problem (as the total is being divided), but then I realized that the bars themselves won\\'t be repeated and they don\\'t have any inherent value. Haha."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "if you sort the array first and do DP approach it will solve all test case"
                    },
                    {
                        "username": "a_pandagre",
                        "content": "yepp, initially thought of DP, but then thought of simply sorting it."
                    },
                    {
                        "username": "Afzal543",
                        "content": "Today while solving this question I saw I have a failed submission on Apr 2021 . Guess what I was using fucking recurrsion . Since then Improved a lot . "
                    },
                    {
                        "username": "Sorry",
                        "content": "32.3% tried DP, because the acceptance rate is 67.7%."
                    },
                    {
                        "username": "shubhankar00",
                        "content": "I spent more time contemplating what I\\'m missing than actually coding the solution. "
                    },
                    {
                        "username": "Maverick767",
                        "content": "I thought there was a trick I was missing when I saw that this was a medium, but nope it\\'s just the easiest medium on the entire website"
                    },
                    {
                        "username": "Sounita51028",
                        "content": "Same here bro XD\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Why are we here ? \\n\\nJust to suffer...."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@user1827o](/user1827o) \\uD83E\\uDEC2"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "We will all make it bro :)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Today no suffering \\uD83D\\uDE05"
                    },
                    {
                        "username": "Joseph86",
                        "content": "bro in the discussion section I always see SOME sort of depressed/meme comment  :s"
                    },
                    {
                        "username": "gullyboy007",
                        "content": "I would say they should have mentioned something about unique ice cream bars or something , otherwise he can simply buy the cheapest one as much as possible(greedy) instead of DP."
                    },
                    {
                        "username": "alexdft",
                        "content": "[@BRABURAJ](/BRABURAJ)  dynamic programming"
                    },
                    {
                        "username": "BRABURAJ",
                        "content": "what is dp?\\n"
                    },
                    {
                        "username": "ankishkhandelwalop",
                        "content": "Appreciate \\n\\neasiest  medium question ever\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did greedy : ) It passed , this should be easy I guess"
                    }
                ]
            },
            {
                "id": 1743667,
                "content": [
                    {
                        "username": "aaron2k12",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "Wanxuan_Li",
                        "content": "definitely"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Yes, I was confused expecting something tricky"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "wasn\\'t going to try this question being new on LeetCode, but this is my only question that was solved in first attempt, lol."
                    },
                    {
                        "username": "drblessing",
                        "content": "Agreed, I was confused at first why it was a Medium. "
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "yess it is very easy problem"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Yes correct this problem teach us to use right approach: \n- if we use DP it will be medium problem \n- If we use greedy its easy problem \n\nbut the point is this problem teach us to use right algorithm"
                    },
                    {
                        "username": "S_Basu",
                        "content": "True"
                    },
                    {
                        "username": "Cut",
                        "content": "My name is aaron too!"
                    },
                    {
                        "username": "Boolean_Autocrats",
                        "content": "this can be easy problem for those who know greedy but for those who don\\'t about it ,this problem is surely medium .  "
                    },
                    {
                        "username": "xeniawann",
                        "content": "Totally agree^^ many people might know how to solve it within 1 minute after reading the question."
                    },
                    {
                        "username": "Mohammed84Farouk",
                        "content": "that\\'s because its the second problem in the contest and they are usually easy, easy-medium..."
                    },
                    {
                        "username": "qiushile",
                        "content": "maybe in some languages, you need to write sort method"
                    },
                    {
                        "username": "djslim",
                        "content": "First time I agree \\uD83E\\uDD23"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I agree"
                    },
                    {
                        "username": "user9382Km",
                        "content": "`Maybe the real challenge, is realizing that there is no challenge.`"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The real challenge is to prove the solution mathematically."
                    },
                    {
                        "username": "bizco8",
                        "content": "haahaha I feel it bro"
                    },
                    {
                        "username": "drblessing",
                        "content": "hahah "
                    },
                    {
                        "username": "TakshPanchal",
                        "content": "shush... don\\'t give spoilers."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "In this case, the problem should be marked as hard."
                    },
                    {
                        "username": "omi23",
                        "content": "lol so true"
                    },
                    {
                        "username": "S_Basu",
                        "content": "\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "picksitquick",
                        "content": "this is what master Oogway would say, wise words SENSEI, lol"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "Yup, I was trying to figure out why the obvious greedy approach wouldn\\'t work and stared at it for five minutes wondering. I asked ChatGPT why a greedy approach wouldn\\'t work and it kinda broke it :)"
                    },
                    {
                        "username": "gilite",
                        "content": "Very wise."
                    },
                    {
                        "username": "valibraimi",
                        "content": "Easiest Medium ever seen "
                    },
                    {
                        "username": "pratikraj001",
                        "content": "Bro you are wrong don\\'t do it in O(nlog n) ; This is challenge . if only sort then it is  in easy section not in medium."
                    },
                    {
                        "username": "laasyalata16",
                        "content": "Indeed YES!"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@djslim](/djslim) Yes, return false"
                    },
                    {
                        "username": "djslim",
                        "content": "[@XJRr8TyB](/XJRr8TyB) is it even easier?"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "Try 2396 Strictly Palindromic Number"
                    },
                    {
                        "username": "kontsis",
                        "content": "Lets go!!!! Conquered this tough medium, now I\\'m ready for FAANG. See u losers at the top "
                    },
                    {
                        "username": "NITHESH_23",
                        "content": "lol....\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "\\uD83D\\uDE02\\uD83E\\uDD23"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Losers won\\'t be at the top. It would be lonely :/"
                    },
                    {
                        "username": "khoai345678",
                        "content": "u r funny\\n"
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Certified \\uD83C\\uDF66BING CHILLING \\uD83E\\uDD76 problem"
                    },
                    {
                        "username": "drblessing",
                        "content": "BING CHILLING \\uD83C\\uDF66"
                    },
                    {
                        "username": "kmp1084",
                        "content": "Only purpose of this question is to see how many people try to solve this using DP and get TLE."
                    },
                    {
                        "username": "mayank-01",
                        "content": "yes"
                    },
                    {
                        "username": "native_element",
                        "content": "i failed using dp. Then i realised Greedy problem."
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Afzal543](/Afzal543) Recursion \\u2620\\u2620"
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Sorry](/Sorry) Meanwhile I Don\\'t Have Good Knowledge Of DP so I Directly Solved It Using Sorting \\uD83D\\uDE0E"
                    },
                    {
                        "username": "raaj-s",
                        "content": "[@Jonatanlp](/Jonatanlp) Even I was like greedy or dp as this problem slightly reminded me of \\'minimum number of coins needed for a given total\\' problem (as the total is being divided), but then I realized that the bars themselves won\\'t be repeated and they don\\'t have any inherent value. Haha."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "if you sort the array first and do DP approach it will solve all test case"
                    },
                    {
                        "username": "a_pandagre",
                        "content": "yepp, initially thought of DP, but then thought of simply sorting it."
                    },
                    {
                        "username": "Afzal543",
                        "content": "Today while solving this question I saw I have a failed submission on Apr 2021 . Guess what I was using fucking recurrsion . Since then Improved a lot . "
                    },
                    {
                        "username": "Sorry",
                        "content": "32.3% tried DP, because the acceptance rate is 67.7%."
                    },
                    {
                        "username": "shubhankar00",
                        "content": "I spent more time contemplating what I\\'m missing than actually coding the solution. "
                    },
                    {
                        "username": "Maverick767",
                        "content": "I thought there was a trick I was missing when I saw that this was a medium, but nope it\\'s just the easiest medium on the entire website"
                    },
                    {
                        "username": "Sounita51028",
                        "content": "Same here bro XD\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Why are we here ? \\n\\nJust to suffer...."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@user1827o](/user1827o) \\uD83E\\uDEC2"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "We will all make it bro :)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Today no suffering \\uD83D\\uDE05"
                    },
                    {
                        "username": "Joseph86",
                        "content": "bro in the discussion section I always see SOME sort of depressed/meme comment  :s"
                    },
                    {
                        "username": "gullyboy007",
                        "content": "I would say they should have mentioned something about unique ice cream bars or something , otherwise he can simply buy the cheapest one as much as possible(greedy) instead of DP."
                    },
                    {
                        "username": "alexdft",
                        "content": "[@BRABURAJ](/BRABURAJ)  dynamic programming"
                    },
                    {
                        "username": "BRABURAJ",
                        "content": "what is dp?\\n"
                    },
                    {
                        "username": "ankishkhandelwalop",
                        "content": "Appreciate \\n\\neasiest  medium question ever\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did greedy : ) It passed , this should be easy I guess"
                    }
                ]
            },
            {
                "id": 1743736,
                "content": [
                    {
                        "username": "aaron2k12",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "Wanxuan_Li",
                        "content": "definitely"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Yes, I was confused expecting something tricky"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "wasn\\'t going to try this question being new on LeetCode, but this is my only question that was solved in first attempt, lol."
                    },
                    {
                        "username": "drblessing",
                        "content": "Agreed, I was confused at first why it was a Medium. "
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "yess it is very easy problem"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Yes correct this problem teach us to use right approach: \n- if we use DP it will be medium problem \n- If we use greedy its easy problem \n\nbut the point is this problem teach us to use right algorithm"
                    },
                    {
                        "username": "S_Basu",
                        "content": "True"
                    },
                    {
                        "username": "Cut",
                        "content": "My name is aaron too!"
                    },
                    {
                        "username": "Boolean_Autocrats",
                        "content": "this can be easy problem for those who know greedy but for those who don\\'t about it ,this problem is surely medium .  "
                    },
                    {
                        "username": "xeniawann",
                        "content": "Totally agree^^ many people might know how to solve it within 1 minute after reading the question."
                    },
                    {
                        "username": "Mohammed84Farouk",
                        "content": "that\\'s because its the second problem in the contest and they are usually easy, easy-medium..."
                    },
                    {
                        "username": "qiushile",
                        "content": "maybe in some languages, you need to write sort method"
                    },
                    {
                        "username": "djslim",
                        "content": "First time I agree \\uD83E\\uDD23"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I agree"
                    },
                    {
                        "username": "user9382Km",
                        "content": "`Maybe the real challenge, is realizing that there is no challenge.`"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The real challenge is to prove the solution mathematically."
                    },
                    {
                        "username": "bizco8",
                        "content": "haahaha I feel it bro"
                    },
                    {
                        "username": "drblessing",
                        "content": "hahah "
                    },
                    {
                        "username": "TakshPanchal",
                        "content": "shush... don\\'t give spoilers."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "In this case, the problem should be marked as hard."
                    },
                    {
                        "username": "omi23",
                        "content": "lol so true"
                    },
                    {
                        "username": "S_Basu",
                        "content": "\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "picksitquick",
                        "content": "this is what master Oogway would say, wise words SENSEI, lol"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "Yup, I was trying to figure out why the obvious greedy approach wouldn\\'t work and stared at it for five minutes wondering. I asked ChatGPT why a greedy approach wouldn\\'t work and it kinda broke it :)"
                    },
                    {
                        "username": "gilite",
                        "content": "Very wise."
                    },
                    {
                        "username": "valibraimi",
                        "content": "Easiest Medium ever seen "
                    },
                    {
                        "username": "pratikraj001",
                        "content": "Bro you are wrong don\\'t do it in O(nlog n) ; This is challenge . if only sort then it is  in easy section not in medium."
                    },
                    {
                        "username": "laasyalata16",
                        "content": "Indeed YES!"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@djslim](/djslim) Yes, return false"
                    },
                    {
                        "username": "djslim",
                        "content": "[@XJRr8TyB](/XJRr8TyB) is it even easier?"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "Try 2396 Strictly Palindromic Number"
                    },
                    {
                        "username": "kontsis",
                        "content": "Lets go!!!! Conquered this tough medium, now I\\'m ready for FAANG. See u losers at the top "
                    },
                    {
                        "username": "NITHESH_23",
                        "content": "lol....\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "\\uD83D\\uDE02\\uD83E\\uDD23"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Losers won\\'t be at the top. It would be lonely :/"
                    },
                    {
                        "username": "khoai345678",
                        "content": "u r funny\\n"
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Certified \\uD83C\\uDF66BING CHILLING \\uD83E\\uDD76 problem"
                    },
                    {
                        "username": "drblessing",
                        "content": "BING CHILLING \\uD83C\\uDF66"
                    },
                    {
                        "username": "kmp1084",
                        "content": "Only purpose of this question is to see how many people try to solve this using DP and get TLE."
                    },
                    {
                        "username": "mayank-01",
                        "content": "yes"
                    },
                    {
                        "username": "native_element",
                        "content": "i failed using dp. Then i realised Greedy problem."
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Afzal543](/Afzal543) Recursion \\u2620\\u2620"
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Sorry](/Sorry) Meanwhile I Don\\'t Have Good Knowledge Of DP so I Directly Solved It Using Sorting \\uD83D\\uDE0E"
                    },
                    {
                        "username": "raaj-s",
                        "content": "[@Jonatanlp](/Jonatanlp) Even I was like greedy or dp as this problem slightly reminded me of \\'minimum number of coins needed for a given total\\' problem (as the total is being divided), but then I realized that the bars themselves won\\'t be repeated and they don\\'t have any inherent value. Haha."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "if you sort the array first and do DP approach it will solve all test case"
                    },
                    {
                        "username": "a_pandagre",
                        "content": "yepp, initially thought of DP, but then thought of simply sorting it."
                    },
                    {
                        "username": "Afzal543",
                        "content": "Today while solving this question I saw I have a failed submission on Apr 2021 . Guess what I was using fucking recurrsion . Since then Improved a lot . "
                    },
                    {
                        "username": "Sorry",
                        "content": "32.3% tried DP, because the acceptance rate is 67.7%."
                    },
                    {
                        "username": "shubhankar00",
                        "content": "I spent more time contemplating what I\\'m missing than actually coding the solution. "
                    },
                    {
                        "username": "Maverick767",
                        "content": "I thought there was a trick I was missing when I saw that this was a medium, but nope it\\'s just the easiest medium on the entire website"
                    },
                    {
                        "username": "Sounita51028",
                        "content": "Same here bro XD\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Why are we here ? \\n\\nJust to suffer...."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@user1827o](/user1827o) \\uD83E\\uDEC2"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "We will all make it bro :)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Today no suffering \\uD83D\\uDE05"
                    },
                    {
                        "username": "Joseph86",
                        "content": "bro in the discussion section I always see SOME sort of depressed/meme comment  :s"
                    },
                    {
                        "username": "gullyboy007",
                        "content": "I would say they should have mentioned something about unique ice cream bars or something , otherwise he can simply buy the cheapest one as much as possible(greedy) instead of DP."
                    },
                    {
                        "username": "alexdft",
                        "content": "[@BRABURAJ](/BRABURAJ)  dynamic programming"
                    },
                    {
                        "username": "BRABURAJ",
                        "content": "what is dp?\\n"
                    },
                    {
                        "username": "ankishkhandelwalop",
                        "content": "Appreciate \\n\\neasiest  medium question ever\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did greedy : ) It passed , this should be easy I guess"
                    }
                ]
            },
            {
                "id": 1743957,
                "content": [
                    {
                        "username": "aaron2k12",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "Wanxuan_Li",
                        "content": "definitely"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Yes, I was confused expecting something tricky"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "wasn\\'t going to try this question being new on LeetCode, but this is my only question that was solved in first attempt, lol."
                    },
                    {
                        "username": "drblessing",
                        "content": "Agreed, I was confused at first why it was a Medium. "
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "yess it is very easy problem"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Yes correct this problem teach us to use right approach: \n- if we use DP it will be medium problem \n- If we use greedy its easy problem \n\nbut the point is this problem teach us to use right algorithm"
                    },
                    {
                        "username": "S_Basu",
                        "content": "True"
                    },
                    {
                        "username": "Cut",
                        "content": "My name is aaron too!"
                    },
                    {
                        "username": "Boolean_Autocrats",
                        "content": "this can be easy problem for those who know greedy but for those who don\\'t about it ,this problem is surely medium .  "
                    },
                    {
                        "username": "xeniawann",
                        "content": "Totally agree^^ many people might know how to solve it within 1 minute after reading the question."
                    },
                    {
                        "username": "Mohammed84Farouk",
                        "content": "that\\'s because its the second problem in the contest and they are usually easy, easy-medium..."
                    },
                    {
                        "username": "qiushile",
                        "content": "maybe in some languages, you need to write sort method"
                    },
                    {
                        "username": "djslim",
                        "content": "First time I agree \\uD83E\\uDD23"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I agree"
                    },
                    {
                        "username": "user9382Km",
                        "content": "`Maybe the real challenge, is realizing that there is no challenge.`"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The real challenge is to prove the solution mathematically."
                    },
                    {
                        "username": "bizco8",
                        "content": "haahaha I feel it bro"
                    },
                    {
                        "username": "drblessing",
                        "content": "hahah "
                    },
                    {
                        "username": "TakshPanchal",
                        "content": "shush... don\\'t give spoilers."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "In this case, the problem should be marked as hard."
                    },
                    {
                        "username": "omi23",
                        "content": "lol so true"
                    },
                    {
                        "username": "S_Basu",
                        "content": "\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "picksitquick",
                        "content": "this is what master Oogway would say, wise words SENSEI, lol"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "Yup, I was trying to figure out why the obvious greedy approach wouldn\\'t work and stared at it for five minutes wondering. I asked ChatGPT why a greedy approach wouldn\\'t work and it kinda broke it :)"
                    },
                    {
                        "username": "gilite",
                        "content": "Very wise."
                    },
                    {
                        "username": "valibraimi",
                        "content": "Easiest Medium ever seen "
                    },
                    {
                        "username": "pratikraj001",
                        "content": "Bro you are wrong don\\'t do it in O(nlog n) ; This is challenge . if only sort then it is  in easy section not in medium."
                    },
                    {
                        "username": "laasyalata16",
                        "content": "Indeed YES!"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@djslim](/djslim) Yes, return false"
                    },
                    {
                        "username": "djslim",
                        "content": "[@XJRr8TyB](/XJRr8TyB) is it even easier?"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "Try 2396 Strictly Palindromic Number"
                    },
                    {
                        "username": "kontsis",
                        "content": "Lets go!!!! Conquered this tough medium, now I\\'m ready for FAANG. See u losers at the top "
                    },
                    {
                        "username": "NITHESH_23",
                        "content": "lol....\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "\\uD83D\\uDE02\\uD83E\\uDD23"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Losers won\\'t be at the top. It would be lonely :/"
                    },
                    {
                        "username": "khoai345678",
                        "content": "u r funny\\n"
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Certified \\uD83C\\uDF66BING CHILLING \\uD83E\\uDD76 problem"
                    },
                    {
                        "username": "drblessing",
                        "content": "BING CHILLING \\uD83C\\uDF66"
                    },
                    {
                        "username": "kmp1084",
                        "content": "Only purpose of this question is to see how many people try to solve this using DP and get TLE."
                    },
                    {
                        "username": "mayank-01",
                        "content": "yes"
                    },
                    {
                        "username": "native_element",
                        "content": "i failed using dp. Then i realised Greedy problem."
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Afzal543](/Afzal543) Recursion \\u2620\\u2620"
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Sorry](/Sorry) Meanwhile I Don\\'t Have Good Knowledge Of DP so I Directly Solved It Using Sorting \\uD83D\\uDE0E"
                    },
                    {
                        "username": "raaj-s",
                        "content": "[@Jonatanlp](/Jonatanlp) Even I was like greedy or dp as this problem slightly reminded me of \\'minimum number of coins needed for a given total\\' problem (as the total is being divided), but then I realized that the bars themselves won\\'t be repeated and they don\\'t have any inherent value. Haha."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "if you sort the array first and do DP approach it will solve all test case"
                    },
                    {
                        "username": "a_pandagre",
                        "content": "yepp, initially thought of DP, but then thought of simply sorting it."
                    },
                    {
                        "username": "Afzal543",
                        "content": "Today while solving this question I saw I have a failed submission on Apr 2021 . Guess what I was using fucking recurrsion . Since then Improved a lot . "
                    },
                    {
                        "username": "Sorry",
                        "content": "32.3% tried DP, because the acceptance rate is 67.7%."
                    },
                    {
                        "username": "shubhankar00",
                        "content": "I spent more time contemplating what I\\'m missing than actually coding the solution. "
                    },
                    {
                        "username": "Maverick767",
                        "content": "I thought there was a trick I was missing when I saw that this was a medium, but nope it\\'s just the easiest medium on the entire website"
                    },
                    {
                        "username": "Sounita51028",
                        "content": "Same here bro XD\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Why are we here ? \\n\\nJust to suffer...."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@user1827o](/user1827o) \\uD83E\\uDEC2"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "We will all make it bro :)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Today no suffering \\uD83D\\uDE05"
                    },
                    {
                        "username": "Joseph86",
                        "content": "bro in the discussion section I always see SOME sort of depressed/meme comment  :s"
                    },
                    {
                        "username": "gullyboy007",
                        "content": "I would say they should have mentioned something about unique ice cream bars or something , otherwise he can simply buy the cheapest one as much as possible(greedy) instead of DP."
                    },
                    {
                        "username": "alexdft",
                        "content": "[@BRABURAJ](/BRABURAJ)  dynamic programming"
                    },
                    {
                        "username": "BRABURAJ",
                        "content": "what is dp?\\n"
                    },
                    {
                        "username": "ankishkhandelwalop",
                        "content": "Appreciate \\n\\neasiest  medium question ever\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did greedy : ) It passed , this should be easy I guess"
                    }
                ]
            },
            {
                "id": 1743749,
                "content": [
                    {
                        "username": "aaron2k12",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "Wanxuan_Li",
                        "content": "definitely"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Yes, I was confused expecting something tricky"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "wasn\\'t going to try this question being new on LeetCode, but this is my only question that was solved in first attempt, lol."
                    },
                    {
                        "username": "drblessing",
                        "content": "Agreed, I was confused at first why it was a Medium. "
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "yess it is very easy problem"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Yes correct this problem teach us to use right approach: \n- if we use DP it will be medium problem \n- If we use greedy its easy problem \n\nbut the point is this problem teach us to use right algorithm"
                    },
                    {
                        "username": "S_Basu",
                        "content": "True"
                    },
                    {
                        "username": "Cut",
                        "content": "My name is aaron too!"
                    },
                    {
                        "username": "Boolean_Autocrats",
                        "content": "this can be easy problem for those who know greedy but for those who don\\'t about it ,this problem is surely medium .  "
                    },
                    {
                        "username": "xeniawann",
                        "content": "Totally agree^^ many people might know how to solve it within 1 minute after reading the question."
                    },
                    {
                        "username": "Mohammed84Farouk",
                        "content": "that\\'s because its the second problem in the contest and they are usually easy, easy-medium..."
                    },
                    {
                        "username": "qiushile",
                        "content": "maybe in some languages, you need to write sort method"
                    },
                    {
                        "username": "djslim",
                        "content": "First time I agree \\uD83E\\uDD23"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I agree"
                    },
                    {
                        "username": "user9382Km",
                        "content": "`Maybe the real challenge, is realizing that there is no challenge.`"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The real challenge is to prove the solution mathematically."
                    },
                    {
                        "username": "bizco8",
                        "content": "haahaha I feel it bro"
                    },
                    {
                        "username": "drblessing",
                        "content": "hahah "
                    },
                    {
                        "username": "TakshPanchal",
                        "content": "shush... don\\'t give spoilers."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "In this case, the problem should be marked as hard."
                    },
                    {
                        "username": "omi23",
                        "content": "lol so true"
                    },
                    {
                        "username": "S_Basu",
                        "content": "\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "picksitquick",
                        "content": "this is what master Oogway would say, wise words SENSEI, lol"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "Yup, I was trying to figure out why the obvious greedy approach wouldn\\'t work and stared at it for five minutes wondering. I asked ChatGPT why a greedy approach wouldn\\'t work and it kinda broke it :)"
                    },
                    {
                        "username": "gilite",
                        "content": "Very wise."
                    },
                    {
                        "username": "valibraimi",
                        "content": "Easiest Medium ever seen "
                    },
                    {
                        "username": "pratikraj001",
                        "content": "Bro you are wrong don\\'t do it in O(nlog n) ; This is challenge . if only sort then it is  in easy section not in medium."
                    },
                    {
                        "username": "laasyalata16",
                        "content": "Indeed YES!"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@djslim](/djslim) Yes, return false"
                    },
                    {
                        "username": "djslim",
                        "content": "[@XJRr8TyB](/XJRr8TyB) is it even easier?"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "Try 2396 Strictly Palindromic Number"
                    },
                    {
                        "username": "kontsis",
                        "content": "Lets go!!!! Conquered this tough medium, now I\\'m ready for FAANG. See u losers at the top "
                    },
                    {
                        "username": "NITHESH_23",
                        "content": "lol....\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "\\uD83D\\uDE02\\uD83E\\uDD23"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Losers won\\'t be at the top. It would be lonely :/"
                    },
                    {
                        "username": "khoai345678",
                        "content": "u r funny\\n"
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Certified \\uD83C\\uDF66BING CHILLING \\uD83E\\uDD76 problem"
                    },
                    {
                        "username": "drblessing",
                        "content": "BING CHILLING \\uD83C\\uDF66"
                    },
                    {
                        "username": "kmp1084",
                        "content": "Only purpose of this question is to see how many people try to solve this using DP and get TLE."
                    },
                    {
                        "username": "mayank-01",
                        "content": "yes"
                    },
                    {
                        "username": "native_element",
                        "content": "i failed using dp. Then i realised Greedy problem."
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Afzal543](/Afzal543) Recursion \\u2620\\u2620"
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Sorry](/Sorry) Meanwhile I Don\\'t Have Good Knowledge Of DP so I Directly Solved It Using Sorting \\uD83D\\uDE0E"
                    },
                    {
                        "username": "raaj-s",
                        "content": "[@Jonatanlp](/Jonatanlp) Even I was like greedy or dp as this problem slightly reminded me of \\'minimum number of coins needed for a given total\\' problem (as the total is being divided), but then I realized that the bars themselves won\\'t be repeated and they don\\'t have any inherent value. Haha."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "if you sort the array first and do DP approach it will solve all test case"
                    },
                    {
                        "username": "a_pandagre",
                        "content": "yepp, initially thought of DP, but then thought of simply sorting it."
                    },
                    {
                        "username": "Afzal543",
                        "content": "Today while solving this question I saw I have a failed submission on Apr 2021 . Guess what I was using fucking recurrsion . Since then Improved a lot . "
                    },
                    {
                        "username": "Sorry",
                        "content": "32.3% tried DP, because the acceptance rate is 67.7%."
                    },
                    {
                        "username": "shubhankar00",
                        "content": "I spent more time contemplating what I\\'m missing than actually coding the solution. "
                    },
                    {
                        "username": "Maverick767",
                        "content": "I thought there was a trick I was missing when I saw that this was a medium, but nope it\\'s just the easiest medium on the entire website"
                    },
                    {
                        "username": "Sounita51028",
                        "content": "Same here bro XD\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Why are we here ? \\n\\nJust to suffer...."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@user1827o](/user1827o) \\uD83E\\uDEC2"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "We will all make it bro :)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Today no suffering \\uD83D\\uDE05"
                    },
                    {
                        "username": "Joseph86",
                        "content": "bro in the discussion section I always see SOME sort of depressed/meme comment  :s"
                    },
                    {
                        "username": "gullyboy007",
                        "content": "I would say they should have mentioned something about unique ice cream bars or something , otherwise he can simply buy the cheapest one as much as possible(greedy) instead of DP."
                    },
                    {
                        "username": "alexdft",
                        "content": "[@BRABURAJ](/BRABURAJ)  dynamic programming"
                    },
                    {
                        "username": "BRABURAJ",
                        "content": "what is dp?\\n"
                    },
                    {
                        "username": "ankishkhandelwalop",
                        "content": "Appreciate \\n\\neasiest  medium question ever\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did greedy : ) It passed , this should be easy I guess"
                    }
                ]
            },
            {
                "id": 1743650,
                "content": [
                    {
                        "username": "aaron2k12",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "Wanxuan_Li",
                        "content": "definitely"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Yes, I was confused expecting something tricky"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "wasn\\'t going to try this question being new on LeetCode, but this is my only question that was solved in first attempt, lol."
                    },
                    {
                        "username": "drblessing",
                        "content": "Agreed, I was confused at first why it was a Medium. "
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "yess it is very easy problem"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Yes correct this problem teach us to use right approach: \n- if we use DP it will be medium problem \n- If we use greedy its easy problem \n\nbut the point is this problem teach us to use right algorithm"
                    },
                    {
                        "username": "S_Basu",
                        "content": "True"
                    },
                    {
                        "username": "Cut",
                        "content": "My name is aaron too!"
                    },
                    {
                        "username": "Boolean_Autocrats",
                        "content": "this can be easy problem for those who know greedy but for those who don\\'t about it ,this problem is surely medium .  "
                    },
                    {
                        "username": "xeniawann",
                        "content": "Totally agree^^ many people might know how to solve it within 1 minute after reading the question."
                    },
                    {
                        "username": "Mohammed84Farouk",
                        "content": "that\\'s because its the second problem in the contest and they are usually easy, easy-medium..."
                    },
                    {
                        "username": "qiushile",
                        "content": "maybe in some languages, you need to write sort method"
                    },
                    {
                        "username": "djslim",
                        "content": "First time I agree \\uD83E\\uDD23"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I agree"
                    },
                    {
                        "username": "user9382Km",
                        "content": "`Maybe the real challenge, is realizing that there is no challenge.`"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The real challenge is to prove the solution mathematically."
                    },
                    {
                        "username": "bizco8",
                        "content": "haahaha I feel it bro"
                    },
                    {
                        "username": "drblessing",
                        "content": "hahah "
                    },
                    {
                        "username": "TakshPanchal",
                        "content": "shush... don\\'t give spoilers."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "In this case, the problem should be marked as hard."
                    },
                    {
                        "username": "omi23",
                        "content": "lol so true"
                    },
                    {
                        "username": "S_Basu",
                        "content": "\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "picksitquick",
                        "content": "this is what master Oogway would say, wise words SENSEI, lol"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "Yup, I was trying to figure out why the obvious greedy approach wouldn\\'t work and stared at it for five minutes wondering. I asked ChatGPT why a greedy approach wouldn\\'t work and it kinda broke it :)"
                    },
                    {
                        "username": "gilite",
                        "content": "Very wise."
                    },
                    {
                        "username": "valibraimi",
                        "content": "Easiest Medium ever seen "
                    },
                    {
                        "username": "pratikraj001",
                        "content": "Bro you are wrong don\\'t do it in O(nlog n) ; This is challenge . if only sort then it is  in easy section not in medium."
                    },
                    {
                        "username": "laasyalata16",
                        "content": "Indeed YES!"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@djslim](/djslim) Yes, return false"
                    },
                    {
                        "username": "djslim",
                        "content": "[@XJRr8TyB](/XJRr8TyB) is it even easier?"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "Try 2396 Strictly Palindromic Number"
                    },
                    {
                        "username": "kontsis",
                        "content": "Lets go!!!! Conquered this tough medium, now I\\'m ready for FAANG. See u losers at the top "
                    },
                    {
                        "username": "NITHESH_23",
                        "content": "lol....\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "\\uD83D\\uDE02\\uD83E\\uDD23"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Losers won\\'t be at the top. It would be lonely :/"
                    },
                    {
                        "username": "khoai345678",
                        "content": "u r funny\\n"
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Certified \\uD83C\\uDF66BING CHILLING \\uD83E\\uDD76 problem"
                    },
                    {
                        "username": "drblessing",
                        "content": "BING CHILLING \\uD83C\\uDF66"
                    },
                    {
                        "username": "kmp1084",
                        "content": "Only purpose of this question is to see how many people try to solve this using DP and get TLE."
                    },
                    {
                        "username": "mayank-01",
                        "content": "yes"
                    },
                    {
                        "username": "native_element",
                        "content": "i failed using dp. Then i realised Greedy problem."
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Afzal543](/Afzal543) Recursion \\u2620\\u2620"
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Sorry](/Sorry) Meanwhile I Don\\'t Have Good Knowledge Of DP so I Directly Solved It Using Sorting \\uD83D\\uDE0E"
                    },
                    {
                        "username": "raaj-s",
                        "content": "[@Jonatanlp](/Jonatanlp) Even I was like greedy or dp as this problem slightly reminded me of \\'minimum number of coins needed for a given total\\' problem (as the total is being divided), but then I realized that the bars themselves won\\'t be repeated and they don\\'t have any inherent value. Haha."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "if you sort the array first and do DP approach it will solve all test case"
                    },
                    {
                        "username": "a_pandagre",
                        "content": "yepp, initially thought of DP, but then thought of simply sorting it."
                    },
                    {
                        "username": "Afzal543",
                        "content": "Today while solving this question I saw I have a failed submission on Apr 2021 . Guess what I was using fucking recurrsion . Since then Improved a lot . "
                    },
                    {
                        "username": "Sorry",
                        "content": "32.3% tried DP, because the acceptance rate is 67.7%."
                    },
                    {
                        "username": "shubhankar00",
                        "content": "I spent more time contemplating what I\\'m missing than actually coding the solution. "
                    },
                    {
                        "username": "Maverick767",
                        "content": "I thought there was a trick I was missing when I saw that this was a medium, but nope it\\'s just the easiest medium on the entire website"
                    },
                    {
                        "username": "Sounita51028",
                        "content": "Same here bro XD\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Why are we here ? \\n\\nJust to suffer...."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@user1827o](/user1827o) \\uD83E\\uDEC2"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "We will all make it bro :)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Today no suffering \\uD83D\\uDE05"
                    },
                    {
                        "username": "Joseph86",
                        "content": "bro in the discussion section I always see SOME sort of depressed/meme comment  :s"
                    },
                    {
                        "username": "gullyboy007",
                        "content": "I would say they should have mentioned something about unique ice cream bars or something , otherwise he can simply buy the cheapest one as much as possible(greedy) instead of DP."
                    },
                    {
                        "username": "alexdft",
                        "content": "[@BRABURAJ](/BRABURAJ)  dynamic programming"
                    },
                    {
                        "username": "BRABURAJ",
                        "content": "what is dp?\\n"
                    },
                    {
                        "username": "ankishkhandelwalop",
                        "content": "Appreciate \\n\\neasiest  medium question ever\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did greedy : ) It passed , this should be easy I guess"
                    }
                ]
            },
            {
                "id": 1648107,
                "content": [
                    {
                        "username": "aaron2k12",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "Wanxuan_Li",
                        "content": "definitely"
                    },
                    {
                        "username": "victorSDK",
                        "content": "Yes, I was confused expecting something tricky"
                    },
                    {
                        "username": "Ritesh_0",
                        "content": "wasn\\'t going to try this question being new on LeetCode, but this is my only question that was solved in first attempt, lol."
                    },
                    {
                        "username": "drblessing",
                        "content": "Agreed, I was confused at first why it was a Medium. "
                    },
                    {
                        "username": "dawar_tanishq",
                        "content": "yess it is very easy problem"
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "Yes correct this problem teach us to use right approach: \n- if we use DP it will be medium problem \n- If we use greedy its easy problem \n\nbut the point is this problem teach us to use right algorithm"
                    },
                    {
                        "username": "S_Basu",
                        "content": "True"
                    },
                    {
                        "username": "Cut",
                        "content": "My name is aaron too!"
                    },
                    {
                        "username": "Boolean_Autocrats",
                        "content": "this can be easy problem for those who know greedy but for those who don\\'t about it ,this problem is surely medium .  "
                    },
                    {
                        "username": "xeniawann",
                        "content": "Totally agree^^ many people might know how to solve it within 1 minute after reading the question."
                    },
                    {
                        "username": "Mohammed84Farouk",
                        "content": "that\\'s because its the second problem in the contest and they are usually easy, easy-medium..."
                    },
                    {
                        "username": "qiushile",
                        "content": "maybe in some languages, you need to write sort method"
                    },
                    {
                        "username": "djslim",
                        "content": "First time I agree \\uD83E\\uDD23"
                    },
                    {
                        "username": "This_is_Allen_Lee",
                        "content": "I agree"
                    },
                    {
                        "username": "user9382Km",
                        "content": "`Maybe the real challenge, is realizing that there is no challenge.`"
                    },
                    {
                        "username": "yangwudi398",
                        "content": "The real challenge is to prove the solution mathematically."
                    },
                    {
                        "username": "bizco8",
                        "content": "haahaha I feel it bro"
                    },
                    {
                        "username": "drblessing",
                        "content": "hahah "
                    },
                    {
                        "username": "TakshPanchal",
                        "content": "shush... don\\'t give spoilers."
                    },
                    {
                        "username": "VictorKoch",
                        "content": "In this case, the problem should be marked as hard."
                    },
                    {
                        "username": "omi23",
                        "content": "lol so true"
                    },
                    {
                        "username": "S_Basu",
                        "content": "\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25\\uD83D\\uDD25"
                    },
                    {
                        "username": "picksitquick",
                        "content": "this is what master Oogway would say, wise words SENSEI, lol"
                    },
                    {
                        "username": "nathanbacon",
                        "content": "Yup, I was trying to figure out why the obvious greedy approach wouldn\\'t work and stared at it for five minutes wondering. I asked ChatGPT why a greedy approach wouldn\\'t work and it kinda broke it :)"
                    },
                    {
                        "username": "gilite",
                        "content": "Very wise."
                    },
                    {
                        "username": "valibraimi",
                        "content": "Easiest Medium ever seen "
                    },
                    {
                        "username": "pratikraj001",
                        "content": "Bro you are wrong don\\'t do it in O(nlog n) ; This is challenge . if only sort then it is  in easy section not in medium."
                    },
                    {
                        "username": "laasyalata16",
                        "content": "Indeed YES!"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "[@djslim](/djslim) Yes, return false"
                    },
                    {
                        "username": "djslim",
                        "content": "[@XJRr8TyB](/XJRr8TyB) is it even easier?"
                    },
                    {
                        "username": "XJRr8TyB",
                        "content": "Try 2396 Strictly Palindromic Number"
                    },
                    {
                        "username": "kontsis",
                        "content": "Lets go!!!! Conquered this tough medium, now I\\'m ready for FAANG. See u losers at the top "
                    },
                    {
                        "username": "NITHESH_23",
                        "content": "lol....\\uD83E\\uDD23\\uD83E\\uDD23\\uD83E\\uDD23"
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "\\uD83D\\uDE02\\uD83E\\uDD23"
                    },
                    {
                        "username": "suren_yeager",
                        "content": "\\uD83D\\uDE02\\uD83D\\uDE02"
                    },
                    {
                        "username": "maheshrajput",
                        "content": "\\uD83D\\uDE05"
                    },
                    {
                        "username": "heisenberg280",
                        "content": "Losers won\\'t be at the top. It would be lonely :/"
                    },
                    {
                        "username": "khoai345678",
                        "content": "u r funny\\n"
                    },
                    {
                        "username": "kevzpeter",
                        "content": "Certified \\uD83C\\uDF66BING CHILLING \\uD83E\\uDD76 problem"
                    },
                    {
                        "username": "drblessing",
                        "content": "BING CHILLING \\uD83C\\uDF66"
                    },
                    {
                        "username": "kmp1084",
                        "content": "Only purpose of this question is to see how many people try to solve this using DP and get TLE."
                    },
                    {
                        "username": "mayank-01",
                        "content": "yes"
                    },
                    {
                        "username": "native_element",
                        "content": "i failed using dp. Then i realised Greedy problem."
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Afzal543](/Afzal543) Recursion \\u2620\\u2620"
                    },
                    {
                        "username": "notphoenix",
                        "content": "[@Sorry](/Sorry) Meanwhile I Don\\'t Have Good Knowledge Of DP so I Directly Solved It Using Sorting \\uD83D\\uDE0E"
                    },
                    {
                        "username": "raaj-s",
                        "content": "[@Jonatanlp](/Jonatanlp) Even I was like greedy or dp as this problem slightly reminded me of \\'minimum number of coins needed for a given total\\' problem (as the total is being divided), but then I realized that the bars themselves won\\'t be repeated and they don\\'t have any inherent value. Haha."
                    },
                    {
                        "username": "Jonatanlp",
                        "content": "if you sort the array first and do DP approach it will solve all test case"
                    },
                    {
                        "username": "a_pandagre",
                        "content": "yepp, initially thought of DP, but then thought of simply sorting it."
                    },
                    {
                        "username": "Afzal543",
                        "content": "Today while solving this question I saw I have a failed submission on Apr 2021 . Guess what I was using fucking recurrsion . Since then Improved a lot . "
                    },
                    {
                        "username": "Sorry",
                        "content": "32.3% tried DP, because the acceptance rate is 67.7%."
                    },
                    {
                        "username": "shubhankar00",
                        "content": "I spent more time contemplating what I\\'m missing than actually coding the solution. "
                    },
                    {
                        "username": "Maverick767",
                        "content": "I thought there was a trick I was missing when I saw that this was a medium, but nope it\\'s just the easiest medium on the entire website"
                    },
                    {
                        "username": "Sounita51028",
                        "content": "Same here bro XD\\n"
                    },
                    {
                        "username": "Kratos50",
                        "content": "Why are we here ? \\n\\nJust to suffer...."
                    },
                    {
                        "username": "S_Basu",
                        "content": "[@user1827o](/user1827o) \\uD83E\\uDEC2"
                    },
                    {
                        "username": "real_nitin_negi",
                        "content": "We will all make it bro :)"
                    },
                    {
                        "username": "S_Basu",
                        "content": "Today no suffering \\uD83D\\uDE05"
                    },
                    {
                        "username": "Joseph86",
                        "content": "bro in the discussion section I always see SOME sort of depressed/meme comment  :s"
                    },
                    {
                        "username": "gullyboy007",
                        "content": "I would say they should have mentioned something about unique ice cream bars or something , otherwise he can simply buy the cheapest one as much as possible(greedy) instead of DP."
                    },
                    {
                        "username": "alexdft",
                        "content": "[@BRABURAJ](/BRABURAJ)  dynamic programming"
                    },
                    {
                        "username": "BRABURAJ",
                        "content": "what is dp?\\n"
                    },
                    {
                        "username": "ankishkhandelwalop",
                        "content": "Appreciate \\n\\neasiest  medium question ever\\n"
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "I did greedy : ) It passed , this should be easy I guess"
                    }
                ]
            },
            {
                "id": 1743756,
                "content": [
                    {
                        "username": "piyushsk1999",
                        "content": "Questions like these give me confidence until I look at the comment section"
                    },
                    {
                        "username": "pushpak7070",
                        "content": "Maturity is when you try to find optimum solution rather thank criticising how easy it is.\\nHappy coding \\uD83E\\uDDBE."
                    },
                    {
                        "username": "noob-pika",
                        "content": "Why is it that the person with the same code as mine has very low runtime. Whereas I on the other hand have very high runtime??"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "internet connectivity matters"
                    },
                    {
                        "username": "ayush6203",
                        "content": "There are lot of factors i.e\\n- Load on host servers\\n- The way you have used variables\\n- Number of times you use if else\\n- etc\\n\\nFor me, the main focus is time & space complexity. I usually ignore runtime if my algorithm is most optimal."
                    },
                    {
                        "username": "majar5c",
                        "content": "This feels like a well deserved medium problem IMO? Though it might belong to the easiest type in medium problems. One needs to be aware of the value range of the input and come up with the idea of using counting sort for optimization. Another key thing is to avoid integer overflow on using counting sort which still require some careful looking on the input size."
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "leetcode giving us easy problem in the start of the year , thats good i think to keep us motivated and positive. "
                    },
                    {
                        "username": "Hypro999",
                        "content": "How is this a medium? The trick here is that there is no trick lol."
                    },
                    {
                        "username": "yashsharma8433",
                        "content": "i cant even solve one problem only copy pasting since 5 days what can i do how to do"
                    },
                    {
                        "username": "yashsharma8433",
                        "content": "[@papitochi](/papitochi) if u feel comfortable then can i get your linkedin profile link?"
                    },
                    {
                        "username": "papitochi",
                        "content": "keep on trying more problems. i was in the same position as you not too long ago, now im smashing most problems, keep going champ!"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "Came here to read all the \"it is an easy problem\" comments."
                    },
                    {
                        "username": "punit07hbti",
                        "content": "Easy one. \\nSort and starting taking from 0th idx and keep counting and also keep comparing with coins, once coins finish return the count."
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "I thought 10 times before submitting that if i am missing something!! because of Medium label"
                    }
                ]
            },
            {
                "id": 1744988,
                "content": [
                    {
                        "username": "piyushsk1999",
                        "content": "Questions like these give me confidence until I look at the comment section"
                    },
                    {
                        "username": "pushpak7070",
                        "content": "Maturity is when you try to find optimum solution rather thank criticising how easy it is.\\nHappy coding \\uD83E\\uDDBE."
                    },
                    {
                        "username": "noob-pika",
                        "content": "Why is it that the person with the same code as mine has very low runtime. Whereas I on the other hand have very high runtime??"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "internet connectivity matters"
                    },
                    {
                        "username": "ayush6203",
                        "content": "There are lot of factors i.e\\n- Load on host servers\\n- The way you have used variables\\n- Number of times you use if else\\n- etc\\n\\nFor me, the main focus is time & space complexity. I usually ignore runtime if my algorithm is most optimal."
                    },
                    {
                        "username": "majar5c",
                        "content": "This feels like a well deserved medium problem IMO? Though it might belong to the easiest type in medium problems. One needs to be aware of the value range of the input and come up with the idea of using counting sort for optimization. Another key thing is to avoid integer overflow on using counting sort which still require some careful looking on the input size."
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "leetcode giving us easy problem in the start of the year , thats good i think to keep us motivated and positive. "
                    },
                    {
                        "username": "Hypro999",
                        "content": "How is this a medium? The trick here is that there is no trick lol."
                    },
                    {
                        "username": "yashsharma8433",
                        "content": "i cant even solve one problem only copy pasting since 5 days what can i do how to do"
                    },
                    {
                        "username": "yashsharma8433",
                        "content": "[@papitochi](/papitochi) if u feel comfortable then can i get your linkedin profile link?"
                    },
                    {
                        "username": "papitochi",
                        "content": "keep on trying more problems. i was in the same position as you not too long ago, now im smashing most problems, keep going champ!"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "Came here to read all the \"it is an easy problem\" comments."
                    },
                    {
                        "username": "punit07hbti",
                        "content": "Easy one. \\nSort and starting taking from 0th idx and keep counting and also keep comparing with coins, once coins finish return the count."
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "I thought 10 times before submitting that if i am missing something!! because of Medium label"
                    }
                ]
            },
            {
                "id": 1744219,
                "content": [
                    {
                        "username": "piyushsk1999",
                        "content": "Questions like these give me confidence until I look at the comment section"
                    },
                    {
                        "username": "pushpak7070",
                        "content": "Maturity is when you try to find optimum solution rather thank criticising how easy it is.\\nHappy coding \\uD83E\\uDDBE."
                    },
                    {
                        "username": "noob-pika",
                        "content": "Why is it that the person with the same code as mine has very low runtime. Whereas I on the other hand have very high runtime??"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "internet connectivity matters"
                    },
                    {
                        "username": "ayush6203",
                        "content": "There are lot of factors i.e\\n- Load on host servers\\n- The way you have used variables\\n- Number of times you use if else\\n- etc\\n\\nFor me, the main focus is time & space complexity. I usually ignore runtime if my algorithm is most optimal."
                    },
                    {
                        "username": "majar5c",
                        "content": "This feels like a well deserved medium problem IMO? Though it might belong to the easiest type in medium problems. One needs to be aware of the value range of the input and come up with the idea of using counting sort for optimization. Another key thing is to avoid integer overflow on using counting sort which still require some careful looking on the input size."
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "leetcode giving us easy problem in the start of the year , thats good i think to keep us motivated and positive. "
                    },
                    {
                        "username": "Hypro999",
                        "content": "How is this a medium? The trick here is that there is no trick lol."
                    },
                    {
                        "username": "yashsharma8433",
                        "content": "i cant even solve one problem only copy pasting since 5 days what can i do how to do"
                    },
                    {
                        "username": "yashsharma8433",
                        "content": "[@papitochi](/papitochi) if u feel comfortable then can i get your linkedin profile link?"
                    },
                    {
                        "username": "papitochi",
                        "content": "keep on trying more problems. i was in the same position as you not too long ago, now im smashing most problems, keep going champ!"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "Came here to read all the \"it is an easy problem\" comments."
                    },
                    {
                        "username": "punit07hbti",
                        "content": "Easy one. \\nSort and starting taking from 0th idx and keep counting and also keep comparing with coins, once coins finish return the count."
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "I thought 10 times before submitting that if i am missing something!! because of Medium label"
                    }
                ]
            },
            {
                "id": 1743794,
                "content": [
                    {
                        "username": "piyushsk1999",
                        "content": "Questions like these give me confidence until I look at the comment section"
                    },
                    {
                        "username": "pushpak7070",
                        "content": "Maturity is when you try to find optimum solution rather thank criticising how easy it is.\\nHappy coding \\uD83E\\uDDBE."
                    },
                    {
                        "username": "noob-pika",
                        "content": "Why is it that the person with the same code as mine has very low runtime. Whereas I on the other hand have very high runtime??"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "internet connectivity matters"
                    },
                    {
                        "username": "ayush6203",
                        "content": "There are lot of factors i.e\\n- Load on host servers\\n- The way you have used variables\\n- Number of times you use if else\\n- etc\\n\\nFor me, the main focus is time & space complexity. I usually ignore runtime if my algorithm is most optimal."
                    },
                    {
                        "username": "majar5c",
                        "content": "This feels like a well deserved medium problem IMO? Though it might belong to the easiest type in medium problems. One needs to be aware of the value range of the input and come up with the idea of using counting sort for optimization. Another key thing is to avoid integer overflow on using counting sort which still require some careful looking on the input size."
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "leetcode giving us easy problem in the start of the year , thats good i think to keep us motivated and positive. "
                    },
                    {
                        "username": "Hypro999",
                        "content": "How is this a medium? The trick here is that there is no trick lol."
                    },
                    {
                        "username": "yashsharma8433",
                        "content": "i cant even solve one problem only copy pasting since 5 days what can i do how to do"
                    },
                    {
                        "username": "yashsharma8433",
                        "content": "[@papitochi](/papitochi) if u feel comfortable then can i get your linkedin profile link?"
                    },
                    {
                        "username": "papitochi",
                        "content": "keep on trying more problems. i was in the same position as you not too long ago, now im smashing most problems, keep going champ!"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "Came here to read all the \"it is an easy problem\" comments."
                    },
                    {
                        "username": "punit07hbti",
                        "content": "Easy one. \\nSort and starting taking from 0th idx and keep counting and also keep comparing with coins, once coins finish return the count."
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "I thought 10 times before submitting that if i am missing something!! because of Medium label"
                    }
                ]
            },
            {
                "id": 1744068,
                "content": [
                    {
                        "username": "piyushsk1999",
                        "content": "Questions like these give me confidence until I look at the comment section"
                    },
                    {
                        "username": "pushpak7070",
                        "content": "Maturity is when you try to find optimum solution rather thank criticising how easy it is.\\nHappy coding \\uD83E\\uDDBE."
                    },
                    {
                        "username": "noob-pika",
                        "content": "Why is it that the person with the same code as mine has very low runtime. Whereas I on the other hand have very high runtime??"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "internet connectivity matters"
                    },
                    {
                        "username": "ayush6203",
                        "content": "There are lot of factors i.e\\n- Load on host servers\\n- The way you have used variables\\n- Number of times you use if else\\n- etc\\n\\nFor me, the main focus is time & space complexity. I usually ignore runtime if my algorithm is most optimal."
                    },
                    {
                        "username": "majar5c",
                        "content": "This feels like a well deserved medium problem IMO? Though it might belong to the easiest type in medium problems. One needs to be aware of the value range of the input and come up with the idea of using counting sort for optimization. Another key thing is to avoid integer overflow on using counting sort which still require some careful looking on the input size."
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "leetcode giving us easy problem in the start of the year , thats good i think to keep us motivated and positive. "
                    },
                    {
                        "username": "Hypro999",
                        "content": "How is this a medium? The trick here is that there is no trick lol."
                    },
                    {
                        "username": "yashsharma8433",
                        "content": "i cant even solve one problem only copy pasting since 5 days what can i do how to do"
                    },
                    {
                        "username": "yashsharma8433",
                        "content": "[@papitochi](/papitochi) if u feel comfortable then can i get your linkedin profile link?"
                    },
                    {
                        "username": "papitochi",
                        "content": "keep on trying more problems. i was in the same position as you not too long ago, now im smashing most problems, keep going champ!"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "Came here to read all the \"it is an easy problem\" comments."
                    },
                    {
                        "username": "punit07hbti",
                        "content": "Easy one. \\nSort and starting taking from 0th idx and keep counting and also keep comparing with coins, once coins finish return the count."
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "I thought 10 times before submitting that if i am missing something!! because of Medium label"
                    }
                ]
            },
            {
                "id": 1743767,
                "content": [
                    {
                        "username": "piyushsk1999",
                        "content": "Questions like these give me confidence until I look at the comment section"
                    },
                    {
                        "username": "pushpak7070",
                        "content": "Maturity is when you try to find optimum solution rather thank criticising how easy it is.\\nHappy coding \\uD83E\\uDDBE."
                    },
                    {
                        "username": "noob-pika",
                        "content": "Why is it that the person with the same code as mine has very low runtime. Whereas I on the other hand have very high runtime??"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "internet connectivity matters"
                    },
                    {
                        "username": "ayush6203",
                        "content": "There are lot of factors i.e\\n- Load on host servers\\n- The way you have used variables\\n- Number of times you use if else\\n- etc\\n\\nFor me, the main focus is time & space complexity. I usually ignore runtime if my algorithm is most optimal."
                    },
                    {
                        "username": "majar5c",
                        "content": "This feels like a well deserved medium problem IMO? Though it might belong to the easiest type in medium problems. One needs to be aware of the value range of the input and come up with the idea of using counting sort for optimization. Another key thing is to avoid integer overflow on using counting sort which still require some careful looking on the input size."
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "leetcode giving us easy problem in the start of the year , thats good i think to keep us motivated and positive. "
                    },
                    {
                        "username": "Hypro999",
                        "content": "How is this a medium? The trick here is that there is no trick lol."
                    },
                    {
                        "username": "yashsharma8433",
                        "content": "i cant even solve one problem only copy pasting since 5 days what can i do how to do"
                    },
                    {
                        "username": "yashsharma8433",
                        "content": "[@papitochi](/papitochi) if u feel comfortable then can i get your linkedin profile link?"
                    },
                    {
                        "username": "papitochi",
                        "content": "keep on trying more problems. i was in the same position as you not too long ago, now im smashing most problems, keep going champ!"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "Came here to read all the \"it is an easy problem\" comments."
                    },
                    {
                        "username": "punit07hbti",
                        "content": "Easy one. \\nSort and starting taking from 0th idx and keep counting and also keep comparing with coins, once coins finish return the count."
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "I thought 10 times before submitting that if i am missing something!! because of Medium label"
                    }
                ]
            },
            {
                "id": 1745210,
                "content": [
                    {
                        "username": "piyushsk1999",
                        "content": "Questions like these give me confidence until I look at the comment section"
                    },
                    {
                        "username": "pushpak7070",
                        "content": "Maturity is when you try to find optimum solution rather thank criticising how easy it is.\\nHappy coding \\uD83E\\uDDBE."
                    },
                    {
                        "username": "noob-pika",
                        "content": "Why is it that the person with the same code as mine has very low runtime. Whereas I on the other hand have very high runtime??"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "internet connectivity matters"
                    },
                    {
                        "username": "ayush6203",
                        "content": "There are lot of factors i.e\\n- Load on host servers\\n- The way you have used variables\\n- Number of times you use if else\\n- etc\\n\\nFor me, the main focus is time & space complexity. I usually ignore runtime if my algorithm is most optimal."
                    },
                    {
                        "username": "majar5c",
                        "content": "This feels like a well deserved medium problem IMO? Though it might belong to the easiest type in medium problems. One needs to be aware of the value range of the input and come up with the idea of using counting sort for optimization. Another key thing is to avoid integer overflow on using counting sort which still require some careful looking on the input size."
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "leetcode giving us easy problem in the start of the year , thats good i think to keep us motivated and positive. "
                    },
                    {
                        "username": "Hypro999",
                        "content": "How is this a medium? The trick here is that there is no trick lol."
                    },
                    {
                        "username": "yashsharma8433",
                        "content": "i cant even solve one problem only copy pasting since 5 days what can i do how to do"
                    },
                    {
                        "username": "yashsharma8433",
                        "content": "[@papitochi](/papitochi) if u feel comfortable then can i get your linkedin profile link?"
                    },
                    {
                        "username": "papitochi",
                        "content": "keep on trying more problems. i was in the same position as you not too long ago, now im smashing most problems, keep going champ!"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "Came here to read all the \"it is an easy problem\" comments."
                    },
                    {
                        "username": "punit07hbti",
                        "content": "Easy one. \\nSort and starting taking from 0th idx and keep counting and also keep comparing with coins, once coins finish return the count."
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "I thought 10 times before submitting that if i am missing something!! because of Medium label"
                    }
                ]
            },
            {
                "id": 1745055,
                "content": [
                    {
                        "username": "piyushsk1999",
                        "content": "Questions like these give me confidence until I look at the comment section"
                    },
                    {
                        "username": "pushpak7070",
                        "content": "Maturity is when you try to find optimum solution rather thank criticising how easy it is.\\nHappy coding \\uD83E\\uDDBE."
                    },
                    {
                        "username": "noob-pika",
                        "content": "Why is it that the person with the same code as mine has very low runtime. Whereas I on the other hand have very high runtime??"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "internet connectivity matters"
                    },
                    {
                        "username": "ayush6203",
                        "content": "There are lot of factors i.e\\n- Load on host servers\\n- The way you have used variables\\n- Number of times you use if else\\n- etc\\n\\nFor me, the main focus is time & space complexity. I usually ignore runtime if my algorithm is most optimal."
                    },
                    {
                        "username": "majar5c",
                        "content": "This feels like a well deserved medium problem IMO? Though it might belong to the easiest type in medium problems. One needs to be aware of the value range of the input and come up with the idea of using counting sort for optimization. Another key thing is to avoid integer overflow on using counting sort which still require some careful looking on the input size."
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "leetcode giving us easy problem in the start of the year , thats good i think to keep us motivated and positive. "
                    },
                    {
                        "username": "Hypro999",
                        "content": "How is this a medium? The trick here is that there is no trick lol."
                    },
                    {
                        "username": "yashsharma8433",
                        "content": "i cant even solve one problem only copy pasting since 5 days what can i do how to do"
                    },
                    {
                        "username": "yashsharma8433",
                        "content": "[@papitochi](/papitochi) if u feel comfortable then can i get your linkedin profile link?"
                    },
                    {
                        "username": "papitochi",
                        "content": "keep on trying more problems. i was in the same position as you not too long ago, now im smashing most problems, keep going champ!"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "Came here to read all the \"it is an easy problem\" comments."
                    },
                    {
                        "username": "punit07hbti",
                        "content": "Easy one. \\nSort and starting taking from 0th idx and keep counting and also keep comparing with coins, once coins finish return the count."
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "I thought 10 times before submitting that if i am missing something!! because of Medium label"
                    }
                ]
            },
            {
                "id": 1744886,
                "content": [
                    {
                        "username": "piyushsk1999",
                        "content": "Questions like these give me confidence until I look at the comment section"
                    },
                    {
                        "username": "pushpak7070",
                        "content": "Maturity is when you try to find optimum solution rather thank criticising how easy it is.\\nHappy coding \\uD83E\\uDDBE."
                    },
                    {
                        "username": "noob-pika",
                        "content": "Why is it that the person with the same code as mine has very low runtime. Whereas I on the other hand have very high runtime??"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "internet connectivity matters"
                    },
                    {
                        "username": "ayush6203",
                        "content": "There are lot of factors i.e\\n- Load on host servers\\n- The way you have used variables\\n- Number of times you use if else\\n- etc\\n\\nFor me, the main focus is time & space complexity. I usually ignore runtime if my algorithm is most optimal."
                    },
                    {
                        "username": "majar5c",
                        "content": "This feels like a well deserved medium problem IMO? Though it might belong to the easiest type in medium problems. One needs to be aware of the value range of the input and come up with the idea of using counting sort for optimization. Another key thing is to avoid integer overflow on using counting sort which still require some careful looking on the input size."
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "leetcode giving us easy problem in the start of the year , thats good i think to keep us motivated and positive. "
                    },
                    {
                        "username": "Hypro999",
                        "content": "How is this a medium? The trick here is that there is no trick lol."
                    },
                    {
                        "username": "yashsharma8433",
                        "content": "i cant even solve one problem only copy pasting since 5 days what can i do how to do"
                    },
                    {
                        "username": "yashsharma8433",
                        "content": "[@papitochi](/papitochi) if u feel comfortable then can i get your linkedin profile link?"
                    },
                    {
                        "username": "papitochi",
                        "content": "keep on trying more problems. i was in the same position as you not too long ago, now im smashing most problems, keep going champ!"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "Came here to read all the \"it is an easy problem\" comments."
                    },
                    {
                        "username": "punit07hbti",
                        "content": "Easy one. \\nSort and starting taking from 0th idx and keep counting and also keep comparing with coins, once coins finish return the count."
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "I thought 10 times before submitting that if i am missing something!! because of Medium label"
                    }
                ]
            },
            {
                "id": 1744815,
                "content": [
                    {
                        "username": "piyushsk1999",
                        "content": "Questions like these give me confidence until I look at the comment section"
                    },
                    {
                        "username": "pushpak7070",
                        "content": "Maturity is when you try to find optimum solution rather thank criticising how easy it is.\\nHappy coding \\uD83E\\uDDBE."
                    },
                    {
                        "username": "noob-pika",
                        "content": "Why is it that the person with the same code as mine has very low runtime. Whereas I on the other hand have very high runtime??"
                    },
                    {
                        "username": "Dhananjay40",
                        "content": "internet connectivity matters"
                    },
                    {
                        "username": "ayush6203",
                        "content": "There are lot of factors i.e\\n- Load on host servers\\n- The way you have used variables\\n- Number of times you use if else\\n- etc\\n\\nFor me, the main focus is time & space complexity. I usually ignore runtime if my algorithm is most optimal."
                    },
                    {
                        "username": "majar5c",
                        "content": "This feels like a well deserved medium problem IMO? Though it might belong to the easiest type in medium problems. One needs to be aware of the value range of the input and come up with the idea of using counting sort for optimization. Another key thing is to avoid integer overflow on using counting sort which still require some careful looking on the input size."
                    },
                    {
                        "username": "abhishekm2106",
                        "content": "leetcode giving us easy problem in the start of the year , thats good i think to keep us motivated and positive. "
                    },
                    {
                        "username": "Hypro999",
                        "content": "How is this a medium? The trick here is that there is no trick lol."
                    },
                    {
                        "username": "yashsharma8433",
                        "content": "i cant even solve one problem only copy pasting since 5 days what can i do how to do"
                    },
                    {
                        "username": "yashsharma8433",
                        "content": "[@papitochi](/papitochi) if u feel comfortable then can i get your linkedin profile link?"
                    },
                    {
                        "username": "papitochi",
                        "content": "keep on trying more problems. i was in the same position as you not too long ago, now im smashing most problems, keep going champ!"
                    },
                    {
                        "username": "anchalgarg0-0",
                        "content": "Came here to read all the \"it is an easy problem\" comments."
                    },
                    {
                        "username": "punit07hbti",
                        "content": "Easy one. \\nSort and starting taking from 0th idx and keep counting and also keep comparing with coins, once coins finish return the count."
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "I thought 10 times before submitting that if i am missing something!! because of Medium label"
                    }
                ]
            },
            {
                "id": 1744571,
                "content": [
                    {
                        "username": "akash_soni",
                        "content": "Problem `MEDIUM` hota nhi hai... hum `MEDIUM` banate hai... ;-) "
                    },
                    {
                        "username": "trpaslik",
                        "content": "Lol, there is even a hint with solution for this \"medium\" \\uD83D\\uDE02"
                    },
                    {
                        "username": "GD18",
                        "content": "And the problems that DO need hints, have none lol\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) on top of that, hint 2 is not just a hint but solution Itself... shortest solution post by leetcode in hint itself  \\uD83E\\uDD23"
                    },
                    {
                        "username": "palharshit239",
                        "content": "can we reduce time complexity less than nlogn\\n"
                    },
                    {
                        "username": "MaxNagy",
                        "content": "It becomes O(N) if you use a heap/priority queue, or O(N+k) if you do the counting sort method. \n\nI'm aware heapsort is O(N log N), but we do not actually need to sort the list, only construct a heap, which is O(N) (c.f. https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity)."
                    },
                    {
                        "username": "jayneversettle",
                        "content": "People saying it\\'s easy please solve it in O(n) and /or DP please."
                    },
                    {
                        "username": "Princesah999",
                        "content": "why do we have to sort the array first?"
                    },
                    {
                        "username": "Limon020",
                        "content": "Am I the only one who actually did this using counting sort?"
                    },
                    {
                        "username": "jianyang404",
                        "content": "High five"
                    },
                    {
                        "username": "jianyang404",
                        "content": "Am I the only one who doesn\\'t know counting sort? LOL still easy but had to look it up"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "It is clearly written ,solve using counting sort, people using inbuilt function hence finding it easy.\\nSolving using count sort will give T.C=O(n), constrains should be coins[i]<=1e6 to make sure hash table length is defined and O(nlogn) solutions must give TLE"
                    },
                    {
                        "username": "vasubansal27",
                        "content": "this needs to be a easy one"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Put a smile on your face, it\\'s a problem to make you laugh a little, why you are all so grumpy"
                    }
                ]
            },
            {
                "id": 1744559,
                "content": [
                    {
                        "username": "akash_soni",
                        "content": "Problem `MEDIUM` hota nhi hai... hum `MEDIUM` banate hai... ;-) "
                    },
                    {
                        "username": "trpaslik",
                        "content": "Lol, there is even a hint with solution for this \"medium\" \\uD83D\\uDE02"
                    },
                    {
                        "username": "GD18",
                        "content": "And the problems that DO need hints, have none lol\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) on top of that, hint 2 is not just a hint but solution Itself... shortest solution post by leetcode in hint itself  \\uD83E\\uDD23"
                    },
                    {
                        "username": "palharshit239",
                        "content": "can we reduce time complexity less than nlogn\\n"
                    },
                    {
                        "username": "MaxNagy",
                        "content": "It becomes O(N) if you use a heap/priority queue, or O(N+k) if you do the counting sort method. \n\nI'm aware heapsort is O(N log N), but we do not actually need to sort the list, only construct a heap, which is O(N) (c.f. https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity)."
                    },
                    {
                        "username": "jayneversettle",
                        "content": "People saying it\\'s easy please solve it in O(n) and /or DP please."
                    },
                    {
                        "username": "Princesah999",
                        "content": "why do we have to sort the array first?"
                    },
                    {
                        "username": "Limon020",
                        "content": "Am I the only one who actually did this using counting sort?"
                    },
                    {
                        "username": "jianyang404",
                        "content": "High five"
                    },
                    {
                        "username": "jianyang404",
                        "content": "Am I the only one who doesn\\'t know counting sort? LOL still easy but had to look it up"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "It is clearly written ,solve using counting sort, people using inbuilt function hence finding it easy.\\nSolving using count sort will give T.C=O(n), constrains should be coins[i]<=1e6 to make sure hash table length is defined and O(nlogn) solutions must give TLE"
                    },
                    {
                        "username": "vasubansal27",
                        "content": "this needs to be a easy one"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Put a smile on your face, it\\'s a problem to make you laugh a little, why you are all so grumpy"
                    }
                ]
            },
            {
                "id": 1744474,
                "content": [
                    {
                        "username": "akash_soni",
                        "content": "Problem `MEDIUM` hota nhi hai... hum `MEDIUM` banate hai... ;-) "
                    },
                    {
                        "username": "trpaslik",
                        "content": "Lol, there is even a hint with solution for this \"medium\" \\uD83D\\uDE02"
                    },
                    {
                        "username": "GD18",
                        "content": "And the problems that DO need hints, have none lol\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) on top of that, hint 2 is not just a hint but solution Itself... shortest solution post by leetcode in hint itself  \\uD83E\\uDD23"
                    },
                    {
                        "username": "palharshit239",
                        "content": "can we reduce time complexity less than nlogn\\n"
                    },
                    {
                        "username": "MaxNagy",
                        "content": "It becomes O(N) if you use a heap/priority queue, or O(N+k) if you do the counting sort method. \n\nI'm aware heapsort is O(N log N), but we do not actually need to sort the list, only construct a heap, which is O(N) (c.f. https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity)."
                    },
                    {
                        "username": "jayneversettle",
                        "content": "People saying it\\'s easy please solve it in O(n) and /or DP please."
                    },
                    {
                        "username": "Princesah999",
                        "content": "why do we have to sort the array first?"
                    },
                    {
                        "username": "Limon020",
                        "content": "Am I the only one who actually did this using counting sort?"
                    },
                    {
                        "username": "jianyang404",
                        "content": "High five"
                    },
                    {
                        "username": "jianyang404",
                        "content": "Am I the only one who doesn\\'t know counting sort? LOL still easy but had to look it up"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "It is clearly written ,solve using counting sort, people using inbuilt function hence finding it easy.\\nSolving using count sort will give T.C=O(n), constrains should be coins[i]<=1e6 to make sure hash table length is defined and O(nlogn) solutions must give TLE"
                    },
                    {
                        "username": "vasubansal27",
                        "content": "this needs to be a easy one"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Put a smile on your face, it\\'s a problem to make you laugh a little, why you are all so grumpy"
                    }
                ]
            },
            {
                "id": 1744420,
                "content": [
                    {
                        "username": "akash_soni",
                        "content": "Problem `MEDIUM` hota nhi hai... hum `MEDIUM` banate hai... ;-) "
                    },
                    {
                        "username": "trpaslik",
                        "content": "Lol, there is even a hint with solution for this \"medium\" \\uD83D\\uDE02"
                    },
                    {
                        "username": "GD18",
                        "content": "And the problems that DO need hints, have none lol\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) on top of that, hint 2 is not just a hint but solution Itself... shortest solution post by leetcode in hint itself  \\uD83E\\uDD23"
                    },
                    {
                        "username": "palharshit239",
                        "content": "can we reduce time complexity less than nlogn\\n"
                    },
                    {
                        "username": "MaxNagy",
                        "content": "It becomes O(N) if you use a heap/priority queue, or O(N+k) if you do the counting sort method. \n\nI'm aware heapsort is O(N log N), but we do not actually need to sort the list, only construct a heap, which is O(N) (c.f. https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity)."
                    },
                    {
                        "username": "jayneversettle",
                        "content": "People saying it\\'s easy please solve it in O(n) and /or DP please."
                    },
                    {
                        "username": "Princesah999",
                        "content": "why do we have to sort the array first?"
                    },
                    {
                        "username": "Limon020",
                        "content": "Am I the only one who actually did this using counting sort?"
                    },
                    {
                        "username": "jianyang404",
                        "content": "High five"
                    },
                    {
                        "username": "jianyang404",
                        "content": "Am I the only one who doesn\\'t know counting sort? LOL still easy but had to look it up"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "It is clearly written ,solve using counting sort, people using inbuilt function hence finding it easy.\\nSolving using count sort will give T.C=O(n), constrains should be coins[i]<=1e6 to make sure hash table length is defined and O(nlogn) solutions must give TLE"
                    },
                    {
                        "username": "vasubansal27",
                        "content": "this needs to be a easy one"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Put a smile on your face, it\\'s a problem to make you laugh a little, why you are all so grumpy"
                    }
                ]
            },
            {
                "id": 2062343,
                "content": [
                    {
                        "username": "akash_soni",
                        "content": "Problem `MEDIUM` hota nhi hai... hum `MEDIUM` banate hai... ;-) "
                    },
                    {
                        "username": "trpaslik",
                        "content": "Lol, there is even a hint with solution for this \"medium\" \\uD83D\\uDE02"
                    },
                    {
                        "username": "GD18",
                        "content": "And the problems that DO need hints, have none lol\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) on top of that, hint 2 is not just a hint but solution Itself... shortest solution post by leetcode in hint itself  \\uD83E\\uDD23"
                    },
                    {
                        "username": "palharshit239",
                        "content": "can we reduce time complexity less than nlogn\\n"
                    },
                    {
                        "username": "MaxNagy",
                        "content": "It becomes O(N) if you use a heap/priority queue, or O(N+k) if you do the counting sort method. \n\nI'm aware heapsort is O(N log N), but we do not actually need to sort the list, only construct a heap, which is O(N) (c.f. https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity)."
                    },
                    {
                        "username": "jayneversettle",
                        "content": "People saying it\\'s easy please solve it in O(n) and /or DP please."
                    },
                    {
                        "username": "Princesah999",
                        "content": "why do we have to sort the array first?"
                    },
                    {
                        "username": "Limon020",
                        "content": "Am I the only one who actually did this using counting sort?"
                    },
                    {
                        "username": "jianyang404",
                        "content": "High five"
                    },
                    {
                        "username": "jianyang404",
                        "content": "Am I the only one who doesn\\'t know counting sort? LOL still easy but had to look it up"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "It is clearly written ,solve using counting sort, people using inbuilt function hence finding it easy.\\nSolving using count sort will give T.C=O(n), constrains should be coins[i]<=1e6 to make sure hash table length is defined and O(nlogn) solutions must give TLE"
                    },
                    {
                        "username": "vasubansal27",
                        "content": "this needs to be a easy one"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Put a smile on your face, it\\'s a problem to make you laugh a little, why you are all so grumpy"
                    }
                ]
            },
            {
                "id": 2027399,
                "content": [
                    {
                        "username": "akash_soni",
                        "content": "Problem `MEDIUM` hota nhi hai... hum `MEDIUM` banate hai... ;-) "
                    },
                    {
                        "username": "trpaslik",
                        "content": "Lol, there is even a hint with solution for this \"medium\" \\uD83D\\uDE02"
                    },
                    {
                        "username": "GD18",
                        "content": "And the problems that DO need hints, have none lol\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) on top of that, hint 2 is not just a hint but solution Itself... shortest solution post by leetcode in hint itself  \\uD83E\\uDD23"
                    },
                    {
                        "username": "palharshit239",
                        "content": "can we reduce time complexity less than nlogn\\n"
                    },
                    {
                        "username": "MaxNagy",
                        "content": "It becomes O(N) if you use a heap/priority queue, or O(N+k) if you do the counting sort method. \n\nI'm aware heapsort is O(N log N), but we do not actually need to sort the list, only construct a heap, which is O(N) (c.f. https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity)."
                    },
                    {
                        "username": "jayneversettle",
                        "content": "People saying it\\'s easy please solve it in O(n) and /or DP please."
                    },
                    {
                        "username": "Princesah999",
                        "content": "why do we have to sort the array first?"
                    },
                    {
                        "username": "Limon020",
                        "content": "Am I the only one who actually did this using counting sort?"
                    },
                    {
                        "username": "jianyang404",
                        "content": "High five"
                    },
                    {
                        "username": "jianyang404",
                        "content": "Am I the only one who doesn\\'t know counting sort? LOL still easy but had to look it up"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "It is clearly written ,solve using counting sort, people using inbuilt function hence finding it easy.\\nSolving using count sort will give T.C=O(n), constrains should be coins[i]<=1e6 to make sure hash table length is defined and O(nlogn) solutions must give TLE"
                    },
                    {
                        "username": "vasubansal27",
                        "content": "this needs to be a easy one"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Put a smile on your face, it\\'s a problem to make you laugh a little, why you are all so grumpy"
                    }
                ]
            },
            {
                "id": 1999262,
                "content": [
                    {
                        "username": "akash_soni",
                        "content": "Problem `MEDIUM` hota nhi hai... hum `MEDIUM` banate hai... ;-) "
                    },
                    {
                        "username": "trpaslik",
                        "content": "Lol, there is even a hint with solution for this \"medium\" \\uD83D\\uDE02"
                    },
                    {
                        "username": "GD18",
                        "content": "And the problems that DO need hints, have none lol\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) on top of that, hint 2 is not just a hint but solution Itself... shortest solution post by leetcode in hint itself  \\uD83E\\uDD23"
                    },
                    {
                        "username": "palharshit239",
                        "content": "can we reduce time complexity less than nlogn\\n"
                    },
                    {
                        "username": "MaxNagy",
                        "content": "It becomes O(N) if you use a heap/priority queue, or O(N+k) if you do the counting sort method. \n\nI'm aware heapsort is O(N log N), but we do not actually need to sort the list, only construct a heap, which is O(N) (c.f. https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity)."
                    },
                    {
                        "username": "jayneversettle",
                        "content": "People saying it\\'s easy please solve it in O(n) and /or DP please."
                    },
                    {
                        "username": "Princesah999",
                        "content": "why do we have to sort the array first?"
                    },
                    {
                        "username": "Limon020",
                        "content": "Am I the only one who actually did this using counting sort?"
                    },
                    {
                        "username": "jianyang404",
                        "content": "High five"
                    },
                    {
                        "username": "jianyang404",
                        "content": "Am I the only one who doesn\\'t know counting sort? LOL still easy but had to look it up"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "It is clearly written ,solve using counting sort, people using inbuilt function hence finding it easy.\\nSolving using count sort will give T.C=O(n), constrains should be coins[i]<=1e6 to make sure hash table length is defined and O(nlogn) solutions must give TLE"
                    },
                    {
                        "username": "vasubansal27",
                        "content": "this needs to be a easy one"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Put a smile on your face, it\\'s a problem to make you laugh a little, why you are all so grumpy"
                    }
                ]
            },
            {
                "id": 1963331,
                "content": [
                    {
                        "username": "akash_soni",
                        "content": "Problem `MEDIUM` hota nhi hai... hum `MEDIUM` banate hai... ;-) "
                    },
                    {
                        "username": "trpaslik",
                        "content": "Lol, there is even a hint with solution for this \"medium\" \\uD83D\\uDE02"
                    },
                    {
                        "username": "GD18",
                        "content": "And the problems that DO need hints, have none lol\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) on top of that, hint 2 is not just a hint but solution Itself... shortest solution post by leetcode in hint itself  \\uD83E\\uDD23"
                    },
                    {
                        "username": "palharshit239",
                        "content": "can we reduce time complexity less than nlogn\\n"
                    },
                    {
                        "username": "MaxNagy",
                        "content": "It becomes O(N) if you use a heap/priority queue, or O(N+k) if you do the counting sort method. \n\nI'm aware heapsort is O(N log N), but we do not actually need to sort the list, only construct a heap, which is O(N) (c.f. https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity)."
                    },
                    {
                        "username": "jayneversettle",
                        "content": "People saying it\\'s easy please solve it in O(n) and /or DP please."
                    },
                    {
                        "username": "Princesah999",
                        "content": "why do we have to sort the array first?"
                    },
                    {
                        "username": "Limon020",
                        "content": "Am I the only one who actually did this using counting sort?"
                    },
                    {
                        "username": "jianyang404",
                        "content": "High five"
                    },
                    {
                        "username": "jianyang404",
                        "content": "Am I the only one who doesn\\'t know counting sort? LOL still easy but had to look it up"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "It is clearly written ,solve using counting sort, people using inbuilt function hence finding it easy.\\nSolving using count sort will give T.C=O(n), constrains should be coins[i]<=1e6 to make sure hash table length is defined and O(nlogn) solutions must give TLE"
                    },
                    {
                        "username": "vasubansal27",
                        "content": "this needs to be a easy one"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Put a smile on your face, it\\'s a problem to make you laugh a little, why you are all so grumpy"
                    }
                ]
            },
            {
                "id": 1876095,
                "content": [
                    {
                        "username": "akash_soni",
                        "content": "Problem `MEDIUM` hota nhi hai... hum `MEDIUM` banate hai... ;-) "
                    },
                    {
                        "username": "trpaslik",
                        "content": "Lol, there is even a hint with solution for this \"medium\" \\uD83D\\uDE02"
                    },
                    {
                        "username": "GD18",
                        "content": "And the problems that DO need hints, have none lol\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) on top of that, hint 2 is not just a hint but solution Itself... shortest solution post by leetcode in hint itself  \\uD83E\\uDD23"
                    },
                    {
                        "username": "palharshit239",
                        "content": "can we reduce time complexity less than nlogn\\n"
                    },
                    {
                        "username": "MaxNagy",
                        "content": "It becomes O(N) if you use a heap/priority queue, or O(N+k) if you do the counting sort method. \n\nI'm aware heapsort is O(N log N), but we do not actually need to sort the list, only construct a heap, which is O(N) (c.f. https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity)."
                    },
                    {
                        "username": "jayneversettle",
                        "content": "People saying it\\'s easy please solve it in O(n) and /or DP please."
                    },
                    {
                        "username": "Princesah999",
                        "content": "why do we have to sort the array first?"
                    },
                    {
                        "username": "Limon020",
                        "content": "Am I the only one who actually did this using counting sort?"
                    },
                    {
                        "username": "jianyang404",
                        "content": "High five"
                    },
                    {
                        "username": "jianyang404",
                        "content": "Am I the only one who doesn\\'t know counting sort? LOL still easy but had to look it up"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "It is clearly written ,solve using counting sort, people using inbuilt function hence finding it easy.\\nSolving using count sort will give T.C=O(n), constrains should be coins[i]<=1e6 to make sure hash table length is defined and O(nlogn) solutions must give TLE"
                    },
                    {
                        "username": "vasubansal27",
                        "content": "this needs to be a easy one"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Put a smile on your face, it\\'s a problem to make you laugh a little, why you are all so grumpy"
                    }
                ]
            },
            {
                "id": 1869281,
                "content": [
                    {
                        "username": "akash_soni",
                        "content": "Problem `MEDIUM` hota nhi hai... hum `MEDIUM` banate hai... ;-) "
                    },
                    {
                        "username": "trpaslik",
                        "content": "Lol, there is even a hint with solution for this \"medium\" \\uD83D\\uDE02"
                    },
                    {
                        "username": "GD18",
                        "content": "And the problems that DO need hints, have none lol\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Michal](/trpaslik) on top of that, hint 2 is not just a hint but solution Itself... shortest solution post by leetcode in hint itself  \\uD83E\\uDD23"
                    },
                    {
                        "username": "palharshit239",
                        "content": "can we reduce time complexity less than nlogn\\n"
                    },
                    {
                        "username": "MaxNagy",
                        "content": "It becomes O(N) if you use a heap/priority queue, or O(N+k) if you do the counting sort method. \n\nI'm aware heapsort is O(N log N), but we do not actually need to sort the list, only construct a heap, which is O(N) (c.f. https://stackoverflow.com/questions/9755721/how-can-building-a-heap-be-on-time-complexity)."
                    },
                    {
                        "username": "jayneversettle",
                        "content": "People saying it\\'s easy please solve it in O(n) and /or DP please."
                    },
                    {
                        "username": "Princesah999",
                        "content": "why do we have to sort the array first?"
                    },
                    {
                        "username": "Limon020",
                        "content": "Am I the only one who actually did this using counting sort?"
                    },
                    {
                        "username": "jianyang404",
                        "content": "High five"
                    },
                    {
                        "username": "jianyang404",
                        "content": "Am I the only one who doesn\\'t know counting sort? LOL still easy but had to look it up"
                    },
                    {
                        "username": "pspriyanshu601",
                        "content": "It is clearly written ,solve using counting sort, people using inbuilt function hence finding it easy.\\nSolving using count sort will give T.C=O(n), constrains should be coins[i]<=1e6 to make sure hash table length is defined and O(nlogn) solutions must give TLE"
                    },
                    {
                        "username": "vasubansal27",
                        "content": "this needs to be a easy one"
                    },
                    {
                        "username": "M1dn1ght",
                        "content": "Put a smile on your face, it\\'s a problem to make you laugh a little, why you are all so grumpy"
                    }
                ]
            },
            {
                "id": 1809195,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "If this is medium problem, Now I am ready for Google interview."
                    },
                    {
                        "username": "JuanQP",
                        "content": "> Hint 2/2:\\n> Sort the prices so that the cheapest ice cream bar comes first.\\n\\n\\uD83D\\uDE10\\uD83D\\uDC4C\\n"
                    },
                    {
                        "username": "gandi_nali_ka_keeda",
                        "content": "```\\nint c = 0,s=0;\\n        for (int cost : costs) {\\n            s += cost;\\n            if (s <= coins) c++;\\n        }\\n```\\nisn\\'t adding individual costs and checking if it less than the total coins same as deducting the cost from total coins? This is giving me wrong output  \\n"
                    },
                    {
                        "username": "ninadapte9",
                        "content": "konsa ganja phuuk ke esko medium level tag diya he bhai?"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Seems they\\'re giving us a New years gift by giving us a very easy week"
                    },
                    {
                        "username": "awb24",
                        "content": "Am I crazy or is this super easy?"
                    },
                    {
                        "username": "geeden",
                        "content": "This is easier than easy problems."
                    },
                    {
                        "username": "bilii",
                        "content": "I hope this is medium for the companies\\' interview"
                    },
                    {
                        "username": "sartaj_codes",
                        "content": "Who all were hesitant before clicking Submit button, seeing this \"Medium\" tagged level question."
                    },
                    {
                        "username": "ashutosh75",
                        "content": "if the sum of all the elements of the array is less than the coins than shouldn\\'t we return the length of array, but this fails on the one test case. why??\\nthis is my program, but it fails on the test case\\n \\n`class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int cost=0;\\n        int n=costs.length;\\n        \\n        for(int i=0;i<n;i++)\\n            cost+=costs[i];\\n\\n        if(cost<=coins)\\n        return n;\\n\\n        Arrays.sort(costs);\\n        if(costs[0]>coins)\\n        return 0;\\n\\n        int num=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(coins>=costs[i])\\n            {\\n                coins-=costs[i];\\n                num++;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n\\nTest case\\n[84195,37244,88639,38757,74362,60418,36934,27895,58532,65586,3292,78881,11155,50282,62760,66638,36227,17129,65612,61706,46056,2967,91032,81729,63368,47323,63798,19382,20208,25594,51206,42094,23165,59606,31648,85622,96402,23663,61983,11185,81143,97152,87273,7708,5376,80578,99057,18274,18338,74031,27744,92746,77831,62210,70446,70345,54338,50358,2712,19112,57950,92110,99706,88823,43578,22910,34823,35506,82962,16820,68315,11999,94554,23989,33608,87675,90444,47599,37225,84891,62189,61890,55737,38409,16222,97707,28636,51044,13969,65127,9914,32581,70867,87271,7363,89384,12668,48113,77365,26177,75073,9012,73963,30035,91549,8697,32882,83047,19849,95287,62290,30604,47065,12730,54852,80511,35312,43872,195,66508,64860,65250,46767,80563,77484,72587,55503,86845,51636,39940,30891,17700,2533,70226,57952,62791,67804,44569,96333,96973,62923,5579,86418,42843,89896,91970,74721,82399,6809,95006,97485,56323,38199,10167,54936,73182,19763,70375,12189,53960,62370,33354,1311,83264,58628,67135,52947,53432,41234,...\\n\\nCoins=26578414\\nOutput\\n47286\\nExpected\\n5073\\n\\n"
                    }
                ]
            },
            {
                "id": 1758227,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "If this is medium problem, Now I am ready for Google interview."
                    },
                    {
                        "username": "JuanQP",
                        "content": "> Hint 2/2:\\n> Sort the prices so that the cheapest ice cream bar comes first.\\n\\n\\uD83D\\uDE10\\uD83D\\uDC4C\\n"
                    },
                    {
                        "username": "gandi_nali_ka_keeda",
                        "content": "```\\nint c = 0,s=0;\\n        for (int cost : costs) {\\n            s += cost;\\n            if (s <= coins) c++;\\n        }\\n```\\nisn\\'t adding individual costs and checking if it less than the total coins same as deducting the cost from total coins? This is giving me wrong output  \\n"
                    },
                    {
                        "username": "ninadapte9",
                        "content": "konsa ganja phuuk ke esko medium level tag diya he bhai?"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Seems they\\'re giving us a New years gift by giving us a very easy week"
                    },
                    {
                        "username": "awb24",
                        "content": "Am I crazy or is this super easy?"
                    },
                    {
                        "username": "geeden",
                        "content": "This is easier than easy problems."
                    },
                    {
                        "username": "bilii",
                        "content": "I hope this is medium for the companies\\' interview"
                    },
                    {
                        "username": "sartaj_codes",
                        "content": "Who all were hesitant before clicking Submit button, seeing this \"Medium\" tagged level question."
                    },
                    {
                        "username": "ashutosh75",
                        "content": "if the sum of all the elements of the array is less than the coins than shouldn\\'t we return the length of array, but this fails on the one test case. why??\\nthis is my program, but it fails on the test case\\n \\n`class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int cost=0;\\n        int n=costs.length;\\n        \\n        for(int i=0;i<n;i++)\\n            cost+=costs[i];\\n\\n        if(cost<=coins)\\n        return n;\\n\\n        Arrays.sort(costs);\\n        if(costs[0]>coins)\\n        return 0;\\n\\n        int num=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(coins>=costs[i])\\n            {\\n                coins-=costs[i];\\n                num++;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n\\nTest case\\n[84195,37244,88639,38757,74362,60418,36934,27895,58532,65586,3292,78881,11155,50282,62760,66638,36227,17129,65612,61706,46056,2967,91032,81729,63368,47323,63798,19382,20208,25594,51206,42094,23165,59606,31648,85622,96402,23663,61983,11185,81143,97152,87273,7708,5376,80578,99057,18274,18338,74031,27744,92746,77831,62210,70446,70345,54338,50358,2712,19112,57950,92110,99706,88823,43578,22910,34823,35506,82962,16820,68315,11999,94554,23989,33608,87675,90444,47599,37225,84891,62189,61890,55737,38409,16222,97707,28636,51044,13969,65127,9914,32581,70867,87271,7363,89384,12668,48113,77365,26177,75073,9012,73963,30035,91549,8697,32882,83047,19849,95287,62290,30604,47065,12730,54852,80511,35312,43872,195,66508,64860,65250,46767,80563,77484,72587,55503,86845,51636,39940,30891,17700,2533,70226,57952,62791,67804,44569,96333,96973,62923,5579,86418,42843,89896,91970,74721,82399,6809,95006,97485,56323,38199,10167,54936,73182,19763,70375,12189,53960,62370,33354,1311,83264,58628,67135,52947,53432,41234,...\\n\\nCoins=26578414\\nOutput\\n47286\\nExpected\\n5073\\n\\n"
                    }
                ]
            },
            {
                "id": 1747479,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "If this is medium problem, Now I am ready for Google interview."
                    },
                    {
                        "username": "JuanQP",
                        "content": "> Hint 2/2:\\n> Sort the prices so that the cheapest ice cream bar comes first.\\n\\n\\uD83D\\uDE10\\uD83D\\uDC4C\\n"
                    },
                    {
                        "username": "gandi_nali_ka_keeda",
                        "content": "```\\nint c = 0,s=0;\\n        for (int cost : costs) {\\n            s += cost;\\n            if (s <= coins) c++;\\n        }\\n```\\nisn\\'t adding individual costs and checking if it less than the total coins same as deducting the cost from total coins? This is giving me wrong output  \\n"
                    },
                    {
                        "username": "ninadapte9",
                        "content": "konsa ganja phuuk ke esko medium level tag diya he bhai?"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Seems they\\'re giving us a New years gift by giving us a very easy week"
                    },
                    {
                        "username": "awb24",
                        "content": "Am I crazy or is this super easy?"
                    },
                    {
                        "username": "geeden",
                        "content": "This is easier than easy problems."
                    },
                    {
                        "username": "bilii",
                        "content": "I hope this is medium for the companies\\' interview"
                    },
                    {
                        "username": "sartaj_codes",
                        "content": "Who all were hesitant before clicking Submit button, seeing this \"Medium\" tagged level question."
                    },
                    {
                        "username": "ashutosh75",
                        "content": "if the sum of all the elements of the array is less than the coins than shouldn\\'t we return the length of array, but this fails on the one test case. why??\\nthis is my program, but it fails on the test case\\n \\n`class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int cost=0;\\n        int n=costs.length;\\n        \\n        for(int i=0;i<n;i++)\\n            cost+=costs[i];\\n\\n        if(cost<=coins)\\n        return n;\\n\\n        Arrays.sort(costs);\\n        if(costs[0]>coins)\\n        return 0;\\n\\n        int num=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(coins>=costs[i])\\n            {\\n                coins-=costs[i];\\n                num++;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n\\nTest case\\n[84195,37244,88639,38757,74362,60418,36934,27895,58532,65586,3292,78881,11155,50282,62760,66638,36227,17129,65612,61706,46056,2967,91032,81729,63368,47323,63798,19382,20208,25594,51206,42094,23165,59606,31648,85622,96402,23663,61983,11185,81143,97152,87273,7708,5376,80578,99057,18274,18338,74031,27744,92746,77831,62210,70446,70345,54338,50358,2712,19112,57950,92110,99706,88823,43578,22910,34823,35506,82962,16820,68315,11999,94554,23989,33608,87675,90444,47599,37225,84891,62189,61890,55737,38409,16222,97707,28636,51044,13969,65127,9914,32581,70867,87271,7363,89384,12668,48113,77365,26177,75073,9012,73963,30035,91549,8697,32882,83047,19849,95287,62290,30604,47065,12730,54852,80511,35312,43872,195,66508,64860,65250,46767,80563,77484,72587,55503,86845,51636,39940,30891,17700,2533,70226,57952,62791,67804,44569,96333,96973,62923,5579,86418,42843,89896,91970,74721,82399,6809,95006,97485,56323,38199,10167,54936,73182,19763,70375,12189,53960,62370,33354,1311,83264,58628,67135,52947,53432,41234,...\\n\\nCoins=26578414\\nOutput\\n47286\\nExpected\\n5073\\n\\n"
                    }
                ]
            },
            {
                "id": 1746058,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "If this is medium problem, Now I am ready for Google interview."
                    },
                    {
                        "username": "JuanQP",
                        "content": "> Hint 2/2:\\n> Sort the prices so that the cheapest ice cream bar comes first.\\n\\n\\uD83D\\uDE10\\uD83D\\uDC4C\\n"
                    },
                    {
                        "username": "gandi_nali_ka_keeda",
                        "content": "```\\nint c = 0,s=0;\\n        for (int cost : costs) {\\n            s += cost;\\n            if (s <= coins) c++;\\n        }\\n```\\nisn\\'t adding individual costs and checking if it less than the total coins same as deducting the cost from total coins? This is giving me wrong output  \\n"
                    },
                    {
                        "username": "ninadapte9",
                        "content": "konsa ganja phuuk ke esko medium level tag diya he bhai?"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Seems they\\'re giving us a New years gift by giving us a very easy week"
                    },
                    {
                        "username": "awb24",
                        "content": "Am I crazy or is this super easy?"
                    },
                    {
                        "username": "geeden",
                        "content": "This is easier than easy problems."
                    },
                    {
                        "username": "bilii",
                        "content": "I hope this is medium for the companies\\' interview"
                    },
                    {
                        "username": "sartaj_codes",
                        "content": "Who all were hesitant before clicking Submit button, seeing this \"Medium\" tagged level question."
                    },
                    {
                        "username": "ashutosh75",
                        "content": "if the sum of all the elements of the array is less than the coins than shouldn\\'t we return the length of array, but this fails on the one test case. why??\\nthis is my program, but it fails on the test case\\n \\n`class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int cost=0;\\n        int n=costs.length;\\n        \\n        for(int i=0;i<n;i++)\\n            cost+=costs[i];\\n\\n        if(cost<=coins)\\n        return n;\\n\\n        Arrays.sort(costs);\\n        if(costs[0]>coins)\\n        return 0;\\n\\n        int num=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(coins>=costs[i])\\n            {\\n                coins-=costs[i];\\n                num++;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n\\nTest case\\n[84195,37244,88639,38757,74362,60418,36934,27895,58532,65586,3292,78881,11155,50282,62760,66638,36227,17129,65612,61706,46056,2967,91032,81729,63368,47323,63798,19382,20208,25594,51206,42094,23165,59606,31648,85622,96402,23663,61983,11185,81143,97152,87273,7708,5376,80578,99057,18274,18338,74031,27744,92746,77831,62210,70446,70345,54338,50358,2712,19112,57950,92110,99706,88823,43578,22910,34823,35506,82962,16820,68315,11999,94554,23989,33608,87675,90444,47599,37225,84891,62189,61890,55737,38409,16222,97707,28636,51044,13969,65127,9914,32581,70867,87271,7363,89384,12668,48113,77365,26177,75073,9012,73963,30035,91549,8697,32882,83047,19849,95287,62290,30604,47065,12730,54852,80511,35312,43872,195,66508,64860,65250,46767,80563,77484,72587,55503,86845,51636,39940,30891,17700,2533,70226,57952,62791,67804,44569,96333,96973,62923,5579,86418,42843,89896,91970,74721,82399,6809,95006,97485,56323,38199,10167,54936,73182,19763,70375,12189,53960,62370,33354,1311,83264,58628,67135,52947,53432,41234,...\\n\\nCoins=26578414\\nOutput\\n47286\\nExpected\\n5073\\n\\n"
                    }
                ]
            },
            {
                "id": 1745460,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "If this is medium problem, Now I am ready for Google interview."
                    },
                    {
                        "username": "JuanQP",
                        "content": "> Hint 2/2:\\n> Sort the prices so that the cheapest ice cream bar comes first.\\n\\n\\uD83D\\uDE10\\uD83D\\uDC4C\\n"
                    },
                    {
                        "username": "gandi_nali_ka_keeda",
                        "content": "```\\nint c = 0,s=0;\\n        for (int cost : costs) {\\n            s += cost;\\n            if (s <= coins) c++;\\n        }\\n```\\nisn\\'t adding individual costs and checking if it less than the total coins same as deducting the cost from total coins? This is giving me wrong output  \\n"
                    },
                    {
                        "username": "ninadapte9",
                        "content": "konsa ganja phuuk ke esko medium level tag diya he bhai?"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Seems they\\'re giving us a New years gift by giving us a very easy week"
                    },
                    {
                        "username": "awb24",
                        "content": "Am I crazy or is this super easy?"
                    },
                    {
                        "username": "geeden",
                        "content": "This is easier than easy problems."
                    },
                    {
                        "username": "bilii",
                        "content": "I hope this is medium for the companies\\' interview"
                    },
                    {
                        "username": "sartaj_codes",
                        "content": "Who all were hesitant before clicking Submit button, seeing this \"Medium\" tagged level question."
                    },
                    {
                        "username": "ashutosh75",
                        "content": "if the sum of all the elements of the array is less than the coins than shouldn\\'t we return the length of array, but this fails on the one test case. why??\\nthis is my program, but it fails on the test case\\n \\n`class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int cost=0;\\n        int n=costs.length;\\n        \\n        for(int i=0;i<n;i++)\\n            cost+=costs[i];\\n\\n        if(cost<=coins)\\n        return n;\\n\\n        Arrays.sort(costs);\\n        if(costs[0]>coins)\\n        return 0;\\n\\n        int num=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(coins>=costs[i])\\n            {\\n                coins-=costs[i];\\n                num++;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n\\nTest case\\n[84195,37244,88639,38757,74362,60418,36934,27895,58532,65586,3292,78881,11155,50282,62760,66638,36227,17129,65612,61706,46056,2967,91032,81729,63368,47323,63798,19382,20208,25594,51206,42094,23165,59606,31648,85622,96402,23663,61983,11185,81143,97152,87273,7708,5376,80578,99057,18274,18338,74031,27744,92746,77831,62210,70446,70345,54338,50358,2712,19112,57950,92110,99706,88823,43578,22910,34823,35506,82962,16820,68315,11999,94554,23989,33608,87675,90444,47599,37225,84891,62189,61890,55737,38409,16222,97707,28636,51044,13969,65127,9914,32581,70867,87271,7363,89384,12668,48113,77365,26177,75073,9012,73963,30035,91549,8697,32882,83047,19849,95287,62290,30604,47065,12730,54852,80511,35312,43872,195,66508,64860,65250,46767,80563,77484,72587,55503,86845,51636,39940,30891,17700,2533,70226,57952,62791,67804,44569,96333,96973,62923,5579,86418,42843,89896,91970,74721,82399,6809,95006,97485,56323,38199,10167,54936,73182,19763,70375,12189,53960,62370,33354,1311,83264,58628,67135,52947,53432,41234,...\\n\\nCoins=26578414\\nOutput\\n47286\\nExpected\\n5073\\n\\n"
                    }
                ]
            },
            {
                "id": 1745384,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "If this is medium problem, Now I am ready for Google interview."
                    },
                    {
                        "username": "JuanQP",
                        "content": "> Hint 2/2:\\n> Sort the prices so that the cheapest ice cream bar comes first.\\n\\n\\uD83D\\uDE10\\uD83D\\uDC4C\\n"
                    },
                    {
                        "username": "gandi_nali_ka_keeda",
                        "content": "```\\nint c = 0,s=0;\\n        for (int cost : costs) {\\n            s += cost;\\n            if (s <= coins) c++;\\n        }\\n```\\nisn\\'t adding individual costs and checking if it less than the total coins same as deducting the cost from total coins? This is giving me wrong output  \\n"
                    },
                    {
                        "username": "ninadapte9",
                        "content": "konsa ganja phuuk ke esko medium level tag diya he bhai?"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Seems they\\'re giving us a New years gift by giving us a very easy week"
                    },
                    {
                        "username": "awb24",
                        "content": "Am I crazy or is this super easy?"
                    },
                    {
                        "username": "geeden",
                        "content": "This is easier than easy problems."
                    },
                    {
                        "username": "bilii",
                        "content": "I hope this is medium for the companies\\' interview"
                    },
                    {
                        "username": "sartaj_codes",
                        "content": "Who all were hesitant before clicking Submit button, seeing this \"Medium\" tagged level question."
                    },
                    {
                        "username": "ashutosh75",
                        "content": "if the sum of all the elements of the array is less than the coins than shouldn\\'t we return the length of array, but this fails on the one test case. why??\\nthis is my program, but it fails on the test case\\n \\n`class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int cost=0;\\n        int n=costs.length;\\n        \\n        for(int i=0;i<n;i++)\\n            cost+=costs[i];\\n\\n        if(cost<=coins)\\n        return n;\\n\\n        Arrays.sort(costs);\\n        if(costs[0]>coins)\\n        return 0;\\n\\n        int num=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(coins>=costs[i])\\n            {\\n                coins-=costs[i];\\n                num++;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n\\nTest case\\n[84195,37244,88639,38757,74362,60418,36934,27895,58532,65586,3292,78881,11155,50282,62760,66638,36227,17129,65612,61706,46056,2967,91032,81729,63368,47323,63798,19382,20208,25594,51206,42094,23165,59606,31648,85622,96402,23663,61983,11185,81143,97152,87273,7708,5376,80578,99057,18274,18338,74031,27744,92746,77831,62210,70446,70345,54338,50358,2712,19112,57950,92110,99706,88823,43578,22910,34823,35506,82962,16820,68315,11999,94554,23989,33608,87675,90444,47599,37225,84891,62189,61890,55737,38409,16222,97707,28636,51044,13969,65127,9914,32581,70867,87271,7363,89384,12668,48113,77365,26177,75073,9012,73963,30035,91549,8697,32882,83047,19849,95287,62290,30604,47065,12730,54852,80511,35312,43872,195,66508,64860,65250,46767,80563,77484,72587,55503,86845,51636,39940,30891,17700,2533,70226,57952,62791,67804,44569,96333,96973,62923,5579,86418,42843,89896,91970,74721,82399,6809,95006,97485,56323,38199,10167,54936,73182,19763,70375,12189,53960,62370,33354,1311,83264,58628,67135,52947,53432,41234,...\\n\\nCoins=26578414\\nOutput\\n47286\\nExpected\\n5073\\n\\n"
                    }
                ]
            },
            {
                "id": 1745341,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "If this is medium problem, Now I am ready for Google interview."
                    },
                    {
                        "username": "JuanQP",
                        "content": "> Hint 2/2:\\n> Sort the prices so that the cheapest ice cream bar comes first.\\n\\n\\uD83D\\uDE10\\uD83D\\uDC4C\\n"
                    },
                    {
                        "username": "gandi_nali_ka_keeda",
                        "content": "```\\nint c = 0,s=0;\\n        for (int cost : costs) {\\n            s += cost;\\n            if (s <= coins) c++;\\n        }\\n```\\nisn\\'t adding individual costs and checking if it less than the total coins same as deducting the cost from total coins? This is giving me wrong output  \\n"
                    },
                    {
                        "username": "ninadapte9",
                        "content": "konsa ganja phuuk ke esko medium level tag diya he bhai?"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Seems they\\'re giving us a New years gift by giving us a very easy week"
                    },
                    {
                        "username": "awb24",
                        "content": "Am I crazy or is this super easy?"
                    },
                    {
                        "username": "geeden",
                        "content": "This is easier than easy problems."
                    },
                    {
                        "username": "bilii",
                        "content": "I hope this is medium for the companies\\' interview"
                    },
                    {
                        "username": "sartaj_codes",
                        "content": "Who all were hesitant before clicking Submit button, seeing this \"Medium\" tagged level question."
                    },
                    {
                        "username": "ashutosh75",
                        "content": "if the sum of all the elements of the array is less than the coins than shouldn\\'t we return the length of array, but this fails on the one test case. why??\\nthis is my program, but it fails on the test case\\n \\n`class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int cost=0;\\n        int n=costs.length;\\n        \\n        for(int i=0;i<n;i++)\\n            cost+=costs[i];\\n\\n        if(cost<=coins)\\n        return n;\\n\\n        Arrays.sort(costs);\\n        if(costs[0]>coins)\\n        return 0;\\n\\n        int num=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(coins>=costs[i])\\n            {\\n                coins-=costs[i];\\n                num++;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n\\nTest case\\n[84195,37244,88639,38757,74362,60418,36934,27895,58532,65586,3292,78881,11155,50282,62760,66638,36227,17129,65612,61706,46056,2967,91032,81729,63368,47323,63798,19382,20208,25594,51206,42094,23165,59606,31648,85622,96402,23663,61983,11185,81143,97152,87273,7708,5376,80578,99057,18274,18338,74031,27744,92746,77831,62210,70446,70345,54338,50358,2712,19112,57950,92110,99706,88823,43578,22910,34823,35506,82962,16820,68315,11999,94554,23989,33608,87675,90444,47599,37225,84891,62189,61890,55737,38409,16222,97707,28636,51044,13969,65127,9914,32581,70867,87271,7363,89384,12668,48113,77365,26177,75073,9012,73963,30035,91549,8697,32882,83047,19849,95287,62290,30604,47065,12730,54852,80511,35312,43872,195,66508,64860,65250,46767,80563,77484,72587,55503,86845,51636,39940,30891,17700,2533,70226,57952,62791,67804,44569,96333,96973,62923,5579,86418,42843,89896,91970,74721,82399,6809,95006,97485,56323,38199,10167,54936,73182,19763,70375,12189,53960,62370,33354,1311,83264,58628,67135,52947,53432,41234,...\\n\\nCoins=26578414\\nOutput\\n47286\\nExpected\\n5073\\n\\n"
                    }
                ]
            },
            {
                "id": 1745279,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "If this is medium problem, Now I am ready for Google interview."
                    },
                    {
                        "username": "JuanQP",
                        "content": "> Hint 2/2:\\n> Sort the prices so that the cheapest ice cream bar comes first.\\n\\n\\uD83D\\uDE10\\uD83D\\uDC4C\\n"
                    },
                    {
                        "username": "gandi_nali_ka_keeda",
                        "content": "```\\nint c = 0,s=0;\\n        for (int cost : costs) {\\n            s += cost;\\n            if (s <= coins) c++;\\n        }\\n```\\nisn\\'t adding individual costs and checking if it less than the total coins same as deducting the cost from total coins? This is giving me wrong output  \\n"
                    },
                    {
                        "username": "ninadapte9",
                        "content": "konsa ganja phuuk ke esko medium level tag diya he bhai?"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Seems they\\'re giving us a New years gift by giving us a very easy week"
                    },
                    {
                        "username": "awb24",
                        "content": "Am I crazy or is this super easy?"
                    },
                    {
                        "username": "geeden",
                        "content": "This is easier than easy problems."
                    },
                    {
                        "username": "bilii",
                        "content": "I hope this is medium for the companies\\' interview"
                    },
                    {
                        "username": "sartaj_codes",
                        "content": "Who all were hesitant before clicking Submit button, seeing this \"Medium\" tagged level question."
                    },
                    {
                        "username": "ashutosh75",
                        "content": "if the sum of all the elements of the array is less than the coins than shouldn\\'t we return the length of array, but this fails on the one test case. why??\\nthis is my program, but it fails on the test case\\n \\n`class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int cost=0;\\n        int n=costs.length;\\n        \\n        for(int i=0;i<n;i++)\\n            cost+=costs[i];\\n\\n        if(cost<=coins)\\n        return n;\\n\\n        Arrays.sort(costs);\\n        if(costs[0]>coins)\\n        return 0;\\n\\n        int num=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(coins>=costs[i])\\n            {\\n                coins-=costs[i];\\n                num++;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n\\nTest case\\n[84195,37244,88639,38757,74362,60418,36934,27895,58532,65586,3292,78881,11155,50282,62760,66638,36227,17129,65612,61706,46056,2967,91032,81729,63368,47323,63798,19382,20208,25594,51206,42094,23165,59606,31648,85622,96402,23663,61983,11185,81143,97152,87273,7708,5376,80578,99057,18274,18338,74031,27744,92746,77831,62210,70446,70345,54338,50358,2712,19112,57950,92110,99706,88823,43578,22910,34823,35506,82962,16820,68315,11999,94554,23989,33608,87675,90444,47599,37225,84891,62189,61890,55737,38409,16222,97707,28636,51044,13969,65127,9914,32581,70867,87271,7363,89384,12668,48113,77365,26177,75073,9012,73963,30035,91549,8697,32882,83047,19849,95287,62290,30604,47065,12730,54852,80511,35312,43872,195,66508,64860,65250,46767,80563,77484,72587,55503,86845,51636,39940,30891,17700,2533,70226,57952,62791,67804,44569,96333,96973,62923,5579,86418,42843,89896,91970,74721,82399,6809,95006,97485,56323,38199,10167,54936,73182,19763,70375,12189,53960,62370,33354,1311,83264,58628,67135,52947,53432,41234,...\\n\\nCoins=26578414\\nOutput\\n47286\\nExpected\\n5073\\n\\n"
                    }
                ]
            },
            {
                "id": 1745255,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "If this is medium problem, Now I am ready for Google interview."
                    },
                    {
                        "username": "JuanQP",
                        "content": "> Hint 2/2:\\n> Sort the prices so that the cheapest ice cream bar comes first.\\n\\n\\uD83D\\uDE10\\uD83D\\uDC4C\\n"
                    },
                    {
                        "username": "gandi_nali_ka_keeda",
                        "content": "```\\nint c = 0,s=0;\\n        for (int cost : costs) {\\n            s += cost;\\n            if (s <= coins) c++;\\n        }\\n```\\nisn\\'t adding individual costs and checking if it less than the total coins same as deducting the cost from total coins? This is giving me wrong output  \\n"
                    },
                    {
                        "username": "ninadapte9",
                        "content": "konsa ganja phuuk ke esko medium level tag diya he bhai?"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Seems they\\'re giving us a New years gift by giving us a very easy week"
                    },
                    {
                        "username": "awb24",
                        "content": "Am I crazy or is this super easy?"
                    },
                    {
                        "username": "geeden",
                        "content": "This is easier than easy problems."
                    },
                    {
                        "username": "bilii",
                        "content": "I hope this is medium for the companies\\' interview"
                    },
                    {
                        "username": "sartaj_codes",
                        "content": "Who all were hesitant before clicking Submit button, seeing this \"Medium\" tagged level question."
                    },
                    {
                        "username": "ashutosh75",
                        "content": "if the sum of all the elements of the array is less than the coins than shouldn\\'t we return the length of array, but this fails on the one test case. why??\\nthis is my program, but it fails on the test case\\n \\n`class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int cost=0;\\n        int n=costs.length;\\n        \\n        for(int i=0;i<n;i++)\\n            cost+=costs[i];\\n\\n        if(cost<=coins)\\n        return n;\\n\\n        Arrays.sort(costs);\\n        if(costs[0]>coins)\\n        return 0;\\n\\n        int num=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(coins>=costs[i])\\n            {\\n                coins-=costs[i];\\n                num++;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n\\nTest case\\n[84195,37244,88639,38757,74362,60418,36934,27895,58532,65586,3292,78881,11155,50282,62760,66638,36227,17129,65612,61706,46056,2967,91032,81729,63368,47323,63798,19382,20208,25594,51206,42094,23165,59606,31648,85622,96402,23663,61983,11185,81143,97152,87273,7708,5376,80578,99057,18274,18338,74031,27744,92746,77831,62210,70446,70345,54338,50358,2712,19112,57950,92110,99706,88823,43578,22910,34823,35506,82962,16820,68315,11999,94554,23989,33608,87675,90444,47599,37225,84891,62189,61890,55737,38409,16222,97707,28636,51044,13969,65127,9914,32581,70867,87271,7363,89384,12668,48113,77365,26177,75073,9012,73963,30035,91549,8697,32882,83047,19849,95287,62290,30604,47065,12730,54852,80511,35312,43872,195,66508,64860,65250,46767,80563,77484,72587,55503,86845,51636,39940,30891,17700,2533,70226,57952,62791,67804,44569,96333,96973,62923,5579,86418,42843,89896,91970,74721,82399,6809,95006,97485,56323,38199,10167,54936,73182,19763,70375,12189,53960,62370,33354,1311,83264,58628,67135,52947,53432,41234,...\\n\\nCoins=26578414\\nOutput\\n47286\\nExpected\\n5073\\n\\n"
                    }
                ]
            },
            {
                "id": 1745250,
                "content": [
                    {
                        "username": "abhijeet_mavi",
                        "content": "If this is medium problem, Now I am ready for Google interview."
                    },
                    {
                        "username": "JuanQP",
                        "content": "> Hint 2/2:\\n> Sort the prices so that the cheapest ice cream bar comes first.\\n\\n\\uD83D\\uDE10\\uD83D\\uDC4C\\n"
                    },
                    {
                        "username": "gandi_nali_ka_keeda",
                        "content": "```\\nint c = 0,s=0;\\n        for (int cost : costs) {\\n            s += cost;\\n            if (s <= coins) c++;\\n        }\\n```\\nisn\\'t adding individual costs and checking if it less than the total coins same as deducting the cost from total coins? This is giving me wrong output  \\n"
                    },
                    {
                        "username": "ninadapte9",
                        "content": "konsa ganja phuuk ke esko medium level tag diya he bhai?"
                    },
                    {
                        "username": "Tobe_Triton",
                        "content": "Seems they\\'re giving us a New years gift by giving us a very easy week"
                    },
                    {
                        "username": "awb24",
                        "content": "Am I crazy or is this super easy?"
                    },
                    {
                        "username": "geeden",
                        "content": "This is easier than easy problems."
                    },
                    {
                        "username": "bilii",
                        "content": "I hope this is medium for the companies\\' interview"
                    },
                    {
                        "username": "sartaj_codes",
                        "content": "Who all were hesitant before clicking Submit button, seeing this \"Medium\" tagged level question."
                    },
                    {
                        "username": "ashutosh75",
                        "content": "if the sum of all the elements of the array is less than the coins than shouldn\\'t we return the length of array, but this fails on the one test case. why??\\nthis is my program, but it fails on the test case\\n \\n`class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        int cost=0;\\n        int n=costs.length;\\n        \\n        for(int i=0;i<n;i++)\\n            cost+=costs[i];\\n\\n        if(cost<=coins)\\n        return n;\\n\\n        Arrays.sort(costs);\\n        if(costs[0]>coins)\\n        return 0;\\n\\n        int num=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            if(coins>=costs[i])\\n            {\\n                coins-=costs[i];\\n                num++;\\n            }\\n        }\\n        return num;\\n    }\\n}\\n\\nTest case\\n[84195,37244,88639,38757,74362,60418,36934,27895,58532,65586,3292,78881,11155,50282,62760,66638,36227,17129,65612,61706,46056,2967,91032,81729,63368,47323,63798,19382,20208,25594,51206,42094,23165,59606,31648,85622,96402,23663,61983,11185,81143,97152,87273,7708,5376,80578,99057,18274,18338,74031,27744,92746,77831,62210,70446,70345,54338,50358,2712,19112,57950,92110,99706,88823,43578,22910,34823,35506,82962,16820,68315,11999,94554,23989,33608,87675,90444,47599,37225,84891,62189,61890,55737,38409,16222,97707,28636,51044,13969,65127,9914,32581,70867,87271,7363,89384,12668,48113,77365,26177,75073,9012,73963,30035,91549,8697,32882,83047,19849,95287,62290,30604,47065,12730,54852,80511,35312,43872,195,66508,64860,65250,46767,80563,77484,72587,55503,86845,51636,39940,30891,17700,2533,70226,57952,62791,67804,44569,96333,96973,62923,5579,86418,42843,89896,91970,74721,82399,6809,95006,97485,56323,38199,10167,54936,73182,19763,70375,12189,53960,62370,33354,1311,83264,58628,67135,52947,53432,41234,...\\n\\nCoins=26578414\\nOutput\\n47286\\nExpected\\n5073\\n\\n"
                    }
                ]
            },
            {
                "id": 1745242,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "I dont know why my test case aren\\'t running anyone help fast\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int sum=0;\\n        int ans=0;\\n        for(int i=0;i<costs.length;i++){\\n            if(costs[i]>coins){\\n                return 0;\\n            }\\n            if(sum < coins)\\n            {\\n                sum+=costs[i];\\n                ans=i+1;\\n    \\n\\n            }\\n            else{\\n                \\n                break;\\n                \\n\\n            }\\n            \\n         }\\n         return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "debug_04",
                        "content": "Is this problem is similar to 0/1 Knapsack problem ? If yes, can anyone give me the code solution of this problem with 0/1 Knapsack approach ?\\n\\nIf no, then why this problem is not the variation of 0/1 knapsack, I mean what is the reason? Like if we consider `coins` as knapsack\\'s `capacity` and `costs` as array of items, then why can\\'t we solve this by 0/1 knapsack method?"
                    },
                    {
                        "username": "dmittal_be20",
                        "content": "class Solution {\\npublic:\\nint f(int index,vector<int> &costs,int coins,vector<vector<int>> &dp)\\n{\\n    if(index==0)\\n    {\\n        if(costs[index]<=coins)\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    if(dp[index][coins]!=-1) return dp[index][coins];\\n    int nottake = 0+f(index-1,costs,coins,dp);\\n    int take = INT_MIN;\\n    if(costs[index]<=coins)\\n    {\\n        take = 1+f(index-1,costs,coins-costs[index],dp);\\n    }\\n    return dp[index][coins] = max(take,nottake);\\n}\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        vector<vector<int>> dp(n,vector<int>(coins+1,-1));\\n        return f(n-1,costs,coins,dp);\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\n\\nDone using memoization but giving tle"
                    },
                    {
                        "username": "ag10022101",
                        "content": "this should not exist "
                    },
                    {
                        "username": "MZain",
                        "content": "Easiest problem. It should be ranked as easy."
                    },
                    {
                        "username": "JV_004",
                        "content": "confidence booster , ty !"
                    },
                    {
                        "username": "d3vu",
                        "content": "In the starting I was thinking it must be a variation of knap sack then I realized this is easiest medium."
                    },
                    {
                        "username": "ArunSantharam",
                        "content": "I read the question multiple times to not miss the constraint that makes the question \"medium\"."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Suppose a guy is doing medium leetcode problem for the first time and he stumbles upon this problem - boy is he gonna be on 7th sky to be able to solve a leetcode medium."
                    },
                    {
                        "username": "Kazuma0803",
                        "content": "For those who generally have doubts whether to apply dp or greedy, just see the constraints, if no. of operations with using dp is more than 10^8, try to think of dp."
                    },
                    {
                        "username": "jga111",
                        "content": "I don\\'t understand the distinction between greedy and dp. Normally, DP problems are greedy too. As for this problem, you can solve it in O(n+m) - most will opt for \\'easy\\' O(n log n)"
                    },
                    {
                        "username": "noob_coder_smd",
                        "content": "I am very new in Leetcode and this was my first day coding challenge. Gladly it\\'s an easy one comparatively. I have solved the problem using python3, mostly built in list functions, and thankfully it worked fine in 51/63 testcases. However, it is showing Time Limit Exceeded for the remaining one. Is it a matter of concern or something? Or it\\'s fine? The code is merely 15 lines but still there\\'s runtime issue. Will appreciate advice and suggestions from others. Thanks."
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "I think number of lines in code doesn\\'t affect the runtime issue it is the functions you used, or loops affecting btw I know java so that\\'s all I think"
                    }
                ]
            },
            {
                "id": 1745198,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "I dont know why my test case aren\\'t running anyone help fast\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int sum=0;\\n        int ans=0;\\n        for(int i=0;i<costs.length;i++){\\n            if(costs[i]>coins){\\n                return 0;\\n            }\\n            if(sum < coins)\\n            {\\n                sum+=costs[i];\\n                ans=i+1;\\n    \\n\\n            }\\n            else{\\n                \\n                break;\\n                \\n\\n            }\\n            \\n         }\\n         return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "debug_04",
                        "content": "Is this problem is similar to 0/1 Knapsack problem ? If yes, can anyone give me the code solution of this problem with 0/1 Knapsack approach ?\\n\\nIf no, then why this problem is not the variation of 0/1 knapsack, I mean what is the reason? Like if we consider `coins` as knapsack\\'s `capacity` and `costs` as array of items, then why can\\'t we solve this by 0/1 knapsack method?"
                    },
                    {
                        "username": "dmittal_be20",
                        "content": "class Solution {\\npublic:\\nint f(int index,vector<int> &costs,int coins,vector<vector<int>> &dp)\\n{\\n    if(index==0)\\n    {\\n        if(costs[index]<=coins)\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    if(dp[index][coins]!=-1) return dp[index][coins];\\n    int nottake = 0+f(index-1,costs,coins,dp);\\n    int take = INT_MIN;\\n    if(costs[index]<=coins)\\n    {\\n        take = 1+f(index-1,costs,coins-costs[index],dp);\\n    }\\n    return dp[index][coins] = max(take,nottake);\\n}\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        vector<vector<int>> dp(n,vector<int>(coins+1,-1));\\n        return f(n-1,costs,coins,dp);\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\n\\nDone using memoization but giving tle"
                    },
                    {
                        "username": "ag10022101",
                        "content": "this should not exist "
                    },
                    {
                        "username": "MZain",
                        "content": "Easiest problem. It should be ranked as easy."
                    },
                    {
                        "username": "JV_004",
                        "content": "confidence booster , ty !"
                    },
                    {
                        "username": "d3vu",
                        "content": "In the starting I was thinking it must be a variation of knap sack then I realized this is easiest medium."
                    },
                    {
                        "username": "ArunSantharam",
                        "content": "I read the question multiple times to not miss the constraint that makes the question \"medium\"."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Suppose a guy is doing medium leetcode problem for the first time and he stumbles upon this problem - boy is he gonna be on 7th sky to be able to solve a leetcode medium."
                    },
                    {
                        "username": "Kazuma0803",
                        "content": "For those who generally have doubts whether to apply dp or greedy, just see the constraints, if no. of operations with using dp is more than 10^8, try to think of dp."
                    },
                    {
                        "username": "jga111",
                        "content": "I don\\'t understand the distinction between greedy and dp. Normally, DP problems are greedy too. As for this problem, you can solve it in O(n+m) - most will opt for \\'easy\\' O(n log n)"
                    },
                    {
                        "username": "noob_coder_smd",
                        "content": "I am very new in Leetcode and this was my first day coding challenge. Gladly it\\'s an easy one comparatively. I have solved the problem using python3, mostly built in list functions, and thankfully it worked fine in 51/63 testcases. However, it is showing Time Limit Exceeded for the remaining one. Is it a matter of concern or something? Or it\\'s fine? The code is merely 15 lines but still there\\'s runtime issue. Will appreciate advice and suggestions from others. Thanks."
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "I think number of lines in code doesn\\'t affect the runtime issue it is the functions you used, or loops affecting btw I know java so that\\'s all I think"
                    }
                ]
            },
            {
                "id": 1745184,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "I dont know why my test case aren\\'t running anyone help fast\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int sum=0;\\n        int ans=0;\\n        for(int i=0;i<costs.length;i++){\\n            if(costs[i]>coins){\\n                return 0;\\n            }\\n            if(sum < coins)\\n            {\\n                sum+=costs[i];\\n                ans=i+1;\\n    \\n\\n            }\\n            else{\\n                \\n                break;\\n                \\n\\n            }\\n            \\n         }\\n         return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "debug_04",
                        "content": "Is this problem is similar to 0/1 Knapsack problem ? If yes, can anyone give me the code solution of this problem with 0/1 Knapsack approach ?\\n\\nIf no, then why this problem is not the variation of 0/1 knapsack, I mean what is the reason? Like if we consider `coins` as knapsack\\'s `capacity` and `costs` as array of items, then why can\\'t we solve this by 0/1 knapsack method?"
                    },
                    {
                        "username": "dmittal_be20",
                        "content": "class Solution {\\npublic:\\nint f(int index,vector<int> &costs,int coins,vector<vector<int>> &dp)\\n{\\n    if(index==0)\\n    {\\n        if(costs[index]<=coins)\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    if(dp[index][coins]!=-1) return dp[index][coins];\\n    int nottake = 0+f(index-1,costs,coins,dp);\\n    int take = INT_MIN;\\n    if(costs[index]<=coins)\\n    {\\n        take = 1+f(index-1,costs,coins-costs[index],dp);\\n    }\\n    return dp[index][coins] = max(take,nottake);\\n}\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        vector<vector<int>> dp(n,vector<int>(coins+1,-1));\\n        return f(n-1,costs,coins,dp);\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\n\\nDone using memoization but giving tle"
                    },
                    {
                        "username": "ag10022101",
                        "content": "this should not exist "
                    },
                    {
                        "username": "MZain",
                        "content": "Easiest problem. It should be ranked as easy."
                    },
                    {
                        "username": "JV_004",
                        "content": "confidence booster , ty !"
                    },
                    {
                        "username": "d3vu",
                        "content": "In the starting I was thinking it must be a variation of knap sack then I realized this is easiest medium."
                    },
                    {
                        "username": "ArunSantharam",
                        "content": "I read the question multiple times to not miss the constraint that makes the question \"medium\"."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Suppose a guy is doing medium leetcode problem for the first time and he stumbles upon this problem - boy is he gonna be on 7th sky to be able to solve a leetcode medium."
                    },
                    {
                        "username": "Kazuma0803",
                        "content": "For those who generally have doubts whether to apply dp or greedy, just see the constraints, if no. of operations with using dp is more than 10^8, try to think of dp."
                    },
                    {
                        "username": "jga111",
                        "content": "I don\\'t understand the distinction between greedy and dp. Normally, DP problems are greedy too. As for this problem, you can solve it in O(n+m) - most will opt for \\'easy\\' O(n log n)"
                    },
                    {
                        "username": "noob_coder_smd",
                        "content": "I am very new in Leetcode and this was my first day coding challenge. Gladly it\\'s an easy one comparatively. I have solved the problem using python3, mostly built in list functions, and thankfully it worked fine in 51/63 testcases. However, it is showing Time Limit Exceeded for the remaining one. Is it a matter of concern or something? Or it\\'s fine? The code is merely 15 lines but still there\\'s runtime issue. Will appreciate advice and suggestions from others. Thanks."
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "I think number of lines in code doesn\\'t affect the runtime issue it is the functions you used, or loops affecting btw I know java so that\\'s all I think"
                    }
                ]
            },
            {
                "id": 1745162,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "I dont know why my test case aren\\'t running anyone help fast\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int sum=0;\\n        int ans=0;\\n        for(int i=0;i<costs.length;i++){\\n            if(costs[i]>coins){\\n                return 0;\\n            }\\n            if(sum < coins)\\n            {\\n                sum+=costs[i];\\n                ans=i+1;\\n    \\n\\n            }\\n            else{\\n                \\n                break;\\n                \\n\\n            }\\n            \\n         }\\n         return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "debug_04",
                        "content": "Is this problem is similar to 0/1 Knapsack problem ? If yes, can anyone give me the code solution of this problem with 0/1 Knapsack approach ?\\n\\nIf no, then why this problem is not the variation of 0/1 knapsack, I mean what is the reason? Like if we consider `coins` as knapsack\\'s `capacity` and `costs` as array of items, then why can\\'t we solve this by 0/1 knapsack method?"
                    },
                    {
                        "username": "dmittal_be20",
                        "content": "class Solution {\\npublic:\\nint f(int index,vector<int> &costs,int coins,vector<vector<int>> &dp)\\n{\\n    if(index==0)\\n    {\\n        if(costs[index]<=coins)\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    if(dp[index][coins]!=-1) return dp[index][coins];\\n    int nottake = 0+f(index-1,costs,coins,dp);\\n    int take = INT_MIN;\\n    if(costs[index]<=coins)\\n    {\\n        take = 1+f(index-1,costs,coins-costs[index],dp);\\n    }\\n    return dp[index][coins] = max(take,nottake);\\n}\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        vector<vector<int>> dp(n,vector<int>(coins+1,-1));\\n        return f(n-1,costs,coins,dp);\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\n\\nDone using memoization but giving tle"
                    },
                    {
                        "username": "ag10022101",
                        "content": "this should not exist "
                    },
                    {
                        "username": "MZain",
                        "content": "Easiest problem. It should be ranked as easy."
                    },
                    {
                        "username": "JV_004",
                        "content": "confidence booster , ty !"
                    },
                    {
                        "username": "d3vu",
                        "content": "In the starting I was thinking it must be a variation of knap sack then I realized this is easiest medium."
                    },
                    {
                        "username": "ArunSantharam",
                        "content": "I read the question multiple times to not miss the constraint that makes the question \"medium\"."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Suppose a guy is doing medium leetcode problem for the first time and he stumbles upon this problem - boy is he gonna be on 7th sky to be able to solve a leetcode medium."
                    },
                    {
                        "username": "Kazuma0803",
                        "content": "For those who generally have doubts whether to apply dp or greedy, just see the constraints, if no. of operations with using dp is more than 10^8, try to think of dp."
                    },
                    {
                        "username": "jga111",
                        "content": "I don\\'t understand the distinction between greedy and dp. Normally, DP problems are greedy too. As for this problem, you can solve it in O(n+m) - most will opt for \\'easy\\' O(n log n)"
                    },
                    {
                        "username": "noob_coder_smd",
                        "content": "I am very new in Leetcode and this was my first day coding challenge. Gladly it\\'s an easy one comparatively. I have solved the problem using python3, mostly built in list functions, and thankfully it worked fine in 51/63 testcases. However, it is showing Time Limit Exceeded for the remaining one. Is it a matter of concern or something? Or it\\'s fine? The code is merely 15 lines but still there\\'s runtime issue. Will appreciate advice and suggestions from others. Thanks."
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "I think number of lines in code doesn\\'t affect the runtime issue it is the functions you used, or loops affecting btw I know java so that\\'s all I think"
                    }
                ]
            },
            {
                "id": 1745144,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "I dont know why my test case aren\\'t running anyone help fast\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int sum=0;\\n        int ans=0;\\n        for(int i=0;i<costs.length;i++){\\n            if(costs[i]>coins){\\n                return 0;\\n            }\\n            if(sum < coins)\\n            {\\n                sum+=costs[i];\\n                ans=i+1;\\n    \\n\\n            }\\n            else{\\n                \\n                break;\\n                \\n\\n            }\\n            \\n         }\\n         return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "debug_04",
                        "content": "Is this problem is similar to 0/1 Knapsack problem ? If yes, can anyone give me the code solution of this problem with 0/1 Knapsack approach ?\\n\\nIf no, then why this problem is not the variation of 0/1 knapsack, I mean what is the reason? Like if we consider `coins` as knapsack\\'s `capacity` and `costs` as array of items, then why can\\'t we solve this by 0/1 knapsack method?"
                    },
                    {
                        "username": "dmittal_be20",
                        "content": "class Solution {\\npublic:\\nint f(int index,vector<int> &costs,int coins,vector<vector<int>> &dp)\\n{\\n    if(index==0)\\n    {\\n        if(costs[index]<=coins)\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    if(dp[index][coins]!=-1) return dp[index][coins];\\n    int nottake = 0+f(index-1,costs,coins,dp);\\n    int take = INT_MIN;\\n    if(costs[index]<=coins)\\n    {\\n        take = 1+f(index-1,costs,coins-costs[index],dp);\\n    }\\n    return dp[index][coins] = max(take,nottake);\\n}\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        vector<vector<int>> dp(n,vector<int>(coins+1,-1));\\n        return f(n-1,costs,coins,dp);\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\n\\nDone using memoization but giving tle"
                    },
                    {
                        "username": "ag10022101",
                        "content": "this should not exist "
                    },
                    {
                        "username": "MZain",
                        "content": "Easiest problem. It should be ranked as easy."
                    },
                    {
                        "username": "JV_004",
                        "content": "confidence booster , ty !"
                    },
                    {
                        "username": "d3vu",
                        "content": "In the starting I was thinking it must be a variation of knap sack then I realized this is easiest medium."
                    },
                    {
                        "username": "ArunSantharam",
                        "content": "I read the question multiple times to not miss the constraint that makes the question \"medium\"."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Suppose a guy is doing medium leetcode problem for the first time and he stumbles upon this problem - boy is he gonna be on 7th sky to be able to solve a leetcode medium."
                    },
                    {
                        "username": "Kazuma0803",
                        "content": "For those who generally have doubts whether to apply dp or greedy, just see the constraints, if no. of operations with using dp is more than 10^8, try to think of dp."
                    },
                    {
                        "username": "jga111",
                        "content": "I don\\'t understand the distinction between greedy and dp. Normally, DP problems are greedy too. As for this problem, you can solve it in O(n+m) - most will opt for \\'easy\\' O(n log n)"
                    },
                    {
                        "username": "noob_coder_smd",
                        "content": "I am very new in Leetcode and this was my first day coding challenge. Gladly it\\'s an easy one comparatively. I have solved the problem using python3, mostly built in list functions, and thankfully it worked fine in 51/63 testcases. However, it is showing Time Limit Exceeded for the remaining one. Is it a matter of concern or something? Or it\\'s fine? The code is merely 15 lines but still there\\'s runtime issue. Will appreciate advice and suggestions from others. Thanks."
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "I think number of lines in code doesn\\'t affect the runtime issue it is the functions you used, or loops affecting btw I know java so that\\'s all I think"
                    }
                ]
            },
            {
                "id": 1745142,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "I dont know why my test case aren\\'t running anyone help fast\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int sum=0;\\n        int ans=0;\\n        for(int i=0;i<costs.length;i++){\\n            if(costs[i]>coins){\\n                return 0;\\n            }\\n            if(sum < coins)\\n            {\\n                sum+=costs[i];\\n                ans=i+1;\\n    \\n\\n            }\\n            else{\\n                \\n                break;\\n                \\n\\n            }\\n            \\n         }\\n         return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "debug_04",
                        "content": "Is this problem is similar to 0/1 Knapsack problem ? If yes, can anyone give me the code solution of this problem with 0/1 Knapsack approach ?\\n\\nIf no, then why this problem is not the variation of 0/1 knapsack, I mean what is the reason? Like if we consider `coins` as knapsack\\'s `capacity` and `costs` as array of items, then why can\\'t we solve this by 0/1 knapsack method?"
                    },
                    {
                        "username": "dmittal_be20",
                        "content": "class Solution {\\npublic:\\nint f(int index,vector<int> &costs,int coins,vector<vector<int>> &dp)\\n{\\n    if(index==0)\\n    {\\n        if(costs[index]<=coins)\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    if(dp[index][coins]!=-1) return dp[index][coins];\\n    int nottake = 0+f(index-1,costs,coins,dp);\\n    int take = INT_MIN;\\n    if(costs[index]<=coins)\\n    {\\n        take = 1+f(index-1,costs,coins-costs[index],dp);\\n    }\\n    return dp[index][coins] = max(take,nottake);\\n}\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        vector<vector<int>> dp(n,vector<int>(coins+1,-1));\\n        return f(n-1,costs,coins,dp);\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\n\\nDone using memoization but giving tle"
                    },
                    {
                        "username": "ag10022101",
                        "content": "this should not exist "
                    },
                    {
                        "username": "MZain",
                        "content": "Easiest problem. It should be ranked as easy."
                    },
                    {
                        "username": "JV_004",
                        "content": "confidence booster , ty !"
                    },
                    {
                        "username": "d3vu",
                        "content": "In the starting I was thinking it must be a variation of knap sack then I realized this is easiest medium."
                    },
                    {
                        "username": "ArunSantharam",
                        "content": "I read the question multiple times to not miss the constraint that makes the question \"medium\"."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Suppose a guy is doing medium leetcode problem for the first time and he stumbles upon this problem - boy is he gonna be on 7th sky to be able to solve a leetcode medium."
                    },
                    {
                        "username": "Kazuma0803",
                        "content": "For those who generally have doubts whether to apply dp or greedy, just see the constraints, if no. of operations with using dp is more than 10^8, try to think of dp."
                    },
                    {
                        "username": "jga111",
                        "content": "I don\\'t understand the distinction between greedy and dp. Normally, DP problems are greedy too. As for this problem, you can solve it in O(n+m) - most will opt for \\'easy\\' O(n log n)"
                    },
                    {
                        "username": "noob_coder_smd",
                        "content": "I am very new in Leetcode and this was my first day coding challenge. Gladly it\\'s an easy one comparatively. I have solved the problem using python3, mostly built in list functions, and thankfully it worked fine in 51/63 testcases. However, it is showing Time Limit Exceeded for the remaining one. Is it a matter of concern or something? Or it\\'s fine? The code is merely 15 lines but still there\\'s runtime issue. Will appreciate advice and suggestions from others. Thanks."
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "I think number of lines in code doesn\\'t affect the runtime issue it is the functions you used, or loops affecting btw I know java so that\\'s all I think"
                    }
                ]
            },
            {
                "id": 1745135,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "I dont know why my test case aren\\'t running anyone help fast\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int sum=0;\\n        int ans=0;\\n        for(int i=0;i<costs.length;i++){\\n            if(costs[i]>coins){\\n                return 0;\\n            }\\n            if(sum < coins)\\n            {\\n                sum+=costs[i];\\n                ans=i+1;\\n    \\n\\n            }\\n            else{\\n                \\n                break;\\n                \\n\\n            }\\n            \\n         }\\n         return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "debug_04",
                        "content": "Is this problem is similar to 0/1 Knapsack problem ? If yes, can anyone give me the code solution of this problem with 0/1 Knapsack approach ?\\n\\nIf no, then why this problem is not the variation of 0/1 knapsack, I mean what is the reason? Like if we consider `coins` as knapsack\\'s `capacity` and `costs` as array of items, then why can\\'t we solve this by 0/1 knapsack method?"
                    },
                    {
                        "username": "dmittal_be20",
                        "content": "class Solution {\\npublic:\\nint f(int index,vector<int> &costs,int coins,vector<vector<int>> &dp)\\n{\\n    if(index==0)\\n    {\\n        if(costs[index]<=coins)\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    if(dp[index][coins]!=-1) return dp[index][coins];\\n    int nottake = 0+f(index-1,costs,coins,dp);\\n    int take = INT_MIN;\\n    if(costs[index]<=coins)\\n    {\\n        take = 1+f(index-1,costs,coins-costs[index],dp);\\n    }\\n    return dp[index][coins] = max(take,nottake);\\n}\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        vector<vector<int>> dp(n,vector<int>(coins+1,-1));\\n        return f(n-1,costs,coins,dp);\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\n\\nDone using memoization but giving tle"
                    },
                    {
                        "username": "ag10022101",
                        "content": "this should not exist "
                    },
                    {
                        "username": "MZain",
                        "content": "Easiest problem. It should be ranked as easy."
                    },
                    {
                        "username": "JV_004",
                        "content": "confidence booster , ty !"
                    },
                    {
                        "username": "d3vu",
                        "content": "In the starting I was thinking it must be a variation of knap sack then I realized this is easiest medium."
                    },
                    {
                        "username": "ArunSantharam",
                        "content": "I read the question multiple times to not miss the constraint that makes the question \"medium\"."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Suppose a guy is doing medium leetcode problem for the first time and he stumbles upon this problem - boy is he gonna be on 7th sky to be able to solve a leetcode medium."
                    },
                    {
                        "username": "Kazuma0803",
                        "content": "For those who generally have doubts whether to apply dp or greedy, just see the constraints, if no. of operations with using dp is more than 10^8, try to think of dp."
                    },
                    {
                        "username": "jga111",
                        "content": "I don\\'t understand the distinction between greedy and dp. Normally, DP problems are greedy too. As for this problem, you can solve it in O(n+m) - most will opt for \\'easy\\' O(n log n)"
                    },
                    {
                        "username": "noob_coder_smd",
                        "content": "I am very new in Leetcode and this was my first day coding challenge. Gladly it\\'s an easy one comparatively. I have solved the problem using python3, mostly built in list functions, and thankfully it worked fine in 51/63 testcases. However, it is showing Time Limit Exceeded for the remaining one. Is it a matter of concern or something? Or it\\'s fine? The code is merely 15 lines but still there\\'s runtime issue. Will appreciate advice and suggestions from others. Thanks."
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "I think number of lines in code doesn\\'t affect the runtime issue it is the functions you used, or loops affecting btw I know java so that\\'s all I think"
                    }
                ]
            },
            {
                "id": 1745131,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "I dont know why my test case aren\\'t running anyone help fast\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int sum=0;\\n        int ans=0;\\n        for(int i=0;i<costs.length;i++){\\n            if(costs[i]>coins){\\n                return 0;\\n            }\\n            if(sum < coins)\\n            {\\n                sum+=costs[i];\\n                ans=i+1;\\n    \\n\\n            }\\n            else{\\n                \\n                break;\\n                \\n\\n            }\\n            \\n         }\\n         return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "debug_04",
                        "content": "Is this problem is similar to 0/1 Knapsack problem ? If yes, can anyone give me the code solution of this problem with 0/1 Knapsack approach ?\\n\\nIf no, then why this problem is not the variation of 0/1 knapsack, I mean what is the reason? Like if we consider `coins` as knapsack\\'s `capacity` and `costs` as array of items, then why can\\'t we solve this by 0/1 knapsack method?"
                    },
                    {
                        "username": "dmittal_be20",
                        "content": "class Solution {\\npublic:\\nint f(int index,vector<int> &costs,int coins,vector<vector<int>> &dp)\\n{\\n    if(index==0)\\n    {\\n        if(costs[index]<=coins)\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    if(dp[index][coins]!=-1) return dp[index][coins];\\n    int nottake = 0+f(index-1,costs,coins,dp);\\n    int take = INT_MIN;\\n    if(costs[index]<=coins)\\n    {\\n        take = 1+f(index-1,costs,coins-costs[index],dp);\\n    }\\n    return dp[index][coins] = max(take,nottake);\\n}\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        vector<vector<int>> dp(n,vector<int>(coins+1,-1));\\n        return f(n-1,costs,coins,dp);\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\n\\nDone using memoization but giving tle"
                    },
                    {
                        "username": "ag10022101",
                        "content": "this should not exist "
                    },
                    {
                        "username": "MZain",
                        "content": "Easiest problem. It should be ranked as easy."
                    },
                    {
                        "username": "JV_004",
                        "content": "confidence booster , ty !"
                    },
                    {
                        "username": "d3vu",
                        "content": "In the starting I was thinking it must be a variation of knap sack then I realized this is easiest medium."
                    },
                    {
                        "username": "ArunSantharam",
                        "content": "I read the question multiple times to not miss the constraint that makes the question \"medium\"."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Suppose a guy is doing medium leetcode problem for the first time and he stumbles upon this problem - boy is he gonna be on 7th sky to be able to solve a leetcode medium."
                    },
                    {
                        "username": "Kazuma0803",
                        "content": "For those who generally have doubts whether to apply dp or greedy, just see the constraints, if no. of operations with using dp is more than 10^8, try to think of dp."
                    },
                    {
                        "username": "jga111",
                        "content": "I don\\'t understand the distinction between greedy and dp. Normally, DP problems are greedy too. As for this problem, you can solve it in O(n+m) - most will opt for \\'easy\\' O(n log n)"
                    },
                    {
                        "username": "noob_coder_smd",
                        "content": "I am very new in Leetcode and this was my first day coding challenge. Gladly it\\'s an easy one comparatively. I have solved the problem using python3, mostly built in list functions, and thankfully it worked fine in 51/63 testcases. However, it is showing Time Limit Exceeded for the remaining one. Is it a matter of concern or something? Or it\\'s fine? The code is merely 15 lines but still there\\'s runtime issue. Will appreciate advice and suggestions from others. Thanks."
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "I think number of lines in code doesn\\'t affect the runtime issue it is the functions you used, or loops affecting btw I know java so that\\'s all I think"
                    }
                ]
            },
            {
                "id": 1745124,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "I dont know why my test case aren\\'t running anyone help fast\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int sum=0;\\n        int ans=0;\\n        for(int i=0;i<costs.length;i++){\\n            if(costs[i]>coins){\\n                return 0;\\n            }\\n            if(sum < coins)\\n            {\\n                sum+=costs[i];\\n                ans=i+1;\\n    \\n\\n            }\\n            else{\\n                \\n                break;\\n                \\n\\n            }\\n            \\n         }\\n         return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "debug_04",
                        "content": "Is this problem is similar to 0/1 Knapsack problem ? If yes, can anyone give me the code solution of this problem with 0/1 Knapsack approach ?\\n\\nIf no, then why this problem is not the variation of 0/1 knapsack, I mean what is the reason? Like if we consider `coins` as knapsack\\'s `capacity` and `costs` as array of items, then why can\\'t we solve this by 0/1 knapsack method?"
                    },
                    {
                        "username": "dmittal_be20",
                        "content": "class Solution {\\npublic:\\nint f(int index,vector<int> &costs,int coins,vector<vector<int>> &dp)\\n{\\n    if(index==0)\\n    {\\n        if(costs[index]<=coins)\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    if(dp[index][coins]!=-1) return dp[index][coins];\\n    int nottake = 0+f(index-1,costs,coins,dp);\\n    int take = INT_MIN;\\n    if(costs[index]<=coins)\\n    {\\n        take = 1+f(index-1,costs,coins-costs[index],dp);\\n    }\\n    return dp[index][coins] = max(take,nottake);\\n}\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        vector<vector<int>> dp(n,vector<int>(coins+1,-1));\\n        return f(n-1,costs,coins,dp);\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\n\\nDone using memoization but giving tle"
                    },
                    {
                        "username": "ag10022101",
                        "content": "this should not exist "
                    },
                    {
                        "username": "MZain",
                        "content": "Easiest problem. It should be ranked as easy."
                    },
                    {
                        "username": "JV_004",
                        "content": "confidence booster , ty !"
                    },
                    {
                        "username": "d3vu",
                        "content": "In the starting I was thinking it must be a variation of knap sack then I realized this is easiest medium."
                    },
                    {
                        "username": "ArunSantharam",
                        "content": "I read the question multiple times to not miss the constraint that makes the question \"medium\"."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Suppose a guy is doing medium leetcode problem for the first time and he stumbles upon this problem - boy is he gonna be on 7th sky to be able to solve a leetcode medium."
                    },
                    {
                        "username": "Kazuma0803",
                        "content": "For those who generally have doubts whether to apply dp or greedy, just see the constraints, if no. of operations with using dp is more than 10^8, try to think of dp."
                    },
                    {
                        "username": "jga111",
                        "content": "I don\\'t understand the distinction between greedy and dp. Normally, DP problems are greedy too. As for this problem, you can solve it in O(n+m) - most will opt for \\'easy\\' O(n log n)"
                    },
                    {
                        "username": "noob_coder_smd",
                        "content": "I am very new in Leetcode and this was my first day coding challenge. Gladly it\\'s an easy one comparatively. I have solved the problem using python3, mostly built in list functions, and thankfully it worked fine in 51/63 testcases. However, it is showing Time Limit Exceeded for the remaining one. Is it a matter of concern or something? Or it\\'s fine? The code is merely 15 lines but still there\\'s runtime issue. Will appreciate advice and suggestions from others. Thanks."
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "I think number of lines in code doesn\\'t affect the runtime issue it is the functions you used, or loops affecting btw I know java so that\\'s all I think"
                    }
                ]
            },
            {
                "id": 1745118,
                "content": [
                    {
                        "username": "Vabs_786",
                        "content": "I dont know why my test case aren\\'t running anyone help fast\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int sum=0;\\n        int ans=0;\\n        for(int i=0;i<costs.length;i++){\\n            if(costs[i]>coins){\\n                return 0;\\n            }\\n            if(sum < coins)\\n            {\\n                sum+=costs[i];\\n                ans=i+1;\\n    \\n\\n            }\\n            else{\\n                \\n                break;\\n                \\n\\n            }\\n            \\n         }\\n         return ans;\\n\\n    }\\n}"
                    },
                    {
                        "username": "debug_04",
                        "content": "Is this problem is similar to 0/1 Knapsack problem ? If yes, can anyone give me the code solution of this problem with 0/1 Knapsack approach ?\\n\\nIf no, then why this problem is not the variation of 0/1 knapsack, I mean what is the reason? Like if we consider `coins` as knapsack\\'s `capacity` and `costs` as array of items, then why can\\'t we solve this by 0/1 knapsack method?"
                    },
                    {
                        "username": "dmittal_be20",
                        "content": "class Solution {\\npublic:\\nint f(int index,vector<int> &costs,int coins,vector<vector<int>> &dp)\\n{\\n    if(index==0)\\n    {\\n        if(costs[index]<=coins)\\n        {\\n            return 1;\\n        }\\n        return 0;\\n    }\\n    if(dp[index][coins]!=-1) return dp[index][coins];\\n    int nottake = 0+f(index-1,costs,coins,dp);\\n    int take = INT_MIN;\\n    if(costs[index]<=coins)\\n    {\\n        take = 1+f(index-1,costs,coins-costs[index],dp);\\n    }\\n    return dp[index][coins] = max(take,nottake);\\n}\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        int n = costs.size();\\n        vector<vector<int>> dp(n,vector<int>(coins+1,-1));\\n        return f(n-1,costs,coins,dp);\\n\\xA0\\xA0\\xA0\\xA0}\\n};\\n\\n\\nDone using memoization but giving tle"
                    },
                    {
                        "username": "ag10022101",
                        "content": "this should not exist "
                    },
                    {
                        "username": "MZain",
                        "content": "Easiest problem. It should be ranked as easy."
                    },
                    {
                        "username": "JV_004",
                        "content": "confidence booster , ty !"
                    },
                    {
                        "username": "d3vu",
                        "content": "In the starting I was thinking it must be a variation of knap sack then I realized this is easiest medium."
                    },
                    {
                        "username": "ArunSantharam",
                        "content": "I read the question multiple times to not miss the constraint that makes the question \"medium\"."
                    },
                    {
                        "username": "raghupalash",
                        "content": "Suppose a guy is doing medium leetcode problem for the first time and he stumbles upon this problem - boy is he gonna be on 7th sky to be able to solve a leetcode medium."
                    },
                    {
                        "username": "Kazuma0803",
                        "content": "For those who generally have doubts whether to apply dp or greedy, just see the constraints, if no. of operations with using dp is more than 10^8, try to think of dp."
                    },
                    {
                        "username": "jga111",
                        "content": "I don\\'t understand the distinction between greedy and dp. Normally, DP problems are greedy too. As for this problem, you can solve it in O(n+m) - most will opt for \\'easy\\' O(n log n)"
                    },
                    {
                        "username": "noob_coder_smd",
                        "content": "I am very new in Leetcode and this was my first day coding challenge. Gladly it\\'s an easy one comparatively. I have solved the problem using python3, mostly built in list functions, and thankfully it worked fine in 51/63 testcases. However, it is showing Time Limit Exceeded for the remaining one. Is it a matter of concern or something? Or it\\'s fine? The code is merely 15 lines but still there\\'s runtime issue. Will appreciate advice and suggestions from others. Thanks."
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "I think number of lines in code doesn\\'t affect the runtime issue it is the functions you used, or loops affecting btw I know java so that\\'s all I think"
                    }
                ]
            },
            {
                "id": 1745089,
                "content": [
                    {
                        "username": "kiruba_20-04",
                        "content": "How sort the arrays "
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "using    Arrays.sort( Array Name given);"
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "I think Anyone do it using greedy but the challenge is to use DP to improve your skills and learning. This is not a contest so don\\'t rush. If you think this is not a Challenge  make it challenge."
                    },
                    {
                        "username": "parthkharbanda28",
                        "content": "dp gives tle"
                    },
                    {
                        "username": "likhith1",
                        "content": "class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        \\n        Arrays.sort(costs);\\n        int res=0;\\n        for(int i=0;i<costs.length;i++){\\n            \\n            if(costs[i]<=coins){\\n                coins-=costs[i];\\n                res++;\\n            }else\\n              break;\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditi30ag",
                        "content": "Easy Peasy Medium (dp mat karna bhai, simple sort and +-)\\n`class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        if(costs.size()==0) return 0;\\n        sort(costs.begin(), costs.end()); \\n        int s=0,i;\\n        for(i=0;i<costs.size();i++){\\n            s+=costs[i];\\n            if(s>coins){\\n                break;\\n            }\\n        }\\n        //cout<<s;\\n        return i;\\n    }\\n};`\\n\\ni was wondering how we could do it in complexity lesser than O(nlogn) !!!!\\n"
                    },
                    {
                        "username": "user9177Z",
                        "content": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int sum = costs[0], count = 1;\\n        for(int i = 1; i < costs.size(); i++)\\n        {\\n            if(sum < coins)\\n            {\\n                sum+=costs[i];\\n                count++;\\n            }\\n            else { break; }\\n        }\\n        if(sum > coins) { count -=1; }\\n        else if(sum == costs[0] && costs.size() != 1) { count = 0; }\\n        \\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "user8248Rf",
                        "content": "I have to say that this question should be marked as easy . "
                    },
                    {
                        "username": "rustam_taov",
                        "content": "Why is it the medium task? It\\'s too easy"
                    },
                    {
                        "username": "neopraveen",
                        "content": "How the same solutions shows beats 95% first time but next time it shows beats 23%.  I used to believe their stats haha."
                    },
                    {
                        "username": "ebram96",
                        "content": "This should be changed to Easy level."
                    },
                    {
                        "username": "jhashivam748",
                        "content": " `C++ using 2 Complexity \\n  //tc(nlogn) sc(0(1))\\n        sort(costs.begin(),costs.end()); \\n\\n        int count=0;\\n        int sum=0;\\n        for(auto it:costs){\\n            sum+=it;\\n            if(sum<=coins){\\n                count++;\\n            }\\n            else{\\n                return count;\\n            }\\n        }\\n        return count; \\n//  tc(0(n)) sc(0(n))\\n        int sum=0;\\n        int count=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(auto it:costs){\\n            pq.push(it);\\n        }\\n        while(!pq.empty()){\\n            int x=pq.top();\\n            sum+=x;\\n            if(sum<=coins){\\n                count++;\\n            }\\n            else{\\n                return count;\\n            }\\n            pq.pop();\\n        }\\n        return count;`"
                    }
                ]
            },
            {
                "id": 1745075,
                "content": [
                    {
                        "username": "kiruba_20-04",
                        "content": "How sort the arrays "
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "using    Arrays.sort( Array Name given);"
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "I think Anyone do it using greedy but the challenge is to use DP to improve your skills and learning. This is not a contest so don\\'t rush. If you think this is not a Challenge  make it challenge."
                    },
                    {
                        "username": "parthkharbanda28",
                        "content": "dp gives tle"
                    },
                    {
                        "username": "likhith1",
                        "content": "class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        \\n        Arrays.sort(costs);\\n        int res=0;\\n        for(int i=0;i<costs.length;i++){\\n            \\n            if(costs[i]<=coins){\\n                coins-=costs[i];\\n                res++;\\n            }else\\n              break;\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditi30ag",
                        "content": "Easy Peasy Medium (dp mat karna bhai, simple sort and +-)\\n`class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        if(costs.size()==0) return 0;\\n        sort(costs.begin(), costs.end()); \\n        int s=0,i;\\n        for(i=0;i<costs.size();i++){\\n            s+=costs[i];\\n            if(s>coins){\\n                break;\\n            }\\n        }\\n        //cout<<s;\\n        return i;\\n    }\\n};`\\n\\ni was wondering how we could do it in complexity lesser than O(nlogn) !!!!\\n"
                    },
                    {
                        "username": "user9177Z",
                        "content": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int sum = costs[0], count = 1;\\n        for(int i = 1; i < costs.size(); i++)\\n        {\\n            if(sum < coins)\\n            {\\n                sum+=costs[i];\\n                count++;\\n            }\\n            else { break; }\\n        }\\n        if(sum > coins) { count -=1; }\\n        else if(sum == costs[0] && costs.size() != 1) { count = 0; }\\n        \\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "user8248Rf",
                        "content": "I have to say that this question should be marked as easy . "
                    },
                    {
                        "username": "rustam_taov",
                        "content": "Why is it the medium task? It\\'s too easy"
                    },
                    {
                        "username": "neopraveen",
                        "content": "How the same solutions shows beats 95% first time but next time it shows beats 23%.  I used to believe their stats haha."
                    },
                    {
                        "username": "ebram96",
                        "content": "This should be changed to Easy level."
                    },
                    {
                        "username": "jhashivam748",
                        "content": " `C++ using 2 Complexity \\n  //tc(nlogn) sc(0(1))\\n        sort(costs.begin(),costs.end()); \\n\\n        int count=0;\\n        int sum=0;\\n        for(auto it:costs){\\n            sum+=it;\\n            if(sum<=coins){\\n                count++;\\n            }\\n            else{\\n                return count;\\n            }\\n        }\\n        return count; \\n//  tc(0(n)) sc(0(n))\\n        int sum=0;\\n        int count=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(auto it:costs){\\n            pq.push(it);\\n        }\\n        while(!pq.empty()){\\n            int x=pq.top();\\n            sum+=x;\\n            if(sum<=coins){\\n                count++;\\n            }\\n            else{\\n                return count;\\n            }\\n            pq.pop();\\n        }\\n        return count;`"
                    }
                ]
            },
            {
                "id": 1745039,
                "content": [
                    {
                        "username": "kiruba_20-04",
                        "content": "How sort the arrays "
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "using    Arrays.sort( Array Name given);"
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "I think Anyone do it using greedy but the challenge is to use DP to improve your skills and learning. This is not a contest so don\\'t rush. If you think this is not a Challenge  make it challenge."
                    },
                    {
                        "username": "parthkharbanda28",
                        "content": "dp gives tle"
                    },
                    {
                        "username": "likhith1",
                        "content": "class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        \\n        Arrays.sort(costs);\\n        int res=0;\\n        for(int i=0;i<costs.length;i++){\\n            \\n            if(costs[i]<=coins){\\n                coins-=costs[i];\\n                res++;\\n            }else\\n              break;\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditi30ag",
                        "content": "Easy Peasy Medium (dp mat karna bhai, simple sort and +-)\\n`class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        if(costs.size()==0) return 0;\\n        sort(costs.begin(), costs.end()); \\n        int s=0,i;\\n        for(i=0;i<costs.size();i++){\\n            s+=costs[i];\\n            if(s>coins){\\n                break;\\n            }\\n        }\\n        //cout<<s;\\n        return i;\\n    }\\n};`\\n\\ni was wondering how we could do it in complexity lesser than O(nlogn) !!!!\\n"
                    },
                    {
                        "username": "user9177Z",
                        "content": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int sum = costs[0], count = 1;\\n        for(int i = 1; i < costs.size(); i++)\\n        {\\n            if(sum < coins)\\n            {\\n                sum+=costs[i];\\n                count++;\\n            }\\n            else { break; }\\n        }\\n        if(sum > coins) { count -=1; }\\n        else if(sum == costs[0] && costs.size() != 1) { count = 0; }\\n        \\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "user8248Rf",
                        "content": "I have to say that this question should be marked as easy . "
                    },
                    {
                        "username": "rustam_taov",
                        "content": "Why is it the medium task? It\\'s too easy"
                    },
                    {
                        "username": "neopraveen",
                        "content": "How the same solutions shows beats 95% first time but next time it shows beats 23%.  I used to believe their stats haha."
                    },
                    {
                        "username": "ebram96",
                        "content": "This should be changed to Easy level."
                    },
                    {
                        "username": "jhashivam748",
                        "content": " `C++ using 2 Complexity \\n  //tc(nlogn) sc(0(1))\\n        sort(costs.begin(),costs.end()); \\n\\n        int count=0;\\n        int sum=0;\\n        for(auto it:costs){\\n            sum+=it;\\n            if(sum<=coins){\\n                count++;\\n            }\\n            else{\\n                return count;\\n            }\\n        }\\n        return count; \\n//  tc(0(n)) sc(0(n))\\n        int sum=0;\\n        int count=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(auto it:costs){\\n            pq.push(it);\\n        }\\n        while(!pq.empty()){\\n            int x=pq.top();\\n            sum+=x;\\n            if(sum<=coins){\\n                count++;\\n            }\\n            else{\\n                return count;\\n            }\\n            pq.pop();\\n        }\\n        return count;`"
                    }
                ]
            },
            {
                "id": 1745034,
                "content": [
                    {
                        "username": "kiruba_20-04",
                        "content": "How sort the arrays "
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "using    Arrays.sort( Array Name given);"
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "I think Anyone do it using greedy but the challenge is to use DP to improve your skills and learning. This is not a contest so don\\'t rush. If you think this is not a Challenge  make it challenge."
                    },
                    {
                        "username": "parthkharbanda28",
                        "content": "dp gives tle"
                    },
                    {
                        "username": "likhith1",
                        "content": "class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        \\n        Arrays.sort(costs);\\n        int res=0;\\n        for(int i=0;i<costs.length;i++){\\n            \\n            if(costs[i]<=coins){\\n                coins-=costs[i];\\n                res++;\\n            }else\\n              break;\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditi30ag",
                        "content": "Easy Peasy Medium (dp mat karna bhai, simple sort and +-)\\n`class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        if(costs.size()==0) return 0;\\n        sort(costs.begin(), costs.end()); \\n        int s=0,i;\\n        for(i=0;i<costs.size();i++){\\n            s+=costs[i];\\n            if(s>coins){\\n                break;\\n            }\\n        }\\n        //cout<<s;\\n        return i;\\n    }\\n};`\\n\\ni was wondering how we could do it in complexity lesser than O(nlogn) !!!!\\n"
                    },
                    {
                        "username": "user9177Z",
                        "content": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int sum = costs[0], count = 1;\\n        for(int i = 1; i < costs.size(); i++)\\n        {\\n            if(sum < coins)\\n            {\\n                sum+=costs[i];\\n                count++;\\n            }\\n            else { break; }\\n        }\\n        if(sum > coins) { count -=1; }\\n        else if(sum == costs[0] && costs.size() != 1) { count = 0; }\\n        \\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "user8248Rf",
                        "content": "I have to say that this question should be marked as easy . "
                    },
                    {
                        "username": "rustam_taov",
                        "content": "Why is it the medium task? It\\'s too easy"
                    },
                    {
                        "username": "neopraveen",
                        "content": "How the same solutions shows beats 95% first time but next time it shows beats 23%.  I used to believe their stats haha."
                    },
                    {
                        "username": "ebram96",
                        "content": "This should be changed to Easy level."
                    },
                    {
                        "username": "jhashivam748",
                        "content": " `C++ using 2 Complexity \\n  //tc(nlogn) sc(0(1))\\n        sort(costs.begin(),costs.end()); \\n\\n        int count=0;\\n        int sum=0;\\n        for(auto it:costs){\\n            sum+=it;\\n            if(sum<=coins){\\n                count++;\\n            }\\n            else{\\n                return count;\\n            }\\n        }\\n        return count; \\n//  tc(0(n)) sc(0(n))\\n        int sum=0;\\n        int count=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(auto it:costs){\\n            pq.push(it);\\n        }\\n        while(!pq.empty()){\\n            int x=pq.top();\\n            sum+=x;\\n            if(sum<=coins){\\n                count++;\\n            }\\n            else{\\n                return count;\\n            }\\n            pq.pop();\\n        }\\n        return count;`"
                    }
                ]
            },
            {
                "id": 1744989,
                "content": [
                    {
                        "username": "kiruba_20-04",
                        "content": "How sort the arrays "
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "using    Arrays.sort( Array Name given);"
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "I think Anyone do it using greedy but the challenge is to use DP to improve your skills and learning. This is not a contest so don\\'t rush. If you think this is not a Challenge  make it challenge."
                    },
                    {
                        "username": "parthkharbanda28",
                        "content": "dp gives tle"
                    },
                    {
                        "username": "likhith1",
                        "content": "class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        \\n        Arrays.sort(costs);\\n        int res=0;\\n        for(int i=0;i<costs.length;i++){\\n            \\n            if(costs[i]<=coins){\\n                coins-=costs[i];\\n                res++;\\n            }else\\n              break;\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditi30ag",
                        "content": "Easy Peasy Medium (dp mat karna bhai, simple sort and +-)\\n`class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        if(costs.size()==0) return 0;\\n        sort(costs.begin(), costs.end()); \\n        int s=0,i;\\n        for(i=0;i<costs.size();i++){\\n            s+=costs[i];\\n            if(s>coins){\\n                break;\\n            }\\n        }\\n        //cout<<s;\\n        return i;\\n    }\\n};`\\n\\ni was wondering how we could do it in complexity lesser than O(nlogn) !!!!\\n"
                    },
                    {
                        "username": "user9177Z",
                        "content": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int sum = costs[0], count = 1;\\n        for(int i = 1; i < costs.size(); i++)\\n        {\\n            if(sum < coins)\\n            {\\n                sum+=costs[i];\\n                count++;\\n            }\\n            else { break; }\\n        }\\n        if(sum > coins) { count -=1; }\\n        else if(sum == costs[0] && costs.size() != 1) { count = 0; }\\n        \\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "user8248Rf",
                        "content": "I have to say that this question should be marked as easy . "
                    },
                    {
                        "username": "rustam_taov",
                        "content": "Why is it the medium task? It\\'s too easy"
                    },
                    {
                        "username": "neopraveen",
                        "content": "How the same solutions shows beats 95% first time but next time it shows beats 23%.  I used to believe their stats haha."
                    },
                    {
                        "username": "ebram96",
                        "content": "This should be changed to Easy level."
                    },
                    {
                        "username": "jhashivam748",
                        "content": " `C++ using 2 Complexity \\n  //tc(nlogn) sc(0(1))\\n        sort(costs.begin(),costs.end()); \\n\\n        int count=0;\\n        int sum=0;\\n        for(auto it:costs){\\n            sum+=it;\\n            if(sum<=coins){\\n                count++;\\n            }\\n            else{\\n                return count;\\n            }\\n        }\\n        return count; \\n//  tc(0(n)) sc(0(n))\\n        int sum=0;\\n        int count=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(auto it:costs){\\n            pq.push(it);\\n        }\\n        while(!pq.empty()){\\n            int x=pq.top();\\n            sum+=x;\\n            if(sum<=coins){\\n                count++;\\n            }\\n            else{\\n                return count;\\n            }\\n            pq.pop();\\n        }\\n        return count;`"
                    }
                ]
            },
            {
                "id": 1744975,
                "content": [
                    {
                        "username": "kiruba_20-04",
                        "content": "How sort the arrays "
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "using    Arrays.sort( Array Name given);"
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "I think Anyone do it using greedy but the challenge is to use DP to improve your skills and learning. This is not a contest so don\\'t rush. If you think this is not a Challenge  make it challenge."
                    },
                    {
                        "username": "parthkharbanda28",
                        "content": "dp gives tle"
                    },
                    {
                        "username": "likhith1",
                        "content": "class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        \\n        Arrays.sort(costs);\\n        int res=0;\\n        for(int i=0;i<costs.length;i++){\\n            \\n            if(costs[i]<=coins){\\n                coins-=costs[i];\\n                res++;\\n            }else\\n              break;\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditi30ag",
                        "content": "Easy Peasy Medium (dp mat karna bhai, simple sort and +-)\\n`class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        if(costs.size()==0) return 0;\\n        sort(costs.begin(), costs.end()); \\n        int s=0,i;\\n        for(i=0;i<costs.size();i++){\\n            s+=costs[i];\\n            if(s>coins){\\n                break;\\n            }\\n        }\\n        //cout<<s;\\n        return i;\\n    }\\n};`\\n\\ni was wondering how we could do it in complexity lesser than O(nlogn) !!!!\\n"
                    },
                    {
                        "username": "user9177Z",
                        "content": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int sum = costs[0], count = 1;\\n        for(int i = 1; i < costs.size(); i++)\\n        {\\n            if(sum < coins)\\n            {\\n                sum+=costs[i];\\n                count++;\\n            }\\n            else { break; }\\n        }\\n        if(sum > coins) { count -=1; }\\n        else if(sum == costs[0] && costs.size() != 1) { count = 0; }\\n        \\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "user8248Rf",
                        "content": "I have to say that this question should be marked as easy . "
                    },
                    {
                        "username": "rustam_taov",
                        "content": "Why is it the medium task? It\\'s too easy"
                    },
                    {
                        "username": "neopraveen",
                        "content": "How the same solutions shows beats 95% first time but next time it shows beats 23%.  I used to believe their stats haha."
                    },
                    {
                        "username": "ebram96",
                        "content": "This should be changed to Easy level."
                    },
                    {
                        "username": "jhashivam748",
                        "content": " `C++ using 2 Complexity \\n  //tc(nlogn) sc(0(1))\\n        sort(costs.begin(),costs.end()); \\n\\n        int count=0;\\n        int sum=0;\\n        for(auto it:costs){\\n            sum+=it;\\n            if(sum<=coins){\\n                count++;\\n            }\\n            else{\\n                return count;\\n            }\\n        }\\n        return count; \\n//  tc(0(n)) sc(0(n))\\n        int sum=0;\\n        int count=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(auto it:costs){\\n            pq.push(it);\\n        }\\n        while(!pq.empty()){\\n            int x=pq.top();\\n            sum+=x;\\n            if(sum<=coins){\\n                count++;\\n            }\\n            else{\\n                return count;\\n            }\\n            pq.pop();\\n        }\\n        return count;`"
                    }
                ]
            },
            {
                "id": 1744973,
                "content": [
                    {
                        "username": "kiruba_20-04",
                        "content": "How sort the arrays "
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "using    Arrays.sort( Array Name given);"
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "I think Anyone do it using greedy but the challenge is to use DP to improve your skills and learning. This is not a contest so don\\'t rush. If you think this is not a Challenge  make it challenge."
                    },
                    {
                        "username": "parthkharbanda28",
                        "content": "dp gives tle"
                    },
                    {
                        "username": "likhith1",
                        "content": "class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        \\n        Arrays.sort(costs);\\n        int res=0;\\n        for(int i=0;i<costs.length;i++){\\n            \\n            if(costs[i]<=coins){\\n                coins-=costs[i];\\n                res++;\\n            }else\\n              break;\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditi30ag",
                        "content": "Easy Peasy Medium (dp mat karna bhai, simple sort and +-)\\n`class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        if(costs.size()==0) return 0;\\n        sort(costs.begin(), costs.end()); \\n        int s=0,i;\\n        for(i=0;i<costs.size();i++){\\n            s+=costs[i];\\n            if(s>coins){\\n                break;\\n            }\\n        }\\n        //cout<<s;\\n        return i;\\n    }\\n};`\\n\\ni was wondering how we could do it in complexity lesser than O(nlogn) !!!!\\n"
                    },
                    {
                        "username": "user9177Z",
                        "content": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int sum = costs[0], count = 1;\\n        for(int i = 1; i < costs.size(); i++)\\n        {\\n            if(sum < coins)\\n            {\\n                sum+=costs[i];\\n                count++;\\n            }\\n            else { break; }\\n        }\\n        if(sum > coins) { count -=1; }\\n        else if(sum == costs[0] && costs.size() != 1) { count = 0; }\\n        \\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "user8248Rf",
                        "content": "I have to say that this question should be marked as easy . "
                    },
                    {
                        "username": "rustam_taov",
                        "content": "Why is it the medium task? It\\'s too easy"
                    },
                    {
                        "username": "neopraveen",
                        "content": "How the same solutions shows beats 95% first time but next time it shows beats 23%.  I used to believe their stats haha."
                    },
                    {
                        "username": "ebram96",
                        "content": "This should be changed to Easy level."
                    },
                    {
                        "username": "jhashivam748",
                        "content": " `C++ using 2 Complexity \\n  //tc(nlogn) sc(0(1))\\n        sort(costs.begin(),costs.end()); \\n\\n        int count=0;\\n        int sum=0;\\n        for(auto it:costs){\\n            sum+=it;\\n            if(sum<=coins){\\n                count++;\\n            }\\n            else{\\n                return count;\\n            }\\n        }\\n        return count; \\n//  tc(0(n)) sc(0(n))\\n        int sum=0;\\n        int count=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(auto it:costs){\\n            pq.push(it);\\n        }\\n        while(!pq.empty()){\\n            int x=pq.top();\\n            sum+=x;\\n            if(sum<=coins){\\n                count++;\\n            }\\n            else{\\n                return count;\\n            }\\n            pq.pop();\\n        }\\n        return count;`"
                    }
                ]
            },
            {
                "id": 1744967,
                "content": [
                    {
                        "username": "kiruba_20-04",
                        "content": "How sort the arrays "
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "using    Arrays.sort( Array Name given);"
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "I think Anyone do it using greedy but the challenge is to use DP to improve your skills and learning. This is not a contest so don\\'t rush. If you think this is not a Challenge  make it challenge."
                    },
                    {
                        "username": "parthkharbanda28",
                        "content": "dp gives tle"
                    },
                    {
                        "username": "likhith1",
                        "content": "class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        \\n        Arrays.sort(costs);\\n        int res=0;\\n        for(int i=0;i<costs.length;i++){\\n            \\n            if(costs[i]<=coins){\\n                coins-=costs[i];\\n                res++;\\n            }else\\n              break;\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditi30ag",
                        "content": "Easy Peasy Medium (dp mat karna bhai, simple sort and +-)\\n`class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        if(costs.size()==0) return 0;\\n        sort(costs.begin(), costs.end()); \\n        int s=0,i;\\n        for(i=0;i<costs.size();i++){\\n            s+=costs[i];\\n            if(s>coins){\\n                break;\\n            }\\n        }\\n        //cout<<s;\\n        return i;\\n    }\\n};`\\n\\ni was wondering how we could do it in complexity lesser than O(nlogn) !!!!\\n"
                    },
                    {
                        "username": "user9177Z",
                        "content": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int sum = costs[0], count = 1;\\n        for(int i = 1; i < costs.size(); i++)\\n        {\\n            if(sum < coins)\\n            {\\n                sum+=costs[i];\\n                count++;\\n            }\\n            else { break; }\\n        }\\n        if(sum > coins) { count -=1; }\\n        else if(sum == costs[0] && costs.size() != 1) { count = 0; }\\n        \\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "user8248Rf",
                        "content": "I have to say that this question should be marked as easy . "
                    },
                    {
                        "username": "rustam_taov",
                        "content": "Why is it the medium task? It\\'s too easy"
                    },
                    {
                        "username": "neopraveen",
                        "content": "How the same solutions shows beats 95% first time but next time it shows beats 23%.  I used to believe their stats haha."
                    },
                    {
                        "username": "ebram96",
                        "content": "This should be changed to Easy level."
                    },
                    {
                        "username": "jhashivam748",
                        "content": " `C++ using 2 Complexity \\n  //tc(nlogn) sc(0(1))\\n        sort(costs.begin(),costs.end()); \\n\\n        int count=0;\\n        int sum=0;\\n        for(auto it:costs){\\n            sum+=it;\\n            if(sum<=coins){\\n                count++;\\n            }\\n            else{\\n                return count;\\n            }\\n        }\\n        return count; \\n//  tc(0(n)) sc(0(n))\\n        int sum=0;\\n        int count=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(auto it:costs){\\n            pq.push(it);\\n        }\\n        while(!pq.empty()){\\n            int x=pq.top();\\n            sum+=x;\\n            if(sum<=coins){\\n                count++;\\n            }\\n            else{\\n                return count;\\n            }\\n            pq.pop();\\n        }\\n        return count;`"
                    }
                ]
            },
            {
                "id": 1744962,
                "content": [
                    {
                        "username": "kiruba_20-04",
                        "content": "How sort the arrays "
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "using    Arrays.sort( Array Name given);"
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "I think Anyone do it using greedy but the challenge is to use DP to improve your skills and learning. This is not a contest so don\\'t rush. If you think this is not a Challenge  make it challenge."
                    },
                    {
                        "username": "parthkharbanda28",
                        "content": "dp gives tle"
                    },
                    {
                        "username": "likhith1",
                        "content": "class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        \\n        Arrays.sort(costs);\\n        int res=0;\\n        for(int i=0;i<costs.length;i++){\\n            \\n            if(costs[i]<=coins){\\n                coins-=costs[i];\\n                res++;\\n            }else\\n              break;\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditi30ag",
                        "content": "Easy Peasy Medium (dp mat karna bhai, simple sort and +-)\\n`class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        if(costs.size()==0) return 0;\\n        sort(costs.begin(), costs.end()); \\n        int s=0,i;\\n        for(i=0;i<costs.size();i++){\\n            s+=costs[i];\\n            if(s>coins){\\n                break;\\n            }\\n        }\\n        //cout<<s;\\n        return i;\\n    }\\n};`\\n\\ni was wondering how we could do it in complexity lesser than O(nlogn) !!!!\\n"
                    },
                    {
                        "username": "user9177Z",
                        "content": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int sum = costs[0], count = 1;\\n        for(int i = 1; i < costs.size(); i++)\\n        {\\n            if(sum < coins)\\n            {\\n                sum+=costs[i];\\n                count++;\\n            }\\n            else { break; }\\n        }\\n        if(sum > coins) { count -=1; }\\n        else if(sum == costs[0] && costs.size() != 1) { count = 0; }\\n        \\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "user8248Rf",
                        "content": "I have to say that this question should be marked as easy . "
                    },
                    {
                        "username": "rustam_taov",
                        "content": "Why is it the medium task? It\\'s too easy"
                    },
                    {
                        "username": "neopraveen",
                        "content": "How the same solutions shows beats 95% first time but next time it shows beats 23%.  I used to believe their stats haha."
                    },
                    {
                        "username": "ebram96",
                        "content": "This should be changed to Easy level."
                    },
                    {
                        "username": "jhashivam748",
                        "content": " `C++ using 2 Complexity \\n  //tc(nlogn) sc(0(1))\\n        sort(costs.begin(),costs.end()); \\n\\n        int count=0;\\n        int sum=0;\\n        for(auto it:costs){\\n            sum+=it;\\n            if(sum<=coins){\\n                count++;\\n            }\\n            else{\\n                return count;\\n            }\\n        }\\n        return count; \\n//  tc(0(n)) sc(0(n))\\n        int sum=0;\\n        int count=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(auto it:costs){\\n            pq.push(it);\\n        }\\n        while(!pq.empty()){\\n            int x=pq.top();\\n            sum+=x;\\n            if(sum<=coins){\\n                count++;\\n            }\\n            else{\\n                return count;\\n            }\\n            pq.pop();\\n        }\\n        return count;`"
                    }
                ]
            },
            {
                "id": 1744953,
                "content": [
                    {
                        "username": "kiruba_20-04",
                        "content": "How sort the arrays "
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "using    Arrays.sort( Array Name given);"
                    },
                    {
                        "username": "Manikant_tyagi",
                        "content": "I think Anyone do it using greedy but the challenge is to use DP to improve your skills and learning. This is not a contest so don\\'t rush. If you think this is not a Challenge  make it challenge."
                    },
                    {
                        "username": "parthkharbanda28",
                        "content": "dp gives tle"
                    },
                    {
                        "username": "likhith1",
                        "content": "class Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        \\n        Arrays.sort(costs);\\n        int res=0;\\n        for(int i=0;i<costs.length;i++){\\n            \\n            if(costs[i]<=coins){\\n                coins-=costs[i];\\n                res++;\\n            }else\\n              break;\\n        }\\n        return res;\\n    }\\n}"
                    },
                    {
                        "username": "aditi30ag",
                        "content": "Easy Peasy Medium (dp mat karna bhai, simple sort and +-)\\n`class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        if(costs.size()==0) return 0;\\n        sort(costs.begin(), costs.end()); \\n        int s=0,i;\\n        for(i=0;i<costs.size();i++){\\n            s+=costs[i];\\n            if(s>coins){\\n                break;\\n            }\\n        }\\n        //cout<<s;\\n        return i;\\n    }\\n};`\\n\\ni was wondering how we could do it in complexity lesser than O(nlogn) !!!!\\n"
                    },
                    {
                        "username": "user9177Z",
                        "content": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(),costs.end());\\n        int sum = costs[0], count = 1;\\n        for(int i = 1; i < costs.size(); i++)\\n        {\\n            if(sum < coins)\\n            {\\n                sum+=costs[i];\\n                count++;\\n            }\\n            else { break; }\\n        }\\n        if(sum > coins) { count -=1; }\\n        else if(sum == costs[0] && costs.size() != 1) { count = 0; }\\n        \\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "user8248Rf",
                        "content": "I have to say that this question should be marked as easy . "
                    },
                    {
                        "username": "rustam_taov",
                        "content": "Why is it the medium task? It\\'s too easy"
                    },
                    {
                        "username": "neopraveen",
                        "content": "How the same solutions shows beats 95% first time but next time it shows beats 23%.  I used to believe their stats haha."
                    },
                    {
                        "username": "ebram96",
                        "content": "This should be changed to Easy level."
                    },
                    {
                        "username": "jhashivam748",
                        "content": " `C++ using 2 Complexity \\n  //tc(nlogn) sc(0(1))\\n        sort(costs.begin(),costs.end()); \\n\\n        int count=0;\\n        int sum=0;\\n        for(auto it:costs){\\n            sum+=it;\\n            if(sum<=coins){\\n                count++;\\n            }\\n            else{\\n                return count;\\n            }\\n        }\\n        return count; \\n//  tc(0(n)) sc(0(n))\\n        int sum=0;\\n        int count=0;\\n        priority_queue<int,vector<int>,greater<int>>pq;\\n        for(auto it:costs){\\n            pq.push(it);\\n        }\\n        while(!pq.empty()){\\n            int x=pq.top();\\n            sum+=x;\\n            if(sum<=coins){\\n                count++;\\n            }\\n            else{\\n                return count;\\n            }\\n            pq.pop();\\n        }\\n        return count;`"
                    }
                ]
            },
            {
                "id": 1744941,
                "content": [
                    {
                        "username": "ravish12413",
                        "content": "one of my way is : Firstly we will sort that vector in increasing order. we will use use count a  variable to count the number of ice creams boy bought by subtracting ice cream value from coin. Till coins greater then or equal to value of ice cream"
                    },
                    {
                        "username": "Dudu91",
                        "content": "100% Easy difficulty"
                    },
                    {
                        "username": "kavyamehra",
                        "content": "Can someone tell me why this approach won\\'t work ? This is passing all the given test cases but giving wrong submission.\\nMy approach was to sort the costs[] and find Subarray with given sum equal to coins.\\n\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int count=0, sum=0;\\n        for(int i=0; i<costs.length; i++){\\n            sum+=costs[i];\\n            if(sum<=coins)\\n                count++;\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "kavyamehra",
                        "content": "[@Rishu_Raj_Anand](/Rishu_Raj_Anand) Thank you !\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Hi Kavya!\\nActually you are calculating sum, eventhough the sum>coins.\\nThis will exhaust the Integer bound for large test cases. \\nJust use \\'\\'long\\'\\' for sum and you are done.\\nOr you can decrease the coins untill it becomes less than 0. \\n\\nUpvote if you find helpful :)"
                    },
                    {
                        "username": "willy816yy",
                        "content": "what is the min time complexity for this question and how to do it\\n"
                    },
                    {
                        "username": "user8296H",
                        "content": "Why is this a medium question? \\nvery straightforward..."
                    },
                    {
                        "username": "sardonicankita",
                        "content": "Hello, I was trying to write an approach for time: O(n). I was able to only pass 17 testcases. Can somebody please help me to correct it so it can pass all the test cases?\nThanks in advance!\n\n```\n    int maxIceCream(vector<int>& costs, int coins) {\n        int sum=0, count=0, maxE=INT_MIN;;\n        for(int i=0; i<costs.size(); i++){\n            if(sum+costs[i]<=coins){\n                count++;\n                sum+=costs[i];\n                if(costs[i]>maxE)maxE=costs[i];\n            }else{\n                //sum>coins\n                if(maxE>costs[i]){\n                    sum=sum-maxE+costs[i];\n                    maxE=costs[i];\n                }\n                else{\n                    continue;\n                }                  \n            }\n        }\n        return count;\n    }\n```"
                    },
                    {
                        "username": "ankitraj824209",
                        "content": "class Solution {\\npublic:\\n  int maxIceCream(vector<int>& costs, int coins) {\\n    sort(costs.begin(), costs.end());\\n\\n    int sum = 0;\\n    int count = 0;\\n\\n    for (const auto& cost : costs) {\\n      if (cost <= coins - sum) {\\n        sum += cost;\\n        count++;\\n      } else {\\n        break;\\n      }\\n    }\\n\\n    return count;\\n  }\\n};\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Very similar to [2279. Maximum Bags With Full Capacity of Rocks](https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/), a just little bit easier"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "The easy level medium problem."
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": " `your inline code...\\ncosts = sorted(costs)\\n        sum = 0\\n        m = 0\\n        for ele in costs:\\n            sum += ele\\n            if sum> coins:\\n                break\\n            else:\\n                m += 1\\n        return m\\n\\nyour inline code...`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "For better performance, if left coins is less than price[i], then return ans (no need to check the reste of list)."
                    }
                ]
            },
            {
                "id": 1744935,
                "content": [
                    {
                        "username": "ravish12413",
                        "content": "one of my way is : Firstly we will sort that vector in increasing order. we will use use count a  variable to count the number of ice creams boy bought by subtracting ice cream value from coin. Till coins greater then or equal to value of ice cream"
                    },
                    {
                        "username": "Dudu91",
                        "content": "100% Easy difficulty"
                    },
                    {
                        "username": "kavyamehra",
                        "content": "Can someone tell me why this approach won\\'t work ? This is passing all the given test cases but giving wrong submission.\\nMy approach was to sort the costs[] and find Subarray with given sum equal to coins.\\n\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int count=0, sum=0;\\n        for(int i=0; i<costs.length; i++){\\n            sum+=costs[i];\\n            if(sum<=coins)\\n                count++;\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "kavyamehra",
                        "content": "[@Rishu_Raj_Anand](/Rishu_Raj_Anand) Thank you !\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Hi Kavya!\\nActually you are calculating sum, eventhough the sum>coins.\\nThis will exhaust the Integer bound for large test cases. \\nJust use \\'\\'long\\'\\' for sum and you are done.\\nOr you can decrease the coins untill it becomes less than 0. \\n\\nUpvote if you find helpful :)"
                    },
                    {
                        "username": "willy816yy",
                        "content": "what is the min time complexity for this question and how to do it\\n"
                    },
                    {
                        "username": "user8296H",
                        "content": "Why is this a medium question? \\nvery straightforward..."
                    },
                    {
                        "username": "sardonicankita",
                        "content": "Hello, I was trying to write an approach for time: O(n). I was able to only pass 17 testcases. Can somebody please help me to correct it so it can pass all the test cases?\nThanks in advance!\n\n```\n    int maxIceCream(vector<int>& costs, int coins) {\n        int sum=0, count=0, maxE=INT_MIN;;\n        for(int i=0; i<costs.size(); i++){\n            if(sum+costs[i]<=coins){\n                count++;\n                sum+=costs[i];\n                if(costs[i]>maxE)maxE=costs[i];\n            }else{\n                //sum>coins\n                if(maxE>costs[i]){\n                    sum=sum-maxE+costs[i];\n                    maxE=costs[i];\n                }\n                else{\n                    continue;\n                }                  \n            }\n        }\n        return count;\n    }\n```"
                    },
                    {
                        "username": "ankitraj824209",
                        "content": "class Solution {\\npublic:\\n  int maxIceCream(vector<int>& costs, int coins) {\\n    sort(costs.begin(), costs.end());\\n\\n    int sum = 0;\\n    int count = 0;\\n\\n    for (const auto& cost : costs) {\\n      if (cost <= coins - sum) {\\n        sum += cost;\\n        count++;\\n      } else {\\n        break;\\n      }\\n    }\\n\\n    return count;\\n  }\\n};\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Very similar to [2279. Maximum Bags With Full Capacity of Rocks](https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/), a just little bit easier"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "The easy level medium problem."
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": " `your inline code...\\ncosts = sorted(costs)\\n        sum = 0\\n        m = 0\\n        for ele in costs:\\n            sum += ele\\n            if sum> coins:\\n                break\\n            else:\\n                m += 1\\n        return m\\n\\nyour inline code...`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "For better performance, if left coins is less than price[i], then return ans (no need to check the reste of list)."
                    }
                ]
            },
            {
                "id": 1744909,
                "content": [
                    {
                        "username": "ravish12413",
                        "content": "one of my way is : Firstly we will sort that vector in increasing order. we will use use count a  variable to count the number of ice creams boy bought by subtracting ice cream value from coin. Till coins greater then or equal to value of ice cream"
                    },
                    {
                        "username": "Dudu91",
                        "content": "100% Easy difficulty"
                    },
                    {
                        "username": "kavyamehra",
                        "content": "Can someone tell me why this approach won\\'t work ? This is passing all the given test cases but giving wrong submission.\\nMy approach was to sort the costs[] and find Subarray with given sum equal to coins.\\n\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int count=0, sum=0;\\n        for(int i=0; i<costs.length; i++){\\n            sum+=costs[i];\\n            if(sum<=coins)\\n                count++;\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "kavyamehra",
                        "content": "[@Rishu_Raj_Anand](/Rishu_Raj_Anand) Thank you !\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Hi Kavya!\\nActually you are calculating sum, eventhough the sum>coins.\\nThis will exhaust the Integer bound for large test cases. \\nJust use \\'\\'long\\'\\' for sum and you are done.\\nOr you can decrease the coins untill it becomes less than 0. \\n\\nUpvote if you find helpful :)"
                    },
                    {
                        "username": "willy816yy",
                        "content": "what is the min time complexity for this question and how to do it\\n"
                    },
                    {
                        "username": "user8296H",
                        "content": "Why is this a medium question? \\nvery straightforward..."
                    },
                    {
                        "username": "sardonicankita",
                        "content": "Hello, I was trying to write an approach for time: O(n). I was able to only pass 17 testcases. Can somebody please help me to correct it so it can pass all the test cases?\nThanks in advance!\n\n```\n    int maxIceCream(vector<int>& costs, int coins) {\n        int sum=0, count=0, maxE=INT_MIN;;\n        for(int i=0; i<costs.size(); i++){\n            if(sum+costs[i]<=coins){\n                count++;\n                sum+=costs[i];\n                if(costs[i]>maxE)maxE=costs[i];\n            }else{\n                //sum>coins\n                if(maxE>costs[i]){\n                    sum=sum-maxE+costs[i];\n                    maxE=costs[i];\n                }\n                else{\n                    continue;\n                }                  \n            }\n        }\n        return count;\n    }\n```"
                    },
                    {
                        "username": "ankitraj824209",
                        "content": "class Solution {\\npublic:\\n  int maxIceCream(vector<int>& costs, int coins) {\\n    sort(costs.begin(), costs.end());\\n\\n    int sum = 0;\\n    int count = 0;\\n\\n    for (const auto& cost : costs) {\\n      if (cost <= coins - sum) {\\n        sum += cost;\\n        count++;\\n      } else {\\n        break;\\n      }\\n    }\\n\\n    return count;\\n  }\\n};\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Very similar to [2279. Maximum Bags With Full Capacity of Rocks](https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/), a just little bit easier"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "The easy level medium problem."
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": " `your inline code...\\ncosts = sorted(costs)\\n        sum = 0\\n        m = 0\\n        for ele in costs:\\n            sum += ele\\n            if sum> coins:\\n                break\\n            else:\\n                m += 1\\n        return m\\n\\nyour inline code...`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "For better performance, if left coins is less than price[i], then return ans (no need to check the reste of list)."
                    }
                ]
            },
            {
                "id": 1744908,
                "content": [
                    {
                        "username": "ravish12413",
                        "content": "one of my way is : Firstly we will sort that vector in increasing order. we will use use count a  variable to count the number of ice creams boy bought by subtracting ice cream value from coin. Till coins greater then or equal to value of ice cream"
                    },
                    {
                        "username": "Dudu91",
                        "content": "100% Easy difficulty"
                    },
                    {
                        "username": "kavyamehra",
                        "content": "Can someone tell me why this approach won\\'t work ? This is passing all the given test cases but giving wrong submission.\\nMy approach was to sort the costs[] and find Subarray with given sum equal to coins.\\n\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int count=0, sum=0;\\n        for(int i=0; i<costs.length; i++){\\n            sum+=costs[i];\\n            if(sum<=coins)\\n                count++;\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "kavyamehra",
                        "content": "[@Rishu_Raj_Anand](/Rishu_Raj_Anand) Thank you !\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Hi Kavya!\\nActually you are calculating sum, eventhough the sum>coins.\\nThis will exhaust the Integer bound for large test cases. \\nJust use \\'\\'long\\'\\' for sum and you are done.\\nOr you can decrease the coins untill it becomes less than 0. \\n\\nUpvote if you find helpful :)"
                    },
                    {
                        "username": "willy816yy",
                        "content": "what is the min time complexity for this question and how to do it\\n"
                    },
                    {
                        "username": "user8296H",
                        "content": "Why is this a medium question? \\nvery straightforward..."
                    },
                    {
                        "username": "sardonicankita",
                        "content": "Hello, I was trying to write an approach for time: O(n). I was able to only pass 17 testcases. Can somebody please help me to correct it so it can pass all the test cases?\nThanks in advance!\n\n```\n    int maxIceCream(vector<int>& costs, int coins) {\n        int sum=0, count=0, maxE=INT_MIN;;\n        for(int i=0; i<costs.size(); i++){\n            if(sum+costs[i]<=coins){\n                count++;\n                sum+=costs[i];\n                if(costs[i]>maxE)maxE=costs[i];\n            }else{\n                //sum>coins\n                if(maxE>costs[i]){\n                    sum=sum-maxE+costs[i];\n                    maxE=costs[i];\n                }\n                else{\n                    continue;\n                }                  \n            }\n        }\n        return count;\n    }\n```"
                    },
                    {
                        "username": "ankitraj824209",
                        "content": "class Solution {\\npublic:\\n  int maxIceCream(vector<int>& costs, int coins) {\\n    sort(costs.begin(), costs.end());\\n\\n    int sum = 0;\\n    int count = 0;\\n\\n    for (const auto& cost : costs) {\\n      if (cost <= coins - sum) {\\n        sum += cost;\\n        count++;\\n      } else {\\n        break;\\n      }\\n    }\\n\\n    return count;\\n  }\\n};\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Very similar to [2279. Maximum Bags With Full Capacity of Rocks](https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/), a just little bit easier"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "The easy level medium problem."
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": " `your inline code...\\ncosts = sorted(costs)\\n        sum = 0\\n        m = 0\\n        for ele in costs:\\n            sum += ele\\n            if sum> coins:\\n                break\\n            else:\\n                m += 1\\n        return m\\n\\nyour inline code...`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "For better performance, if left coins is less than price[i], then return ans (no need to check the reste of list)."
                    }
                ]
            },
            {
                "id": 1744885,
                "content": [
                    {
                        "username": "ravish12413",
                        "content": "one of my way is : Firstly we will sort that vector in increasing order. we will use use count a  variable to count the number of ice creams boy bought by subtracting ice cream value from coin. Till coins greater then or equal to value of ice cream"
                    },
                    {
                        "username": "Dudu91",
                        "content": "100% Easy difficulty"
                    },
                    {
                        "username": "kavyamehra",
                        "content": "Can someone tell me why this approach won\\'t work ? This is passing all the given test cases but giving wrong submission.\\nMy approach was to sort the costs[] and find Subarray with given sum equal to coins.\\n\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int count=0, sum=0;\\n        for(int i=0; i<costs.length; i++){\\n            sum+=costs[i];\\n            if(sum<=coins)\\n                count++;\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "kavyamehra",
                        "content": "[@Rishu_Raj_Anand](/Rishu_Raj_Anand) Thank you !\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Hi Kavya!\\nActually you are calculating sum, eventhough the sum>coins.\\nThis will exhaust the Integer bound for large test cases. \\nJust use \\'\\'long\\'\\' for sum and you are done.\\nOr you can decrease the coins untill it becomes less than 0. \\n\\nUpvote if you find helpful :)"
                    },
                    {
                        "username": "willy816yy",
                        "content": "what is the min time complexity for this question and how to do it\\n"
                    },
                    {
                        "username": "user8296H",
                        "content": "Why is this a medium question? \\nvery straightforward..."
                    },
                    {
                        "username": "sardonicankita",
                        "content": "Hello, I was trying to write an approach for time: O(n). I was able to only pass 17 testcases. Can somebody please help me to correct it so it can pass all the test cases?\nThanks in advance!\n\n```\n    int maxIceCream(vector<int>& costs, int coins) {\n        int sum=0, count=0, maxE=INT_MIN;;\n        for(int i=0; i<costs.size(); i++){\n            if(sum+costs[i]<=coins){\n                count++;\n                sum+=costs[i];\n                if(costs[i]>maxE)maxE=costs[i];\n            }else{\n                //sum>coins\n                if(maxE>costs[i]){\n                    sum=sum-maxE+costs[i];\n                    maxE=costs[i];\n                }\n                else{\n                    continue;\n                }                  \n            }\n        }\n        return count;\n    }\n```"
                    },
                    {
                        "username": "ankitraj824209",
                        "content": "class Solution {\\npublic:\\n  int maxIceCream(vector<int>& costs, int coins) {\\n    sort(costs.begin(), costs.end());\\n\\n    int sum = 0;\\n    int count = 0;\\n\\n    for (const auto& cost : costs) {\\n      if (cost <= coins - sum) {\\n        sum += cost;\\n        count++;\\n      } else {\\n        break;\\n      }\\n    }\\n\\n    return count;\\n  }\\n};\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Very similar to [2279. Maximum Bags With Full Capacity of Rocks](https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/), a just little bit easier"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "The easy level medium problem."
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": " `your inline code...\\ncosts = sorted(costs)\\n        sum = 0\\n        m = 0\\n        for ele in costs:\\n            sum += ele\\n            if sum> coins:\\n                break\\n            else:\\n                m += 1\\n        return m\\n\\nyour inline code...`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "For better performance, if left coins is less than price[i], then return ans (no need to check the reste of list)."
                    }
                ]
            },
            {
                "id": 1744870,
                "content": [
                    {
                        "username": "ravish12413",
                        "content": "one of my way is : Firstly we will sort that vector in increasing order. we will use use count a  variable to count the number of ice creams boy bought by subtracting ice cream value from coin. Till coins greater then or equal to value of ice cream"
                    },
                    {
                        "username": "Dudu91",
                        "content": "100% Easy difficulty"
                    },
                    {
                        "username": "kavyamehra",
                        "content": "Can someone tell me why this approach won\\'t work ? This is passing all the given test cases but giving wrong submission.\\nMy approach was to sort the costs[] and find Subarray with given sum equal to coins.\\n\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int count=0, sum=0;\\n        for(int i=0; i<costs.length; i++){\\n            sum+=costs[i];\\n            if(sum<=coins)\\n                count++;\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "kavyamehra",
                        "content": "[@Rishu_Raj_Anand](/Rishu_Raj_Anand) Thank you !\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Hi Kavya!\\nActually you are calculating sum, eventhough the sum>coins.\\nThis will exhaust the Integer bound for large test cases. \\nJust use \\'\\'long\\'\\' for sum and you are done.\\nOr you can decrease the coins untill it becomes less than 0. \\n\\nUpvote if you find helpful :)"
                    },
                    {
                        "username": "willy816yy",
                        "content": "what is the min time complexity for this question and how to do it\\n"
                    },
                    {
                        "username": "user8296H",
                        "content": "Why is this a medium question? \\nvery straightforward..."
                    },
                    {
                        "username": "sardonicankita",
                        "content": "Hello, I was trying to write an approach for time: O(n). I was able to only pass 17 testcases. Can somebody please help me to correct it so it can pass all the test cases?\nThanks in advance!\n\n```\n    int maxIceCream(vector<int>& costs, int coins) {\n        int sum=0, count=0, maxE=INT_MIN;;\n        for(int i=0; i<costs.size(); i++){\n            if(sum+costs[i]<=coins){\n                count++;\n                sum+=costs[i];\n                if(costs[i]>maxE)maxE=costs[i];\n            }else{\n                //sum>coins\n                if(maxE>costs[i]){\n                    sum=sum-maxE+costs[i];\n                    maxE=costs[i];\n                }\n                else{\n                    continue;\n                }                  \n            }\n        }\n        return count;\n    }\n```"
                    },
                    {
                        "username": "ankitraj824209",
                        "content": "class Solution {\\npublic:\\n  int maxIceCream(vector<int>& costs, int coins) {\\n    sort(costs.begin(), costs.end());\\n\\n    int sum = 0;\\n    int count = 0;\\n\\n    for (const auto& cost : costs) {\\n      if (cost <= coins - sum) {\\n        sum += cost;\\n        count++;\\n      } else {\\n        break;\\n      }\\n    }\\n\\n    return count;\\n  }\\n};\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Very similar to [2279. Maximum Bags With Full Capacity of Rocks](https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/), a just little bit easier"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "The easy level medium problem."
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": " `your inline code...\\ncosts = sorted(costs)\\n        sum = 0\\n        m = 0\\n        for ele in costs:\\n            sum += ele\\n            if sum> coins:\\n                break\\n            else:\\n                m += 1\\n        return m\\n\\nyour inline code...`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "For better performance, if left coins is less than price[i], then return ans (no need to check the reste of list)."
                    }
                ]
            },
            {
                "id": 1744853,
                "content": [
                    {
                        "username": "ravish12413",
                        "content": "one of my way is : Firstly we will sort that vector in increasing order. we will use use count a  variable to count the number of ice creams boy bought by subtracting ice cream value from coin. Till coins greater then or equal to value of ice cream"
                    },
                    {
                        "username": "Dudu91",
                        "content": "100% Easy difficulty"
                    },
                    {
                        "username": "kavyamehra",
                        "content": "Can someone tell me why this approach won\\'t work ? This is passing all the given test cases but giving wrong submission.\\nMy approach was to sort the costs[] and find Subarray with given sum equal to coins.\\n\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int count=0, sum=0;\\n        for(int i=0; i<costs.length; i++){\\n            sum+=costs[i];\\n            if(sum<=coins)\\n                count++;\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "kavyamehra",
                        "content": "[@Rishu_Raj_Anand](/Rishu_Raj_Anand) Thank you !\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Hi Kavya!\\nActually you are calculating sum, eventhough the sum>coins.\\nThis will exhaust the Integer bound for large test cases. \\nJust use \\'\\'long\\'\\' for sum and you are done.\\nOr you can decrease the coins untill it becomes less than 0. \\n\\nUpvote if you find helpful :)"
                    },
                    {
                        "username": "willy816yy",
                        "content": "what is the min time complexity for this question and how to do it\\n"
                    },
                    {
                        "username": "user8296H",
                        "content": "Why is this a medium question? \\nvery straightforward..."
                    },
                    {
                        "username": "sardonicankita",
                        "content": "Hello, I was trying to write an approach for time: O(n). I was able to only pass 17 testcases. Can somebody please help me to correct it so it can pass all the test cases?\nThanks in advance!\n\n```\n    int maxIceCream(vector<int>& costs, int coins) {\n        int sum=0, count=0, maxE=INT_MIN;;\n        for(int i=0; i<costs.size(); i++){\n            if(sum+costs[i]<=coins){\n                count++;\n                sum+=costs[i];\n                if(costs[i]>maxE)maxE=costs[i];\n            }else{\n                //sum>coins\n                if(maxE>costs[i]){\n                    sum=sum-maxE+costs[i];\n                    maxE=costs[i];\n                }\n                else{\n                    continue;\n                }                  \n            }\n        }\n        return count;\n    }\n```"
                    },
                    {
                        "username": "ankitraj824209",
                        "content": "class Solution {\\npublic:\\n  int maxIceCream(vector<int>& costs, int coins) {\\n    sort(costs.begin(), costs.end());\\n\\n    int sum = 0;\\n    int count = 0;\\n\\n    for (const auto& cost : costs) {\\n      if (cost <= coins - sum) {\\n        sum += cost;\\n        count++;\\n      } else {\\n        break;\\n      }\\n    }\\n\\n    return count;\\n  }\\n};\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Very similar to [2279. Maximum Bags With Full Capacity of Rocks](https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/), a just little bit easier"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "The easy level medium problem."
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": " `your inline code...\\ncosts = sorted(costs)\\n        sum = 0\\n        m = 0\\n        for ele in costs:\\n            sum += ele\\n            if sum> coins:\\n                break\\n            else:\\n                m += 1\\n        return m\\n\\nyour inline code...`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "For better performance, if left coins is less than price[i], then return ans (no need to check the reste of list)."
                    }
                ]
            },
            {
                "id": 1744847,
                "content": [
                    {
                        "username": "ravish12413",
                        "content": "one of my way is : Firstly we will sort that vector in increasing order. we will use use count a  variable to count the number of ice creams boy bought by subtracting ice cream value from coin. Till coins greater then or equal to value of ice cream"
                    },
                    {
                        "username": "Dudu91",
                        "content": "100% Easy difficulty"
                    },
                    {
                        "username": "kavyamehra",
                        "content": "Can someone tell me why this approach won\\'t work ? This is passing all the given test cases but giving wrong submission.\\nMy approach was to sort the costs[] and find Subarray with given sum equal to coins.\\n\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int count=0, sum=0;\\n        for(int i=0; i<costs.length; i++){\\n            sum+=costs[i];\\n            if(sum<=coins)\\n                count++;\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "kavyamehra",
                        "content": "[@Rishu_Raj_Anand](/Rishu_Raj_Anand) Thank you !\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Hi Kavya!\\nActually you are calculating sum, eventhough the sum>coins.\\nThis will exhaust the Integer bound for large test cases. \\nJust use \\'\\'long\\'\\' for sum and you are done.\\nOr you can decrease the coins untill it becomes less than 0. \\n\\nUpvote if you find helpful :)"
                    },
                    {
                        "username": "willy816yy",
                        "content": "what is the min time complexity for this question and how to do it\\n"
                    },
                    {
                        "username": "user8296H",
                        "content": "Why is this a medium question? \\nvery straightforward..."
                    },
                    {
                        "username": "sardonicankita",
                        "content": "Hello, I was trying to write an approach for time: O(n). I was able to only pass 17 testcases. Can somebody please help me to correct it so it can pass all the test cases?\nThanks in advance!\n\n```\n    int maxIceCream(vector<int>& costs, int coins) {\n        int sum=0, count=0, maxE=INT_MIN;;\n        for(int i=0; i<costs.size(); i++){\n            if(sum+costs[i]<=coins){\n                count++;\n                sum+=costs[i];\n                if(costs[i]>maxE)maxE=costs[i];\n            }else{\n                //sum>coins\n                if(maxE>costs[i]){\n                    sum=sum-maxE+costs[i];\n                    maxE=costs[i];\n                }\n                else{\n                    continue;\n                }                  \n            }\n        }\n        return count;\n    }\n```"
                    },
                    {
                        "username": "ankitraj824209",
                        "content": "class Solution {\\npublic:\\n  int maxIceCream(vector<int>& costs, int coins) {\\n    sort(costs.begin(), costs.end());\\n\\n    int sum = 0;\\n    int count = 0;\\n\\n    for (const auto& cost : costs) {\\n      if (cost <= coins - sum) {\\n        sum += cost;\\n        count++;\\n      } else {\\n        break;\\n      }\\n    }\\n\\n    return count;\\n  }\\n};\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Very similar to [2279. Maximum Bags With Full Capacity of Rocks](https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/), a just little bit easier"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "The easy level medium problem."
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": " `your inline code...\\ncosts = sorted(costs)\\n        sum = 0\\n        m = 0\\n        for ele in costs:\\n            sum += ele\\n            if sum> coins:\\n                break\\n            else:\\n                m += 1\\n        return m\\n\\nyour inline code...`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "For better performance, if left coins is less than price[i], then return ans (no need to check the reste of list)."
                    }
                ]
            },
            {
                "id": 1744844,
                "content": [
                    {
                        "username": "ravish12413",
                        "content": "one of my way is : Firstly we will sort that vector in increasing order. we will use use count a  variable to count the number of ice creams boy bought by subtracting ice cream value from coin. Till coins greater then or equal to value of ice cream"
                    },
                    {
                        "username": "Dudu91",
                        "content": "100% Easy difficulty"
                    },
                    {
                        "username": "kavyamehra",
                        "content": "Can someone tell me why this approach won\\'t work ? This is passing all the given test cases but giving wrong submission.\\nMy approach was to sort the costs[] and find Subarray with given sum equal to coins.\\n\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int count=0, sum=0;\\n        for(int i=0; i<costs.length; i++){\\n            sum+=costs[i];\\n            if(sum<=coins)\\n                count++;\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "kavyamehra",
                        "content": "[@Rishu_Raj_Anand](/Rishu_Raj_Anand) Thank you !\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Hi Kavya!\\nActually you are calculating sum, eventhough the sum>coins.\\nThis will exhaust the Integer bound for large test cases. \\nJust use \\'\\'long\\'\\' for sum and you are done.\\nOr you can decrease the coins untill it becomes less than 0. \\n\\nUpvote if you find helpful :)"
                    },
                    {
                        "username": "willy816yy",
                        "content": "what is the min time complexity for this question and how to do it\\n"
                    },
                    {
                        "username": "user8296H",
                        "content": "Why is this a medium question? \\nvery straightforward..."
                    },
                    {
                        "username": "sardonicankita",
                        "content": "Hello, I was trying to write an approach for time: O(n). I was able to only pass 17 testcases. Can somebody please help me to correct it so it can pass all the test cases?\nThanks in advance!\n\n```\n    int maxIceCream(vector<int>& costs, int coins) {\n        int sum=0, count=0, maxE=INT_MIN;;\n        for(int i=0; i<costs.size(); i++){\n            if(sum+costs[i]<=coins){\n                count++;\n                sum+=costs[i];\n                if(costs[i]>maxE)maxE=costs[i];\n            }else{\n                //sum>coins\n                if(maxE>costs[i]){\n                    sum=sum-maxE+costs[i];\n                    maxE=costs[i];\n                }\n                else{\n                    continue;\n                }                  \n            }\n        }\n        return count;\n    }\n```"
                    },
                    {
                        "username": "ankitraj824209",
                        "content": "class Solution {\\npublic:\\n  int maxIceCream(vector<int>& costs, int coins) {\\n    sort(costs.begin(), costs.end());\\n\\n    int sum = 0;\\n    int count = 0;\\n\\n    for (const auto& cost : costs) {\\n      if (cost <= coins - sum) {\\n        sum += cost;\\n        count++;\\n      } else {\\n        break;\\n      }\\n    }\\n\\n    return count;\\n  }\\n};\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Very similar to [2279. Maximum Bags With Full Capacity of Rocks](https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/), a just little bit easier"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "The easy level medium problem."
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": " `your inline code...\\ncosts = sorted(costs)\\n        sum = 0\\n        m = 0\\n        for ele in costs:\\n            sum += ele\\n            if sum> coins:\\n                break\\n            else:\\n                m += 1\\n        return m\\n\\nyour inline code...`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "For better performance, if left coins is less than price[i], then return ans (no need to check the reste of list)."
                    }
                ]
            },
            {
                "id": 1744808,
                "content": [
                    {
                        "username": "ravish12413",
                        "content": "one of my way is : Firstly we will sort that vector in increasing order. we will use use count a  variable to count the number of ice creams boy bought by subtracting ice cream value from coin. Till coins greater then or equal to value of ice cream"
                    },
                    {
                        "username": "Dudu91",
                        "content": "100% Easy difficulty"
                    },
                    {
                        "username": "kavyamehra",
                        "content": "Can someone tell me why this approach won\\'t work ? This is passing all the given test cases but giving wrong submission.\\nMy approach was to sort the costs[] and find Subarray with given sum equal to coins.\\n\\nclass Solution {\\n    public int maxIceCream(int[] costs, int coins) {\\n        Arrays.sort(costs);\\n        int count=0, sum=0;\\n        for(int i=0; i<costs.length; i++){\\n            sum+=costs[i];\\n            if(sum<=coins)\\n                count++;\\n        }\\n        return count;\\n    }\\n}"
                    },
                    {
                        "username": "kavyamehra",
                        "content": "[@Rishu_Raj_Anand](/Rishu_Raj_Anand) Thank you !\\n"
                    },
                    {
                        "username": "Rishu_Raj_Anand",
                        "content": "Hi Kavya!\\nActually you are calculating sum, eventhough the sum>coins.\\nThis will exhaust the Integer bound for large test cases. \\nJust use \\'\\'long\\'\\' for sum and you are done.\\nOr you can decrease the coins untill it becomes less than 0. \\n\\nUpvote if you find helpful :)"
                    },
                    {
                        "username": "willy816yy",
                        "content": "what is the min time complexity for this question and how to do it\\n"
                    },
                    {
                        "username": "user8296H",
                        "content": "Why is this a medium question? \\nvery straightforward..."
                    },
                    {
                        "username": "sardonicankita",
                        "content": "Hello, I was trying to write an approach for time: O(n). I was able to only pass 17 testcases. Can somebody please help me to correct it so it can pass all the test cases?\nThanks in advance!\n\n```\n    int maxIceCream(vector<int>& costs, int coins) {\n        int sum=0, count=0, maxE=INT_MIN;;\n        for(int i=0; i<costs.size(); i++){\n            if(sum+costs[i]<=coins){\n                count++;\n                sum+=costs[i];\n                if(costs[i]>maxE)maxE=costs[i];\n            }else{\n                //sum>coins\n                if(maxE>costs[i]){\n                    sum=sum-maxE+costs[i];\n                    maxE=costs[i];\n                }\n                else{\n                    continue;\n                }                  \n            }\n        }\n        return count;\n    }\n```"
                    },
                    {
                        "username": "ankitraj824209",
                        "content": "class Solution {\\npublic:\\n  int maxIceCream(vector<int>& costs, int coins) {\\n    sort(costs.begin(), costs.end());\\n\\n    int sum = 0;\\n    int count = 0;\\n\\n    for (const auto& cost : costs) {\\n      if (cost <= coins - sum) {\\n        sum += cost;\\n        count++;\\n      } else {\\n        break;\\n      }\\n    }\\n\\n    return count;\\n  }\\n};\\n"
                    },
                    {
                        "username": "Finesse",
                        "content": "Very similar to [2279. Maximum Bags With Full Capacity of Rocks](https://leetcode.com/problems/maximum-bags-with-full-capacity-of-rocks/), a just little bit easier"
                    },
                    {
                        "username": "Kishan_Kumar_Pandey_2002",
                        "content": "The easy level medium problem."
                    },
                    {
                        "username": "abhishekjkrsna",
                        "content": " `your inline code...\\ncosts = sorted(costs)\\n        sum = 0\\n        m = 0\\n        for ele in costs:\\n            sum += ele\\n            if sum> coins:\\n                break\\n            else:\\n                m += 1\\n        return m\\n\\nyour inline code...`"
                    },
                    {
                        "username": "Yongbi",
                        "content": "For better performance, if left coins is less than price[i], then return ans (no need to check the reste of list)."
                    }
                ]
            },
            {
                "id": 1744806,
                "content": [
                    {
                        "username": "VictorKoch",
                        "content": "Just a small condition, that boy must spend all his coins, would make this problem more challenging."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah! Your intuition on sorting is exactly right."
                    },
                    {
                        "username": "Anish-Karthik",
                        "content": "could anybody explain me how to solve it by DP instead of greedy since all greedy is subset of DP, so DP could solve it right.\\n\\nI know DP is not needed here and it will be much slower, complex and space inefficient, I just need to understand why it is possible or why not?     "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy took just few sec to get the intution and 1 min to code"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Imagine the state of mind of people for whom this becomes the first medium problem on Leetcode  ! \\nBut anyways why is sorting faster than using a prirority queue ? is\\'nt the latter just O(log n) ? "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vedansh Bhardwaj](/vedwaj) logn for one element, then you do that for n times, so it is also n.log(n). Infact using a heap is same as sorting (read Heapsort)"
                    },
                    {
                        "username": "calm27",
                        "content": "I\\'m not sure why people write that sorting approach is greedy. \\nWhat local optimal solution you do here? Check if currentPrice <= ? It is not greedy, just a regular condition. \\nWe can call any if-else statement greedy in such case. \\nExplain, please, if im wrong. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": " [@calm27](/calm27)The official solution itself says it is greedy. Sorting itself is local optimization... we want the smallest values first... not any other value from list globally ... just the smallest value first.. that\\'s why it is greedy. Compare 0/1 knapsack with fractional knapsack problem and you\\'ll ger more clarity."
                    },
                    {
                        "username": "pratikraj001",
                        "content": " This is challenge . if only sort then it is in easy section not in medium.\\nTry............................"
                    },
                    {
                        "username": "jovice786",
                        "content": "Hahahah, leetcode, Hahahaaha"
                    },
                    {
                        "username": "dikshman",
                        "content": "Question is so easy\\nWe have to return the maximum bar of ice-cream that we can buy with given coins. The order of buying bar can be any.\\n\\nFirst things that came to our mind that we have to buy cheapest ice-cream to maximize the bar number.\\nso, sort the costs array in increasing order then A for loop from 0 index to the maximum costs that we can buy.\\nThen return the maximum number of bar."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "I\\'ve spent more time reading the description than solving this \\'medium\\' problem"
                    }
                ]
            },
            {
                "id": 1744802,
                "content": [
                    {
                        "username": "VictorKoch",
                        "content": "Just a small condition, that boy must spend all his coins, would make this problem more challenging."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah! Your intuition on sorting is exactly right."
                    },
                    {
                        "username": "Anish-Karthik",
                        "content": "could anybody explain me how to solve it by DP instead of greedy since all greedy is subset of DP, so DP could solve it right.\\n\\nI know DP is not needed here and it will be much slower, complex and space inefficient, I just need to understand why it is possible or why not?     "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy took just few sec to get the intution and 1 min to code"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Imagine the state of mind of people for whom this becomes the first medium problem on Leetcode  ! \\nBut anyways why is sorting faster than using a prirority queue ? is\\'nt the latter just O(log n) ? "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vedansh Bhardwaj](/vedwaj) logn for one element, then you do that for n times, so it is also n.log(n). Infact using a heap is same as sorting (read Heapsort)"
                    },
                    {
                        "username": "calm27",
                        "content": "I\\'m not sure why people write that sorting approach is greedy. \\nWhat local optimal solution you do here? Check if currentPrice <= ? It is not greedy, just a regular condition. \\nWe can call any if-else statement greedy in such case. \\nExplain, please, if im wrong. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": " [@calm27](/calm27)The official solution itself says it is greedy. Sorting itself is local optimization... we want the smallest values first... not any other value from list globally ... just the smallest value first.. that\\'s why it is greedy. Compare 0/1 knapsack with fractional knapsack problem and you\\'ll ger more clarity."
                    },
                    {
                        "username": "pratikraj001",
                        "content": " This is challenge . if only sort then it is in easy section not in medium.\\nTry............................"
                    },
                    {
                        "username": "jovice786",
                        "content": "Hahahah, leetcode, Hahahaaha"
                    },
                    {
                        "username": "dikshman",
                        "content": "Question is so easy\\nWe have to return the maximum bar of ice-cream that we can buy with given coins. The order of buying bar can be any.\\n\\nFirst things that came to our mind that we have to buy cheapest ice-cream to maximize the bar number.\\nso, sort the costs array in increasing order then A for loop from 0 index to the maximum costs that we can buy.\\nThen return the maximum number of bar."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "I\\'ve spent more time reading the description than solving this \\'medium\\' problem"
                    }
                ]
            },
            {
                "id": 1744782,
                "content": [
                    {
                        "username": "VictorKoch",
                        "content": "Just a small condition, that boy must spend all his coins, would make this problem more challenging."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah! Your intuition on sorting is exactly right."
                    },
                    {
                        "username": "Anish-Karthik",
                        "content": "could anybody explain me how to solve it by DP instead of greedy since all greedy is subset of DP, so DP could solve it right.\\n\\nI know DP is not needed here and it will be much slower, complex and space inefficient, I just need to understand why it is possible or why not?     "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy took just few sec to get the intution and 1 min to code"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Imagine the state of mind of people for whom this becomes the first medium problem on Leetcode  ! \\nBut anyways why is sorting faster than using a prirority queue ? is\\'nt the latter just O(log n) ? "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vedansh Bhardwaj](/vedwaj) logn for one element, then you do that for n times, so it is also n.log(n). Infact using a heap is same as sorting (read Heapsort)"
                    },
                    {
                        "username": "calm27",
                        "content": "I\\'m not sure why people write that sorting approach is greedy. \\nWhat local optimal solution you do here? Check if currentPrice <= ? It is not greedy, just a regular condition. \\nWe can call any if-else statement greedy in such case. \\nExplain, please, if im wrong. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": " [@calm27](/calm27)The official solution itself says it is greedy. Sorting itself is local optimization... we want the smallest values first... not any other value from list globally ... just the smallest value first.. that\\'s why it is greedy. Compare 0/1 knapsack with fractional knapsack problem and you\\'ll ger more clarity."
                    },
                    {
                        "username": "pratikraj001",
                        "content": " This is challenge . if only sort then it is in easy section not in medium.\\nTry............................"
                    },
                    {
                        "username": "jovice786",
                        "content": "Hahahah, leetcode, Hahahaaha"
                    },
                    {
                        "username": "dikshman",
                        "content": "Question is so easy\\nWe have to return the maximum bar of ice-cream that we can buy with given coins. The order of buying bar can be any.\\n\\nFirst things that came to our mind that we have to buy cheapest ice-cream to maximize the bar number.\\nso, sort the costs array in increasing order then A for loop from 0 index to the maximum costs that we can buy.\\nThen return the maximum number of bar."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "I\\'ve spent more time reading the description than solving this \\'medium\\' problem"
                    }
                ]
            },
            {
                "id": 1744731,
                "content": [
                    {
                        "username": "VictorKoch",
                        "content": "Just a small condition, that boy must spend all his coins, would make this problem more challenging."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah! Your intuition on sorting is exactly right."
                    },
                    {
                        "username": "Anish-Karthik",
                        "content": "could anybody explain me how to solve it by DP instead of greedy since all greedy is subset of DP, so DP could solve it right.\\n\\nI know DP is not needed here and it will be much slower, complex and space inefficient, I just need to understand why it is possible or why not?     "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy took just few sec to get the intution and 1 min to code"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Imagine the state of mind of people for whom this becomes the first medium problem on Leetcode  ! \\nBut anyways why is sorting faster than using a prirority queue ? is\\'nt the latter just O(log n) ? "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vedansh Bhardwaj](/vedwaj) logn for one element, then you do that for n times, so it is also n.log(n). Infact using a heap is same as sorting (read Heapsort)"
                    },
                    {
                        "username": "calm27",
                        "content": "I\\'m not sure why people write that sorting approach is greedy. \\nWhat local optimal solution you do here? Check if currentPrice <= ? It is not greedy, just a regular condition. \\nWe can call any if-else statement greedy in such case. \\nExplain, please, if im wrong. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": " [@calm27](/calm27)The official solution itself says it is greedy. Sorting itself is local optimization... we want the smallest values first... not any other value from list globally ... just the smallest value first.. that\\'s why it is greedy. Compare 0/1 knapsack with fractional knapsack problem and you\\'ll ger more clarity."
                    },
                    {
                        "username": "pratikraj001",
                        "content": " This is challenge . if only sort then it is in easy section not in medium.\\nTry............................"
                    },
                    {
                        "username": "jovice786",
                        "content": "Hahahah, leetcode, Hahahaaha"
                    },
                    {
                        "username": "dikshman",
                        "content": "Question is so easy\\nWe have to return the maximum bar of ice-cream that we can buy with given coins. The order of buying bar can be any.\\n\\nFirst things that came to our mind that we have to buy cheapest ice-cream to maximize the bar number.\\nso, sort the costs array in increasing order then A for loop from 0 index to the maximum costs that we can buy.\\nThen return the maximum number of bar."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "I\\'ve spent more time reading the description than solving this \\'medium\\' problem"
                    }
                ]
            },
            {
                "id": 1744714,
                "content": [
                    {
                        "username": "VictorKoch",
                        "content": "Just a small condition, that boy must spend all his coins, would make this problem more challenging."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah! Your intuition on sorting is exactly right."
                    },
                    {
                        "username": "Anish-Karthik",
                        "content": "could anybody explain me how to solve it by DP instead of greedy since all greedy is subset of DP, so DP could solve it right.\\n\\nI know DP is not needed here and it will be much slower, complex and space inefficient, I just need to understand why it is possible or why not?     "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy took just few sec to get the intution and 1 min to code"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Imagine the state of mind of people for whom this becomes the first medium problem on Leetcode  ! \\nBut anyways why is sorting faster than using a prirority queue ? is\\'nt the latter just O(log n) ? "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vedansh Bhardwaj](/vedwaj) logn for one element, then you do that for n times, so it is also n.log(n). Infact using a heap is same as sorting (read Heapsort)"
                    },
                    {
                        "username": "calm27",
                        "content": "I\\'m not sure why people write that sorting approach is greedy. \\nWhat local optimal solution you do here? Check if currentPrice <= ? It is not greedy, just a regular condition. \\nWe can call any if-else statement greedy in such case. \\nExplain, please, if im wrong. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": " [@calm27](/calm27)The official solution itself says it is greedy. Sorting itself is local optimization... we want the smallest values first... not any other value from list globally ... just the smallest value first.. that\\'s why it is greedy. Compare 0/1 knapsack with fractional knapsack problem and you\\'ll ger more clarity."
                    },
                    {
                        "username": "pratikraj001",
                        "content": " This is challenge . if only sort then it is in easy section not in medium.\\nTry............................"
                    },
                    {
                        "username": "jovice786",
                        "content": "Hahahah, leetcode, Hahahaaha"
                    },
                    {
                        "username": "dikshman",
                        "content": "Question is so easy\\nWe have to return the maximum bar of ice-cream that we can buy with given coins. The order of buying bar can be any.\\n\\nFirst things that came to our mind that we have to buy cheapest ice-cream to maximize the bar number.\\nso, sort the costs array in increasing order then A for loop from 0 index to the maximum costs that we can buy.\\nThen return the maximum number of bar."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "I\\'ve spent more time reading the description than solving this \\'medium\\' problem"
                    }
                ]
            },
            {
                "id": 1744682,
                "content": [
                    {
                        "username": "VictorKoch",
                        "content": "Just a small condition, that boy must spend all his coins, would make this problem more challenging."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah! Your intuition on sorting is exactly right."
                    },
                    {
                        "username": "Anish-Karthik",
                        "content": "could anybody explain me how to solve it by DP instead of greedy since all greedy is subset of DP, so DP could solve it right.\\n\\nI know DP is not needed here and it will be much slower, complex and space inefficient, I just need to understand why it is possible or why not?     "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy took just few sec to get the intution and 1 min to code"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Imagine the state of mind of people for whom this becomes the first medium problem on Leetcode  ! \\nBut anyways why is sorting faster than using a prirority queue ? is\\'nt the latter just O(log n) ? "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vedansh Bhardwaj](/vedwaj) logn for one element, then you do that for n times, so it is also n.log(n). Infact using a heap is same as sorting (read Heapsort)"
                    },
                    {
                        "username": "calm27",
                        "content": "I\\'m not sure why people write that sorting approach is greedy. \\nWhat local optimal solution you do here? Check if currentPrice <= ? It is not greedy, just a regular condition. \\nWe can call any if-else statement greedy in such case. \\nExplain, please, if im wrong. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": " [@calm27](/calm27)The official solution itself says it is greedy. Sorting itself is local optimization... we want the smallest values first... not any other value from list globally ... just the smallest value first.. that\\'s why it is greedy. Compare 0/1 knapsack with fractional knapsack problem and you\\'ll ger more clarity."
                    },
                    {
                        "username": "pratikraj001",
                        "content": " This is challenge . if only sort then it is in easy section not in medium.\\nTry............................"
                    },
                    {
                        "username": "jovice786",
                        "content": "Hahahah, leetcode, Hahahaaha"
                    },
                    {
                        "username": "dikshman",
                        "content": "Question is so easy\\nWe have to return the maximum bar of ice-cream that we can buy with given coins. The order of buying bar can be any.\\n\\nFirst things that came to our mind that we have to buy cheapest ice-cream to maximize the bar number.\\nso, sort the costs array in increasing order then A for loop from 0 index to the maximum costs that we can buy.\\nThen return the maximum number of bar."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "I\\'ve spent more time reading the description than solving this \\'medium\\' problem"
                    }
                ]
            },
            {
                "id": 1744668,
                "content": [
                    {
                        "username": "VictorKoch",
                        "content": "Just a small condition, that boy must spend all his coins, would make this problem more challenging."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah! Your intuition on sorting is exactly right."
                    },
                    {
                        "username": "Anish-Karthik",
                        "content": "could anybody explain me how to solve it by DP instead of greedy since all greedy is subset of DP, so DP could solve it right.\\n\\nI know DP is not needed here and it will be much slower, complex and space inefficient, I just need to understand why it is possible or why not?     "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy took just few sec to get the intution and 1 min to code"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Imagine the state of mind of people for whom this becomes the first medium problem on Leetcode  ! \\nBut anyways why is sorting faster than using a prirority queue ? is\\'nt the latter just O(log n) ? "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vedansh Bhardwaj](/vedwaj) logn for one element, then you do that for n times, so it is also n.log(n). Infact using a heap is same as sorting (read Heapsort)"
                    },
                    {
                        "username": "calm27",
                        "content": "I\\'m not sure why people write that sorting approach is greedy. \\nWhat local optimal solution you do here? Check if currentPrice <= ? It is not greedy, just a regular condition. \\nWe can call any if-else statement greedy in such case. \\nExplain, please, if im wrong. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": " [@calm27](/calm27)The official solution itself says it is greedy. Sorting itself is local optimization... we want the smallest values first... not any other value from list globally ... just the smallest value first.. that\\'s why it is greedy. Compare 0/1 knapsack with fractional knapsack problem and you\\'ll ger more clarity."
                    },
                    {
                        "username": "pratikraj001",
                        "content": " This is challenge . if only sort then it is in easy section not in medium.\\nTry............................"
                    },
                    {
                        "username": "jovice786",
                        "content": "Hahahah, leetcode, Hahahaaha"
                    },
                    {
                        "username": "dikshman",
                        "content": "Question is so easy\\nWe have to return the maximum bar of ice-cream that we can buy with given coins. The order of buying bar can be any.\\n\\nFirst things that came to our mind that we have to buy cheapest ice-cream to maximize the bar number.\\nso, sort the costs array in increasing order then A for loop from 0 index to the maximum costs that we can buy.\\nThen return the maximum number of bar."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "I\\'ve spent more time reading the description than solving this \\'medium\\' problem"
                    }
                ]
            },
            {
                "id": 1744665,
                "content": [
                    {
                        "username": "VictorKoch",
                        "content": "Just a small condition, that boy must spend all his coins, would make this problem more challenging."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah! Your intuition on sorting is exactly right."
                    },
                    {
                        "username": "Anish-Karthik",
                        "content": "could anybody explain me how to solve it by DP instead of greedy since all greedy is subset of DP, so DP could solve it right.\\n\\nI know DP is not needed here and it will be much slower, complex and space inefficient, I just need to understand why it is possible or why not?     "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy took just few sec to get the intution and 1 min to code"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Imagine the state of mind of people for whom this becomes the first medium problem on Leetcode  ! \\nBut anyways why is sorting faster than using a prirority queue ? is\\'nt the latter just O(log n) ? "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vedansh Bhardwaj](/vedwaj) logn for one element, then you do that for n times, so it is also n.log(n). Infact using a heap is same as sorting (read Heapsort)"
                    },
                    {
                        "username": "calm27",
                        "content": "I\\'m not sure why people write that sorting approach is greedy. \\nWhat local optimal solution you do here? Check if currentPrice <= ? It is not greedy, just a regular condition. \\nWe can call any if-else statement greedy in such case. \\nExplain, please, if im wrong. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": " [@calm27](/calm27)The official solution itself says it is greedy. Sorting itself is local optimization... we want the smallest values first... not any other value from list globally ... just the smallest value first.. that\\'s why it is greedy. Compare 0/1 knapsack with fractional knapsack problem and you\\'ll ger more clarity."
                    },
                    {
                        "username": "pratikraj001",
                        "content": " This is challenge . if only sort then it is in easy section not in medium.\\nTry............................"
                    },
                    {
                        "username": "jovice786",
                        "content": "Hahahah, leetcode, Hahahaaha"
                    },
                    {
                        "username": "dikshman",
                        "content": "Question is so easy\\nWe have to return the maximum bar of ice-cream that we can buy with given coins. The order of buying bar can be any.\\n\\nFirst things that came to our mind that we have to buy cheapest ice-cream to maximize the bar number.\\nso, sort the costs array in increasing order then A for loop from 0 index to the maximum costs that we can buy.\\nThen return the maximum number of bar."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "I\\'ve spent more time reading the description than solving this \\'medium\\' problem"
                    }
                ]
            },
            {
                "id": 1744646,
                "content": [
                    {
                        "username": "VictorKoch",
                        "content": "Just a small condition, that boy must spend all his coins, would make this problem more challenging."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah! Your intuition on sorting is exactly right."
                    },
                    {
                        "username": "Anish-Karthik",
                        "content": "could anybody explain me how to solve it by DP instead of greedy since all greedy is subset of DP, so DP could solve it right.\\n\\nI know DP is not needed here and it will be much slower, complex and space inefficient, I just need to understand why it is possible or why not?     "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy took just few sec to get the intution and 1 min to code"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Imagine the state of mind of people for whom this becomes the first medium problem on Leetcode  ! \\nBut anyways why is sorting faster than using a prirority queue ? is\\'nt the latter just O(log n) ? "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vedansh Bhardwaj](/vedwaj) logn for one element, then you do that for n times, so it is also n.log(n). Infact using a heap is same as sorting (read Heapsort)"
                    },
                    {
                        "username": "calm27",
                        "content": "I\\'m not sure why people write that sorting approach is greedy. \\nWhat local optimal solution you do here? Check if currentPrice <= ? It is not greedy, just a regular condition. \\nWe can call any if-else statement greedy in such case. \\nExplain, please, if im wrong. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": " [@calm27](/calm27)The official solution itself says it is greedy. Sorting itself is local optimization... we want the smallest values first... not any other value from list globally ... just the smallest value first.. that\\'s why it is greedy. Compare 0/1 knapsack with fractional knapsack problem and you\\'ll ger more clarity."
                    },
                    {
                        "username": "pratikraj001",
                        "content": " This is challenge . if only sort then it is in easy section not in medium.\\nTry............................"
                    },
                    {
                        "username": "jovice786",
                        "content": "Hahahah, leetcode, Hahahaaha"
                    },
                    {
                        "username": "dikshman",
                        "content": "Question is so easy\\nWe have to return the maximum bar of ice-cream that we can buy with given coins. The order of buying bar can be any.\\n\\nFirst things that came to our mind that we have to buy cheapest ice-cream to maximize the bar number.\\nso, sort the costs array in increasing order then A for loop from 0 index to the maximum costs that we can buy.\\nThen return the maximum number of bar."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "I\\'ve spent more time reading the description than solving this \\'medium\\' problem"
                    }
                ]
            },
            {
                "id": 1744639,
                "content": [
                    {
                        "username": "VictorKoch",
                        "content": "Just a small condition, that boy must spend all his coins, would make this problem more challenging."
                    },
                    {
                        "username": "santanusen",
                        "content": "Yeah! Your intuition on sorting is exactly right."
                    },
                    {
                        "username": "Anish-Karthik",
                        "content": "could anybody explain me how to solve it by DP instead of greedy since all greedy is subset of DP, so DP could solve it right.\\n\\nI know DP is not needed here and it will be much slower, complex and space inefficient, I just need to understand why it is possible or why not?     "
                    },
                    {
                        "username": "abhi_shek123",
                        "content": "very easy took just few sec to get the intution and 1 min to code"
                    },
                    {
                        "username": "vedwaj",
                        "content": "Imagine the state of mind of people for whom this becomes the first medium problem on Leetcode  ! \\nBut anyways why is sorting faster than using a prirority queue ? is\\'nt the latter just O(log n) ? "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Vedansh Bhardwaj](/vedwaj) logn for one element, then you do that for n times, so it is also n.log(n). Infact using a heap is same as sorting (read Heapsort)"
                    },
                    {
                        "username": "calm27",
                        "content": "I\\'m not sure why people write that sorting approach is greedy. \\nWhat local optimal solution you do here? Check if currentPrice <= ? It is not greedy, just a regular condition. \\nWe can call any if-else statement greedy in such case. \\nExplain, please, if im wrong. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": " [@calm27](/calm27)The official solution itself says it is greedy. Sorting itself is local optimization... we want the smallest values first... not any other value from list globally ... just the smallest value first.. that\\'s why it is greedy. Compare 0/1 knapsack with fractional knapsack problem and you\\'ll ger more clarity."
                    },
                    {
                        "username": "pratikraj001",
                        "content": " This is challenge . if only sort then it is in easy section not in medium.\\nTry............................"
                    },
                    {
                        "username": "jovice786",
                        "content": "Hahahah, leetcode, Hahahaaha"
                    },
                    {
                        "username": "dikshman",
                        "content": "Question is so easy\\nWe have to return the maximum bar of ice-cream that we can buy with given coins. The order of buying bar can be any.\\n\\nFirst things that came to our mind that we have to buy cheapest ice-cream to maximize the bar number.\\nso, sort the costs array in increasing order then A for loop from 0 index to the maximum costs that we can buy.\\nThen return the maximum number of bar."
                    },
                    {
                        "username": "cherkezovr",
                        "content": "I\\'ve spent more time reading the description than solving this \\'medium\\' problem"
                    }
                ]
            },
            {
                "id": 1744636,
                "content": [
                    {
                        "username": "Dhananjay40",
                        "content": "Okay! this is the fastest  medium problem I have ever solved. Give me the ice-cream"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "# Should be an easy difficulty for this problem\\n"
                    },
                    {
                        "username": "program22b",
                        "content": "is there a way to solve it even faster that O(n log n)?"
                    },
                    {
                        "username": "program22b",
                        "content": "[@sharma842nikhil](/sharma842nikhil) i think the count sort will be O(n+k) because we\\'re iterating through the array of frequencies to sort the original one"
                    },
                    {
                        "username": "program22b",
                        "content": "[@sarpalmadhav](/sarpalmadhav) i\\'m not a premium user to see it. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ahmed Mustafa](/program22b) always read official solution after submitting, It has something extra most of the times. There you will find O(n) way for this problem."
                    },
                    {
                        "username": "sharma842nikhil",
                        "content": "yes, you can use Counting sort instead of quick and you\\'ll get your result in O(N) "
                    },
                    {
                        "username": "ak503005",
                        "content": "Dedication and hardwork pays off\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode wanted to promote good habits so replaced thief stealing things in 0/1 knapsack to boy purchasing ice cream from his own hard earned money!! \\uD83D\\uDE0D \\uD83D\\uDE0D"
                    },
                    {
                        "username": "Umair9912",
                        "content": "The violations this problem is receiving is definitely not easy  xD"
                    },
                    {
                        "username": "0icy",
                        "content": "Even my unborn son would have solved this in a minute"
                    },
                    {
                        "username": "taj_1",
                        "content": "I think this problem should be in easy category..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Don\\'t confuse us by tagging easy problem as medium -_-"
                    },
                    {
                        "username": "native_element",
                        "content": "can you elaborate when i use dp or Greedy. A bit confusing."
                    }
                ]
            },
            {
                "id": 1744621,
                "content": [
                    {
                        "username": "Dhananjay40",
                        "content": "Okay! this is the fastest  medium problem I have ever solved. Give me the ice-cream"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "# Should be an easy difficulty for this problem\\n"
                    },
                    {
                        "username": "program22b",
                        "content": "is there a way to solve it even faster that O(n log n)?"
                    },
                    {
                        "username": "program22b",
                        "content": "[@sharma842nikhil](/sharma842nikhil) i think the count sort will be O(n+k) because we\\'re iterating through the array of frequencies to sort the original one"
                    },
                    {
                        "username": "program22b",
                        "content": "[@sarpalmadhav](/sarpalmadhav) i\\'m not a premium user to see it. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ahmed Mustafa](/program22b) always read official solution after submitting, It has something extra most of the times. There you will find O(n) way for this problem."
                    },
                    {
                        "username": "sharma842nikhil",
                        "content": "yes, you can use Counting sort instead of quick and you\\'ll get your result in O(N) "
                    },
                    {
                        "username": "ak503005",
                        "content": "Dedication and hardwork pays off\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode wanted to promote good habits so replaced thief stealing things in 0/1 knapsack to boy purchasing ice cream from his own hard earned money!! \\uD83D\\uDE0D \\uD83D\\uDE0D"
                    },
                    {
                        "username": "Umair9912",
                        "content": "The violations this problem is receiving is definitely not easy  xD"
                    },
                    {
                        "username": "0icy",
                        "content": "Even my unborn son would have solved this in a minute"
                    },
                    {
                        "username": "taj_1",
                        "content": "I think this problem should be in easy category..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Don\\'t confuse us by tagging easy problem as medium -_-"
                    },
                    {
                        "username": "native_element",
                        "content": "can you elaborate when i use dp or Greedy. A bit confusing."
                    }
                ]
            },
            {
                "id": 1744611,
                "content": [
                    {
                        "username": "Dhananjay40",
                        "content": "Okay! this is the fastest  medium problem I have ever solved. Give me the ice-cream"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "# Should be an easy difficulty for this problem\\n"
                    },
                    {
                        "username": "program22b",
                        "content": "is there a way to solve it even faster that O(n log n)?"
                    },
                    {
                        "username": "program22b",
                        "content": "[@sharma842nikhil](/sharma842nikhil) i think the count sort will be O(n+k) because we\\'re iterating through the array of frequencies to sort the original one"
                    },
                    {
                        "username": "program22b",
                        "content": "[@sarpalmadhav](/sarpalmadhav) i\\'m not a premium user to see it. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ahmed Mustafa](/program22b) always read official solution after submitting, It has something extra most of the times. There you will find O(n) way for this problem."
                    },
                    {
                        "username": "sharma842nikhil",
                        "content": "yes, you can use Counting sort instead of quick and you\\'ll get your result in O(N) "
                    },
                    {
                        "username": "ak503005",
                        "content": "Dedication and hardwork pays off\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode wanted to promote good habits so replaced thief stealing things in 0/1 knapsack to boy purchasing ice cream from his own hard earned money!! \\uD83D\\uDE0D \\uD83D\\uDE0D"
                    },
                    {
                        "username": "Umair9912",
                        "content": "The violations this problem is receiving is definitely not easy  xD"
                    },
                    {
                        "username": "0icy",
                        "content": "Even my unborn son would have solved this in a minute"
                    },
                    {
                        "username": "taj_1",
                        "content": "I think this problem should be in easy category..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Don\\'t confuse us by tagging easy problem as medium -_-"
                    },
                    {
                        "username": "native_element",
                        "content": "can you elaborate when i use dp or Greedy. A bit confusing."
                    }
                ]
            },
            {
                "id": 1744596,
                "content": [
                    {
                        "username": "Dhananjay40",
                        "content": "Okay! this is the fastest  medium problem I have ever solved. Give me the ice-cream"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "# Should be an easy difficulty for this problem\\n"
                    },
                    {
                        "username": "program22b",
                        "content": "is there a way to solve it even faster that O(n log n)?"
                    },
                    {
                        "username": "program22b",
                        "content": "[@sharma842nikhil](/sharma842nikhil) i think the count sort will be O(n+k) because we\\'re iterating through the array of frequencies to sort the original one"
                    },
                    {
                        "username": "program22b",
                        "content": "[@sarpalmadhav](/sarpalmadhav) i\\'m not a premium user to see it. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ahmed Mustafa](/program22b) always read official solution after submitting, It has something extra most of the times. There you will find O(n) way for this problem."
                    },
                    {
                        "username": "sharma842nikhil",
                        "content": "yes, you can use Counting sort instead of quick and you\\'ll get your result in O(N) "
                    },
                    {
                        "username": "ak503005",
                        "content": "Dedication and hardwork pays off\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode wanted to promote good habits so replaced thief stealing things in 0/1 knapsack to boy purchasing ice cream from his own hard earned money!! \\uD83D\\uDE0D \\uD83D\\uDE0D"
                    },
                    {
                        "username": "Umair9912",
                        "content": "The violations this problem is receiving is definitely not easy  xD"
                    },
                    {
                        "username": "0icy",
                        "content": "Even my unborn son would have solved this in a minute"
                    },
                    {
                        "username": "taj_1",
                        "content": "I think this problem should be in easy category..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Don\\'t confuse us by tagging easy problem as medium -_-"
                    },
                    {
                        "username": "native_element",
                        "content": "can you elaborate when i use dp or Greedy. A bit confusing."
                    }
                ]
            },
            {
                "id": 1744582,
                "content": [
                    {
                        "username": "Dhananjay40",
                        "content": "Okay! this is the fastest  medium problem I have ever solved. Give me the ice-cream"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "# Should be an easy difficulty for this problem\\n"
                    },
                    {
                        "username": "program22b",
                        "content": "is there a way to solve it even faster that O(n log n)?"
                    },
                    {
                        "username": "program22b",
                        "content": "[@sharma842nikhil](/sharma842nikhil) i think the count sort will be O(n+k) because we\\'re iterating through the array of frequencies to sort the original one"
                    },
                    {
                        "username": "program22b",
                        "content": "[@sarpalmadhav](/sarpalmadhav) i\\'m not a premium user to see it. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ahmed Mustafa](/program22b) always read official solution after submitting, It has something extra most of the times. There you will find O(n) way for this problem."
                    },
                    {
                        "username": "sharma842nikhil",
                        "content": "yes, you can use Counting sort instead of quick and you\\'ll get your result in O(N) "
                    },
                    {
                        "username": "ak503005",
                        "content": "Dedication and hardwork pays off\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode wanted to promote good habits so replaced thief stealing things in 0/1 knapsack to boy purchasing ice cream from his own hard earned money!! \\uD83D\\uDE0D \\uD83D\\uDE0D"
                    },
                    {
                        "username": "Umair9912",
                        "content": "The violations this problem is receiving is definitely not easy  xD"
                    },
                    {
                        "username": "0icy",
                        "content": "Even my unborn son would have solved this in a minute"
                    },
                    {
                        "username": "taj_1",
                        "content": "I think this problem should be in easy category..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Don\\'t confuse us by tagging easy problem as medium -_-"
                    },
                    {
                        "username": "native_element",
                        "content": "can you elaborate when i use dp or Greedy. A bit confusing."
                    }
                ]
            },
            {
                "id": 1744580,
                "content": [
                    {
                        "username": "Dhananjay40",
                        "content": "Okay! this is the fastest  medium problem I have ever solved. Give me the ice-cream"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "# Should be an easy difficulty for this problem\\n"
                    },
                    {
                        "username": "program22b",
                        "content": "is there a way to solve it even faster that O(n log n)?"
                    },
                    {
                        "username": "program22b",
                        "content": "[@sharma842nikhil](/sharma842nikhil) i think the count sort will be O(n+k) because we\\'re iterating through the array of frequencies to sort the original one"
                    },
                    {
                        "username": "program22b",
                        "content": "[@sarpalmadhav](/sarpalmadhav) i\\'m not a premium user to see it. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ahmed Mustafa](/program22b) always read official solution after submitting, It has something extra most of the times. There you will find O(n) way for this problem."
                    },
                    {
                        "username": "sharma842nikhil",
                        "content": "yes, you can use Counting sort instead of quick and you\\'ll get your result in O(N) "
                    },
                    {
                        "username": "ak503005",
                        "content": "Dedication and hardwork pays off\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode wanted to promote good habits so replaced thief stealing things in 0/1 knapsack to boy purchasing ice cream from his own hard earned money!! \\uD83D\\uDE0D \\uD83D\\uDE0D"
                    },
                    {
                        "username": "Umair9912",
                        "content": "The violations this problem is receiving is definitely not easy  xD"
                    },
                    {
                        "username": "0icy",
                        "content": "Even my unborn son would have solved this in a minute"
                    },
                    {
                        "username": "taj_1",
                        "content": "I think this problem should be in easy category..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Don\\'t confuse us by tagging easy problem as medium -_-"
                    },
                    {
                        "username": "native_element",
                        "content": "can you elaborate when i use dp or Greedy. A bit confusing."
                    }
                ]
            },
            {
                "id": 1744570,
                "content": [
                    {
                        "username": "Dhananjay40",
                        "content": "Okay! this is the fastest  medium problem I have ever solved. Give me the ice-cream"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "# Should be an easy difficulty for this problem\\n"
                    },
                    {
                        "username": "program22b",
                        "content": "is there a way to solve it even faster that O(n log n)?"
                    },
                    {
                        "username": "program22b",
                        "content": "[@sharma842nikhil](/sharma842nikhil) i think the count sort will be O(n+k) because we\\'re iterating through the array of frequencies to sort the original one"
                    },
                    {
                        "username": "program22b",
                        "content": "[@sarpalmadhav](/sarpalmadhav) i\\'m not a premium user to see it. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ahmed Mustafa](/program22b) always read official solution after submitting, It has something extra most of the times. There you will find O(n) way for this problem."
                    },
                    {
                        "username": "sharma842nikhil",
                        "content": "yes, you can use Counting sort instead of quick and you\\'ll get your result in O(N) "
                    },
                    {
                        "username": "ak503005",
                        "content": "Dedication and hardwork pays off\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode wanted to promote good habits so replaced thief stealing things in 0/1 knapsack to boy purchasing ice cream from his own hard earned money!! \\uD83D\\uDE0D \\uD83D\\uDE0D"
                    },
                    {
                        "username": "Umair9912",
                        "content": "The violations this problem is receiving is definitely not easy  xD"
                    },
                    {
                        "username": "0icy",
                        "content": "Even my unborn son would have solved this in a minute"
                    },
                    {
                        "username": "taj_1",
                        "content": "I think this problem should be in easy category..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Don\\'t confuse us by tagging easy problem as medium -_-"
                    },
                    {
                        "username": "native_element",
                        "content": "can you elaborate when i use dp or Greedy. A bit confusing."
                    }
                ]
            },
            {
                "id": 1744534,
                "content": [
                    {
                        "username": "Dhananjay40",
                        "content": "Okay! this is the fastest  medium problem I have ever solved. Give me the ice-cream"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "# Should be an easy difficulty for this problem\\n"
                    },
                    {
                        "username": "program22b",
                        "content": "is there a way to solve it even faster that O(n log n)?"
                    },
                    {
                        "username": "program22b",
                        "content": "[@sharma842nikhil](/sharma842nikhil) i think the count sort will be O(n+k) because we\\'re iterating through the array of frequencies to sort the original one"
                    },
                    {
                        "username": "program22b",
                        "content": "[@sarpalmadhav](/sarpalmadhav) i\\'m not a premium user to see it. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ahmed Mustafa](/program22b) always read official solution after submitting, It has something extra most of the times. There you will find O(n) way for this problem."
                    },
                    {
                        "username": "sharma842nikhil",
                        "content": "yes, you can use Counting sort instead of quick and you\\'ll get your result in O(N) "
                    },
                    {
                        "username": "ak503005",
                        "content": "Dedication and hardwork pays off\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode wanted to promote good habits so replaced thief stealing things in 0/1 knapsack to boy purchasing ice cream from his own hard earned money!! \\uD83D\\uDE0D \\uD83D\\uDE0D"
                    },
                    {
                        "username": "Umair9912",
                        "content": "The violations this problem is receiving is definitely not easy  xD"
                    },
                    {
                        "username": "0icy",
                        "content": "Even my unborn son would have solved this in a minute"
                    },
                    {
                        "username": "taj_1",
                        "content": "I think this problem should be in easy category..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Don\\'t confuse us by tagging easy problem as medium -_-"
                    },
                    {
                        "username": "native_element",
                        "content": "can you elaborate when i use dp or Greedy. A bit confusing."
                    }
                ]
            },
            {
                "id": 1744526,
                "content": [
                    {
                        "username": "Dhananjay40",
                        "content": "Okay! this is the fastest  medium problem I have ever solved. Give me the ice-cream"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "# Should be an easy difficulty for this problem\\n"
                    },
                    {
                        "username": "program22b",
                        "content": "is there a way to solve it even faster that O(n log n)?"
                    },
                    {
                        "username": "program22b",
                        "content": "[@sharma842nikhil](/sharma842nikhil) i think the count sort will be O(n+k) because we\\'re iterating through the array of frequencies to sort the original one"
                    },
                    {
                        "username": "program22b",
                        "content": "[@sarpalmadhav](/sarpalmadhav) i\\'m not a premium user to see it. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ahmed Mustafa](/program22b) always read official solution after submitting, It has something extra most of the times. There you will find O(n) way for this problem."
                    },
                    {
                        "username": "sharma842nikhil",
                        "content": "yes, you can use Counting sort instead of quick and you\\'ll get your result in O(N) "
                    },
                    {
                        "username": "ak503005",
                        "content": "Dedication and hardwork pays off\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode wanted to promote good habits so replaced thief stealing things in 0/1 knapsack to boy purchasing ice cream from his own hard earned money!! \\uD83D\\uDE0D \\uD83D\\uDE0D"
                    },
                    {
                        "username": "Umair9912",
                        "content": "The violations this problem is receiving is definitely not easy  xD"
                    },
                    {
                        "username": "0icy",
                        "content": "Even my unborn son would have solved this in a minute"
                    },
                    {
                        "username": "taj_1",
                        "content": "I think this problem should be in easy category..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Don\\'t confuse us by tagging easy problem as medium -_-"
                    },
                    {
                        "username": "native_element",
                        "content": "can you elaborate when i use dp or Greedy. A bit confusing."
                    }
                ]
            },
            {
                "id": 1744521,
                "content": [
                    {
                        "username": "Dhananjay40",
                        "content": "Okay! this is the fastest  medium problem I have ever solved. Give me the ice-cream"
                    },
                    {
                        "username": "Jiganesh",
                        "content": "# Should be an easy difficulty for this problem\\n"
                    },
                    {
                        "username": "program22b",
                        "content": "is there a way to solve it even faster that O(n log n)?"
                    },
                    {
                        "username": "program22b",
                        "content": "[@sharma842nikhil](/sharma842nikhil) i think the count sort will be O(n+k) because we\\'re iterating through the array of frequencies to sort the original one"
                    },
                    {
                        "username": "program22b",
                        "content": "[@sarpalmadhav](/sarpalmadhav) i\\'m not a premium user to see it. "
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Ahmed Mustafa](/program22b) always read official solution after submitting, It has something extra most of the times. There you will find O(n) way for this problem."
                    },
                    {
                        "username": "sharma842nikhil",
                        "content": "yes, you can use Counting sort instead of quick and you\\'ll get your result in O(N) "
                    },
                    {
                        "username": "ak503005",
                        "content": "Dedication and hardwork pays off\\n"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "Leetcode wanted to promote good habits so replaced thief stealing things in 0/1 knapsack to boy purchasing ice cream from his own hard earned money!! \\uD83D\\uDE0D \\uD83D\\uDE0D"
                    },
                    {
                        "username": "Umair9912",
                        "content": "The violations this problem is receiving is definitely not easy  xD"
                    },
                    {
                        "username": "0icy",
                        "content": "Even my unborn son would have solved this in a minute"
                    },
                    {
                        "username": "taj_1",
                        "content": "I think this problem should be in easy category..."
                    },
                    {
                        "username": "leeten__1500",
                        "content": "Don\\'t confuse us by tagging easy problem as medium -_-"
                    },
                    {
                        "username": "native_element",
                        "content": "can you elaborate when i use dp or Greedy. A bit confusing."
                    }
                ]
            },
            {
                "id": 1744514,
                "content": [
                    {
                        "username": "GD18",
                        "content": "They couldnt be serious with this now could they lol"
                    },
                    {
                        "username": "readonlylogin",
                        "content": "It\\'s definitely not medium, but easy"
                    },
                    {
                        "username": "pro_flow",
                        "content": "A real easy Medium Problem \\uD83E\\uDD73"
                    },
                    {
                        "username": "vineetsharma36",
                        "content": "It\\'s good that the question was this easy, I almost gave up after seeing the difficulty tag of the question as the harder the question, the more time I need to keep my gloves off in this cold. Thanks Leetcode for being sensitive in the winters."
                    },
                    {
                        "username": "deepaksharmana",
                        "content": "This medium is easier than easy lol."
                    },
                    {
                        "username": "Sudha_S",
                        "content": "I think trying to solve it using DP in O(n) is the difficult problem here. \nAnyone can sort & use greedy!!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "and [@Sudha_S](/Sudha_S) is being sarcastic here, greedy is the only way. A lot of newbies are taking DP comments seriously and trying to do DP in a problem that is unarguably the most famous greedy problem (0/1 knapsack)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Minamikaze392](/Minamikaze392) Read the constraints again, max of costs[i] is still same as O(n) only since both have upper limit of 10^5. At the end sorting is the bottleneck here and only 2 options are there n.logn and O(n) with counting sort!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Is an O(n) solution possible? Counting sort is not O(n) but O(n + max(costs[i]))."
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "I spent more time on finding out those testcases where simple logic will not work."
                    },
                    {
                        "username": "Valentin_Markov",
                        "content": "It gives me Time Limit Exceeded in test 51/63. Is it possible that I don\\'t have enough RAM for it? hahaha"
                    },
                    {
                        "username": "guna576",
                        "content": "It\\'s an easy problem if we realize we can sort!!!"
                    },
                    {
                        "username": "JhaSamirK",
                        "content": "EASY SOLUTION....#C++\\nint ans=0;\\n        long long sum=0;\\n        int n=costs.size();\\n        sort(costs.begin(),costs.end());\\n        for(int i=0;i<n;i++){\\n            sum+=costs[i];\\n            if(coins>=sum){\\n                ans++;\\n            }\\n            else{\\n                ans;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "Ghadeer_Elsalhawy",
                        "content": "You should post the solution on the solutions tab not the discussion tab."
                    }
                ]
            },
            {
                "id": 1744512,
                "content": [
                    {
                        "username": "GD18",
                        "content": "They couldnt be serious with this now could they lol"
                    },
                    {
                        "username": "readonlylogin",
                        "content": "It\\'s definitely not medium, but easy"
                    },
                    {
                        "username": "pro_flow",
                        "content": "A real easy Medium Problem \\uD83E\\uDD73"
                    },
                    {
                        "username": "vineetsharma36",
                        "content": "It\\'s good that the question was this easy, I almost gave up after seeing the difficulty tag of the question as the harder the question, the more time I need to keep my gloves off in this cold. Thanks Leetcode for being sensitive in the winters."
                    },
                    {
                        "username": "deepaksharmana",
                        "content": "This medium is easier than easy lol."
                    },
                    {
                        "username": "Sudha_S",
                        "content": "I think trying to solve it using DP in O(n) is the difficult problem here. \nAnyone can sort & use greedy!!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "and [@Sudha_S](/Sudha_S) is being sarcastic here, greedy is the only way. A lot of newbies are taking DP comments seriously and trying to do DP in a problem that is unarguably the most famous greedy problem (0/1 knapsack)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Minamikaze392](/Minamikaze392) Read the constraints again, max of costs[i] is still same as O(n) only since both have upper limit of 10^5. At the end sorting is the bottleneck here and only 2 options are there n.logn and O(n) with counting sort!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Is an O(n) solution possible? Counting sort is not O(n) but O(n + max(costs[i]))."
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "I spent more time on finding out those testcases where simple logic will not work."
                    },
                    {
                        "username": "Valentin_Markov",
                        "content": "It gives me Time Limit Exceeded in test 51/63. Is it possible that I don\\'t have enough RAM for it? hahaha"
                    },
                    {
                        "username": "guna576",
                        "content": "It\\'s an easy problem if we realize we can sort!!!"
                    },
                    {
                        "username": "JhaSamirK",
                        "content": "EASY SOLUTION....#C++\\nint ans=0;\\n        long long sum=0;\\n        int n=costs.size();\\n        sort(costs.begin(),costs.end());\\n        for(int i=0;i<n;i++){\\n            sum+=costs[i];\\n            if(coins>=sum){\\n                ans++;\\n            }\\n            else{\\n                ans;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "Ghadeer_Elsalhawy",
                        "content": "You should post the solution on the solutions tab not the discussion tab."
                    }
                ]
            },
            {
                "id": 1744500,
                "content": [
                    {
                        "username": "GD18",
                        "content": "They couldnt be serious with this now could they lol"
                    },
                    {
                        "username": "readonlylogin",
                        "content": "It\\'s definitely not medium, but easy"
                    },
                    {
                        "username": "pro_flow",
                        "content": "A real easy Medium Problem \\uD83E\\uDD73"
                    },
                    {
                        "username": "vineetsharma36",
                        "content": "It\\'s good that the question was this easy, I almost gave up after seeing the difficulty tag of the question as the harder the question, the more time I need to keep my gloves off in this cold. Thanks Leetcode for being sensitive in the winters."
                    },
                    {
                        "username": "deepaksharmana",
                        "content": "This medium is easier than easy lol."
                    },
                    {
                        "username": "Sudha_S",
                        "content": "I think trying to solve it using DP in O(n) is the difficult problem here. \nAnyone can sort & use greedy!!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "and [@Sudha_S](/Sudha_S) is being sarcastic here, greedy is the only way. A lot of newbies are taking DP comments seriously and trying to do DP in a problem that is unarguably the most famous greedy problem (0/1 knapsack)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Minamikaze392](/Minamikaze392) Read the constraints again, max of costs[i] is still same as O(n) only since both have upper limit of 10^5. At the end sorting is the bottleneck here and only 2 options are there n.logn and O(n) with counting sort!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Is an O(n) solution possible? Counting sort is not O(n) but O(n + max(costs[i]))."
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "I spent more time on finding out those testcases where simple logic will not work."
                    },
                    {
                        "username": "Valentin_Markov",
                        "content": "It gives me Time Limit Exceeded in test 51/63. Is it possible that I don\\'t have enough RAM for it? hahaha"
                    },
                    {
                        "username": "guna576",
                        "content": "It\\'s an easy problem if we realize we can sort!!!"
                    },
                    {
                        "username": "JhaSamirK",
                        "content": "EASY SOLUTION....#C++\\nint ans=0;\\n        long long sum=0;\\n        int n=costs.size();\\n        sort(costs.begin(),costs.end());\\n        for(int i=0;i<n;i++){\\n            sum+=costs[i];\\n            if(coins>=sum){\\n                ans++;\\n            }\\n            else{\\n                ans;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "Ghadeer_Elsalhawy",
                        "content": "You should post the solution on the solutions tab not the discussion tab."
                    }
                ]
            },
            {
                "id": 1744495,
                "content": [
                    {
                        "username": "GD18",
                        "content": "They couldnt be serious with this now could they lol"
                    },
                    {
                        "username": "readonlylogin",
                        "content": "It\\'s definitely not medium, but easy"
                    },
                    {
                        "username": "pro_flow",
                        "content": "A real easy Medium Problem \\uD83E\\uDD73"
                    },
                    {
                        "username": "vineetsharma36",
                        "content": "It\\'s good that the question was this easy, I almost gave up after seeing the difficulty tag of the question as the harder the question, the more time I need to keep my gloves off in this cold. Thanks Leetcode for being sensitive in the winters."
                    },
                    {
                        "username": "deepaksharmana",
                        "content": "This medium is easier than easy lol."
                    },
                    {
                        "username": "Sudha_S",
                        "content": "I think trying to solve it using DP in O(n) is the difficult problem here. \nAnyone can sort & use greedy!!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "and [@Sudha_S](/Sudha_S) is being sarcastic here, greedy is the only way. A lot of newbies are taking DP comments seriously and trying to do DP in a problem that is unarguably the most famous greedy problem (0/1 knapsack)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Minamikaze392](/Minamikaze392) Read the constraints again, max of costs[i] is still same as O(n) only since both have upper limit of 10^5. At the end sorting is the bottleneck here and only 2 options are there n.logn and O(n) with counting sort!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Is an O(n) solution possible? Counting sort is not O(n) but O(n + max(costs[i]))."
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "I spent more time on finding out those testcases where simple logic will not work."
                    },
                    {
                        "username": "Valentin_Markov",
                        "content": "It gives me Time Limit Exceeded in test 51/63. Is it possible that I don\\'t have enough RAM for it? hahaha"
                    },
                    {
                        "username": "guna576",
                        "content": "It\\'s an easy problem if we realize we can sort!!!"
                    },
                    {
                        "username": "JhaSamirK",
                        "content": "EASY SOLUTION....#C++\\nint ans=0;\\n        long long sum=0;\\n        int n=costs.size();\\n        sort(costs.begin(),costs.end());\\n        for(int i=0;i<n;i++){\\n            sum+=costs[i];\\n            if(coins>=sum){\\n                ans++;\\n            }\\n            else{\\n                ans;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "Ghadeer_Elsalhawy",
                        "content": "You should post the solution on the solutions tab not the discussion tab."
                    }
                ]
            },
            {
                "id": 1744478,
                "content": [
                    {
                        "username": "GD18",
                        "content": "They couldnt be serious with this now could they lol"
                    },
                    {
                        "username": "readonlylogin",
                        "content": "It\\'s definitely not medium, but easy"
                    },
                    {
                        "username": "pro_flow",
                        "content": "A real easy Medium Problem \\uD83E\\uDD73"
                    },
                    {
                        "username": "vineetsharma36",
                        "content": "It\\'s good that the question was this easy, I almost gave up after seeing the difficulty tag of the question as the harder the question, the more time I need to keep my gloves off in this cold. Thanks Leetcode for being sensitive in the winters."
                    },
                    {
                        "username": "deepaksharmana",
                        "content": "This medium is easier than easy lol."
                    },
                    {
                        "username": "Sudha_S",
                        "content": "I think trying to solve it using DP in O(n) is the difficult problem here. \nAnyone can sort & use greedy!!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "and [@Sudha_S](/Sudha_S) is being sarcastic here, greedy is the only way. A lot of newbies are taking DP comments seriously and trying to do DP in a problem that is unarguably the most famous greedy problem (0/1 knapsack)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Minamikaze392](/Minamikaze392) Read the constraints again, max of costs[i] is still same as O(n) only since both have upper limit of 10^5. At the end sorting is the bottleneck here and only 2 options are there n.logn and O(n) with counting sort!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Is an O(n) solution possible? Counting sort is not O(n) but O(n + max(costs[i]))."
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "I spent more time on finding out those testcases where simple logic will not work."
                    },
                    {
                        "username": "Valentin_Markov",
                        "content": "It gives me Time Limit Exceeded in test 51/63. Is it possible that I don\\'t have enough RAM for it? hahaha"
                    },
                    {
                        "username": "guna576",
                        "content": "It\\'s an easy problem if we realize we can sort!!!"
                    },
                    {
                        "username": "JhaSamirK",
                        "content": "EASY SOLUTION....#C++\\nint ans=0;\\n        long long sum=0;\\n        int n=costs.size();\\n        sort(costs.begin(),costs.end());\\n        for(int i=0;i<n;i++){\\n            sum+=costs[i];\\n            if(coins>=sum){\\n                ans++;\\n            }\\n            else{\\n                ans;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "Ghadeer_Elsalhawy",
                        "content": "You should post the solution on the solutions tab not the discussion tab."
                    }
                ]
            },
            {
                "id": 1744476,
                "content": [
                    {
                        "username": "GD18",
                        "content": "They couldnt be serious with this now could they lol"
                    },
                    {
                        "username": "readonlylogin",
                        "content": "It\\'s definitely not medium, but easy"
                    },
                    {
                        "username": "pro_flow",
                        "content": "A real easy Medium Problem \\uD83E\\uDD73"
                    },
                    {
                        "username": "vineetsharma36",
                        "content": "It\\'s good that the question was this easy, I almost gave up after seeing the difficulty tag of the question as the harder the question, the more time I need to keep my gloves off in this cold. Thanks Leetcode for being sensitive in the winters."
                    },
                    {
                        "username": "deepaksharmana",
                        "content": "This medium is easier than easy lol."
                    },
                    {
                        "username": "Sudha_S",
                        "content": "I think trying to solve it using DP in O(n) is the difficult problem here. \nAnyone can sort & use greedy!!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "and [@Sudha_S](/Sudha_S) is being sarcastic here, greedy is the only way. A lot of newbies are taking DP comments seriously and trying to do DP in a problem that is unarguably the most famous greedy problem (0/1 knapsack)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Minamikaze392](/Minamikaze392) Read the constraints again, max of costs[i] is still same as O(n) only since both have upper limit of 10^5. At the end sorting is the bottleneck here and only 2 options are there n.logn and O(n) with counting sort!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Is an O(n) solution possible? Counting sort is not O(n) but O(n + max(costs[i]))."
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "I spent more time on finding out those testcases where simple logic will not work."
                    },
                    {
                        "username": "Valentin_Markov",
                        "content": "It gives me Time Limit Exceeded in test 51/63. Is it possible that I don\\'t have enough RAM for it? hahaha"
                    },
                    {
                        "username": "guna576",
                        "content": "It\\'s an easy problem if we realize we can sort!!!"
                    },
                    {
                        "username": "JhaSamirK",
                        "content": "EASY SOLUTION....#C++\\nint ans=0;\\n        long long sum=0;\\n        int n=costs.size();\\n        sort(costs.begin(),costs.end());\\n        for(int i=0;i<n;i++){\\n            sum+=costs[i];\\n            if(coins>=sum){\\n                ans++;\\n            }\\n            else{\\n                ans;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "Ghadeer_Elsalhawy",
                        "content": "You should post the solution on the solutions tab not the discussion tab."
                    }
                ]
            },
            {
                "id": 1744470,
                "content": [
                    {
                        "username": "GD18",
                        "content": "They couldnt be serious with this now could they lol"
                    },
                    {
                        "username": "readonlylogin",
                        "content": "It\\'s definitely not medium, but easy"
                    },
                    {
                        "username": "pro_flow",
                        "content": "A real easy Medium Problem \\uD83E\\uDD73"
                    },
                    {
                        "username": "vineetsharma36",
                        "content": "It\\'s good that the question was this easy, I almost gave up after seeing the difficulty tag of the question as the harder the question, the more time I need to keep my gloves off in this cold. Thanks Leetcode for being sensitive in the winters."
                    },
                    {
                        "username": "deepaksharmana",
                        "content": "This medium is easier than easy lol."
                    },
                    {
                        "username": "Sudha_S",
                        "content": "I think trying to solve it using DP in O(n) is the difficult problem here. \nAnyone can sort & use greedy!!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "and [@Sudha_S](/Sudha_S) is being sarcastic here, greedy is the only way. A lot of newbies are taking DP comments seriously and trying to do DP in a problem that is unarguably the most famous greedy problem (0/1 knapsack)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Minamikaze392](/Minamikaze392) Read the constraints again, max of costs[i] is still same as O(n) only since both have upper limit of 10^5. At the end sorting is the bottleneck here and only 2 options are there n.logn and O(n) with counting sort!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Is an O(n) solution possible? Counting sort is not O(n) but O(n + max(costs[i]))."
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "I spent more time on finding out those testcases where simple logic will not work."
                    },
                    {
                        "username": "Valentin_Markov",
                        "content": "It gives me Time Limit Exceeded in test 51/63. Is it possible that I don\\'t have enough RAM for it? hahaha"
                    },
                    {
                        "username": "guna576",
                        "content": "It\\'s an easy problem if we realize we can sort!!!"
                    },
                    {
                        "username": "JhaSamirK",
                        "content": "EASY SOLUTION....#C++\\nint ans=0;\\n        long long sum=0;\\n        int n=costs.size();\\n        sort(costs.begin(),costs.end());\\n        for(int i=0;i<n;i++){\\n            sum+=costs[i];\\n            if(coins>=sum){\\n                ans++;\\n            }\\n            else{\\n                ans;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "Ghadeer_Elsalhawy",
                        "content": "You should post the solution on the solutions tab not the discussion tab."
                    }
                ]
            },
            {
                "id": 1744443,
                "content": [
                    {
                        "username": "GD18",
                        "content": "They couldnt be serious with this now could they lol"
                    },
                    {
                        "username": "readonlylogin",
                        "content": "It\\'s definitely not medium, but easy"
                    },
                    {
                        "username": "pro_flow",
                        "content": "A real easy Medium Problem \\uD83E\\uDD73"
                    },
                    {
                        "username": "vineetsharma36",
                        "content": "It\\'s good that the question was this easy, I almost gave up after seeing the difficulty tag of the question as the harder the question, the more time I need to keep my gloves off in this cold. Thanks Leetcode for being sensitive in the winters."
                    },
                    {
                        "username": "deepaksharmana",
                        "content": "This medium is easier than easy lol."
                    },
                    {
                        "username": "Sudha_S",
                        "content": "I think trying to solve it using DP in O(n) is the difficult problem here. \nAnyone can sort & use greedy!!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "and [@Sudha_S](/Sudha_S) is being sarcastic here, greedy is the only way. A lot of newbies are taking DP comments seriously and trying to do DP in a problem that is unarguably the most famous greedy problem (0/1 knapsack)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Minamikaze392](/Minamikaze392) Read the constraints again, max of costs[i] is still same as O(n) only since both have upper limit of 10^5. At the end sorting is the bottleneck here and only 2 options are there n.logn and O(n) with counting sort!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Is an O(n) solution possible? Counting sort is not O(n) but O(n + max(costs[i]))."
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "I spent more time on finding out those testcases where simple logic will not work."
                    },
                    {
                        "username": "Valentin_Markov",
                        "content": "It gives me Time Limit Exceeded in test 51/63. Is it possible that I don\\'t have enough RAM for it? hahaha"
                    },
                    {
                        "username": "guna576",
                        "content": "It\\'s an easy problem if we realize we can sort!!!"
                    },
                    {
                        "username": "JhaSamirK",
                        "content": "EASY SOLUTION....#C++\\nint ans=0;\\n        long long sum=0;\\n        int n=costs.size();\\n        sort(costs.begin(),costs.end());\\n        for(int i=0;i<n;i++){\\n            sum+=costs[i];\\n            if(coins>=sum){\\n                ans++;\\n            }\\n            else{\\n                ans;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "Ghadeer_Elsalhawy",
                        "content": "You should post the solution on the solutions tab not the discussion tab."
                    }
                ]
            },
            {
                "id": 1744441,
                "content": [
                    {
                        "username": "GD18",
                        "content": "They couldnt be serious with this now could they lol"
                    },
                    {
                        "username": "readonlylogin",
                        "content": "It\\'s definitely not medium, but easy"
                    },
                    {
                        "username": "pro_flow",
                        "content": "A real easy Medium Problem \\uD83E\\uDD73"
                    },
                    {
                        "username": "vineetsharma36",
                        "content": "It\\'s good that the question was this easy, I almost gave up after seeing the difficulty tag of the question as the harder the question, the more time I need to keep my gloves off in this cold. Thanks Leetcode for being sensitive in the winters."
                    },
                    {
                        "username": "deepaksharmana",
                        "content": "This medium is easier than easy lol."
                    },
                    {
                        "username": "Sudha_S",
                        "content": "I think trying to solve it using DP in O(n) is the difficult problem here. \nAnyone can sort & use greedy!!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "and [@Sudha_S](/Sudha_S) is being sarcastic here, greedy is the only way. A lot of newbies are taking DP comments seriously and trying to do DP in a problem that is unarguably the most famous greedy problem (0/1 knapsack)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Minamikaze392](/Minamikaze392) Read the constraints again, max of costs[i] is still same as O(n) only since both have upper limit of 10^5. At the end sorting is the bottleneck here and only 2 options are there n.logn and O(n) with counting sort!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Is an O(n) solution possible? Counting sort is not O(n) but O(n + max(costs[i]))."
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "I spent more time on finding out those testcases where simple logic will not work."
                    },
                    {
                        "username": "Valentin_Markov",
                        "content": "It gives me Time Limit Exceeded in test 51/63. Is it possible that I don\\'t have enough RAM for it? hahaha"
                    },
                    {
                        "username": "guna576",
                        "content": "It\\'s an easy problem if we realize we can sort!!!"
                    },
                    {
                        "username": "JhaSamirK",
                        "content": "EASY SOLUTION....#C++\\nint ans=0;\\n        long long sum=0;\\n        int n=costs.size();\\n        sort(costs.begin(),costs.end());\\n        for(int i=0;i<n;i++){\\n            sum+=costs[i];\\n            if(coins>=sum){\\n                ans++;\\n            }\\n            else{\\n                ans;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "Ghadeer_Elsalhawy",
                        "content": "You should post the solution on the solutions tab not the discussion tab."
                    }
                ]
            },
            {
                "id": 1744435,
                "content": [
                    {
                        "username": "GD18",
                        "content": "They couldnt be serious with this now could they lol"
                    },
                    {
                        "username": "readonlylogin",
                        "content": "It\\'s definitely not medium, but easy"
                    },
                    {
                        "username": "pro_flow",
                        "content": "A real easy Medium Problem \\uD83E\\uDD73"
                    },
                    {
                        "username": "vineetsharma36",
                        "content": "It\\'s good that the question was this easy, I almost gave up after seeing the difficulty tag of the question as the harder the question, the more time I need to keep my gloves off in this cold. Thanks Leetcode for being sensitive in the winters."
                    },
                    {
                        "username": "deepaksharmana",
                        "content": "This medium is easier than easy lol."
                    },
                    {
                        "username": "Sudha_S",
                        "content": "I think trying to solve it using DP in O(n) is the difficult problem here. \nAnyone can sort & use greedy!!"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "and [@Sudha_S](/Sudha_S) is being sarcastic here, greedy is the only way. A lot of newbies are taking DP comments seriously and trying to do DP in a problem that is unarguably the most famous greedy problem (0/1 knapsack)"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Minamikaze392](/Minamikaze392) Read the constraints again, max of costs[i] is still same as O(n) only since both have upper limit of 10^5. At the end sorting is the bottleneck here and only 2 options are there n.logn and O(n) with counting sort!"
                    },
                    {
                        "username": "Minamikaze392",
                        "content": "Is an O(n) solution possible? Counting sort is not O(n) but O(n + max(costs[i]))."
                    },
                    {
                        "username": "Rajkumar_007",
                        "content": "I spent more time on finding out those testcases where simple logic will not work."
                    },
                    {
                        "username": "Valentin_Markov",
                        "content": "It gives me Time Limit Exceeded in test 51/63. Is it possible that I don\\'t have enough RAM for it? hahaha"
                    },
                    {
                        "username": "guna576",
                        "content": "It\\'s an easy problem if we realize we can sort!!!"
                    },
                    {
                        "username": "JhaSamirK",
                        "content": "EASY SOLUTION....#C++\\nint ans=0;\\n        long long sum=0;\\n        int n=costs.size();\\n        sort(costs.begin(),costs.end());\\n        for(int i=0;i<n;i++){\\n            sum+=costs[i];\\n            if(coins>=sum){\\n                ans++;\\n            }\\n            else{\\n                ans;\\n            }\\n        }\\n        return ans;"
                    },
                    {
                        "username": "Ghadeer_Elsalhawy",
                        "content": "You should post the solution on the solutions tab not the discussion tab."
                    }
                ]
            },
            {
                "id": 1744422,
                "content": [
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode should check its difficulty level again i think it should marked as easy . <br>\\nMy solution link O(1) space . https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3007309/c-easy-and-simple-solution-o1-space/"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Another day, another easy problem..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "solved the question in one minute with one hand .... this definitely had to be an easy one lol !"
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "Good question,gained confidence\\n\\n"
                    },
                    {
                        "username": "alxolr",
                        "content": "I\\'ve spent more time to understand what\\'s the catch, it can\\'t be that easy. Tried to look into a O(n) solution but couldn\\'t find. I guess O(nlogn) is good enough."
                    },
                    {
                        "username": "Rishil96",
                        "content": "I have seen problems tagged as easy more challenging than this medium problem XD"
                    },
                    {
                        "username": "VishalVerma11021999",
                        "content": "new year resolution continue on sixth day "
                    },
                    {
                        "username": "Raj_Gupta97",
                        "content": "Yooo , after solving this tough medium problem i feel like i\\'m Elon Musk."
                    },
                    {
                        "username": "dhruv_bajaj",
                        "content": "Questions title should be deception."
                    },
                    {
                        "username": "fuadul012",
                        "content": "Why this problem is in the medium section\\uD83E\\uDD72. It\\'s too easy to think. "
                    }
                ]
            },
            {
                "id": 1744419,
                "content": [
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode should check its difficulty level again i think it should marked as easy . <br>\\nMy solution link O(1) space . https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3007309/c-easy-and-simple-solution-o1-space/"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Another day, another easy problem..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "solved the question in one minute with one hand .... this definitely had to be an easy one lol !"
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "Good question,gained confidence\\n\\n"
                    },
                    {
                        "username": "alxolr",
                        "content": "I\\'ve spent more time to understand what\\'s the catch, it can\\'t be that easy. Tried to look into a O(n) solution but couldn\\'t find. I guess O(nlogn) is good enough."
                    },
                    {
                        "username": "Rishil96",
                        "content": "I have seen problems tagged as easy more challenging than this medium problem XD"
                    },
                    {
                        "username": "VishalVerma11021999",
                        "content": "new year resolution continue on sixth day "
                    },
                    {
                        "username": "Raj_Gupta97",
                        "content": "Yooo , after solving this tough medium problem i feel like i\\'m Elon Musk."
                    },
                    {
                        "username": "dhruv_bajaj",
                        "content": "Questions title should be deception."
                    },
                    {
                        "username": "fuadul012",
                        "content": "Why this problem is in the medium section\\uD83E\\uDD72. It\\'s too easy to think. "
                    }
                ]
            },
            {
                "id": 1744404,
                "content": [
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode should check its difficulty level again i think it should marked as easy . <br>\\nMy solution link O(1) space . https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3007309/c-easy-and-simple-solution-o1-space/"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Another day, another easy problem..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "solved the question in one minute with one hand .... this definitely had to be an easy one lol !"
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "Good question,gained confidence\\n\\n"
                    },
                    {
                        "username": "alxolr",
                        "content": "I\\'ve spent more time to understand what\\'s the catch, it can\\'t be that easy. Tried to look into a O(n) solution but couldn\\'t find. I guess O(nlogn) is good enough."
                    },
                    {
                        "username": "Rishil96",
                        "content": "I have seen problems tagged as easy more challenging than this medium problem XD"
                    },
                    {
                        "username": "VishalVerma11021999",
                        "content": "new year resolution continue on sixth day "
                    },
                    {
                        "username": "Raj_Gupta97",
                        "content": "Yooo , after solving this tough medium problem i feel like i\\'m Elon Musk."
                    },
                    {
                        "username": "dhruv_bajaj",
                        "content": "Questions title should be deception."
                    },
                    {
                        "username": "fuadul012",
                        "content": "Why this problem is in the medium section\\uD83E\\uDD72. It\\'s too easy to think. "
                    }
                ]
            },
            {
                "id": 1744388,
                "content": [
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode should check its difficulty level again i think it should marked as easy . <br>\\nMy solution link O(1) space . https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3007309/c-easy-and-simple-solution-o1-space/"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Another day, another easy problem..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "solved the question in one minute with one hand .... this definitely had to be an easy one lol !"
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "Good question,gained confidence\\n\\n"
                    },
                    {
                        "username": "alxolr",
                        "content": "I\\'ve spent more time to understand what\\'s the catch, it can\\'t be that easy. Tried to look into a O(n) solution but couldn\\'t find. I guess O(nlogn) is good enough."
                    },
                    {
                        "username": "Rishil96",
                        "content": "I have seen problems tagged as easy more challenging than this medium problem XD"
                    },
                    {
                        "username": "VishalVerma11021999",
                        "content": "new year resolution continue on sixth day "
                    },
                    {
                        "username": "Raj_Gupta97",
                        "content": "Yooo , after solving this tough medium problem i feel like i\\'m Elon Musk."
                    },
                    {
                        "username": "dhruv_bajaj",
                        "content": "Questions title should be deception."
                    },
                    {
                        "username": "fuadul012",
                        "content": "Why this problem is in the medium section\\uD83E\\uDD72. It\\'s too easy to think. "
                    }
                ]
            },
            {
                "id": 1744367,
                "content": [
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode should check its difficulty level again i think it should marked as easy . <br>\\nMy solution link O(1) space . https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3007309/c-easy-and-simple-solution-o1-space/"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Another day, another easy problem..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "solved the question in one minute with one hand .... this definitely had to be an easy one lol !"
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "Good question,gained confidence\\n\\n"
                    },
                    {
                        "username": "alxolr",
                        "content": "I\\'ve spent more time to understand what\\'s the catch, it can\\'t be that easy. Tried to look into a O(n) solution but couldn\\'t find. I guess O(nlogn) is good enough."
                    },
                    {
                        "username": "Rishil96",
                        "content": "I have seen problems tagged as easy more challenging than this medium problem XD"
                    },
                    {
                        "username": "VishalVerma11021999",
                        "content": "new year resolution continue on sixth day "
                    },
                    {
                        "username": "Raj_Gupta97",
                        "content": "Yooo , after solving this tough medium problem i feel like i\\'m Elon Musk."
                    },
                    {
                        "username": "dhruv_bajaj",
                        "content": "Questions title should be deception."
                    },
                    {
                        "username": "fuadul012",
                        "content": "Why this problem is in the medium section\\uD83E\\uDD72. It\\'s too easy to think. "
                    }
                ]
            },
            {
                "id": 1744364,
                "content": [
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode should check its difficulty level again i think it should marked as easy . <br>\\nMy solution link O(1) space . https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3007309/c-easy-and-simple-solution-o1-space/"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Another day, another easy problem..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "solved the question in one minute with one hand .... this definitely had to be an easy one lol !"
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "Good question,gained confidence\\n\\n"
                    },
                    {
                        "username": "alxolr",
                        "content": "I\\'ve spent more time to understand what\\'s the catch, it can\\'t be that easy. Tried to look into a O(n) solution but couldn\\'t find. I guess O(nlogn) is good enough."
                    },
                    {
                        "username": "Rishil96",
                        "content": "I have seen problems tagged as easy more challenging than this medium problem XD"
                    },
                    {
                        "username": "VishalVerma11021999",
                        "content": "new year resolution continue on sixth day "
                    },
                    {
                        "username": "Raj_Gupta97",
                        "content": "Yooo , after solving this tough medium problem i feel like i\\'m Elon Musk."
                    },
                    {
                        "username": "dhruv_bajaj",
                        "content": "Questions title should be deception."
                    },
                    {
                        "username": "fuadul012",
                        "content": "Why this problem is in the medium section\\uD83E\\uDD72. It\\'s too easy to think. "
                    }
                ]
            },
            {
                "id": 1744355,
                "content": [
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode should check its difficulty level again i think it should marked as easy . <br>\\nMy solution link O(1) space . https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3007309/c-easy-and-simple-solution-o1-space/"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Another day, another easy problem..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "solved the question in one minute with one hand .... this definitely had to be an easy one lol !"
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "Good question,gained confidence\\n\\n"
                    },
                    {
                        "username": "alxolr",
                        "content": "I\\'ve spent more time to understand what\\'s the catch, it can\\'t be that easy. Tried to look into a O(n) solution but couldn\\'t find. I guess O(nlogn) is good enough."
                    },
                    {
                        "username": "Rishil96",
                        "content": "I have seen problems tagged as easy more challenging than this medium problem XD"
                    },
                    {
                        "username": "VishalVerma11021999",
                        "content": "new year resolution continue on sixth day "
                    },
                    {
                        "username": "Raj_Gupta97",
                        "content": "Yooo , after solving this tough medium problem i feel like i\\'m Elon Musk."
                    },
                    {
                        "username": "dhruv_bajaj",
                        "content": "Questions title should be deception."
                    },
                    {
                        "username": "fuadul012",
                        "content": "Why this problem is in the medium section\\uD83E\\uDD72. It\\'s too easy to think. "
                    }
                ]
            },
            {
                "id": 1744354,
                "content": [
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode should check its difficulty level again i think it should marked as easy . <br>\\nMy solution link O(1) space . https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3007309/c-easy-and-simple-solution-o1-space/"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Another day, another easy problem..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "solved the question in one minute with one hand .... this definitely had to be an easy one lol !"
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "Good question,gained confidence\\n\\n"
                    },
                    {
                        "username": "alxolr",
                        "content": "I\\'ve spent more time to understand what\\'s the catch, it can\\'t be that easy. Tried to look into a O(n) solution but couldn\\'t find. I guess O(nlogn) is good enough."
                    },
                    {
                        "username": "Rishil96",
                        "content": "I have seen problems tagged as easy more challenging than this medium problem XD"
                    },
                    {
                        "username": "VishalVerma11021999",
                        "content": "new year resolution continue on sixth day "
                    },
                    {
                        "username": "Raj_Gupta97",
                        "content": "Yooo , after solving this tough medium problem i feel like i\\'m Elon Musk."
                    },
                    {
                        "username": "dhruv_bajaj",
                        "content": "Questions title should be deception."
                    },
                    {
                        "username": "fuadul012",
                        "content": "Why this problem is in the medium section\\uD83E\\uDD72. It\\'s too easy to think. "
                    }
                ]
            },
            {
                "id": 1744352,
                "content": [
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode should check its difficulty level again i think it should marked as easy . <br>\\nMy solution link O(1) space . https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3007309/c-easy-and-simple-solution-o1-space/"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Another day, another easy problem..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "solved the question in one minute with one hand .... this definitely had to be an easy one lol !"
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "Good question,gained confidence\\n\\n"
                    },
                    {
                        "username": "alxolr",
                        "content": "I\\'ve spent more time to understand what\\'s the catch, it can\\'t be that easy. Tried to look into a O(n) solution but couldn\\'t find. I guess O(nlogn) is good enough."
                    },
                    {
                        "username": "Rishil96",
                        "content": "I have seen problems tagged as easy more challenging than this medium problem XD"
                    },
                    {
                        "username": "VishalVerma11021999",
                        "content": "new year resolution continue on sixth day "
                    },
                    {
                        "username": "Raj_Gupta97",
                        "content": "Yooo , after solving this tough medium problem i feel like i\\'m Elon Musk."
                    },
                    {
                        "username": "dhruv_bajaj",
                        "content": "Questions title should be deception."
                    },
                    {
                        "username": "fuadul012",
                        "content": "Why this problem is in the medium section\\uD83E\\uDD72. It\\'s too easy to think. "
                    }
                ]
            },
            {
                "id": 1744350,
                "content": [
                    {
                        "username": "ayushluthra62",
                        "content": "LeetCode should check its difficulty level again i think it should marked as easy . <br>\\nMy solution link O(1) space . https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3007309/c-easy-and-simple-solution-o1-space/"
                    },
                    {
                        "username": "Unbeknownstguy",
                        "content": "Another day, another easy problem..."
                    },
                    {
                        "username": "AkshatJain4",
                        "content": "solved the question in one minute with one hand .... this definitely had to be an easy one lol !"
                    },
                    {
                        "username": "rohankolhatkar",
                        "content": "Good question,gained confidence\\n\\n"
                    },
                    {
                        "username": "alxolr",
                        "content": "I\\'ve spent more time to understand what\\'s the catch, it can\\'t be that easy. Tried to look into a O(n) solution but couldn\\'t find. I guess O(nlogn) is good enough."
                    },
                    {
                        "username": "Rishil96",
                        "content": "I have seen problems tagged as easy more challenging than this medium problem XD"
                    },
                    {
                        "username": "VishalVerma11021999",
                        "content": "new year resolution continue on sixth day "
                    },
                    {
                        "username": "Raj_Gupta97",
                        "content": "Yooo , after solving this tough medium problem i feel like i\\'m Elon Musk."
                    },
                    {
                        "username": "dhruv_bajaj",
                        "content": "Questions title should be deception."
                    },
                    {
                        "username": "fuadul012",
                        "content": "Why this problem is in the medium section\\uD83E\\uDD72. It\\'s too easy to think. "
                    }
                ]
            },
            {
                "id": 1744348,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "easiest medium"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Difficulty - Easy "
                    },
                    {
                        "username": "nubcoder25",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Binary Search maybe the best Solution as per my Knowledge\nsince they given order is not concerned "
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easiest solution\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        int count=0;\\n        \\n        for(int i=0;i<costs.size();i++)\\n        {\\n            if(coins >= costs[i])\\n            {\\n                count++;\\n                coins-=costs[i];\\n            }\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sanket0708",
                        "content": "Lets solve it using DP ! Leetcode be like - LOL :)"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for detailed explanation\\nhttps://youtu.be/nmiIyBQFMeM"
                    },
                    {
                        "username": "Jitesh_k",
                        "content": "Super easy 3000"
                    },
                    {
                        "username": "ashunegi880",
                        "content": "I thought I was missing something it could not be this simple. XD \\uD83D\\uDE02"
                    },
                    {
                        "username": "kevinyou77",
                        "content": "- Reading the question and thought, hmmm this is easy tho, is there anything I missed, must be a reason this is a medium  question amirite\\n- Read the second time\\n- Huh\\n- Code up the solution and submit, maybe a test case will fail\\n- AC\\n- Oh."
                    }
                ]
            },
            {
                "id": 1744327,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "easiest medium"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Difficulty - Easy "
                    },
                    {
                        "username": "nubcoder25",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Binary Search maybe the best Solution as per my Knowledge\nsince they given order is not concerned "
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easiest solution\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        int count=0;\\n        \\n        for(int i=0;i<costs.size();i++)\\n        {\\n            if(coins >= costs[i])\\n            {\\n                count++;\\n                coins-=costs[i];\\n            }\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sanket0708",
                        "content": "Lets solve it using DP ! Leetcode be like - LOL :)"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for detailed explanation\\nhttps://youtu.be/nmiIyBQFMeM"
                    },
                    {
                        "username": "Jitesh_k",
                        "content": "Super easy 3000"
                    },
                    {
                        "username": "ashunegi880",
                        "content": "I thought I was missing something it could not be this simple. XD \\uD83D\\uDE02"
                    },
                    {
                        "username": "kevinyou77",
                        "content": "- Reading the question and thought, hmmm this is easy tho, is there anything I missed, must be a reason this is a medium  question amirite\\n- Read the second time\\n- Huh\\n- Code up the solution and submit, maybe a test case will fail\\n- AC\\n- Oh."
                    }
                ]
            },
            {
                "id": 1744324,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "easiest medium"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Difficulty - Easy "
                    },
                    {
                        "username": "nubcoder25",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Binary Search maybe the best Solution as per my Knowledge\nsince they given order is not concerned "
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easiest solution\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        int count=0;\\n        \\n        for(int i=0;i<costs.size();i++)\\n        {\\n            if(coins >= costs[i])\\n            {\\n                count++;\\n                coins-=costs[i];\\n            }\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sanket0708",
                        "content": "Lets solve it using DP ! Leetcode be like - LOL :)"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for detailed explanation\\nhttps://youtu.be/nmiIyBQFMeM"
                    },
                    {
                        "username": "Jitesh_k",
                        "content": "Super easy 3000"
                    },
                    {
                        "username": "ashunegi880",
                        "content": "I thought I was missing something it could not be this simple. XD \\uD83D\\uDE02"
                    },
                    {
                        "username": "kevinyou77",
                        "content": "- Reading the question and thought, hmmm this is easy tho, is there anything I missed, must be a reason this is a medium  question amirite\\n- Read the second time\\n- Huh\\n- Code up the solution and submit, maybe a test case will fail\\n- AC\\n- Oh."
                    }
                ]
            },
            {
                "id": 1744314,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "easiest medium"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Difficulty - Easy "
                    },
                    {
                        "username": "nubcoder25",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Binary Search maybe the best Solution as per my Knowledge\nsince they given order is not concerned "
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easiest solution\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        int count=0;\\n        \\n        for(int i=0;i<costs.size();i++)\\n        {\\n            if(coins >= costs[i])\\n            {\\n                count++;\\n                coins-=costs[i];\\n            }\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sanket0708",
                        "content": "Lets solve it using DP ! Leetcode be like - LOL :)"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for detailed explanation\\nhttps://youtu.be/nmiIyBQFMeM"
                    },
                    {
                        "username": "Jitesh_k",
                        "content": "Super easy 3000"
                    },
                    {
                        "username": "ashunegi880",
                        "content": "I thought I was missing something it could not be this simple. XD \\uD83D\\uDE02"
                    },
                    {
                        "username": "kevinyou77",
                        "content": "- Reading the question and thought, hmmm this is easy tho, is there anything I missed, must be a reason this is a medium  question amirite\\n- Read the second time\\n- Huh\\n- Code up the solution and submit, maybe a test case will fail\\n- AC\\n- Oh."
                    }
                ]
            },
            {
                "id": 1744306,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "easiest medium"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Difficulty - Easy "
                    },
                    {
                        "username": "nubcoder25",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Binary Search maybe the best Solution as per my Knowledge\nsince they given order is not concerned "
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easiest solution\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        int count=0;\\n        \\n        for(int i=0;i<costs.size();i++)\\n        {\\n            if(coins >= costs[i])\\n            {\\n                count++;\\n                coins-=costs[i];\\n            }\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sanket0708",
                        "content": "Lets solve it using DP ! Leetcode be like - LOL :)"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for detailed explanation\\nhttps://youtu.be/nmiIyBQFMeM"
                    },
                    {
                        "username": "Jitesh_k",
                        "content": "Super easy 3000"
                    },
                    {
                        "username": "ashunegi880",
                        "content": "I thought I was missing something it could not be this simple. XD \\uD83D\\uDE02"
                    },
                    {
                        "username": "kevinyou77",
                        "content": "- Reading the question and thought, hmmm this is easy tho, is there anything I missed, must be a reason this is a medium  question amirite\\n- Read the second time\\n- Huh\\n- Code up the solution and submit, maybe a test case will fail\\n- AC\\n- Oh."
                    }
                ]
            },
            {
                "id": 1744296,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "easiest medium"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Difficulty - Easy "
                    },
                    {
                        "username": "nubcoder25",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Binary Search maybe the best Solution as per my Knowledge\nsince they given order is not concerned "
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easiest solution\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        int count=0;\\n        \\n        for(int i=0;i<costs.size();i++)\\n        {\\n            if(coins >= costs[i])\\n            {\\n                count++;\\n                coins-=costs[i];\\n            }\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sanket0708",
                        "content": "Lets solve it using DP ! Leetcode be like - LOL :)"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for detailed explanation\\nhttps://youtu.be/nmiIyBQFMeM"
                    },
                    {
                        "username": "Jitesh_k",
                        "content": "Super easy 3000"
                    },
                    {
                        "username": "ashunegi880",
                        "content": "I thought I was missing something it could not be this simple. XD \\uD83D\\uDE02"
                    },
                    {
                        "username": "kevinyou77",
                        "content": "- Reading the question and thought, hmmm this is easy tho, is there anything I missed, must be a reason this is a medium  question amirite\\n- Read the second time\\n- Huh\\n- Code up the solution and submit, maybe a test case will fail\\n- AC\\n- Oh."
                    }
                ]
            },
            {
                "id": 1744289,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "easiest medium"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Difficulty - Easy "
                    },
                    {
                        "username": "nubcoder25",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Binary Search maybe the best Solution as per my Knowledge\nsince they given order is not concerned "
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easiest solution\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        int count=0;\\n        \\n        for(int i=0;i<costs.size();i++)\\n        {\\n            if(coins >= costs[i])\\n            {\\n                count++;\\n                coins-=costs[i];\\n            }\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sanket0708",
                        "content": "Lets solve it using DP ! Leetcode be like - LOL :)"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for detailed explanation\\nhttps://youtu.be/nmiIyBQFMeM"
                    },
                    {
                        "username": "Jitesh_k",
                        "content": "Super easy 3000"
                    },
                    {
                        "username": "ashunegi880",
                        "content": "I thought I was missing something it could not be this simple. XD \\uD83D\\uDE02"
                    },
                    {
                        "username": "kevinyou77",
                        "content": "- Reading the question and thought, hmmm this is easy tho, is there anything I missed, must be a reason this is a medium  question amirite\\n- Read the second time\\n- Huh\\n- Code up the solution and submit, maybe a test case will fail\\n- AC\\n- Oh."
                    }
                ]
            },
            {
                "id": 1744288,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "easiest medium"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Difficulty - Easy "
                    },
                    {
                        "username": "nubcoder25",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Binary Search maybe the best Solution as per my Knowledge\nsince they given order is not concerned "
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easiest solution\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        int count=0;\\n        \\n        for(int i=0;i<costs.size();i++)\\n        {\\n            if(coins >= costs[i])\\n            {\\n                count++;\\n                coins-=costs[i];\\n            }\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sanket0708",
                        "content": "Lets solve it using DP ! Leetcode be like - LOL :)"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for detailed explanation\\nhttps://youtu.be/nmiIyBQFMeM"
                    },
                    {
                        "username": "Jitesh_k",
                        "content": "Super easy 3000"
                    },
                    {
                        "username": "ashunegi880",
                        "content": "I thought I was missing something it could not be this simple. XD \\uD83D\\uDE02"
                    },
                    {
                        "username": "kevinyou77",
                        "content": "- Reading the question and thought, hmmm this is easy tho, is there anything I missed, must be a reason this is a medium  question amirite\\n- Read the second time\\n- Huh\\n- Code up the solution and submit, maybe a test case will fail\\n- AC\\n- Oh."
                    }
                ]
            },
            {
                "id": 1744275,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "easiest medium"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Difficulty - Easy "
                    },
                    {
                        "username": "nubcoder25",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Binary Search maybe the best Solution as per my Knowledge\nsince they given order is not concerned "
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easiest solution\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        int count=0;\\n        \\n        for(int i=0;i<costs.size();i++)\\n        {\\n            if(coins >= costs[i])\\n            {\\n                count++;\\n                coins-=costs[i];\\n            }\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sanket0708",
                        "content": "Lets solve it using DP ! Leetcode be like - LOL :)"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for detailed explanation\\nhttps://youtu.be/nmiIyBQFMeM"
                    },
                    {
                        "username": "Jitesh_k",
                        "content": "Super easy 3000"
                    },
                    {
                        "username": "ashunegi880",
                        "content": "I thought I was missing something it could not be this simple. XD \\uD83D\\uDE02"
                    },
                    {
                        "username": "kevinyou77",
                        "content": "- Reading the question and thought, hmmm this is easy tho, is there anything I missed, must be a reason this is a medium  question amirite\\n- Read the second time\\n- Huh\\n- Code up the solution and submit, maybe a test case will fail\\n- AC\\n- Oh."
                    }
                ]
            },
            {
                "id": 1744265,
                "content": [
                    {
                        "username": "sasukesharma",
                        "content": "easiest medium"
                    },
                    {
                        "username": "pulkitrajpal",
                        "content": "Difficulty - Easy "
                    },
                    {
                        "username": "nubcoder25",
                        "content": "Should be tagged as easy."
                    },
                    {
                        "username": "Ak_15",
                        "content": "Binary Search maybe the best Solution as per my Knowledge\nsince they given order is not concerned "
                    },
                    {
                        "username": "utkarshv2619",
                        "content": "//easiest solution\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin(), costs.end());\\n        int count=0;\\n        \\n        for(int i=0;i<costs.size();i++)\\n        {\\n            if(coins >= costs[i])\\n            {\\n                count++;\\n                coins-=costs[i];\\n            }\\n            else\\n                break;\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "sanket0708",
                        "content": "Lets solve it using DP ! Leetcode be like - LOL :)"
                    },
                    {
                        "username": "bhanujoshi",
                        "content": "Please watch video for detailed explanation\\nhttps://youtu.be/nmiIyBQFMeM"
                    },
                    {
                        "username": "Jitesh_k",
                        "content": "Super easy 3000"
                    },
                    {
                        "username": "ashunegi880",
                        "content": "I thought I was missing something it could not be this simple. XD \\uD83D\\uDE02"
                    },
                    {
                        "username": "kevinyou77",
                        "content": "- Reading the question and thought, hmmm this is easy tho, is there anything I missed, must be a reason this is a medium  question amirite\\n- Read the second time\\n- Huh\\n- Code up the solution and submit, maybe a test case will fail\\n- AC\\n- Oh."
                    }
                ]
            },
            {
                "id": 1744261,
                "content": [
                    {
                        "username": "admschaaf",
                        "content": "The description should specify linear time if this is a medium problem."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Oh I love this Question \\uD83D\\uDE18"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Many people may get confused and can apply subset sum problem approach here but then they may get memory limit warning."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Similar to 0/1 Knapsack problem isn\\'t it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shounak Basu](/S_Basu)It is not similar, it is the same problem. Easiest greedy problem... and yet people are debating greedy vs DP in discussion"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "this should not be a problem"
                    },
                    {
                        "username": "debanjan2002",
                        "content": "This should definitely be an easy question. There is no complex logic required!"
                    },
                    {
                        "username": "Hrsh_123",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "schanjr",
                        "content": "I was shocked I solved a medium problem. After solving it, I determined this is not a medium problem. "
                    },
                    {
                        "username": "HackHustler",
                        "content": "easiest ever "
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": " `class Solution {\\n    static int[] dp;\\n    public int maxIceCream(int[] costs, int coins) {\\n        dp = new int[costs.length];\\n        Arrays.fill(dp , -1);\\n// Arrays.sort(costs);\\n        return helper(costs , coins , 0);\\n    }\\n    private int helper(int[] costs , int remCoins , int start) {\\n        if(remCoins <= 0 ) return 0;\\n        if(start == costs.length-1){\\n            if(costs[start] <= remCoins){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        if(dp[start] != -1) {\\n            return dp[start];\\n        }\\n        int take=0;\\n        int doesNot = 0;\\n        if(costs[start] <= remCoins) {\\n             take = 1 + helper(costs , remCoins - costs[start] , start +1) ;\\n        }\\n        doesNot = helper(costs , remCoins , start +1);\\n\\n        return dp[start] = Math.max(take , doesNot);\\n    }\\n}`\\nWhy this is not working ? in dp! like it goes to till certain test cases but then it doesn\\'t for rest!\\nBut it works perfectly once i sort the arrays from start, then what will be the point of even using dp? Can someone please tell me"
                    }
                ]
            },
            {
                "id": 1744258,
                "content": [
                    {
                        "username": "admschaaf",
                        "content": "The description should specify linear time if this is a medium problem."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Oh I love this Question \\uD83D\\uDE18"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Many people may get confused and can apply subset sum problem approach here but then they may get memory limit warning."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Similar to 0/1 Knapsack problem isn\\'t it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shounak Basu](/S_Basu)It is not similar, it is the same problem. Easiest greedy problem... and yet people are debating greedy vs DP in discussion"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "this should not be a problem"
                    },
                    {
                        "username": "debanjan2002",
                        "content": "This should definitely be an easy question. There is no complex logic required!"
                    },
                    {
                        "username": "Hrsh_123",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "schanjr",
                        "content": "I was shocked I solved a medium problem. After solving it, I determined this is not a medium problem. "
                    },
                    {
                        "username": "HackHustler",
                        "content": "easiest ever "
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": " `class Solution {\\n    static int[] dp;\\n    public int maxIceCream(int[] costs, int coins) {\\n        dp = new int[costs.length];\\n        Arrays.fill(dp , -1);\\n// Arrays.sort(costs);\\n        return helper(costs , coins , 0);\\n    }\\n    private int helper(int[] costs , int remCoins , int start) {\\n        if(remCoins <= 0 ) return 0;\\n        if(start == costs.length-1){\\n            if(costs[start] <= remCoins){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        if(dp[start] != -1) {\\n            return dp[start];\\n        }\\n        int take=0;\\n        int doesNot = 0;\\n        if(costs[start] <= remCoins) {\\n             take = 1 + helper(costs , remCoins - costs[start] , start +1) ;\\n        }\\n        doesNot = helper(costs , remCoins , start +1);\\n\\n        return dp[start] = Math.max(take , doesNot);\\n    }\\n}`\\nWhy this is not working ? in dp! like it goes to till certain test cases but then it doesn\\'t for rest!\\nBut it works perfectly once i sort the arrays from start, then what will be the point of even using dp? Can someone please tell me"
                    }
                ]
            },
            {
                "id": 1744248,
                "content": [
                    {
                        "username": "admschaaf",
                        "content": "The description should specify linear time if this is a medium problem."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Oh I love this Question \\uD83D\\uDE18"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Many people may get confused and can apply subset sum problem approach here but then they may get memory limit warning."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Similar to 0/1 Knapsack problem isn\\'t it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shounak Basu](/S_Basu)It is not similar, it is the same problem. Easiest greedy problem... and yet people are debating greedy vs DP in discussion"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "this should not be a problem"
                    },
                    {
                        "username": "debanjan2002",
                        "content": "This should definitely be an easy question. There is no complex logic required!"
                    },
                    {
                        "username": "Hrsh_123",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "schanjr",
                        "content": "I was shocked I solved a medium problem. After solving it, I determined this is not a medium problem. "
                    },
                    {
                        "username": "HackHustler",
                        "content": "easiest ever "
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": " `class Solution {\\n    static int[] dp;\\n    public int maxIceCream(int[] costs, int coins) {\\n        dp = new int[costs.length];\\n        Arrays.fill(dp , -1);\\n// Arrays.sort(costs);\\n        return helper(costs , coins , 0);\\n    }\\n    private int helper(int[] costs , int remCoins , int start) {\\n        if(remCoins <= 0 ) return 0;\\n        if(start == costs.length-1){\\n            if(costs[start] <= remCoins){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        if(dp[start] != -1) {\\n            return dp[start];\\n        }\\n        int take=0;\\n        int doesNot = 0;\\n        if(costs[start] <= remCoins) {\\n             take = 1 + helper(costs , remCoins - costs[start] , start +1) ;\\n        }\\n        doesNot = helper(costs , remCoins , start +1);\\n\\n        return dp[start] = Math.max(take , doesNot);\\n    }\\n}`\\nWhy this is not working ? in dp! like it goes to till certain test cases but then it doesn\\'t for rest!\\nBut it works perfectly once i sort the arrays from start, then what will be the point of even using dp? Can someone please tell me"
                    }
                ]
            },
            {
                "id": 1744246,
                "content": [
                    {
                        "username": "admschaaf",
                        "content": "The description should specify linear time if this is a medium problem."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Oh I love this Question \\uD83D\\uDE18"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Many people may get confused and can apply subset sum problem approach here but then they may get memory limit warning."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Similar to 0/1 Knapsack problem isn\\'t it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shounak Basu](/S_Basu)It is not similar, it is the same problem. Easiest greedy problem... and yet people are debating greedy vs DP in discussion"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "this should not be a problem"
                    },
                    {
                        "username": "debanjan2002",
                        "content": "This should definitely be an easy question. There is no complex logic required!"
                    },
                    {
                        "username": "Hrsh_123",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "schanjr",
                        "content": "I was shocked I solved a medium problem. After solving it, I determined this is not a medium problem. "
                    },
                    {
                        "username": "HackHustler",
                        "content": "easiest ever "
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": " `class Solution {\\n    static int[] dp;\\n    public int maxIceCream(int[] costs, int coins) {\\n        dp = new int[costs.length];\\n        Arrays.fill(dp , -1);\\n// Arrays.sort(costs);\\n        return helper(costs , coins , 0);\\n    }\\n    private int helper(int[] costs , int remCoins , int start) {\\n        if(remCoins <= 0 ) return 0;\\n        if(start == costs.length-1){\\n            if(costs[start] <= remCoins){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        if(dp[start] != -1) {\\n            return dp[start];\\n        }\\n        int take=0;\\n        int doesNot = 0;\\n        if(costs[start] <= remCoins) {\\n             take = 1 + helper(costs , remCoins - costs[start] , start +1) ;\\n        }\\n        doesNot = helper(costs , remCoins , start +1);\\n\\n        return dp[start] = Math.max(take , doesNot);\\n    }\\n}`\\nWhy this is not working ? in dp! like it goes to till certain test cases but then it doesn\\'t for rest!\\nBut it works perfectly once i sort the arrays from start, then what will be the point of even using dp? Can someone please tell me"
                    }
                ]
            },
            {
                "id": 1744245,
                "content": [
                    {
                        "username": "admschaaf",
                        "content": "The description should specify linear time if this is a medium problem."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Oh I love this Question \\uD83D\\uDE18"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Many people may get confused and can apply subset sum problem approach here but then they may get memory limit warning."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Similar to 0/1 Knapsack problem isn\\'t it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shounak Basu](/S_Basu)It is not similar, it is the same problem. Easiest greedy problem... and yet people are debating greedy vs DP in discussion"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "this should not be a problem"
                    },
                    {
                        "username": "debanjan2002",
                        "content": "This should definitely be an easy question. There is no complex logic required!"
                    },
                    {
                        "username": "Hrsh_123",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "schanjr",
                        "content": "I was shocked I solved a medium problem. After solving it, I determined this is not a medium problem. "
                    },
                    {
                        "username": "HackHustler",
                        "content": "easiest ever "
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": " `class Solution {\\n    static int[] dp;\\n    public int maxIceCream(int[] costs, int coins) {\\n        dp = new int[costs.length];\\n        Arrays.fill(dp , -1);\\n// Arrays.sort(costs);\\n        return helper(costs , coins , 0);\\n    }\\n    private int helper(int[] costs , int remCoins , int start) {\\n        if(remCoins <= 0 ) return 0;\\n        if(start == costs.length-1){\\n            if(costs[start] <= remCoins){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        if(dp[start] != -1) {\\n            return dp[start];\\n        }\\n        int take=0;\\n        int doesNot = 0;\\n        if(costs[start] <= remCoins) {\\n             take = 1 + helper(costs , remCoins - costs[start] , start +1) ;\\n        }\\n        doesNot = helper(costs , remCoins , start +1);\\n\\n        return dp[start] = Math.max(take , doesNot);\\n    }\\n}`\\nWhy this is not working ? in dp! like it goes to till certain test cases but then it doesn\\'t for rest!\\nBut it works perfectly once i sort the arrays from start, then what will be the point of even using dp? Can someone please tell me"
                    }
                ]
            },
            {
                "id": 1744244,
                "content": [
                    {
                        "username": "admschaaf",
                        "content": "The description should specify linear time if this is a medium problem."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Oh I love this Question \\uD83D\\uDE18"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Many people may get confused and can apply subset sum problem approach here but then they may get memory limit warning."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Similar to 0/1 Knapsack problem isn\\'t it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shounak Basu](/S_Basu)It is not similar, it is the same problem. Easiest greedy problem... and yet people are debating greedy vs DP in discussion"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "this should not be a problem"
                    },
                    {
                        "username": "debanjan2002",
                        "content": "This should definitely be an easy question. There is no complex logic required!"
                    },
                    {
                        "username": "Hrsh_123",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "schanjr",
                        "content": "I was shocked I solved a medium problem. After solving it, I determined this is not a medium problem. "
                    },
                    {
                        "username": "HackHustler",
                        "content": "easiest ever "
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": " `class Solution {\\n    static int[] dp;\\n    public int maxIceCream(int[] costs, int coins) {\\n        dp = new int[costs.length];\\n        Arrays.fill(dp , -1);\\n// Arrays.sort(costs);\\n        return helper(costs , coins , 0);\\n    }\\n    private int helper(int[] costs , int remCoins , int start) {\\n        if(remCoins <= 0 ) return 0;\\n        if(start == costs.length-1){\\n            if(costs[start] <= remCoins){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        if(dp[start] != -1) {\\n            return dp[start];\\n        }\\n        int take=0;\\n        int doesNot = 0;\\n        if(costs[start] <= remCoins) {\\n             take = 1 + helper(costs , remCoins - costs[start] , start +1) ;\\n        }\\n        doesNot = helper(costs , remCoins , start +1);\\n\\n        return dp[start] = Math.max(take , doesNot);\\n    }\\n}`\\nWhy this is not working ? in dp! like it goes to till certain test cases but then it doesn\\'t for rest!\\nBut it works perfectly once i sort the arrays from start, then what will be the point of even using dp? Can someone please tell me"
                    }
                ]
            },
            {
                "id": 1744233,
                "content": [
                    {
                        "username": "admschaaf",
                        "content": "The description should specify linear time if this is a medium problem."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Oh I love this Question \\uD83D\\uDE18"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Many people may get confused and can apply subset sum problem approach here but then they may get memory limit warning."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Similar to 0/1 Knapsack problem isn\\'t it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shounak Basu](/S_Basu)It is not similar, it is the same problem. Easiest greedy problem... and yet people are debating greedy vs DP in discussion"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "this should not be a problem"
                    },
                    {
                        "username": "debanjan2002",
                        "content": "This should definitely be an easy question. There is no complex logic required!"
                    },
                    {
                        "username": "Hrsh_123",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "schanjr",
                        "content": "I was shocked I solved a medium problem. After solving it, I determined this is not a medium problem. "
                    },
                    {
                        "username": "HackHustler",
                        "content": "easiest ever "
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": " `class Solution {\\n    static int[] dp;\\n    public int maxIceCream(int[] costs, int coins) {\\n        dp = new int[costs.length];\\n        Arrays.fill(dp , -1);\\n// Arrays.sort(costs);\\n        return helper(costs , coins , 0);\\n    }\\n    private int helper(int[] costs , int remCoins , int start) {\\n        if(remCoins <= 0 ) return 0;\\n        if(start == costs.length-1){\\n            if(costs[start] <= remCoins){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        if(dp[start] != -1) {\\n            return dp[start];\\n        }\\n        int take=0;\\n        int doesNot = 0;\\n        if(costs[start] <= remCoins) {\\n             take = 1 + helper(costs , remCoins - costs[start] , start +1) ;\\n        }\\n        doesNot = helper(costs , remCoins , start +1);\\n\\n        return dp[start] = Math.max(take , doesNot);\\n    }\\n}`\\nWhy this is not working ? in dp! like it goes to till certain test cases but then it doesn\\'t for rest!\\nBut it works perfectly once i sort the arrays from start, then what will be the point of even using dp? Can someone please tell me"
                    }
                ]
            },
            {
                "id": 1744225,
                "content": [
                    {
                        "username": "admschaaf",
                        "content": "The description should specify linear time if this is a medium problem."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Oh I love this Question \\uD83D\\uDE18"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Many people may get confused and can apply subset sum problem approach here but then they may get memory limit warning."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Similar to 0/1 Knapsack problem isn\\'t it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shounak Basu](/S_Basu)It is not similar, it is the same problem. Easiest greedy problem... and yet people are debating greedy vs DP in discussion"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "this should not be a problem"
                    },
                    {
                        "username": "debanjan2002",
                        "content": "This should definitely be an easy question. There is no complex logic required!"
                    },
                    {
                        "username": "Hrsh_123",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "schanjr",
                        "content": "I was shocked I solved a medium problem. After solving it, I determined this is not a medium problem. "
                    },
                    {
                        "username": "HackHustler",
                        "content": "easiest ever "
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": " `class Solution {\\n    static int[] dp;\\n    public int maxIceCream(int[] costs, int coins) {\\n        dp = new int[costs.length];\\n        Arrays.fill(dp , -1);\\n// Arrays.sort(costs);\\n        return helper(costs , coins , 0);\\n    }\\n    private int helper(int[] costs , int remCoins , int start) {\\n        if(remCoins <= 0 ) return 0;\\n        if(start == costs.length-1){\\n            if(costs[start] <= remCoins){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        if(dp[start] != -1) {\\n            return dp[start];\\n        }\\n        int take=0;\\n        int doesNot = 0;\\n        if(costs[start] <= remCoins) {\\n             take = 1 + helper(costs , remCoins - costs[start] , start +1) ;\\n        }\\n        doesNot = helper(costs , remCoins , start +1);\\n\\n        return dp[start] = Math.max(take , doesNot);\\n    }\\n}`\\nWhy this is not working ? in dp! like it goes to till certain test cases but then it doesn\\'t for rest!\\nBut it works perfectly once i sort the arrays from start, then what will be the point of even using dp? Can someone please tell me"
                    }
                ]
            },
            {
                "id": 1744218,
                "content": [
                    {
                        "username": "admschaaf",
                        "content": "The description should specify linear time if this is a medium problem."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Oh I love this Question \\uD83D\\uDE18"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Many people may get confused and can apply subset sum problem approach here but then they may get memory limit warning."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Similar to 0/1 Knapsack problem isn\\'t it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shounak Basu](/S_Basu)It is not similar, it is the same problem. Easiest greedy problem... and yet people are debating greedy vs DP in discussion"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "this should not be a problem"
                    },
                    {
                        "username": "debanjan2002",
                        "content": "This should definitely be an easy question. There is no complex logic required!"
                    },
                    {
                        "username": "Hrsh_123",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "schanjr",
                        "content": "I was shocked I solved a medium problem. After solving it, I determined this is not a medium problem. "
                    },
                    {
                        "username": "HackHustler",
                        "content": "easiest ever "
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": " `class Solution {\\n    static int[] dp;\\n    public int maxIceCream(int[] costs, int coins) {\\n        dp = new int[costs.length];\\n        Arrays.fill(dp , -1);\\n// Arrays.sort(costs);\\n        return helper(costs , coins , 0);\\n    }\\n    private int helper(int[] costs , int remCoins , int start) {\\n        if(remCoins <= 0 ) return 0;\\n        if(start == costs.length-1){\\n            if(costs[start] <= remCoins){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        if(dp[start] != -1) {\\n            return dp[start];\\n        }\\n        int take=0;\\n        int doesNot = 0;\\n        if(costs[start] <= remCoins) {\\n             take = 1 + helper(costs , remCoins - costs[start] , start +1) ;\\n        }\\n        doesNot = helper(costs , remCoins , start +1);\\n\\n        return dp[start] = Math.max(take , doesNot);\\n    }\\n}`\\nWhy this is not working ? in dp! like it goes to till certain test cases but then it doesn\\'t for rest!\\nBut it works perfectly once i sort the arrays from start, then what will be the point of even using dp? Can someone please tell me"
                    }
                ]
            },
            {
                "id": 1744214,
                "content": [
                    {
                        "username": "admschaaf",
                        "content": "The description should specify linear time if this is a medium problem."
                    },
                    {
                        "username": "Bobzero",
                        "content": "Oh I love this Question \\uD83D\\uDE18"
                    },
                    {
                        "username": "karan_cpp_py",
                        "content": "Many people may get confused and can apply subset sum problem approach here but then they may get memory limit warning."
                    },
                    {
                        "username": "S_Basu",
                        "content": "Similar to 0/1 Knapsack problem isn\\'t it?"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Shounak Basu](/S_Basu)It is not similar, it is the same problem. Easiest greedy problem... and yet people are debating greedy vs DP in discussion"
                    },
                    {
                        "username": "Mike_Rye",
                        "content": "this should not be a problem"
                    },
                    {
                        "username": "debanjan2002",
                        "content": "This should definitely be an easy question. There is no complex logic required!"
                    },
                    {
                        "username": "Hrsh_123",
                        "content": "This should be an easy problem"
                    },
                    {
                        "username": "schanjr",
                        "content": "I was shocked I solved a medium problem. After solving it, I determined this is not a medium problem. "
                    },
                    {
                        "username": "HackHustler",
                        "content": "easiest ever "
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": " `class Solution {\\n    static int[] dp;\\n    public int maxIceCream(int[] costs, int coins) {\\n        dp = new int[costs.length];\\n        Arrays.fill(dp , -1);\\n// Arrays.sort(costs);\\n        return helper(costs , coins , 0);\\n    }\\n    private int helper(int[] costs , int remCoins , int start) {\\n        if(remCoins <= 0 ) return 0;\\n        if(start == costs.length-1){\\n            if(costs[start] <= remCoins){\\n                return 1;\\n            }\\n            else{\\n                return 0;\\n            }\\n        }\\n        if(dp[start] != -1) {\\n            return dp[start];\\n        }\\n        int take=0;\\n        int doesNot = 0;\\n        if(costs[start] <= remCoins) {\\n             take = 1 + helper(costs , remCoins - costs[start] , start +1) ;\\n        }\\n        doesNot = helper(costs , remCoins , start +1);\\n\\n        return dp[start] = Math.max(take , doesNot);\\n    }\\n}`\\nWhy this is not working ? in dp! like it goes to till certain test cases but then it doesn\\'t for rest!\\nBut it works perfectly once i sort the arrays from start, then what will be the point of even using dp? Can someone please tell me"
                    }
                ]
            },
            {
                "id": 1744210,
                "content": [
                    {
                        "username": "mayank_pant",
                        "content": "So I thought this problm might be similar to the coin exchange problem and kept thinking why a greedy solution wouldnt work. Couldnt think of a reason so just tried the solution expecting it to be wrong. To my surprise it wasnt."
                    },
                    {
                        "username": "FireDragon124225",
                        "content": "I think the question should mention that one ice-cream could be bought only once"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "What is this ahahahahah"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Me solving Medium Level Problem in the first Attemp.\nLe Confidance: 100% Boost up\nProblem is similar with 01 kanpsack Problem"
                    },
                    {
                        "username": "Bobby710",
                        "content": "CAN WE SOLVE THE PROBLEM IN O(N) TIME COMPLEXITY??"
                    },
                    {
                        "username": "kuldip_01",
                        "content": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin() ,costs.end());\\n        int c=0;\\n        for(int i=0; i<costs.size(); i++)\\n        {\\n            if(coins - costs[i] >=0)\\n            {\\n                c++;\\n                coins-=costs[i];\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return c;\\n\\n    }\\n};"
                    },
                    {
                        "username": "korakagaj",
                        "content": "Medium..LOL"
                    },
                    {
                        "username": "prtyhr",
                        "content": "This should be marked easy (sort array and use greedy approach)"
                    },
                    {
                        "username": "tendencymilk",
                        "content": "So easy, it must be a easy problem."
                    },
                    {
                        "username": "rohit_213",
                        "content": "Who kept it in medium?"
                    }
                ]
            },
            {
                "id": 1744194,
                "content": [
                    {
                        "username": "mayank_pant",
                        "content": "So I thought this problm might be similar to the coin exchange problem and kept thinking why a greedy solution wouldnt work. Couldnt think of a reason so just tried the solution expecting it to be wrong. To my surprise it wasnt."
                    },
                    {
                        "username": "FireDragon124225",
                        "content": "I think the question should mention that one ice-cream could be bought only once"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "What is this ahahahahah"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Me solving Medium Level Problem in the first Attemp.\nLe Confidance: 100% Boost up\nProblem is similar with 01 kanpsack Problem"
                    },
                    {
                        "username": "Bobby710",
                        "content": "CAN WE SOLVE THE PROBLEM IN O(N) TIME COMPLEXITY??"
                    },
                    {
                        "username": "kuldip_01",
                        "content": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin() ,costs.end());\\n        int c=0;\\n        for(int i=0; i<costs.size(); i++)\\n        {\\n            if(coins - costs[i] >=0)\\n            {\\n                c++;\\n                coins-=costs[i];\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return c;\\n\\n    }\\n};"
                    },
                    {
                        "username": "korakagaj",
                        "content": "Medium..LOL"
                    },
                    {
                        "username": "prtyhr",
                        "content": "This should be marked easy (sort array and use greedy approach)"
                    },
                    {
                        "username": "tendencymilk",
                        "content": "So easy, it must be a easy problem."
                    },
                    {
                        "username": "rohit_213",
                        "content": "Who kept it in medium?"
                    }
                ]
            },
            {
                "id": 1744184,
                "content": [
                    {
                        "username": "mayank_pant",
                        "content": "So I thought this problm might be similar to the coin exchange problem and kept thinking why a greedy solution wouldnt work. Couldnt think of a reason so just tried the solution expecting it to be wrong. To my surprise it wasnt."
                    },
                    {
                        "username": "FireDragon124225",
                        "content": "I think the question should mention that one ice-cream could be bought only once"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "What is this ahahahahah"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Me solving Medium Level Problem in the first Attemp.\nLe Confidance: 100% Boost up\nProblem is similar with 01 kanpsack Problem"
                    },
                    {
                        "username": "Bobby710",
                        "content": "CAN WE SOLVE THE PROBLEM IN O(N) TIME COMPLEXITY??"
                    },
                    {
                        "username": "kuldip_01",
                        "content": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin() ,costs.end());\\n        int c=0;\\n        for(int i=0; i<costs.size(); i++)\\n        {\\n            if(coins - costs[i] >=0)\\n            {\\n                c++;\\n                coins-=costs[i];\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return c;\\n\\n    }\\n};"
                    },
                    {
                        "username": "korakagaj",
                        "content": "Medium..LOL"
                    },
                    {
                        "username": "prtyhr",
                        "content": "This should be marked easy (sort array and use greedy approach)"
                    },
                    {
                        "username": "tendencymilk",
                        "content": "So easy, it must be a easy problem."
                    },
                    {
                        "username": "rohit_213",
                        "content": "Who kept it in medium?"
                    }
                ]
            },
            {
                "id": 1744176,
                "content": [
                    {
                        "username": "mayank_pant",
                        "content": "So I thought this problm might be similar to the coin exchange problem and kept thinking why a greedy solution wouldnt work. Couldnt think of a reason so just tried the solution expecting it to be wrong. To my surprise it wasnt."
                    },
                    {
                        "username": "FireDragon124225",
                        "content": "I think the question should mention that one ice-cream could be bought only once"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "What is this ahahahahah"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Me solving Medium Level Problem in the first Attemp.\nLe Confidance: 100% Boost up\nProblem is similar with 01 kanpsack Problem"
                    },
                    {
                        "username": "Bobby710",
                        "content": "CAN WE SOLVE THE PROBLEM IN O(N) TIME COMPLEXITY??"
                    },
                    {
                        "username": "kuldip_01",
                        "content": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin() ,costs.end());\\n        int c=0;\\n        for(int i=0; i<costs.size(); i++)\\n        {\\n            if(coins - costs[i] >=0)\\n            {\\n                c++;\\n                coins-=costs[i];\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return c;\\n\\n    }\\n};"
                    },
                    {
                        "username": "korakagaj",
                        "content": "Medium..LOL"
                    },
                    {
                        "username": "prtyhr",
                        "content": "This should be marked easy (sort array and use greedy approach)"
                    },
                    {
                        "username": "tendencymilk",
                        "content": "So easy, it must be a easy problem."
                    },
                    {
                        "username": "rohit_213",
                        "content": "Who kept it in medium?"
                    }
                ]
            },
            {
                "id": 1744163,
                "content": [
                    {
                        "username": "mayank_pant",
                        "content": "So I thought this problm might be similar to the coin exchange problem and kept thinking why a greedy solution wouldnt work. Couldnt think of a reason so just tried the solution expecting it to be wrong. To my surprise it wasnt."
                    },
                    {
                        "username": "FireDragon124225",
                        "content": "I think the question should mention that one ice-cream could be bought only once"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "What is this ahahahahah"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Me solving Medium Level Problem in the first Attemp.\nLe Confidance: 100% Boost up\nProblem is similar with 01 kanpsack Problem"
                    },
                    {
                        "username": "Bobby710",
                        "content": "CAN WE SOLVE THE PROBLEM IN O(N) TIME COMPLEXITY??"
                    },
                    {
                        "username": "kuldip_01",
                        "content": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin() ,costs.end());\\n        int c=0;\\n        for(int i=0; i<costs.size(); i++)\\n        {\\n            if(coins - costs[i] >=0)\\n            {\\n                c++;\\n                coins-=costs[i];\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return c;\\n\\n    }\\n};"
                    },
                    {
                        "username": "korakagaj",
                        "content": "Medium..LOL"
                    },
                    {
                        "username": "prtyhr",
                        "content": "This should be marked easy (sort array and use greedy approach)"
                    },
                    {
                        "username": "tendencymilk",
                        "content": "So easy, it must be a easy problem."
                    },
                    {
                        "username": "rohit_213",
                        "content": "Who kept it in medium?"
                    }
                ]
            },
            {
                "id": 1744148,
                "content": [
                    {
                        "username": "mayank_pant",
                        "content": "So I thought this problm might be similar to the coin exchange problem and kept thinking why a greedy solution wouldnt work. Couldnt think of a reason so just tried the solution expecting it to be wrong. To my surprise it wasnt."
                    },
                    {
                        "username": "FireDragon124225",
                        "content": "I think the question should mention that one ice-cream could be bought only once"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "What is this ahahahahah"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Me solving Medium Level Problem in the first Attemp.\nLe Confidance: 100% Boost up\nProblem is similar with 01 kanpsack Problem"
                    },
                    {
                        "username": "Bobby710",
                        "content": "CAN WE SOLVE THE PROBLEM IN O(N) TIME COMPLEXITY??"
                    },
                    {
                        "username": "kuldip_01",
                        "content": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin() ,costs.end());\\n        int c=0;\\n        for(int i=0; i<costs.size(); i++)\\n        {\\n            if(coins - costs[i] >=0)\\n            {\\n                c++;\\n                coins-=costs[i];\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return c;\\n\\n    }\\n};"
                    },
                    {
                        "username": "korakagaj",
                        "content": "Medium..LOL"
                    },
                    {
                        "username": "prtyhr",
                        "content": "This should be marked easy (sort array and use greedy approach)"
                    },
                    {
                        "username": "tendencymilk",
                        "content": "So easy, it must be a easy problem."
                    },
                    {
                        "username": "rohit_213",
                        "content": "Who kept it in medium?"
                    }
                ]
            },
            {
                "id": 1744144,
                "content": [
                    {
                        "username": "mayank_pant",
                        "content": "So I thought this problm might be similar to the coin exchange problem and kept thinking why a greedy solution wouldnt work. Couldnt think of a reason so just tried the solution expecting it to be wrong. To my surprise it wasnt."
                    },
                    {
                        "username": "FireDragon124225",
                        "content": "I think the question should mention that one ice-cream could be bought only once"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "What is this ahahahahah"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Me solving Medium Level Problem in the first Attemp.\nLe Confidance: 100% Boost up\nProblem is similar with 01 kanpsack Problem"
                    },
                    {
                        "username": "Bobby710",
                        "content": "CAN WE SOLVE THE PROBLEM IN O(N) TIME COMPLEXITY??"
                    },
                    {
                        "username": "kuldip_01",
                        "content": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin() ,costs.end());\\n        int c=0;\\n        for(int i=0; i<costs.size(); i++)\\n        {\\n            if(coins - costs[i] >=0)\\n            {\\n                c++;\\n                coins-=costs[i];\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return c;\\n\\n    }\\n};"
                    },
                    {
                        "username": "korakagaj",
                        "content": "Medium..LOL"
                    },
                    {
                        "username": "prtyhr",
                        "content": "This should be marked easy (sort array and use greedy approach)"
                    },
                    {
                        "username": "tendencymilk",
                        "content": "So easy, it must be a easy problem."
                    },
                    {
                        "username": "rohit_213",
                        "content": "Who kept it in medium?"
                    }
                ]
            },
            {
                "id": 1744142,
                "content": [
                    {
                        "username": "mayank_pant",
                        "content": "So I thought this problm might be similar to the coin exchange problem and kept thinking why a greedy solution wouldnt work. Couldnt think of a reason so just tried the solution expecting it to be wrong. To my surprise it wasnt."
                    },
                    {
                        "username": "FireDragon124225",
                        "content": "I think the question should mention that one ice-cream could be bought only once"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "What is this ahahahahah"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Me solving Medium Level Problem in the first Attemp.\nLe Confidance: 100% Boost up\nProblem is similar with 01 kanpsack Problem"
                    },
                    {
                        "username": "Bobby710",
                        "content": "CAN WE SOLVE THE PROBLEM IN O(N) TIME COMPLEXITY??"
                    },
                    {
                        "username": "kuldip_01",
                        "content": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin() ,costs.end());\\n        int c=0;\\n        for(int i=0; i<costs.size(); i++)\\n        {\\n            if(coins - costs[i] >=0)\\n            {\\n                c++;\\n                coins-=costs[i];\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return c;\\n\\n    }\\n};"
                    },
                    {
                        "username": "korakagaj",
                        "content": "Medium..LOL"
                    },
                    {
                        "username": "prtyhr",
                        "content": "This should be marked easy (sort array and use greedy approach)"
                    },
                    {
                        "username": "tendencymilk",
                        "content": "So easy, it must be a easy problem."
                    },
                    {
                        "username": "rohit_213",
                        "content": "Who kept it in medium?"
                    }
                ]
            },
            {
                "id": 1744136,
                "content": [
                    {
                        "username": "mayank_pant",
                        "content": "So I thought this problm might be similar to the coin exchange problem and kept thinking why a greedy solution wouldnt work. Couldnt think of a reason so just tried the solution expecting it to be wrong. To my surprise it wasnt."
                    },
                    {
                        "username": "FireDragon124225",
                        "content": "I think the question should mention that one ice-cream could be bought only once"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "What is this ahahahahah"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Me solving Medium Level Problem in the first Attemp.\nLe Confidance: 100% Boost up\nProblem is similar with 01 kanpsack Problem"
                    },
                    {
                        "username": "Bobby710",
                        "content": "CAN WE SOLVE THE PROBLEM IN O(N) TIME COMPLEXITY??"
                    },
                    {
                        "username": "kuldip_01",
                        "content": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin() ,costs.end());\\n        int c=0;\\n        for(int i=0; i<costs.size(); i++)\\n        {\\n            if(coins - costs[i] >=0)\\n            {\\n                c++;\\n                coins-=costs[i];\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return c;\\n\\n    }\\n};"
                    },
                    {
                        "username": "korakagaj",
                        "content": "Medium..LOL"
                    },
                    {
                        "username": "prtyhr",
                        "content": "This should be marked easy (sort array and use greedy approach)"
                    },
                    {
                        "username": "tendencymilk",
                        "content": "So easy, it must be a easy problem."
                    },
                    {
                        "username": "rohit_213",
                        "content": "Who kept it in medium?"
                    }
                ]
            },
            {
                "id": 1744132,
                "content": [
                    {
                        "username": "mayank_pant",
                        "content": "So I thought this problm might be similar to the coin exchange problem and kept thinking why a greedy solution wouldnt work. Couldnt think of a reason so just tried the solution expecting it to be wrong. To my surprise it wasnt."
                    },
                    {
                        "username": "FireDragon124225",
                        "content": "I think the question should mention that one ice-cream could be bought only once"
                    },
                    {
                        "username": "IamAJ22",
                        "content": "What is this ahahahahah"
                    },
                    {
                        "username": "rohitramteke",
                        "content": "Me solving Medium Level Problem in the first Attemp.\nLe Confidance: 100% Boost up\nProblem is similar with 01 kanpsack Problem"
                    },
                    {
                        "username": "Bobby710",
                        "content": "CAN WE SOLVE THE PROBLEM IN O(N) TIME COMPLEXITY??"
                    },
                    {
                        "username": "kuldip_01",
                        "content": "class Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n        sort(costs.begin() ,costs.end());\\n        int c=0;\\n        for(int i=0; i<costs.size(); i++)\\n        {\\n            if(coins - costs[i] >=0)\\n            {\\n                c++;\\n                coins-=costs[i];\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return c;\\n\\n    }\\n};"
                    },
                    {
                        "username": "korakagaj",
                        "content": "Medium..LOL"
                    },
                    {
                        "username": "prtyhr",
                        "content": "This should be marked easy (sort array and use greedy approach)"
                    },
                    {
                        "username": "tendencymilk",
                        "content": "So easy, it must be a easy problem."
                    },
                    {
                        "username": "rohit_213",
                        "content": "Who kept it in medium?"
                    }
                ]
            },
            {
                "id": 1744129,
                "content": [
                    {
                        "username": "ylchao",
                        "content": "Why does the runtime vary so much in python submissions? The same solution can beat from 6% to 57%. Was there a change to testcases?\\n"
                    },
                    {
                        "username": "aman_soni_5632",
                        "content": "// Easiest Solution C++ || using sorting || O(n) solution\\n\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n\\n       // sort the costs in ascending order as we want to find maximum number of ice creams\\n       // which can happen if it purchases chepest ice cream first.\\n        sort(costs.begin(),costs.end());\\n        int sum = 0;\\n        int count = 0;\\n\\n    // if total cost > coins then that means coins get empty\\n    // while if cost <= coins then it can still buy ice cream so count more number of ice creams\\n        for(int i=0;i<costs.size();i++){\\n            sum += costs[i];\\n            if(sum <= coins){\\n                count++;\\n            }\\n      \\n            if(sum > coins){\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "xyp7x",
                        "content": "if you are sorting, the solution is no longer O(N)"
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This is too easy for a medium problem"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "       \\n                   \\n   class Solution:\\n        def maxIceCream(self, costs: List[int], coins: int) -> int:\\n              costs.sort()\\n             for i in range(len(costs)):\\n                  coins -= costs[i]\\n                   if coins < 0:\\n                      return i\\n             return len(costs)\\n\\n             ans=0\\n            costs.sort()\\n            for x,y in enumerate(costs):\\n                  if coins<y:\\n                     break\\n                 ans=ans + 1\\n                 costs-coins+y\\n           return ans\\n       "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This should be marked as easy"
                    },
                    {
                        "username": "be_upriser",
                        "content": "can we done this question without sorting the array use of two pointer approach?\\n"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "Why can\\'t we apply  `0/1 knapsack type problem here` ? \\nCause after looking up to the question we have : an array and we have to return the maximum to this both follows the knapsack rule : 2/3 which means that it has to be knapsack type right?"
                    },
                    {
                        "username": "raashish-aggarwal909",
                        "content": "May everyone\\'s life be as easy as this question :)"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "Try to do in time comlexity -->O(N) \\nhint : Count Sort"
                    },
                    {
                        "username": "sravan127",
                        "content": "No way this is a medium problem\\uD83D\\uDC80"
                    }
                ]
            },
            {
                "id": 1744125,
                "content": [
                    {
                        "username": "ylchao",
                        "content": "Why does the runtime vary so much in python submissions? The same solution can beat from 6% to 57%. Was there a change to testcases?\\n"
                    },
                    {
                        "username": "aman_soni_5632",
                        "content": "// Easiest Solution C++ || using sorting || O(n) solution\\n\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n\\n       // sort the costs in ascending order as we want to find maximum number of ice creams\\n       // which can happen if it purchases chepest ice cream first.\\n        sort(costs.begin(),costs.end());\\n        int sum = 0;\\n        int count = 0;\\n\\n    // if total cost > coins then that means coins get empty\\n    // while if cost <= coins then it can still buy ice cream so count more number of ice creams\\n        for(int i=0;i<costs.size();i++){\\n            sum += costs[i];\\n            if(sum <= coins){\\n                count++;\\n            }\\n      \\n            if(sum > coins){\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "xyp7x",
                        "content": "if you are sorting, the solution is no longer O(N)"
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This is too easy for a medium problem"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "       \\n                   \\n   class Solution:\\n        def maxIceCream(self, costs: List[int], coins: int) -> int:\\n              costs.sort()\\n             for i in range(len(costs)):\\n                  coins -= costs[i]\\n                   if coins < 0:\\n                      return i\\n             return len(costs)\\n\\n             ans=0\\n            costs.sort()\\n            for x,y in enumerate(costs):\\n                  if coins<y:\\n                     break\\n                 ans=ans + 1\\n                 costs-coins+y\\n           return ans\\n       "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This should be marked as easy"
                    },
                    {
                        "username": "be_upriser",
                        "content": "can we done this question without sorting the array use of two pointer approach?\\n"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "Why can\\'t we apply  `0/1 knapsack type problem here` ? \\nCause after looking up to the question we have : an array and we have to return the maximum to this both follows the knapsack rule : 2/3 which means that it has to be knapsack type right?"
                    },
                    {
                        "username": "raashish-aggarwal909",
                        "content": "May everyone\\'s life be as easy as this question :)"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "Try to do in time comlexity -->O(N) \\nhint : Count Sort"
                    },
                    {
                        "username": "sravan127",
                        "content": "No way this is a medium problem\\uD83D\\uDC80"
                    }
                ]
            },
            {
                "id": 1744124,
                "content": [
                    {
                        "username": "ylchao",
                        "content": "Why does the runtime vary so much in python submissions? The same solution can beat from 6% to 57%. Was there a change to testcases?\\n"
                    },
                    {
                        "username": "aman_soni_5632",
                        "content": "// Easiest Solution C++ || using sorting || O(n) solution\\n\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n\\n       // sort the costs in ascending order as we want to find maximum number of ice creams\\n       // which can happen if it purchases chepest ice cream first.\\n        sort(costs.begin(),costs.end());\\n        int sum = 0;\\n        int count = 0;\\n\\n    // if total cost > coins then that means coins get empty\\n    // while if cost <= coins then it can still buy ice cream so count more number of ice creams\\n        for(int i=0;i<costs.size();i++){\\n            sum += costs[i];\\n            if(sum <= coins){\\n                count++;\\n            }\\n      \\n            if(sum > coins){\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "xyp7x",
                        "content": "if you are sorting, the solution is no longer O(N)"
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This is too easy for a medium problem"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "       \\n                   \\n   class Solution:\\n        def maxIceCream(self, costs: List[int], coins: int) -> int:\\n              costs.sort()\\n             for i in range(len(costs)):\\n                  coins -= costs[i]\\n                   if coins < 0:\\n                      return i\\n             return len(costs)\\n\\n             ans=0\\n            costs.sort()\\n            for x,y in enumerate(costs):\\n                  if coins<y:\\n                     break\\n                 ans=ans + 1\\n                 costs-coins+y\\n           return ans\\n       "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This should be marked as easy"
                    },
                    {
                        "username": "be_upriser",
                        "content": "can we done this question without sorting the array use of two pointer approach?\\n"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "Why can\\'t we apply  `0/1 knapsack type problem here` ? \\nCause after looking up to the question we have : an array and we have to return the maximum to this both follows the knapsack rule : 2/3 which means that it has to be knapsack type right?"
                    },
                    {
                        "username": "raashish-aggarwal909",
                        "content": "May everyone\\'s life be as easy as this question :)"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "Try to do in time comlexity -->O(N) \\nhint : Count Sort"
                    },
                    {
                        "username": "sravan127",
                        "content": "No way this is a medium problem\\uD83D\\uDC80"
                    }
                ]
            },
            {
                "id": 1744117,
                "content": [
                    {
                        "username": "ylchao",
                        "content": "Why does the runtime vary so much in python submissions? The same solution can beat from 6% to 57%. Was there a change to testcases?\\n"
                    },
                    {
                        "username": "aman_soni_5632",
                        "content": "// Easiest Solution C++ || using sorting || O(n) solution\\n\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n\\n       // sort the costs in ascending order as we want to find maximum number of ice creams\\n       // which can happen if it purchases chepest ice cream first.\\n        sort(costs.begin(),costs.end());\\n        int sum = 0;\\n        int count = 0;\\n\\n    // if total cost > coins then that means coins get empty\\n    // while if cost <= coins then it can still buy ice cream so count more number of ice creams\\n        for(int i=0;i<costs.size();i++){\\n            sum += costs[i];\\n            if(sum <= coins){\\n                count++;\\n            }\\n      \\n            if(sum > coins){\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "xyp7x",
                        "content": "if you are sorting, the solution is no longer O(N)"
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This is too easy for a medium problem"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "       \\n                   \\n   class Solution:\\n        def maxIceCream(self, costs: List[int], coins: int) -> int:\\n              costs.sort()\\n             for i in range(len(costs)):\\n                  coins -= costs[i]\\n                   if coins < 0:\\n                      return i\\n             return len(costs)\\n\\n             ans=0\\n            costs.sort()\\n            for x,y in enumerate(costs):\\n                  if coins<y:\\n                     break\\n                 ans=ans + 1\\n                 costs-coins+y\\n           return ans\\n       "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This should be marked as easy"
                    },
                    {
                        "username": "be_upriser",
                        "content": "can we done this question without sorting the array use of two pointer approach?\\n"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "Why can\\'t we apply  `0/1 knapsack type problem here` ? \\nCause after looking up to the question we have : an array and we have to return the maximum to this both follows the knapsack rule : 2/3 which means that it has to be knapsack type right?"
                    },
                    {
                        "username": "raashish-aggarwal909",
                        "content": "May everyone\\'s life be as easy as this question :)"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "Try to do in time comlexity -->O(N) \\nhint : Count Sort"
                    },
                    {
                        "username": "sravan127",
                        "content": "No way this is a medium problem\\uD83D\\uDC80"
                    }
                ]
            },
            {
                "id": 1744100,
                "content": [
                    {
                        "username": "ylchao",
                        "content": "Why does the runtime vary so much in python submissions? The same solution can beat from 6% to 57%. Was there a change to testcases?\\n"
                    },
                    {
                        "username": "aman_soni_5632",
                        "content": "// Easiest Solution C++ || using sorting || O(n) solution\\n\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n\\n       // sort the costs in ascending order as we want to find maximum number of ice creams\\n       // which can happen if it purchases chepest ice cream first.\\n        sort(costs.begin(),costs.end());\\n        int sum = 0;\\n        int count = 0;\\n\\n    // if total cost > coins then that means coins get empty\\n    // while if cost <= coins then it can still buy ice cream so count more number of ice creams\\n        for(int i=0;i<costs.size();i++){\\n            sum += costs[i];\\n            if(sum <= coins){\\n                count++;\\n            }\\n      \\n            if(sum > coins){\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "xyp7x",
                        "content": "if you are sorting, the solution is no longer O(N)"
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This is too easy for a medium problem"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "       \\n                   \\n   class Solution:\\n        def maxIceCream(self, costs: List[int], coins: int) -> int:\\n              costs.sort()\\n             for i in range(len(costs)):\\n                  coins -= costs[i]\\n                   if coins < 0:\\n                      return i\\n             return len(costs)\\n\\n             ans=0\\n            costs.sort()\\n            for x,y in enumerate(costs):\\n                  if coins<y:\\n                     break\\n                 ans=ans + 1\\n                 costs-coins+y\\n           return ans\\n       "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This should be marked as easy"
                    },
                    {
                        "username": "be_upriser",
                        "content": "can we done this question without sorting the array use of two pointer approach?\\n"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "Why can\\'t we apply  `0/1 knapsack type problem here` ? \\nCause after looking up to the question we have : an array and we have to return the maximum to this both follows the knapsack rule : 2/3 which means that it has to be knapsack type right?"
                    },
                    {
                        "username": "raashish-aggarwal909",
                        "content": "May everyone\\'s life be as easy as this question :)"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "Try to do in time comlexity -->O(N) \\nhint : Count Sort"
                    },
                    {
                        "username": "sravan127",
                        "content": "No way this is a medium problem\\uD83D\\uDC80"
                    }
                ]
            },
            {
                "id": 1744088,
                "content": [
                    {
                        "username": "ylchao",
                        "content": "Why does the runtime vary so much in python submissions? The same solution can beat from 6% to 57%. Was there a change to testcases?\\n"
                    },
                    {
                        "username": "aman_soni_5632",
                        "content": "// Easiest Solution C++ || using sorting || O(n) solution\\n\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n\\n       // sort the costs in ascending order as we want to find maximum number of ice creams\\n       // which can happen if it purchases chepest ice cream first.\\n        sort(costs.begin(),costs.end());\\n        int sum = 0;\\n        int count = 0;\\n\\n    // if total cost > coins then that means coins get empty\\n    // while if cost <= coins then it can still buy ice cream so count more number of ice creams\\n        for(int i=0;i<costs.size();i++){\\n            sum += costs[i];\\n            if(sum <= coins){\\n                count++;\\n            }\\n      \\n            if(sum > coins){\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "xyp7x",
                        "content": "if you are sorting, the solution is no longer O(N)"
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This is too easy for a medium problem"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "       \\n                   \\n   class Solution:\\n        def maxIceCream(self, costs: List[int], coins: int) -> int:\\n              costs.sort()\\n             for i in range(len(costs)):\\n                  coins -= costs[i]\\n                   if coins < 0:\\n                      return i\\n             return len(costs)\\n\\n             ans=0\\n            costs.sort()\\n            for x,y in enumerate(costs):\\n                  if coins<y:\\n                     break\\n                 ans=ans + 1\\n                 costs-coins+y\\n           return ans\\n       "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This should be marked as easy"
                    },
                    {
                        "username": "be_upriser",
                        "content": "can we done this question without sorting the array use of two pointer approach?\\n"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "Why can\\'t we apply  `0/1 knapsack type problem here` ? \\nCause after looking up to the question we have : an array and we have to return the maximum to this both follows the knapsack rule : 2/3 which means that it has to be knapsack type right?"
                    },
                    {
                        "username": "raashish-aggarwal909",
                        "content": "May everyone\\'s life be as easy as this question :)"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "Try to do in time comlexity -->O(N) \\nhint : Count Sort"
                    },
                    {
                        "username": "sravan127",
                        "content": "No way this is a medium problem\\uD83D\\uDC80"
                    }
                ]
            },
            {
                "id": 1744064,
                "content": [
                    {
                        "username": "ylchao",
                        "content": "Why does the runtime vary so much in python submissions? The same solution can beat from 6% to 57%. Was there a change to testcases?\\n"
                    },
                    {
                        "username": "aman_soni_5632",
                        "content": "// Easiest Solution C++ || using sorting || O(n) solution\\n\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n\\n       // sort the costs in ascending order as we want to find maximum number of ice creams\\n       // which can happen if it purchases chepest ice cream first.\\n        sort(costs.begin(),costs.end());\\n        int sum = 0;\\n        int count = 0;\\n\\n    // if total cost > coins then that means coins get empty\\n    // while if cost <= coins then it can still buy ice cream so count more number of ice creams\\n        for(int i=0;i<costs.size();i++){\\n            sum += costs[i];\\n            if(sum <= coins){\\n                count++;\\n            }\\n      \\n            if(sum > coins){\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "xyp7x",
                        "content": "if you are sorting, the solution is no longer O(N)"
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This is too easy for a medium problem"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "       \\n                   \\n   class Solution:\\n        def maxIceCream(self, costs: List[int], coins: int) -> int:\\n              costs.sort()\\n             for i in range(len(costs)):\\n                  coins -= costs[i]\\n                   if coins < 0:\\n                      return i\\n             return len(costs)\\n\\n             ans=0\\n            costs.sort()\\n            for x,y in enumerate(costs):\\n                  if coins<y:\\n                     break\\n                 ans=ans + 1\\n                 costs-coins+y\\n           return ans\\n       "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This should be marked as easy"
                    },
                    {
                        "username": "be_upriser",
                        "content": "can we done this question without sorting the array use of two pointer approach?\\n"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "Why can\\'t we apply  `0/1 knapsack type problem here` ? \\nCause after looking up to the question we have : an array and we have to return the maximum to this both follows the knapsack rule : 2/3 which means that it has to be knapsack type right?"
                    },
                    {
                        "username": "raashish-aggarwal909",
                        "content": "May everyone\\'s life be as easy as this question :)"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "Try to do in time comlexity -->O(N) \\nhint : Count Sort"
                    },
                    {
                        "username": "sravan127",
                        "content": "No way this is a medium problem\\uD83D\\uDC80"
                    }
                ]
            },
            {
                "id": 1744059,
                "content": [
                    {
                        "username": "ylchao",
                        "content": "Why does the runtime vary so much in python submissions? The same solution can beat from 6% to 57%. Was there a change to testcases?\\n"
                    },
                    {
                        "username": "aman_soni_5632",
                        "content": "// Easiest Solution C++ || using sorting || O(n) solution\\n\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n\\n       // sort the costs in ascending order as we want to find maximum number of ice creams\\n       // which can happen if it purchases chepest ice cream first.\\n        sort(costs.begin(),costs.end());\\n        int sum = 0;\\n        int count = 0;\\n\\n    // if total cost > coins then that means coins get empty\\n    // while if cost <= coins then it can still buy ice cream so count more number of ice creams\\n        for(int i=0;i<costs.size();i++){\\n            sum += costs[i];\\n            if(sum <= coins){\\n                count++;\\n            }\\n      \\n            if(sum > coins){\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "xyp7x",
                        "content": "if you are sorting, the solution is no longer O(N)"
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This is too easy for a medium problem"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "       \\n                   \\n   class Solution:\\n        def maxIceCream(self, costs: List[int], coins: int) -> int:\\n              costs.sort()\\n             for i in range(len(costs)):\\n                  coins -= costs[i]\\n                   if coins < 0:\\n                      return i\\n             return len(costs)\\n\\n             ans=0\\n            costs.sort()\\n            for x,y in enumerate(costs):\\n                  if coins<y:\\n                     break\\n                 ans=ans + 1\\n                 costs-coins+y\\n           return ans\\n       "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This should be marked as easy"
                    },
                    {
                        "username": "be_upriser",
                        "content": "can we done this question without sorting the array use of two pointer approach?\\n"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "Why can\\'t we apply  `0/1 knapsack type problem here` ? \\nCause after looking up to the question we have : an array and we have to return the maximum to this both follows the knapsack rule : 2/3 which means that it has to be knapsack type right?"
                    },
                    {
                        "username": "raashish-aggarwal909",
                        "content": "May everyone\\'s life be as easy as this question :)"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "Try to do in time comlexity -->O(N) \\nhint : Count Sort"
                    },
                    {
                        "username": "sravan127",
                        "content": "No way this is a medium problem\\uD83D\\uDC80"
                    }
                ]
            },
            {
                "id": 1744034,
                "content": [
                    {
                        "username": "ylchao",
                        "content": "Why does the runtime vary so much in python submissions? The same solution can beat from 6% to 57%. Was there a change to testcases?\\n"
                    },
                    {
                        "username": "aman_soni_5632",
                        "content": "// Easiest Solution C++ || using sorting || O(n) solution\\n\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n\\n       // sort the costs in ascending order as we want to find maximum number of ice creams\\n       // which can happen if it purchases chepest ice cream first.\\n        sort(costs.begin(),costs.end());\\n        int sum = 0;\\n        int count = 0;\\n\\n    // if total cost > coins then that means coins get empty\\n    // while if cost <= coins then it can still buy ice cream so count more number of ice creams\\n        for(int i=0;i<costs.size();i++){\\n            sum += costs[i];\\n            if(sum <= coins){\\n                count++;\\n            }\\n      \\n            if(sum > coins){\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "xyp7x",
                        "content": "if you are sorting, the solution is no longer O(N)"
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This is too easy for a medium problem"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "       \\n                   \\n   class Solution:\\n        def maxIceCream(self, costs: List[int], coins: int) -> int:\\n              costs.sort()\\n             for i in range(len(costs)):\\n                  coins -= costs[i]\\n                   if coins < 0:\\n                      return i\\n             return len(costs)\\n\\n             ans=0\\n            costs.sort()\\n            for x,y in enumerate(costs):\\n                  if coins<y:\\n                     break\\n                 ans=ans + 1\\n                 costs-coins+y\\n           return ans\\n       "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This should be marked as easy"
                    },
                    {
                        "username": "be_upriser",
                        "content": "can we done this question without sorting the array use of two pointer approach?\\n"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "Why can\\'t we apply  `0/1 knapsack type problem here` ? \\nCause after looking up to the question we have : an array and we have to return the maximum to this both follows the knapsack rule : 2/3 which means that it has to be knapsack type right?"
                    },
                    {
                        "username": "raashish-aggarwal909",
                        "content": "May everyone\\'s life be as easy as this question :)"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "Try to do in time comlexity -->O(N) \\nhint : Count Sort"
                    },
                    {
                        "username": "sravan127",
                        "content": "No way this is a medium problem\\uD83D\\uDC80"
                    }
                ]
            },
            {
                "id": 1743983,
                "content": [
                    {
                        "username": "ylchao",
                        "content": "Why does the runtime vary so much in python submissions? The same solution can beat from 6% to 57%. Was there a change to testcases?\\n"
                    },
                    {
                        "username": "aman_soni_5632",
                        "content": "// Easiest Solution C++ || using sorting || O(n) solution\\n\\nclass Solution {\\npublic:\\n    int maxIceCream(vector<int>& costs, int coins) {\\n\\n       // sort the costs in ascending order as we want to find maximum number of ice creams\\n       // which can happen if it purchases chepest ice cream first.\\n        sort(costs.begin(),costs.end());\\n        int sum = 0;\\n        int count = 0;\\n\\n    // if total cost > coins then that means coins get empty\\n    // while if cost <= coins then it can still buy ice cream so count more number of ice creams\\n        for(int i=0;i<costs.size();i++){\\n            sum += costs[i];\\n            if(sum <= coins){\\n                count++;\\n            }\\n      \\n            if(sum > coins){\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n};"
                    },
                    {
                        "username": "xyp7x",
                        "content": "if you are sorting, the solution is no longer O(N)"
                    },
                    {
                        "username": "MinhUchiha",
                        "content": "This is too easy for a medium problem"
                    },
                    {
                        "username": "darasingh12998",
                        "content": "       \\n                   \\n   class Solution:\\n        def maxIceCream(self, costs: List[int], coins: int) -> int:\\n              costs.sort()\\n             for i in range(len(costs)):\\n                  coins -= costs[i]\\n                   if coins < 0:\\n                      return i\\n             return len(costs)\\n\\n             ans=0\\n            costs.sort()\\n            for x,y in enumerate(costs):\\n                  if coins<y:\\n                     break\\n                 ans=ans + 1\\n                 costs-coins+y\\n           return ans\\n       "
                    },
                    {
                        "username": "UVSinghK",
                        "content": "This should be marked as easy"
                    },
                    {
                        "username": "be_upriser",
                        "content": "can we done this question without sorting the array use of two pointer approach?\\n"
                    },
                    {
                        "username": "Vinay-Chaurasiya",
                        "content": "Why can\\'t we apply  `0/1 knapsack type problem here` ? \\nCause after looking up to the question we have : an array and we have to return the maximum to this both follows the knapsack rule : 2/3 which means that it has to be knapsack type right?"
                    },
                    {
                        "username": "raashish-aggarwal909",
                        "content": "May everyone\\'s life be as easy as this question :)"
                    },
                    {
                        "username": "kamalraj5544",
                        "content": "Try to do in time comlexity -->O(N) \\nhint : Count Sort"
                    },
                    {
                        "username": "sravan127",
                        "content": "No way this is a medium problem\\uD83D\\uDC80"
                    }
                ]
            },
            {
                "id": 1743981,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "*And today we learn how to* ***Sort***!!"
                    },
                    {
                        "username": "Deetav",
                        "content": "Me figuring out why this boy wants to buy maximum number of ice creams in this chilly weather \\uD83E\\uDD76"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Afzal543](/Afzal543) No need to be sad, he is a rich boy- rascal can afford upto 10^5 ice creams and that he is doing in the form of coins, should have given a cheque/ electronic transfer."
                    },
                    {
                        "username": "Afzal543",
                        "content": "I was sad because boy could\\'nt buy a single ice cream in testcase 2 "
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "1.Sort the costs array in non-ascending or ascending order. This will allow us to prioritize buying the cheaper ice cream bars first.\\n2.Initialize a variable to keep track of the number of ice cream bars we can buy.\\n3.Iterate through the sorted costs array. For each element in the array:\\ni.If we can afford to buy the ice cream bar, add it to the total and subtract the cost from our remaining coins.\\nii.If we can\\'t afford to buy the ice cream bar, we\\'re done.\\n4.Return the total number of ice cream bars we can buy."
                    },
                    {
                        "username": "yg7976077690",
                        "content": "so we can easily this question by sort first and traverse the bars and incresing the count and decreasing the coins.  \\n\\nint count=0;\\n        sort(costs.begin(),costs.end());\\n\\n        for(int i=0;i<costs.size();i++){\\n            if(coins>=costs[i]){\\n                count++;\\n                coins-=costs[i];\\n            }\\n        }\\n        return count;"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Easy though again!!!"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "Wow. This was easier than Fizzbuzz."
                    },
                    {
                        "username": "space_invader",
                        "content": "The new year\\'s holidays on leetcode are still going on... ah no, I forgot about yesterday\\'s daily problem"
                    },
                    {
                        "username": "Amyourkungepower",
                        "content": "not a dp"
                    },
                    {
                        "username": "pravinglkp",
                        "content": "This is easy question.\\n"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Difficulty should probably be changed, I solved this while my spaghetti was microwaving and I\\'m not an experienced dev."
                    }
                ]
            },
            {
                "id": 1743979,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "*And today we learn how to* ***Sort***!!"
                    },
                    {
                        "username": "Deetav",
                        "content": "Me figuring out why this boy wants to buy maximum number of ice creams in this chilly weather \\uD83E\\uDD76"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Afzal543](/Afzal543) No need to be sad, he is a rich boy- rascal can afford upto 10^5 ice creams and that he is doing in the form of coins, should have given a cheque/ electronic transfer."
                    },
                    {
                        "username": "Afzal543",
                        "content": "I was sad because boy could\\'nt buy a single ice cream in testcase 2 "
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "1.Sort the costs array in non-ascending or ascending order. This will allow us to prioritize buying the cheaper ice cream bars first.\\n2.Initialize a variable to keep track of the number of ice cream bars we can buy.\\n3.Iterate through the sorted costs array. For each element in the array:\\ni.If we can afford to buy the ice cream bar, add it to the total and subtract the cost from our remaining coins.\\nii.If we can\\'t afford to buy the ice cream bar, we\\'re done.\\n4.Return the total number of ice cream bars we can buy."
                    },
                    {
                        "username": "yg7976077690",
                        "content": "so we can easily this question by sort first and traverse the bars and incresing the count and decreasing the coins.  \\n\\nint count=0;\\n        sort(costs.begin(),costs.end());\\n\\n        for(int i=0;i<costs.size();i++){\\n            if(coins>=costs[i]){\\n                count++;\\n                coins-=costs[i];\\n            }\\n        }\\n        return count;"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Easy though again!!!"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "Wow. This was easier than Fizzbuzz."
                    },
                    {
                        "username": "space_invader",
                        "content": "The new year\\'s holidays on leetcode are still going on... ah no, I forgot about yesterday\\'s daily problem"
                    },
                    {
                        "username": "Amyourkungepower",
                        "content": "not a dp"
                    },
                    {
                        "username": "pravinglkp",
                        "content": "This is easy question.\\n"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Difficulty should probably be changed, I solved this while my spaghetti was microwaving and I\\'m not an experienced dev."
                    }
                ]
            },
            {
                "id": 1743969,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "*And today we learn how to* ***Sort***!!"
                    },
                    {
                        "username": "Deetav",
                        "content": "Me figuring out why this boy wants to buy maximum number of ice creams in this chilly weather \\uD83E\\uDD76"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Afzal543](/Afzal543) No need to be sad, he is a rich boy- rascal can afford upto 10^5 ice creams and that he is doing in the form of coins, should have given a cheque/ electronic transfer."
                    },
                    {
                        "username": "Afzal543",
                        "content": "I was sad because boy could\\'nt buy a single ice cream in testcase 2 "
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "1.Sort the costs array in non-ascending or ascending order. This will allow us to prioritize buying the cheaper ice cream bars first.\\n2.Initialize a variable to keep track of the number of ice cream bars we can buy.\\n3.Iterate through the sorted costs array. For each element in the array:\\ni.If we can afford to buy the ice cream bar, add it to the total and subtract the cost from our remaining coins.\\nii.If we can\\'t afford to buy the ice cream bar, we\\'re done.\\n4.Return the total number of ice cream bars we can buy."
                    },
                    {
                        "username": "yg7976077690",
                        "content": "so we can easily this question by sort first and traverse the bars and incresing the count and decreasing the coins.  \\n\\nint count=0;\\n        sort(costs.begin(),costs.end());\\n\\n        for(int i=0;i<costs.size();i++){\\n            if(coins>=costs[i]){\\n                count++;\\n                coins-=costs[i];\\n            }\\n        }\\n        return count;"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Easy though again!!!"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "Wow. This was easier than Fizzbuzz."
                    },
                    {
                        "username": "space_invader",
                        "content": "The new year\\'s holidays on leetcode are still going on... ah no, I forgot about yesterday\\'s daily problem"
                    },
                    {
                        "username": "Amyourkungepower",
                        "content": "not a dp"
                    },
                    {
                        "username": "pravinglkp",
                        "content": "This is easy question.\\n"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Difficulty should probably be changed, I solved this while my spaghetti was microwaving and I\\'m not an experienced dev."
                    }
                ]
            },
            {
                "id": 1743965,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "*And today we learn how to* ***Sort***!!"
                    },
                    {
                        "username": "Deetav",
                        "content": "Me figuring out why this boy wants to buy maximum number of ice creams in this chilly weather \\uD83E\\uDD76"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Afzal543](/Afzal543) No need to be sad, he is a rich boy- rascal can afford upto 10^5 ice creams and that he is doing in the form of coins, should have given a cheque/ electronic transfer."
                    },
                    {
                        "username": "Afzal543",
                        "content": "I was sad because boy could\\'nt buy a single ice cream in testcase 2 "
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "1.Sort the costs array in non-ascending or ascending order. This will allow us to prioritize buying the cheaper ice cream bars first.\\n2.Initialize a variable to keep track of the number of ice cream bars we can buy.\\n3.Iterate through the sorted costs array. For each element in the array:\\ni.If we can afford to buy the ice cream bar, add it to the total and subtract the cost from our remaining coins.\\nii.If we can\\'t afford to buy the ice cream bar, we\\'re done.\\n4.Return the total number of ice cream bars we can buy."
                    },
                    {
                        "username": "yg7976077690",
                        "content": "so we can easily this question by sort first and traverse the bars and incresing the count and decreasing the coins.  \\n\\nint count=0;\\n        sort(costs.begin(),costs.end());\\n\\n        for(int i=0;i<costs.size();i++){\\n            if(coins>=costs[i]){\\n                count++;\\n                coins-=costs[i];\\n            }\\n        }\\n        return count;"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Easy though again!!!"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "Wow. This was easier than Fizzbuzz."
                    },
                    {
                        "username": "space_invader",
                        "content": "The new year\\'s holidays on leetcode are still going on... ah no, I forgot about yesterday\\'s daily problem"
                    },
                    {
                        "username": "Amyourkungepower",
                        "content": "not a dp"
                    },
                    {
                        "username": "pravinglkp",
                        "content": "This is easy question.\\n"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Difficulty should probably be changed, I solved this while my spaghetti was microwaving and I\\'m not an experienced dev."
                    }
                ]
            },
            {
                "id": 1743937,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "*And today we learn how to* ***Sort***!!"
                    },
                    {
                        "username": "Deetav",
                        "content": "Me figuring out why this boy wants to buy maximum number of ice creams in this chilly weather \\uD83E\\uDD76"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Afzal543](/Afzal543) No need to be sad, he is a rich boy- rascal can afford upto 10^5 ice creams and that he is doing in the form of coins, should have given a cheque/ electronic transfer."
                    },
                    {
                        "username": "Afzal543",
                        "content": "I was sad because boy could\\'nt buy a single ice cream in testcase 2 "
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "1.Sort the costs array in non-ascending or ascending order. This will allow us to prioritize buying the cheaper ice cream bars first.\\n2.Initialize a variable to keep track of the number of ice cream bars we can buy.\\n3.Iterate through the sorted costs array. For each element in the array:\\ni.If we can afford to buy the ice cream bar, add it to the total and subtract the cost from our remaining coins.\\nii.If we can\\'t afford to buy the ice cream bar, we\\'re done.\\n4.Return the total number of ice cream bars we can buy."
                    },
                    {
                        "username": "yg7976077690",
                        "content": "so we can easily this question by sort first and traverse the bars and incresing the count and decreasing the coins.  \\n\\nint count=0;\\n        sort(costs.begin(),costs.end());\\n\\n        for(int i=0;i<costs.size();i++){\\n            if(coins>=costs[i]){\\n                count++;\\n                coins-=costs[i];\\n            }\\n        }\\n        return count;"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Easy though again!!!"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "Wow. This was easier than Fizzbuzz."
                    },
                    {
                        "username": "space_invader",
                        "content": "The new year\\'s holidays on leetcode are still going on... ah no, I forgot about yesterday\\'s daily problem"
                    },
                    {
                        "username": "Amyourkungepower",
                        "content": "not a dp"
                    },
                    {
                        "username": "pravinglkp",
                        "content": "This is easy question.\\n"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Difficulty should probably be changed, I solved this while my spaghetti was microwaving and I\\'m not an experienced dev."
                    }
                ]
            },
            {
                "id": 1743925,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "*And today we learn how to* ***Sort***!!"
                    },
                    {
                        "username": "Deetav",
                        "content": "Me figuring out why this boy wants to buy maximum number of ice creams in this chilly weather \\uD83E\\uDD76"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Afzal543](/Afzal543) No need to be sad, he is a rich boy- rascal can afford upto 10^5 ice creams and that he is doing in the form of coins, should have given a cheque/ electronic transfer."
                    },
                    {
                        "username": "Afzal543",
                        "content": "I was sad because boy could\\'nt buy a single ice cream in testcase 2 "
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "1.Sort the costs array in non-ascending or ascending order. This will allow us to prioritize buying the cheaper ice cream bars first.\\n2.Initialize a variable to keep track of the number of ice cream bars we can buy.\\n3.Iterate through the sorted costs array. For each element in the array:\\ni.If we can afford to buy the ice cream bar, add it to the total and subtract the cost from our remaining coins.\\nii.If we can\\'t afford to buy the ice cream bar, we\\'re done.\\n4.Return the total number of ice cream bars we can buy."
                    },
                    {
                        "username": "yg7976077690",
                        "content": "so we can easily this question by sort first and traverse the bars and incresing the count and decreasing the coins.  \\n\\nint count=0;\\n        sort(costs.begin(),costs.end());\\n\\n        for(int i=0;i<costs.size();i++){\\n            if(coins>=costs[i]){\\n                count++;\\n                coins-=costs[i];\\n            }\\n        }\\n        return count;"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Easy though again!!!"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "Wow. This was easier than Fizzbuzz."
                    },
                    {
                        "username": "space_invader",
                        "content": "The new year\\'s holidays on leetcode are still going on... ah no, I forgot about yesterday\\'s daily problem"
                    },
                    {
                        "username": "Amyourkungepower",
                        "content": "not a dp"
                    },
                    {
                        "username": "pravinglkp",
                        "content": "This is easy question.\\n"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Difficulty should probably be changed, I solved this while my spaghetti was microwaving and I\\'m not an experienced dev."
                    }
                ]
            },
            {
                "id": 1743914,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "*And today we learn how to* ***Sort***!!"
                    },
                    {
                        "username": "Deetav",
                        "content": "Me figuring out why this boy wants to buy maximum number of ice creams in this chilly weather \\uD83E\\uDD76"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Afzal543](/Afzal543) No need to be sad, he is a rich boy- rascal can afford upto 10^5 ice creams and that he is doing in the form of coins, should have given a cheque/ electronic transfer."
                    },
                    {
                        "username": "Afzal543",
                        "content": "I was sad because boy could\\'nt buy a single ice cream in testcase 2 "
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "1.Sort the costs array in non-ascending or ascending order. This will allow us to prioritize buying the cheaper ice cream bars first.\\n2.Initialize a variable to keep track of the number of ice cream bars we can buy.\\n3.Iterate through the sorted costs array. For each element in the array:\\ni.If we can afford to buy the ice cream bar, add it to the total and subtract the cost from our remaining coins.\\nii.If we can\\'t afford to buy the ice cream bar, we\\'re done.\\n4.Return the total number of ice cream bars we can buy."
                    },
                    {
                        "username": "yg7976077690",
                        "content": "so we can easily this question by sort first and traverse the bars and incresing the count and decreasing the coins.  \\n\\nint count=0;\\n        sort(costs.begin(),costs.end());\\n\\n        for(int i=0;i<costs.size();i++){\\n            if(coins>=costs[i]){\\n                count++;\\n                coins-=costs[i];\\n            }\\n        }\\n        return count;"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Easy though again!!!"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "Wow. This was easier than Fizzbuzz."
                    },
                    {
                        "username": "space_invader",
                        "content": "The new year\\'s holidays on leetcode are still going on... ah no, I forgot about yesterday\\'s daily problem"
                    },
                    {
                        "username": "Amyourkungepower",
                        "content": "not a dp"
                    },
                    {
                        "username": "pravinglkp",
                        "content": "This is easy question.\\n"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Difficulty should probably be changed, I solved this while my spaghetti was microwaving and I\\'m not an experienced dev."
                    }
                ]
            },
            {
                "id": 1743909,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "*And today we learn how to* ***Sort***!!"
                    },
                    {
                        "username": "Deetav",
                        "content": "Me figuring out why this boy wants to buy maximum number of ice creams in this chilly weather \\uD83E\\uDD76"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Afzal543](/Afzal543) No need to be sad, he is a rich boy- rascal can afford upto 10^5 ice creams and that he is doing in the form of coins, should have given a cheque/ electronic transfer."
                    },
                    {
                        "username": "Afzal543",
                        "content": "I was sad because boy could\\'nt buy a single ice cream in testcase 2 "
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "1.Sort the costs array in non-ascending or ascending order. This will allow us to prioritize buying the cheaper ice cream bars first.\\n2.Initialize a variable to keep track of the number of ice cream bars we can buy.\\n3.Iterate through the sorted costs array. For each element in the array:\\ni.If we can afford to buy the ice cream bar, add it to the total and subtract the cost from our remaining coins.\\nii.If we can\\'t afford to buy the ice cream bar, we\\'re done.\\n4.Return the total number of ice cream bars we can buy."
                    },
                    {
                        "username": "yg7976077690",
                        "content": "so we can easily this question by sort first and traverse the bars and incresing the count and decreasing the coins.  \\n\\nint count=0;\\n        sort(costs.begin(),costs.end());\\n\\n        for(int i=0;i<costs.size();i++){\\n            if(coins>=costs[i]){\\n                count++;\\n                coins-=costs[i];\\n            }\\n        }\\n        return count;"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Easy though again!!!"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "Wow. This was easier than Fizzbuzz."
                    },
                    {
                        "username": "space_invader",
                        "content": "The new year\\'s holidays on leetcode are still going on... ah no, I forgot about yesterday\\'s daily problem"
                    },
                    {
                        "username": "Amyourkungepower",
                        "content": "not a dp"
                    },
                    {
                        "username": "pravinglkp",
                        "content": "This is easy question.\\n"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Difficulty should probably be changed, I solved this while my spaghetti was microwaving and I\\'m not an experienced dev."
                    }
                ]
            },
            {
                "id": 1743906,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "*And today we learn how to* ***Sort***!!"
                    },
                    {
                        "username": "Deetav",
                        "content": "Me figuring out why this boy wants to buy maximum number of ice creams in this chilly weather \\uD83E\\uDD76"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Afzal543](/Afzal543) No need to be sad, he is a rich boy- rascal can afford upto 10^5 ice creams and that he is doing in the form of coins, should have given a cheque/ electronic transfer."
                    },
                    {
                        "username": "Afzal543",
                        "content": "I was sad because boy could\\'nt buy a single ice cream in testcase 2 "
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "1.Sort the costs array in non-ascending or ascending order. This will allow us to prioritize buying the cheaper ice cream bars first.\\n2.Initialize a variable to keep track of the number of ice cream bars we can buy.\\n3.Iterate through the sorted costs array. For each element in the array:\\ni.If we can afford to buy the ice cream bar, add it to the total and subtract the cost from our remaining coins.\\nii.If we can\\'t afford to buy the ice cream bar, we\\'re done.\\n4.Return the total number of ice cream bars we can buy."
                    },
                    {
                        "username": "yg7976077690",
                        "content": "so we can easily this question by sort first and traverse the bars and incresing the count and decreasing the coins.  \\n\\nint count=0;\\n        sort(costs.begin(),costs.end());\\n\\n        for(int i=0;i<costs.size();i++){\\n            if(coins>=costs[i]){\\n                count++;\\n                coins-=costs[i];\\n            }\\n        }\\n        return count;"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Easy though again!!!"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "Wow. This was easier than Fizzbuzz."
                    },
                    {
                        "username": "space_invader",
                        "content": "The new year\\'s holidays on leetcode are still going on... ah no, I forgot about yesterday\\'s daily problem"
                    },
                    {
                        "username": "Amyourkungepower",
                        "content": "not a dp"
                    },
                    {
                        "username": "pravinglkp",
                        "content": "This is easy question.\\n"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Difficulty should probably be changed, I solved this while my spaghetti was microwaving and I\\'m not an experienced dev."
                    }
                ]
            },
            {
                "id": 1743889,
                "content": [
                    {
                        "username": "shriyansnaik",
                        "content": "*And today we learn how to* ***Sort***!!"
                    },
                    {
                        "username": "Deetav",
                        "content": "Me figuring out why this boy wants to buy maximum number of ice creams in this chilly weather \\uD83E\\uDD76"
                    },
                    {
                        "username": "sarpalmadhav",
                        "content": "[@Afzal543](/Afzal543) No need to be sad, he is a rich boy- rascal can afford upto 10^5 ice creams and that he is doing in the form of coins, should have given a cheque/ electronic transfer."
                    },
                    {
                        "username": "Afzal543",
                        "content": "I was sad because boy could\\'nt buy a single ice cream in testcase 2 "
                    },
                    {
                        "username": "arpana_singh_27",
                        "content": "1.Sort the costs array in non-ascending or ascending order. This will allow us to prioritize buying the cheaper ice cream bars first.\\n2.Initialize a variable to keep track of the number of ice cream bars we can buy.\\n3.Iterate through the sorted costs array. For each element in the array:\\ni.If we can afford to buy the ice cream bar, add it to the total and subtract the cost from our remaining coins.\\nii.If we can\\'t afford to buy the ice cream bar, we\\'re done.\\n4.Return the total number of ice cream bars we can buy."
                    },
                    {
                        "username": "yg7976077690",
                        "content": "so we can easily this question by sort first and traverse the bars and incresing the count and decreasing the coins.  \\n\\nint count=0;\\n        sort(costs.begin(),costs.end());\\n\\n        for(int i=0;i<costs.size();i++){\\n            if(coins>=costs[i]){\\n                count++;\\n                coins-=costs[i];\\n            }\\n        }\\n        return count;"
                    },
                    {
                        "username": "aneesh1029",
                        "content": "Easy though again!!!"
                    },
                    {
                        "username": "leetcode_user_noob",
                        "content": "Wow. This was easier than Fizzbuzz."
                    },
                    {
                        "username": "space_invader",
                        "content": "The new year\\'s holidays on leetcode are still going on... ah no, I forgot about yesterday\\'s daily problem"
                    },
                    {
                        "username": "Amyourkungepower",
                        "content": "not a dp"
                    },
                    {
                        "username": "pravinglkp",
                        "content": "This is easy question.\\n"
                    },
                    {
                        "username": "KershKersh",
                        "content": "Difficulty should probably be changed, I solved this while my spaghetti was microwaving and I\\'m not an experienced dev."
                    }
                ]
            },
            {
                "id": 1743888,
                "content": [
                    {
                        "username": "2498pulkit",
                        "content": "This should have been the easy problem.\\n"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "should be converted into a dp problem"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Love this one! Done with today\\u2019s challenge:)"
                    },
                    {
                        "username": "ramakant",
                        "content": "if you think its easy, try to do this in O(n)"
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be rated as easy."
                    },
                    {
                        "username": "iamkhs",
                        "content": "people are saying this is easy question\\uD83D\\uDE22 i\\'m trying since 1 hour, i couldn\\'t solve it, i\\'m so dumb, feeling depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Leetcode is high on dsa xD."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "We need max indexes to add to spend our coins!"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "Sorting or Heap?"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "Yes"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Such a simple question in medium category! I think, leetcode people are seeing if anyone tries with DP to get TLE!!!!"
                    }
                ]
            },
            {
                "id": 1743864,
                "content": [
                    {
                        "username": "2498pulkit",
                        "content": "This should have been the easy problem.\\n"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "should be converted into a dp problem"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Love this one! Done with today\\u2019s challenge:)"
                    },
                    {
                        "username": "ramakant",
                        "content": "if you think its easy, try to do this in O(n)"
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be rated as easy."
                    },
                    {
                        "username": "iamkhs",
                        "content": "people are saying this is easy question\\uD83D\\uDE22 i\\'m trying since 1 hour, i couldn\\'t solve it, i\\'m so dumb, feeling depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Leetcode is high on dsa xD."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "We need max indexes to add to spend our coins!"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "Sorting or Heap?"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "Yes"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Such a simple question in medium category! I think, leetcode people are seeing if anyone tries with DP to get TLE!!!!"
                    }
                ]
            },
            {
                "id": 1743849,
                "content": [
                    {
                        "username": "2498pulkit",
                        "content": "This should have been the easy problem.\\n"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "should be converted into a dp problem"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Love this one! Done with today\\u2019s challenge:)"
                    },
                    {
                        "username": "ramakant",
                        "content": "if you think its easy, try to do this in O(n)"
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be rated as easy."
                    },
                    {
                        "username": "iamkhs",
                        "content": "people are saying this is easy question\\uD83D\\uDE22 i\\'m trying since 1 hour, i couldn\\'t solve it, i\\'m so dumb, feeling depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Leetcode is high on dsa xD."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "We need max indexes to add to spend our coins!"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "Sorting or Heap?"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "Yes"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Such a simple question in medium category! I think, leetcode people are seeing if anyone tries with DP to get TLE!!!!"
                    }
                ]
            },
            {
                "id": 1743846,
                "content": [
                    {
                        "username": "2498pulkit",
                        "content": "This should have been the easy problem.\\n"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "should be converted into a dp problem"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Love this one! Done with today\\u2019s challenge:)"
                    },
                    {
                        "username": "ramakant",
                        "content": "if you think its easy, try to do this in O(n)"
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be rated as easy."
                    },
                    {
                        "username": "iamkhs",
                        "content": "people are saying this is easy question\\uD83D\\uDE22 i\\'m trying since 1 hour, i couldn\\'t solve it, i\\'m so dumb, feeling depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Leetcode is high on dsa xD."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "We need max indexes to add to spend our coins!"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "Sorting or Heap?"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "Yes"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Such a simple question in medium category! I think, leetcode people are seeing if anyone tries with DP to get TLE!!!!"
                    }
                ]
            },
            {
                "id": 1743843,
                "content": [
                    {
                        "username": "2498pulkit",
                        "content": "This should have been the easy problem.\\n"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "should be converted into a dp problem"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Love this one! Done with today\\u2019s challenge:)"
                    },
                    {
                        "username": "ramakant",
                        "content": "if you think its easy, try to do this in O(n)"
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be rated as easy."
                    },
                    {
                        "username": "iamkhs",
                        "content": "people are saying this is easy question\\uD83D\\uDE22 i\\'m trying since 1 hour, i couldn\\'t solve it, i\\'m so dumb, feeling depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Leetcode is high on dsa xD."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "We need max indexes to add to spend our coins!"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "Sorting or Heap?"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "Yes"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Such a simple question in medium category! I think, leetcode people are seeing if anyone tries with DP to get TLE!!!!"
                    }
                ]
            },
            {
                "id": 1743840,
                "content": [
                    {
                        "username": "2498pulkit",
                        "content": "This should have been the easy problem.\\n"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "should be converted into a dp problem"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Love this one! Done with today\\u2019s challenge:)"
                    },
                    {
                        "username": "ramakant",
                        "content": "if you think its easy, try to do this in O(n)"
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be rated as easy."
                    },
                    {
                        "username": "iamkhs",
                        "content": "people are saying this is easy question\\uD83D\\uDE22 i\\'m trying since 1 hour, i couldn\\'t solve it, i\\'m so dumb, feeling depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Leetcode is high on dsa xD."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "We need max indexes to add to spend our coins!"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "Sorting or Heap?"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "Yes"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Such a simple question in medium category! I think, leetcode people are seeing if anyone tries with DP to get TLE!!!!"
                    }
                ]
            },
            {
                "id": 1743835,
                "content": [
                    {
                        "username": "2498pulkit",
                        "content": "This should have been the easy problem.\\n"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "should be converted into a dp problem"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Love this one! Done with today\\u2019s challenge:)"
                    },
                    {
                        "username": "ramakant",
                        "content": "if you think its easy, try to do this in O(n)"
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be rated as easy."
                    },
                    {
                        "username": "iamkhs",
                        "content": "people are saying this is easy question\\uD83D\\uDE22 i\\'m trying since 1 hour, i couldn\\'t solve it, i\\'m so dumb, feeling depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Leetcode is high on dsa xD."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "We need max indexes to add to spend our coins!"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "Sorting or Heap?"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "Yes"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Such a simple question in medium category! I think, leetcode people are seeing if anyone tries with DP to get TLE!!!!"
                    }
                ]
            },
            {
                "id": 1743831,
                "content": [
                    {
                        "username": "2498pulkit",
                        "content": "This should have been the easy problem.\\n"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "should be converted into a dp problem"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Love this one! Done with today\\u2019s challenge:)"
                    },
                    {
                        "username": "ramakant",
                        "content": "if you think its easy, try to do this in O(n)"
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be rated as easy."
                    },
                    {
                        "username": "iamkhs",
                        "content": "people are saying this is easy question\\uD83D\\uDE22 i\\'m trying since 1 hour, i couldn\\'t solve it, i\\'m so dumb, feeling depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Leetcode is high on dsa xD."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "We need max indexes to add to spend our coins!"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "Sorting or Heap?"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "Yes"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Such a simple question in medium category! I think, leetcode people are seeing if anyone tries with DP to get TLE!!!!"
                    }
                ]
            },
            {
                "id": 1743830,
                "content": [
                    {
                        "username": "2498pulkit",
                        "content": "This should have been the easy problem.\\n"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "should be converted into a dp problem"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Love this one! Done with today\\u2019s challenge:)"
                    },
                    {
                        "username": "ramakant",
                        "content": "if you think its easy, try to do this in O(n)"
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be rated as easy."
                    },
                    {
                        "username": "iamkhs",
                        "content": "people are saying this is easy question\\uD83D\\uDE22 i\\'m trying since 1 hour, i couldn\\'t solve it, i\\'m so dumb, feeling depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Leetcode is high on dsa xD."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "We need max indexes to add to spend our coins!"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "Sorting or Heap?"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "Yes"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Such a simple question in medium category! I think, leetcode people are seeing if anyone tries with DP to get TLE!!!!"
                    }
                ]
            },
            {
                "id": 1743829,
                "content": [
                    {
                        "username": "2498pulkit",
                        "content": "This should have been the easy problem.\\n"
                    },
                    {
                        "username": "crazysamurai",
                        "content": "should be converted into a dp problem"
                    },
                    {
                        "username": "xeniawann",
                        "content": "Love this one! Done with today\\u2019s challenge:)"
                    },
                    {
                        "username": "ramakant",
                        "content": "if you think its easy, try to do this in O(n)"
                    },
                    {
                        "username": "lebaur",
                        "content": "Should be rated as easy."
                    },
                    {
                        "username": "iamkhs",
                        "content": "people are saying this is easy question\\uD83D\\uDE22 i\\'m trying since 1 hour, i couldn\\'t solve it, i\\'m so dumb, feeling depressed\\uD83D\\uDE13"
                    },
                    {
                        "username": "dumb_me",
                        "content": "Leetcode is high on dsa xD."
                    },
                    {
                        "username": "rushi_4123",
                        "content": "We need max indexes to add to spend our coins!"
                    },
                    {
                        "username": "Andrew_2018_11",
                        "content": "Sorting or Heap?"
                    },
                    {
                        "username": "xswzaq44321",
                        "content": "Yes"
                    },
                    {
                        "username": "rushi_4123",
                        "content": "Such a simple question in medium category! I think, leetcode people are seeing if anyone tries with DP to get TLE!!!!"
                    }
                ]
            },
            {
                "id": 1743828,
                "content": [
                    {
                        "username": "Derithus",
                        "content": "Most medium problem in Ohio"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Go Greedy!"
                    },
                    {
                        "username": "jga111",
                        "content": "Yes this is easy if you wanna head for the O(n log n) solution. Medium-easy for O(n). "
                    },
                    {
                        "username": "vghoghari82",
                        "content": "Is it me only that it should be tagged as an easy problem?"
                    },
                    {
                        "username": "Umair9912",
                        "content": "What.\\n"
                    },
                    {
                        "username": "zgigix",
                        "content": "Honestly, the easiest thing in my life. I don't know why it is classified as medium"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Why is this tagged as medium ????"
                    },
                    {
                        "username": "zhuoya-li",
                        "content": "so hard. "
                    },
                    {
                        "username": "dallaylaen",
                        "content": "I\\'m seeing basically the same solution (in JS) running anywhere from 247ms to ~600ms. Kind of puzzled... Is it ok?"
                    },
                    {
                        "username": "shrined",
                        "content": "This is an easy-easy. "
                    }
                ]
            },
            {
                "id": 1743817,
                "content": [
                    {
                        "username": "Derithus",
                        "content": "Most medium problem in Ohio"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Go Greedy!"
                    },
                    {
                        "username": "jga111",
                        "content": "Yes this is easy if you wanna head for the O(n log n) solution. Medium-easy for O(n). "
                    },
                    {
                        "username": "vghoghari82",
                        "content": "Is it me only that it should be tagged as an easy problem?"
                    },
                    {
                        "username": "Umair9912",
                        "content": "What.\\n"
                    },
                    {
                        "username": "zgigix",
                        "content": "Honestly, the easiest thing in my life. I don't know why it is classified as medium"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Why is this tagged as medium ????"
                    },
                    {
                        "username": "zhuoya-li",
                        "content": "so hard. "
                    },
                    {
                        "username": "dallaylaen",
                        "content": "I\\'m seeing basically the same solution (in JS) running anywhere from 247ms to ~600ms. Kind of puzzled... Is it ok?"
                    },
                    {
                        "username": "shrined",
                        "content": "This is an easy-easy. "
                    }
                ]
            },
            {
                "id": 1743783,
                "content": [
                    {
                        "username": "Derithus",
                        "content": "Most medium problem in Ohio"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Go Greedy!"
                    },
                    {
                        "username": "jga111",
                        "content": "Yes this is easy if you wanna head for the O(n log n) solution. Medium-easy for O(n). "
                    },
                    {
                        "username": "vghoghari82",
                        "content": "Is it me only that it should be tagged as an easy problem?"
                    },
                    {
                        "username": "Umair9912",
                        "content": "What.\\n"
                    },
                    {
                        "username": "zgigix",
                        "content": "Honestly, the easiest thing in my life. I don't know why it is classified as medium"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Why is this tagged as medium ????"
                    },
                    {
                        "username": "zhuoya-li",
                        "content": "so hard. "
                    },
                    {
                        "username": "dallaylaen",
                        "content": "I\\'m seeing basically the same solution (in JS) running anywhere from 247ms to ~600ms. Kind of puzzled... Is it ok?"
                    },
                    {
                        "username": "shrined",
                        "content": "This is an easy-easy. "
                    }
                ]
            },
            {
                "id": 1743775,
                "content": [
                    {
                        "username": "Derithus",
                        "content": "Most medium problem in Ohio"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Go Greedy!"
                    },
                    {
                        "username": "jga111",
                        "content": "Yes this is easy if you wanna head for the O(n log n) solution. Medium-easy for O(n). "
                    },
                    {
                        "username": "vghoghari82",
                        "content": "Is it me only that it should be tagged as an easy problem?"
                    },
                    {
                        "username": "Umair9912",
                        "content": "What.\\n"
                    },
                    {
                        "username": "zgigix",
                        "content": "Honestly, the easiest thing in my life. I don't know why it is classified as medium"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Why is this tagged as medium ????"
                    },
                    {
                        "username": "zhuoya-li",
                        "content": "so hard. "
                    },
                    {
                        "username": "dallaylaen",
                        "content": "I\\'m seeing basically the same solution (in JS) running anywhere from 247ms to ~600ms. Kind of puzzled... Is it ok?"
                    },
                    {
                        "username": "shrined",
                        "content": "This is an easy-easy. "
                    }
                ]
            },
            {
                "id": 1743743,
                "content": [
                    {
                        "username": "Derithus",
                        "content": "Most medium problem in Ohio"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Go Greedy!"
                    },
                    {
                        "username": "jga111",
                        "content": "Yes this is easy if you wanna head for the O(n log n) solution. Medium-easy for O(n). "
                    },
                    {
                        "username": "vghoghari82",
                        "content": "Is it me only that it should be tagged as an easy problem?"
                    },
                    {
                        "username": "Umair9912",
                        "content": "What.\\n"
                    },
                    {
                        "username": "zgigix",
                        "content": "Honestly, the easiest thing in my life. I don't know why it is classified as medium"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Why is this tagged as medium ????"
                    },
                    {
                        "username": "zhuoya-li",
                        "content": "so hard. "
                    },
                    {
                        "username": "dallaylaen",
                        "content": "I\\'m seeing basically the same solution (in JS) running anywhere from 247ms to ~600ms. Kind of puzzled... Is it ok?"
                    },
                    {
                        "username": "shrined",
                        "content": "This is an easy-easy. "
                    }
                ]
            },
            {
                "id": 1743722,
                "content": [
                    {
                        "username": "Derithus",
                        "content": "Most medium problem in Ohio"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Go Greedy!"
                    },
                    {
                        "username": "jga111",
                        "content": "Yes this is easy if you wanna head for the O(n log n) solution. Medium-easy for O(n). "
                    },
                    {
                        "username": "vghoghari82",
                        "content": "Is it me only that it should be tagged as an easy problem?"
                    },
                    {
                        "username": "Umair9912",
                        "content": "What.\\n"
                    },
                    {
                        "username": "zgigix",
                        "content": "Honestly, the easiest thing in my life. I don't know why it is classified as medium"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Why is this tagged as medium ????"
                    },
                    {
                        "username": "zhuoya-li",
                        "content": "so hard. "
                    },
                    {
                        "username": "dallaylaen",
                        "content": "I\\'m seeing basically the same solution (in JS) running anywhere from 247ms to ~600ms. Kind of puzzled... Is it ok?"
                    },
                    {
                        "username": "shrined",
                        "content": "This is an easy-easy. "
                    }
                ]
            },
            {
                "id": 1743721,
                "content": [
                    {
                        "username": "Derithus",
                        "content": "Most medium problem in Ohio"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Go Greedy!"
                    },
                    {
                        "username": "jga111",
                        "content": "Yes this is easy if you wanna head for the O(n log n) solution. Medium-easy for O(n). "
                    },
                    {
                        "username": "vghoghari82",
                        "content": "Is it me only that it should be tagged as an easy problem?"
                    },
                    {
                        "username": "Umair9912",
                        "content": "What.\\n"
                    },
                    {
                        "username": "zgigix",
                        "content": "Honestly, the easiest thing in my life. I don't know why it is classified as medium"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Why is this tagged as medium ????"
                    },
                    {
                        "username": "zhuoya-li",
                        "content": "so hard. "
                    },
                    {
                        "username": "dallaylaen",
                        "content": "I\\'m seeing basically the same solution (in JS) running anywhere from 247ms to ~600ms. Kind of puzzled... Is it ok?"
                    },
                    {
                        "username": "shrined",
                        "content": "This is an easy-easy. "
                    }
                ]
            },
            {
                "id": 1743712,
                "content": [
                    {
                        "username": "Derithus",
                        "content": "Most medium problem in Ohio"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Go Greedy!"
                    },
                    {
                        "username": "jga111",
                        "content": "Yes this is easy if you wanna head for the O(n log n) solution. Medium-easy for O(n). "
                    },
                    {
                        "username": "vghoghari82",
                        "content": "Is it me only that it should be tagged as an easy problem?"
                    },
                    {
                        "username": "Umair9912",
                        "content": "What.\\n"
                    },
                    {
                        "username": "zgigix",
                        "content": "Honestly, the easiest thing in my life. I don't know why it is classified as medium"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Why is this tagged as medium ????"
                    },
                    {
                        "username": "zhuoya-li",
                        "content": "so hard. "
                    },
                    {
                        "username": "dallaylaen",
                        "content": "I\\'m seeing basically the same solution (in JS) running anywhere from 247ms to ~600ms. Kind of puzzled... Is it ok?"
                    },
                    {
                        "username": "shrined",
                        "content": "This is an easy-easy. "
                    }
                ]
            },
            {
                "id": 1743711,
                "content": [
                    {
                        "username": "Derithus",
                        "content": "Most medium problem in Ohio"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Go Greedy!"
                    },
                    {
                        "username": "jga111",
                        "content": "Yes this is easy if you wanna head for the O(n log n) solution. Medium-easy for O(n). "
                    },
                    {
                        "username": "vghoghari82",
                        "content": "Is it me only that it should be tagged as an easy problem?"
                    },
                    {
                        "username": "Umair9912",
                        "content": "What.\\n"
                    },
                    {
                        "username": "zgigix",
                        "content": "Honestly, the easiest thing in my life. I don't know why it is classified as medium"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Why is this tagged as medium ????"
                    },
                    {
                        "username": "zhuoya-li",
                        "content": "so hard. "
                    },
                    {
                        "username": "dallaylaen",
                        "content": "I\\'m seeing basically the same solution (in JS) running anywhere from 247ms to ~600ms. Kind of puzzled... Is it ok?"
                    },
                    {
                        "username": "shrined",
                        "content": "This is an easy-easy. "
                    }
                ]
            },
            {
                "id": 1743710,
                "content": [
                    {
                        "username": "Derithus",
                        "content": "Most medium problem in Ohio"
                    },
                    {
                        "username": "brijKhajuria",
                        "content": "Go Greedy!"
                    },
                    {
                        "username": "jga111",
                        "content": "Yes this is easy if you wanna head for the O(n log n) solution. Medium-easy for O(n). "
                    },
                    {
                        "username": "vghoghari82",
                        "content": "Is it me only that it should be tagged as an easy problem?"
                    },
                    {
                        "username": "Umair9912",
                        "content": "What.\\n"
                    },
                    {
                        "username": "zgigix",
                        "content": "Honestly, the easiest thing in my life. I don't know why it is classified as medium"
                    },
                    {
                        "username": "Ashwin_Acharya",
                        "content": "Why is this tagged as medium ????"
                    },
                    {
                        "username": "zhuoya-li",
                        "content": "so hard. "
                    },
                    {
                        "username": "dallaylaen",
                        "content": "I\\'m seeing basically the same solution (in JS) running anywhere from 247ms to ~600ms. Kind of puzzled... Is it ok?"
                    },
                    {
                        "username": "shrined",
                        "content": "This is an easy-easy. "
                    }
                ]
            },
            {
                "id": 1743707,
                "content": [
                    {
                        "username": "nishantk3101",
                        "content": "Easy questions be like - \"Shall i leave my job\" \\uD83D\\uDE11"
                    },
                    {
                        "username": "glitchedturtle",
                        "content": "\"medium\""
                    },
                    {
                        "username": "k2bilimo",
                        "content": "Greedy: Sort the costs array least->greatest. "
                    },
                    {
                        "username": "benyamin137928",
                        "content": "What is the point of this question? Sorting and selecting greedy is the easiest solution that will come to mind at first, Why this is a medium question? Is there a tricky and better than nlogn time solution?"
                    },
                    {
                        "username": "jotho_",
                        "content": "You can try hitting Submit without hitting Run :)  Also, using a linear bucket sort with division instead of counting makes it more challenging"
                    },
                    {
                        "username": "yaseenalk",
                        "content": "Weird problem to suggest counting sort IMO. The range of possible costs is pretty big, as is the range of coins."
                    },
                    {
                        "username": "soumita_basu",
                        "content": "( Didn't expect this question to be of medium level :})\nThis problem is easy if the logic is clear. You can solve this way.\n\nInitialize sum=0 and count=0\nSort the array costs\n\nNext, we will include:\nIf costs[0] = coins, return 1\nElse If costs[0] > coins, return 0\nElse initiate a for loop from 0 to size of array, incrementing by 1 in which we will add the ith element till the sum gets greater than the value of coins. If the sum gets greater than the value of coins then we will break the statement else count++\n\nReturn count\n\nLink to solution for better understanding: [https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3005126/simple-c-code/\n](https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3005126/simple-c-code/\n)\nHope it helps :)"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Literally Everyone : Waiting for new Problem of the Day so that I can write something in discussion and get upvotes \\uD83D\\uDE02"
                    },
                    {
                        "username": "omscode",
                        "content": "Its rubbish question . even i solved this in first attempt \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "Easy disguised as Medium.. :D "
                    },
                    {
                        "username": "adityasinghz",
                        "content": "How it can be in medium category? XD"
                    }
                ]
            },
            {
                "id": 1743698,
                "content": [
                    {
                        "username": "nishantk3101",
                        "content": "Easy questions be like - \"Shall i leave my job\" \\uD83D\\uDE11"
                    },
                    {
                        "username": "glitchedturtle",
                        "content": "\"medium\""
                    },
                    {
                        "username": "k2bilimo",
                        "content": "Greedy: Sort the costs array least->greatest. "
                    },
                    {
                        "username": "benyamin137928",
                        "content": "What is the point of this question? Sorting and selecting greedy is the easiest solution that will come to mind at first, Why this is a medium question? Is there a tricky and better than nlogn time solution?"
                    },
                    {
                        "username": "jotho_",
                        "content": "You can try hitting Submit without hitting Run :)  Also, using a linear bucket sort with division instead of counting makes it more challenging"
                    },
                    {
                        "username": "yaseenalk",
                        "content": "Weird problem to suggest counting sort IMO. The range of possible costs is pretty big, as is the range of coins."
                    },
                    {
                        "username": "soumita_basu",
                        "content": "( Didn't expect this question to be of medium level :})\nThis problem is easy if the logic is clear. You can solve this way.\n\nInitialize sum=0 and count=0\nSort the array costs\n\nNext, we will include:\nIf costs[0] = coins, return 1\nElse If costs[0] > coins, return 0\nElse initiate a for loop from 0 to size of array, incrementing by 1 in which we will add the ith element till the sum gets greater than the value of coins. If the sum gets greater than the value of coins then we will break the statement else count++\n\nReturn count\n\nLink to solution for better understanding: [https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3005126/simple-c-code/\n](https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3005126/simple-c-code/\n)\nHope it helps :)"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Literally Everyone : Waiting for new Problem of the Day so that I can write something in discussion and get upvotes \\uD83D\\uDE02"
                    },
                    {
                        "username": "omscode",
                        "content": "Its rubbish question . even i solved this in first attempt \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "Easy disguised as Medium.. :D "
                    },
                    {
                        "username": "adityasinghz",
                        "content": "How it can be in medium category? XD"
                    }
                ]
            },
            {
                "id": 1743697,
                "content": [
                    {
                        "username": "nishantk3101",
                        "content": "Easy questions be like - \"Shall i leave my job\" \\uD83D\\uDE11"
                    },
                    {
                        "username": "glitchedturtle",
                        "content": "\"medium\""
                    },
                    {
                        "username": "k2bilimo",
                        "content": "Greedy: Sort the costs array least->greatest. "
                    },
                    {
                        "username": "benyamin137928",
                        "content": "What is the point of this question? Sorting and selecting greedy is the easiest solution that will come to mind at first, Why this is a medium question? Is there a tricky and better than nlogn time solution?"
                    },
                    {
                        "username": "jotho_",
                        "content": "You can try hitting Submit without hitting Run :)  Also, using a linear bucket sort with division instead of counting makes it more challenging"
                    },
                    {
                        "username": "yaseenalk",
                        "content": "Weird problem to suggest counting sort IMO. The range of possible costs is pretty big, as is the range of coins."
                    },
                    {
                        "username": "soumita_basu",
                        "content": "( Didn't expect this question to be of medium level :})\nThis problem is easy if the logic is clear. You can solve this way.\n\nInitialize sum=0 and count=0\nSort the array costs\n\nNext, we will include:\nIf costs[0] = coins, return 1\nElse If costs[0] > coins, return 0\nElse initiate a for loop from 0 to size of array, incrementing by 1 in which we will add the ith element till the sum gets greater than the value of coins. If the sum gets greater than the value of coins then we will break the statement else count++\n\nReturn count\n\nLink to solution for better understanding: [https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3005126/simple-c-code/\n](https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3005126/simple-c-code/\n)\nHope it helps :)"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Literally Everyone : Waiting for new Problem of the Day so that I can write something in discussion and get upvotes \\uD83D\\uDE02"
                    },
                    {
                        "username": "omscode",
                        "content": "Its rubbish question . even i solved this in first attempt \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "Easy disguised as Medium.. :D "
                    },
                    {
                        "username": "adityasinghz",
                        "content": "How it can be in medium category? XD"
                    }
                ]
            },
            {
                "id": 1743694,
                "content": [
                    {
                        "username": "nishantk3101",
                        "content": "Easy questions be like - \"Shall i leave my job\" \\uD83D\\uDE11"
                    },
                    {
                        "username": "glitchedturtle",
                        "content": "\"medium\""
                    },
                    {
                        "username": "k2bilimo",
                        "content": "Greedy: Sort the costs array least->greatest. "
                    },
                    {
                        "username": "benyamin137928",
                        "content": "What is the point of this question? Sorting and selecting greedy is the easiest solution that will come to mind at first, Why this is a medium question? Is there a tricky and better than nlogn time solution?"
                    },
                    {
                        "username": "jotho_",
                        "content": "You can try hitting Submit without hitting Run :)  Also, using a linear bucket sort with division instead of counting makes it more challenging"
                    },
                    {
                        "username": "yaseenalk",
                        "content": "Weird problem to suggest counting sort IMO. The range of possible costs is pretty big, as is the range of coins."
                    },
                    {
                        "username": "soumita_basu",
                        "content": "( Didn't expect this question to be of medium level :})\nThis problem is easy if the logic is clear. You can solve this way.\n\nInitialize sum=0 and count=0\nSort the array costs\n\nNext, we will include:\nIf costs[0] = coins, return 1\nElse If costs[0] > coins, return 0\nElse initiate a for loop from 0 to size of array, incrementing by 1 in which we will add the ith element till the sum gets greater than the value of coins. If the sum gets greater than the value of coins then we will break the statement else count++\n\nReturn count\n\nLink to solution for better understanding: [https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3005126/simple-c-code/\n](https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3005126/simple-c-code/\n)\nHope it helps :)"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Literally Everyone : Waiting for new Problem of the Day so that I can write something in discussion and get upvotes \\uD83D\\uDE02"
                    },
                    {
                        "username": "omscode",
                        "content": "Its rubbish question . even i solved this in first attempt \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "Easy disguised as Medium.. :D "
                    },
                    {
                        "username": "adityasinghz",
                        "content": "How it can be in medium category? XD"
                    }
                ]
            },
            {
                "id": 1743689,
                "content": [
                    {
                        "username": "nishantk3101",
                        "content": "Easy questions be like - \"Shall i leave my job\" \\uD83D\\uDE11"
                    },
                    {
                        "username": "glitchedturtle",
                        "content": "\"medium\""
                    },
                    {
                        "username": "k2bilimo",
                        "content": "Greedy: Sort the costs array least->greatest. "
                    },
                    {
                        "username": "benyamin137928",
                        "content": "What is the point of this question? Sorting and selecting greedy is the easiest solution that will come to mind at first, Why this is a medium question? Is there a tricky and better than nlogn time solution?"
                    },
                    {
                        "username": "jotho_",
                        "content": "You can try hitting Submit without hitting Run :)  Also, using a linear bucket sort with division instead of counting makes it more challenging"
                    },
                    {
                        "username": "yaseenalk",
                        "content": "Weird problem to suggest counting sort IMO. The range of possible costs is pretty big, as is the range of coins."
                    },
                    {
                        "username": "soumita_basu",
                        "content": "( Didn't expect this question to be of medium level :})\nThis problem is easy if the logic is clear. You can solve this way.\n\nInitialize sum=0 and count=0\nSort the array costs\n\nNext, we will include:\nIf costs[0] = coins, return 1\nElse If costs[0] > coins, return 0\nElse initiate a for loop from 0 to size of array, incrementing by 1 in which we will add the ith element till the sum gets greater than the value of coins. If the sum gets greater than the value of coins then we will break the statement else count++\n\nReturn count\n\nLink to solution for better understanding: [https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3005126/simple-c-code/\n](https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3005126/simple-c-code/\n)\nHope it helps :)"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Literally Everyone : Waiting for new Problem of the Day so that I can write something in discussion and get upvotes \\uD83D\\uDE02"
                    },
                    {
                        "username": "omscode",
                        "content": "Its rubbish question . even i solved this in first attempt \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "Easy disguised as Medium.. :D "
                    },
                    {
                        "username": "adityasinghz",
                        "content": "How it can be in medium category? XD"
                    }
                ]
            },
            {
                "id": 1743688,
                "content": [
                    {
                        "username": "nishantk3101",
                        "content": "Easy questions be like - \"Shall i leave my job\" \\uD83D\\uDE11"
                    },
                    {
                        "username": "glitchedturtle",
                        "content": "\"medium\""
                    },
                    {
                        "username": "k2bilimo",
                        "content": "Greedy: Sort the costs array least->greatest. "
                    },
                    {
                        "username": "benyamin137928",
                        "content": "What is the point of this question? Sorting and selecting greedy is the easiest solution that will come to mind at first, Why this is a medium question? Is there a tricky and better than nlogn time solution?"
                    },
                    {
                        "username": "jotho_",
                        "content": "You can try hitting Submit without hitting Run :)  Also, using a linear bucket sort with division instead of counting makes it more challenging"
                    },
                    {
                        "username": "yaseenalk",
                        "content": "Weird problem to suggest counting sort IMO. The range of possible costs is pretty big, as is the range of coins."
                    },
                    {
                        "username": "soumita_basu",
                        "content": "( Didn't expect this question to be of medium level :})\nThis problem is easy if the logic is clear. You can solve this way.\n\nInitialize sum=0 and count=0\nSort the array costs\n\nNext, we will include:\nIf costs[0] = coins, return 1\nElse If costs[0] > coins, return 0\nElse initiate a for loop from 0 to size of array, incrementing by 1 in which we will add the ith element till the sum gets greater than the value of coins. If the sum gets greater than the value of coins then we will break the statement else count++\n\nReturn count\n\nLink to solution for better understanding: [https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3005126/simple-c-code/\n](https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3005126/simple-c-code/\n)\nHope it helps :)"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Literally Everyone : Waiting for new Problem of the Day so that I can write something in discussion and get upvotes \\uD83D\\uDE02"
                    },
                    {
                        "username": "omscode",
                        "content": "Its rubbish question . even i solved this in first attempt \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "Easy disguised as Medium.. :D "
                    },
                    {
                        "username": "adityasinghz",
                        "content": "How it can be in medium category? XD"
                    }
                ]
            },
            {
                "id": 1743682,
                "content": [
                    {
                        "username": "nishantk3101",
                        "content": "Easy questions be like - \"Shall i leave my job\" \\uD83D\\uDE11"
                    },
                    {
                        "username": "glitchedturtle",
                        "content": "\"medium\""
                    },
                    {
                        "username": "k2bilimo",
                        "content": "Greedy: Sort the costs array least->greatest. "
                    },
                    {
                        "username": "benyamin137928",
                        "content": "What is the point of this question? Sorting and selecting greedy is the easiest solution that will come to mind at first, Why this is a medium question? Is there a tricky and better than nlogn time solution?"
                    },
                    {
                        "username": "jotho_",
                        "content": "You can try hitting Submit without hitting Run :)  Also, using a linear bucket sort with division instead of counting makes it more challenging"
                    },
                    {
                        "username": "yaseenalk",
                        "content": "Weird problem to suggest counting sort IMO. The range of possible costs is pretty big, as is the range of coins."
                    },
                    {
                        "username": "soumita_basu",
                        "content": "( Didn't expect this question to be of medium level :})\nThis problem is easy if the logic is clear. You can solve this way.\n\nInitialize sum=0 and count=0\nSort the array costs\n\nNext, we will include:\nIf costs[0] = coins, return 1\nElse If costs[0] > coins, return 0\nElse initiate a for loop from 0 to size of array, incrementing by 1 in which we will add the ith element till the sum gets greater than the value of coins. If the sum gets greater than the value of coins then we will break the statement else count++\n\nReturn count\n\nLink to solution for better understanding: [https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3005126/simple-c-code/\n](https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3005126/simple-c-code/\n)\nHope it helps :)"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Literally Everyone : Waiting for new Problem of the Day so that I can write something in discussion and get upvotes \\uD83D\\uDE02"
                    },
                    {
                        "username": "omscode",
                        "content": "Its rubbish question . even i solved this in first attempt \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "Easy disguised as Medium.. :D "
                    },
                    {
                        "username": "adityasinghz",
                        "content": "How it can be in medium category? XD"
                    }
                ]
            },
            {
                "id": 1743681,
                "content": [
                    {
                        "username": "nishantk3101",
                        "content": "Easy questions be like - \"Shall i leave my job\" \\uD83D\\uDE11"
                    },
                    {
                        "username": "glitchedturtle",
                        "content": "\"medium\""
                    },
                    {
                        "username": "k2bilimo",
                        "content": "Greedy: Sort the costs array least->greatest. "
                    },
                    {
                        "username": "benyamin137928",
                        "content": "What is the point of this question? Sorting and selecting greedy is the easiest solution that will come to mind at first, Why this is a medium question? Is there a tricky and better than nlogn time solution?"
                    },
                    {
                        "username": "jotho_",
                        "content": "You can try hitting Submit without hitting Run :)  Also, using a linear bucket sort with division instead of counting makes it more challenging"
                    },
                    {
                        "username": "yaseenalk",
                        "content": "Weird problem to suggest counting sort IMO. The range of possible costs is pretty big, as is the range of coins."
                    },
                    {
                        "username": "soumita_basu",
                        "content": "( Didn't expect this question to be of medium level :})\nThis problem is easy if the logic is clear. You can solve this way.\n\nInitialize sum=0 and count=0\nSort the array costs\n\nNext, we will include:\nIf costs[0] = coins, return 1\nElse If costs[0] > coins, return 0\nElse initiate a for loop from 0 to size of array, incrementing by 1 in which we will add the ith element till the sum gets greater than the value of coins. If the sum gets greater than the value of coins then we will break the statement else count++\n\nReturn count\n\nLink to solution for better understanding: [https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3005126/simple-c-code/\n](https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3005126/simple-c-code/\n)\nHope it helps :)"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Literally Everyone : Waiting for new Problem of the Day so that I can write something in discussion and get upvotes \\uD83D\\uDE02"
                    },
                    {
                        "username": "omscode",
                        "content": "Its rubbish question . even i solved this in first attempt \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "Easy disguised as Medium.. :D "
                    },
                    {
                        "username": "adityasinghz",
                        "content": "How it can be in medium category? XD"
                    }
                ]
            },
            {
                "id": 1743676,
                "content": [
                    {
                        "username": "nishantk3101",
                        "content": "Easy questions be like - \"Shall i leave my job\" \\uD83D\\uDE11"
                    },
                    {
                        "username": "glitchedturtle",
                        "content": "\"medium\""
                    },
                    {
                        "username": "k2bilimo",
                        "content": "Greedy: Sort the costs array least->greatest. "
                    },
                    {
                        "username": "benyamin137928",
                        "content": "What is the point of this question? Sorting and selecting greedy is the easiest solution that will come to mind at first, Why this is a medium question? Is there a tricky and better than nlogn time solution?"
                    },
                    {
                        "username": "jotho_",
                        "content": "You can try hitting Submit without hitting Run :)  Also, using a linear bucket sort with division instead of counting makes it more challenging"
                    },
                    {
                        "username": "yaseenalk",
                        "content": "Weird problem to suggest counting sort IMO. The range of possible costs is pretty big, as is the range of coins."
                    },
                    {
                        "username": "soumita_basu",
                        "content": "( Didn't expect this question to be of medium level :})\nThis problem is easy if the logic is clear. You can solve this way.\n\nInitialize sum=0 and count=0\nSort the array costs\n\nNext, we will include:\nIf costs[0] = coins, return 1\nElse If costs[0] > coins, return 0\nElse initiate a for loop from 0 to size of array, incrementing by 1 in which we will add the ith element till the sum gets greater than the value of coins. If the sum gets greater than the value of coins then we will break the statement else count++\n\nReturn count\n\nLink to solution for better understanding: [https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3005126/simple-c-code/\n](https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3005126/simple-c-code/\n)\nHope it helps :)"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Literally Everyone : Waiting for new Problem of the Day so that I can write something in discussion and get upvotes \\uD83D\\uDE02"
                    },
                    {
                        "username": "omscode",
                        "content": "Its rubbish question . even i solved this in first attempt \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "Easy disguised as Medium.. :D "
                    },
                    {
                        "username": "adityasinghz",
                        "content": "How it can be in medium category? XD"
                    }
                ]
            },
            {
                "id": 1743675,
                "content": [
                    {
                        "username": "nishantk3101",
                        "content": "Easy questions be like - \"Shall i leave my job\" \\uD83D\\uDE11"
                    },
                    {
                        "username": "glitchedturtle",
                        "content": "\"medium\""
                    },
                    {
                        "username": "k2bilimo",
                        "content": "Greedy: Sort the costs array least->greatest. "
                    },
                    {
                        "username": "benyamin137928",
                        "content": "What is the point of this question? Sorting and selecting greedy is the easiest solution that will come to mind at first, Why this is a medium question? Is there a tricky and better than nlogn time solution?"
                    },
                    {
                        "username": "jotho_",
                        "content": "You can try hitting Submit without hitting Run :)  Also, using a linear bucket sort with division instead of counting makes it more challenging"
                    },
                    {
                        "username": "yaseenalk",
                        "content": "Weird problem to suggest counting sort IMO. The range of possible costs is pretty big, as is the range of coins."
                    },
                    {
                        "username": "soumita_basu",
                        "content": "( Didn't expect this question to be of medium level :})\nThis problem is easy if the logic is clear. You can solve this way.\n\nInitialize sum=0 and count=0\nSort the array costs\n\nNext, we will include:\nIf costs[0] = coins, return 1\nElse If costs[0] > coins, return 0\nElse initiate a for loop from 0 to size of array, incrementing by 1 in which we will add the ith element till the sum gets greater than the value of coins. If the sum gets greater than the value of coins then we will break the statement else count++\n\nReturn count\n\nLink to solution for better understanding: [https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3005126/simple-c-code/\n](https://leetcode.com/problems/maximum-ice-cream-bars/solutions/3005126/simple-c-code/\n)\nHope it helps :)"
                    },
                    {
                        "username": "abhisheksharmayt",
                        "content": "Literally Everyone : Waiting for new Problem of the Day so that I can write something in discussion and get upvotes \\uD83D\\uDE02"
                    },
                    {
                        "username": "omscode",
                        "content": "Its rubbish question . even i solved this in first attempt \\uD83E\\uDD23"
                    },
                    {
                        "username": "six519",
                        "content": "Easy disguised as Medium.. :D "
                    },
                    {
                        "username": "adityasinghz",
                        "content": "How it can be in medium category? XD"
                    }
                ]
            }
        ]
    }
]