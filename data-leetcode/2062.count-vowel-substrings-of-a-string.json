[
    {
        "title": "Count Vowel Substrings of a String",
        "question_content": "A substring is a contiguous (non-empty) sequence of characters within a string.\nA vowel substring is a substring that only consists of vowels ('a', 'e', 'i', 'o', and 'u') and has all five vowels present in it.\nGiven a string word, return the number of vowel substrings in word.\n&nbsp;\nExample 1:\n\nInput: word = \"aeiouu\"\nOutput: 2\nExplanation: The vowel substrings of word are as follows (underlined):\n- \"aeiouu\"\n- \"aeiouu\"\n\nExample 2:\n\nInput: word = \"unicornarihan\"\nOutput: 0\nExplanation: Not all 5 vowels are present, so there are no vowel substrings.\n\nExample 3:\n\nInput: word = \"cuaieuouac\"\nOutput: 7\nExplanation: The vowel substrings of word are as follows (underlined):\n- \"cuaieuouac\"\n- \"cuaieuouac\"\n- \"cuaieuouac\"\n- \"cuaieuouac\"\n- \"cuaieuouac\"\n- \"cuaieuouac\"\n- \"cuaieuouac\"\n\n&nbsp;\nConstraints:\n\n\t1 <= word.length <= 100\n\tword consists of lowercase English letters only.",
        "solutions": [
            {
                "id": 1563737,
                "title": "sliding-window",
                "content": "I spent more time on this problem than on medium/hard problems in the contest.\\n\\nBrute-force would do for `100` characters (since it\\'s an easy problem), but I wanted to solve it efficiently.\\n\\n`j` marks the start of an \"all-vowel\" substring. We advance `j` every time we see a consonant.\\n\\n`i` is the current position, and `k` indicates the smallest window with all 5 vowels. \\n\\n> Note that we use a trick to move `k` one step forward, so the smallest window is actually `[k - 1, j]`. \\n> This is just to simplify the calculation, so that `k - j == 1` when we find the first vowel substring.\\n\\nSo, for each position `i`, we have `k - j` valid substrings. The picture below demonstrate it for `\"xxaiioueiiaxx\"` test case:\\n\\n![image](https://assets.leetcode.com/users/images/2cd3551e-c4de-46c8-98af-f323fb7574f8_1636260773.946565.png)\\n\\n**C++**\\n```cpp\\nint countVowelSubstrings(string w) {\\n    int vow = 0, cnt = 0, m[123] = {};\\n    string vowels(\"aeiou\");\\n    for (int i = 0, j = 0, k = 0; i < w.size(); ++i) {\\n        if (vowels.find(w[i]) != string::npos) {\\n            vow += ++m[w[i]] == 1;\\n            for (; vow == 5; ++k)\\n                vow -= --m[w[k]] == 0;\\n            cnt += k - j;\\n        }\\n        else {\\n            m[\\'a\\'] = m[\\'e\\'] = m[\\'i\\'] = m[\\'o\\'] = m[\\'u\\'] = vow = 0;\\n            j = k = i + 1;\\n        }\\n    }\\n    return cnt;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint countVowelSubstrings(string w) {\\n    int vow = 0, cnt = 0, m[123] = {};\\n    string vowels(\"aeiou\");\\n    for (int i = 0, j = 0, k = 0; i < w.size(); ++i) {\\n        if (vowels.find(w[i]) != string::npos) {\\n            vow += ++m[w[i]] == 1;\\n            for (; vow == 5; ++k)\\n                vow -= --m[w[k]] == 0;\\n            cnt += k - j;\\n        }\\n        else {\\n            m[\\'a\\'] = m[\\'e\\'] = m[\\'i\\'] = m[\\'o\\'] = m[\\'u\\'] = vow = 0;\\n            j = k = i + 1;\\n        }\\n    }\\n    return cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1563888,
                "title": "python-one-pass-no-sliding-window-o-n",
                "content": "**Intuition**\\n* Keep track of 6 values: the last index we saw a consonant,\\n and the last index where we saw each of the 5 vowels.\\n* At each index: the number of valid substrings ending here is the distance backwards from the earliest last seen vowel to the last seen consonant.\\n\\n```python\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n\\n        ans, last_consonant = 0, -1\\n        last_seen_vowels = {v: -2 for v in vowels}\\n        for i, x in enumerate(word):\\n            if x not in vowels:\\n                last_consonant = i\\n            else:\\n                last_seen_vowels[x] = i\\n                ans += max(min(last_seen_vowels.values())-last_consonant, 0)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n\\n        ans, last_consonant = 0, -1\\n        last_seen_vowels = {v: -2 for v in vowels}\\n        for i, x in enumerate(word):\\n            if x not in vowels:\\n                last_consonant = i\\n            else:\\n                last_seen_vowels[x] = i\\n                ans += max(min(last_seen_vowels.values())-last_consonant, 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563765,
                "title": "c-o-n-time-sliding-window-at-most-to-equal-trick",
                "content": "See my latest update in repo [LeetCode](https://github.com/lzl124631x/LeetCode)\\n## Solution 1. Brute Force\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/count-vowel-substrings-of-a-string/\\n// Author: github.com/lzl124631x\\n// Time: O(N^2)\\n// Space: O(1)\\nclass Solution {\\n    bool isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    };\\npublic:\\n    int countVowelSubstrings(string s) {\\n        int ans = 0, N = s.size();\\n        unordered_map<char, int> cnt;\\n        for (int i = 0; i < N; ++i) {\\n            cnt.clear();\\n            for (int j = i; j < N && isVowel(s[j]); ++j) {\\n                cnt[s[j]]++;\\n                if (cnt.size() == 5) ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n## Solution 2. Sliding Window\\n\\nCheck out \"[C++ Maximum Sliding Window Cheatsheet Template!](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!)\"\\n\\nFunction `atMost(s, goal)` returns the number of substrings that has at most `goal` number of unique vowels. The answer is `atMost(s, 5) - atMost(s, 4)`.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/count-vowel-substrings-of-a-string/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\n    bool isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    };\\n    int atMost(string &s, int goal) {\\n        int ans = 0, i = 0, j = 0, N = s.size();\\n        unordered_map<char, int> cnt;\\n        for (; j < N; ++j) {\\n            if (!isVowel(s[j])) {\\n                i = j + 1;\\n                cnt.clear();\\n                continue;\\n            }\\n            cnt[s[j]]++;\\n            for (; cnt.size() > goal; ++i) {\\n                if (--cnt[s[i]] == 0) cnt.erase(s[i]);\\n            }\\n            ans += j - i + 1; // this window [i, j] is the maximum window ending at `s[j]` that has at most `goal` number of unique vowels.\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countVowelSubstrings(string s) {\\n        return atMost(s, 5) - atMost(s, 4);\\n    }\\n};\\n```\\n\\n# \\uD83C\\uDF1F Sliding Window \"At Most to Equal\" trick\\n\\nNOTE: this is an extension to my \"[C++ Maximum Sliding Window Cheatsheet Template!](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!)\". Please make sure you are familiar with this template first.\\n\\nFor problems solvable using this trick, also check out \"[C++ Maximum Sliding Window Cheatsheet Template!](https://leetcode.com/problems/frequency-of-the-most-frequent-element/discuss/1175088/C%2B%2B-Maximum-Sliding-Window-Cheatsheet-Template!)\"\\n\\nFor a find maximum sliding window problem that is looking for windows with **exactly** `k` something in it, we can convert it to a problem that is looking for **at most** `k` something in it.\\n\\nIt\\'s because \"number of windows with **exactly** `k` something in it\" = \"number of windows with **at most** `k` something in it\" - \"number of windows with **at most** `k - 1` something in it\".\\n\\n\\n\\nTake [930. Binary Subarrays With Sum (Medium)](https://leetcode.com/problems/binary-subarrays-with-sum/discuss/1513935/C%2B%2B-Prefix-State-Map-or-Sliding-Window) for example, if we want to use the \"find maximum sliding window template\" without this trick, we would need to use 3 pointers -- `i` as the left edge of the window with `goal` number of `1`s in it, `j` as the left edge of the window with `goal - 1` number of `1`s in it, and `k` as the right edge.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/binary-subarrays-with-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int numSubarraysWithSum(vector<int>& A, int goal) {\\n        int i = 0, j = 0, k = 0, N = A.size(), sum1 = 0, sum2 = 0, ans = 0;\\n        for (; k < N; ++k) {\\n            sum1 += A[k];\\n            sum2 += A[k];\\n            while (i <= k && sum1 > goal) sum1 -= A[i++];\\n            while (j <= k && sum2 > goal - 1) sum2 -= A[j++];\\n            ans += j - i;\\n        }\\n        return ans;\\n    }\\n};\\n```\\nThis code is repetitive -- we need to do similar jobs for `i` and `j`, and keep states for both windows.\\n\\nBy extracting an `atMost` function, we make the code cleaner and less error-prone.\\n\\n```cpp\\n// OJ: https://leetcode.com/problems/binary-subarrays-with-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\n    int atMost(vector<int> &A, int goal) {\\n        int i = 0, j = 0, N = A.size(), sum = 0, ans = 0;\\n        for (; j < N; ++j) {\\n            sum += A[j];\\n            while (i <= j && sum > goal) sum -= A[i++];\\n            ans += j - i;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int numSubarraysWithSum(vector<int>& A, int goal) {\\n        return atMost(A, goal) - atMost(A, goal - 1);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```cpp\\n// OJ: https://leetcode.com/problems/count-vowel-substrings-of-a-string/\\n// Author: github.com/lzl124631x\\n// Time: O(N^2)\\n// Space: O(1)\\nclass Solution {\\n    bool isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    };\\npublic:\\n    int countVowelSubstrings(string s) {\\n        int ans = 0, N = s.size();\\n        unordered_map<char, int> cnt;\\n        for (int i = 0; i < N; ++i) {\\n            cnt.clear();\\n            for (int j = i; j < N && isVowel(s[j]); ++j) {\\n                cnt[s[j]]++;\\n                if (cnt.size() == 5) ++ans;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/count-vowel-substrings-of-a-string/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\n    bool isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    };\\n    int atMost(string &s, int goal) {\\n        int ans = 0, i = 0, j = 0, N = s.size();\\n        unordered_map<char, int> cnt;\\n        for (; j < N; ++j) {\\n            if (!isVowel(s[j])) {\\n                i = j + 1;\\n                cnt.clear();\\n                continue;\\n            }\\n            cnt[s[j]]++;\\n            for (; cnt.size() > goal; ++i) {\\n                if (--cnt[s[i]] == 0) cnt.erase(s[i]);\\n            }\\n            ans += j - i + 1; // this window [i, j] is the maximum window ending at `s[j]` that has at most `goal` number of unique vowels.\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countVowelSubstrings(string s) {\\n        return atMost(s, 5) - atMost(s, 4);\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/binary-subarrays-with-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\npublic:\\n    int numSubarraysWithSum(vector<int>& A, int goal) {\\n        int i = 0, j = 0, k = 0, N = A.size(), sum1 = 0, sum2 = 0, ans = 0;\\n        for (; k < N; ++k) {\\n            sum1 += A[k];\\n            sum2 += A[k];\\n            while (i <= k && sum1 > goal) sum1 -= A[i++];\\n            while (j <= k && sum2 > goal - 1) sum2 -= A[j++];\\n            ans += j - i;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```cpp\\n// OJ: https://leetcode.com/problems/binary-subarrays-with-sum/\\n// Author: github.com/lzl124631x\\n// Time: O(N)\\n// Space: O(1)\\nclass Solution {\\n    int atMost(vector<int> &A, int goal) {\\n        int i = 0, j = 0, N = A.size(), sum = 0, ans = 0;\\n        for (; j < N; ++j) {\\n            sum += A[j];\\n            while (i <= j && sum > goal) sum -= A[i++];\\n            ans += j - i;\\n        }\\n        return ans;\\n    }\\npublic:\\n    int numSubarraysWithSum(vector<int>& A, int goal) {\\n        return atMost(A, goal) - atMost(A, goal - 1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563906,
                "title": "java-brute-force-hashset-8ms-easy-to-understand",
                "content": "Approach:\\nTwo loops are used to find every possible substring starting at i=0 to i = (length)-4 because the minimum length of substring must be 5 to contain each of the vowels.\\nA HashSet maintains the vowels encountered in each substring which is cleared after each iteration.\\nIf the size of the set is 5, we know that each of the 5 vowels are present.\\nIf a consonant is found, we break out of the inner loop.\\n\\n**Runtime : 8 ms(83.33%), Memory Usage: 37.3 MB(100%)**\\n```\\nclass Solution\\n{\\n    public int countVowelSubstrings(String word)\\n    {\\n        int vow = 0;\\n        int n = word.length();\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < n-4; i++)\\n        {\\n            set.clear();\\n            for(int j = i; j < n; j++)\\n            {\\n                char ch = word.charAt(j);\\n                if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n                {\\n                    set.add(ch);\\n                    if(set.size() == 5)\\n                        vow++;\\n                }\\n                else\\n                    break;\\n            }\\n        }\\n        return vow;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution\\n{\\n    public int countVowelSubstrings(String word)\\n    {\\n        int vow = 0;\\n        int n = word.length();\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < n-4; i++)\\n        {\\n            set.clear();\\n            for(int j = i; j < n; j++)\\n            {\\n                char ch = word.charAt(j);\\n                if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\')\\n                {\\n                    set.add(ch);\\n                    if(set.size() == 5)\\n                        vow++;\\n                }\\n                else\\n                    break;\\n            }\\n        }\\n        return vow;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1572798,
                "title": "c-o-n-2-to-o-n-detailed-explanation-with-picture",
                "content": "```\\n\\nApproach1:  \\n\\nThe idea is to run a nested loop and keep counting a substring that \\nonly contains vowels and has all 5 vowels.\\n\\nSteps:\\n\\n1.)Run a nested roop.\\n\\n2.)check whether the current character matches \\n   any of the 5 vowels (a,,e,i,o,u).\\n   \\n3.)if yes then   \\n\\n   a.) insert that character in any data structure which will count \\n       the number of unique vowels.\\n \\n   b.) if the number of unique vowels is greater or equal to 5 then\\n\\t\\tincrement the count variable which will count the  number \\n\\t\\tof vowels substring.\\n\\t\\t\\n4.) if not then break the loop.\\n\\n\\nDry Run:\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/00520789-75de-4155-9090-47e90278eda2_1636668826.0015643.png)\\n\\n![image](https://assets.leetcode.com/users/images/8c27e36b-d118-4b03-9c89-fd262a872a02_1636668793.1397736.png)\\n![image](https://assets.leetcode.com/users/images/22def884-0ae0-4419-8f14-c81823760c14_1636668803.9500117.png)\\n\\n\\n\\n```\\n\\ncode:\\n \\n        bool isVowel(char ch) \\n        { \\n                return (ch == \\'a\\') || (ch == \\'e\\') ||(ch == \\'i\\') ||(ch == \\'o\\') ||(ch == \\'u\\');\\n        }\\n\\n\\n        int countVowelSubstrings(string word) {\\n        \\n        if(word.size()<5)\\n            return 0;   \\n        \\n        int countOfVowelSubstring=0;\\n        \\n        for(int i=0; i<word.size()-4; i++)\\n        {\\n            unordered_set<char> uniqueVowel;\\n            \\n            for(int j=i; j<word.size(); j++)\\n            {\\n                if(isVowel(word[j]))\\n                {\\n                    uniqueVowel.insert(word[j]);\\n                    \\n                    if(uniqueVowel.size()==5)\\n                        ++countOfVowelSubstring;\\n                    \\n                }\\n                else \\n                    break;\\n            }\\n        }\\n        \\n        return countOfVowelSubstring;\\n    }\\n\\n\\n\\nTime Complexity: O(N^2)\\nSpace Complexity: O(1)\\n\\n\\n\\nApproach 2:\\n\\nIn this approach, we will first count the number of substrings that \\nhas at most 5 unique vowels. Then we will count the number of \\nsubstrings that has at most 4 unique vowels and we will subtract them.\\n\\nLet\\'s take a simple example and see  how it works ->\\n\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/71bdab16-be9f-41d3-859e-f71861951d46_1636668978.1239243.png)\\n\\n\\n```\\nTo solve this, we will be using the sliding window concept.\\nMost of the time in the Sliding window we will be given a \\nwindow size but in our case, we have to take our window size, \\nso for the first time window size will be 5 because we have to \\ncount a substring that has at most 5 unique vowels, and in the \\nsecond time window size will be 4.\\n\\n\\nstep:\\n\\n1) Iterate through a string. \\n2.) check whether the current character matches any of the 5 vowels (a,e, i,o,u).\\n\\n     a.) If yes then insert that character in any data structure which will \\n\\t     count the number of unique vowels.\\n\\n          1) If the number of unique vowels exceeds the window size \\n             then move the window until window size becomes equal.\\n\\n          2) add the current window size in the count variable which will count the substring. \\n \\n   b.) If not then shift the window to the next index and remove all \\n       elements from the data structure since we have counted all the \\n\\t   substrings in that window.\\n\\n\\n\\nDry Run:\\n\\n1.)Calculate  number of substrings that has at most 5 unique vowels in \\u201Ccuaieuouac\\u201D.\\n\\n```\\n\\n![image](https://assets.leetcode.com/users/images/93201d4a-0ae4-461b-8d8e-db9e545bc564_1636669083.1064029.png)\\n\\n```\\n\\n2.)Similarly  Calculate  number of substrings that has at most 4 unique vowels in \\u201Ccuaieuouac\\u201D.\\n\\n\\n\\n3.) ans = ( Difference of number of substrings that has at most 5 unique vowels -  \\n            Difference of number of substrings that has at most 5 unique vowels)\\n    ans = ( 44 - 36)\\n    ans = 7\\n  \\n \\nCode:\\n\\n\\n    bool isVowel(char ch)\\n    {\\n        return (ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\');\\n    }\\n    \\n    int count_Vowel_At_Most_K_Unique_Vowels(string s,int k)\\n    {\\n        unordered_map<char,int> freq;\\n        int count=0;\\n        int i=0,j=0;\\n        while(j<s.size())\\n        {\\n            if(!isVowel(s[j]))\\n            {\\n                i=j+1;\\n                j++;\\n                freq.clear();\\n                continue;\\n            }\\n            freq[s[j++]]++;\\n            while(freq.size()>k)\\n            {\\n                freq[s[i]]--;\\n                if(freq[s[i]]==0)\\n                    freq.erase(s[i]);\\n                i++;\\n            }\\n            count+=(j-i+1);\\n        }\\n        return count;\\n    }\\n    \\n    int countVowelSubstrings(string word) {\\n         return ( count_Vowel_At_Most_K_Unique_Vowels(word,5) -  \\n                     count_Vowel_At_Most_K_Unique_Vowels(word,4));   \\n    }\\n\\n\\n\\nTime Complexity: O(N)\\nSpace Complexity: O(1)\\n\\n\\n\\n \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n\\nApproach1:  \\n\\nThe idea is to run a nested loop and keep counting a substring that \\nonly contains vowels and has all 5 vowels.\\n\\nSteps:\\n\\n1.)Run a nested roop.\\n\\n2.)check whether the current character matches \\n   any of the 5 vowels (a,,e,i,o,u).\\n   \\n3.)if yes then   \\n\\n   a.) insert that character in any data structure which will count \\n       the number of unique vowels.\\n \\n   b.) if the number of unique vowels is greater or equal to 5 then\\n\\t\\tincrement the count variable which will count the  number \\n\\t\\tof vowels substring.\\n\\t\\t\\n4.) if not then break the loop.\\n\\n\\nDry Run:\\n\\n```\n```\\n\\ncode:\\n \\n        bool isVowel(char ch) \\n        { \\n                return (ch == \\'a\\') || (ch == \\'e\\') ||(ch == \\'i\\') ||(ch == \\'o\\') ||(ch == \\'u\\');\\n        }\\n\\n\\n        int countVowelSubstrings(string word) {\\n        \\n        if(word.size()<5)\\n            return 0;   \\n        \\n        int countOfVowelSubstring=0;\\n        \\n        for(int i=0; i<word.size()-4; i++)\\n        {\\n            unordered_set<char> uniqueVowel;\\n            \\n            for(int j=i; j<word.size(); j++)\\n            {\\n                if(isVowel(word[j]))\\n                {\\n                    uniqueVowel.insert(word[j]);\\n                    \\n                    if(uniqueVowel.size()==5)\\n                        ++countOfVowelSubstring;\\n                    \\n                }\\n                else \\n                    break;\\n            }\\n        }\\n        \\n        return countOfVowelSubstring;\\n    }\\n\\n\\n\\nTime Complexity: O(N^2)\\nSpace Complexity: O(1)\\n\\n\\n\\nApproach 2:\\n\\nIn this approach, we will first count the number of substrings that \\nhas at most 5 unique vowels. Then we will count the number of \\nsubstrings that has at most 4 unique vowels and we will subtract them.\\n\\nLet\\'s take a simple example and see  how it works ->\\n\\n\\n```\n```\\nTo solve this, we will be using the sliding window concept.\\nMost of the time in the Sliding window we will be given a \\nwindow size but in our case, we have to take our window size, \\nso for the first time window size will be 5 because we have to \\ncount a substring that has at most 5 unique vowels, and in the \\nsecond time window size will be 4.\\n\\n\\nstep:\\n\\n1) Iterate through a string. \\n2.) check whether the current character matches any of the 5 vowels (a,e, i,o,u).\\n\\n     a.) If yes then insert that character in any data structure which will \\n\\t     count the number of unique vowels.\\n\\n          1) If the number of unique vowels exceeds the window size \\n             then move the window until window size becomes equal.\\n\\n          2) add the current window size in the count variable which will count the substring. \\n \\n   b.) If not then shift the window to the next index and remove all \\n       elements from the data structure since we have counted all the \\n\\t   substrings in that window.\\n\\n\\n\\nDry Run:\\n\\n1.)Calculate  number of substrings that has at most 5 unique vowels in \\u201Ccuaieuouac\\u201D.\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1563764,
                "title": "well-commented-c-code-with-explanation-using-set",
                "content": "This is a straightforward question with a pretty straightforward approach (although not an easy one). This question was also asked in many interviews so make sure to understand this thoroughly.\\nThe approach is => we iterate over the given string and we consider all substrings starting from it. If we encounter a consonant, we move to the next starting character. Else, we insert the current character in a set. If all vowels are included, we increment the ans (count of substrings with all vowels). \\n```\\nclass Solution {\\npublic:\\n    // Function to check whether a character is a vowel or not\\n    bool isVowel(char x){\\n        return (x == \\'a\\' || x == \\'e\\' || x == \\'i\\' || x == \\'o\\' || x == \\'u\\');\\n    }\\n    int countVowelSubstrings(string word) {\\n        set<char> s;\\n        int ans = 0;\\n        int n = word.size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                // check if the encountered char is a consonant if it is the break the loop there itself\\n                if(isVowel(word[j])==false)\\n                    break;\\n                // else insert it into the set\\n                s.insert(word[j]);\\n                \\n                // increment the ans if the count of vowels in a substring becomes 5, i.e. the substring contains all vowels\\n                if(s.size()==5){\\n                    ans++;\\n                }\\n            }\\n            s.clear();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\nplease upvote if you found this useful.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    // Function to check whether a character is a vowel or not\\n    bool isVowel(char x){\\n        return (x == \\'a\\' || x == \\'e\\' || x == \\'i\\' || x == \\'o\\' || x == \\'u\\');\\n    }\\n    int countVowelSubstrings(string word) {\\n        set<char> s;\\n        int ans = 0;\\n        int n = word.size();\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=i;j<n;j++){\\n                // check if the encountered char is a consonant if it is the break the loop there itself\\n                if(isVowel(word[j])==false)\\n                    break;\\n                // else insert it into the set\\n                s.insert(word[j]);\\n                \\n                // increment the ans if the count of vowels in a substring becomes 5, i.e. the substring contains all vowels\\n                if(s.size()==5){\\n                    ans++;\\n                }\\n            }\\n            s.clear();\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563707,
                "title": "python3-sliding-window-o-n",
                "content": "Please check out this [commit](https://github.com/gaosanyong/leetcode/commit/6b6e6b9115d2b659e68dcf3ea8e21befefaae16c) for solutions of weekly 266. \\n\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        ans = 0 \\n        freq = defaultdict(int)\\n        for i, x in enumerate(word): \\n            if x in \"aeiou\": \\n                if not i or word[i-1] not in \"aeiou\": \\n                    jj = j = i # set anchor\\n                    freq.clear()\\n                freq[x] += 1\\n                while len(freq) == 5 and all(freq.values()): \\n                    freq[word[j]] -= 1\\n                    j += 1\\n                ans += j - jj\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        ans = 0 \\n        freq = defaultdict(int)\\n        for i, x in enumerate(word): \\n            if x in \"aeiou\": \\n                if not i or word[i-1] not in \"aeiou\": \\n                    jj = j = i # set anchor\\n                    freq.clear()\\n                freq[x] += 1\\n                while len(freq) == 5 and all(freq.values()): \\n                    freq[word[j]] -= 1\\n                    j += 1\\n                ans += j - jj\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563778,
                "title": "c-not-an-easy-problem",
                "content": "This should atleast be a medium problem.\\n**1. Brute Force:**\\n```\\n    int countVowelSubstrings(string s) {\\n        int res = 0;\\n        for(int i=0; i<s.size(); i++){\\n            unordered_set<char> set;\\n            for(int j=i; j<s.size(); j++){\\n                if(!isVowel(s[j])) break;\\n                set.insert(s[j]);\\n                if(set.size() == 5) res++;\\n            }\\n        }\\n        return res;\\n    } \\n\\t\\n\\tbool isVowel(char c) {\\n        return (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\');\\n    }\\n```\\n\\n**2. Sliding Window:**\\nExactly k = atMostK(k) - atMostK(k-1)\\n```\\nclass Solution {\\n    public:\\n    bool isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    };\\n    \\n    int atMostK(string &s, int k) {\\n        int res = 0, i=0, n = s.size();\\n        unordered_map<char, int> mp;\\n        \\n        for(int j=0; j<n; j++) {\\n            if (!isVowel(s[j])) {\\n                i = j + 1;\\n                //Clear map as new substring will begin\\n                mp.clear();\\n                continue;\\n            }\\n            mp[s[j]]++;\\n            while(mp.size() > k){\\n                mp[s[i]]--;\\n                if(mp[s[i]] == 0) mp.erase(s[i]);\\n                i++;\\n            }\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n    \\n    int countVowelSubstrings(string str) {\\n        return atMostK(str, 5) - atMostK(str, 4);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n    int countVowelSubstrings(string s) {\\n        int res = 0;\\n        for(int i=0; i<s.size(); i++){\\n            unordered_set<char> set;\\n            for(int j=i; j<s.size(); j++){\\n                if(!isVowel(s[j])) break;\\n                set.insert(s[j]);\\n                if(set.size() == 5) res++;\\n            }\\n        }\\n        return res;\\n    } \\n\\t\\n\\tbool isVowel(char c) {\\n        return (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\');\\n    }\\n```\n```\\nclass Solution {\\n    public:\\n    bool isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    };\\n    \\n    int atMostK(string &s, int k) {\\n        int res = 0, i=0, n = s.size();\\n        unordered_map<char, int> mp;\\n        \\n        for(int j=0; j<n; j++) {\\n            if (!isVowel(s[j])) {\\n                i = j + 1;\\n                //Clear map as new substring will begin\\n                mp.clear();\\n                continue;\\n            }\\n            mp[s[j]]++;\\n            while(mp.size() > k){\\n                mp[s[i]]--;\\n                if(mp[s[i]] == 0) mp.erase(s[i]);\\n                i++;\\n            }\\n            res += j - i + 1;\\n        }\\n        return res;\\n    }\\n    \\n    int countVowelSubstrings(string str) {\\n        return atMostK(str, 5) - atMostK(str, 4);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1594931,
                "title": "python-time-one-pass-o-n-space-o-1-not-a-sliding-window",
                "content": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        vowels = (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')\\n        \\n        result = 0\\n        start = 0\\n        vowel_idx = {}\\n        for idx, c in enumerate(word):\\n            if c in vowels:\\n                if not vowel_idx:\\n                    start = idx       \\n                vowel_idx[c] = idx\\n                if len(vowel_idx) == 5:\\n                    result += min(vowel_idx.values()) - start + 1 \\n            elif vowel_idx:\\n                vowel_idx = {}\\n                \\n        return result\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        vowels = (\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')\\n        \\n        result = 0\\n        start = 0\\n        vowel_idx = {}\\n        for idx, c in enumerate(word):\\n            if c in vowels:\\n                if not vowel_idx:\\n                    start = idx       \\n                vowel_idx[c] = idx\\n                if len(vowel_idx) == 5:\\n                    result += min(vowel_idx.values()) - start + 1 \\n            elif vowel_idx:\\n                vowel_idx = {}\\n                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564009,
                "title": "java-16-lines-o-n-solution-without-using-sliding-window",
                "content": "Java implementation based on the Python solution by @kcsquared (https://leetcode.com/problems/count-vowel-substrings-of-a-string/discuss/1563888/Python-One-pass-no-sliding-window-O(n))\\n```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        int count = 0;\\n        Map<Character, Integer> lastSeen =\\n            new HashMap<>(Map.of(\\'a\\', -1, \\'e\\', -1, \\'i\\', -1, \\'o\\', -1, \\'u\\', -1));\\n        for (int i = 0, lastInvalidPos = -1; i < word.length(); ++i) {\\n            if (lastSeen.containsKey(word.charAt(i))) {\\n                lastSeen.put(word.charAt(i), i);\\n                count += Math.max(Collections.min(lastSeen.values()) - lastInvalidPos, 0);\\n            } else {\\n                lastInvalidPos = i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        int count = 0;\\n        Map<Character, Integer> lastSeen =\\n            new HashMap<>(Map.of(\\'a\\', -1, \\'e\\', -1, \\'i\\', -1, \\'o\\', -1, \\'u\\', -1));\\n        for (int i = 0, lastInvalidPos = -1; i < word.length(); ++i) {\\n            if (lastSeen.containsKey(word.charAt(i))) {\\n                lastSeen.put(word.charAt(i), i);\\n                count += Math.max(Collections.min(lastSeen.values()) - lastInvalidPos, 0);\\n            } else {\\n                lastInvalidPos = i;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2307677,
                "title": "c-o-n-time-o-1-space-solution-with-explanation",
                "content": "The idea is using two pointers to keep track the current substring window.\\nThe current window is determined by [i+1, j]. Initially i is -1.\\nStarting to scan the character from j = 0, if it is not vowel just skip and set i to j.\\nIf it is a vowel, than the current window has a chance to become vowel substring.\\nSo use a hash map to keep track of last position of all vowels.\\nIf the size of map is 5 (i.e. current window has all vowels), current window is vowel substring.\\nNow we can use last position of all vowels to count the answer.\\nFor every last positions of the vowel, find the leftmost position k.\\nThen the current window has k - i vowels substring.\\n\\nFor example:\\nword = \"cuaieuouac\"\\nwhen j = 6, current window become a vowel substring\\nHash map will be a: 2, e: 4, i: 3, o: 6, u: 5\\nk is the leftmost (min) position of all index (idx) which is 2\\n```\\n0 1 2 3 4 5 6 7 8 9\\nc u a i e u o u a c\\ni   k       j\\n```\\nNow k - i is 2, indicate that current window has 2 vowel substrings: uaieuo and aieuo\\nWhen j = 7, k is still 2\\n```\\n0 1 2 3 4 5 6 7 8 9\\nc u a i e u o u a c\\ni   k         j\\n```\\nk - i is still 2, indicate 2 new vowel substrings: uaieuou and aieuou\\nBut for j = 8, k will be 3\\n```\\n0 1 2 3 4 5 6 7 8 9\\nc u a i e u o u a c\\ni     k         j\\n```\\nk - i is 3, indicate 3 new vowel substrings: uaieuoua, aieuoua and ieuoua\\nSo the answer is 2 + 2 + 3 = 7.\\n\\nTime complexity: O(5n) = O(n)\\nSpace complexity: O(5+5) = O(1)\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        unordered_set<char> vowel = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        unordered_map<char, int> m;\\n        int ans = 0;\\n        for (int i = -1, j = 0; j < size(word); j++) {\\n            if (vowel.find(word[j]) == end(vowel)) {\\n                m.clear();\\n                i = j;\\n                continue;\\n            }\\n            m[word[j]] = j;\\n            if (size(m) == 5) {\\n                int k = j;\\n                for (auto& [c, idx]: m) k = min(k, idx);\\n                ans += k - i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n0 1 2 3 4 5 6 7 8 9\\nc u a i e u o u a c\\ni   k       j\\n```\n```\\n0 1 2 3 4 5 6 7 8 9\\nc u a i e u o u a c\\ni   k         j\\n```\n```\\n0 1 2 3 4 5 6 7 8 9\\nc u a i e u o u a c\\ni     k         j\\n```\n```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        unordered_set<char> vowel = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        unordered_map<char, int> m;\\n        int ans = 0;\\n        for (int i = -1, j = 0; j < size(word); j++) {\\n            if (vowel.find(word[j]) == end(vowel)) {\\n                m.clear();\\n                i = j;\\n                continue;\\n            }\\n            m[word[j]] = j;\\n            if (size(m) == 5) {\\n                int k = j;\\n                for (auto& [c, idx]: m) k = min(k, idx);\\n                ans += k - i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1574341,
                "title": "python-straightforward-solution",
                "content": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        count = 0 \\n        current = set() \\n        for i in range(len(word)):\\n            if word[i] in \\'aeiou\\':\\n                current.add(word[i])\\n                \\n                for j in range(i+1, len(word)): \\n                    if word[j] in \\'aeiou\\':\\n                        current.add(word[j])\\n                    else:\\n                        break\\n                    \\n                    if len(current) == 5:\\n                        count += 1\\n\\t\\t\\t\\t\\t\\t\\n            current = set()\\n                        \\n        return count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        count = 0 \\n        current = set() \\n        for i in range(len(word)):\\n            if word[i] in \\'aeiou\\':\\n                current.add(word[i])\\n                \\n                for j in range(i+1, len(word)): \\n                    if word[j] in \\'aeiou\\':\\n                        current.add(word[j])\\n                    else:\\n                        break\\n                    \\n                    if len(current) == 5:\\n                        count += 1\\n\\t\\t\\t\\t\\t\\t\\n            current = set()\\n                        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563978,
                "title": "python3-one-line-solution",
                "content": "```python\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        return sum(set(word[i:j+1]) == set(\\'aeiou\\') for i in range(len(word)) for j in range(i+1, len(word)))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        return sum(set(word[i:j+1]) == set(\\'aeiou\\') for i in range(len(word)) for j in range(i+1, len(word)))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2617418,
                "title": "java-solution-brute-force-and-optimal-solutions-hashtable-sliding-window",
                "content": "### Please Upvote !!! **(\\u25E0\\u203F\\u25E0)**\\n##### 1. Brute Force approach:\\n```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        Set<Character> set;\\n        int count = 0;\\n\\n        for (int i = 0; i < word.length() - 4; i++) {\\n            set = new HashSet<>();\\n\\n            for (int j = i; j < word.length(); j++) {\\n                char c = word.charAt(j);\\n                if (!isVowel(c)) break;\\n              \\n                set.add(c);\\n                if (set.size() == 5) count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\\n##### 2. Optimaized solution (Using Sliding Window technique):\\n```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        return atMostKVowels(word, 5) - atMostKVowels(word, 4);\\n    }\\n\\n    boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n    \\n    int atMostKVowels(String s, int k) {\\n        int i = 0;\\n        Map<Character, Integer> vowelMap = new HashMap<>();\\n        int count = 0;\\n        \\n        for (int j = 0; j < s.length(); j++) {\\n            char c = s.charAt(j);\\n            \\n            // consonant encountered\\n            if (!isVowel(c)) {\\n                vowelMap.clear();     // clear the map coz new substring will start\\n                i = j + 1;\\n                continue;\\n            }\\n            \\n            vowelMap.put(c, vowelMap.getOrDefault(c, 0) + 1);\\n            \\n            while(vowelMap.size() > k) {\\n                vowelMap.put(s.charAt(i), vowelMap.get(s.charAt(i)) - 1);\\n                if (vowelMap.get(s.charAt(i)) == 0) {\\n                    vowelMap.remove(s.charAt(i));\\n                }\\n                \\n                i++;\\n            }\\n            \\n            count += (j - i + 1);\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        Set<Character> set;\\n        int count = 0;\\n\\n        for (int i = 0; i < word.length() - 4; i++) {\\n            set = new HashSet<>();\\n\\n            for (int j = i; j < word.length(); j++) {\\n                char c = word.charAt(j);\\n                if (!isVowel(c)) break;\\n              \\n                set.add(c);\\n                if (set.size() == 5) count++;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n}\\n\\n// TC: O(n ^ 2), SC: O(1)\\n```\n```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        return atMostKVowels(word, 5) - atMostKVowels(word, 4);\\n    }\\n\\n    boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n    \\n    int atMostKVowels(String s, int k) {\\n        int i = 0;\\n        Map<Character, Integer> vowelMap = new HashMap<>();\\n        int count = 0;\\n        \\n        for (int j = 0; j < s.length(); j++) {\\n            char c = s.charAt(j);\\n            \\n            // consonant encountered\\n            if (!isVowel(c)) {\\n                vowelMap.clear();     // clear the map coz new substring will start\\n                i = j + 1;\\n                continue;\\n            }\\n            \\n            vowelMap.put(c, vowelMap.getOrDefault(c, 0) + 1);\\n            \\n            while(vowelMap.size() > k) {\\n                vowelMap.put(s.charAt(i), vowelMap.get(s.charAt(i)) - 1);\\n                if (vowelMap.get(s.charAt(i)) == 0) {\\n                    vowelMap.remove(s.charAt(i));\\n                }\\n                \\n                i++;\\n            }\\n            \\n            count += (j - i + 1);\\n        }\\n        \\n        return count;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1828637,
                "title": "javascript-map-solution",
                "content": "```\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nvar isVowel = function(c) {\\n    return (c === \\'a\\' || c === \\'e\\' || c === \\'i\\' || c === \\'o\\' || c === \\'u\\');\\n}\\n\\nvar countVowelSubstrings = function(word) {\\n    let vowelMap = new Map();\\n    let total = 0;\\n    let totalLen = word.length - 1;\\n    for(let i = 0 ; i <= totalLen; i++){\\n        vowelMap.clear();\\n        for(let j = i; j <= totalLen && isVowel(word[j]); j++){\\n            vowelMap.set(word[j], (vowelMap.get(word[j]) ?? 0) + 1);\\n            if(vowelMap.size == 5)\\n                total++;\\n        }\\n    }\\n    return total;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nvar isVowel = function(c) {\\n    return (c === \\'a\\' || c === \\'e\\' || c === \\'i\\' || c === \\'o\\' || c === \\'u\\');\\n}\\n\\nvar countVowelSubstrings = function(word) {\\n    let vowelMap = new Map();\\n    let total = 0;\\n    let totalLen = word.length - 1;\\n    for(let i = 0 ; i <= totalLen; i++){\\n        vowelMap.clear();\\n        for(let j = i; j <= totalLen && isVowel(word[j]); j++){\\n            vowelMap.set(word[j], (vowelMap.get(word[j]) ?? 0) + 1);\\n            if(vowelMap.size == 5)\\n                total++;\\n        }\\n    }\\n    return total;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1566698,
                "title": "c-sliding-window-unordered-map-100-faster-o-n",
                "content": "```\\n//The basic idea is to find all substrings with <=5 vovels and then find all substrings with \\n//distinct vovels <=4 and return substraction of both(Basic maths as <=4 contains \\n//all substrings <=4 and when we subtract it from <=5 only substrings with distinct \\n//vovel count =5 remains)\\n\\nO(n) solution:\\nclass Solution {\\nprivate:\\n    bool check(char ch)\\n    {\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\'|| ch==\\'o\\'|| ch==\\'u\\')\\n            return true;\\n        return false;\\n    }\\n    int solve(string& w,int c)\\n    {\\n        int n=w.size();\\n        unordered_map<int,int> mp;\\n        int i=0,ans=0,start=0;\\n        while(i<n)\\n        {\\n            if(!check(w[i]))\\n            {\\n                mp.clear();\\n                start=i+1;\\n                ++i\\n                continue;\\n            }\\n            mp[w[i]]++;\\n            if(mp.size()<=c)\\n            {\\n                ans+=i-start+1;\\n                ++i\\n            }\\n            else\\n            {\\n                while(start<=i && mp.size()>c)\\n                {\\n                --mp[w[start]];\\n                if(mp[w[start]]==0)mp.erase(w[start]);\\n                ++start;\\n                ans+=i-start+1;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countVowelSubstrings(string w) {\\n        return solve(w,5)-solve(w,4);\\n    }\\n};\\n//Like if it helped you :)\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n//The basic idea is to find all substrings with <=5 vovels and then find all substrings with \\n//distinct vovels <=4 and return substraction of both(Basic maths as <=4 contains \\n//all substrings <=4 and when we subtract it from <=5 only substrings with distinct \\n//vovel count =5 remains)\\n\\nO(n) solution:\\nclass Solution {\\nprivate:\\n    bool check(char ch)\\n    {\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\'|| ch==\\'o\\'|| ch==\\'u\\')\\n            return true;\\n        return false;\\n    }\\n    int solve(string& w,int c)\\n    {\\n        int n=w.size();\\n        unordered_map<int,int> mp;\\n        int i=0,ans=0,start=0;\\n        while(i<n)\\n        {\\n            if(!check(w[i]))\\n            {\\n                mp.clear();\\n                start=i+1;\\n                ++i\\n                continue;\\n            }\\n            mp[w[i]]++;\\n            if(mp.size()<=c)\\n            {\\n                ans+=i-start+1;\\n                ++i\\n            }\\n            else\\n            {\\n                while(start<=i && mp.size()>c)\\n                {\\n                --mp[w[start]];\\n                if(mp[w[start]]==0)mp.erase(w[start]);\\n                ++start;\\n                ans+=i-start+1;\\n            }\\n        }\\n        return ans;\\n    }\\npublic:\\n    int countVowelSubstrings(string w) {\\n        return solve(w,5)-solve(w,4);\\n    }\\n};\\n//Like if it helped you :)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564159,
                "title": "python3-sliding-window-o-n-with-explanations",
                "content": "\\n```python\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        result = 0\\n        vowels = \\'aeiou\\'\\n        # dictionary to record counts of each char\\n        mp = defaultdict(lambda: 0)\\n\\n        for i, char in enumerate(word):\\n            # if the current letter is a vowel\\n            if char in vowels:\\n                mp[char] += 1\\n                # if the previous letter is not a vowel, set the current point to a left point and a pivot\\n                if i == 0 or word[i-1] not in vowels:\\n                    left = pivot = i\\n                # if all five vowels are founded,\\n                # try to calculate how many substrings that contain all five vowels using sliding window\\n                # window range is between the left point and the current i point\\n\\t\\t\\t\\t# move the pivot to the right-side one by one, check if [pivot, i] contains all five vowels\\n                while len(mp) == 5 and all(mp.values()):\\n                    mp[word[pivot]] -= 1\\n                    pivot += 1\\n                result += (pivot - left)\\n            else:\\n                mp.clear()\\n                left = pivot = i+1\\n        \\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```python\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        result = 0\\n        vowels = \\'aeiou\\'\\n        # dictionary to record counts of each char\\n        mp = defaultdict(lambda: 0)\\n\\n        for i, char in enumerate(word):\\n            # if the current letter is a vowel\\n            if char in vowels:\\n                mp[char] += 1\\n                # if the previous letter is not a vowel, set the current point to a left point and a pivot\\n                if i == 0 or word[i-1] not in vowels:\\n                    left = pivot = i\\n                # if all five vowels are founded,\\n                # try to calculate how many substrings that contain all five vowels using sliding window\\n                # window range is between the left point and the current i point\\n\\t\\t\\t\\t# move the pivot to the right-side one by one, check if [pivot, i] contains all five vowels\\n                while len(mp) == 5 and all(mp.values()):\\n                    mp[word[pivot]] -= 1\\n                    pivot += 1\\n                result += (pivot - left)\\n            else:\\n                mp.clear()\\n                left = pivot = i+1\\n        \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2385471,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Appraoch 1 :- Using Brute Force***\\n\\n* ***Time Complexity :- O(N ^ 3)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool is_contain(string str)\\n    {\\n        int n = str.size();\\n        \\n        bool a = false;\\n        \\n        bool e = false;\\n        \\n        bool i = false;\\n        \\n        bool o = false;\\n        \\n        bool u = false;\\n        \\n        for(int k = 0; k < n; k++)\\n        {\\n            if(str[k] == \\'a\\')\\n            {\\n                a = true;\\n            }\\n            else if(str[k] == \\'e\\')\\n            {\\n                e = true;\\n            }\\n            else if(str[k] == \\'i\\')\\n            {\\n                i = true;\\n            }\\n            else if(str[k] == \\'o\\')\\n            {\\n                o = true;\\n            }\\n            else if(str[k] == \\'u\\')\\n            {\\n                u = true;\\n            }\\n            else\\n                return false;\\n        }\\n        \\n        return (a && e && i && o && u);\\n    }\\n    \\n    int countVowelSubstrings(string str) {\\n        \\n        int n = str.size();\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            string sub = \"\";\\n            \\n            for(int j = i; j < n; j++)\\n            {\\n                sub += str[j];\\n                \\n                if(sub.size() >= 5 && is_contain(sub))\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n* ***Approach 2 :- Brute Force***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool is_vowel(char ch)\\n    {\\n        return (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\');\\n    }\\n    \\n    int countVowelSubstrings(string str) {\\n        \\n        int n = str.size();\\n       \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            unordered_set<char> s;\\n            \\n            for(int j = i; j < n; j++)\\n            {\\n                if(is_vowel(str[j]))\\n                {\\n                    s.insert(str[j]);\\n                }\\n                else\\n                    break;\\n                \\n                if(s.size() == 5)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\\n\\n* ***Approach 3 :- Using Sliding Window && Unordered Map***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // function to check, a charater is vowel or not\\n    \\n    bool is_vowel(char ch)\\n    {\\n        return (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\');\\n    }\\n    \\n    // the below function count the no. of substrings having at most k unique vowels\\n    \\n    int count_at_most_k(string& str, int k)\\n    {\\n        int n = str.size();\\n        \\n        // store the count of each character in a substring\\n        \\n        unordered_map<char, int> mp;\\n       \\n        int count = 0;\\n        \\n        int left = 0;\\n        \\n        for(int right = 0; right < n; right++)\\n        {\\n            // if curr character is not vowel \\n            \\n            if(is_vowel(str[right]) == false)\\n            {\\n                // update left pointer\\n                \\n                left = right + 1;\\n                \\n                // delete all the previously stored count\\n                \\n                mp.clear();\\n                \\n                continue;\\n            }\\n            \\n            // if curr character is vowel\\n            \\n            else\\n            {\\n                // increment the count of curr character\\n                \\n                mp[str[right]]++;\\n                \\n                // if no. of unique vowel is greater than k,\\n                \\n                // decrement the count from the left\\n                \\n                while(left <= right && mp.size() > k)\\n                {\\n                    mp[str[left]]--;\\n                    \\n                    if(mp[str[left]] == 0)\\n                    {\\n                        mp.erase(str[left]);\\n                    }\\n                    \\n                    left++;\\n                }\\n                \\n                // update the count\\n                \\n                count += right - left + 1;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int countVowelSubstrings(string str) {\\n        \\n        int at_most_5 = count_at_most_k(str, 5);\\n        \\n        int at_most_4 = count_at_most_k(str, 4);\\n        \\n        // this will give the no. of substrings which has exactly k unique vowels\\n        \\n        return at_most_5 - at_most_4;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool is_contain(string str)\\n    {\\n        int n = str.size();\\n        \\n        bool a = false;\\n        \\n        bool e = false;\\n        \\n        bool i = false;\\n        \\n        bool o = false;\\n        \\n        bool u = false;\\n        \\n        for(int k = 0; k < n; k++)\\n        {\\n            if(str[k] == \\'a\\')\\n            {\\n                a = true;\\n            }\\n            else if(str[k] == \\'e\\')\\n            {\\n                e = true;\\n            }\\n            else if(str[k] == \\'i\\')\\n            {\\n                i = true;\\n            }\\n            else if(str[k] == \\'o\\')\\n            {\\n                o = true;\\n            }\\n            else if(str[k] == \\'u\\')\\n            {\\n                u = true;\\n            }\\n            else\\n                return false;\\n        }\\n        \\n        return (a && e && i && o && u);\\n    }\\n    \\n    int countVowelSubstrings(string str) {\\n        \\n        int n = str.size();\\n        \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            string sub = \"\";\\n            \\n            for(int j = i; j < n; j++)\\n            {\\n                sub += str[j];\\n                \\n                if(sub.size() >= 5 && is_contain(sub))\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    bool is_vowel(char ch)\\n    {\\n        return (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\');\\n    }\\n    \\n    int countVowelSubstrings(string str) {\\n        \\n        int n = str.size();\\n       \\n        int count = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            unordered_set<char> s;\\n            \\n            for(int j = i; j < n; j++)\\n            {\\n                if(is_vowel(str[j]))\\n                {\\n                    s.insert(str[j]);\\n                }\\n                else\\n                    break;\\n                \\n                if(s.size() == 5)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    \\n    // function to check, a charater is vowel or not\\n    \\n    bool is_vowel(char ch)\\n    {\\n        return (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\');\\n    }\\n    \\n    // the below function count the no. of substrings having at most k unique vowels\\n    \\n    int count_at_most_k(string& str, int k)\\n    {\\n        int n = str.size();\\n        \\n        // store the count of each character in a substring\\n        \\n        unordered_map<char, int> mp;\\n       \\n        int count = 0;\\n        \\n        int left = 0;\\n        \\n        for(int right = 0; right < n; right++)\\n        {\\n            // if curr character is not vowel \\n            \\n            if(is_vowel(str[right]) == false)\\n            {\\n                // update left pointer\\n                \\n                left = right + 1;\\n                \\n                // delete all the previously stored count\\n                \\n                mp.clear();\\n                \\n                continue;\\n            }\\n            \\n            // if curr character is vowel\\n            \\n            else\\n            {\\n                // increment the count of curr character\\n                \\n                mp[str[right]]++;\\n                \\n                // if no. of unique vowel is greater than k,\\n                \\n                // decrement the count from the left\\n                \\n                while(left <= right && mp.size() > k)\\n                {\\n                    mp[str[left]]--;\\n                    \\n                    if(mp[str[left]] == 0)\\n                    {\\n                        mp.erase(str[left]);\\n                    }\\n                    \\n                    left++;\\n                }\\n                \\n                // update the count\\n                \\n                count += right - left + 1;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n    \\n    int countVowelSubstrings(string str) {\\n        \\n        int at_most_5 = count_at_most_k(str, 5);\\n        \\n        int at_most_4 = count_at_most_k(str, 4);\\n        \\n        // this will give the no. of substrings which has exactly k unique vowels\\n        \\n        return at_most_5 - at_most_4;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1956551,
                "title": "sliding-window-intuitive-solution-js-self-explanatory",
                "content": "```\\nvar countVowelSubstrings = function(word) {\\n    \\n    let vowelObj = {\\'a\\': 1, \\'e\\': 1, \\'i\\': 1, \\'o\\': 1, \\'u\\': 1}\\n    let map = new Map(Object.entries(vowelObj));\\n    \\n    let left = 0;\\n    let tempStr = \"\"\\n    let pointer = 0\\n    let res = 0;\\n    while(left <= word.length - 5){\\n        if(map.has(word[pointer])){\\n            tempStr += word[pointer++];\\n            if(tempStr.length >= 5 && isAllVowel(tempStr)){\\n                res++;\\n            }\\n        }else{\\n            left++;\\n            tempStr = \"\"\\n            pointer = left;\\n        }\\n    }\\n    \\n    function isAllVowel(str) {\\n        return str.includes(\\'a\\') && str.includes(\\'e\\') && str.includes(\\'i\\') && str.includes(\\'o\\') && str.includes(\\'u\\'); \\n    }\\n    \\n    return res;\\n    \\n};\\n```\\n\\nPlease upvote if you find this helpful :)",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar countVowelSubstrings = function(word) {\\n    \\n    let vowelObj = {\\'a\\': 1, \\'e\\': 1, \\'i\\': 1, \\'o\\': 1, \\'u\\': 1}\\n    let map = new Map(Object.entries(vowelObj));\\n    \\n    let left = 0;\\n    let tempStr = \"\"\\n    let pointer = 0\\n    let res = 0;\\n    while(left <= word.length - 5){\\n        if(map.has(word[pointer])){\\n            tempStr += word[pointer++];\\n            if(tempStr.length >= 5 && isAllVowel(tempStr)){\\n                res++;\\n            }\\n        }else{\\n            left++;\\n            tempStr = \"\"\\n            pointer = left;\\n        }\\n    }\\n    \\n    function isAllVowel(str) {\\n        return str.includes(\\'a\\') && str.includes(\\'e\\') && str.includes(\\'i\\') && str.includes(\\'o\\') && str.includes(\\'u\\'); \\n    }\\n    \\n    return res;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1699004,
                "title": "c-time-complexity-o-n-2-space-complexity-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        int n = word.size();\\n        int res = 0;\\n        \\n        unordered_set<char> vowels {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            unordered_set<char> letters;\\n            // string temp = \"\";\\n            for (int j = i; j < n; j++)\\n            {\\n                // temp += word[j];\\n                letters.insert(word[j]);\\n                if (letters == vowels)\\n                res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}; \\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        int n = word.size();\\n        int res = 0;\\n        \\n        unordered_set<char> vowels {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        \\n        for (int i = 0; i < n; i++)\\n        {\\n            unordered_set<char> letters;\\n            // string temp = \"\";\\n            for (int j = i; j < n; j++)\\n            {\\n                // temp += word[j];\\n                letters.insert(word[j]);\\n                if (letters == vowels)\\n                res++;\\n            }\\n        }\\n        \\n        return res;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753220,
                "title": "python-3-simple-solution-beginner-s-easy-understand",
                "content": "```\\nv={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}\\nc=0\\nfor i in range(len(word)-4):\\n\\tfor j in range(i+5,len(word)+1):\\n\\t\\tif set(word[i:j])==v:\\n\\t\\t\\tc+=1\\nreturn c\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nv={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}\\nc=0\\nfor i in range(len(word)-4):\\n\\tfor j in range(i+5,len(word)+1):\\n\\t\\tif set(word[i:j])==v:\\n\\t\\t\\tc+=1\\nreturn c\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1563750,
                "title": "c-sorting",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        int count=0;\\n        for(int i=0;i<word.size()-1;i++)\\n        {\\n            for(int j=i+1;j<word.size();j++)\\n            {\\n                string t=word.substr(i,j-i+1);\\n                sort(t.begin(),t.end());\\n                t.erase(unique(t.begin(),t.end()),t.end());\\n             \\n                if(t.size()==5 && t[0]==\\'a\\' && t[1]==\\'e\\' && t[2]==\\'i\\' && t[3]==\\'o\\' && t[4]==\\'u\\')\\n                    count++;\\n            }\\n        }\\n       return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        int count=0;\\n        for(int i=0;i<word.size()-1;i++)\\n        {\\n            for(int j=i+1;j<word.size();j++)\\n            {\\n                string t=word.substr(i,j-i+1);\\n                sort(t.begin(),t.end());\\n                t.erase(unique(t.begin(),t.end()),t.end());\\n             \\n                if(t.size()==5 && t[0]==\\'a\\' && t[1]==\\'e\\' && t[2]==\\'i\\' && t[3]==\\'o\\' && t[4]==\\'u\\')\\n                    count++;\\n            }\\n        }\\n       return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2787709,
                "title": "java-71-time-72-memory-solution",
                "content": "# Complexity\\n- Time complexity: O (N * N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        int countSubs = 0;\\n        byte[] vowels = new byte[5];\\n        for (int i = 0; i < word.length(); i++) {\\n            int count = i;\\n            while (count < word.length() && isVowel(word.charAt(count))) {\\n                char c = word.charAt(count);\\n                switch (c) {\\n                    case \\'a\\':\\n                        vowels[0]++;\\n                        break;\\n                    case \\'e\\':\\n                        vowels[1]++;\\n                        break;\\n                    case \\'i\\':\\n                        vowels[2]++;\\n                        break;\\n                    case \\'o\\':\\n                        vowels[3]++;\\n                        break;\\n                    case \\'u\\':\\n                        vowels[4]++;\\n                        break;\\n                }\\n                if (containsAllVowels(vowels)) {\\n                    countSubs++;\\n                }\\n                count++;\\n            }\\n            refreshArray(vowels);\\n        }\\n        return countSubs;\\n    }\\n\\n    private static void refreshArray(byte[] vowels) {\\n        for (int i = 0; i < vowels.length; i++) {\\n            vowels[i] = 0;\\n        }\\n    }\\n\\n    private static boolean containsAllVowels(byte[] vowels) {\\n        for (byte b : vowels) {\\n            if (b == 0) return false;\\n        }\\n        return true;\\n    }\\n\\n    private static boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        int countSubs = 0;\\n        byte[] vowels = new byte[5];\\n        for (int i = 0; i < word.length(); i++) {\\n            int count = i;\\n            while (count < word.length() && isVowel(word.charAt(count))) {\\n                char c = word.charAt(count);\\n                switch (c) {\\n                    case \\'a\\':\\n                        vowels[0]++;\\n                        break;\\n                    case \\'e\\':\\n                        vowels[1]++;\\n                        break;\\n                    case \\'i\\':\\n                        vowels[2]++;\\n                        break;\\n                    case \\'o\\':\\n                        vowels[3]++;\\n                        break;\\n                    case \\'u\\':\\n                        vowels[4]++;\\n                        break;\\n                }\\n                if (containsAllVowels(vowels)) {\\n                    countSubs++;\\n                }\\n                count++;\\n            }\\n            refreshArray(vowels);\\n        }\\n        return countSubs;\\n    }\\n\\n    private static void refreshArray(byte[] vowels) {\\n        for (int i = 0; i < vowels.length; i++) {\\n            vowels[i] = 0;\\n        }\\n    }\\n\\n    private static boolean containsAllVowels(byte[] vowels) {\\n        for (byte b : vowels) {\\n            if (b == 0) return false;\\n        }\\n        return true;\\n    }\\n\\n    private static boolean isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2177576,
                "title": "javascript-set-solution",
                "content": "```\\nconst countVowelSubstrings = word => {\\n  const vowels = new Set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']);\\n  const set = new Set();\\n  let count = 0;\\n\\n  for (let i = 0; i < word.length; i += 1) {\\n    set.clear();\\n\\n    for (let j = 0; j + i < word.length && vowels.has(word[j + i]); j += 1) {\\n      set.add(word[i + j]);\\n\\n      if (set.size === vowels.size) {\\n        count += 1;\\n      }\\n    }\\n  }\\n\\n  return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst countVowelSubstrings = word => {\\n  const vowels = new Set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']);\\n  const set = new Set();\\n  let count = 0;\\n\\n  for (let i = 0; i < word.length; i += 1) {\\n    set.clear();\\n\\n    for (let j = 0; j + i < word.length && vowels.has(word[j + i]); j += 1) {\\n      set.add(word[i + j]);\\n\\n      if (set.size === vowels.size) {\\n        count += 1;\\n      }\\n    }\\n  }\\n\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1795513,
                "title": "count-vowel-substrings-of-a-string",
                "content": "```\\nclass Solution {\\n    public static boolean check(String s){\\n        Set<Character> sb=new HashSet<Character>();\\n        for(int i=0;i<s.length();i++)\\n            sb.add(s.charAt(i));\\n        if(sb.contains(\\'a\\') && sb.contains(\\'e\\') && sb.contains(\\'i\\') && sb.contains(\\'o\\') &&sb.contains(\\'u\\') && sb.size()==5){\\n                    //System.out.println(s);\\n                    return true;\\n        }\\n        return false;\\n    } \\n    public int countVowelSubstrings(String word) {\\n        int count=0;\\n        for(int i=0;i<word.length();i++){\\n            StringBuilder sb=new StringBuilder();\\n            for(int j=i;j<word.length();j++){\\n                sb.append(word.charAt(j));\\n                System.out.println(sb.toString());\\n                if(check(sb.toString()))\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public static boolean check(String s){\\n        Set<Character> sb=new HashSet<Character>();\\n        for(int i=0;i<s.length();i++)\\n            sb.add(s.charAt(i));\\n        if(sb.contains(\\'a\\') && sb.contains(\\'e\\') && sb.contains(\\'i\\') && sb.contains(\\'o\\') &&sb.contains(\\'u\\') && sb.size()==5){\\n                    //System.out.println(s);\\n                    return true;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1626092,
                "title": "java-2-solutions-similar-to-1358-number-of-substrings-containing-all-three-characters",
                "content": "This is the harder variant of the medium question [1358. Number of Substrings Containing All Three Characters](https://leetcode.com/problems/number-of-substrings-containing-all-three-characters/) and yet this question is classified as easy and that as a medium. \\n\\nUse sliding window and count the number of valid substrings that starts with index 0, 1, then 2, so on and so forth. The thing that\\'s trickier for this question than 1358 is that \\n\\nA. we have non vowel characters that we have to deal with here, and \\nB. because of that, our end for the sliding window is the last conseuctive vowel. \\n\\nThe valid number of substrings for substring that starts with index `j` is then `end - i`, with `i` being the index of first vowel that forms a valid substring.\\n\\nIt should be a medium level question. \\n\\n**Time Complexity: O(n) [Old solution. Newer version is down below]**\\n\\n```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        char[] arr = word.toCharArray();\\n        int[] count= new int[26];\\n\\n        int j = 0; //start index for the sliding window\\n        int ans = 0;\\n        int end = 0; //no need to recompute end every time so we declare it here\\n        for (int i = 0; i < arr.length; i++){\\n            if(!isVowel(arr[i])) {count = new int[26]; j = i + 1; continue;} //reset count arr if cur char isn\\'t a vowel, and set our start index to i + 1\\n\\n            count[arr[i] - \\'a\\']++;\\n            if (i >= end) end = i + 1; //only update end when necessary\\n            while(j < arr.length && found(count)){\\n                while(end < arr.length && isVowel(arr[end])) end++; //update end position if needed\\n                ans += end - i; //this is the valid range\\n                count[arr[j++] - \\'a\\']--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private static boolean found(int[] count){\\n        return count[\\'a\\' - \\'a\\'] > 0 && count[\\'e\\' - \\'a\\'] > 0\\n            && count[\\'i\\' - \\'a\\'] > 0 && count[\\'o\\' - \\'a\\'] > 0\\n            && count[\\'u\\' - \\'a\\'] > 0;\\n    }\\n\\n    private static boolean isVowel(char ch){\\n        return ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\'\\n            || ch == \\'o\\' || ch == \\'u\\';\\n    }\\n}\\n```\\n\\nI updated this in April here. \\nNow it is more concise:\\n\\nIt is still O(n) time complexity but may run a bit slower on LeetCode because HashMap tends to be slower than int array. \\n**[New Version]**\\n```Java\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        int ans = 0;\\n        String vowels = \"aeiou\";\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0, j = -1; i < word.length(); i++){ // j is the letter behind the current start of the window\\n            int found = vowels.indexOf(word.charAt(i));\\n            if (found == -1){ // Reset everything because it can\\'t end with i\\n                map.clear();\\n                j = i;\\n            }else{\\n                map.put(found, i); // we only care about the latest index for any given vowel\\n            }\\n            if (map.size() == 5){ // we have the min idx of the vowels - j valid subarrays.\\n                ans += map.values().stream().min(Integer::compare).get() - j;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        char[] arr = word.toCharArray();\\n        int[] count= new int[26];\\n\\n        int j = 0; //start index for the sliding window\\n        int ans = 0;\\n        int end = 0; //no need to recompute end every time so we declare it here\\n        for (int i = 0; i < arr.length; i++){\\n            if(!isVowel(arr[i])) {count = new int[26]; j = i + 1; continue;} //reset count arr if cur char isn\\'t a vowel, and set our start index to i + 1\\n\\n            count[arr[i] - \\'a\\']++;\\n            if (i >= end) end = i + 1; //only update end when necessary\\n            while(j < arr.length && found(count)){\\n                while(end < arr.length && isVowel(arr[end])) end++; //update end position if needed\\n                ans += end - i; //this is the valid range\\n                count[arr[j++] - \\'a\\']--;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n\\n    private static boolean found(int[] count){\\n        return count[\\'a\\' - \\'a\\'] > 0 && count[\\'e\\' - \\'a\\'] > 0\\n            && count[\\'i\\' - \\'a\\'] > 0 && count[\\'o\\' - \\'a\\'] > 0\\n            && count[\\'u\\' - \\'a\\'] > 0;\\n    }\\n\\n    private static boolean isVowel(char ch){\\n        return ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\'\\n            || ch == \\'o\\' || ch == \\'u\\';\\n    }\\n}\\n```\n```Java\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        int ans = 0;\\n        String vowels = \"aeiou\";\\n        Map<Integer, Integer> map = new HashMap<>();\\n\\n        for (int i = 0, j = -1; i < word.length(); i++){ // j is the letter behind the current start of the window\\n            int found = vowels.indexOf(word.charAt(i));\\n            if (found == -1){ // Reset everything because it can\\'t end with i\\n                map.clear();\\n                j = i;\\n            }else{\\n                map.put(found, i); // we only care about the latest index for any given vowel\\n            }\\n            if (map.size() == 5){ // we have the min idx of the vowels - j valid subarrays.\\n                ans += map.values().stream().min(Integer::compare).get() - j;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568614,
                "title": "simple-brute-force-c-solution",
                "content": "class Solution {\\npublic:\\n\\n    int countVowelSubstrings(string w) {\\n        int n=w.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            set<char>s;\\n            for(int j=i;j<n;j++)\\n            {\\n                if(w[j]==\\'a\\'||w[j]==\\'e\\'||w[j]==\\'i\\'||w[j]==\\'o\\'||w[j]==\\'u\\')\\n                {\\n                 s.insert(w[j]);  \\n                 if(s.size()==5)\\n                 ans++;\\n                }\\n                else\\n                break;\\n            } \\n        } \\n       return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "String",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n\\n    int countVowelSubstrings(string w) {\\n        int n=w.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            set<char>s;\\n            for(int j=i;j<n;j++)\\n            {\\n                if(w[j]==\\'a\\'||w[j]==\\'e\\'||w[j]==\\'i\\'||w[j]==\\'o\\'||w[j]==\\'u\\')\\n                {\\n                 s.insert(w[j]);  \\n                 if(s.size()==5)\\n                 ans++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1564039,
                "title": "concise-java-9-lines",
                "content": "```java\\npublic int countVowelSubstrings(String word) {\\n        Set<Character> vowels = Set.of(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'), curr = new HashSet<>();\\n        int r = 0;\\n        char[] w = word.toCharArray();\\n        for (int i = 0; i < w.length; i++, curr.clear())\\n            for (int j = i; j < w.length && vowels.contains(w[j]); j++) {\\n                curr.add(w[j]);\\n                r += curr.size() == vowels.size() ? 1 : 0;\\n            }\\n        return r;\\n    }",
                "solutionTags": [],
                "code": "```java\\npublic int countVowelSubstrings(String word) {\\n        Set<Character> vowels = Set.of(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'), curr = new HashSet<>();\\n        int r = 0;\\n        char[] w = word.toCharArray();\\n        for (int i = 0; i < w.length; i++, curr.clear())\\n            for (int j = i; j < w.length && vowels.contains(w[j]); j++) {\\n                curr.add(w[j]);\\n                r += curr.size() == vowels.size() ? 1 : 0;\\n            }\\n        return r;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1563830,
                "title": "python-brute-force",
                "content": "\\tclass Solution:\\n\\t\\tdef countVowelSubstrings(self, word: str) -> int:\\n\\t\\t\\tvowels = {\"a\", \"e\", \"i\", \"o\", \"u\"}        \\n\\t\\t\\tres = 0\\n\\t\\t\\tfor i in range(len(word) - 4):\\n\\t\\t\\t\\tj = i\\n\\t\\t\\t\\tseen = set()\\n\\t\\t\\t\\twhile j < len(word):\\n\\t\\t\\t\\t\\tif word[j] in vowels:\\n\\t\\t\\t\\t\\t\\tseen.add(word[j])\\n\\t\\t\\t\\t\\t\\tj += 1\\n\\t\\t\\t\\t\\t\\tif len(seen) == 5:\\n\\t\\t\\t\\t\\t\\t\\tres += 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\treturn res",
                "solutionTags": [],
                "code": "class Solution:\\n\\t\\tdef countVowelSubstrings(self, word: str) -> int:\\n\\t\\t\\tvowels = {\"a\", \"e\", \"i\", \"o\", \"u\"}",
                "codeTag": "Java"
            },
            {
                "id": 1563735,
                "title": "java-o-n-three-points",
                "content": "```\\n    private int sln2(String w){\\n        int n = w.length();\\n        int[] map = new int[26];\\n        Arrays.fill(map, -1);\\n        map[\\'a\\'-\\'a\\'] = 0; map[\\'e\\'-\\'a\\'] = 1; map[\\'i\\'-\\'a\\'] = 2; map[\\'o\\'-\\'a\\'] = 3; map[\\'u\\'-\\'a\\'] = 4;\\n        int[] count = new int[5];\\n        int unique = 0;\\n        int res = 0;\\n        for(int i = 0, l= 0, r=0;i<n;i++){\\n            char c = w.charAt(i);\\n            if(map[c-\\'a\\']==-1) {\\n                count = new int[5];\\n                unique = 0; \\n                l=i+1; r= i+1;\\n            }else{\\n                count[map[c-\\'a\\']]++;\\n                if(count[map[c-\\'a\\']] == 1) unique++;\\n                while(unique==5){\\n                    char c2 = w.charAt(r++);\\n                    count[map[c2-\\'a\\']]--;\\n                    if(count[map[c2-\\'a\\']] == 0) unique--;\\n                }\\n                res+= r-l;\\n            }\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "```\\n    private int sln2(String w){\\n        int n = w.length();\\n        int[] map = new int[26];\\n        Arrays.fill(map, -1);\\n        map[\\'a\\'-\\'a\\'] = 0; map[\\'e\\'-\\'a\\'] = 1; map[\\'i\\'-\\'a\\'] = 2; map[\\'o\\'-\\'a\\'] = 3; map[\\'u\\'-\\'a\\'] = 4;\\n        int[] count = new int[5];\\n        int unique = 0;\\n        int res = 0;\\n        for(int i = 0, l= 0, r=0;i<n;i++){\\n            char c = w.charAt(i);\\n            if(map[c-\\'a\\']==-1) {\\n                count = new int[5];\\n                unique = 0; \\n                l=i+1; r= i+1;\\n            }else{\\n                count[map[c-\\'a\\']]++;\\n                if(count[map[c-\\'a\\']] == 1) unique++;\\n                while(unique==5){\\n                    char c2 = w.charAt(r++);\\n                    count[map[c2-\\'a\\']]--;\\n                    if(count[map[c2-\\'a\\']] == 0) unique--;\\n                }\\n                res+= r-l;\\n            }\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3245865,
                "title": "two-pointer-approach-run-time-is-slow-but-low-memory-needed-starightforward-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        vowels = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}\\n        pointer = 0\\n        res = 0\\n        if len(word) <= 4:\\n            return 0\\n        while pointer != len(word)-4:\\n            # if set(list(word[pointer:pointer+5])) == vowels:\\n            #     temp = 1\\n            #     res += 1\\n            #     while set(list(word[pointer:pointer+temp+5])) == vowels and pointer+temp+4 != len(word):\\n            #         res += 1\\n            #         temp += 1\\n            # elif word[pointer] in vowels:\\n            #     temp = 1\\n            #     while set(list(word[pointer:pointer+5+temp])) != vowels:\\n            #         temp += 1\\n            #     res += 1\\n            # pointer += 1\\n            temp = 0\\n            if word[pointer] in vowels:\\n                while temp+pointer != len(word)-4:\\n                    test_1 = set(list(word[pointer:pointer+temp+5]))\\n                    test_2 = word[pointer:pointer+temp+5]\\n                    if set(list(word[pointer:pointer+temp+5])).issubset(vowels): \\n                        if set(list(word[pointer:pointer+temp+5])) == vowels:\\n                            res += 1\\n                        temp+=1\\n                    else:\\n                        break\\n                    \\n            pointer += 1\\n        return res\\n\\n            \\n```",
                "solutionTags": [
                    "Python3",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        vowels = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}\\n        pointer = 0\\n        res = 0\\n        if len(word) <= 4:\\n            return 0\\n        while pointer != len(word)-4:\\n            # if set(list(word[pointer:pointer+5])) == vowels:\\n            #     temp = 1\\n            #     res += 1\\n            #     while set(list(word[pointer:pointer+temp+5])) == vowels and pointer+temp+4 != len(word):\\n            #         res += 1\\n            #         temp += 1\\n            # elif word[pointer] in vowels:\\n            #     temp = 1\\n            #     while set(list(word[pointer:pointer+5+temp])) != vowels:\\n            #         temp += 1\\n            #     res += 1\\n            # pointer += 1\\n            temp = 0\\n            if word[pointer] in vowels:\\n                while temp+pointer != len(word)-4:\\n                    test_1 = set(list(word[pointer:pointer+temp+5]))\\n                    test_2 = word[pointer:pointer+temp+5]\\n                    if set(list(word[pointer:pointer+temp+5])).issubset(vowels): \\n                        if set(list(word[pointer:pointer+temp+5])) == vowels:\\n                            res += 1\\n                        temp+=1\\n                    else:\\n                        break\\n                    \\n            pointer += 1\\n        return res\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2670441,
                "title": "python",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:        \\n        fin=0\\n        for i in range(len(word)):             \\n            res = set()\\n            for j in range(i,len(word)):\\n                if word[j] in \\'aeiou\\':\\n                    res.add(word[j])\\n                    if len(res)>=5:\\n                        fin+=1\\n                else:\\n                    break                \\n        return fin\\n                \\n            \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:        \\n        fin=0\\n        for i in range(len(word)):             \\n            res = set()\\n            for j in range(i,len(word)):\\n                if word[j] in \\'aeiou\\':\\n                    res.add(word[j])\\n                    if len(res)>=5:\\n                        fin+=1\\n                else:\\n                    break                \\n        return fin\\n                \\n            \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2608960,
                "title": "brute-force-approch-using-set",
                "content": "class Solution {\\n    bool vowel(char ch)\\n    {\\n        if(ch==\\'a\\'||ch==\\'i\\'||ch==\\'e\\'||ch==\\'o\\'||ch==\\'u\\')\\n            return true;\\n        else\\n            return false;\\n    }\\npublic:\\n    int countVowelSubstrings(string word) \\n    {\\n        int cnt=0;\\n        for(int i=0;i<word.size();i++)\\n        {\\n            set<char>s;\\n            for(int j=i;j<word.length();j++)\\n            {\\n                if(!vowel(word[j]))\\n                    break;\\n                s.insert(word[j]);\\n                if(s.size()==5)\\n                {\\n                    cnt+=1;\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    bool vowel(char ch)\\n    {\\n        if(ch==\\'a\\'||ch==\\'i\\'||ch==\\'e\\'||ch==\\'o\\'||ch==\\'u\\')\\n            return true;\\n        else\\n            return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2583054,
                "title": "c-set-bruteforce-easy-and-clean",
                "content": "\\tbool isVowel(char word)\\n    {\\n        return word==\\'a\\'||word==\\'e\\'||word==\\'i\\'||word==\\'o\\'||word==\\'u\\';\\n    }\\n    int countVowelSubstrings(string word) {\\n        int n=word.size();\\n        int ans=0;\\n        unordered_set<char>st;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!isVowel(word[i])) continue;  //if ith word is not a vowel then no need to check futher\\n            for(int j=i;j<n;j++)  \\n            {\\n                if(isVowel(word[j]))  //if the jth word is a vowel insert in a set, keep on doing this till we don\\'t find a non-vowel char...\\n                {\\n                    st.insert(word[j]);\\n                    if(st.size()==5) ans++;  //if the set size becomes 5 means we have all the vowels in our current substring increment ans...\\n                }\\n                else  //anytime j becomes non-vowel break;\\n                {\\n                    break;\\n                }\\n            }\\n            st.clear();  //clear the string before going to next iteration so that it wont\\'t hit (st.size()==5) this condition already...\\n        }\\n        return ans;\\n    }",
                "solutionTags": [],
                "code": "\\tbool isVowel(char word)\\n    {\\n        return word==\\'a\\'||word==\\'e\\'||word==\\'i\\'||word==\\'o\\'||word==\\'u\\';\\n    }\\n    int countVowelSubstrings(string word) {\\n        int n=word.size();\\n        int ans=0;\\n        unordered_set<char>st;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(!isVowel(word[i])) continue;  //if ith word is not a vowel then no need to check futher\\n            for(int j=i;j<n;j++)  \\n            {\\n                if(isVowel(word[j]))  //if the jth word is a vowel insert in a set, keep on doing this till we don\\'t find a non-vowel char...\\n                {\\n                    st.insert(word[j]);\\n                    if(st.size()==5) ans++;  //if the set size becomes 5 means we have all the vowels in our current substring increment ans...\\n                }\\n                else  //anytime j becomes non-vowel break;\\n                {\\n                    break;\\n                }\\n            }\\n            st.clear();  //clear the string before going to next iteration so that it wont\\'t hit (st.size()==5) this condition already...\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2457479,
                "title": "o-n-solution",
                "content": "This problem should bw a mediam level problem with constrains that it should be solved in o(n)..\\nAnd I am posting my o(n) solution....\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(char c){\\n        return (c==\\'a\\'||c==\\'e\\'||c==\\'i\\'||c==\\'o\\'||c==\\'u\\');\\n    }\\n    int get_min(map<char,int>&m){\\n        int ans=1e9;\\n        for(auto it :m)ans=min(ans,it.second);\\n        if(ans!=1e9)return ans;\\n        else return -1;\\n    }\\n    string vov=\"aeiou\"; \\n    int countVowelSubstrings(string word) {\\n        int ans=0;\\n        map<char,int>m;\\n        int prev_vov=-1;\\n        for(int i=0;i<word.size();i++){\\n            if(isvalid(word[i])){\\n                if(prev_vov==-1){\\n                    prev_vov=i;\\n                }\\n                m[word[i]]=i;\\n                if(m.size()==5){\\n                    ans+=(get_min(m)-prev_vov+1);\\n                }\\n            }\\n            else {\\n                prev_vov=-1;\\n                m.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(char c){\\n        return (c==\\'a\\'||c==\\'e\\'||c==\\'i\\'||c==\\'o\\'||c==\\'u\\');\\n    }\\n    int get_min(map<char,int>&m){\\n        int ans=1e9;\\n        for(auto it :m)ans=min(ans,it.second);\\n        if(ans!=1e9)return ans;\\n        else return -1;\\n    }\\n    string vov=\"aeiou\"; \\n    int countVowelSubstrings(string word) {\\n        int ans=0;\\n        map<char,int>m;\\n        int prev_vov=-1;\\n        for(int i=0;i<word.size();i++){\\n            if(isvalid(word[i])){\\n                if(prev_vov==-1){\\n                    prev_vov=i;\\n                }\\n                m[word[i]]=i;\\n                if(m.size()==5){\\n                    ans+=(get_min(m)-prev_vov+1);\\n                }\\n            }\\n            else {\\n                prev_vov=-1;\\n                m.clear();\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2449001,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        int out=0;\\n         for (int i=0;i<word.length();i++){\\n             Set<Character>st=new HashSet<>();\\n             for (int j=i;j<word.length();j++){\\n                 if (!isVowel(word.charAt(j)))break;\\n                 st.add(word.charAt(j));\\n                 if (st.size()==5)out++;\\n             }\\n         }\\n        return out;\\n    }\\n    public static boolean isVowel(char c){\\n        return c==\\'a\\'||c==\\'i\\'||c==\\'o\\'||c==\\'u\\'||c==\\'e\\';\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        int out=0;\\n         for (int i=0;i<word.length();i++){\\n             Set<Character>st=new HashSet<>();\\n             for (int j=i;j<word.length();j++){\\n                 if (!isVowel(word.charAt(j)))break;\\n                 st.add(word.charAt(j));\\n                 if (st.size()==5)out++;\\n             }\\n         }\\n        return out;\\n    }\\n    public static boolean isVowel(char c){\\n        return c==\\'a\\'||c==\\'i\\'||c==\\'o\\'||c==\\'u\\'||c==\\'e\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2316682,
                "title": "python-solution-easy-understanding-of-brute-force-and-sliding-window",
                "content": "```\\nv=\\'aeiou\\'\\ncount=0\\nfor i in range(len(word)):\\n\\t\\ts=set()\\n\\t\\tif word[i] in v:\\n\\t\\t\\t\\tfor j in range(i,len(word)):\\n\\t\\t\\t\\t\\t\\tif word[j] not in v:\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\ts.add(word[j])\\n\\t\\t\\t\\t\\t\\tif len(s)==5:\\n\\t\\t\\t\\t\\t\\t\\t\\tcount+=1\\nreturn count\\n```\\nThe above is Brute Force Approach...........\\n\\n```\\nv=\\'aeiou\\'\\nd={i:0 for i in v}\\ncount=0\\nstart=0\\nj=0\\ntotalv=0\\nfor i in range(len(word)):\\n\\t\\tif word[i] in v:\\n\\t\\t\\t\\td[word[i]]+=1\\n\\t\\t\\t\\tif d[word[i]]==1:\\n\\t\\t\\t\\t\\t\\ttotalv+=1\\n\\t\\t\\t\\twhile totalv==5:\\n\\t\\t\\t\\t\\t\\td[word[start]]-=1\\n\\t\\t\\t\\t\\t\\tif d[word[start]]==0:\\n\\t\\t\\t\\t\\t\\t\\t\\ttotalv-=1\\n\\t\\t\\t\\t\\t\\tstart+=1\\n\\t\\t\\t\\tcount+=start-j\\n\\t\\telse:\\n\\t\\t\\t\\td={i:0 for i in v}\\n\\t\\t\\t\\tstart=j=i+1\\n\\t\\t\\t\\ttotalv=0\\nreturn count\\n```\\n\\nHere we use the sliding window technique\\n1.First we find the continuous substring of vowels\\n2.Then, we take 2 variables form the first index of substring and another that iterates until we dont satisfy the condition \\n3.now we stop somewhere thus having the count by subtracting from iterated variable to starting index \\n4.also imporatant to note that if the condition doesnt satisfy and still its a vowel the substring count remains same as the previous one so we need add again \\n5.its kinda tricky but this will be understood once we see it from other side\\n6.if it is not a vowel we stop there and empty the dic count and increment the count of 2 variables and also the count of vowels should be 0\\n7.In this way we return the count of the substrigs.",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nv=\\'aeiou\\'\\ncount=0\\nfor i in range(len(word)):\\n\\t\\ts=set()\\n\\t\\tif word[i] in v:\\n\\t\\t\\t\\tfor j in range(i,len(word)):\\n\\t\\t\\t\\t\\t\\tif word[j] not in v:\\n\\t\\t\\t\\t\\t\\t\\t\\tbreak\\n\\t\\t\\t\\t\\t\\ts.add(word[j])\\n\\t\\t\\t\\t\\t\\tif len(s)==5:\\n\\t\\t\\t\\t\\t\\t\\t\\tcount+=1\\nreturn count\\n```\n```\\nv=\\'aeiou\\'\\nd={i:0 for i in v}\\ncount=0\\nstart=0\\nj=0\\ntotalv=0\\nfor i in range(len(word)):\\n\\t\\tif word[i] in v:\\n\\t\\t\\t\\td[word[i]]+=1\\n\\t\\t\\t\\tif d[word[i]]==1:\\n\\t\\t\\t\\t\\t\\ttotalv+=1\\n\\t\\t\\t\\twhile totalv==5:\\n\\t\\t\\t\\t\\t\\td[word[start]]-=1\\n\\t\\t\\t\\t\\t\\tif d[word[start]]==0:\\n\\t\\t\\t\\t\\t\\t\\t\\ttotalv-=1\\n\\t\\t\\t\\t\\t\\tstart+=1\\n\\t\\t\\t\\tcount+=start-j\\n\\t\\telse:\\n\\t\\t\\t\\td={i:0 for i in v}\\n\\t\\t\\t\\tstart=j=i+1\\n\\t\\t\\t\\ttotalv=0\\nreturn count\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2254962,
                "title": "java-very-easy-solution",
                "content": "```\\nint c=0;\\n        for(int i=0;i<word.length();i++){\\n            Set<Character> set=new HashSet<>();\\n            for(int j=i;j<word.length();j++){\\n                if(!isVowel(word.charAt(j))) break;\\n                else{\\n                    set.add(word.charAt(j));\\n                    if(set.size()==5) c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n    public boolean isVowel(char x){\\n        if(x==\\'a\\' || x==\\'e\\' || x==\\'i\\'|| x==\\'o\\' || x==\\'u\\') return true;\\n        return false;\\n    }```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nint c=0;\\n        for(int i=0;i<word.length();i++){\\n            Set<Character> set=new HashSet<>();\\n            for(int j=i;j<word.length();j++){\\n                if(!isVowel(word.charAt(j))) break;\\n                else{\\n                    set.add(word.charAt(j));\\n                    if(set.size()==5) c++;\\n                }\\n            }\\n        }\\n        return c;\\n    }\\n    public boolean isVowel(char x){\\n        if(x==\\'a\\' || x==\\'e\\' || x==\\'i\\'|| x==\\'o\\' || x==\\'u\\') return true;\\n        return false;\\n    }```",
                "codeTag": "Unknown"
            },
            {
                "id": 2233705,
                "title": "js-using-set",
                "content": "```\\nconst set = new Set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']);\\n\\nvar countVowelSubstrings = function(word) {\\n    let count = 0;\\n    let len = word.length;\\n    \\n    for(let i=0; i<len; i++) {        \\n        let tempSet = new Set();\\n\\t\\t\\n        if(set.has(word[i])) {\\n            tempSet.add(word[i]);\\n            let j = i+1;\\n\\t\\t\\t\\n            while( set.has(word[j]) && j<len && len-i>=4 ) {\\n                tempSet.add(word[j++]);                \\n                if( tempSet.size === 5 ) {\\n                    count++;\\n                }\\n            }\\n            tempSet.clear();\\n        }\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Ordered Set"
                ],
                "code": "```\\nconst set = new Set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']);\\n\\nvar countVowelSubstrings = function(word) {\\n    let count = 0;\\n    let len = word.length;\\n    \\n    for(let i=0; i<len; i++) {        \\n        let tempSet = new Set();\\n\\t\\t\\n        if(set.has(word[i])) {\\n            tempSet.add(word[i]);\\n            let j = i+1;\\n\\t\\t\\t\\n            while( set.has(word[j]) && j<len && len-i>=4 ) {\\n                tempSet.add(word[j++]);                \\n                if( tempSet.size === 5 ) {\\n                    count++;\\n                }\\n            }\\n            tempSet.clear();\\n        }\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2147190,
                "title": "c-o-n-time-sliding-window-technique-0ms-runtime",
                "content": "```\\n\\nHere is my approach \\nI\\'m  maintaing a hashmap to map a vowel to it\\'s frequency and a count variable for the number of vowels in a particular sub string\\nMy intuition is that as a substring must contain only all the vowels with no consonants and for a substring (j,i) containing only vowels,if first prefix vowels are also present in (j+prefix,i) then 1+prefix number of substrings are valid substrings to our given asked condition\\n\\nWhenever I encounter a consonant ,I make the values of count,prefix to be zero and clearing the hashmap thereby conveying the idea that we need to start again fresh to find the required substrings containing only vowels\\n\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        \\n        unordered_map<char,int>m;\\n        int n=word.size();\\n        int ans=0;\\n        \\n        for(int i=0,cnt=0,j=0,pref=0;i<n;i++){\\n            if((word[i]==\\'a\\'||word[i]==\\'e\\'||word[i]==\\'i\\'||word[i]==\\'o\\'||word[i]==\\'u\\'))\\n            {\\n                if(m[word[i]]++==0)\\n                     cnt++;\\n                \\n                while(m[word[j]]>1)\\n\\t\\t\\t\\tm[word[j++]]--,pref++;\\n                \\n            if(cnt==5)ans+=(1+pref);\\n            }\\n               else{\\n               \\n                   cnt=0;\\n                   pref=0;\\n                   m.clear();\\n                   j=i+1;\\n               }\\n                   \\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```\\n![image](https://assets.leetcode.com/users/images/3c22ed94-24ce-41a7-af24-abcd21785de7_1655124701.0148885.png)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\n\\nHere is my approach \\nI\\'m  maintaing a hashmap to map a vowel to it\\'s frequency and a count variable for the number of vowels in a particular sub string\\nMy intuition is that as a substring must contain only all the vowels with no consonants and for a substring (j,i) containing only vowels,if first prefix vowels are also present in (j+prefix,i) then 1+prefix number of substrings are valid substrings to our given asked condition\\n\\nWhenever I encounter a consonant ,I make the values of count,prefix to be zero and clearing the hashmap thereby conveying the idea that we need to start again fresh to find the required substrings containing only vowels\\n\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        \\n        unordered_map<char,int>m;\\n        int n=word.size();\\n        int ans=0;\\n        \\n        for(int i=0,cnt=0,j=0,pref=0;i<n;i++){\\n            if((word[i]==\\'a\\'||word[i]==\\'e\\'||word[i]==\\'i\\'||word[i]==\\'o\\'||word[i]==\\'u\\'))\\n            {\\n                if(m[word[i]]++==0)\\n                     cnt++;\\n                \\n                while(m[word[j]]>1)\\n\\t\\t\\t\\tm[word[j++]]--,pref++;\\n                \\n            if(cnt==5)ans+=(1+pref);\\n            }\\n               else{\\n               \\n                   cnt=0;\\n                   pref=0;\\n                   m.clear();\\n                   j=i+1;\\n               }\\n                   \\n            \\n            \\n        }\\n        return ans;\\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2143852,
                "title": "python3-simple-solution",
                "content": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        count = 0\\n        k = 0\\n        while k < len(word):\\n            a = e = i = o = u = False\\n            for j in range(k,len(word)):\\n                if word[j] == \\'a\\':\\n                    a = True\\n                elif word[j] == \\'e\\':\\n                    e = True\\n                elif word[j] == \\'i\\':\\n                    i = True\\n                elif word[j] == \\'o\\':\\n                    o = True\\n                elif word[j] == \\'u\\':\\n                    u = True\\n                else:\\n                    a = e = i = o = u = False\\n                    break\\n                if a == e == i == o == u == True:\\n                    count += 1\\n            k += 1\\n        return count\\n```\\n**If you like this solution, please upvote for this**",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        count = 0\\n        k = 0\\n        while k < len(word):\\n            a = e = i = o = u = False\\n            for j in range(k,len(word)):\\n                if word[j] == \\'a\\':\\n                    a = True\\n                elif word[j] == \\'e\\':\\n                    e = True\\n                elif word[j] == \\'i\\':\\n                    i = True\\n                elif word[j] == \\'o\\':\\n                    o = True\\n                elif word[j] == \\'u\\':\\n                    u = True\\n                else:\\n                    a = e = i = o = u = False\\n                    break\\n                if a == e == i == o == u == True:\\n                    count += 1\\n            k += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2117742,
                "title": "c-solution-hashmap-beginner-friendly",
                "content": "**Code:**\\n\\n```\\nclass Solution\\n{\\npublic:\\n    int count(string s)\\n    {\\n        int a = 0;\\n        map<char, int> mp;\\n        int st = 0;\\n        int n = s.length();\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[s[i]]++;\\n\\n            while (mp[\\'a\\'] > 0 && mp[\\'e\\'] > 0 && mp[\\'i\\'] > 0 && mp[\\'o\\'] > 0 && mp[\\'u\\'] > 0)\\n            {\\n                a += n - i;\\n                mp[s[st]]--;\\n                st += 1;\\n            }\\n        }\\n        return a;\\n    }\\n    int countVowelSubstrings(string word)\\n    {\\n        int k = 0;\\n        string t = \"\";\\n        for (char c : word)\\n        {\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n            {\\n                t += c;\\n            }\\n            else\\n            {\\n                if (t.length() > 0)\\n                {\\n                    k += count(t);\\n                }\\n\\n                t = \"\";\\n            }\\n        }\\n        if (t.length() > 0)\\n        {\\n            k += count(t);\\n        }\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    int count(string s)\\n    {\\n        int a = 0;\\n        map<char, int> mp;\\n        int st = 0;\\n        int n = s.length();\\n        for (int i = 0; i < n; i++)\\n        {\\n            mp[s[i]]++;\\n\\n            while (mp[\\'a\\'] > 0 && mp[\\'e\\'] > 0 && mp[\\'i\\'] > 0 && mp[\\'o\\'] > 0 && mp[\\'u\\'] > 0)\\n            {\\n                a += n - i;\\n                mp[s[st]]--;\\n                st += 1;\\n            }\\n        }\\n        return a;\\n    }\\n    int countVowelSubstrings(string word)\\n    {\\n        int k = 0;\\n        string t = \"\";\\n        for (char c : word)\\n        {\\n            if (c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n            {\\n                t += c;\\n            }\\n            else\\n            {\\n                if (t.length() > 0)\\n                {\\n                    k += count(t);\\n                }\\n\\n                t = \"\";\\n            }\\n        }\\n        if (t.length() > 0)\\n        {\\n            k += count(t);\\n        }\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2016522,
                "title": "c-sliding-window-solution-with-explanation-o-n-time-o-1-space",
                "content": "**HW Notes**: https://github.com/arkayyy/leetcode-problems/blob/main/2062-count-vowel-substrings-of-a-string/LC2062%20-%20HW%20Notes.pdf\\n```\\nclass Solution {\\npublic:\\n    //INTUITION: Using a sliding window and an additional third pointer, we can determine the valid substring as well as\\n    //we can also find out the total number of unique substrings that can be made using each cluster of vowels\\n    //present in the string.\\n    \\n    //ALGO: Sliding window and three pointers...See HW Notes for visual explanations...\\n    int countVowelSubstrings(string word) {\\n        int j = 0, k = 0, vowels = 0, ans = 0;\\n        unordered_map<char,int> mp;\\n        mp[\\'a\\'] = 0, mp[\\'e\\'] = 0, mp[\\'i\\'] = 0, mp[\\'o\\'] = 0, mp[\\'u\\'] = 0;\\n        for(int i = 0; i<word.size(); i++)\\n        {\\n            if(mp.find(word[i])!=mp.end()) //vowel found\\n            {\\n                vowels += (++mp[word[i]] == 1);//vowels increase only if a new vowel is found\\n                \\n                //Now we are looping k forward until there exists a valid all vowel substr b/w k and i :-\\n                while(vowels==5)\\n                    {vowels-= (--mp[word[k++]] == 0);} //vowels decreases only if all occurence of a vowel is eliminated\\n                \\n                ans+= (k-j); //because with the valid all vowel substr b/w k and i, every letter b/w k and j can also be associated to make a unique substring..\\n                //so adding all such possibilities to answer\\n            }\\n            else //consonant found\\n            {//resetting all vowel frequencies once any non vowel is found\\n                mp[\\'a\\'] = mp[\\'e\\'] = mp[\\'i\\'] = mp[\\'o\\'] = mp[\\'u\\'] = 0;\\n                vowels = 0;\\n                j = k = i+1; \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //INTUITION: Using a sliding window and an additional third pointer, we can determine the valid substring as well as\\n    //we can also find out the total number of unique substrings that can be made using each cluster of vowels\\n    //present in the string.\\n    \\n    //ALGO: Sliding window and three pointers...See HW Notes for visual explanations...\\n    int countVowelSubstrings(string word) {\\n        int j = 0, k = 0, vowels = 0, ans = 0;\\n        unordered_map<char,int> mp;\\n        mp[\\'a\\'] = 0, mp[\\'e\\'] = 0, mp[\\'i\\'] = 0, mp[\\'o\\'] = 0, mp[\\'u\\'] = 0;\\n        for(int i = 0; i<word.size(); i++)\\n        {\\n            if(mp.find(word[i])!=mp.end()) //vowel found\\n            {\\n                vowels += (++mp[word[i]] == 1);//vowels increase only if a new vowel is found\\n                \\n                //Now we are looping k forward until there exists a valid all vowel substr b/w k and i :-\\n                while(vowels==5)\\n                    {vowels-= (--mp[word[k++]] == 0);} //vowels decreases only if all occurence of a vowel is eliminated\\n                \\n                ans+= (k-j); //because with the valid all vowel substr b/w k and i, every letter b/w k and j can also be associated to make a unique substring..\\n                //so adding all such possibilities to answer\\n            }\\n            else //consonant found\\n            {//resetting all vowel frequencies once any non vowel is found\\n                mp[\\'a\\'] = mp[\\'e\\'] = mp[\\'i\\'] = mp[\\'o\\'] = mp[\\'u\\'] = 0;\\n                vowels = 0;\\n                j = k = i+1; \\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1683185,
                "title": "the-art-of-dynamic-programming",
                "content": "[\\uD83C\\uDFA8 The ART of Dynamic Programming](https://leetcode.com/discuss/general-discussion/712010/The-ART-of-Dynamic-Programming-An-Intuitive-Approach%3A-from-Apprentice-to-Master)\\n\\n**Top-Down Brute-Force:** Since `N = 100`, a recursive brute-force solution is AC; ie. for each index `i = 0..N-1` we can recursively `go()` accumulate the count of all vowel substrings of the input string `s` starting at index `i` and return those accumulated counts.\\n\\nNote: this is *not* a memoizable DP solution.  Instead we use DP to reduce the asymptotic bounds for O(1) lookups to find `k` for each sliding window `i..j` (see second set of solutions below).\\n\\n---\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countVowelSubstrings(s: String, V: Set<Char> = listOf(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\').toSet()): Int {\\n        var N = s.length\\n        fun go(i: Int, have: MutableSet<Char> = mutableSetOf<Char>()): Int {\\n            if (i == N || !V.contains(s[i]))\\n                return 0\\n            have.add(s[i])\\n            return (if (have.size == V.size) 1 else 0) + go(i + 1, have)\\n        }\\n        return IntArray(N){ go(it) }.sum()!!\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countVowelSubstrings = (s, N = s.length, V = new Set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'])) => {\\n    let go = (i, have = new Set()) => {\\n        if (i == N || !V.has(s[i]))\\n            return 0;\\n        have.add(s[i]);\\n        return Number(have.size == V.size) + go(i + 1, have);\\n    }\\n    return _.sum([...Array(N).keys()].map(i => go(i)));\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, s: str, V = set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'])) -> int:\\n        N = len(s)\\n        def go(i, have):\\n            if i == N or s[i] not in V:\\n                return 0\\n            have.add(s[i])\\n            return int(len(have) == len(V)) + go(i + 1, have)\\n        return sum(go(i, set()) for i in range(N))\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    using fun = function<int(int, Set&&)>;\\n    int countVowelSubstrings(string s, Set V = Set{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}, int cnt = 0) {\\n        int N = s.size();\\n        fun go = [&](auto i, auto&& have) {\\n            if (i == N || V.find(s[i]) == V.end())\\n                return 0;\\n            have.insert(s[i]);\\n            return int(have.size() == V.size()) + go(i + 1, move(have));\\n        };\\n        for (auto i{ 0 }; i < N; ++i)\\n            cnt += go(i, {});\\n        return cnt;\\n    }\\n};\\n```\\n\\n---\\n\\n**Bottom-Up Sliding Window + Proceprocessing:**\\nIt\\'s obvioiusly inefficient to calculate the same sums over and over again!  Let\\'s use a sliding window `i..j` upon the input string `s` to meet the constraint `s[i..j]` contains one of every vowel.  Then we can find index `k` as the right-most contiguous vowel index to the right of index `j` (inclusive) in O(1) time via preprocessing the input string `s`.\\n\\nFor example, when the interval `i..j` contains all vowels, then we add onto the ongoing count `cnt` the length of contiguous vowels from `j..k` inclusive:\\n```\\n      [.....] <-- add contiguous vowels j..k to the right of the i..j window onto the ongoing count\\ni.....j.....k\\n[aeiou] <-- constraint for window i..j to contain at least one of each vowel\\n\\nk = R[j]  <-- find k via O(1) lookups upon j\\n```\\n\\n*Kotlin*\\n```\\nclass Solution {\\n    fun countVowelSubstrings(s: String, V: Set<Char> = listOf(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\').toSet()): Int {\\n        var cnt = 0\\n        var N = s.length\\n        var R = IntArray(N){ it }\\n        for (i in N - 2 downTo 0)\\n            if (V.contains(s[i + 1]))\\n                R[i] = R[i + 1]\\n        var (i, j) = Pair(0, 0)\\n        var have = mutableMapOf<Char, Int>()\\n        while (j < N) {\\n            if (!V.contains(s[j])) {\\n                i = ++j\\n                have.clear()\\n                continue\\n            }\\n            have[s[j]] = 1 + have.getOrDefault(s[j], 0)\\n            while (have.size == V.size) {\\n                cnt += R[j] - j + 1\\n                have[s[i]] = -1 + have[s[i]]!!\\n                if (have[s[i]]!! == 0)\\n                    have.remove(s[i])\\n                ++i\\n            }\\n            ++j\\n        }\\n        return cnt\\n    }\\n}\\n```\\n\\n*Javascript*\\n```\\nlet countVowelSubstrings = (s, N = s.length, V = new Set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']), have = new Map(), cnt = 0) => {\\n    let R = [...Array(N).keys()];\\n    for (let i = N - 2; 0 <= i; --i)\\n        if (V.has(s[i + 1]))\\n            R[i] = R[i + 1];\\n    let i = 0,\\n        j = 0;\\n    while (j < N) {\\n        if (!V.has(s[j])) {\\n            i = ++j;\\n            have = new Map();\\n            continue;\\n        }\\n        have.set(s[j], 1 + (have.get(s[j]) || 0));\\n        while (have.size == V.size) {\\n            cnt += R[j] - j + 1;\\n            have.set(s[i], -1 + have.get(s[i]));\\n            if (!have.get(s[i]))\\n                have.delete(s[i]);\\n            ++i;\\n        }\\n        ++j;\\n    }\\n    return cnt;\\n};\\n```\\n\\n*Python3*\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, s: str, V = set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']), cnt = 0) -> int:\\n        N = len(s)\\n        R = [i for i in range(N)]\\n        for i in range(N - 2, -1, -1):\\n            if s[i + 1] in V:\\n                R[i] = R[i + 1]\\n        i = 0\\n        j = 0\\n        have = {}\\n        while j < N:\\n            if s[j] not in V:\\n                j += 1; i = j\\n                have = {}\\n                continue\\n            have[s[j]] = 1 + (have[s[j]] if s[j] in have else 0)\\n            while len(have) == len(V):\\n                cnt += R[j] - j + 1\\n                have[s[i]] -= 1\\n                if not have[s[i]]:\\n                    del have[s[i]]\\n                i += 1\\n            j += 1\\n        return cnt\\n```\\n\\n*C++*\\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = unordered_set<char>;\\n    using Map = unordered_map<char, int>;\\n    int countVowelSubstrings(string s, Set V = Set{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}, Map have = {}, int cnt = 0) {\\n        int N = s.size();\\n        VI R(N); iota(R.begin(), R.end(), 0);\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            if (V.find(s[i + 1]) != V.end())\\n                R[i] = R[i + 1];\\n        auto i = 0,\\n             j = 0;\\n        while (j < N) {\\n            if (V.find(s[j]) == V.end()) {\\n                i = ++j;\\n                have.clear();\\n                continue;\\n            }\\n            ++have[s[j]];\\n            while (have.size() == V.size()) {\\n                cnt += R[j] - j + 1;\\n                if (!--have[s[i]])\\n                    have.erase(s[i]);\\n                ++i;\\n            }\\n            ++j;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    fun countVowelSubstrings(s: String, V: Set<Char> = listOf(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\').toSet()): Int {\\n        var N = s.length\\n        fun go(i: Int, have: MutableSet<Char> = mutableSetOf<Char>()): Int {\\n            if (i == N || !V.contains(s[i]))\\n                return 0\\n            have.add(s[i])\\n            return (if (have.size == V.size) 1 else 0) + go(i + 1, have)\\n        }\\n        return IntArray(N){ go(it) }.sum()!!\\n    }\\n}\\n```\n```\\nlet countVowelSubstrings = (s, N = s.length, V = new Set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'])) => {\\n    let go = (i, have = new Set()) => {\\n        if (i == N || !V.has(s[i]))\\n            return 0;\\n        have.add(s[i]);\\n        return Number(have.size == V.size) + go(i + 1, have);\\n    }\\n    return _.sum([...Array(N).keys()].map(i => go(i)));\\n};\\n```\n```\\nclass Solution:\\n    def countVowelSubstrings(self, s: str, V = set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'])) -> int:\\n        N = len(s)\\n        def go(i, have):\\n            if i == N or s[i] not in V:\\n                return 0\\n            have.add(s[i])\\n            return int(len(have) == len(V)) + go(i + 1, have)\\n        return sum(go(i, set()) for i in range(N))\\n```\n```\\nclass Solution {\\npublic:\\n    using Set = unordered_set<char>;\\n    using fun = function<int(int, Set&&)>;\\n    int countVowelSubstrings(string s, Set V = Set{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}, int cnt = 0) {\\n        int N = s.size();\\n        fun go = [&](auto i, auto&& have) {\\n            if (i == N || V.find(s[i]) == V.end())\\n                return 0;\\n            have.insert(s[i]);\\n            return int(have.size() == V.size()) + go(i + 1, move(have));\\n        };\\n        for (auto i{ 0 }; i < N; ++i)\\n            cnt += go(i, {});\\n        return cnt;\\n    }\\n};\\n```\n```\\n      [.....] <-- add contiguous vowels j..k to the right of the i..j window onto the ongoing count\\ni.....j.....k\\n[aeiou] <-- constraint for window i..j to contain at least one of each vowel\\n\\nk = R[j]  <-- find k via O(1) lookups upon j\\n```\n```\\nclass Solution {\\n    fun countVowelSubstrings(s: String, V: Set<Char> = listOf(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\').toSet()): Int {\\n        var cnt = 0\\n        var N = s.length\\n        var R = IntArray(N){ it }\\n        for (i in N - 2 downTo 0)\\n            if (V.contains(s[i + 1]))\\n                R[i] = R[i + 1]\\n        var (i, j) = Pair(0, 0)\\n        var have = mutableMapOf<Char, Int>()\\n        while (j < N) {\\n            if (!V.contains(s[j])) {\\n                i = ++j\\n                have.clear()\\n                continue\\n            }\\n            have[s[j]] = 1 + have.getOrDefault(s[j], 0)\\n            while (have.size == V.size) {\\n                cnt += R[j] - j + 1\\n                have[s[i]] = -1 + have[s[i]]!!\\n                if (have[s[i]]!! == 0)\\n                    have.remove(s[i])\\n                ++i\\n            }\\n            ++j\\n        }\\n        return cnt\\n    }\\n}\\n```\n```\\nlet countVowelSubstrings = (s, N = s.length, V = new Set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']), have = new Map(), cnt = 0) => {\\n    let R = [...Array(N).keys()];\\n    for (let i = N - 2; 0 <= i; --i)\\n        if (V.has(s[i + 1]))\\n            R[i] = R[i + 1];\\n    let i = 0,\\n        j = 0;\\n    while (j < N) {\\n        if (!V.has(s[j])) {\\n            i = ++j;\\n            have = new Map();\\n            continue;\\n        }\\n        have.set(s[j], 1 + (have.get(s[j]) || 0));\\n        while (have.size == V.size) {\\n            cnt += R[j] - j + 1;\\n            have.set(s[i], -1 + have.get(s[i]));\\n            if (!have.get(s[i]))\\n                have.delete(s[i]);\\n            ++i;\\n        }\\n        ++j;\\n    }\\n    return cnt;\\n};\\n```\n```\\nclass Solution:\\n    def countVowelSubstrings(self, s: str, V = set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']), cnt = 0) -> int:\\n        N = len(s)\\n        R = [i for i in range(N)]\\n        for i in range(N - 2, -1, -1):\\n            if s[i + 1] in V:\\n                R[i] = R[i + 1]\\n        i = 0\\n        j = 0\\n        have = {}\\n        while j < N:\\n            if s[j] not in V:\\n                j += 1; i = j\\n                have = {}\\n                continue\\n            have[s[j]] = 1 + (have[s[j]] if s[j] in have else 0)\\n            while len(have) == len(V):\\n                cnt += R[j] - j + 1\\n                have[s[i]] -= 1\\n                if not have[s[i]]:\\n                    del have[s[i]]\\n                i += 1\\n            j += 1\\n        return cnt\\n```\n```\\nclass Solution {\\npublic:\\n    using VI = vector<int>;\\n    using Set = unordered_set<char>;\\n    using Map = unordered_map<char, int>;\\n    int countVowelSubstrings(string s, Set V = Set{\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}, Map have = {}, int cnt = 0) {\\n        int N = s.size();\\n        VI R(N); iota(R.begin(), R.end(), 0);\\n        for (auto i{ N - 2 }; 0 <= i; --i)\\n            if (V.find(s[i + 1]) != V.end())\\n                R[i] = R[i + 1];\\n        auto i = 0,\\n             j = 0;\\n        while (j < N) {\\n            if (V.find(s[j]) == V.end()) {\\n                i = ++j;\\n                have.clear();\\n                continue;\\n            }\\n            ++have[s[j]];\\n            while (have.size() == V.size()) {\\n                cnt += R[j] - j + 1;\\n                if (!--have[s[i]])\\n                    have.erase(s[i]);\\n                ++i;\\n            }\\n            ++j;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1649210,
                "title": "python-3",
                "content": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        vows = \"aeiou\"\\n        sta = -1\\n        m = {}\\n        n = 0\\n        for i, a in enumerate(word):\\n            if a not in vows:\\n                sta = i\\n                m = {}\\n            else:\\n                m[a] = i\\n            if len(m) == 5:\\n                mi = min(m.values())\\n                n += mi - sta\\n        return n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        vows = \"aeiou\"\\n        sta = -1\\n        m = {}\\n        n = 0\\n        for i, a in enumerate(word):\\n            if a not in vows:\\n                sta = i\\n                m = {}\\n            else:\\n                m[a] = i\\n            if len(m) == 5:\\n                mi = min(m.values())\\n                n += mi - sta\\n        return n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1581969,
                "title": "c-99-1-mem-100-time-very-easy-to-understand",
                "content": "I hadn\\'t seen this posted, but this shows up as 99.1% memory/100% CPU (0ms) so it seems to be significantly faster than existing executions.\\n\\nThis is largely a brute force solution but with some added short circuits:\\n\\n* If `i` and `j` are ever less than 5 characters apart once we hit a consonent, we can just skip to j--we can never have a match from i.\\n* Use a `bitmap` so that we can VERY easily check to see if we\\'ve accessed all the vowels.\\n\\t* We are guaranteed that we only have lowercase characters, so we can limit this to 26 bits.\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        // This is a bitmap with the values for a, e, i, o, and  u set.\\n        // This is a fixed value, but you could do the same thing manually.\\n        const std::bitset<26> vowels(1065233);\\n        \\n        int cnt = 0;\\n        for (size_t i = 0; i < word.size(); ++i) {\\n            // Only start loking if there\\'s a vowel.\\n            if (vowels.test(word[i] - \\'a\\')) {\\n                // We don\\'t need to keep track of the NUMBER of times we\\'ve seen a vowl,\\n                // just the fact that we\\'ve seen it. This could technically be a vector\\n                // or map, but a bitset is small and fast--plus, we can easily do an\\n                // equality comparison below.\\n                std::bitset<26> seen;\\n                size_t j = i;\\n                while (j < word.size() && vowels.test(word[j] - \\'a\\')) {\\n                    // Mark that we\\'ve seen this value; this is a no-op if it\\'s we\\'ve\\n                    // already seen and set it.\\n                    seen.set(word[j++] - \\'a\\');\\n                    \\n                    // Since underneath these bitmaps are essentially just integers,\\n                    // we just need to check that we\\'ve seen all the values! This comparison\\n                    // is very fast, so there\\'s no need to short circuit.\\n                    if (vowels == seen) {\\n                        ++cnt;\\n                    }\\n                }\\n                \\n                // If we ever have less than 5 characters between i and the next consonent,\\n                // skip the remaining checks. Not a huge time saver but does help with\\n                // edge cases.\\n                if (j - i < 5) {\\n                    i = j;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        // This is a bitmap with the values for a, e, i, o, and  u set.\\n        // This is a fixed value, but you could do the same thing manually.\\n        const std::bitset<26> vowels(1065233);\\n        \\n        int cnt = 0;\\n        for (size_t i = 0; i < word.size(); ++i) {\\n            // Only start loking if there\\'s a vowel.\\n            if (vowels.test(word[i] - \\'a\\')) {\\n                // We don\\'t need to keep track of the NUMBER of times we\\'ve seen a vowl,\\n                // just the fact that we\\'ve seen it. This could technically be a vector\\n                // or map, but a bitset is small and fast--plus, we can easily do an\\n                // equality comparison below.\\n                std::bitset<26> seen;\\n                size_t j = i;\\n                while (j < word.size() && vowels.test(word[j] - \\'a\\')) {\\n                    // Mark that we\\'ve seen this value; this is a no-op if it\\'s we\\'ve\\n                    // already seen and set it.\\n                    seen.set(word[j++] - \\'a\\');\\n                    \\n                    // Since underneath these bitmaps are essentially just integers,\\n                    // we just need to check that we\\'ve seen all the values! This comparison\\n                    // is very fast, so there\\'s no need to short circuit.\\n                    if (vowels == seen) {\\n                        ++cnt;\\n                    }\\n                }\\n                \\n                // If we ever have less than 5 characters between i and the next consonent,\\n                // skip the remaining checks. Not a huge time saver but does help with\\n                // edge cases.\\n                if (j - i < 5) {\\n                    i = j;\\n                }\\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1567039,
                "title": "fast-easy-to-undertand-js",
                "content": "```\\nfunction countVowelSubstrings(word){\\n    let count = 0;\\n    for (let i = 0; i < word.length; i++) {\\n        for (let j = i; j < word.length; j++) {\\n            let s = word.slice(i, j + 1);\\n            if (checkVowels(s)) count++;\\n        }\\n    }\\n    return count;\\n};\\n\\nfunction checkVowels(s){\\n    let a = 0, e = 0, i = 0, o = 0, u = 0;\\n    for (const c of s) {\\n        switch(c){\\n            case \\'a\\': a++; break;\\n            case \\'e\\': e++; break;\\n            case \\'i\\': i++; break;\\n            case \\'o\\': o++; break;\\n            case \\'u\\': u++; break;\\n            default: return false;\\n        }\\n    }\\n    return a != 0 && e != 0 && i !=0 && o != 0 && u != 0;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction countVowelSubstrings(word){\\n    let count = 0;\\n    for (let i = 0; i < word.length; i++) {\\n        for (let j = i; j < word.length; j++) {\\n            let s = word.slice(i, j + 1);\\n            if (checkVowels(s)) count++;\\n        }\\n    }\\n    return count;\\n};\\n\\nfunction checkVowels(s){\\n    let a = 0, e = 0, i = 0, o = 0, u = 0;\\n    for (const c of s) {\\n        switch(c){\\n            case \\'a\\': a++; break;\\n            case \\'e\\': e++; break;\\n            case \\'i\\': i++; break;\\n            case \\'o\\': o++; break;\\n            case \\'u\\': u++; break;\\n            default: return false;\\n        }\\n    }\\n    return a != 0 && e != 0 && i !=0 && o != 0 && u != 0;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1566021,
                "title": "o-n-3-time-o-1-space-c-brute-force",
                "content": "Explanation:\\n1. Check for all substrings.\\n2. For every substring, check if it contains [a,e,i,o,u] & whether or not it contains a consonant (using boolen variables).\\n\\n* Since smallest substring could be of size=5, we check for all substring with size>=5.\\n\\n```\\nclass Solution {\\npublic:\\n   \\n    \\n    int countVowelSubstrings(string s) {\\n        \\n        int cnt =0;\\n        \\n        int n = s.size();\\n        \\n        for(int i=0;i<n;i++){             \\n            for(int j=i;j<n;j++){\\n                bool a=0,e=0,I=0,o=0,u=0,con=1;\\n                if(j-i+1>=5){ //check for size >=5                   \\n                    for(int k=i;k<=j;k++){                       \\n                        if(s[k]==\\'a\\'){\\n                            a=1;\\n                        }\\n                        else if(s[k]==\\'e\\'){\\n                            e=1;\\n                        }\\n                        else if(s[k]==\\'i\\'){\\n                            I=1;\\n                        }\\n                        else if(s[k]==\\'o\\'){\\n                            o=1;\\n                        }\\n                        else if(s[k]==\\'u\\'){\\n                            u=1;\\n                        }\\n                        else{\\n                            con=0;\\n                        }\\n                    }\\n                    if(a&&e&&I&&o&&u&&con){\\n                        cnt++;\\n                    }\\n                }                 \\n            }            \\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   \\n    \\n    int countVowelSubstrings(string s) {\\n        \\n        int cnt =0;\\n        \\n        int n = s.size();\\n        \\n        for(int i=0;i<n;i++){             \\n            for(int j=i;j<n;j++){\\n                bool a=0,e=0,I=0,o=0,u=0,con=1;\\n                if(j-i+1>=5){ //check for size >=5                   \\n                    for(int k=i;k<=j;k++){                       \\n                        if(s[k]==\\'a\\'){\\n                            a=1;\\n                        }\\n                        else if(s[k]==\\'e\\'){\\n                            e=1;\\n                        }\\n                        else if(s[k]==\\'i\\'){\\n                            I=1;\\n                        }\\n                        else if(s[k]==\\'o\\'){\\n                            o=1;\\n                        }\\n                        else if(s[k]==\\'u\\'){\\n                            u=1;\\n                        }\\n                        else{\\n                            con=0;\\n                        }\\n                    }\\n                    if(a&&e&&I&&o&&u&&con){\\n                        cnt++;\\n                    }\\n                }                 \\n            }            \\n        }\\n        \\n        return cnt;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564015,
                "title": "java-sliding-window",
                "content": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        int n = word.length();\\n        int ans = 0;\\n        int j = 0;\\n        String sub = \"\";\\n        for (int i = 0; i < n; i++) {\\n            char ch = word.charAt(i);\\n            if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') {\\n                map.put(ch, map.getOrDefault(ch, 0) + 1);\\n                sub += ch;\\n                \\n            } else {\\n                if (map.size() == 5) {\\n                    ans += helper(sub);\\n                }\\n                map.clear();\\n                sub = \"\";\\n            }\\n        }\\n        if (map.size() == 5) {\\n            ans += helper(sub);\\n        }\\n        return ans;\\n    }\\n    \\n    public int helper(String sub) {\\n        System.out.println(sub);\\n        int ans = 0;\\n        int n = sub.length();\\n        \\n        Map<Character, Integer> freq = new HashMap<>();\\n        int j = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            char ch = sub.charAt(i);\\n            freq.put(ch, freq.getOrDefault(ch, 0) + 1);\\n            \\n            while (freq.size() == 5) {\\n                ans += n - i;\\n                char cj = sub.charAt(j++);\\n                freq.put(cj, freq.get(cj) - 1);\\n                if (freq.get(cj) == 0) freq.remove(cj);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        Map<Character, Integer> map = new HashMap<>();\\n        int n = word.length();\\n        int ans = 0;\\n        int j = 0;\\n        String sub = \"\";\\n        for (int i = 0; i < n; i++) {\\n            char ch = word.charAt(i);\\n            if (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') {\\n                map.put(ch, map.getOrDefault(ch, 0) + 1);\\n                sub += ch;\\n                \\n            } else {\\n                if (map.size() == 5) {\\n                    ans += helper(sub);\\n                }\\n                map.clear();\\n                sub = \"\";\\n            }\\n        }\\n        if (map.size() == 5) {\\n            ans += helper(sub);\\n        }\\n        return ans;\\n    }\\n    \\n    public int helper(String sub) {\\n        System.out.println(sub);\\n        int ans = 0;\\n        int n = sub.length();\\n        \\n        Map<Character, Integer> freq = new HashMap<>();\\n        int j = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            char ch = sub.charAt(i);\\n            freq.put(ch, freq.getOrDefault(ch, 0) + 1);\\n            \\n            while (freq.size() == 5) {\\n                ans += n - i;\\n                char cj = sub.charAt(j++);\\n                freq.put(cj, freq.get(cj) - 1);\\n                if (freq.get(cj) == 0) freq.remove(cj);\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563863,
                "title": "java-brute-force",
                "content": "Not easy for me (wasted lot of time).\\n\\n```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        \\n        if(word.length() < 5) return 0;\\n        int ans = 0;\\n        \\n        for(int i=0; i<word.length(); i++) {\\n            int j = i+5;\\n            while( (j) <= word.length()) {\\n                \\n                // System.out.println(\"result \" + checkVowel(word.substring(i, j)) + \" substr \" + word.substring(i, j) );\\n                if(checkVowel(word.substring(i, j))) {\\n                    ans++;\\n                }\\n                \\n                j++;\\n            }\\n        }           \\n        \\n        return ans;\\n    }\\n    \\n    public boolean checkVowel(String w) { \\n        Set<Character> set = new HashSet<>();\\n        Set<Character> set1 = new HashSet<>();\\n        \\n        for(char c: w.toCharArray()) {\\n            if(c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\')\\n                set.add(c);\\n            else {\\n                return false;\\n            }\\n        }\\n                \\n        if(set.size() < 5) return false;\\n        \\n        for(char c: set) {\\n            if(c == \\'a\\') set1.add(c);\\n            else if(c == \\'e\\') set1.add(c);\\n            else if(c == \\'i\\') set1.add(c);\\n            else if(c == \\'o\\') set1.add(c);\\n            else if(c == \\'u\\') set1.add(c);\\n            else return false;            \\n        }\\n        \\n        return set.size()==set1.size();\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int countVowelSubstrings(String word) {\\n        \\n        if(word.length() < 5) return 0;\\n        int ans = 0;\\n        \\n        for(int i=0; i<word.length(); i++) {\\n            int j = i+5;\\n            while( (j) <= word.length()) {\\n                \\n                // System.out.println(\"result \" + checkVowel(word.substring(i, j)) + \" substr \" + word.substring(i, j) );\\n                if(checkVowel(word.substring(i, j))) {\\n                    ans++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1563761,
                "title": "c-o-n-2-time-and-o-1-space-brute-force-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        if (word.size() < 5) {\\n            return 0;\\n        }\\n        \\n        int count = 0;        \\n        \\n        for(int i = 0; i <= word.size()-5; i++) {\\n            std::unordered_map<char, int> vowel_map;\\n            for (int j = i; j < word.size(); j++) {\\n                if (!isvowel(word[j])) {\\n                    break;\\n                } else {\\n                    vowel_map[word[j]]++;\\n                    if (vowel_map.size() == 5) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\nprivate:\\n    bool isvowel(char ch) { \\n        return (ch == \\'a\\') || (ch == \\'e\\') ||(ch == \\'i\\') ||(ch == \\'o\\') ||(ch == \\'u\\');\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        if (word.size() < 5) {\\n            return 0;\\n        }\\n        \\n        int count = 0;        \\n        \\n        for(int i = 0; i <= word.size()-5; i++) {\\n            std::unordered_map<char, int> vowel_map;\\n            for (int j = i; j < word.size(); j++) {\\n                if (!isvowel(word[j])) {\\n                    break;\\n                } else {\\n                    vowel_map[word[j]]++;\\n                    if (vowel_map.size() == 5) {\\n                        count++;\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return count;\\n    }\\nprivate:\\n    bool isvowel(char ch) { \\n        return (ch == \\'a\\') || (ch == \\'e\\') ||(ch == \\'i\\') ||(ch == \\'o\\') ||(ch == \\'u\\');\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3714749,
                "title": "java-sliding-window-explained",
                "content": "**Idea:**\\n* Have a variable sized window\\n* Keep track of the last consonant (C) and last indices of each vowel seen (V)\\n* Once this window reaches a state where all 5 vowels have been seen, the vowel substrings count will increment by min(V) - C\\n* This is because the next character to C is a vowel which can be included in a vowel substring starting at C + 1 and ending at the current vowel\\n* Example:\\n```\\n! = vowel pointer, | = consonant pointer\\nword = cuaieuouac, map = [a = -1, e = -1, i = -1, o = -1, u = -1], totalSubs = 0, lastConsonant = -1\\n\\n!\\ncuaieuouac\\nlastConsonant = 0\\n\\n!|\\ncuaieuouac\\nmap = [a = -1, e = -1, i = -1, o = -1, u = 1]\\n\\n! |\\ncuaieuouac\\nmap = [a = 2, e = -1, i = -1, o = -1, u = 1]\\n\\n!  |\\ncuaieuouac\\nmap = [a = 2, e = -1, i = 3, o = -1, u = 1]\\n\\n!   |\\ncuaieuouac\\nmap = [a = 2, e = 4, i = 3, o = -1, u = 1]\\n\\n!    |\\ncuaieuouac\\nmap = [a = 2, e = 4, i = 3, o = -1, u = 5]\\n\\n!     |\\ncuaieuouac\\nmap = [a = 2, e = 4, i = 3, o = 6, u = 5], now all 5 vowels have been seen in this window\\ntotalSubs += 2 - 0 = 2\\n\\n!      |\\ncuaieuouac\\nmap = [a = 2, e = 4, i = 3, o = 6, u = 7]\\ntotalSubs += 2 - 0 = 4\\n\\n!       |\\ncuaieuouac\\nmap = [a = 8, e = 4, i = 3, o = 6, u = 7]\\ntotalSubs += 3 - 0 = 7\\n\\n        |!\\ncuaieuouac\\nlastConsonant = 9\\n\\n[Ans] totalSubs = 7\\n```\\n>**T/S:** O(n)/O(1), where n = size(word)\\n```\\npublic int countVowelSubstrings(String word) {\\n\\tvar totalSubs = 0;\\n\\tvar lastConsonant = -1;\\n\\tvar lastIndex = new HashMap<>(Map.of(\\'a\\', -1,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\'e\\', -1,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\'i\\', -1,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\'o\\', -1,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\'u\\', -1));\\n\\n\\tfor (var i = 0; i < word.length(); i++) {\\n\\t\\tvar ch = word.charAt(i);\\n\\n\\t\\tif (lastIndex.containsKey(ch)) {\\n\\t\\t\\tlastIndex.put(ch, i);\\n\\t\\t\\tvar firstVowel = Collections.min(lastIndex.values());\\n\\t\\t\\tvar subs = firstVowel - lastConsonant;\\n\\n\\t\\t\\t// the first condition checks whether all 5 vowels have been seen in this window\\n\\t\\t\\t// the second condition checks whether the first vowel in the window occurs after the last consonant seen\\n\\t\\t\\t// Although in the presence of second condition, the first condition is redundant, I\\'ve still kept it for a better understanding\\n\\t\\t\\tif (firstVowel != -1 && subs > 0) \\n\\t\\t\\t\\ttotalSubs += subs;\\n\\t\\t} else {\\n\\t\\t\\tlastConsonant = i;\\n\\t\\t}\\n\\t}\\n\\n\\treturn totalSubs;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n! = vowel pointer, | = consonant pointer\\nword = cuaieuouac, map = [a = -1, e = -1, i = -1, o = -1, u = -1], totalSubs = 0, lastConsonant = -1\\n\\n!\\ncuaieuouac\\nlastConsonant = 0\\n\\n!|\\ncuaieuouac\\nmap = [a = -1, e = -1, i = -1, o = -1, u = 1]\\n\\n! |\\ncuaieuouac\\nmap = [a = 2, e = -1, i = -1, o = -1, u = 1]\\n\\n!  |\\ncuaieuouac\\nmap = [a = 2, e = -1, i = 3, o = -1, u = 1]\\n\\n!   |\\ncuaieuouac\\nmap = [a = 2, e = 4, i = 3, o = -1, u = 1]\\n\\n!    |\\ncuaieuouac\\nmap = [a = 2, e = 4, i = 3, o = -1, u = 5]\\n\\n!     |\\ncuaieuouac\\nmap = [a = 2, e = 4, i = 3, o = 6, u = 5], now all 5 vowels have been seen in this window\\ntotalSubs += 2 - 0 = 2\\n\\n!      |\\ncuaieuouac\\nmap = [a = 2, e = 4, i = 3, o = 6, u = 7]\\ntotalSubs += 2 - 0 = 4\\n\\n!       |\\ncuaieuouac\\nmap = [a = 8, e = 4, i = 3, o = 6, u = 7]\\ntotalSubs += 3 - 0 = 7\\n\\n        |!\\ncuaieuouac\\nlastConsonant = 9\\n\\n[Ans] totalSubs = 7\\n```\n```\\npublic int countVowelSubstrings(String word) {\\n\\tvar totalSubs = 0;\\n\\tvar lastConsonant = -1;\\n\\tvar lastIndex = new HashMap<>(Map.of(\\'a\\', -1,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\'e\\', -1,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\'i\\', -1,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\'o\\', -1,\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t \\'u\\', -1));\\n\\n\\tfor (var i = 0; i < word.length(); i++) {\\n\\t\\tvar ch = word.charAt(i);\\n\\n\\t\\tif (lastIndex.containsKey(ch)) {\\n\\t\\t\\tlastIndex.put(ch, i);\\n\\t\\t\\tvar firstVowel = Collections.min(lastIndex.values());\\n\\t\\t\\tvar subs = firstVowel - lastConsonant;\\n\\n\\t\\t\\t// the first condition checks whether all 5 vowels have been seen in this window\\n\\t\\t\\t// the second condition checks whether the first vowel in the window occurs after the last consonant seen\\n\\t\\t\\t// Although in the presence of second condition, the first condition is redundant, I\\'ve still kept it for a better understanding\\n\\t\\t\\tif (firstVowel != -1 && subs > 0) \\n\\t\\t\\t\\ttotalSubs += subs;\\n\\t\\t} else {\\n\\t\\t\\tlastConsonant = i;\\n\\t\\t}\\n\\t}\\n\\n\\treturn totalSubs;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3297828,
                "title": "python-sliding-window-concise-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nWe can use a sliding window approach. If we meet a vowel, we check we had all vowels until when; if we meet a consonant, we reset all.\\n \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe create a dictionary `C` which have all the vowels in it, then we use it to create dictionary `D` which we will store the number of vowels in an all-vowel substring. \\n\\nFor every char in the word, if we encounter a vowel, we first store it in a dictionary `D`, then check if we had all the vowels in our dictionary. If yes, while we keep have all the vowels from the start of the vowel substring, we increase this index `beg`, and add the answer a variable `num`, which we increase it too by one in each step. \\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, word):\\n        C = {\\'a\\':0,\\'e\\':0,\\'i\\':0,\\'o\\':0,\\'u\\':0}\\n        ans, num, beg, D = 0, 0, 0, C.copy()\\n        for i,w in enumerate(word):\\n            if w not in \"aeiou\":\\n                num, beg, D = 0, i+1, C.copy()\\n            else:\\n                D[w] += 1\\n                while min(D.values()):  \\n                    D[word[beg]] -= 1\\n                    beg, num = beg+1, num+1\\n            ans += num\\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word):\\n        C = {\\'a\\':0,\\'e\\':0,\\'i\\':0,\\'o\\':0,\\'u\\':0}\\n        ans, num, beg, D = 0, 0, 0, C.copy()\\n        for i,w in enumerate(word):\\n            if w not in \"aeiou\":\\n                num, beg, D = 0, i+1, C.copy()\\n            else:\\n                D[w] += 1\\n                while min(D.values()):  \\n                    D[word[beg]] -= 1\\n                    beg, num = beg+1, num+1\\n            ans += num\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3238244,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def countVowelSubstrings(word: String): Int = \\n        (for {a <- 0 to word.length - 1\\n              b <- a + 1 to word.length\\n            if (word.substring(a, b).toSet == \"aeiou\".toSet)\\n        } yield 1).sum\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def countVowelSubstrings(word: String): Int = \\n        (for {a <- 0 to word.length - 1\\n              b <- a + 1 to word.length\\n            if (word.substring(a, b).toSet == \"aeiou\".toSet)\\n        } yield 1).sum\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3152761,
                "title": "count-vowel-substrings-of-a-string",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, s: str) -> int:\\n        count = 0\\n        l = []\\n        b = [\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        for i in range(len(s)+1):\\n            for j in range(i):\\n                a = s[j:i]\\n                if \"a\" in a and \"e\" in a and \"i\" in a and \"o\" in a and \"u\" in a:\\n                    l.append(a)\\n        for i in l:\\n            c1 = 0\\n            for j in i:\\n                if j not in b:\\n                    c1+=1\\n                    break\\n            if c1==0:\\n                count+=1\\n                \\n        return (count)\\n                \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, s: str) -> int:\\n        count = 0\\n        l = []\\n        b = [\"a\",\"e\",\"i\",\"o\",\"u\"]\\n        for i in range(len(s)+1):\\n            for j in range(i):\\n                a = s[j:i]\\n                if \"a\" in a and \"e\" in a and \"i\" in a and \"o\" in a and \"u\" in a:\\n                    l.append(a)\\n        for i in l:\\n            c1 = 0\\n            for j in i:\\n                if j not in b:\\n                    c1+=1\\n                    break\\n            if c1==0:\\n                count+=1\\n                \\n        return (count)\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128892,
                "title": "scala-brute-force-oneliner",
                "content": "compare all substrings to a set and count\\n# Code\\n```\\nobject Solution {\\n  val vset = Set(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\') \\n  def countVowelSubstrings(word: String): Int =\\n    word.tails.filter(_.size >= vset.size).map(\\n      _.inits.filter(_.size >= vset.size).count(_.toSet == vset)\\n    ).sum\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "String"
                ],
                "code": "```\\nobject Solution {\\n  val vset = Set(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\') \\n  def countVowelSubstrings(word: String): Int =\\n    word.tails.filter(_.size >= vset.size).map(\\n      _.inits.filter(_.size >= vset.size).count(_.toSet == vset)\\n    ).sum\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3119872,
                "title": "javascript-solution-with-set",
                "content": "```\\nvar countVowelSubstrings = function(word) {\\n    const vowels = new Set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']), temp = new Set()\\n    let count = 0\\n    \\n    for (let i = 0; i < word.length; i++) {\\n        temp.clear()\\n        for (let j = i; j < word.length; j++){\\n            if (!vowels.has(word[j])) break\\n            temp.add(word[j])\\n            if (temp.size === vowels.size) count++\\n        }\\n    }\\n    return count\\n};",
                "solutionTags": [
                    "JavaScript",
                    "Iterator",
                    "Ordered Set"
                ],
                "code": "```\\nvar countVowelSubstrings = function(word) {\\n    const vowels = new Set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']), temp = new Set()\\n    let count = 0\\n    \\n    for (let i = 0; i < word.length; i++) {\\n        temp.clear()\\n        for (let j = i; j < word.length; j++){\\n            if (!vowels.has(word[j])) break\\n            temp.add(word[j])\\n            if (temp.size === vowels.size) count++\\n        }\\n    }\\n    return count\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 3053869,
                "title": "sliding-window-intuitive-solution-js",
                "content": "# Complexity\\n- Time complexity: O(N)\\n- it only needs to traverse through the list once.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- Space complexity: O(1)\\n- we are re-using the existing list to traverse through the chars.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\n\\nconst isAllVowel = (vowels_set, str) => {\\n    for (let char of vowels_set) {\\n        // if str does not contain char, return false\\n        const verify = str.includes(char);\\n        if (verify == false) return false;\\n    }\\n    // if str contains all the 5 vowels return true\\n    return true;\\n}\\n\\nvar countVowelSubstrings = function(word) {\\n    // the set is used to verify whether all the vowels exists\\n    let vowels = new Set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']);\\n\\n    let left_pointer = 0;\\n    let right_pointer = 0;\\n    let temp_str = \"\";   \\n    let result = 0;\\n    \\n    while (left_pointer <= word.length - 5) {\\n        // get the curr char\\n        const curr_char = word[right_pointer];\\n        // if the current char is a vowel\\n        if (vowels.has(curr_char)) {\\n            // update the current char into the temp str\\n            temp_str += curr_char;\\n            // if the length of the temp_str is 5 or greater and all of them are vowels\\n            // then increase the result counter\\n            if (temp_str.length >= 5 && isAllVowel(vowels, temp_str)) {\\n                result++;\\n            }\\n            // move the right pointer to the next char\\n            right_pointer++;\\n        }\\n        // if the current char is not a vowel\\n        else {\\n            // move the left pointer to the next char\\n            left_pointer++;\\n            // reset the temp char\\n            temp_str = \"\";\\n            // update the left pointer to the right pointer\\n            // because the chain of characters is broken\\n            right_pointer = left_pointer;\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\n\\nconst isAllVowel = (vowels_set, str) => {\\n    for (let char of vowels_set) {\\n        // if str does not contain char, return false\\n        const verify = str.includes(char);\\n        if (verify == false) return false;\\n    }\\n    // if str contains all the 5 vowels return true\\n    return true;\\n}\\n\\nvar countVowelSubstrings = function(word) {\\n    // the set is used to verify whether all the vowels exists\\n    let vowels = new Set([\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\']);\\n\\n    let left_pointer = 0;\\n    let right_pointer = 0;\\n    let temp_str = \"\";   \\n    let result = 0;\\n    \\n    while (left_pointer <= word.length - 5) {\\n        // get the curr char\\n        const curr_char = word[right_pointer];\\n        // if the current char is a vowel\\n        if (vowels.has(curr_char)) {\\n            // update the current char into the temp str\\n            temp_str += curr_char;\\n            // if the length of the temp_str is 5 or greater and all of them are vowels\\n            // then increase the result counter\\n            if (temp_str.length >= 5 && isAllVowel(vowels, temp_str)) {\\n                result++;\\n            }\\n            // move the right pointer to the next char\\n            right_pointer++;\\n        }\\n        // if the current char is not a vowel\\n        else {\\n            // move the left pointer to the next char\\n            left_pointer++;\\n            // reset the temp char\\n            temp_str = \"\";\\n            // update the left pointer to the right pointer\\n            // because the chain of characters is broken\\n            right_pointer = left_pointer;\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2762776,
                "title": "silly-brute-force-python-solution",
                "content": "I am not proud of this, but since I tend to share my code - here it is.\\nIt\\'s O(n^2) using set. It can be done in liner time using sliding window with bit more smart logic, but I am too lazy for that.\\n\\n```python\\n    def countVowelSubstrings(self, word: str) -> int:\\n        v = set(\"aeiou\")\\n        n = len(word)\\n        ans = 0\\n\\t\\t# check every 5+ long substrings\\n        for start in range(n-4):\\n            for end in range(start+5, n+1):\\n                if set(word[start:end]) == v:\\n                    ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\n    def countVowelSubstrings(self, word: str) -> int:\\n        v = set(\"aeiou\")\\n        n = len(word)\\n        ans = 0\\n\\t\\t# check every 5+ long substrings\\n        for start in range(n-4):\\n            for end in range(start+5, n+1):\\n                if set(word[start:end]) == v:\\n                    ans += 1\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2757922,
                "title": "brute-force-approch-using-set",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string s) {\\n        int n=s.size();\\n        int ans=0;\\n        unordered_set<char>st;\\n        for(int i=0;i<n;++i){\\n            for(int j=i;j<n;++j){\\n                if(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'){\\n                     st.insert(s[j]);\\n                }\\n                else break;\\n                if(st.size()==5) ans++;\\n            }\\n            st.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string s) {\\n        int n=s.size();\\n        int ans=0;\\n        unordered_set<char>st;\\n        for(int i=0;i<n;++i){\\n            for(int j=i;j<n;++j){\\n                if(s[j]==\\'a\\'||s[j]==\\'e\\'||s[j]==\\'i\\'||s[j]==\\'o\\'||s[j]==\\'u\\'){\\n                     st.insert(s[j]);\\n                }\\n                else break;\\n                if(st.size()==5) ans++;\\n            }\\n            st.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2622729,
                "title": "c-80-faster-than-all-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string w)\\n    {\\n        int j=0,k=0,vow=0,ans=0;\\n        unordered_map<char,int> m= {{\\'a\\', 0}, {\\'e\\', 0}, {\\'i\\', 0}, {\\'o\\', 0}, {\\'u\\', 0}};\\n        for(int i=0;i<w.size();i++)\\n        {\\n            if(m.count(w[i]))\\n            {\\n                m[w[i]]++;\\n                if(m[w[i]]==1)\\n                {\\n                    vow+=1;\\n                }\\n                while(vow==5)\\n                {\\n                    m[w[k]]--;\\n                    if(m[w[k]]==0)\\n                        vow-=1;\\n                    k++;\\n                }\\n                ans+=k-j;\\n            }\\n            else\\n            {\\n                m[\\'a\\']=m[\\'e\\']=m[\\'i\\']=m[\\'o\\']=m[\\'u\\']=vow=0;\\n                j=k=i+1;\\n            }\\n        }\\n        return ans;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int countVowelSubstrings(string w)\\n    {\\n        int j=0,k=0,vow=0,ans=0;\\n        unordered_map<char,int> m= {{\\'a\\', 0}",
                "codeTag": "Java"
            },
            {
                "id": 2589889,
                "title": "bf-c-solution",
                "content": "```\\n#define vowel  0x104111\\n\\nint countVowelSubstrings(char * word){\\n    int idx = 0, len = strlen(word);\\n    int ansCnt = 0, mask;\\n    for(int i = 0; i < len-4; i++)\\n    {\\n        idx = i; \\n        mask = (1 << (word[idx]-\\'a\\'));\\n        while(idx < len && mask & vowel)\\n        {\\n            mask |= (1 << (word[idx++]-\\'a\\'));\\n            if(mask == vowel)\\n                ansCnt++;\\n            else if(mask & ~vowel)\\n                break;\\n        }\\n    }\\n    return ansCnt;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define vowel  0x104111\\n\\nint countVowelSubstrings(char * word){\\n    int idx = 0, len = strlen(word);\\n    int ansCnt = 0, mask;\\n    for(int i = 0; i < len-4; i++)\\n    {\\n        idx = i; \\n        mask = (1 << (word[idx]-\\'a\\'));\\n        while(idx < len && mask & vowel)\\n        {\\n            mask |= (1 << (word[idx++]-\\'a\\'));\\n            if(mask == vowel)\\n                ansCnt++;\\n            else if(mask & ~vowel)\\n                break;\\n        }\\n    }\\n    return ansCnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2461460,
                "title": "fundamental-approach-c-traversal-set",
                "content": "\\tclass Solution {\\n\\tpublic:\\n    int countVowelSubstrings(string word) {\\n        int count = 0;\\n        for(int i=0;i<word.size();i++) {\\n            set<char> s1 = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n            set<char> s2;\\n            for(int j=i;j<word.size();j++) {\\n                if(s1.count(word[j]) == 0)\\n                    break;\\n                s2.insert(word[j]);\\n                if(s1 == s2)\\n                    count++;\\n            }\\n        }\\n        return count;\\n    }\\n\\t};",
                "solutionTags": [
                    "C++",
                    "Ordered Set"
                ],
                "code": "class Solution {\\n\\tpublic:\\n    int countVowelSubstrings(string word) {\\n        int count = 0;\\n        for(int i=0;i<word.size();i++) {\\n            set<char> s1 = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}",
                "codeTag": "Java"
            },
            {
                "id": 2460888,
                "title": "count-vowel-substrings-of-a-string-runtime-8ms-memory-8-1mb",
                "content": "I have tried to explain the use of every line in code please try to understand.\\n\\n```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string s) {\\n        map<char,int> f={{\\'a\\',1},{\\'e\\',1},{\\'i\\',1},{\\'o\\',1},{\\'u\\',1}};  //taking a reference map to compare if all vowels are present or not\\n        string a=\"aeiou\";                   //taking a reference string to compare if the element we got is a vowel of not\\n        \\n\\t\\tint c=0;                            //counter for substrings\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(a.find(s[i])!=string::npos)  //if element we got is vowel\\n            {\\n              map<char,int> mp={{\\'a\\',0},{\\'e\\',0},{\\'i\\',0},{\\'o\\',0},{\\'u\\',0}};   // now a counter map to count total vowel we got till now\\n              for(int j=i;j<s.size();j++)        //to create a substring \\n              {\\n                if(a.find(s[j])!=string::npos)  //if element we got next to a vowel is also a vowel or not to create a substring\\n                {\\n                    mp[s[j]]++;                //increment value in map corresponding to the traced vowel\\n                    int flag=1;\\n                    for(auto itr=f.begin();itr!=f.end();itr++)  //to compare reference map and counter map if all vowels are present in substring\\n                    {\\n                        if(mp[itr->first]<f[itr->first]) //if atleast on vowel is not present terminate\\n                        {\\n                            flag=0;\\n                            break;\\n                        }\\n                    }\\n                    if(flag==1)\\n                        c++;\\n                }\\n                       else                             //if we got a consonant after a vowel\\n                           break;\\n              }\\n              \\n            }\\n            \\n        }\\n  return c;  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "String",
                    "Sort"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string s) {\\n        map<char,int> f={{\\'a\\',1},{\\'e\\',1},{\\'i\\',1},{\\'o\\',1},{\\'u\\',1}};  //taking a reference map to compare if all vowels are present or not\\n        string a=\"aeiou\";                   //taking a reference string to compare if the element we got is a vowel of not\\n        \\n\\t\\tint c=0;                            //counter for substrings\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(a.find(s[i])!=string::npos)  //if element we got is vowel\\n            {\\n              map<char,int> mp={{\\'a\\',0},{\\'e\\',0},{\\'i\\',0},{\\'o\\',0},{\\'u\\',0}};   // now a counter map to count total vowel we got till now\\n              for(int j=i;j<s.size();j++)        //to create a substring \\n              {\\n                if(a.find(s[j])!=string::npos)  //if element we got next to a vowel is also a vowel or not to create a substring\\n                {\\n                    mp[s[j]]++;                //increment value in map corresponding to the traced vowel\\n                    int flag=1;\\n                    for(auto itr=f.begin();itr!=f.end();itr++)  //to compare reference map and counter map if all vowels are present in substring\\n                    {\\n                        if(mp[itr->first]<f[itr->first]) //if atleast on vowel is not present terminate\\n                        {\\n                            flag=0;\\n                            break;\\n                        }\\n                    }\\n                    if(flag==1)\\n                        c++;\\n                }\\n                       else                             //if we got a consonant after a vowel\\n                           break;\\n              }\\n              \\n            }\\n            \\n        }\\n  return c;  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2312415,
                "title": "python3-clean-runtime-54-ms-faster-than-83-61-of-python3-online-submissions",
                "content": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        count = 0\\n        lastConsonant = -1\\n        vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n        lastSeenVowels = {vowel: -1 for vowel in vowels}\\n        for idx, char in enumerate(word):\\n            if char not in vowels:\\n                lastConsonant = idx\\n            else:\\n                lastSeenVowels[char] = idx\\n                count += max(min(lastSeenVowels.values()) - lastConsonant, 0)\\n        return count\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        count = 0\\n        lastConsonant = -1\\n        vowels = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n        lastSeenVowels = {vowel: -1 for vowel in vowels}\\n        for idx, char in enumerate(word):\\n            if char not in vowels:\\n                lastConsonant = idx\\n            else:\\n                lastSeenVowels[char] = idx\\n                count += max(min(lastSeenVowels.values()) - lastConsonant, 0)\\n        return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2312069,
                "title": "python3-easy-and-simple-solution",
                "content": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        count = 0\\n        current = set()\\n        vowel = \\'aeiou\\'\\n        for idx, char in enumerate(word):\\n            if char in vowel:\\n                current.add(char)\\n                \\n                for idx2 in range(idx+1, len(word)):\\n                    if word[idx2] in vowel:\\n                        current.add(word[idx2])\\n                    else:\\n                        break\\n                    if len(current) >= 5:\\n                        count += 1\\n                        \\n                current = set()\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        count = 0\\n        current = set()\\n        vowel = \\'aeiou\\'\\n        for idx, char in enumerate(word):\\n            if char in vowel:\\n                current.add(char)\\n                \\n                for idx2 in range(idx+1, len(word)):\\n                    if word[idx2] in vowel:\\n                        current.add(word[idx2])\\n                    else:\\n                        break\\n                    if len(current) >= 5:\\n                        count += 1\\n                        \\n                current = set()\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308838,
                "title": "java-faster-than-96-15-less-than-89-82",
                "content": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        int count = 0;\\n        int[] last = new int[5];\\n        Arrays.fill(last, -1);\\n        int start = -1;\\n        boolean formed = false;\\n        for (int pos = 0; pos < word.length(); pos++) {\\n            char c = word.charAt(pos);\\n            int idx = index(c);\\n            if (idx == -1) {\\n                Arrays.fill(last, -1);\\n                start = -1;\\n                formed = false;\\n            }\\n            else {\\n                start = start == -1 ? pos : start;\\n                last[idx] = pos;\\n                formed = true;\\n                for (int l : last) formed &= (l >= 0);\\n            }\\n            if (formed) {\\n                int min = pos;\\n                for (int l : last) min = Math.min(min, l);\\n                count += (min-start+1);\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private int index(char c) {\\n        if (c == \\'a\\') return 0;\\n        if (c == \\'e\\') return 1;\\n        if (c == \\'i\\') return 2;\\n        if (c == \\'o\\') return 3;\\n        if (c == \\'u\\') return 4;\\n        return -1;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        int count = 0;\\n        int[] last = new int[5];\\n        Arrays.fill(last, -1);\\n        int start = -1;\\n        boolean formed = false;\\n        for (int pos = 0; pos < word.length(); pos++) {\\n            char c = word.charAt(pos);\\n            int idx = index(c);\\n            if (idx == -1) {\\n                Arrays.fill(last, -1);\\n                start = -1;\\n                formed = false;\\n            }\\n            else {\\n                start = start == -1 ? pos : start;\\n                last[idx] = pos;\\n                formed = true;\\n                for (int l : last) formed &= (l >= 0);\\n            }\\n            if (formed) {\\n                int min = pos;\\n                for (int l : last) min = Math.min(min, l);\\n                count += (min-start+1);\\n            }\\n        }\\n        return count;\\n    }\\n    \\n    private int index(char c) {\\n        if (c == \\'a\\') return 0;\\n        if (c == \\'e\\') return 1;\\n        if (c == \\'i\\') return 2;\\n        if (c == \\'o\\') return 3;\\n        if (c == \\'u\\') return 4;\\n        return -1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306420,
                "title": "o-n-simple-python-solution",
                "content": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        vowels = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'])\\n        dp = defaultdict(lambda : 0)\\n        ans = 0\\n        l = 0\\n        temp = 0\\n        for i, c in enumerate(word):\\n            if c in vowels:\\n                dp[c] = i\\n                \\n                while len(dp) == 5:\\n                    if dp[word[l]] == l:\\n                        del dp[word[l]]\\n                    \\n                    l += 1\\n                    temp += 1\\n                    \\n                ans += temp\\n            else:\\n                dp.clear()\\n                temp = 0\\n                l = i + 1\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        vowels = set([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'])\\n        dp = defaultdict(lambda : 0)\\n        ans = 0\\n        l = 0\\n        temp = 0\\n        for i, c in enumerate(word):\\n            if c in vowels:\\n                dp[c] = i\\n                \\n                while len(dp) == 5:\\n                    if dp[word[l]] == l:\\n                        del dp[word[l]]\\n                    \\n                    l += 1\\n                    temp += 1\\n                    \\n                ans += temp\\n            else:\\n                dp.clear()\\n                temp = 0\\n                l = i + 1\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2300472,
                "title": "easy-solutin-python",
                "content": "class Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        \\n        if len(word)<5:\\n            return 0\\n        \\n        counter=0\\n        \\n        for i in range(len(word)):\\n            for j in range(i+5,len(word)+1):\\n                if set(word[i:j])==set(\\'aeiou\\'):\\n                    counter+=1\\n        return counter\\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        \\n        if len(word)<5:\\n            return 0\\n        \\n        counter=0\\n        \\n        for i in range(len(word)):\\n            for j in range(i+5,len(word)+1):\\n                if set(word[i:j])==set(\\'aeiou\\'):\\n                    counter+=1\\n        return counter\\n",
                "codeTag": "Java"
            },
            {
                "id": 2272706,
                "title": "clean-100-small-2062-count-vowel-substrings-of-a-string",
                "content": "class Solution {\\npublic:\\n\\n\\n\\tbool isvowel(char s){  // to check that it contains  the vowel from  a e i o u\\n        if(s==\\'a\\'||s==\\'e\\'||s==\\'i\\'||s==\\'o\\'||s==\\'u\\')return true;\\n        return false;\\n    }\\n    int countVowelSubstrings(string s) {\\n        \\n        int n=s.size();\\n        \\n        int ans=0;\\n        \\n        unordered_map<char,int>mp;\\n        \\n        for(int i=0;i<n;i++){\\n            mp.clear();\\n            for(int j=i;j<n;j++)\\n            {\\n                if(!isvowel(s[j]))break; // if char is not ovwel then false\\n                mp[s[j]]++;\\n                if(mp.size()==5)ans++ ;// to check that the string form contains all the vowel\\n\\n            }\\n        }  \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n\\tbool isvowel(char s){  // to check that it contains  the vowel from  a e i o u\\n        if(s==\\'a\\'||s==\\'e\\'||s==\\'i\\'||s==\\'o\\'||s==\\'u\\')return true;\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2049197,
                "title": "simple-logic-c-easy-understnding",
                "content": "```\\nclass Solution {\\nprivate:\\n    inline bool is(char ch) \\n    {\\n        return (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\');\\n    }\\npublic:\\n    int countVowelSubstrings(string word)\\n    {\\n        unordered_set<char> set;\\n        int len = word.length(), count = 0;\\n        \\n        for (int i = 0; i < len - 4; i++)\\n        {\\n            set.clear();\\n            for (int j = i; j < len; j++)\\n            {\\n                if( is(word[j]) ){\\n                    set.insert(word[j]);\\n                }\\n                else {\\n                    break;\\n                }\\n                if(set.size() == 5){\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\nprivate:\\n    inline bool is(char ch) \\n    {\\n        return (ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\');\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2034988,
                "title": "3ms-93-faster-simple-java-solution",
                "content": "java code is:\\n```\\nclass Solution {\\n      Map<Character,Integer>map;\\n    int substrings(String word,int size){\\n        int count=0;\\n        for(int i=0,j=0;i<word.length();i++){\\n           char c=word.charAt(i);\\n            if(c!=\\'a\\'&&c!=\\'e\\'&&c!=\\'i\\'&&c!=\\'o\\'&&c!=\\'u\\'){\\n                map.clear();\\n                j=i+1;\\n                continue;\\n            }\\n            map.put(c,map.getOrDefault(c,0)+1);\\n            while(map.size()>size){\\n                    char jc=word.charAt(j++);\\n                    int f=map.get(jc);\\n                    if(f==1)map.remove(jc);\\n                    else map.put(jc,f-1);\\n            }\\n            count+=(i-j+1);\\n        }\\n        map.clear();\\n        return count;\\n    }\\n    public int countVowelSubstrings(String word) {\\n        //no of substring contains at-most 5 vowel - substring contains at most 4 vowel\\n        map=new HashMap<>();\\n        return substrings(word,5)-substrings(word,4);\\n    }\\n}\\n```\\n\\n# Time : O(n) linear***\\n# Space : O(n) linear\\n# \\n# Please Upvote if this is helpful*",
                "solutionTags": [
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n      Map<Character,Integer>map;\\n    int substrings(String word,int size){\\n        int count=0;\\n        for(int i=0,j=0;i<word.length();i++){\\n           char c=word.charAt(i);\\n            if(c!=\\'a\\'&&c!=\\'e\\'&&c!=\\'i\\'&&c!=\\'o\\'&&c!=\\'u\\'){\\n                map.clear();\\n                j=i+1;\\n                continue;\\n            }\\n            map.put(c,map.getOrDefault(c,0)+1);\\n            while(map.size()>size){\\n                    char jc=word.charAt(j++);\\n                    int f=map.get(jc);\\n                    if(f==1)map.remove(jc);\\n                    else map.put(jc,f-1);\\n            }\\n            count+=(i-j+1);\\n        }\\n        map.clear();\\n        return count;\\n    }\\n    public int countVowelSubstrings(String word) {\\n        //no of substring contains at-most 5 vowel - substring contains at most 4 vowel\\n        map=new HashMap<>();\\n        return substrings(word,5)-substrings(word,4);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032149,
                "title": "easy-to-undertand-java-solution",
                "content": "~~~\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        \\n        int count5 = count(word,5);// find the substring that contains atmost 5 vowels.\\n        int count4 = count(word,4); find the substring that contains atmost 4 vowels.\\n        return count5-count4;// this is equal to substring containing exactly 5 vowels.\\n    }\\n    \\n    private int count(String word,int k){\\n        \\n        Set<Character> vowels = new HashSet();\\n        vowels.add(\\'a\\');\\n        vowels.add(\\'e\\');\\n        vowels.add(\\'i\\');\\n        vowels.add(\\'o\\');\\n        vowels.add(\\'u\\');\\n        \\n        Set<Character> curr = new HashSet();\\n        int res =0;\\n        int left=0;\\n        Map<Character,Integer> map = new HashMap();        \\n        for(int right=0;right<word.length();right++){\\n            \\n            if(!vowels.contains(word.charAt(right))){    \\n                map.clear();\\n                left=right+1;\\n            }else{\\n                \\n                map.put(word.charAt(right),map.getOrDefault(word.charAt(right),0)+1);\\n                while(map.size()>k){\\n                    \\n                     map.put(word.charAt(left),map.getOrDefault(word.charAt(left),0)-1);\\n                    if(map.get(word.charAt(left))==0){\\n                        map.remove(word.charAt(left));\\n                    }\\n                    left++;\\n                }\\n                \\n               res+=right-left+1; \\n            }\\n            \\n        }\\n        \\n        \\n        \\n        return res;\\n    }\\n}\\n~~~",
                "solutionTags": [],
                "code": "class Solution {\\n    public int countVowelSubstrings(String word) {\\n        \\n        int count5 = count(word,5);// find the substring that contains atmost 5 vowels.\\n        int count4 = count(word,4); find the substring that contains atmost 4 vowels.\\n        return count5-count4;// this is equal to substring containing exactly 5 vowels.\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2008673,
                "title": "c-quick-learner-sliding-window",
                "content": "May 4, 2022\\nIt is challenge to write a sliding window solution with readable and easy to following code. I chose to study one of C# Leetcode discuss post, and then add my coding styles. \\n\\n**Sliding window | Case study: \"xxaiioueiiaxx\"**\\nI like to quickly learn from votrubac\\'s analysis on this algorithm using sliding window technique. \\n\\nj mark the start of an \"all-vowel\" substring, and i is the current position. The window between k - 1 and i is the smallest window with all 5 vowels. So, for each position i, we have k - j valid substrings. \\n\\n![image](https://assets.leetcode.com/users/images/f0e5dc4e-2368-452d-8805-2a4740f78ba2_1651701009.9394739.jpeg)\\n\\n\\n\\n**Sliding window | Inside loop left pointer** \\nI tried to understand inside loop sliding window left pointer - time complexity issue, it seems that the linear time complexity is impossible because of left pointer.  I will look into more and add my thought process here. \\n\\nThe following C# code passes online judge. \\n\\n```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _2062_sliding_window\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var result = CountVowelSubstrings(\"cuaieuouac\");\\n        }\\n\\n        /// <summary>\\n        /// sliding window \\n        /// study code: \\n        /// https://leetcode.com/problems/count-vowel-substrings-of-a-string/discuss/1563916/C-Sliding-Window\\n        /// </summary>\\n        /// <param name=\"word\"></param>\\n        /// <returns></returns>\\n        public static int CountVowelSubstrings(string word)\\n        {\\n            if (word == null || word.Length == 0)\\n            {\\n                return 0;\\n            }\\n\\n            // pad one space char, why? \\n            var padding = word + \" \"; \\n\\n            int start = 0;\\n            var count = 0;\\n\\n            var map = new Dictionary<char, int>();\\n\\n            // two loops - outside, inside one is for sliding window left pointer\\n            for (int outside = 0; outside < padding.Length; outside++)\\n            {\\n                var c = padding[outside];\\n                if (\"aeiou\".Contains(c))\\n                {\\n                    if(!map.ContainsKey(c))\\n                    {\\n                        map.Add(c, 0);\\n                    }\\n\\n                    map[c]++;\\n\\n                    if (map.Keys.Count == 5)\\n                    {\\n                        count++;\\n                        var dict1 = new Dictionary<char, int>(map);\\n                        int left = start;\\n\\n                        // Find more substrings containing all vowel chars - \\n                        // move left pointer - index\\n                        while (left < outside)\\n                        {\\n                            dict1[padding[left]]--;\\n\\n                            if (dict1[padding[left]] == 0)\\n                            {\\n                                break;\\n                            }\\n\\n                            count++;\\n                            left++;\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    // reset, start new substring search\\n                    map.Clear();\\n                    start = outside + 1;\\n                }\\n            }\\n\\n            return count;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nusing System;\\nusing System.Collections.Generic;\\nusing System.Linq;\\nusing System.Text;\\nusing System.Threading.Tasks;\\n\\nnamespace _2062_sliding_window\\n{\\n    class Program\\n    {\\n        static void Main(string[] args)\\n        {\\n            var result = CountVowelSubstrings(\"cuaieuouac\");\\n        }\\n\\n        /// <summary>\\n        /// sliding window \\n        /// study code: \\n        /// https://leetcode.com/problems/count-vowel-substrings-of-a-string/discuss/1563916/C-Sliding-Window\\n        /// </summary>\\n        /// <param name=\"word\"></param>\\n        /// <returns></returns>\\n        public static int CountVowelSubstrings(string word)\\n        {\\n            if (word == null || word.Length == 0)\\n            {\\n                return 0;\\n            }\\n\\n            // pad one space char, why? \\n            var padding = word + \" \"; \\n\\n            int start = 0;\\n            var count = 0;\\n\\n            var map = new Dictionary<char, int>();\\n\\n            // two loops - outside, inside one is for sliding window left pointer\\n            for (int outside = 0; outside < padding.Length; outside++)\\n            {\\n                var c = padding[outside];\\n                if (\"aeiou\".Contains(c))\\n                {\\n                    if(!map.ContainsKey(c))\\n                    {\\n                        map.Add(c, 0);\\n                    }\\n\\n                    map[c]++;\\n\\n                    if (map.Keys.Count == 5)\\n                    {\\n                        count++;\\n                        var dict1 = new Dictionary<char, int>(map);\\n                        int left = start;\\n\\n                        // Find more substrings containing all vowel chars - \\n                        // move left pointer - index\\n                        while (left < outside)\\n                        {\\n                            dict1[padding[left]]--;\\n\\n                            if (dict1[padding[left]] == 0)\\n                            {\\n                                break;\\n                            }\\n\\n                            count++;\\n                            left++;\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    // reset, start new substring search\\n                    map.Clear();\\n                    start = outside + 1;\\n                }\\n            }\\n\\n            return count;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1895096,
                "title": "o-n-sliding-window-intuition-behind-explained-easily-understandable-code",
                "content": "### Intution\\n\\n##### *Overall time complexity O(N)*\\n\\nWe traverse the string and get the max length of the substring starting at index i till an index j that contains only \\nvowels from i to j . Now , as we have 2 indexes and we know that there are only vowels in between these 2 indexes,\\nwe call a function to check the number of substrings that have all the vowels in them.\\n\\nNow the sliding window part should be self explanatory , please dry run the code to understand further .\\nPlease comment if you dont understand any part.\\n\\n\\n\\n\\n```\\nclass Solution {\\n    \\n    int solve(int s , int e , string &word)\\n    {\\n          map<int , int> st ;\\n        \\n         int i = s , j = s ;\\n        \\n         int ans = 0;\\n        \\n         for(int i=s ; i<e ; i++)\\n         {\\n             while(j < e && st.size() < 5)\\n             {\\n                 st[word[j]]++;\\n                 j++ ;\\n             }\\n             \\n             if(st.size() == 5 )\\n             ans+= (e - j + 1) ;\\n             \\n             st[word[i]]-- ;\\n             if(st[word[i]] == 0) st.erase(word[i]) ;\\n         }\\n        \\n        return ans;\\n    }\\n    \\npublic:\\n    int countVowelSubstrings(string word) {\\n        \\n        int sz = word.size() ;\\n        set<int> vowels({\\'a\\' , \\'e\\' , \\'i\\' , \\'o\\' , \\'u\\'}) ;\\n        int ans = 0;\\n        \\n        for(int i = 0; i<sz ; i++)\\n        {\\n            \\n            if(!vowels.count(word[i])) continue ;\\n            \\n            int j = i;\\n            while(j < sz && vowels.count( word[j]) )\\n            {\\n                j++;\\n            }\\n            \\n            if(i!= j)\\n            {\\n                ans+= solve(i , j , word) ;\\n                i = j ;\\n            }\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "Sliding Window"
                ],
                "code": "class Solution {\\n    \\n    int solve(int s , int e , string &word)\\n    {\\n          map<int , int> st ;\\n        \\n         int i = s , j = s ;\\n        \\n         int ans = 0;\\n        \\n         for(int i=s ; i<e ; i++)\\n         {\\n             while(j < e && st.size() < 5)\\n             {\\n                 st[word[j]]++;\\n                 j++ ;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 1869748,
                "title": "python3",
                "content": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        c=0\\n        for i in range(len(word)-4):\\n            for j in range(i+5,len(word)+1):\\n                if((set(word[i:j]) == set(\\'aeiou\\'))):\\n                    c+=1\\n        return c\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        c=0\\n        for i in range(len(word)-4):\\n            for j in range(i+5,len(word)+1):\\n                if((set(word[i:j]) == set(\\'aeiou\\'))):\\n                    c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1692502,
                "title": "diagram-explanation-java-3ms-beats-85-sliding-windows-plus-backtracking",
                "content": "With sliding windows, we see how far we can decrement the right pointer until the substring doesn\\'t contain all 5 vowels. Then we advance the left pointer and check again. See below for the seven vowel substring solutions to the string \"cuaieuouac\" as an example.\\n\\n\\n![image](https://assets.leetcode.com/users/images/ec7e8ee2-8459-4f19-b1a1-cffb4fd6ab93_1642282458.2297754.jpeg)\\n\\n\\n\\n\\n```\\n/*\\nRuntime: 3 ms, faster than 84.76% of Java online submissions for Count Vowel Substrings of a String.\\nMemory Usage: 37.4 MB, less than 74.44% of Java online submissions for Count Vowel Substrings of a String.\\n*/\\n\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        \\n        int numVowelSubstrings = 0; // what we\\'ll return\\n        \\n        // strategy: two pointers/sliding windows plus some backtracking\\n        \\n        int leftPointer = 0;\\n        int rightPointer = 0;\\n        \\n        while (leftPointer <= word.length() - 1) {\\n            \\n            if (!isVowel(word.charAt(leftPointer))) {\\n                ++leftPointer;\\n                continue;\\n            }\\n            \\n            // now we\\'re on first vowel, so find last vowel of substring\\n            int[] vowelCounts = new int[26]; // frequency table\\n            ++vowelCounts[word.charAt(leftPointer) - \\'a\\'];\\n            rightPointer = leftPointer + 1;\\n            while (rightPointer < word.length() && isVowel(word.charAt(rightPointer))) {\\n                ++vowelCounts[word.charAt(rightPointer) - \\'a\\'];\\n                ++rightPointer;\\n            }\\n            \\n            if (rightPointer - leftPointer < 4) {\\n                // not possible to have all five vowels, so continue search\\n                leftPointer = rightPointer + 1;\\n                continue;\\n            }\\n            \\n            if (!haveAllFiveVowels(vowelCounts)) {\\n                // don\\'t have all five vowels, so continue search\\n                leftPointer = rightPointer + 1;\\n                continue;\\n            }\\n            \\n            // now we have a valid vowel substring that is `word.substring(leftPointer, rightPointer)`\\n            for (int i = leftPointer; i < rightPointer; ++i) {\\n                \\n                ++numVowelSubstrings;\\n                \\n                int[] copyVowelCounts = vowelCounts.clone(); // for our \"backtracking\" we reset the `copyVowelCounts` array to `vowelCounts`\\n                \\n                for (int j = rightPointer - 1; ; --j) {\\n                    --copyVowelCounts[word.charAt(j) - \\'a\\'];\\n                    if (haveAllFiveVowels(copyVowelCounts)) {\\n                        ++numVowelSubstrings;\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                \\n                --vowelCounts[word.charAt(leftPointer) - \\'a\\']; // advance `leftPointer` and update `vowelCounts`\\n                ++leftPointer;\\n                \\n                if (!haveAllFiveVowels(vowelCounts)) {\\n                    break;\\n                }\\n            }\\n            \\n            leftPointer = rightPointer + 1;\\n        }\\n        \\n        return numVowelSubstrings;\\n    }\\n    \\n    private boolean isVowel(char c) {\\n        if (\"aeiou\".indexOf(c) < 0) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n    \\n    private boolean haveAllFiveVowels(int[] arr) {\\n        if (arr[\\'a\\' - \\'a\\'] == 0) {\\n            return false;\\n        }\\n        if (arr[\\'e\\' - \\'a\\'] == 0) {\\n            return false;\\n        }\\n        if (arr[\\'i\\' - \\'a\\'] == 0) {\\n            return false;\\n        }\\n        if (arr[\\'o\\' - \\'a\\'] == 0) {\\n            return false;\\n        }\\n        if (arr[\\'u\\' - \\'a\\'] == 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\nRuntime: 3 ms, faster than 84.76% of Java online submissions for Count Vowel Substrings of a String.\\nMemory Usage: 37.4 MB, less than 74.44% of Java online submissions for Count Vowel Substrings of a String.\\n*/\\n\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        \\n        int numVowelSubstrings = 0; // what we\\'ll return\\n        \\n        // strategy: two pointers/sliding windows plus some backtracking\\n        \\n        int leftPointer = 0;\\n        int rightPointer = 0;\\n        \\n        while (leftPointer <= word.length() - 1) {\\n            \\n            if (!isVowel(word.charAt(leftPointer))) {\\n                ++leftPointer;\\n                continue;\\n            }\\n            \\n            // now we\\'re on first vowel, so find last vowel of substring\\n            int[] vowelCounts = new int[26]; // frequency table\\n            ++vowelCounts[word.charAt(leftPointer) - \\'a\\'];\\n            rightPointer = leftPointer + 1;\\n            while (rightPointer < word.length() && isVowel(word.charAt(rightPointer))) {\\n                ++vowelCounts[word.charAt(rightPointer) - \\'a\\'];\\n                ++rightPointer;\\n            }\\n            \\n            if (rightPointer - leftPointer < 4) {\\n                // not possible to have all five vowels, so continue search\\n                leftPointer = rightPointer + 1;\\n                continue;\\n            }\\n            \\n            if (!haveAllFiveVowels(vowelCounts)) {\\n                // don\\'t have all five vowels, so continue search\\n                leftPointer = rightPointer + 1;\\n                continue;\\n            }\\n            \\n            // now we have a valid vowel substring that is `word.substring(leftPointer, rightPointer)`\\n            for (int i = leftPointer; i < rightPointer; ++i) {\\n                \\n                ++numVowelSubstrings;\\n                \\n                int[] copyVowelCounts = vowelCounts.clone(); // for our \"backtracking\" we reset the `copyVowelCounts` array to `vowelCounts`\\n                \\n                for (int j = rightPointer - 1; ; --j) {\\n                    --copyVowelCounts[word.charAt(j) - \\'a\\'];\\n                    if (haveAllFiveVowels(copyVowelCounts)) {\\n                        ++numVowelSubstrings;\\n                    } else {\\n                        break;\\n                    }\\n                }\\n                \\n                --vowelCounts[word.charAt(leftPointer) - \\'a\\']; // advance `leftPointer` and update `vowelCounts`\\n                ++leftPointer;\\n                \\n                if (!haveAllFiveVowels(vowelCounts)) {\\n                    break;\\n                }\\n            }\\n            \\n            leftPointer = rightPointer + 1;\\n        }\\n        \\n        return numVowelSubstrings;\\n    }\\n    \\n    private boolean isVowel(char c) {\\n        if (\"aeiou\".indexOf(c) < 0) {\\n            return false;\\n        } else {\\n            return true;\\n        }\\n    }\\n    \\n    private boolean haveAllFiveVowels(int[] arr) {\\n        if (arr[\\'a\\' - \\'a\\'] == 0) {\\n            return false;\\n        }\\n        if (arr[\\'e\\' - \\'a\\'] == 0) {\\n            return false;\\n        }\\n        if (arr[\\'i\\' - \\'a\\'] == 0) {\\n            return false;\\n        }\\n        if (arr[\\'o\\' - \\'a\\'] == 0) {\\n            return false;\\n        }\\n        if (arr[\\'u\\' - \\'a\\'] == 0) {\\n            return false;\\n        }\\n        return true;\\n    }\\n\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1682638,
                "title": "count-vowel-substrings-of-a-string-brute-force-c-operator-overloading-in-sets",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        int n = word.size(), ans = 0;\\n        unordered_set<char> vowels{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        for(int i = 0; i < n; i++){\\n            for(int j = 1; j <= n - i; j++){\\n                string s = word.substr(i, j);\\n                unordered_set<char> str(begin(s), end(s));\\n                if(str == vowels) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        int n = word.size(), ans = 0;\\n        unordered_set<char> vowels{\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'};\\n        for(int i = 0; i < n; i++){\\n            for(int j = 1; j <= n - i; j++){\\n                string s = word.substr(i, j);\\n                unordered_set<char> str(begin(s), end(s));\\n                if(str == vowels) ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626777,
                "title": "c-0ms",
                "content": "```\\nclass Solution {\\npublic:\\n    bool update(int& code, char c)\\n    {\\n        if (c == \\'a\\') code |= 1;\\n        else if (c == \\'e\\') code |= 2;\\n        else if (c == \\'i\\') code |= 4;\\n        else if (c == \\'o\\') code |= 8;\\n        else if (c == \\'u\\') code |= 16;\\n        else return false;\\n        return true;\\n    }\\n    \\n    int countVowelSubstrings(string word) {\\n        int count = 0;\\n        const int length = word.length();\\n        for (int i = 0; i < length - 4; ++i) {\\n            int code = 0;\\n            if (!update( code, word[i] )) continue;\\n            \\n            for (int j = i + 1; j < length; ++j) {\\n                if (!update( code, word[j] )) break;\\n                else if (code == 31) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool update(int& code, char c)\\n    {\\n        if (c == \\'a\\') code |= 1;\\n        else if (c == \\'e\\') code |= 2;\\n        else if (c == \\'i\\') code |= 4;\\n        else if (c == \\'o\\') code |= 8;\\n        else if (c == \\'u\\') code |= 16;\\n        else return false;\\n        return true;\\n    }\\n    \\n    int countVowelSubstrings(string word) {\\n        int count = 0;\\n        const int length = word.length();\\n        for (int i = 0; i < length - 4; ++i) {\\n            int code = 0;\\n            if (!update( code, word[i] )) continue;\\n            \\n            for (int j = i + 1; j < length; ++j) {\\n                if (!update( code, word[j] )) break;\\n                else if (code == 31) count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1626076,
                "title": "easy-python3-solution-using-counter",
                "content": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        n=len(word)\\n        vowels=\"aeiou\"\\n        from collections import Counter\\n        \\n        res=0\\n        \\n        for i in range(n):\\n            for j in range(i+4,n):\\n                counter=Counter(word[i:j+1])\\n                if all(counter[key]>=1 for key in vowels) and len(counter)==5:\\n                    res+=1\\n                    \\n        \\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        n=len(word)\\n        vowels=\"aeiou\"\\n        from collections import Counter\\n        \\n        res=0\\n        \\n        for i in range(n):\\n            for j in range(i+4,n):\\n                counter=Counter(word[i:j+1])\\n                if all(counter[key]>=1 for key in vowels) and len(counter)==5:\\n                    res+=1\\n                    \\n        \\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1625306,
                "title": "c-prefix-sliding-window-simple-solution",
                "content": "We use `prefix` as how many substring extended from minimum legal substring `word[left...right]`\\nif prefix == 3, then there are 4 substring \\n* s[left...right]\\n* s[left-1...right]\\n* s[left-2...right]\\n* s[left-3...right]\\n```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        int n = word.size();\\n        int left = 0, right = 0, res = 0, times = 0, prefix = 0;\\n        vector<int> cnt(26, 0);\\n        unordered_set<char> set = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        while (right < n) {\\n            if (set.find(word[right]) == set.end()) {\\n                left = right+1;\\n                cnt.clear();\\n                cnt.resize(26, 0);\\n                prefix = times = 0;\\n            } else {\\n                times += ++cnt[word[right]-\\'a\\'] == 1;\\n            }\\n            while (left < right && cnt[word[left]-\\'a\\'] > 1) {\\n                --cnt[word[left++]-\\'a\\'];\\n                ++prefix;\\n            }\\n            if (times == 5) {\\n                res += 1+prefix;\\n            }\\n            ++right;\\n        }\\n        return res;\\n    }\\n};\\n```\\n* time: `O(n)`\\n* space: `O(1)`",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        int n = word.size();\\n        int left = 0, right = 0, res = 0, times = 0, prefix = 0;\\n        vector<int> cnt(26, 0);\\n        unordered_set<char> set = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n        while (right < n) {\\n            if (set.find(word[right]) == set.end()) {\\n                left = right+1;\\n                cnt.clear();\\n                cnt.resize(26, 0);\\n                prefix = times = 0;\\n            } else {\\n                times += ++cnt[word[right]-\\'a\\'] == 1;\\n            }\\n            while (left < right && cnt[word[left]-\\'a\\'] > 1) {\\n                --cnt[word[left++]-\\'a\\'];\\n                ++prefix;\\n            }\\n            if (times == 5) {\\n                res += 1+prefix;\\n            }\\n            ++right;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1615298,
                "title": "modifed-solution-that-finds-any-no-of-vowels-mediam-qusestion",
                "content": "```\\nclass Solution {\\n    \\nprivate:\\n    bool isVowel(char ch){\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\') return true;\\n        return false;\\n    }\\nprivate:\\n    int countAtMostKvowels(string s,int k){\\n        int l = 0;\\n        unordered_map<char,int>mp;\\n        int cnt = 0;\\n        int n = s.size();\\n        for(int r = 0;r<n;r++){\\n            if(isVowel(s[r])==false){\\n                //clear the map bcs a new substring will start\\n                mp.clear();\\n                l = r+1;\\n                continue;\\n            }\\n            mp[s[r]]++;\\n            \\n            while(mp.size()>k){\\n                mp[s[l]]--;\\n                if(mp[s[l]] == 0) mp.erase(s[l]);\\n                l++;\\n            }\\n            cnt += (r-l+1);\\n        }\\n        return cnt;\\n    }\\n    \\n    \\npublic:\\n    int countVowelSubstrings(string word) {\\n        int n = word.size();\\n        int cntFor5 = countAtMostKvowels(word,5);\\n        int cntFor4 = countAtMostKvowels(word,4);\\n        return cntFor5 - cntFor4;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\nprivate:\\n    bool isVowel(char ch){\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\') return true;\\n        return false;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1594658,
                "title": "java-easy-solution",
                "content": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        int count[]=new int[26];\\n        int result=0;\\n        for(int i=0;i<word.length();i++){\\n            for(int j=i;j<word.length();j++){\\n                char c=word.charAt(j);\\n                if(c==\\'a\\'||c==\\'e\\'||c==\\'i\\'||c==\\'o\\'||c==\\'u\\'){\\n                    count[c-97]=1;\\n                    int sum=0;\\n                    for(int k:count)\\n                    sum+=k;\\n                    if(sum==5)\\n                     result++;\\n                }\\n                else\\n                    break;\\n            }\\n            count[0]=0;\\n            count[\\'e\\'-97]=0;\\n            count[\\'i\\'-97]=0;\\n            count[\\'o\\'-97]=0;\\n            count[\\'u\\'-97]=0;\\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        int count[]=new int[26];\\n        int result=0;\\n        for(int i=0;i<word.length();i++){\\n            for(int j=i;j<word.length();j++){\\n                char c=word.charAt(j);\\n                if(c==\\'a\\'||c==\\'e\\'||c==\\'i\\'||c==\\'o\\'||c==\\'u\\'){\\n                    count[c-97]=1;\\n                    int sum=0;\\n                    for(int k:count)\\n                    sum+=k;\\n                    if(sum==5)\\n                     result++;\\n                }\\n                else\\n                    break;\\n            }\\n            count[0]=0;\\n            count[\\'e\\'-97]=0;\\n            count[\\'i\\'-97]=0;\\n            count[\\'o\\'-97]=0;\\n            count[\\'u\\'-97]=0;\\n        }\\n        return result;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1582476,
                "title": "java-readable-solution",
                "content": "**Problem Statement at a glance:** Return the number of substrings such that it should contain only vowels and all vowels must be in the substring.\\n\\n**Approach 1:** Brute Force\\n-> Quick look: Get all substrings of the given string and check if the substring has all vowels and no consonants.\\n-> Step by step approach:\\n* Use two loops to get substrings. Outer loop says that our substring is starting from that index. Inner loop will traverse for remaining characters. So the substring starts from the current index of the outer loop and the substring ends at the index of the inner loop.\\n* If the character is not a vowel, then it\\'s an invalid case, so just break the loop.\\n* Else, set its frequency to 1, and check if the sum of all elements in our array is 5 or not.\\n* If it is 5, increment our answer.\\n**Code (Java ):**\\n```\\nclass Solution {\\n    // Function to check whether character is Vowel or not\\n    public boolean isVowel(char ch)\\n    {\\n        if( ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch==\\'u\\')\\n            return true;\\n        return false;\\n    }\\n    // Function to get sum of elements in frequency array\\n    public int totalSum(int []freq)\\n    {\\n        int sum=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            sum+=freq[i];\\n        }\\n        return sum;\\n    }\\n    public int countVowelSubstrings(String word) {\\n        // Initialize current count of substrings as 0\\n        int count=0;\\n        // Frequency array: In this array we set frequency of character to 1, if it is present.\\n        int []freqArray=new int[26];\\n        for(int i=0;i<word.length();i++)\\n        { \\n            // Make the frequency of all elements to 0.\\n            Arrays.fill(freqArray,0);\\n            // Traverse to get all substrings starting from i.\\n            for(int j=i;j<word.length();j++)\\n            {\\n                // If the character is a vowel then set the frequency to 1.\\n                if(isVowel(word.charAt(j)))\\n                {\\n                    freqArray[word.charAt(j)-\\'a\\']=1;\\n                    // Checking if the total sum of the Frequency Array is 5 or not.\\n                    if(totalSum(freqArray)==5)\\n                    {\\n                        count++;\\n                    }\\n                }\\n                // If the current character is not a vowel, then this substring is not valid, so break.\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        // Return the total number of valid substrings.\\n        return count;\\n    }\\n}\\n```\\n**Complexity Analysis:**\\nTime Complexity: O(N^2) [ Practical time complexity: O(N^2 * 26) ]\\nSpace Complexity: O(1)   [Though we are using extra array, it is not dependent on size of      string]\\n\\n**Approach 2: Sliding Window**\\n-> Quick look: Find the difference between the number of substrings with at most 5 vowels and the number of substrings with at most 4 vowels.\\n-> Step by step explanation:\\n* At most 5 vowel substrings means a substring having 0 vowels, having 1 vowel, 2 vowels, 3 vowels, 4 vowels and 5 vowels.\\n* At most 4 vowel substrings means a substring having 0 vowels, having 1 vowel, 2 vowels, 3 vowels and 4 vowels.\\n* So if we take the difference between both of them, we are left with substring having exactly 5 vowels.\\n* Finding the number of substrings with at most k vowels:\\n* Maintain a map to store the frequency of characters, two pointers prev and current.\\n* If the current character is not a vowel, point the prev pointer to the next character.\\n* Else, increment its frequency. Now check if the size of the map is greater than k, then contract our window. \\n* Lastly increment the result with current-prev+1\\n**Code ( Java ):**\\n```\\nclass Solution {\\n    // Function to check whether character is Vowel or not\\n    public boolean isVowel(char ch)\\n    {\\n        if( ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch==\\'u\\')\\n            return true;\\n        return false;\\n    }\\n    public int countAtMostKVowels(String word,int k)\\n    {\\n        // Pointer used to contract the window\\n        int prev=0;\\n        HashMap<Character,Integer>vowelMap = new HashMap<>();\\n        int count=0;\\n        for(int current=0; current < word.length(); current++)\\n        {\\n            // If current character is not vowel, then a substring containing it is not valid, so just move prev to current + 1\\n            if(!isVowel(word.charAt(current)))\\n            {\\n                vowelMap.clear();\\n                prev=current+1;\\n                continue;\\n            }\\n            else\\n            {\\n                // Getting current character into \\'ch\\'\\n                char ch=word.charAt(current);\\n                // Increment frequency of current character\\n                if(vowelMap.containsKey(ch))\\n                    vowelMap.put(ch,vowelMap.get(ch)+1);\\n                else\\n                    vowelMap.put(ch,1);\\n                // If map size exceeds k, then contract the window size, so that we get number of substrings having at most k vowels\\n                while(vowelMap.size()>k)\\n                {\\n                    if(vowelMap.get(word.charAt(prev))==1)\\n                        vowelMap.remove(word.charAt(prev));\\n                    else\\n                        vowelMap.put(word.charAt(prev),vowelMap.get(word.charAt(prev))-1);\\n                    prev++;\\n                }\\n                count += current - prev + 1;\\n            }\\n        }\\n        // Finally return the number of substrings with at most k vowels.\\n        return count;\\n        \\n    }\\n    public int countVowelSubstrings(String word) {\\n      // Return difference between the number of substrings with at most 5 vowels and the number of substrings with at most 4 vowels.\\n      return countAtMostKVowels(word,5)-countAtMostKVowels(word,4);\\n    }\\n}\\n```\\n**Complexity Analysis:**\\nTime Complexity: O(N) [ Practical time complexity: O(4*N) ]\\nSpace Complexity: O(1)   [Though we are using extra hashmap, it is not dependent on size of  string, at max hashmap will have 26 characters]\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Function to check whether character is Vowel or not\\n    public boolean isVowel(char ch)\\n    {\\n        if( ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch==\\'u\\')\\n            return true;\\n        return false;\\n    }\\n    // Function to get sum of elements in frequency array\\n    public int totalSum(int []freq)\\n    {\\n        int sum=0;\\n        for(int i=0;i<26;i++)\\n        {\\n            sum+=freq[i];\\n        }\\n        return sum;\\n    }\\n    public int countVowelSubstrings(String word) {\\n        // Initialize current count of substrings as 0\\n        int count=0;\\n        // Frequency array: In this array we set frequency of character to 1, if it is present.\\n        int []freqArray=new int[26];\\n        for(int i=0;i<word.length();i++)\\n        { \\n            // Make the frequency of all elements to 0.\\n            Arrays.fill(freqArray,0);\\n            // Traverse to get all substrings starting from i.\\n            for(int j=i;j<word.length();j++)\\n            {\\n                // If the character is a vowel then set the frequency to 1.\\n                if(isVowel(word.charAt(j)))\\n                {\\n                    freqArray[word.charAt(j)-\\'a\\']=1;\\n                    // Checking if the total sum of the Frequency Array is 5 or not.\\n                    if(totalSum(freqArray)==5)\\n                    {\\n                        count++;\\n                    }\\n                }\\n                // If the current character is not a vowel, then this substring is not valid, so break.\\n                else\\n                {\\n                    break;\\n                }\\n            }\\n        }\\n        // Return the total number of valid substrings.\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    // Function to check whether character is Vowel or not\\n    public boolean isVowel(char ch)\\n    {\\n        if( ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch==\\'u\\')\\n            return true;\\n        return false;\\n    }\\n    public int countAtMostKVowels(String word,int k)\\n    {\\n        // Pointer used to contract the window\\n        int prev=0;\\n        HashMap<Character,Integer>vowelMap = new HashMap<>();\\n        int count=0;\\n        for(int current=0; current < word.length(); current++)\\n        {\\n            // If current character is not vowel, then a substring containing it is not valid, so just move prev to current + 1\\n            if(!isVowel(word.charAt(current)))\\n            {\\n                vowelMap.clear();\\n                prev=current+1;\\n                continue;\\n            }\\n            else\\n            {\\n                // Getting current character into \\'ch\\'\\n                char ch=word.charAt(current);\\n                // Increment frequency of current character\\n                if(vowelMap.containsKey(ch))\\n                    vowelMap.put(ch,vowelMap.get(ch)+1);\\n                else\\n                    vowelMap.put(ch,1);\\n                // If map size exceeds k, then contract the window size, so that we get number of substrings having at most k vowels\\n                while(vowelMap.size()>k)\\n                {\\n                    if(vowelMap.get(word.charAt(prev))==1)\\n                        vowelMap.remove(word.charAt(prev));\\n                    else\\n                        vowelMap.put(word.charAt(prev),vowelMap.get(word.charAt(prev))-1);\\n                    prev++;\\n                }\\n                count += current - prev + 1;\\n            }\\n        }\\n        // Finally return the number of substrings with at most k vowels.\\n        return count;\\n        \\n    }\\n    public int countVowelSubstrings(String word) {\\n      // Return difference between the number of substrings with at most 5 vowels and the number of substrings with at most 4 vowels.\\n      return countAtMostKVowels(word,5)-countAtMostKVowels(word,4);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1575030,
                "title": "c-60ms",
                "content": "\\n\\n```\\n    bool IsVowel(char c){\\n        return ( (c == \\'a\\') || (c == \\'e\\') || (c == \\'i\\') || (c == \\'o\\') || (c == \\'u\\') );   \\n    }\\n    \\n    public int CountVowelSubstrings(string word) {\\n\\t\\n        int substringCount = 0;\\n\\t\\t\\n        for(int i = 0; i < word.Length; i++){\\n\\t\\t\\n            var hash = new HashSet<char>();\\n\\t\\t\\t\\n            for(int k = i; k < word.Length; k++){\\n                if(!IsVowel(word[k])) break;\\n                hash.Add(word[k]);\\n                if(hash.Count == 5) substringCount++;\\n            }\\n        }\\n        return substringCount;\\n    }\\n\\t\\n\\t```\\n\\t\\n",
                "solutionTags": [],
                "code": "```\\n    bool IsVowel(char c){\\n        return ( (c == \\'a\\') || (c == \\'e\\') || (c == \\'i\\') || (c == \\'o\\') || (c == \\'u\\') );   \\n    }\\n    \\n    public int CountVowelSubstrings(string word) {\\n\\t\\n        int substringCount = 0;\\n\\t\\t\\n        for(int i = 0; i < word.Length; i++){\\n\\t\\t\\n            var hash = new HashSet<char>();\\n\\t\\t\\t\\n            for(int k = i; k < word.Length; k++){\\n                if(!IsVowel(word[k])) break;\\n                hash.Add(word[k]);\\n                if(hash.Count == 5) substringCount++;\\n            }\\n        }\\n        return substringCount;\\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1569750,
                "title": "o-n-solution-with-dry-run-to-help-you-know-how-it-really-works",
                "content": "**Leetcode 2062.   Count Vowel Substrings of a String**\\n\\n\\n\\n\\n**Problem :** A vowel substring is a substring that only consists of vowels and has all five vowels present in it.\\n\\nGiven a string, return the number of vowel substrings in it. \\n\\n\\n\\n\\n**Approaches :** \\n\\n\\n**Brute :** One of the approaches to this problem would be to generate all possible substrings of the given string and to count all the vowel substrings in it. As the time complexity of generating all the substrings of a given string is O(N^2) this solution too would have a time complexity of O(N^2).\\n\\nNote : We can optimize the above solution a bit considering the fact that there are 5 vowels, we may find vowel substrings in substrings of length 5 or greater.\\n\\n\\n\\n\\n\\n**Optimized :** An optimized solution to this problem can be obtained using Sliding Window Technique. In this approach we maintain three pointers : \\n\\ni   :  Current character in the string\\nj   :  Points at the start(head) of the current vowel substring\\nk  :  Points at the first character from the back such that S(i,k) is a vowel substring.\\n\\nHence for each position of i, we would have (k-j) vowel substrings ending at i.\\n\\nLets look at the code first , \\n\\n \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n ```\\npublic int countVowelSubstrings(String word) {\\n        \\n             int j = 0, k = 0, vow = 0, cnt = 0;\\n\\n    HashMap < Character, Integer > map = new HashMap < > ();\\n    map.put(\\'a\\', 0);\\n    map.put(\\'e\\', 0);\\n    map.put(\\'i\\', 0);\\n    map.put(\\'o\\', 0);\\n    map.put(\\'u\\', 0);\\n\\n   \\n\\t\\n\\t\\tfor(int i =0; i<word.length(); i++)\\n\\t\\t\\t\\n\\t\\t\\tif (map.get(word.charAt(i)) != null)\\n\\t\\t\\t\\tmap.put(word.charAt(i), map.get(word.charAt(i)) + 1);\\n\\n\\t\\t\\t\\tif ((int) map.get(word.charAt(i)) == 1)\\n\\t\\t\\t\\t\\t++vow;\\n\\n\\t\\t\\t\\twhile(vow==5)\\n\\t\\t\\t\\t\\tmap.put(word.charAt(k), map.get(word.charAt(k)) - 1);\\n\\n\\t\\t\\t\\t\\t\\tif ((int) map.get(word.charAt(k)) == 0)\\n\\t\\t\\t\\t\\t\\t\\t--vow;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tk++;\\n\\n\\t\\t\\t\\tcnt = cnt + (k-j);\\n\\n\\t\\t\\telse\\n\\t\\t\\t\\tmap.forEach((k1, v) ->  map.put(k1, 0); });\\n\\t\\t\\t\\tvow = 0;\\n            \\t\\t\\tj = k = i + 1;\\n\\n\\n\\treturn cnt;\\n}\\n```\\n\\n\\n\\n\\n\\n\\nInput :    word = \\u201Ccuaieuouac\\u201D\\nOutput :  7\\n\\n\\nPositions of  i  j  and k for the above given test case : \\n\\n\\u201C c  u  a  i  e  u  o  u  a  c \\u201D     (cnt = cnt + 2)\\n   (j==0 ,   k==3,  i==6)\\n\\n\\n\\n\\u201C c  u  a  i  e  u  o  u  a  c \\u201D     (cnt = cnt + 2)\\n      (j==0 ,   k==3,  i==7)\\n\\n\\n\\n\\u201C c  u  a  i  e  u  o  u  a  c \\u201D     (cnt = cnt + 3)\\n      (j==0 ,   k==4  i==8)\\n\\n\\n\\n\\n\\n\\n\\n\\nThank you for reading !\\n",
                "solutionTags": [],
                "code": "```\\npublic int countVowelSubstrings(String word) {\\n        \\n             int j = 0, k = 0, vow = 0, cnt = 0;\\n\\n    HashMap < Character, Integer > map = new HashMap < > ();\\n    map.put(\\'a\\', 0);\\n    map.put(\\'e\\', 0);\\n    map.put(\\'i\\', 0);\\n    map.put(\\'o\\', 0);\\n    map.put(\\'u\\', 0);\\n\\n   \\n\\t\\n\\t\\tfor(int i =0; i<word.length(); i++)\\n\\t\\t\\t\\n\\t\\t\\tif (map.get(word.charAt(i)) != null)\\n\\t\\t\\t\\tmap.put(word.charAt(i), map.get(word.charAt(i)) + 1);\\n\\n\\t\\t\\t\\tif ((int) map.get(word.charAt(i)) == 1)\\n\\t\\t\\t\\t\\t++vow;\\n\\n\\t\\t\\t\\twhile(vow==5)\\n\\t\\t\\t\\t\\tmap.put(word.charAt(k), map.get(word.charAt(k)) - 1);\\n\\n\\t\\t\\t\\t\\t\\tif ((int) map.get(word.charAt(k)) == 0)\\n\\t\\t\\t\\t\\t\\t\\t--vow;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\t\\tk++;\\n\\n\\t\\t\\t\\tcnt = cnt + (k-j);\\n\\n\\t\\t\\telse\\n\\t\\t\\t\\tmap.forEach((k1, v) ->  map.put(k1, 0); });\\n\\t\\t\\t\\tvow = 0;\\n            \\t\\t\\tj = k = i + 1;\\n\\n\\n\\treturn cnt;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1569362,
                "title": "swift-two-approaches-simple-and-fast",
                "content": "1) Simple (12 ms)\\n```\\nclass Solution {\\n    func countVowelSubstrings(_ word: String) -> Int {\\n        guard word.count > 4 else { return 0 }\\n        let word = Array(word), vowels = Set<Character>(\"aeiou\")\\n        var result = 0\\n        for i in word.indices where vowels.contains(word[i]) {\\n            var remainingVowels = vowels\\n            for ch in word[i ..< word.count] {\\n              guard vowels.contains(ch) else { break }\\n              remainingVowels.remove(ch)\\n              if remainingVowels.isEmpty {\\n                result += 1\\n              }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n2) Fast (4 ms)\\n```\\nclass Solution {\\n    func countVowelSubstrings(_ word: String) -> Int {\\n        guard word.count > 4 else { return 0 }\\n        let word = Array(word)\\n        let vowelsInit = Dictionary(uniqueKeysWithValues: \"aeiou\".map{($0, 0)})\\n        var result = 0, windowStart = 0, windowEnd = 0, vowelCounts = vowelsInit, vowelsPresent = 0\\n        for (i, ch) in word.enumerated() {\\n            if let count = vowelCounts[ch] {\\n              if count == 0 {\\n                if vowelsPresent == 0 {\\n                  windowStart = i\\n                  windowEnd = i\\n                }\\n                vowelsPresent += 1\\n              }\\n              vowelCounts[ch]! = count + 1\\n              if vowelsPresent == 5 {\\n                for ch in word[windowEnd ..< word.count] {\\n                    windowEnd += 1\\n                    if let count = vowelCounts[ch] {\\n                      vowelCounts[ch]! = count - 1\\n                      guard count > 1 else { vowelsPresent -= 1; break }\\n                    }\\n                }\\n              }\\n              result += windowEnd - windowStart\\n          } else if vowelsPresent > 0 {\\n            vowelCounts = vowelsInit\\n            vowelsPresent = 0\\n          }\\n        }\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countVowelSubstrings(_ word: String) -> Int {\\n        guard word.count > 4 else { return 0 }\\n        let word = Array(word), vowels = Set<Character>(\"aeiou\")\\n        var result = 0\\n        for i in word.indices where vowels.contains(word[i]) {\\n            var remainingVowels = vowels\\n            for ch in word[i ..< word.count] {\\n              guard vowels.contains(ch) else { break }\\n              remainingVowels.remove(ch)\\n              if remainingVowels.isEmpty {\\n                result += 1\\n              }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func countVowelSubstrings(_ word: String) -> Int {\\n        guard word.count > 4 else { return 0 }\\n        let word = Array(word)\\n        let vowelsInit = Dictionary(uniqueKeysWithValues: \"aeiou\".map{($0, 0)})\\n        var result = 0, windowStart = 0, windowEnd = 0, vowelCounts = vowelsInit, vowelsPresent = 0\\n        for (i, ch) in word.enumerated() {\\n            if let count = vowelCounts[ch] {\\n              if count == 0 {\\n                if vowelsPresent == 0 {\\n                  windowStart = i\\n                  windowEnd = i\\n                }\\n                vowelsPresent += 1\\n              }\\n              vowelCounts[ch]! = count + 1\\n              if vowelsPresent == 5 {\\n                for ch in word[windowEnd ..< word.count] {\\n                    windowEnd += 1\\n                    if let count = vowelCounts[ch] {\\n                      vowelCounts[ch]! = count - 1\\n                      guard count > 1 else { vowelsPresent -= 1; break }\\n                    }\\n                }\\n              }\\n              result += windowEnd - windowStart\\n          } else if vowelsPresent > 0 {\\n            vowelCounts = vowelsInit\\n            vowelsPresent = 0\\n          }\\n        }\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1568484,
                "title": "brute-force",
                "content": "Time Complexity = O(N2);\\n\\n\\n\\n\\n\\n\\n     bool check(char s)\\n    {\\n        if(s==\\'a\\'||s==\\'e\\'||s==\\'i\\'||s==\\'o\\'||s==\\'u\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    \\n    \\n    int countVowelSubstrings(string word) {\\n         int n=word.size();\\n        int count=0;\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            unordered_set<char>u_set;\\n            for(int j=i;j<n&&check(word[j]);j++)\\n            {\\n               u_set.insert(word[j]);\\n                if(u_set.size()==5)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n     \\n    }\\n};\\n",
                "solutionTags": [],
                "code": "Time Complexity = O(N2);\\n\\n\\n\\n\\n\\n\\n     bool check(char s)\\n    {\\n        if(s==\\'a\\'||s==\\'e\\'||s==\\'i\\'||s==\\'o\\'||s==\\'u\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    \\n    \\n    \\n    int countVowelSubstrings(string word) {\\n         int n=word.size();\\n        int count=0;\\n       \\n        for(int i=0;i<n;i++)\\n        {\\n            unordered_set<char>u_set;\\n            for(int j=i;j<n&&check(word[j]);j++)\\n            {\\n               u_set.insert(word[j]);\\n                if(u_set.size()==5)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n     \\n    }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1564817,
                "title": "golang-0ms-brute-force-solution",
                "content": "```go\\nfunc countVowelSubstrings(word string) int {\\n    counter := 0\\n    loop:\\n    for m := 0; m < len(word); m++ {\\n        a, e, i, o, u := 0, 0, 0, 0, 0\\n        for n := m; n < len(word); n++ {\\n            switch word[n] {\\n            case \\'a\\':\\n                a++\\n            case \\'e\\':\\n                e++\\n            case \\'i\\':\\n                i++\\n            case \\'o\\':\\n                o++\\n            case \\'u\\':\\n                u++\\n            default:\\n                continue loop\\n            }\\n            if a > 0 && e > 0 && i > 0 && o > 0 && u > 0 {\\n                counter++\\n            }\\n        }\\n    }\\n    return counter\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc countVowelSubstrings(word string) int {\\n    counter := 0\\n    loop:\\n    for m := 0; m < len(word); m++ {\\n        a, e, i, o, u := 0, 0, 0, 0, 0\\n        for n := m; n < len(word); n++ {\\n            switch word[n] {\\n            case \\'a\\':\\n                a++\\n            case \\'e\\':\\n                e++\\n            case \\'i\\':\\n                i++\\n            case \\'o\\':\\n                o++\\n            case \\'u\\':\\n                u++\\n            default:\\n                continue loop\\n            }\\n            if a > 0 && e > 0 && i > 0 && o > 0 && u > 0 {\\n                counter++\\n            }\\n        }\\n    }\\n    return counter\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1564254,
                "title": "c-solution-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(char s)\\n    {\\n        if(s==\\'a\\'||s==\\'e\\'||s==\\'i\\'||s==\\'o\\'||s==\\'u\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int find(string s,int k)\\n    {\\n        int n=s.size();\\n        unordered_map<char,int>mp;\\n        int j=0;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(check(s[i])==false)\\n            {\\n                j=i+1;\\n                mp.clear();\\n                \\n            }\\n            else\\n            {\\n            mp[s[i]]++;\\n            while(mp.size()>k)\\n            {\\n                if(--mp[s[j]]==0)\\n                {\\n                    mp.erase(s[j]);\\n                }\\n                j++;\\n            }\\n            }\\n            count+=i-j+1;\\n        }\\n        return count;\\n    }\\n    int countVowelSubstrings(string s)\\n    {\\n        return find(s,5)-find(s,4);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(char s)\\n    {\\n        if(s==\\'a\\'||s==\\'e\\'||s==\\'i\\'||s==\\'o\\'||s==\\'u\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int find(string s,int k)\\n    {\\n        int n=s.size();\\n        unordered_map<char,int>mp;\\n        int j=0;\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(check(s[i])==false)\\n            {\\n                j=i+1;\\n                mp.clear();\\n                \\n            }\\n            else\\n            {\\n            mp[s[i]]++;\\n            while(mp.size()>k)\\n            {\\n                if(--mp[s[j]]==0)\\n                {\\n                    mp.erase(s[j]);\\n                }\\n                j++;\\n            }\\n            }\\n            count+=i-j+1;\\n        }\\n        return count;\\n    }\\n    int countVowelSubstrings(string s)\\n    {\\n        return find(s,5)-find(s,4);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564221,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(char s)\\n    {\\n        if(s==\\'a\\'||s==\\'e\\'||s==\\'i\\'||s==\\'o\\'||s==\\'u\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int countVowelSubstrings(string s)\\n    {\\n        int n=s.size();\\n        int count=0;\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp.clear();\\n            for(int j=i;j<n&&check(s[j]);j++)\\n            {\\n                mp[s[j]]++;\\n                if(mp.size()==5)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(char s)\\n    {\\n        if(s==\\'a\\'||s==\\'e\\'||s==\\'i\\'||s==\\'o\\'||s==\\'u\\')\\n        {\\n            return true;\\n        }\\n        return false;\\n    }\\n    int countVowelSubstrings(string s)\\n    {\\n        int n=s.size();\\n        int count=0;\\n        unordered_map<char,int>mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp.clear();\\n            for(int j=i;j<n&&check(s[j]);j++)\\n            {\\n                mp[s[j]]++;\\n                if(mp.size()==5)\\n                {\\n                    count++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564135,
                "title": "c-0ms-100-sliding-window-commented",
                "content": "Runtime: 0 ms, faster than 100.00% of C++ online submissions for Count Vowel Substrings of a String.\\nMemory Usage: 6.3 MB, less than 33.33% of C++ online submissions for Count Vowel Substrings of a String.\\n**General idea:**\\n**1.** in table we will retain number of vowels, in variable **k** number of distinct vowels\\n**2.** prepear for search (all counters in table set into 0)\\n**3.** ignore not vowels\\n**4.** after ignoring not vowel letters we will in start of group vowels letters :\\n\\tfor search( **l*  - left side of group, **m** - middle, **r** - right)\\n\\ta. set **l** \\n\\tb. move through the group (and will calculate number of distinct vowels will be equal 5 - **stop**)\\n\\tc. set **m**\\n\\td. move through the group(and not calculate number of distinct vowels)\\n\\te. set **r**\\n**5**\\nif in our group **k** isnt equal 5 ignore this search and repeat from step **2**\\nif not: we have sliding window like this: \\n\\n![image](https://assets.leetcode.com/users/images/c2d21194-d6e6-46df-9b63-34f715429885_1636270175.745737.png)\\n\\nfor this window will do next steps :\\nmove **l** and count number of moves (will move as far as we will have number of distinct vowels = 5)\\n![image](https://assets.leetcode.com/users/images/e6b7d91f-8bb0-49ab-a15d-5f843acb4383_1636270764.5169227.png)\\n\\nfor this case will have temp answer : **count** * (r - m + 1)\\nwill move **m** while we wont have 5 distinct vowels\\n![image](https://assets.leetcode.com/users/images/ef62629b-c3bf-4362-9332-38a493067bc3_1636270914.4252667.png)\\n\\nwill repeat theese steps while **m**<=**r**\\n\\nrepeat from step **2**\\n```\\nclass Solution {\\npublic:\\n  int countVowelSubstrings(string word) {\\n    int l, r = 0, m, k, n = word.size(), ans = 0, table[128];\\n    unordered_set<char> st = {\\'a\\', \\'o\\', \\'u\\', \\'e\\', \\'i\\'};\\n    \\n    while(r < n){\\n      table[\\'a\\'] = table[\\'o\\'] = table[\\'u\\'] = table[\\'i\\'] = table[\\'e\\'] = 0;\\n      while(r < n && !st.count(word[r])) r++;                             //ignore not vowel\\n      k = 0, l = r - 1;\\n     \\n      while(r < n && st.count(word[r]))                                   //count contigious vowel\\n        if(++table[word[r++]] == 1) if(++k == 5) {m = r;break;}\\n      \\n      while(r < n && st.count(word[r])) r++;\\n     \\n      if(k == 5)\\n        while(m <= r){\\n          int count = 0;  \\n          \\n          while(true){\\n            count++, l++;\\n            if(--table[word[l]] == 0) {k--;  break;}\\n          }  \\n          \\n          ans += count*(r-m+1);\\n    \\n          while(m <= r && k != 5)                                  //count contigious vowel for total set\\n            if(++table[word[m++]] == 1) {k == 5;break;}\\n        }\\n      \\n    }\\n    \\n    return ans;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  int countVowelSubstrings(string word) {\\n    int l, r = 0, m, k, n = word.size(), ans = 0, table[128];\\n    unordered_set<char> st = {\\'a\\', \\'o\\', \\'u\\', \\'e\\', \\'i\\'};\\n    \\n    while(r < n){\\n      table[\\'a\\'] = table[\\'o\\'] = table[\\'u\\'] = table[\\'i\\'] = table[\\'e\\'] = 0;\\n      while(r < n && !st.count(word[r])) r++;                             //ignore not vowel\\n      k = 0, l = r - 1;\\n     \\n      while(r < n && st.count(word[r]))                                   //count contigious vowel\\n        if(++table[word[r++]] == 1) if(++k == 5) {m = r;break;}\\n      \\n      while(r < n && st.count(word[r])) r++;\\n     \\n      if(k == 5)\\n        while(m <= r){\\n          int count = 0;  \\n          \\n          while(true){\\n            count++, l++;\\n            if(--table[word[l]] == 0) {k--;  break;}\\n          }  \\n          \\n          ans += count*(r-m+1);\\n    \\n          while(m <= r && k != 5)                                  //count contigious vowel for total set\\n            if(++table[word[m++]] == 1) {k == 5;break;}\\n        }\\n      \\n    }\\n    \\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564080,
                "title": "go-easy-solution",
                "content": "```go\\nfunc countVowelSubstrings(word string) int {\\n    ans := 0\\n    for i:=0; i<len(word); i++ {\\n        check := make(map[byte]int)\\n        for j:=i; j<len(word); j++ {\\n            if strings.Contains(\"aeiou\", string(word[j])) {\\n                check[word[j]] += 1\\n            } else {\\n                break\\n            }\\n            if len(check) == 5 {\\n                ans += 1\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc countVowelSubstrings(word string) int {\\n    ans := 0\\n    for i:=0; i<len(word); i++ {\\n        check := make(map[byte]int)\\n        for j:=i; j<len(word); j++ {\\n            if strings.Contains(\"aeiou\", string(word[j])) {\\n                check[word[j]] += 1\\n            } else {\\n                break\\n            }\\n            if len(check) == 5 {\\n                ans += 1\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1564042,
                "title": "java-two-pointer-sliding-window-o-n",
                "content": "Use `i` and `j` and two pointers. When we analyze an index `j`, we first append all the valid substring ending with index `j - 1` (prev). Then we greedily remove characters at index `i` to calculate how many additional valid substrings can be achieved with character `j` as the end.  \\n\\nWhenever a consonant is met, reset everything.\\n```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        int result = 0;\\n        int prev = 0;\\n        int i = 0;\\n        Map<Character, Integer> count = new HashMap<>();\\n        int unique = 0;\\n        for (int j = 0; j < word.length(); j++) {\\n            char c = word.charAt(j);\\n            if (\"aeiou\".indexOf(c) == -1) {\\n                prev = 0;\\n                count.clear();\\n                unique = 0;\\n                i = j + 1;\\n                continue;\\n            }\\n            \\n            if (!count.containsKey(c)) {\\n                unique++;\\n            }\\n            count.put(c, count.getOrDefault(c, 0) + 1);\\n                        \\n            int current = prev;           \\n            \\n            while (unique == 5) {\\n                current++;\\n                char toRemove = word.charAt(i++);\\n                count.put(toRemove, count.get(toRemove) - 1);\\n                if (count.get(toRemove) == 0) {\\n                    unique--;\\n                    count.remove(toRemove);\\n                }\\n            }            \\n            prev = current;\\n            result += current;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        int result = 0;\\n        int prev = 0;\\n        int i = 0;\\n        Map<Character, Integer> count = new HashMap<>();\\n        int unique = 0;\\n        for (int j = 0; j < word.length(); j++) {\\n            char c = word.charAt(j);\\n            if (\"aeiou\".indexOf(c) == -1) {\\n                prev = 0;\\n                count.clear();\\n                unique = 0;\\n                i = j + 1;\\n                continue;\\n            }\\n            \\n            if (!count.containsKey(c)) {\\n                unique++;\\n            }\\n            count.put(c, count.getOrDefault(c, 0) + 1);\\n                        \\n            int current = prev;           \\n            \\n            while (unique == 5) {\\n                current++;\\n                char toRemove = word.charAt(i++);\\n                count.put(toRemove, count.get(toRemove) - 1);\\n                if (count.get(toRemove) == 0) {\\n                    unique--;\\n                    count.remove(toRemove);\\n                }\\n            }            \\n            prev = current;\\n            result += current;\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563967,
                "title": "java-easiest-solution-brute-force-solution",
                "content": "Took help from a friend to correct the mistakes from my code .\\nI hope it helps !\\n\\n\\n```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        HashMap<Character,Integer> vowel = new HashMap<>();\\n        vowel.put(\\'a\\',1);\\n        vowel.put(\\'e\\',1);\\n        vowel.put(\\'i\\',1);\\n        vowel.put(\\'o\\',1);\\n        vowel.put(\\'u\\',1);\\n        \\n        int count=0;\\n        int n=word.length();\\n        \\n        if(n<5) return 0;\\n        HashMap<Character,Integer> hmap=new HashMap<>();\\n        for(int i=0;i<n;i++){  \\n            for(int j=i;j<n;j++){\\n                hmap.put(word.charAt(j),1);\\n                if(hmap.equals(vowel)){\\n                    count++;\\n                }\\n            }\\n            hmap.clear();\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        HashMap<Character,Integer> vowel = new HashMap<>();\\n        vowel.put(\\'a\\',1);\\n        vowel.put(\\'e\\',1);\\n        vowel.put(\\'i\\',1);\\n        vowel.put(\\'o\\',1);\\n        vowel.put(\\'u\\',1);\\n        \\n        int count=0;\\n        int n=word.length();\\n        \\n        if(n<5) return 0;\\n        HashMap<Character,Integer> hmap=new HashMap<>();\\n        for(int i=0;i<n;i++){  \\n            for(int j=i;j<n;j++){\\n                hmap.put(word.charAt(j),1);\\n                if(hmap.equals(vowel)){\\n                    count++;\\n                }\\n            }\\n            hmap.clear();\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563915,
                "title": "brute-force-javascript",
                "content": "```\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nvar countVowelSubstrings = function(word) {\\n    word = word.split(\\'\\'); \\n    const set = new Set(); \\n    set.add(\\'a\\').add(\\'e\\').add(\\'i\\').add(\\'o\\').add(\\'u\\'); \\n    let res = 0; \\n    for(let i = 0; i < word.length; i++){\\n        let map = new Map(); \\n        for(let j = i; j < word.length && set.has(word[j]); j++){\\n            map.set(word[j], 1)\\n            if(map.size == 5) res++\\n        }\\n    }\\n    return res \\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nvar countVowelSubstrings = function(word) {\\n    word = word.split(\\'\\'); \\n    const set = new Set(); \\n    set.add(\\'a\\').add(\\'e\\').add(\\'i\\').add(\\'o\\').add(\\'u\\'); \\n    let res = 0; \\n    for(let i = 0; i < word.length; i++){\\n        let map = new Map(); \\n        for(let j = i; j < word.length && set.has(word[j]); j++){\\n            map.set(word[j], 1)\\n            if(map.size == 5) res++\\n        }\\n    }\\n    return res \\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1563867,
                "title": "python-sliding-window-o-n",
                "content": "```python\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        i = 0\\n        n = len(word)\\n        res = 0\\n        \\n        def count(s):\\n            if len(s) < 5:\\n                return 0\\n            left = 0\\n            right = 0\\n            n = len(s)\\n            counter = {}\\n            res = 0\\n            for right, c in enumerate(s):\\n                counter[c] = counter.get(c, 0) + 1\\n                while len(counter) == 5:\\n                    res += n - right\\n                    counter[s[left]] -= 1\\n                    if counter[s[left]] == 0:\\n                        del counter[s[left]]\\n                    left += 1\\n            return res\\n\\n        vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"}\\n        while i < n:\\n            j = i\\n            while i < n and word[i] in vowels:\\n                i += 1\\n            res += count(word[j: i])\\n            i += 1\\n        return res\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        i = 0\\n        n = len(word)\\n        res = 0\\n        \\n        def count(s):\\n            if len(s) < 5:\\n                return 0\\n            left = 0\\n            right = 0\\n            n = len(s)\\n            counter = {}\\n            res = 0\\n            for right, c in enumerate(s):\\n                counter[c] = counter.get(c, 0) + 1\\n                while len(counter) == 5:\\n                    res += n - right\\n                    counter[s[left]] -= 1\\n                    if counter[s[left]] == 0:\\n                        del counter[s[left]]\\n                    left += 1\\n            return res\\n\\n        vowels = {\"a\", \"e\", \"i\", \"o\", \"u\"}\\n        while i < n:\\n            j = i\\n            while i < n and word[i] in vowels:\\n                i += 1\\n            res += count(word[j: i])\\n            i += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1563740,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string s) \\n    {\\n        int res=0;\\n        for(int m=0; m<s.length(); m++)\\n        {\\n            int count = INT_MIN;\\n            int a=0,e=0,i=0,o=0,u=0;\\n            for(int n=m; n<s.length(); n++)\\n            {\\n                if(s[n] == \\'a\\')\\n                    a++;\\n                else if(s[n] == \\'e\\')\\n                    e++;\\n                else if(s[n] == \\'i\\')\\n                    i++;\\n                else if(s[n] == \\'o\\')\\n                    o++;\\n                else if(s[n] == \\'u\\')\\n                    u++;\\n                else\\n                    break;\\n                \\n                int temp = a+e+i+o+u;\\n                if(temp>count)\\n                    if(a>0 && e>0 && i>0 && o>0 && u>0)\\n                        res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string s) \\n    {\\n        int res=0;\\n        for(int m=0; m<s.length(); m++)\\n        {\\n            int count = INT_MIN;\\n            int a=0,e=0,i=0,o=0,u=0;\\n            for(int n=m; n<s.length(); n++)\\n            {\\n                if(s[n] == \\'a\\')\\n                    a++;\\n                else if(s[n] == \\'e\\')\\n                    e++;\\n                else if(s[n] == \\'i\\')\\n                    i++;\\n                else if(s[n] == \\'o\\')\\n                    o++;\\n                else if(s[n] == \\'u\\')\\n                    u++;\\n                else\\n                    break;\\n                \\n                int temp = a+e+i+o+u;\\n                if(temp>count)\\n                    if(a>0 && e>0 && i>0 && o>0 && u>0)\\n                        res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4078416,
                "title": "count-vowel-substrings-of-a-string-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1) -> set\\'s maximum size will be 5 as only 5 vowels are there\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    bool isVowel(char c)\\n    {\\n        if(c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\')\\n            return true;\\n        return false;\\n    }\\npublic:\\n    int countVowelSubstrings(string word) {\\n        int i, j, ans=0;\\n        unordered_set<char> s;\\n\\n        for(i=0 ; i<word.length() ; i++){\\n            if(isVowel(word[i])){\\n                for(j=i ; j<word.length() ; j++){\\n                    if(isVowel(word[j])){\\n                        s.insert(word[j]);\\n                        if(s.size()==5)\\n                            ans++;\\n                    }\\n                    else\\n                        break;\\n                }\\n            }\\n            s.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/4785653a-75d3-44c0-abf2-f531bfb87d6f_1695418997.537749.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    bool isVowel(char c)\\n    {\\n        if(c==\\'a\\' || c==\\'e\\' || c==\\'i\\' || c==\\'o\\' || c==\\'u\\')\\n            return true;\\n        return false;\\n    }\\npublic:\\n    int countVowelSubstrings(string word) {\\n        int i, j, ans=0;\\n        unordered_set<char> s;\\n\\n        for(i=0 ; i<word.length() ; i++){\\n            if(isVowel(word[i])){\\n                for(j=i ; j<word.length() ; j++){\\n                    if(isVowel(word[j])){\\n                        s.insert(word[j]);\\n                        if(s.size()==5)\\n                            ans++;\\n                    }\\n                    else\\n                        break;\\n                }\\n            }\\n            s.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4041266,
                "title": "hashset-based-solution-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        int vow = 0;\\n        int n = word.length();\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < n-4; i++) {\\n            set.clear();\\n            for(int j = i; j < n; j++) {\\n                char ch = word.charAt(j);\\n                if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') {\\n                    set.add(ch);\\n                    if(set.size() == 5)\\n                        vow++;\\n                }\\n                else break;\\n            }\\n        } return vow;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        int vow = 0;\\n        int n = word.length();\\n        Set<Character> set = new HashSet<>();\\n        for(int i = 0; i < n-4; i++) {\\n            set.clear();\\n            for(int j = i; j < n; j++) {\\n                char ch = word.charAt(j);\\n                if(ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\') {\\n                    set.add(ch);\\n                    if(set.size() == 5)\\n                        vow++;\\n                }\\n                else break;\\n            }\\n        } return vow;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4027370,
                "title": "easy-to-understand-python3-solution-2-pointer-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        vowels = set(\\'aeiou\\')\\n        count = 0\\n\\n        l = 0\\n        while l < len(word)-4:\\n            if word[l] in vowels:\\n                r = l\\n                res = set()\\n                while r < len(word):\\n                    if word[r] in vowels:\\n                        res.add(word[r])\\n                        \\n                        if len(res) == 5:\\n                            count += 1\\n                            break\\n                        \\n                        r += 1\\n                    else:\\n                        break\\n                while r+1 < len(word) and len(res) == 5 and word[r+1] in vowels:\\n                    count += 1\\n                    r += 1\\n            \\n            l += 1\\n        \\n        return count\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        vowels = set(\\'aeiou\\')\\n        count = 0\\n\\n        l = 0\\n        while l < len(word)-4:\\n            if word[l] in vowels:\\n                r = l\\n                res = set()\\n                while r < len(word):\\n                    if word[r] in vowels:\\n                        res.add(word[r])\\n                        \\n                        if len(res) == 5:\\n                            count += 1\\n                            break\\n                        \\n                        r += 1\\n                    else:\\n                        break\\n                while r+1 < len(word) and len(res) == 5 and word[r+1] in vowels:\\n                    count += 1\\n                    r += 1\\n            \\n            l += 1\\n        \\n        return count\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 4026960,
                "title": "solved-using-maps",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isFit(string s){\\n        int count = 0;\\n        int fault = 0;\\n        map<char, int> mp;\\n        for(auto it: s){\\n            mp[it]++;\\n        }\\n\\n        if(mp.size() == 5){\\n            for(auto it:mp){\\n                if(it.first == \\'a\\' || it.first == \\'e\\' || it.first == \\'i\\' || it.first == \\'o\\' || it.first == \\'u\\'){\\n                    count ++;\\n                }\\n            }\\n        }\\n        \\n        if(count == 5){\\n            return 1;\\n        }\\n\\n        return 0;\\n    }\\n\\n    int countVowelSubstrings(string word) {\\n        int ans = 0;\\n        for(int i=0; i<word.length(); i++){\\n            string sub = \"\";\\n            for(int j=i; j<word.length(); j++){\\n                sub += word[j];\\n                if(sub.size() > 4){\\n                    int output = isFit(sub);\\n                    ans += output;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isFit(string s){\\n        int count = 0;\\n        int fault = 0;\\n        map<char, int> mp;\\n        for(auto it: s){\\n            mp[it]++;\\n        }\\n\\n        if(mp.size() == 5){\\n            for(auto it:mp){\\n                if(it.first == \\'a\\' || it.first == \\'e\\' || it.first == \\'i\\' || it.first == \\'o\\' || it.first == \\'u\\'){\\n                    count ++;\\n                }\\n            }\\n        }\\n        \\n        if(count == 5){\\n            return 1;\\n        }\\n\\n        return 0;\\n    }\\n\\n    int countVowelSubstrings(string word) {\\n        int ans = 0;\\n        for(int i=0; i<word.length(); i++){\\n            string sub = \"\";\\n            for(int j=i; j<word.length(); j++){\\n                sub += word[j];\\n                if(sub.size() > 4){\\n                    int output = isFit(sub);\\n                    ans += output;\\n                }\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4022678,
                "title": "using-set-for-simplicity-and-optimizing-the-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        int res =0; // record the count of the Substring of Vowels\\n\\n        Set<Character> set = new HashSet<>();\\n        for(int i=0; i<word.length(); i++){\\n\\n            for(int j=i; j<word.length(); j++){\\n                char ch = word.charAt(j);\\n                if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\'){\\n                    set.add(ch);\\n                    if(set.size()==5) res++;\\n                } else{\\n                    break;\\n                }\\n            }\\n            set.clear();\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String",
                    "Hash Function"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        int res =0; // record the count of the Substring of Vowels\\n\\n        Set<Character> set = new HashSet<>();\\n        for(int i=0; i<word.length(); i++){\\n\\n            for(int j=i; j<word.length(); j++){\\n                char ch = word.charAt(j);\\n                if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\'){\\n                    set.add(ch);\\n                    if(set.size()==5) res++;\\n                } else{\\n                    break;\\n                }\\n            }\\n            set.clear();\\n        }\\n\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018021,
                "title": "swift-easy-to-understand-100-time-and-100-space",
                "content": "```\\nclass Solution {\\n    func countVowelSubstrings(_ word: String) -> Int {\\n        if word.count < 5 { return 0 }\\n        var count = 0\\n        var str = word\\n        \\n        for _ in 0..<word.count {\\n            var j = 0\\n            while j < str.count {\\n                let substring = String(str.prefix(j+1))\\n                if isContainsAllVowels(substring) {\\n                    print(substring)\\n                    count += 1 \\n                }\\n                j += 1\\n            }\\n            str.removeFirst()\\n        }\\n        \\n        return count\\n    }\\n    \\n    private func isContainsAllVowels(_ str: String) -> Bool {\\n        var arr = [0, 0, 0, 0, 0]     \\n        //         a, e, i, o, u\\n        \\n        for i in str {\\n            if i == \"a\" { arr[0] += 1 }\\n            else if i == \"e\" { arr[1] += 1 }\\n            else if i == \"i\" { arr[2] += 1 }\\n            else if i == \"o\" { arr[3] += 1 }\\n            else if i == \"u\" { arr[4] += 1 }\\n            else { return false }\\n        }\\n        \\n        return arr.filter{\\xA0$0 > 0 }.count == 5\\n    }\\n}\\n```\\n---\\n![image](https://assets.leetcode.com/users/images/a6e5d098-74f6-4f35-9488-97b7b908c37b_1694173257.1841657.png)\\n",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func countVowelSubstrings(_ word: String) -> Int {\\n        if word.count < 5 { return 0 }\\n        var count = 0\\n        var str = word\\n        \\n        for _ in 0..<word.count {\\n            var j = 0\\n            while j < str.count {\\n                let substring = String(str.prefix(j+1))\\n                if isContainsAllVowels(substring) {\\n                    print(substring)\\n                    count += 1 \\n                }\\n                j += 1\\n            }\\n            str.removeFirst()\\n        }\\n        \\n        return count\\n    }\\n    \\n    private func isContainsAllVowels(_ str: String) -> Bool {\\n        var arr = [0, 0, 0, 0, 0]     \\n        //         a, e, i, o, u\\n        \\n        for i in str {\\n            if i == \"a\" { arr[0] += 1 }\\n            else if i == \"e\" { arr[1] += 1 }\\n            else if i == \"i\" { arr[2] += 1 }\\n            else if i == \"o\" { arr[3] += 1 }\\n            else if i == \"u\" { arr[4] += 1 }\\n            else { return false }\\n        }\\n        \\n        return arr.filter{\\xA0$0 > 0 }.count == 5\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3982279,
                "title": "sliding-window-sets-easy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        vowels = \\'aeiou\\'\\n        output = []\\n        for i in range(len(word)):\\n            for j in range(i,len(word)):\\n                print(word[i:j+1])\\n                if set(vowels) == set(word[i:j+1]):\\n                    output.append(word[i:j+1])\\n        print(output)\\n        return len(output)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        vowels = \\'aeiou\\'\\n        output = []\\n        for i in range(len(word)):\\n            for j in range(i,len(word)):\\n                print(word[i:j+1])\\n                if set(vowels) == set(word[i:j+1]):\\n                    output.append(word[i:j+1])\\n        print(output)\\n        return len(output)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3945265,
                "title": "easy-to-understand-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n       HashSet<Character>set=new HashSet<>();\\n       int count=0;\\n       for(int i=0;i<word.length();i++){\\n           set.clear();\\n           for(int j=i;j<word.length();j++){\\n               char ch=word.charAt(j);\\n               if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\'){\\n                   set.add(ch);\\n                   if(set.size()==5)\\n                   \\n                      count++;\\n                   }\\n                   else\\n                       break;\\n                   \\n               }\\n           }\\n       \\n       return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n       HashSet<Character>set=new HashSet<>();\\n       int count=0;\\n       for(int i=0;i<word.length();i++){\\n           set.clear();\\n           for(int j=i;j<word.length();j++){\\n               char ch=word.charAt(j);\\n               if(ch==\\'a\\'||ch==\\'e\\'||ch==\\'i\\'||ch==\\'o\\'||ch==\\'u\\'){\\n                   set.add(ch);\\n                   if(set.size()==5)\\n                   \\n                      count++;\\n                   }\\n                   else\\n                       break;\\n                   \\n               }\\n           }\\n       \\n       return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3937381,
                "title": "easy-cpp-solution-using-unordered-map-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/a6791028-9997-48a5-bd40-931d4655e0f5_1692548232.7673275.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        unordered_map<char, int> mp;\\n        int ans = 0;\\n        for(int i=0; i < word.length(); i++){\\n            for(int j=i; j<word.length(); j++){\\n                if(word[j] == \\'a\\' || word[j] == \\'e\\' || word[j] == \\'i\\' || word[j] == \\'o\\' || word[j] == \\'u\\'){\\n                    mp[word[j]]++;\\n                    if(mp.size() == 5) ans++;\\n                }\\n                else break;\\n            }\\n            mp.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        unordered_map<char, int> mp;\\n        int ans = 0;\\n        for(int i=0; i < word.length(); i++){\\n            for(int j=i; j<word.length(); j++){\\n                if(word[j] == \\'a\\' || word[j] == \\'e\\' || word[j] == \\'i\\' || word[j] == \\'o\\' || word[j] == \\'u\\'){\\n                    mp[word[j]]++;\\n                    if(mp.size() == 5) ans++;\\n                }\\n                else break;\\n            }\\n            mp.clear();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3914016,
                "title": "masum-code-c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        int count=0;\\n        for(int i=0;i<word.size();i++)\\n        {\\n           set<char>s1={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n            set<char>s2;\\n            for(int j=i;j<word.size();j++)\\n            {\\n                if(s1.count(word[j])==0)\\n                \\n                    break;\\n                \\n                s2.insert(word[j]);\\n                if(s1==s2)\\n                \\n                    count++;\\n                \\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        int count=0;\\n        for(int i=0;i<word.size();i++)\\n        {\\n           set<char>s1={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'};\\n            set<char>s2;\\n            for(int j=i;j<word.size();j++)\\n            {\\n                if(s1.count(word[j])==0)\\n                \\n                    break;\\n                \\n                s2.insert(word[j]);\\n                if(s1==s2)\\n                \\n                    count++;\\n                \\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873384,
                "title": "not-optimised-one-line-solution-using-list-comprehension",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n\\n        d =  [word[i:j] for i in range(len(word)) for j in range(i+1,len(word)+1) if len(word[i:j])>=5 and \\'\\'.join(sorted(set(word[i:j])))==\\'\\'.join(sorted(\\'aeiou\\'))]\\n\\n        return len(d)\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n\\n        d =  [word[i:j] for i in range(len(word)) for j in range(i+1,len(word)+1) if len(word[i:j])>=5 and \\'\\'.join(sorted(set(word[i:j])))==\\'\\'.join(sorted(\\'aeiou\\'))]\\n\\n        return len(d)\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3839792,
                "title": "two-pointer-unordered-map-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        unordered_map<char,int> mp,mp2;\\n\\n        int i=0,j=0;\\n\\n        int ans=0;\\n        while(j<word.size())\\n        {\\n            if(word[j]==\\'a\\' || word[j]==\\'e\\' || word[j]==\\'i\\' || word[j]==\\'o\\' ||word[j]==\\'u\\')\\n            {\\n                mp[word[j]]++;\\n\\n                if(mp[\\'a\\']>0 && mp[\\'e\\']>0 && mp[\\'i\\']>0 && mp[\\'o\\']>0 && mp[\\'u\\']>0)\\n                {\\n                    mp2=mp;\\n                    ans++;\\n                    for(int k=i;k<=j;k++)\\n                    {\\n                        mp2[word[k]]--;\\n                        if(mp2[\\'a\\']>0 && mp2[\\'e\\']>0 && mp2[\\'i\\']>0 && mp2[\\'o\\']>0 && mp2[\\'u\\']>0)\\n                        {\\n                            ans++;\\n                        }\\n                        else\\n                        {\\n                            break;\\n                        }\\n                    }\\n                }\\n                j++;\\n            }\\n            else\\n            {\\n                mp.clear();\\n                i=j+1;\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Two Pointers",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        unordered_map<char,int> mp,mp2;\\n\\n        int i=0,j=0;\\n\\n        int ans=0;\\n        while(j<word.size())\\n        {\\n            if(word[j]==\\'a\\' || word[j]==\\'e\\' || word[j]==\\'i\\' || word[j]==\\'o\\' ||word[j]==\\'u\\')\\n            {\\n                mp[word[j]]++;\\n\\n                if(mp[\\'a\\']>0 && mp[\\'e\\']>0 && mp[\\'i\\']>0 && mp[\\'o\\']>0 && mp[\\'u\\']>0)\\n                {\\n                    mp2=mp;\\n                    ans++;\\n                    for(int k=i;k<=j;k++)\\n                    {\\n                        mp2[word[k]]--;\\n                        if(mp2[\\'a\\']>0 && mp2[\\'e\\']>0 && mp2[\\'i\\']>0 && mp2[\\'o\\']>0 && mp2[\\'u\\']>0)\\n                        {\\n                            ans++;\\n                        }\\n                        else\\n                        {\\n                            break;\\n                        }\\n                    }\\n                }\\n                j++;\\n            }\\n            else\\n            {\\n                mp.clear();\\n                i=j+1;\\n                j++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3833173,
                "title": "kotlin-solution-for-beginners",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    fun countVowelSubstrings(word: String): Int {\\n        if(word.length < 5) return 0\\n        var ans = 0\\n        for(i in word.indices){\\n            if(isVowel(word[i])){\\n                val map = HashSet<Char>()\\n                map.add(word[i])\\n                for(j in i+1..word.length-1){\\n                    if(isVowel(word[j]).not()) break \\n                    map.add(word[j])\\n                    if(map.size == 5) {\\n                        ++ans\\n                    }\\n                }\\n            }\\n        }\\n        return ans\\n    }\\n\\n    inline fun isVowel(ch: Char) = ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\'\\n}\\n\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun countVowelSubstrings(word: String): Int {\\n        if(word.length < 5) return 0\\n        var ans = 0\\n        for(i in word.indices){\\n            if(isVowel(word[i])){\\n                val map = HashSet<Char>()\\n                map.add(word[i])\\n                for(j in i+1..word.length-1){\\n                    if(isVowel(word[j]).not()) break \\n                    map.add(word[j])\\n                    if(map.size == 5) {\\n                        ++ans\\n                    }\\n                }\\n            }\\n        }\\n        return ans\\n    }\\n\\n    inline fun isVowel(ch: Char) = ch == \\'a\\' || ch == \\'e\\' || ch == \\'i\\' || ch == \\'o\\' || ch == \\'u\\'\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831920,
                "title": "can-someone-help-confirm-the-tc-for-my-code-counting-all-valid-substrings-using-hash-table",
                "content": "I wonder whether the TC for this code is O(n)\\nI am looping through the String and on hitting a String that has all 5 vowels, I am checking whether the inner subStrings have any valid ones\\n\\n# Code\\n```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n\\n        int result = 0;\\n\\n        if (word.length() < 5) return result;\\n\\n        int[] map = new int[26];\\n        int i = 0;\\n        int start = -1;\\n        while (i < word.length()) {\\n            char letter = word.charAt(i);\\n            if (letter == \\'a\\' || letter == \\'e\\' || letter == \\'i\\' || letter == \\'o\\' || letter == \\'u\\') {\\n                if (start == -1) start = i;\\n                int index = letter - \\'a\\';\\n                map[index]++;\\n                if (hasAllVowels(map)) {\\n                    result += countValidSubStrings(map, word, start, i);\\n                }\\n            } else {\\n                map = new int[26];\\n                start = -1;\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n\\n    private int countValidSubStrings(int[] map , String word, int left, int right) {\\n        int count = 0;\\n        int[] deleted = new int[26];\\n        while (right - left + 1 >= 5 && hasAllVowels(map)) {\\n            char letter = word.charAt(left);\\n            count++;\\n            deleted[letter-\\'a\\']++;\\n            map[letter - \\'a\\']--;\\n            if (map[letter - \\'a\\'] == 0) {\\n                break;\\n            }\\n            left++;\\n        }\\n\\n        for (int i = 0 ; i < 26 ; i++) {\\n            char ch = (char) (i + 97);\\n            int n = deleted[i];\\n            while (n > 0) {\\n                map[ch - \\'a\\']++;\\n                n--;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private boolean hasAllVowels(int[] map) {\\n        return map[\\'a\\' - 97] > 0 && map[\\'e\\' - 97] > 0 && map[\\'i\\' - 97] > 0 && map[\\'o\\'-97] > 0 && map[\\'u\\' - 97] > 0;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n\\n        int result = 0;\\n\\n        if (word.length() < 5) return result;\\n\\n        int[] map = new int[26];\\n        int i = 0;\\n        int start = -1;\\n        while (i < word.length()) {\\n            char letter = word.charAt(i);\\n            if (letter == \\'a\\' || letter == \\'e\\' || letter == \\'i\\' || letter == \\'o\\' || letter == \\'u\\') {\\n                if (start == -1) start = i;\\n                int index = letter - \\'a\\';\\n                map[index]++;\\n                if (hasAllVowels(map)) {\\n                    result += countValidSubStrings(map, word, start, i);\\n                }\\n            } else {\\n                map = new int[26];\\n                start = -1;\\n            }\\n            i++;\\n        }\\n        return result;\\n    }\\n\\n    private int countValidSubStrings(int[] map , String word, int left, int right) {\\n        int count = 0;\\n        int[] deleted = new int[26];\\n        while (right - left + 1 >= 5 && hasAllVowels(map)) {\\n            char letter = word.charAt(left);\\n            count++;\\n            deleted[letter-\\'a\\']++;\\n            map[letter - \\'a\\']--;\\n            if (map[letter - \\'a\\'] == 0) {\\n                break;\\n            }\\n            left++;\\n        }\\n\\n        for (int i = 0 ; i < 26 ; i++) {\\n            char ch = (char) (i + 97);\\n            int n = deleted[i];\\n            while (n > 0) {\\n                map[ch - \\'a\\']++;\\n                n--;\\n            }\\n        }\\n\\n        return count;\\n    }\\n\\n    private boolean hasAllVowels(int[] map) {\\n        return map[\\'a\\' - 97] > 0 && map[\\'e\\' - 97] > 0 && map[\\'i\\' - 97] > 0 && map[\\'o\\'-97] > 0 && map[\\'u\\' - 97] > 0;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3831406,
                "title": "count-vowel-substring-of-a-string-python-recursion-solution",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        ans = []\\n        def genSub(arr,start,end) :\\n            if end==len(arr) : return \\n            if start>end : genSub(arr,0,end+1)\\n            else :\\n                if len(arr[start:end+1])>=5 : \\n                    d = dict()\\n                    for i in list(arr[start:end+1]) :\\n                        if i in d : d[i]+=1\\n                        else : d[i]=1\\n                    ans.append(\\'\\'.join(sorted(list(d.keys()))))\\n                genSub(arr,start+1,end)\\n            return ans\\n        ans = genSub(word,0,0)\\n        return ans.count(\\'aeiou\\')\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        ans = []\\n        def genSub(arr,start,end) :\\n            if end==len(arr) : return \\n            if start>end : genSub(arr,0,end+1)\\n            else :\\n                if len(arr[start:end+1])>=5 : \\n                    d = dict()\\n                    for i in list(arr[start:end+1]) :\\n                        if i in d : d[i]+=1\\n                        else : d[i]=1\\n                    ans.append(\\'\\'.join(sorted(list(d.keys()))))\\n                genSub(arr,start+1,end)\\n            return ans\\n        ans = genSub(word,0,0)\\n        return ans.count(\\'aeiou\\')\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827668,
                "title": "vowel-substrings-js-count-vowels-91-18",
                "content": "```\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nvar countVowelSubstrings = function(word) {\\n    vowel = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n    count = 0\\n    arr = []\\n\\n    for (let i = 0; i < word.length; i++) {\\n        for (let j = i; j < word.length; j++) {\\n            if (vowel.indexOf(word[j]) >= 0) \\n                count += checkVowel(word.substring(i, j+1))\\n            else\\n                break\\n        }\\n    }\\n\\n    return count\\n\\n    function checkVowel(str) {\\n        if (str.length < vowel.length) return 0\\n        for (v of vowel) {\\n            if (str.indexOf(v) == -1) return 0\\n        }\\n        return 1\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} word\\n * @return {number}\\n */\\nvar countVowelSubstrings = function(word) {\\n    vowel = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n    count = 0\\n    arr = []\\n\\n    for (let i = 0; i < word.length; i++) {\\n        for (let j = i; j < word.length; j++) {\\n            if (vowel.indexOf(word[j]) >= 0) \\n                count += checkVowel(word.substring(i, j+1))\\n            else\\n                break\\n        }\\n    }\\n\\n    return count\\n\\n    function checkVowel(str) {\\n        if (str.length < vowel.length) return 0\\n        for (v of vowel) {\\n            if (str.indexOf(v) == -1) return 0\\n        }\\n        return 1\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3825640,
                "title": "using-exact-k-times-atmost-k-times-atmost-k-1-times",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    };\\n    int atMostK(string &st, int k) {\\n        int res = 0, s=0, n = st.size();\\n        unordered_map<char, int> mp;\\n        \\n        for(int e=0; e<n; e++) {\\n            if (!isVowel(st[e])) {\\n                s = e + 1;\\n                //Clear map as new substring will begin\\n                mp.clear();\\n                continue;\\n            }\\n            mp[st[e]]++;\\n            while(mp.size() > k){\\n                mp[st[s]]--;\\n                if(mp[st[s]] == 0) mp.erase(st[s]);\\n                s++;\\n            }\\n            res += e - s + 1;\\n        }\\n        return res;\\n    }\\n        \\n    int countVowelSubstrings(string word) {\\n        return atMostK(word, 5) - atMostK(word, 4);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char c) {\\n        return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n    };\\n    int atMostK(string &st, int k) {\\n        int res = 0, s=0, n = st.size();\\n        unordered_map<char, int> mp;\\n        \\n        for(int e=0; e<n; e++) {\\n            if (!isVowel(st[e])) {\\n                s = e + 1;\\n                //Clear map as new substring will begin\\n                mp.clear();\\n                continue;\\n            }\\n            mp[st[e]]++;\\n            while(mp.size() > k){\\n                mp[st[s]]--;\\n                if(mp[st[s]] == 0) mp.erase(st[s]);\\n                s++;\\n            }\\n            res += e - s + 1;\\n        }\\n        return res;\\n    }\\n        \\n    int countVowelSubstrings(string word) {\\n        return atMostK(word, 5) - atMostK(word, 4);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3787414,
                "title": "nice-and-elegant-solution-in-java-beats-100-rt-and-98-memory",
                "content": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        int allFive = 0;\\n        char[] lets = word.toCharArray();\\n        for (int i = 0; i < word.length(); i++) {\\n            if (lets[i] == \\'a\\' || lets[i] == \\'e\\' || lets[i] == \\'o\\' || lets[i] == \\'i\\' || lets[i] == \\'u\\') {\\n                int j = i + 1;\\n                while (j + 1 <= lets.length && (lets[j] == \\'a\\' || lets[j] == \\'e\\' || lets[j] == \\'o\\' || lets[j] == \\'i\\' || lets[j] == \\'u\\')) {\\n                    if (isAllFive(lets, i, j)) {\\n                        allFive++;\\n                    }\\n                    j++;\\n                }\\n            }\\n        }\\n        return allFive;        \\n    }\\n\\n    private static boolean isAllFive(char[] ch, int i, int j) {\\n        int[] lets = new int[\\'z\\' + 1];\\n        for (; i <= j ; i++) {\\n            lets[ch[i]]++;\\n        }\\n        return lets[\\'a\\'] > 0 && lets[\\'e\\'] > 0 && lets[\\'i\\'] > 0 && lets[\\'o\\'] > 0 && lets[\\'u\\'] > 0;\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n        int allFive = 0;\\n        char[] lets = word.toCharArray();\\n        for (int i = 0; i < word.length(); i++) {\\n            if (lets[i] == \\'a\\' || lets[i] == \\'e\\' || lets[i] == \\'o\\' || lets[i] == \\'i\\' || lets[i] == \\'u\\') {\\n                int j = i + 1;\\n                while (j + 1 <= lets.length && (lets[j] == \\'a\\' || lets[j] == \\'e\\' || lets[j] == \\'o\\' || lets[j] == \\'i\\' || lets[j] == \\'u\\')) {\\n                    if (isAllFive(lets, i, j)) {\\n                        allFive++;\\n                    }\\n                    j++;\\n                }\\n            }\\n        }\\n        return allFive;        \\n    }\\n\\n    private static boolean isAllFive(char[] ch, int i, int j) {\\n        int[] lets = new int[\\'z\\' + 1];\\n        for (; i <= j ; i++) {\\n            lets[ch[i]]++;\\n        }\\n        return lets[\\'a\\'] > 0 && lets[\\'e\\'] > 0 && lets[\\'i\\'] > 0 && lets[\\'o\\'] > 0 && lets[\\'u\\'] > 0;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777662,
                "title": "easy-c-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis approach uses two pointers, i and j, to keep track of the start and end of a sliding window that moves through the input string. The map m is used to keep track of the count of vowels in the current substring, and when all five vowels are present, the method increments the final answer for all valid substrings starting from index i.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        vector<char> vowel = {\\'a\\',\\'e\\',\\'i\\',\\'o\\', \\'u\\'} ;\\n        map<char, int> m;\\n        int i = 0, j =0, ans = 0;\\n        while(i <= j and j < word.size())\\n        {\\n            if(find(vowel.begin(), vowel.end(), word[j]) == vowel.end())\\n            {\\n                j++;\\n                i = j;\\n                m.clear();\\n                continue;\\n            }\\n            m[word[j]]++;\\n            if(m.size() >= 5 )\\n            {\\n                int k = i;\\n                map<char, int> del;\\n                while(m[word[k]] - del[word[k]] > 1 and (j - k + 1) > 5)\\n                {\\n                    del[word[k]]++;\\n                    k++;\\n                    ans++;\\n                }\\n                ans++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        vector<char> vowel = {\\'a\\',\\'e\\',\\'i\\',\\'o\\', \\'u\\'} ;\\n        map<char, int> m;\\n        int i = 0, j =0, ans = 0;\\n        while(i <= j and j < word.size())\\n        {\\n            if(find(vowel.begin(), vowel.end(), word[j]) == vowel.end())\\n            {\\n                j++;\\n                i = j;\\n                m.clear();\\n                continue;\\n            }\\n            m[word[j]]++;\\n            if(m.size() >= 5 )\\n            {\\n                int k = i;\\n                map<char, int> del;\\n                while(m[word[k]] - del[word[k]] > 1 and (j - k + 1) > 5)\\n                {\\n                    del[word[k]]++;\\n                    k++;\\n                    ans++;\\n                }\\n                ans++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3777661,
                "title": "easy-c-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis approach uses two pointers, i and j, to keep track of the start and end of a sliding window that moves through the input string. The map m is used to keep track of the count of vowels in the current substring, and when all five vowels are present, the method increments the final answer for all valid substrings starting from index i.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n\\n# Code\\n```\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        vector<char> vowel = {\\'a\\',\\'e\\',\\'i\\',\\'o\\', \\'u\\'} ;\\n        map<char, int> m;\\n        int i = 0, j =0, ans = 0;\\n        while(i <= j and j < word.size())\\n        {\\n            if(find(vowel.begin(), vowel.end(), word[j]) == vowel.end())\\n            {\\n                j++;\\n                i = j;\\n                m.clear();\\n                continue;\\n            }\\n            m[word[j]]++;\\n            if(m.size() >= 5 )\\n            {\\n                int k = i;\\n                map<char, int> del;\\n                while(m[word[k]] - del[word[k]] > 1 and (j - k + 1) > 5)\\n                {\\n                    del[word[k]]++;\\n                    k++;\\n                    ans++;\\n                }\\n                ans++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\n#include <algorithm>\\n\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        vector<char> vowel = {\\'a\\',\\'e\\',\\'i\\',\\'o\\', \\'u\\'} ;\\n        map<char, int> m;\\n        int i = 0, j =0, ans = 0;\\n        while(i <= j and j < word.size())\\n        {\\n            if(find(vowel.begin(), vowel.end(), word[j]) == vowel.end())\\n            {\\n                j++;\\n                i = j;\\n                m.clear();\\n                continue;\\n            }\\n            m[word[j]]++;\\n            if(m.size() >= 5 )\\n            {\\n                int k = i;\\n                map<char, int> del;\\n                while(m[word[k]] - del[word[k]] > 1 and (j - k + 1) > 5)\\n                {\\n                    del[word[k]]++;\\n                    k++;\\n                    ans++;\\n                }\\n                ans++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3769877,
                "title": "python-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\ndef check(s):\\n    l = [\\'a\\', \\'e\\' ,\\'i\\', \\'o\\', \\'u\\']\\n    \\n    s = set(s)\\n\\n    for i in s:\\n        if i not in l:\\n            return 0\\n\\n    if len(s) < 5:\\n        return 2\\n    else:\\n        return 1    \\n\\n\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        count = 0\\n        l = list(word)\\n        for i in range(0, len(word)-4):\\n            c = 5\\n            while c + i <= len(l):\\n                \\n                Flag = check(l[i:i+c])\\n\\n                if Flag == 1:\\n                    count += 1\\n                elif Flag == 0:\\n                    break    \\n                \\n                c += 1\\n               \\n\\n        return count        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef check(s):\\n    l = [\\'a\\', \\'e\\' ,\\'i\\', \\'o\\', \\'u\\']\\n    \\n    s = set(s)\\n\\n    for i in s:\\n        if i not in l:\\n            return 0\\n\\n    if len(s) < 5:\\n        return 2\\n    else:\\n        return 1    \\n\\n\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        count = 0\\n        l = list(word)\\n        for i in range(0, len(word)-4):\\n            c = 5\\n            while c + i <= len(l):\\n                \\n                Flag = check(l[i:i+c])\\n\\n                if Flag == 1:\\n                    count += 1\\n                elif Flag == 0:\\n                    break    \\n                \\n                c += 1\\n               \\n\\n        return count        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3735641,
                "title": "q-2062-count-vowel-substrings-of-a-string-implemeted-using-2-for-loops",
                "content": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char z){\\n        if(z==\\'a\\' || z==\\'o\\' || z==\\'i\\' || z==\\'e\\' || z==\\'u\\')\\n            return true;\\n        return false;\\n    }\\n    int countVowelSubstrings(string word) {\\n        unordered_map<char,int> store;\\n        int ans=0;\\n        for(int i=0;i<word.length();i++){\\n            store.clear();\\n            for(int j=i;j<word.length() ;j++){\\n                if(isVowel(word[j])==true){\\n                    store[word[j]]++;\\n                    if(store.size()==5)\\n                        ans++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isVowel(char z){\\n        if(z==\\'a\\' || z==\\'o\\' || z==\\'i\\' || z==\\'e\\' || z==\\'u\\')\\n            return true;\\n        return false;\\n    }\\n    int countVowelSubstrings(string word) {\\n        unordered_map<char,int> store;\\n        int ans=0;\\n        for(int i=0;i<word.length();i++){\\n            store.clear();\\n            for(int j=i;j<word.length() ;j++){\\n                if(isVowel(word[j])==true){\\n                    store[word[j]]++;\\n                    if(store.size()==5)\\n                        ans++;\\n                }\\n                else{\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3731707,
                "title": "go-golang-solution",
                "content": "```\\nfunc countVowelSubstrings(word string) int {\\n        var counter int\\n\\n        for i := 5; i <= len(word); i++ {\\n                for j := 0; j <= len(word)-i; j++ {\\n                        stVowels := map[byte]struct{}{\\'a\\': {}, \\'i\\': {}, \\'u\\': {}, \\'e\\': {}, \\'o\\': {}}\\n                        ndVowels := map[byte]struct{}{\\'a\\': {}, \\'i\\': {}, \\'u\\': {}, \\'e\\': {}, \\'o\\': {}}\\n                        subStr := string(word[j : j+i])\\n\\n                        isValid := true\\n                        for j := 0; j < len(subStr); j++ {\\n                                char := subStr[j]\\n                                if _, ok := stVowels[char]; !ok {\\n                                        isValid = false\\n                                        break\\n                                }\\n\\n                                delete(ndVowels, char)\\n                        }\\n\\n                        if isValid && len(ndVowels) == 0 {\\n                                counter++\\n                        }\\n                }\\n        }\\n                                                                                                                              return counter\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc countVowelSubstrings(word string) int {\\n        var counter int\\n\\n        for i := 5; i <= len(word); i++ {\\n                for j := 0; j <= len(word)-i; j++ {\\n                        stVowels := map[byte]struct{}{\\'a\\': {}, \\'i\\': {}, \\'u\\': {}, \\'e\\': {}, \\'o\\': {}}\\n                        ndVowels := map[byte]struct{}{\\'a\\': {}, \\'i\\': {}, \\'u\\': {}, \\'e\\': {}, \\'o\\': {}}\\n                        subStr := string(word[j : j+i])\\n\\n                        isValid := true\\n                        for j := 0; j < len(subStr); j++ {\\n                                char := subStr[j]\\n                                if _, ok := stVowels[char]; !ok {\\n                                        isValid = false\\n                                        break\\n                                }\\n\\n                                delete(ndVowels, char)\\n                        }\\n\\n                        if isValid && len(ndVowels) == 0 {\\n                                counter++\\n                        }\\n                }\\n        }\\n                                                                                                                              return counter\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3727127,
                "title": "easy-solution-double-set-method",
                "content": "# Method\\nDouble set method, one that contains the vowels and one that contains the vowels that haven\\'t been used yet.\\n\\nOnce all of the vowels have been used the set increments the total until a consanant or end of string.\\n\\nPlease suggest improvements!\\n\\n# Code\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        if len(word)<5:\\n            return 0\\n        tot = 0\\n        inc = 0\\n        s = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}\\n        e = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}\\n        for i in range(len(word)-4):\\n            if word[i] in s:\\n                inc = i\\n                while inc<len(word) and word[inc] in s:\\n                    if word[inc] in e:\\n                        e.remove(word[inc])\\n                    if len(e)==0:\\n                        tot +=1\\n                    inc +=1\\n                e = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}\\n\\n        return tot\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        if len(word)<5:\\n            return 0\\n        tot = 0\\n        inc = 0\\n        s = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}\\n        e = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}\\n        for i in range(len(word)-4):\\n            if word[i] in s:\\n                inc = i\\n                while inc<len(word) and word[inc] in s:\\n                    if word[inc] in e:\\n                        e.remove(word[inc])\\n                    if len(e)==0:\\n                        tot +=1\\n                    inc +=1\\n                e = {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}\\n\\n        return tot\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3703978,
                "title": "python-easy-solution-beats-100-space",
                "content": "# Complexity\\n- Time complexity: O(n2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        vowels = {\\'a\\': True, \\'e\\': True, \\'i\\': True, \\'o\\': True, \\'u\\': True}\\n        res = 0\\n        for i, c in enumerate(word):\\n            v_set = set()\\n            if vowels.get(c):\\n                v_set.add(c)\\n                for y in word[i+1:]:\\n                    if vowels.get(y):\\n                        v_set.add(y)\\n                    else:\\n                        break\\n                    \\n                    if len(v_set) == 5:\\n                        res += 1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        vowels = {\\'a\\': True, \\'e\\': True, \\'i\\': True, \\'o\\': True, \\'u\\': True}\\n        res = 0\\n        for i, c in enumerate(word):\\n            v_set = set()\\n            if vowels.get(c):\\n                v_set.add(c)\\n                for y in word[i+1:]:\\n                    if vowels.get(y):\\n                        v_set.add(y)\\n                    else:\\n                        break\\n                    \\n                    if len(v_set) == 5:\\n                        res += 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3663822,
                "title": "c-sets",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n     int countVowelSubstrings(string s) {\\n        int res = 0;\\n        for(int i=0; i<s.size(); i++){\\n            unordered_set<char> set;\\n            for(int j=i; j<s.size(); j++){\\n                if(!(s[j] == \\'a\\' || s[j]== \\'e\\' ||s[j] == \\'i\\' || s[j] == \\'o\\' ||s[j] == \\'u\\')) break;\\n                set.insert(s[j]);\\n                if(set.size() == 5) res++;\\n            }\\n        }\\n        return res;\\n    } \\n\\t\\n\\t\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n     int countVowelSubstrings(string s) {\\n        int res = 0;\\n        for(int i=0; i<s.size(); i++){\\n            unordered_set<char> set;\\n            for(int j=i; j<s.size(); j++){\\n                if(!(s[j] == \\'a\\' || s[j]== \\'e\\' ||s[j] == \\'i\\' || s[j] == \\'o\\' ||s[j] == \\'u\\')) break;\\n                set.insert(s[j]);\\n                if(set.size() == 5) res++;\\n            }\\n        }\\n        return res;\\n    } \\n\\t\\n\\t\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3656766,
                "title": "count-vowel-substrings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        sum1=0\\n        for i in range(len(word)):\\n            for j in range(i+1,len(word)+1):\\n                if set(word[i:j]).issubset(\\'aeiou\\') and len( set(word[i:j]))==5:\\n                    sum1+=1\\n        return sum1\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        sum1=0\\n        for i in range(len(word)):\\n            for j in range(i+1,len(word)+1):\\n                if set(word[i:j]).issubset(\\'aeiou\\') and len( set(word[i:j]))==5:\\n                    sum1+=1\\n        return sum1\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3654858,
                "title": "java-simple-solution-hashset-bruteforce",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    private static final Set<Character> VOWELS = Set.of(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\');\\n\\n    public int countVowelSubstrings(String word) {\\n        int vowelSubstringCount = 0;\\n        Set<Character> vowelSubstringHolder = new HashSet<>();\\n        for (int i = 0; i < word.length() - 4; i++) {\\n            vowelSubstringHolder.clear();\\n\\n            for (int j = i; j < word.length(); j++) {\\n                char currentChar = word.charAt(j);\\n                if (!VOWELS.contains(currentChar)) {\\n                    break;\\n                }\\n\\n                vowelSubstringHolder.add(currentChar);\\n                if (vowelSubstringHolder.size() == 5) {\\n                    vowelSubstringCount++;\\n                }\\n            }\\n        }\\n\\n        return vowelSubstringCount;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n\\n    private static final Set<Character> VOWELS = Set.of(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\');\\n\\n    public int countVowelSubstrings(String word) {\\n        int vowelSubstringCount = 0;\\n        Set<Character> vowelSubstringHolder = new HashSet<>();\\n        for (int i = 0; i < word.length() - 4; i++) {\\n            vowelSubstringHolder.clear();\\n\\n            for (int j = i; j < word.length(); j++) {\\n                char currentChar = word.charAt(j);\\n                if (!VOWELS.contains(currentChar)) {\\n                    break;\\n                }\\n\\n                vowelSubstringHolder.add(currentChar);\\n                if (vowelSubstringHolder.size() == 5) {\\n                    vowelSubstringCount++;\\n                }\\n            }\\n        }\\n\\n        return vowelSubstringCount;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3648172,
                "title": "great-and-simple-solution-with-explanation",
                "content": "# Intuition\\nWe need to use two pointers to slide window according to requirements.\\n\\n# Approach\\nCreate left and right pointers and initial count. After that start loop until right pointer gets to the end of word. \\n\\nWithin loop, create right V2 pointer (r2) so that it starts from the moment of right pointer and goes further to increase the valid substring if r2 is in set of vowels.\\n\\nIf valid substring is equal or greater than number of vowels and contains each vowel then increase count of valid substring!\\n\\nAfter that increase left pointer and right pointer as the current char is no longer under consideration\\n\\n# Complexity (comment if not right)\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    companion object {\\n        private val VOWELS = setOf(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')\\n    }\\n\\n    fun countVowelSubstrings(word: String): Int {\\n        var l = 0\\n        var r = 0\\n        var count = 0\\n        while (r < word.length) {\\n            var r2 = r\\n            while (r2 < word.length && word[r2] in VOWELS) {\\n                val substring = word.substring(r, r2+1)\\n                if (substring.length >= 5 && hasAllVowels(substring)) {\\n                    count++\\n                }\\n                r2++\\n            }\\n            l++\\n            r++\\n        }\\n        return count\\n    }\\n\\n    private fun hasAllVowels(substring: String) = VOWELS.all {\\n        substring.contains(it)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    companion object {\\n        private val VOWELS = setOf(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')\\n    }\\n\\n    fun countVowelSubstrings(word: String): Int {\\n        var l = 0\\n        var r = 0\\n        var count = 0\\n        while (r < word.length) {\\n            var r2 = r\\n            while (r2 < word.length && word[r2] in VOWELS) {\\n                val substring = word.substring(r, r2+1)\\n                if (substring.length >= 5 && hasAllVowels(substring)) {\\n                    count++\\n                }\\n                r2++\\n            }\\n            l++\\n            r++\\n        }\\n        return count\\n    }\\n\\n    private fun hasAllVowels(substring: String) = VOWELS.all {\\n        substring.contains(it)\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3642834,
                "title": "simple-python-solution",
                "content": "# Code\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        ret = 0\\n        vow = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n        for l in range(len(word)):\\n            r = l+1\\n            while r<=len(word) and word[r-1] in vow:\\n                if vow.issubset(set(word[l:r])):\\n                    ret+=1\\n                r+=1\\n        return ret\\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        ret = 0\\n        vow = {\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\'}\\n        for l in range(len(word)):\\n            r = l+1\\n            while r<=len(word) and word[r-1] in vow:\\n                if vow.issubset(set(word[l:r])):\\n                    ret+=1\\n                r+=1\\n        return ret\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3586597,
                "title": "bad-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n\\n        vowel = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n        totalval = 0\\n        filter_set = set()\\n        \\n        def cl(array, cnt, left, right):\\n            nonlocal totalval\\n            if (left,right) in filter_set:\\n                return\\n            filter_set.add((left, right))\\n\\n            if len(cnt) == 5:\\n                totalval += 1\\n            else:\\n                return\\n            \\n            l = cnt.copy()\\n            l[array[0]] -= 1\\n            if l[array[0]] ==0:\\n                del l[array[0]]\\n            cl(array[1:],l, left+1,right)\\n            \\n            r = cnt.copy()\\n            r[array[-1]] -= 1\\n            if r[array[-1]] ==0:\\n                del r[array[-1]]\\n            \\n            cl(array[:-1],r,left,right+1)\\n\\n        buffer = []\\n        counter = defaultdict(int)\\n        for i, ch in enumerate(word):\\n            if ch in vowel:\\n                counter[ch]+=1\\n                buffer.append(ch)\\n            else:\\n                cl(buffer, counter,0, 0)\\n                buffer = []\\n                counter.clear()\\n                filter_set.clear()\\n        \\n        if buffer:\\n            cl(buffer, counter,0 ,0)\\n        return totalval\\n\\n            \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n\\n        vowel = [\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']\\n        totalval = 0\\n        filter_set = set()\\n        \\n        def cl(array, cnt, left, right):\\n            nonlocal totalval\\n            if (left,right) in filter_set:\\n                return\\n            filter_set.add((left, right))\\n\\n            if len(cnt) == 5:\\n                totalval += 1\\n            else:\\n                return\\n            \\n            l = cnt.copy()\\n            l[array[0]] -= 1\\n            if l[array[0]] ==0:\\n                del l[array[0]]\\n            cl(array[1:],l, left+1,right)\\n            \\n            r = cnt.copy()\\n            r[array[-1]] -= 1\\n            if r[array[-1]] ==0:\\n                del r[array[-1]]\\n            \\n            cl(array[:-1],r,left,right+1)\\n\\n        buffer = []\\n        counter = defaultdict(int)\\n        for i, ch in enumerate(word):\\n            if ch in vowel:\\n                counter[ch]+=1\\n                buffer.append(ch)\\n            else:\\n                cl(buffer, counter,0, 0)\\n                buffer = []\\n                counter.clear()\\n                filter_set.clear()\\n        \\n        if buffer:\\n            cl(buffer, counter,0 ,0)\\n        return totalval\\n\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3582414,
                "title": "best-c-solution-without-using-hashmap-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        string s=\"aeiou\";\\n        int c=0;\\n        string str=\"\";\\n        for(int i=0;i<word.size();i++)\\n        {\\n            for(int j=i;j<word.size();j++)\\n            {\\n                if(word[j]==\\'a\\' ||word[j]==\\'e\\' ||word[j]==\\'i\\' ||word[j]==\\'o\\' ||word[j]==\\'u\\') \\n                {\\n                    if(str.find(word[j])== string :: npos)\\n                    {\\n                      str=str+word[j];\\n                      if(str.size()>=5)\\n                    {\\n                        c++;\\n                    }\\n                    }\\n                    else\\n                    {\\n                        if(str.size()>=5)\\n                        {\\n                             str=str+word[j];\\n                             c++;\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    str.clear();\\n                    break;\\n                }\\n            }\\n            \\n            \\n                str.clear();\\n            \\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        string s=\"aeiou\";\\n        int c=0;\\n        string str=\"\";\\n        for(int i=0;i<word.size();i++)\\n        {\\n            for(int j=i;j<word.size();j++)\\n            {\\n                if(word[j]==\\'a\\' ||word[j]==\\'e\\' ||word[j]==\\'i\\' ||word[j]==\\'o\\' ||word[j]==\\'u\\') \\n                {\\n                    if(str.find(word[j])== string :: npos)\\n                    {\\n                      str=str+word[j];\\n                      if(str.size()>=5)\\n                    {\\n                        c++;\\n                    }\\n                    }\\n                    else\\n                    {\\n                        if(str.size()>=5)\\n                        {\\n                             str=str+word[j];\\n                             c++;\\n                        }\\n                    }\\n                }\\n                else\\n                {\\n                    str.clear();\\n                    break;\\n                }\\n            }\\n            \\n            \\n                str.clear();\\n            \\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580857,
                "title": "c-100-t-c-and-95-s-c-unique-approach",
                "content": "# Intuition\\nit is obvious from the problem that i have to use map in problem for taking care of all vowels in a window \\n\\n# Approach\\n1.I stored only the vowels in the map ,and when i am encountering a consonents i am making my map clear and starting my index i from next to it (from where i will start window)\\n2.now i increased the j till my map size reaches to 5 ,means all vowels are in my current window \\n3.when window size reaches to 5 >>> see this example cabooooeiiiu atba  now from above explanatation my i will be on  index 2 in given string and  j will be on u ,now the total possible strings will be from initail o to final o (this size) ,that i have taken in formula \\n\\n\\nfor any doubt comment \\n\\n# Complexity\\n- Time complexity:\\no(n) because i am traversing through the string \\n\\n- Space complexity:\\nmap is used so o(n) \\n# Code\\n```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        unordered_map<int,int> m;\\n        int j=0,i=0;\\n        int ct=0;\\n        while(j<word.length())\\n        {\\n            if(word[j]==\\'a\\'||word[j]==\\'e\\'||word[j]==\\'i\\'||word[j]==\\'o\\'||word[j]==\\'u\\')\\n            {\\n                m[word[j]]=j ;\\n            }\\n            else\\n            {\\n                m.clear() ;\\n                i=j+1  ;\\n            }\\n            if(m.size()<5)\\n            {\\n                j++ ;\\n            }\\n            else \\n            {\\n             ct = ct + min(m[\\'a\\'], min(m[\\'e\\'], min(m[\\'i\\'], min(m[\\'o\\'], m[\\'u\\'])))) -i + 1;\\n             j++ ;\\n;\\n            }\\n        }\\n        return ct ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int countVowelSubstrings(string word) {\\n        unordered_map<int,int> m;\\n        int j=0,i=0;\\n        int ct=0;\\n        while(j<word.length())\\n        {\\n            if(word[j]==\\'a\\'||word[j]==\\'e\\'||word[j]==\\'i\\'||word[j]==\\'o\\'||word[j]==\\'u\\')\\n            {\\n                m[word[j]]=j ;\\n            }\\n            else\\n            {\\n                m.clear() ;\\n                i=j+1  ;\\n            }\\n            if(m.size()<5)\\n            {\\n                j++ ;\\n            }\\n            else \\n            {\\n             ct = ct + min(m[\\'a\\'], min(m[\\'e\\'], min(m[\\'i\\'], min(m[\\'o\\'], m[\\'u\\'])))) -i + 1;\\n             j++ ;\\n;\\n            }\\n        }\\n        return ct ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3525146,
                "title": "optimized-sliding-window-with-comments-and-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDecided to do this one to a deep level since a lot of comments were saying it is not a medium and I honestly agree. Still, found a few sliding window improvements that make it run very nicely speed-wise. \\n\\nCouple thoughts before we start \\n- If we have a word less than length 5 -> not possible return 0 \\n- If we do not have all five vowels -> return 0 \\n- If we have run out of vowels we can use in string, return 0 \\n\\nWe can use these few ideas to set up our sliding window and early stopping conditions as described in approach \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSkipping past the trivial case of less than 5 letters, we turn to getting the frequency of the characters in word to start \\n\\nNext, we set up a vowels array, a vowel string, and a second vowel array of 0\\'s that we\\'ll need later. \\n\\nEnumerate over our vowel string, and if we have it in frequency, mark one of vowels array at that index to 1. \\n\\nSum up that array after, and if not 5, return 0 \\nOtherwise, move the vowel frequencies into their own dictionary; we could jettison the memory for frequency of the other now if we wanted. \\n\\nSet up a variable for the nubmer of vowel substrings, a local count of substrings in the window, a beginning index for the window and the vowels in the current window. \\n\\nWe\\'ll start at word index, w_i, at 0, and then go to length of the word \\n- As we loop get char at this index \\n    - if char is not a vowel \\n        - reset local count, find next index that is a vowel and move beginning index there \\n        - loop over your vowel window and reduce your vowel frequency appropriately \\n        - reset our vowel window (a dict of zip of vowel string and 5 0\\'s in an array) \\n        - sum up the vowel frequency values and if 0, break -> early end\\n        - Otherwise, continue \\n    - otherwise\\n        - increment vowel window at char by 1 \\n        - while minimum vowel of window values is at least 1\\n            - move end up, decrementing vowel window at word at beginning index by 1\\n            - do same for vowel frequency \\n            - increment local count \\n    - increment number vowel substrings by local count \\n    - increment w_i by 1 \\n\\nWhen done, return the number vowel substrings \\n\\n# Complexity\\n- Time complexity: O(N) \\n    - N characters in word, need to travel over it twice for frequency and enumeration. Can quit early though, which gives significant speed ups.  \\n\\n\\n- Space complexity: O(V)\\n    - If properly implemented with memory dealloc, could be done with memory only for the frequency of the vowels in the word.  \\n\\n# Code\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int :\\n        # cannot have 5 vowels without 5 characters \\n        if len(word) < 5 : \\n            return 0 \\n        # get frequency of each of the values \\n        frequency = collections.Counter(word)\\n        # check over valuations \\n        vowels = [0] * 5\\n        # use now and later \\n        vowel_string = \"aeiou\"\\n        vowel_array = [0] * 5 \\n\\n        # if present, set to 1, otherwise ignore \\n        for index, vowel in enumerate(vowel_string) : \\n            if vowel in frequency : \\n                vowels[index] = 1 \\n        \\n        # if not five, no good! \\n        if sum(vowels) != 5 : \\n            return 0 \\n\\n        # set in the vowels over the whole string \\n        vowel_frequency = dict()\\n        for vowel in vowel_string : \\n            vowel_frequency[vowel] = frequency[vowel]\\n        \\n        # now we have eliminated base cases \\n        # we turn to solving the problem as it stands \\n        # we seek the number of vowel substrings \\n        number_vowel_substrings = 0 \\n        # get the local count of substring windows of vowels \\n        local_count = 0 \\n        # track beginning index of window \\n        beginning_index = 0 \\n        # set up a vowel window for aeiou -> 0 to start \\n        vowel_window = dict(zip(vowel_string, vowel_array))\\n        w_i = 0 \\n        # for index, char in enumerate word \\n        while w_i < len(word) :\\n            char = word[w_i] \\n            # if char not a vowel \\n            if char not in vowel_string : \\n                # reset local count, beginning index, vowel_frequency, vowel_window \\n                local_count = 0 \\n                while w_i < len(word) and word[w_i] not in vowel_string : \\n                    w_i += 1 \\n                beginning_index = w_i \\n                # loop over and reduce \\n                for vowel in vowel_window : \\n                    vowel_frequency[vowel] -= vowel_window[vowel]\\n                # reset window \\n                vowel_window = dict(zip(vowel_string, vowel_array))\\n                if sum(vowel_frequency.values()) == 0 : \\n                    break \\n                continue\\n            else : \\n                # increment vowel window\\'s count \\n                vowel_window[char] += 1 \\n                # then, while the min of these is not 0 for any of them \\n                while min(vowel_window.values()) : \\n                    # move the vowel window forward, and decrement the appropriate frequency \\n                    vowel_window[word[beginning_index]] -= 1 \\n                    vowel_frequency[word[beginning_index]] -= 1 \\n                    # move beginning index forward and increment count \\n                    beginning_index += 1 \\n                    local_count += 1 \\n            # increment number of vowel substrings \\n            number_vowel_substrings += local_count \\n            w_i += 1 \\n        # return number vowel substrings \\n        return number_vowel_substrings\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int :\\n        # cannot have 5 vowels without 5 characters \\n        if len(word) < 5 : \\n            return 0 \\n        # get frequency of each of the values \\n        frequency = collections.Counter(word)\\n        # check over valuations \\n        vowels = [0] * 5\\n        # use now and later \\n        vowel_string = \"aeiou\"\\n        vowel_array = [0] * 5 \\n\\n        # if present, set to 1, otherwise ignore \\n        for index, vowel in enumerate(vowel_string) : \\n            if vowel in frequency : \\n                vowels[index] = 1 \\n        \\n        # if not five, no good! \\n        if sum(vowels) != 5 : \\n            return 0 \\n\\n        # set in the vowels over the whole string \\n        vowel_frequency = dict()\\n        for vowel in vowel_string : \\n            vowel_frequency[vowel] = frequency[vowel]\\n        \\n        # now we have eliminated base cases \\n        # we turn to solving the problem as it stands \\n        # we seek the number of vowel substrings \\n        number_vowel_substrings = 0 \\n        # get the local count of substring windows of vowels \\n        local_count = 0 \\n        # track beginning index of window \\n        beginning_index = 0 \\n        # set up a vowel window for aeiou -> 0 to start \\n        vowel_window = dict(zip(vowel_string, vowel_array))\\n        w_i = 0 \\n        # for index, char in enumerate word \\n        while w_i < len(word) :\\n            char = word[w_i] \\n            # if char not a vowel \\n            if char not in vowel_string : \\n                # reset local count, beginning index, vowel_frequency, vowel_window \\n                local_count = 0 \\n                while w_i < len(word) and word[w_i] not in vowel_string : \\n                    w_i += 1 \\n                beginning_index = w_i \\n                # loop over and reduce \\n                for vowel in vowel_window : \\n                    vowel_frequency[vowel] -= vowel_window[vowel]\\n                # reset window \\n                vowel_window = dict(zip(vowel_string, vowel_array))\\n                if sum(vowel_frequency.values()) == 0 : \\n                    break \\n                continue\\n            else : \\n                # increment vowel window\\'s count \\n                vowel_window[char] += 1 \\n                # then, while the min of these is not 0 for any of them \\n                while min(vowel_window.values()) : \\n                    # move the vowel window forward, and decrement the appropriate frequency \\n                    vowel_window[word[beginning_index]] -= 1 \\n                    vowel_frequency[word[beginning_index]] -= 1 \\n                    # move beginning index forward and increment count \\n                    beginning_index += 1 \\n                    local_count += 1 \\n            # increment number of vowel substrings \\n            number_vowel_substrings += local_count \\n            w_i += 1 \\n        # return number vowel substrings \\n        return number_vowel_substrings\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3516338,
                "title": "easy",
                "content": "# Code\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        ct=0\\n        for i in range(len(word)):\\n            if word[i] not in {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}:\\n                continue\\n            else:\\n                s=\"\"\\n                while i<len(word):\\n                    s+=word[i]\\n                    if len(set(s))==5 and set(s)=={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'} :\\n                        ct+=1\\n                    i+=1\\n        return ct\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        ct=0\\n        for i in range(len(word)):\\n            if word[i] not in {\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'}:\\n                continue\\n            else:\\n                s=\"\"\\n                while i<len(word):\\n                    s+=word[i]\\n                    if len(set(s))==5 and set(s)=={\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\'} :\\n                        ct+=1\\n                    i+=1\\n        return ct\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3508399,
                "title": "kotlin-sliding-window-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    fun countVowelSubstrings(word: String): Int {\\n        var result = 0\\n        var left = -1\\n        var mid = -1\\n\\n        val vowel = arrayOf(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\').toSet()\\n        var hist = HashMap<Char, Int>()\\n\\n        for (right in 0 until word.length) {\\n            val ch = word[right]\\n\\n            if (vowel.contains(ch)) {\\n                hist.put(ch, hist.getOrDefault(ch, 0) + 1)\\n                if (left == -1) { \\n                    left = right\\n                    mid = right \\n                }\\n\\n                while (mid < right && hist.getOrDefault(word[mid], 0) > 1) {\\n                    hist.put(word[mid], hist.getOrDefault(word[mid++], 1) - 1)\\n                }\\n\\n                if (hist.keys.size == 5) {\\n                    result += mid - left + 1\\n                }\\n            } else {\\n                hist = HashMap<Char, Int>()\\n                left = -1\\n                mid = -1\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun countVowelSubstrings(word: String): Int {\\n        var result = 0\\n        var left = -1\\n        var mid = -1\\n\\n        val vowel = arrayOf(\\'a\\',\\'e\\',\\'i\\',\\'o\\',\\'u\\').toSet()\\n        var hist = HashMap<Char, Int>()\\n\\n        for (right in 0 until word.length) {\\n            val ch = word[right]\\n\\n            if (vowel.contains(ch)) {\\n                hist.put(ch, hist.getOrDefault(ch, 0) + 1)\\n                if (left == -1) { \\n                    left = right\\n                    mid = right \\n                }\\n\\n                while (mid < right && hist.getOrDefault(word[mid], 0) > 1) {\\n                    hist.put(word[mid], hist.getOrDefault(word[mid++], 1) - 1)\\n                }\\n\\n                if (hist.keys.size == 5) {\\n                    result += mid - left + 1\\n                }\\n            } else {\\n                hist = HashMap<Char, Int>()\\n                left = -1\\n                mid = -1\\n            }\\n        }\\n\\n        return result\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496986,
                "title": "c-solution-beginner-friendly",
                "content": "approach ->\\nfirst find the string which have all vowels only , and if the it has all the vowels , ie m.size()==5, the count the number of strings which have all the string with all the vowels by using a sliding window\\n\\nfeel free to ask doubts below !\\n```\\nclass Solution {\\npublic:\\nbool check(char x)\\n{\\n    if(x==\\'a\\' or x==\\'e\\' or x==\\'i\\' or x==\\'o\\' or x==\\'u\\') return 1;\\n    return 0;\\n}\\nint help(string s)\\n{\\n    cout<<s<<\" \"<<endl;\\n    unordered_map<int , int>m;\\n    int j=0;\\n    int count=0;\\n    for(int i=0 ; i<s.length() ; i++)\\n    {\\n        m[s[i]]++;\\n        while(m.size()==5)\\n        {\\n            count++;\\n            m[s[j]]--;\\n            if(m[s[j]]==0)\\n            {\\n                // cout<<\"now erasing :\"<<s[j]<<\" size : \"<<m.size()<<endl;\\n                m.erase(s[j]);\\n            }\\n            j++;\\n        }   \\n    }\\n    // cout<<count<<\" \";\\n    return count;\\n}\\n    int countVowelSubstrings(string s) {\\nint n=s.length();\\nint i=0;\\nint start=0;\\nint ans=0;\\nstring temp=\"\";\\nunordered_map<int , int>m;\\nwhile(i<n)\\n{\\n    if(check(s[i])==false)\\n    {\\n        m.clear();\\n        temp=\"\";\\n        i++;\\n    }\\n    else \\n    {\\n        m[s[i]]++;\\n        temp+=s[i];\\n        if(m.size()==5)\\n        {\\n            ans+=help(temp);\\n            // cout<<temp<<endl;\\n        }\\n        i++;\\n    }\\n}\\n        return ans;\\n    }\\n};\\n\\n````",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nbool check(char x)\\n{\\n    if(x==\\'a\\' or x==\\'e\\' or x==\\'i\\' or x==\\'o\\' or x==\\'u\\') return 1;\\n    return 0;\\n}\\nint help(string s)\\n{\\n    cout<<s<<\" \"<<endl;\\n    unordered_map<int , int>m;\\n    int j=0;\\n    int count=0;\\n    for(int i=0 ; i<s.length() ; i++)\\n    {\\n        m[s[i]]++;\\n        while(m.size()==5)\\n        {\\n            count++;\\n            m[s[j]]--;\\n            if(m[s[j]]==0)\\n            {\\n                // cout<<\"now erasing :\"<<s[j]<<\" size : \"<<m.size()<<endl;\\n                m.erase(s[j]);\\n            }\\n            j++;\\n        }   \\n    }\\n    // cout<<count<<\" \";\\n    return count;\\n}\\n    int countVowelSubstrings(string s) {\\nint n=s.length();\\nint i=0;\\nint start=0;\\nint ans=0;\\nstring temp=\"\";\\nunordered_map<int , int>m;\\nwhile(i<n)\\n{\\n    if(check(s[i])==false)\\n    {\\n        m.clear();\\n        temp=\"\";\\n        i++;\\n    }\\n    else \\n    {\\n        m[s[i]]++;\\n        temp+=s[i];\\n        if(m.size()==5)\\n        {\\n            ans+=help(temp);\\n            // cout<<temp<<endl;\\n        }\\n        i++;\\n    }\\n}\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3491556,
                "title": "multiple-approach-go",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n// Apporach #1 Start with\\nfunc countVowelSubstrings(word string) int {\\n\\tallVowel := map[rune]int{\\n\\t\\t\\'a\\': 1, \\'e\\': 2, \\'i\\': 3, \\'o\\': 4, \\'u\\': 5,\\n\\t}\\n\\tvs := \"\"\\n\\tcnt := 0\\n\\tfor _, c := range word {\\n\\t\\tif _, ok := allVowel[c]; ok {\\n\\t\\t\\tvs = fmt.Sprintf(\"%s%s\", vs, string(c))\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif len(vs) >= 5 {\\n\\t\\t\\tcnt += substrigsContainsAll(vs)\\n\\t\\t}\\n\\t\\tvs = \"\"\\n\\t}\\n\\tif len(vs) >= 5 {\\n\\t\\tcnt += substrigsContainsAll(vs)\\n\\t}\\n\\treturn cnt\\n}\\n\\nfunc substrigsContainsAll(s string) int {\\n\\tcnt := 0\\n\\tfor i := 0; i <= len(s)-5; i++ {\\n\\t\\tfor j := len(s); j-i >= 5; j-- {\\n\\t\\t\\t// fmt.Printf(\"%d == %d\", i, j)\\n\\t\\t\\tif containsAllVowels(s[i:j]) {\\n\\t\\t\\t\\tcnt++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn cnt\\n}\\n\\nfunc containsAllVowels(s string) bool {\\n\\tfmt.Printf(\"%s \\\\n\", s)\\n\\tdict := make(map[rune]int)\\n\\tfor _, c := range s {\\n\\t\\tdict[c]++\\n\\t}\\n\\treturn len(dict) >= 5\\n}\\n\\n\\n// approach #2 Optimize Version\\n\\nfunc countVowelSubstrings(word string) int {\\n\\tallVowel := map[byte]int{\\n\\t\\t\\'a\\': 1, \\'e\\': 2, \\'i\\': 3, \\'o\\': 4, \\'u\\': 5,\\n\\t}\\n\\n\\tisVwl := func(a byte) bool {\\n\\t\\tif _, ok := allVowel[a]; ok {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\treturn false\\n\\t}\\n\\tcnt := 0\\n\\tfor idx, _ := range word {\\n\\t\\tdict := make(map[byte]int)\\n\\t\\tfor i := idx; i < len(word) && isVwl(word[i]); i++ {\\n\\t\\t\\tdict[word[i]]++\\n\\t\\t\\tif len(dict) == 5 {\\n\\t\\t\\t\\tcnt++\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\treturn cnt\\n\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\n// Apporach #1 Start with\\nfunc countVowelSubstrings(word string) int {\\n\\tallVowel := map[rune]int{\\n\\t\\t\\'a\\': 1, \\'e\\': 2, \\'i\\': 3, \\'o\\': 4, \\'u\\': 5,\\n\\t}\\n\\tvs := \"\"\\n\\tcnt := 0\\n\\tfor _, c := range word {\\n\\t\\tif _, ok := allVowel[c]; ok {\\n\\t\\t\\tvs = fmt.Sprintf(\"%s%s\", vs, string(c))\\n\\t\\t\\tcontinue\\n\\t\\t}\\n\\t\\tif len(vs) >= 5 {\\n\\t\\t\\tcnt += substrigsContainsAll(vs)\\n\\t\\t}\\n\\t\\tvs = \"\"\\n\\t}\\n\\tif len(vs) >= 5 {\\n\\t\\tcnt += substrigsContainsAll(vs)\\n\\t}\\n\\treturn cnt\\n}\\n\\nfunc substrigsContainsAll(s string) int {\\n\\tcnt := 0\\n\\tfor i := 0; i <= len(s)-5; i++ {\\n\\t\\tfor j := len(s); j-i >= 5; j-- {\\n\\t\\t\\t// fmt.Printf(\"%d == %d\", i, j)\\n\\t\\t\\tif containsAllVowels(s[i:j]) {\\n\\t\\t\\t\\tcnt++\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn cnt\\n}\\n\\nfunc containsAllVowels(s string) bool {\\n\\tfmt.Printf(\"%s \\\\n\", s)\\n\\tdict := make(map[rune]int)\\n\\tfor _, c := range s {\\n\\t\\tdict[c]++\\n\\t}\\n\\treturn len(dict) >= 5\\n}\\n\\n\\n// approach #2 Optimize Version\\n\\nfunc countVowelSubstrings(word string) int {\\n\\tallVowel := map[byte]int{\\n\\t\\t\\'a\\': 1, \\'e\\': 2, \\'i\\': 3, \\'o\\': 4, \\'u\\': 5,\\n\\t}\\n\\n\\tisVwl := func(a byte) bool {\\n\\t\\tif _, ok := allVowel[a]; ok {\\n\\t\\t\\treturn true\\n\\t\\t}\\n\\t\\treturn false\\n\\t}\\n\\tcnt := 0\\n\\tfor idx, _ := range word {\\n\\t\\tdict := make(map[byte]int)\\n\\t\\tfor i := idx; i < len(word) && isVwl(word[i]); i++ {\\n\\t\\t\\tdict[word[i]]++\\n\\t\\t\\tif len(dict) == 5 {\\n\\t\\t\\t\\tcnt++\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t}\\n\\treturn cnt\\n\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3484571,
                "title": "python3-sliding-window",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        \\n        \\n        \\n        left=ans=0\\n        d=Counter()\\n        vowels=\"aeiou\"                                                     \\n                                                                            \\n        \\n        for right,ch in enumerate(word):\\n            \\n            d[ch]+=1                                                       \\n            if ch not in vowels:\\n                d=Counter()\\n                left=right+1\\n\\n            if len(d)==5:\\n                new_d=dict(d)\\n                new_l=left\\n                while len(new_d)==5:\\n                    ans+=1\\n                    new_d[word[new_l]]-=1\\n                    if new_d[word[new_l]]==0:\\n                        new_d.pop(word[new_l])\\n                    new_l+=1\\n            \\n            \\n            return ans \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        \\n        \\n        \\n        left=ans=0\\n        d=Counter()\\n        vowels=\"aeiou\"                                                     \\n                                                                            \\n        \\n        for right,ch in enumerate(word):\\n            \\n            d[ch]+=1                                                       \\n            if ch not in vowels:\\n                d=Counter()\\n                left=right+1\\n\\n            if len(d)==5:\\n                new_d=dict(d)\\n                new_l=left\\n                while len(new_d)==5:\\n                    ans+=1\\n                    new_d[word[new_l]]-=1\\n                    if new_d[word[new_l]]==0:\\n                        new_d.pop(word[new_l])\\n                    new_l+=1\\n            \\n            \\n            return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3479396,
                "title": "python-sliding-window-explained",
                "content": "This is still the sliding window. Shrinking slidign window.\\nYou need to count subarrays **ending at `x`** (starting at 0 and ending at `x`):\\n\\nFor example: find all subarrays that contain `x` in `12x345`:\\n```\\n12x\\n12x3\\n12x34\\n12x345\\n2x\\n2x3\\n2x34\\n2x345\\nx\\nx3\\nx34\\nx345\\ntotal = 12\\nwhich is the same as: len(12x) * len(x345) = 3 * 4 = 12\\n```\\n\\nThis is going to be the same 3 pointer shrinking window:\\n3 pointers: start mid end\\n```\\n012 <-- idx\\n12x -> 2 - 0 + 1 = 3: 12x, 2x, x\\ns m\\n  e\\n  \\n12x3 -> 2 - 0 + 1 = 3: 12x3, 2x3, x3\\ns m\\n   e\\n\\n12x34 -> 2 - 0 + 1 = 3: 12x34, 2x34, x34\\ns m\\n    e\\n\\n12x345 -> 2 - 0 + 1 = 3: 12x345, 2x345, x345\\ns m\\n     e\\nTotal: 3 + 3 + 3 + 3 = 12\\n```\\n\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        \"\"\"\\n        Sliding window: 3 pointer approach\\n\\n        start\\n        mid\\n        end\\n        |\\n        0123456789\\n        cuaieuouac\\n\\n        1. push \\'end\\' till you get a valid-window-substring with all 5 vowels\\n        \\n         start\\n         mid  end\\n         |    |\\n        0123456789\\n        cuaieuouac\\n        \\n        2. shrink `mid` till you get a valid-window-substring of the smallest size\\n\\n         start\\n         | midend\\n         | |  |\\n        0123456789\\n        cuaieuouac\\n         ^^^^^^\\n        2.1. The distance between `((mid - 1) - start) + 1` is the number of substrigs you can form\\n          in the range [start, end] with the minimum valid-window-substring of size 5\\n          Think about start to mid as a prefix that forms substrnigs:\\n          1 char - 2 substrings (no prefix + 1 char)\\n          2 chars - 3 substrings (no prefix + 1 char + 2 chars)\\n          3 chars - 4 substrings (no prefix + 1 char + 2 chars + 3 chars) ...\\n\\n         start\\n         | midend\\n         | |  |\\n        0123456789\\n        cuaieuouac\\n          ^^^^^ <- smallest window that contains all 5 vowels: substirng #1\\n\\t\\t ^^^^^^ substring #2\\n        count += 3 - 1 = 2\\n\\n        2.2. repeat 1-2\\n        \\n         start\\n         | mid end\\n         | |   |\\n        0123456789\\n        cuaieuouac\\n          ^^^^^^ substirng #3\\n\\t\\t ^^^^^^^ substring #4\\n\\n        count += 3 - 1 = 2\\n\\n        2.3. repeat 1-2\\n        \\n         start\\n         |  mid end\\n         |  |   |\\n        0123456789\\n        cuaieuouac\\n           ^^^^^^ substirng #5\\n\\t\\t  ^^^^^^^ substring #6\\n\\t\\t ^^^^^^^^ substring #7\\n\\n        count += 4 - 1 = 3\\n        \"\"\"\\n        N = len(word)\\n        VOWELS = { \\'a\\': 0, \\'o\\': 0, \\'u\\': 0, \\'e\\': 0, \\'i\\': 0 }\\n        count = 0\\n        unique_vowels_count = 0\\n        start = mid = 0\\n        for end in range(N):\\n            if word[end] in VOWELS:\\n                VOWELS[word[end]] += 1\\n                if VOWELS[word[end]] == 1:\\n                    unique_vowels_count += 1\\n                \\n                while unique_vowels_count == 5:\\n                    VOWELS[word[mid]] -= 1\\n                    if VOWELS[word[mid]] == 0:\\n                        unique_vowels_count -= 1\\n                    mid += 1\\n                count += (mid - 1) - start + 1\\n            else:\\n                start = mid = end + 1\\n                unique_vowels_count = 0\\n                VOWELS[\\'a\\'] = VOWELS[\\'o\\'] = VOWELS[\\'u\\'] = VOWELS[\\'e\\'] = VOWELS[\\'i\\'] = 0\\n        \\n        return count\\n```\\n\\nThis can be further optimized by storing pointers of vowels and replace of the while loop with min/max.\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\n12x\\n12x3\\n12x34\\n12x345\\n2x\\n2x3\\n2x34\\n2x345\\nx\\nx3\\nx34\\nx345\\ntotal = 12\\nwhich is the same as: len(12x) * len(x345) = 3 * 4 = 12\\n```\n```\\n012 <-- idx\\n12x -> 2 - 0 + 1 = 3: 12x, 2x, x\\ns m\\n  e\\n  \\n12x3 -> 2 - 0 + 1 = 3: 12x3, 2x3, x3\\ns m\\n   e\\n\\n12x34 -> 2 - 0 + 1 = 3: 12x34, 2x34, x34\\ns m\\n    e\\n\\n12x345 -> 2 - 0 + 1 = 3: 12x345, 2x345, x345\\ns m\\n     e\\nTotal: 3 + 3 + 3 + 3 = 12\\n```\n```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        \"\"\"\\n        Sliding window: 3 pointer approach\\n\\n        start\\n        mid\\n        end\\n        |\\n        0123456789\\n        cuaieuouac\\n\\n        1. push \\'end\\' till you get a valid-window-substring with all 5 vowels\\n        \\n         start\\n         mid  end\\n         |    |\\n        0123456789\\n        cuaieuouac\\n        \\n        2. shrink `mid` till you get a valid-window-substring of the smallest size\\n\\n         start\\n         | midend\\n         | |  |\\n        0123456789\\n        cuaieuouac\\n         ^^^^^^\\n        2.1. The distance between `((mid - 1) - start) + 1` is the number of substrigs you can form\\n          in the range [start, end] with the minimum valid-window-substring of size 5\\n          Think about start to mid as a prefix that forms substrnigs:\\n          1 char - 2 substrings (no prefix + 1 char)\\n          2 chars - 3 substrings (no prefix + 1 char + 2 chars)\\n          3 chars - 4 substrings (no prefix + 1 char + 2 chars + 3 chars) ...\\n\\n         start\\n         | midend\\n         | |  |\\n        0123456789\\n        cuaieuouac\\n          ^^^^^ <- smallest window that contains all 5 vowels: substirng #1\\n\\t\\t ^^^^^^ substring #2\\n        count += 3 - 1 = 2\\n\\n        2.2. repeat 1-2\\n        \\n         start\\n         | mid end\\n         | |   |\\n        0123456789\\n        cuaieuouac\\n          ^^^^^^ substirng #3\\n\\t\\t ^^^^^^^ substring #4\\n\\n        count += 3 - 1 = 2\\n\\n        2.3. repeat 1-2\\n        \\n         start\\n         |  mid end\\n         |  |   |\\n        0123456789\\n        cuaieuouac\\n           ^^^^^^ substirng #5\\n\\t\\t  ^^^^^^^ substring #6\\n\\t\\t ^^^^^^^^ substring #7\\n\\n        count += 4 - 1 = 3\\n        \"\"\"\\n        N = len(word)\\n        VOWELS = { \\'a\\': 0, \\'o\\': 0, \\'u\\': 0, \\'e\\': 0, \\'i\\': 0 }\\n        count = 0\\n        unique_vowels_count = 0\\n        start = mid = 0\\n        for end in range(N):\\n            if word[end] in VOWELS:\\n                VOWELS[word[end]] += 1\\n                if VOWELS[word[end]] == 1:\\n                    unique_vowels_count += 1\\n                \\n                while unique_vowels_count == 5:\\n                    VOWELS[word[mid]] -= 1\\n                    if VOWELS[word[mid]] == 0:\\n                        unique_vowels_count -= 1\\n                    mid += 1\\n                count += (mid - 1) - start + 1\\n            else:\\n                start = mid = end + 1\\n                unique_vowels_count = 0\\n                VOWELS[\\'a\\'] = VOWELS[\\'o\\'] = VOWELS[\\'u\\'] = VOWELS[\\'e\\'] = VOWELS[\\'i\\'] = 0\\n        \\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3465443,
                "title": "simple-solution",
                "content": "# Intuition\\nScan the string for vowels. Each time we find a vowel, start a linear search at that point until we find the end of a run of vowels or the end of the string.\\n\\nDuring the search, keep a count of vowels seen so far so we can know which substrings have all of them.\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass VowelCounts {\\npublic:\\n  VowelCounts() { clear(); }\\n\\n  void clear() {\\n    for (int i = 0; i < 5; ++i)\\n      counts[i] = 0;\\n  }\\n  \\n  void add(char c) {\\n    if (c == \\'a\\')      ++counts[0];\\n    else if (c == \\'e\\') ++counts[1];\\n    else if (c == \\'i\\') ++counts[2];\\n    else if (c == \\'o\\') ++counts[3];\\n    else if (c == \\'u\\') ++counts[4];\\n  }\\n\\n  bool hasAllVowels() {\\n    for (int i = 0; i < 5; ++i)\\n      if (counts[i] == 0) return false;\\n    return true;\\n  }\\n\\n  int counts[5];\\n};\\n\\nbool isVowel(char c) {\\n  return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\n\\nclass Solution {\\npublic:\\n  int countVowelSubstrings(string word) {\\n    int total = 0;\\n    int N = word.size();\\n    for (int i = 0; i < N - 4; ++i) {\\n      if (isVowel(word[i])) {\\n        VowelCounts vowels;  // start with a new set of counts\\n        for (int j = i; j < N; ++j) {\\n          if (isVowel(word[j])) {\\n            vowels.add(word[j]);\\n            if (vowels.hasAllVowels()) {\\n              ++total;\\n            }\\n          } else {\\n            break;\\n          }\\n        }\\n      }\\n    }\\n    return total;\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass VowelCounts {\\npublic:\\n  VowelCounts() { clear(); }\\n\\n  void clear() {\\n    for (int i = 0; i < 5; ++i)\\n      counts[i] = 0;\\n  }\\n  \\n  void add(char c) {\\n    if (c == \\'a\\')      ++counts[0];\\n    else if (c == \\'e\\') ++counts[1];\\n    else if (c == \\'i\\') ++counts[2];\\n    else if (c == \\'o\\') ++counts[3];\\n    else if (c == \\'u\\') ++counts[4];\\n  }\\n\\n  bool hasAllVowels() {\\n    for (int i = 0; i < 5; ++i)\\n      if (counts[i] == 0) return false;\\n    return true;\\n  }\\n\\n  int counts[5];\\n};\\n\\nbool isVowel(char c) {\\n  return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\n\\nclass Solution {\\npublic:\\n  int countVowelSubstrings(string word) {\\n    int total = 0;\\n    int N = word.size();\\n    for (int i = 0; i < N - 4; ++i) {\\n      if (isVowel(word[i])) {\\n        VowelCounts vowels;  // start with a new set of counts\\n        for (int j = i; j < N; ++j) {\\n          if (isVowel(word[j])) {\\n            vowels.add(word[j]);\\n            if (vowels.hasAllVowels()) {\\n              ++total;\\n            }\\n          } else {\\n            break;\\n          }\\n        }\\n      }\\n    }\\n    return total;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3450204,
                "title": "scala-straightforward-solution",
                "content": "# Complexity\\n- Time complexity: $$O(n^2)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```scala\\nobject Solution {\\n\\n  def countVowelSubstrings(word: String): Int = {\\n    import scala.collection.mutable\\n\\n    val vowels = Set(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')\\n\\n    val counts = new mutable.HashMap[Char, Int](vowels.size, mutable.HashMap.defaultLoadFactor)\\n\\n    def isVowelSubstring(): Boolean = counts.size == 5 && counts.values.forall(_ > 0)\\n\\n    var result = 0\\n    var idx = 0\\n\\n    while (idx < word.length) {\\n      // Skip consonants\\n      while (idx < word.length && !vowels(word(idx))) {\\n        idx += 1\\n      }\\n      var end = idx\\n      while (end < word.length && vowels(word(end))) {\\n        counts.updateWith(word(end)) {\\n          case Some(value) => Some(value + 1)\\n          case None        => Some(1)\\n        }\\n        if (isVowelSubstring()) {\\n          result += 1\\n        }\\n        end += 1\\n      }\\n      counts.clear()\\n      idx += 1\\n    }\\n\\n    result\\n  }\\n\\n}\\n```",
                "solutionTags": [
                    "Scala",
                    "Hash Table",
                    "Counting"
                ],
                "code": "```scala\\nobject Solution {\\n\\n  def countVowelSubstrings(word: String): Int = {\\n    import scala.collection.mutable\\n\\n    val vowels = Set(\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\')\\n\\n    val counts = new mutable.HashMap[Char, Int](vowels.size, mutable.HashMap.defaultLoadFactor)\\n\\n    def isVowelSubstring(): Boolean = counts.size == 5 && counts.values.forall(_ > 0)\\n\\n    var result = 0\\n    var idx = 0\\n\\n    while (idx < word.length) {\\n      // Skip consonants\\n      while (idx < word.length && !vowels(word(idx))) {\\n        idx += 1\\n      }\\n      var end = idx\\n      while (end < word.length && vowels(word(end))) {\\n        counts.updateWith(word(end)) {\\n          case Some(value) => Some(value + 1)\\n          case None        => Some(1)\\n        }\\n        if (isVowelSubstring()) {\\n          result += 1\\n        }\\n        end += 1\\n      }\\n      counts.clear()\\n      idx += 1\\n    }\\n\\n    result\\n  }\\n\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3445404,
                "title": "two-pointers-solution",
                "content": "```\\nconst vowels = new Set<string>([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']);\\nfunction countVowelSubstrings(word: string): number {\\n    let result: number = 0;\\n    let i:number = 0;\\n    let j:number = 0;\\n\\n    while (i + vowels.size <= word.length) {\\n        if (vowels.has(word[i])) {\\n            j = i + vowels.size;\\n            while (j <= word.length) {\\n                if (isValidSubstring(word.slice(i, j))) result += 1;\\n                j++;\\n            }\\n        }\\n        i++;\\n    }\\n\\n    return result;\\n};\\n\\nfunction isValidSubstring(substr: string):boolean {\\n    const testSet = new Set<string>();\\n    for (let s of substr) {\\n        if (!vowels.has(s)) return false;\\n        testSet.add(s);\\n    }\\n    return testSet.size === vowels.size;\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nconst vowels = new Set<string>([\\'a\\', \\'e\\', \\'i\\', \\'o\\', \\'u\\']);\\nfunction countVowelSubstrings(word: string): number {\\n    let result: number = 0;\\n    let i:number = 0;\\n    let j:number = 0;\\n\\n    while (i + vowels.size <= word.length) {\\n        if (vowels.has(word[i])) {\\n            j = i + vowels.size;\\n            while (j <= word.length) {\\n                if (isValidSubstring(word.slice(i, j))) result += 1;\\n                j++;\\n            }\\n        }\\n        i++;\\n    }\\n\\n    return result;\\n};\\n\\nfunction isValidSubstring(substr: string):boolean {\\n    const testSet = new Set<string>();\\n    for (let s of substr) {\\n        if (!vowels.has(s)) return false;\\n        testSet.add(s);\\n    }\\n    return testSet.size === vowels.size;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3435803,
                "title": "dart-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n int countVowelSubstrings(String s) {\\n  int n = s.length;\\n  int ans = 0;\\n  Set<String> st =  {};\\n  \\n  for (int i = 0; i < n; ++i) {\\n    for (int j = i; j < n; ++j) {\\n      if (s[j] == \\'a\\' || s[j] == \\'e\\' || s[j] == \\'i\\' || s[j] == \\'o\\' || s[j] == \\'u\\') {\\n        st.add(s[j]);\\n      } else {\\n        break;\\n      }\\n      if (st.length == 5) {\\n        ans++;\\n      }\\n    }\\n    st.clear();\\n  }\\n  \\n  return ans;\\n}\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n int countVowelSubstrings(String s) {\\n  int n = s.length;\\n  int ans = 0;\\n  Set<String> st =  {};\\n  \\n  for (int i = 0; i < n; ++i) {\\n    for (int j = i; j < n; ++j) {\\n      if (s[j] == \\'a\\' || s[j] == \\'e\\' || s[j] == \\'i\\' || s[j] == \\'o\\' || s[j] == \\'u\\') {\\n        st.add(s[j]);\\n      } else {\\n        break;\\n      }\\n      if (st.length == 5) {\\n        ans++;\\n      }\\n    }\\n    st.clear();\\n  }\\n  \\n  return ans;\\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3431306,
                "title": "python-sliding-window-o-n",
                "content": "Sliding window start point will be the first valid index.\\nFirst valid index is defined as index post which there is no non vowel char.\\nNow keep a track of last index of all vowels.At each index find the first occurence(min index) of all 5 vowels.If it doesn\\'t exist, do nothing.If it exists we can take all windows starting from start till this min index.\\n```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        vowels=set([\"a\",\"e\",\"i\",\"o\",\"u\"])\\n        last={c:-1 for c in vowels}\\n        n,ans,start=len(word),0,0\\n        def okay():\\n            mmax=sys.maxsize\\n            for c in last:\\n                if last[c]==-1: return 0,mmax\\n                mmax=min(mmax,last[c])\\n            return 1,mmax\\n        for i in range(n):\\n            if word[i] not in vowels:\\n                last={c:-1 for c in vowels}\\n                start=i+1\\n            else: \\n                last[word[i]]=i\\n                flag,mmax=okay()\\n                if flag:\\n                    ans+=mmax-start+1\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        vowels=set([\"a\",\"e\",\"i\",\"o\",\"u\"])\\n        last={c:-1 for c in vowels}\\n        n,ans,start=len(word),0,0\\n        def okay():\\n            mmax=sys.maxsize\\n            for c in last:\\n                if last[c]==-1: return 0,mmax\\n                mmax=min(mmax,last[c])\\n            return 1,mmax\\n        for i in range(n):\\n            if word[i] not in vowels:\\n                last={c:-1 for c in vowels}\\n                start=i+1\\n            else: \\n                last[word[i]]=i\\n                flag,mmax=okay()\\n                if flag:\\n                    ans+=mmax-start+1\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3418835,
                "title": "using-map-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N^2)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check_vowel(unordered_map<char, int>& mapstr){\\n        int count=0;\\n        if(mapstr[\\'a\\']) count++;\\n        if(mapstr[\\'e\\']) count++;\\n        if(mapstr[\\'i\\']) count++;\\n        if(mapstr[\\'o\\']) count++;\\n        if(mapstr[\\'u\\']) count++;\\n        if(count!=5) return 0;\\n        return 1;\\n    }\\n\\n    int substringcount(string& substring){\\n        int scount=0, count=0, start=1;\\n        unordered_map<char, int> mapstring;\\n        for(int i = start; i < substring.size(); i++){\\n            mapstring[substring[i]]++;\\n            count++;\\n            if(count >=5) scount+=check_vowel(mapstring);\\n            if(i==substring.size()-1 and count>5){\\n                mapstring.clear();\\n                count=0;\\n                i=start++;\\n            }\\n        }\\n        return scount;\\n    }\\n\\n    int countVowelSubstrings(string word) {\\n        unordered_map<char, int> vowels;\\n        unordered_map<char, int> mapstring;\\n        string vowstr=\"aeiou\";\\n        for(int i=0; i < vowstr.size(); i++) vowels[vowstr[i]]++;\\n        int answer=0, vcount=0;\\n        string substring=\"\";\\n        word+=\"_\";\\n        for(int i=0; i < word.size(); i++){\\n            if(vowels[word[i]]){\\n                vcount++;\\n                substring+=word[i];\\n                mapstring[word[i]]++;\\n                if(vcount>=5){\\n                    answer+=check_vowel(mapstring);\\n                }\\n            }\\n            else{\\n                if(vcount>=5){\\n                    answer+=substringcount(substring);\\n                }\\n                mapstring.clear();\\n                substring=\"\";\\n                vcount=0;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check_vowel(unordered_map<char, int>& mapstr){\\n        int count=0;\\n        if(mapstr[\\'a\\']) count++;\\n        if(mapstr[\\'e\\']) count++;\\n        if(mapstr[\\'i\\']) count++;\\n        if(mapstr[\\'o\\']) count++;\\n        if(mapstr[\\'u\\']) count++;\\n        if(count!=5) return 0;\\n        return 1;\\n    }\\n\\n    int substringcount(string& substring){\\n        int scount=0, count=0, start=1;\\n        unordered_map<char, int> mapstring;\\n        for(int i = start; i < substring.size(); i++){\\n            mapstring[substring[i]]++;\\n            count++;\\n            if(count >=5) scount+=check_vowel(mapstring);\\n            if(i==substring.size()-1 and count>5){\\n                mapstring.clear();\\n                count=0;\\n                i=start++;\\n            }\\n        }\\n        return scount;\\n    }\\n\\n    int countVowelSubstrings(string word) {\\n        unordered_map<char, int> vowels;\\n        unordered_map<char, int> mapstring;\\n        string vowstr=\"aeiou\";\\n        for(int i=0; i < vowstr.size(); i++) vowels[vowstr[i]]++;\\n        int answer=0, vcount=0;\\n        string substring=\"\";\\n        word+=\"_\";\\n        for(int i=0; i < word.size(); i++){\\n            if(vowels[word[i]]){\\n                vcount++;\\n                substring+=word[i];\\n                mapstring[word[i]]++;\\n                if(vcount>=5){\\n                    answer+=check_vowel(mapstring);\\n                }\\n            }\\n            else{\\n                if(vcount>=5){\\n                    answer+=substringcount(substring);\\n                }\\n                mapstring.clear();\\n                substring=\"\";\\n                vcount=0;\\n            }\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3411496,
                "title": "count-vowel-substrings-of-a-string",
                "content": "-------------- Easy C++ Solution ---------------\\n\\n# Complexity\\n- Time complexity:\\nAdd your time complexity here, e.g. $$O(n)$$\\n\\n- Space complexity:\\nAdd your space complexity here, e.g. $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n  bool isV(char ch)\\n    {\\n        return (ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\');\\n    }\\n    \\n    int count_Vowel(string s,int k)\\n    {\\n        unordered_map<char,int> freq;\\n        int count=0;\\n        int i=0,j=0;\\n        while(j<s.size())\\n        {\\n            if(!isV(s[j]))\\n            {\\n                i=j+1;\\n                j++;\\n                freq.clear();\\n                continue;\\n            }\\n            freq[s[j++]]++;\\n            while(freq.size()>k)\\n            {\\n                freq[s[i]]--;\\n                \\n                if(freq[s[i]]==0)\\n                    freq.erase(s[i]);\\n                i++;\\n            }\\n            count+=(j-i+1);\\n        }\\n        return count;\\n    }\\n    \\n    int countVowelSubstrings(string word) {\\n         return ( count_Vowel(word,5) -  \\n                     count_Vowel(word,4));   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  bool isV(char ch)\\n    {\\n        return (ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\');\\n    }\\n    \\n    int count_Vowel(string s,int k)\\n    {\\n        unordered_map<char,int> freq;\\n        int count=0;\\n        int i=0,j=0;\\n        while(j<s.size())\\n        {\\n            if(!isV(s[j]))\\n            {\\n                i=j+1;\\n                j++;\\n                freq.clear();\\n                continue;\\n            }\\n            freq[s[j++]]++;\\n            while(freq.size()>k)\\n            {\\n                freq[s[i]]--;\\n                \\n                if(freq[s[i]]==0)\\n                    freq.erase(s[i]);\\n                i++;\\n            }\\n            count+=(j-i+1);\\n        }\\n        return count;\\n    }\\n    \\n    int countVowelSubstrings(string word) {\\n         return ( count_Vowel(word,5) -  \\n                     count_Vowel(word,4));   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399386,
                "title": "java-simple-and-very-slow-solution",
                "content": "# Complexity\\n- Time complexity: O(n ^ n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n       int n = word.length(), count = 0;\\n       int left = 0, right = word.length();\\n\\n       while(left <= n - 5){\\n           StringBuilder sb = new StringBuilder();\\n\\n           for(int i = left; i < n; i++){\\n               char c = word.charAt(i);\\n               if(c == \\'a\\' || c == \\'e\\' || c ==\\'i\\' || c == \\'o\\' || c == \\'u\\'){\\n                   sb.append(c);\\n                   if(isValid(sb.toString()))count++;\\n               }else{\\n                   break;\\n               }\\n           }\\n\\n           left++;\\n       }\\n\\n       return count;\\n    }\\n\\n    private boolean isValid(String s){\\n        if( s.contains(\"a\") &&\\n            s.contains(\"e\") &&\\n            s.contains(\"i\") &&\\n            s.contains(\"o\") &&\\n            s.contains(\"u\")) return true;\\n            return false;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int countVowelSubstrings(String word) {\\n       int n = word.length(), count = 0;\\n       int left = 0, right = word.length();\\n\\n       while(left <= n - 5){\\n           StringBuilder sb = new StringBuilder();\\n\\n           for(int i = left; i < n; i++){\\n               char c = word.charAt(i);\\n               if(c == \\'a\\' || c == \\'e\\' || c ==\\'i\\' || c == \\'o\\' || c == \\'u\\'){\\n                   sb.append(c);\\n                   if(isValid(sb.toString()))count++;\\n               }else{\\n                   break;\\n               }\\n           }\\n\\n           left++;\\n       }\\n\\n       return count;\\n    }\\n\\n    private boolean isValid(String s){\\n        if( s.contains(\"a\") &&\\n            s.contains(\"e\") &&\\n            s.contains(\"i\") &&\\n            s.contains(\"o\") &&\\n            s.contains(\"u\")) return true;\\n            return false;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3399162,
                "title": "simple-sliding-window-python-solution",
                "content": "# Intuition\\nGenerate all substring and check if substring has only vovels. Easily can be done by converting substring into set\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: ```O(n^2)```\\nwhere n is the number of chars in given word\\n\\n- Space complexity: ```O(n)```\\nSpace is required to convert substring into a set\\n\\n# Code\\n```\\nclass Solution(object):\\n    def countVowelSubstrings(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(len(word)):\\n            for j in range(i+5, len(word)+1):\\n                substr_set = set(word[i:j])\\n                if substr_set == set(\"aeiou\"):\\n                    count += 1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```O(n^2)```\n```O(n)```\n```\\nclass Solution(object):\\n    def countVowelSubstrings(self, word):\\n        \"\"\"\\n        :type word: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        for i in range(len(word)):\\n            for j in range(i+5, len(word)+1):\\n                substr_set = set(word[i:j])\\n                if substr_set == set(\"aeiou\"):\\n                    count += 1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3396115,
                "title": "c-c-figurative-beginner-friendly",
                "content": "1. `What I can do` = `What my previous can do` + `What only I can do`\\n2. Two pointers:\\n    1. the `right` pointer is my current position.\\n    2. the `left` pointer is where my previous character failed to form a vowel substring. If we haven\\'t got a valid vowel substring yet, then it is -1.\\n3. Every vowel substring of previous character is also my vowel substring, that is `What my previous can do`.\\n4. Starting from where my previous character failed to form a vowel substring, I can try to form a new vowel substring because I have a new character.\\n5. I can keep testing my limit by removing characters from the left. This is `What only I can do`.\\n6. We have to clear the occurrence table and reset left pointer when encountering a non-vowel character because vowel substring must be contiguous.\\n\\n![Count Vowel Substrings of a String.png](https://assets.leetcode.com/users/images/72955d72-8988-43d1-9fb3-7b8ad3c2d95a_1681018257.1670148.png)\\n# Code\\n```CS []\\npublic int CountVowelSubstrings(string word) \\n{\\n    int totalCount = 0;\\n    int previousCount = 0;\\n    Dictionary<char, int> occurrence = new Dictionary<char, int>();\\n    int left = -1;\\n    foreach(char vowel in \"aeiou\")\\n    {\\n        occurrence[vowel] = 0;\\n    }\\n    for (int right = 0; right < word.Length; ++right) \\n    {\\n        char c = word[right];\\n        \\n        if (IsVowel(c))\\n        {\\n            ++occurrence[c];\\n            if (left < 0) \\n            {\\n                left = right;\\n            }\\n            int myUniqueCount = 0;\\n            while (IsValidVowelSubstring(occurrence)) \\n            {\\n                ++myUniqueCount;\\n                --occurrence[word[left]];\\n                ++left;\\n            }\\n\\n            totalCount += previousCount + myUniqueCount;\\n            previousCount = previousCount + myUniqueCount;\\n        }\\n        else {\\n            left = -1;\\n            previousCount = 0;\\n            foreach(char vowel in \"aeiou\")\\n            {\\n                occurrence[vowel] = 0;\\n            }\\n        }\\n    }\\n    return totalCount;\\n}\\n\\nbool IsVowel(char c)\\n{\\n    return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\n\\nbool IsValidVowelSubstring(Dictionary<char, int> occurrence)\\n{\\n    bool valid = true;\\n    foreach(char c in \"aeiou\")\\n    {\\n        if (occurrence[c] <= 0) \\n        {\\n            valid = false;\\n            break;\\n        }\\n    }\\n    return valid;\\n}\\n```\\n```C++ []\\nint countVowelSubstrings(string word) {\\n    int totalCount = 0;\\n    int previousCount = 0;\\n    unordered_map<char, int> occurrence;\\n    int left = -1;\\n    for (int right = 0; right < word.size(); ++right) {\\n        char c = word[right];\\n        if (isVowel(c)) {\\n            ++occurrence[c];\\n            if (left < 0) {\\n                left = right;\\n            }\\n            int myUniqueCount = 0;\\n            while (isValidVowelSubstring(occurrence)) {\\n                ++myUniqueCount;\\n                --occurrence[word[left]];\\n                ++left;\\n            }\\n            totalCount += previousCount + myUniqueCount;\\n            previousCount = previousCount + myUniqueCount;\\n        }\\n        else {\\n            left = -1;\\n            previousCount = 0;\\n            occurrence.clear();\\n        }\\n    }\\n\\n    return totalCount;\\n}\\n\\nbool isVowel(char c) {\\n    return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\n\\nbool isValidVowelSubstring(unordered_map<char, int>& occurrence) {\\n    bool valid = true;\\n    string vowels = \"aeiou\";\\n    for (char c : vowels) {\\n        if (occurrence[c] <= 0) {\\n            valid = false;\\n            break;\\n        }\\n    }\\n\\n    return valid;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C#"
                ],
                "code": "```CS []\\npublic int CountVowelSubstrings(string word) \\n{\\n    int totalCount = 0;\\n    int previousCount = 0;\\n    Dictionary<char, int> occurrence = new Dictionary<char, int>();\\n    int left = -1;\\n    foreach(char vowel in \"aeiou\")\\n    {\\n        occurrence[vowel] = 0;\\n    }\\n    for (int right = 0; right < word.Length; ++right) \\n    {\\n        char c = word[right];\\n        \\n        if (IsVowel(c))\\n        {\\n            ++occurrence[c];\\n            if (left < 0) \\n            {\\n                left = right;\\n            }\\n            int myUniqueCount = 0;\\n            while (IsValidVowelSubstring(occurrence)) \\n            {\\n                ++myUniqueCount;\\n                --occurrence[word[left]];\\n                ++left;\\n            }\\n\\n            totalCount += previousCount + myUniqueCount;\\n            previousCount = previousCount + myUniqueCount;\\n        }\\n        else {\\n            left = -1;\\n            previousCount = 0;\\n            foreach(char vowel in \"aeiou\")\\n            {\\n                occurrence[vowel] = 0;\\n            }\\n        }\\n    }\\n    return totalCount;\\n}\\n\\nbool IsVowel(char c)\\n{\\n    return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\n\\nbool IsValidVowelSubstring(Dictionary<char, int> occurrence)\\n{\\n    bool valid = true;\\n    foreach(char c in \"aeiou\")\\n    {\\n        if (occurrence[c] <= 0) \\n        {\\n            valid = false;\\n            break;\\n        }\\n    }\\n    return valid;\\n}\\n```\n```C++ []\\nint countVowelSubstrings(string word) {\\n    int totalCount = 0;\\n    int previousCount = 0;\\n    unordered_map<char, int> occurrence;\\n    int left = -1;\\n    for (int right = 0; right < word.size(); ++right) {\\n        char c = word[right];\\n        if (isVowel(c)) {\\n            ++occurrence[c];\\n            if (left < 0) {\\n                left = right;\\n            }\\n            int myUniqueCount = 0;\\n            while (isValidVowelSubstring(occurrence)) {\\n                ++myUniqueCount;\\n                --occurrence[word[left]];\\n                ++left;\\n            }\\n            totalCount += previousCount + myUniqueCount;\\n            previousCount = previousCount + myUniqueCount;\\n        }\\n        else {\\n            left = -1;\\n            previousCount = 0;\\n            occurrence.clear();\\n        }\\n    }\\n\\n    return totalCount;\\n}\\n\\nbool isVowel(char c) {\\n    return c == \\'a\\' || c == \\'e\\' || c == \\'i\\' || c == \\'o\\' || c == \\'u\\';\\n}\\n\\nbool isValidVowelSubstring(unordered_map<char, int>& occurrence) {\\n    bool valid = true;\\n    string vowels = \"aeiou\";\\n    for (char c : vowels) {\\n        if (occurrence[c] <= 0) {\\n            valid = false;\\n            break;\\n        }\\n    }\\n\\n    return valid;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3388745,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        if len(word) < 5:\\n            return 0\\n\\n        count = 0\\n\\n        i = 0\\n        start = None\\n        seen = set()\\n        while i < len(word) or ((len(word) if start is None else start) < len(word)):\\n            if i < len(word) and word[i] in \\'aeiou\\':\\n                if start is None:\\n                    start = i\\n\\n                seen.add(word[i])\\n\\n                if len(seen) == 5:\\n                    count += 1\\n                \\n                i += 1\\n\\n            else:\\n                start = None if start is None else start+1\\n                i = i+1 if start is None else start\\n                seen = set()\\n\\n        return count\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def countVowelSubstrings(self, word: str) -> int:\\n        if len(word) < 5:\\n            return 0\\n\\n        count = 0\\n\\n        i = 0\\n        start = None\\n        seen = set()\\n        while i < len(word) or ((len(word) if start is None else start) < len(word)):\\n            if i < len(word) and word[i] in \\'aeiou\\':\\n                if start is None:\\n                    start = i\\n\\n                seen.add(word[i])\\n\\n                if len(seen) == 5:\\n                    count += 1\\n                \\n                i += 1\\n\\n            else:\\n                start = None if start is None else start+1\\n                i = i+1 if start is None else start\\n                seen = set()\\n\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362546,
                "title": "simple-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(char ch){\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\')return true;\\n        return false;\\n    }\\n    int countVowelSubstrings(string word) {\\n        set<char>s;\\n        int ans=0;\\n       \\n        for(int i=0;i<word.size();i++){\\n            int j=i;\\n           \\n           s.clear();\\n            while(j<word.size()){\\n                if(!isvalid(word[j]))break;\\n                s.insert(word[j]);\\n                if(s.size()==5)ans++;\\n                \\n                j++;\\n                \\n                \\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(char ch){\\n        if(ch==\\'a\\' || ch==\\'e\\' || ch==\\'i\\' || ch==\\'o\\' || ch==\\'u\\')return true;\\n        return false;\\n    }\\n    int countVowelSubstrings(string word) {\\n        set<char>s;\\n        int ans=0;\\n       \\n        for(int i=0;i<word.size();i++){\\n            int j=i;\\n           \\n           s.clear();\\n            while(j<word.size()){\\n                if(!isvalid(word[j]))break;\\n                s.insert(word[j]);\\n                if(s.size()==5)ans++;\\n                \\n                j++;\\n                \\n                \\n            }\\n            \\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565917,
                "content": [
                    {
                        "username": "anishLearnsToCode",
                        "content": "This should definitely be a Medium problem at least.  Spent more time on this 10 easy problems combined !!"
                    },
                    {
                        "username": "vivace",
                        "content": "Its easy because constraints say string size <= 100. Make it 10^5, should me on the upper end of mediums atleast. "
                    },
                    {
                        "username": "masha-nv",
                        "content": "not an \\'Easy\\' problem."
                    },
                    {
                        "username": "Leetcode9651",
                        "content": "it is not a easy problem :::"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for problems where you need to generate and test all substrings, sliding window is surely there"
                    },
                    {
                        "username": "rishighai97",
                        "content": "Hi, could anyone please help me confirm the time complexity for my code ? \\n\\nhttps://leetcode.com/problems/count-vowel-substrings-of-a-string/solutions/3831920/can-someone-help-confirm-the-tc-for-my-code-counting-all-valid-substrings-using-hash-table/"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Can this question be done in O(n) time?"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "why we are not considering strings which has length from 1 to 2 or  3 elements? "
                    },
                    {
                        "username": "yathartharora1999",
                        "content": "Because the question says so. The string should have all the 5 vowels"
                    }
                ]
            },
            {
                "id": 1676921,
                "content": [
                    {
                        "username": "anishLearnsToCode",
                        "content": "This should definitely be a Medium problem at least.  Spent more time on this 10 easy problems combined !!"
                    },
                    {
                        "username": "vivace",
                        "content": "Its easy because constraints say string size <= 100. Make it 10^5, should me on the upper end of mediums atleast. "
                    },
                    {
                        "username": "masha-nv",
                        "content": "not an \\'Easy\\' problem."
                    },
                    {
                        "username": "Leetcode9651",
                        "content": "it is not a easy problem :::"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for problems where you need to generate and test all substrings, sliding window is surely there"
                    },
                    {
                        "username": "rishighai97",
                        "content": "Hi, could anyone please help me confirm the time complexity for my code ? \\n\\nhttps://leetcode.com/problems/count-vowel-substrings-of-a-string/solutions/3831920/can-someone-help-confirm-the-tc-for-my-code-counting-all-valid-substrings-using-hash-table/"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Can this question be done in O(n) time?"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "why we are not considering strings which has length from 1 to 2 or  3 elements? "
                    },
                    {
                        "username": "yathartharora1999",
                        "content": "Because the question says so. The string should have all the 5 vowels"
                    }
                ]
            },
            {
                "id": 1791948,
                "content": [
                    {
                        "username": "anishLearnsToCode",
                        "content": "This should definitely be a Medium problem at least.  Spent more time on this 10 easy problems combined !!"
                    },
                    {
                        "username": "vivace",
                        "content": "Its easy because constraints say string size <= 100. Make it 10^5, should me on the upper end of mediums atleast. "
                    },
                    {
                        "username": "masha-nv",
                        "content": "not an \\'Easy\\' problem."
                    },
                    {
                        "username": "Leetcode9651",
                        "content": "it is not a easy problem :::"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for problems where you need to generate and test all substrings, sliding window is surely there"
                    },
                    {
                        "username": "rishighai97",
                        "content": "Hi, could anyone please help me confirm the time complexity for my code ? \\n\\nhttps://leetcode.com/problems/count-vowel-substrings-of-a-string/solutions/3831920/can-someone-help-confirm-the-tc-for-my-code-counting-all-valid-substrings-using-hash-table/"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Can this question be done in O(n) time?"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "why we are not considering strings which has length from 1 to 2 or  3 elements? "
                    },
                    {
                        "username": "yathartharora1999",
                        "content": "Because the question says so. The string should have all the 5 vowels"
                    }
                ]
            },
            {
                "id": 2050014,
                "content": [
                    {
                        "username": "anishLearnsToCode",
                        "content": "This should definitely be a Medium problem at least.  Spent more time on this 10 easy problems combined !!"
                    },
                    {
                        "username": "vivace",
                        "content": "Its easy because constraints say string size <= 100. Make it 10^5, should me on the upper end of mediums atleast. "
                    },
                    {
                        "username": "masha-nv",
                        "content": "not an \\'Easy\\' problem."
                    },
                    {
                        "username": "Leetcode9651",
                        "content": "it is not a easy problem :::"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for problems where you need to generate and test all substrings, sliding window is surely there"
                    },
                    {
                        "username": "rishighai97",
                        "content": "Hi, could anyone please help me confirm the time complexity for my code ? \\n\\nhttps://leetcode.com/problems/count-vowel-substrings-of-a-string/solutions/3831920/can-someone-help-confirm-the-tc-for-my-code-counting-all-valid-substrings-using-hash-table/"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Can this question be done in O(n) time?"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "why we are not considering strings which has length from 1 to 2 or  3 elements? "
                    },
                    {
                        "username": "yathartharora1999",
                        "content": "Because the question says so. The string should have all the 5 vowels"
                    }
                ]
            },
            {
                "id": 1991192,
                "content": [
                    {
                        "username": "anishLearnsToCode",
                        "content": "This should definitely be a Medium problem at least.  Spent more time on this 10 easy problems combined !!"
                    },
                    {
                        "username": "vivace",
                        "content": "Its easy because constraints say string size <= 100. Make it 10^5, should me on the upper end of mediums atleast. "
                    },
                    {
                        "username": "masha-nv",
                        "content": "not an \\'Easy\\' problem."
                    },
                    {
                        "username": "Leetcode9651",
                        "content": "it is not a easy problem :::"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for problems where you need to generate and test all substrings, sliding window is surely there"
                    },
                    {
                        "username": "rishighai97",
                        "content": "Hi, could anyone please help me confirm the time complexity for my code ? \\n\\nhttps://leetcode.com/problems/count-vowel-substrings-of-a-string/solutions/3831920/can-someone-help-confirm-the-tc-for-my-code-counting-all-valid-substrings-using-hash-table/"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Can this question be done in O(n) time?"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "why we are not considering strings which has length from 1 to 2 or  3 elements? "
                    },
                    {
                        "username": "yathartharora1999",
                        "content": "Because the question says so. The string should have all the 5 vowels"
                    }
                ]
            },
            {
                "id": 1963033,
                "content": [
                    {
                        "username": "anishLearnsToCode",
                        "content": "This should definitely be a Medium problem at least.  Spent more time on this 10 easy problems combined !!"
                    },
                    {
                        "username": "vivace",
                        "content": "Its easy because constraints say string size <= 100. Make it 10^5, should me on the upper end of mediums atleast. "
                    },
                    {
                        "username": "masha-nv",
                        "content": "not an \\'Easy\\' problem."
                    },
                    {
                        "username": "Leetcode9651",
                        "content": "it is not a easy problem :::"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for problems where you need to generate and test all substrings, sliding window is surely there"
                    },
                    {
                        "username": "rishighai97",
                        "content": "Hi, could anyone please help me confirm the time complexity for my code ? \\n\\nhttps://leetcode.com/problems/count-vowel-substrings-of-a-string/solutions/3831920/can-someone-help-confirm-the-tc-for-my-code-counting-all-valid-substrings-using-hash-table/"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Can this question be done in O(n) time?"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "why we are not considering strings which has length from 1 to 2 or  3 elements? "
                    },
                    {
                        "username": "yathartharora1999",
                        "content": "Because the question says so. The string should have all the 5 vowels"
                    }
                ]
            },
            {
                "id": 1761934,
                "content": [
                    {
                        "username": "anishLearnsToCode",
                        "content": "This should definitely be a Medium problem at least.  Spent more time on this 10 easy problems combined !!"
                    },
                    {
                        "username": "vivace",
                        "content": "Its easy because constraints say string size <= 100. Make it 10^5, should me on the upper end of mediums atleast. "
                    },
                    {
                        "username": "masha-nv",
                        "content": "not an \\'Easy\\' problem."
                    },
                    {
                        "username": "Leetcode9651",
                        "content": "it is not a easy problem :::"
                    },
                    {
                        "username": "bedmuthaapoorv",
                        "content": "for problems where you need to generate and test all substrings, sliding window is surely there"
                    },
                    {
                        "username": "rishighai97",
                        "content": "Hi, could anyone please help me confirm the time complexity for my code ? \\n\\nhttps://leetcode.com/problems/count-vowel-substrings-of-a-string/solutions/3831920/can-someone-help-confirm-the-tc-for-my-code-counting-all-valid-substrings-using-hash-table/"
                    },
                    {
                        "username": "rahulranaa7",
                        "content": "Can this question be done in O(n) time?"
                    },
                    {
                        "username": "Django_Developer",
                        "content": "why we are not considering strings which has length from 1 to 2 or  3 elements? "
                    },
                    {
                        "username": "yathartharora1999",
                        "content": "Because the question says so. The string should have all the 5 vowels"
                    }
                ]
            }
        ]
    }
]