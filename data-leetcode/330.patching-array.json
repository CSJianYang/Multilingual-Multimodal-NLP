[
    {
        "title": "Substring with Concatenation of All Words",
        "question_content": "You are given a string s and an array of strings words. All the strings of words are of the same length.\nA concatenated substring in s is a substring that contains all the strings of any permutation of words concatenated.\n\n\tFor example, if words = [\"ab\",\"cd\",\"ef\"], then \"abcdef\", \"abefcd\", \"cdabef\", \"cdefab\", \"efabcd\", and \"efcdab\" are all concatenated strings. \"acdbef\" is not a concatenated substring because it is not the concatenation of any permutation of words.\n\nReturn the starting indices of all the concatenated substrings in s. You can return the answer in any order.\n&nbsp;\nExample 1:\n\nInput: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\nOutput: [0,9]\nExplanation: Since words.length == 2 and words[i].length == 3, the concatenated substring has to be of length 6.\nThe substring starting at 0 is \"barfoo\". It is the concatenation of [\"bar\",\"foo\"] which is a permutation of words.\nThe substring starting at 9 is \"foobar\". It is the concatenation of [\"foo\",\"bar\"] which is a permutation of words.\nThe output order does not matter. Returning [9,0] is fine too.\n\nExample 2:\n\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\nOutput: []\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\nThere is no substring of length 16 in s that is equal to the concatenation of any permutation of words.\nWe return an empty array.\n\nExample 3:\n\nInput: s = \"barfoofoobarthefoobarman\", words = [\"bar\",\"foo\",\"the\"]\nOutput: [6,9,12]\nExplanation: Since words.length == 3 and words[i].length == 3, the concatenated substring has to be of length 9.\nThe substring starting at 6 is \"foobarthe\". It is the concatenation of [\"foo\",\"bar\",\"the\"] which is a permutation of words.\nThe substring starting at 9 is \"barthefoo\". It is the concatenation of [\"bar\",\"the\",\"foo\"] which is a permutation of words.\nThe substring starting at 12 is \"thefoobar\". It is the concatenation of [\"the\",\"foo\",\"bar\"] which is a permutation of words.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 104\n\t1 <= words.length <= 5000\n\t1 <= words[i].length <= 30\n\ts and words[i] consist of lowercase English letters.",
        "solutions": [
            {
                "id": 13658,
                "title": "easy-two-map-solution-c-java",
                "content": "I think the following code is self-explanatory enough. We use an `unordered_map<string, int> counts` to record the expected times of each word and another `unordered_map<string, int> seen` to record the times we have seen. Then we check for every possible position of `i`. Once we meet an unexpected word or the times of some word is larger than its expected times, we stop the check. If we finish the check successfully, push `i` to the result `indexes`.\\n\\n* C++\\n\\n\\n    class Solution {\\n    public:\\n        vector<int> findSubstring(string s, vector<string>& words) {\\n            unordered_map<string, int> counts;\\n            for (string word : words)\\n                counts[word]++;\\n            int n = s.length(), num = words.size(), len = words[0].length();\\n            vector<int> indexes;\\n            for (int i = 0; i < n - num * len + 1; i++) {\\n                unordered_map<string, int> seen;\\n                int j = 0;\\n                for (; j < num; j++) {\\n                    string word = s.substr(i + j * len, len);\\n                    if (counts.find(word) != counts.end()) {\\n                        seen[word]++;\\n                        if (seen[word] > counts[word])\\n                            break;\\n                    } \\n                    else break;\\n                }\\n                if (j == num) indexes.push_back(i);\\n            }\\n            return indexes;\\n        }\\n    };\\n\\n* Java\\n\\n```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        final Map<String, Integer> counts = new HashMap<>();\\n        for (final String word : words) {\\n            counts.put(word, counts.getOrDefault(word, 0) + 1);\\n        }\\n        final List<Integer> indexes = new ArrayList<>();\\n        final int n = s.length(), num = words.length, len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            final Map<String, Integer> seen = new HashMap<>();\\n            int j = 0;\\n            while (j < num) {\\n                final String word = s.substring(i + j * len, i + (j + 1) * len);\\n                if (counts.containsKey(word)) {\\n                    seen.put(word, seen.getOrDefault(word, 0) + 1);\\n                    if (seen.get(word) > counts.getOrDefault(word, 0)) {\\n                        break;\\n                    }\\n                } else {\\n                    break;\\n                }\\n                j++;\\n            }\\n            if (j == num) {\\n                indexes.add(i);\\n            }\\n        }\\n        return indexes;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        final Map<String, Integer> counts = new HashMap<>();\\n        for (final String word : words) {\\n            counts.put(word, counts.getOrDefault(word, 0) + 1);\\n        }\\n        final List<Integer> indexes = new ArrayList<>();\\n        final int n = s.length(), num = words.length, len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            final Map<String, Integer> seen = new HashMap<>();\\n            int j = 0;\\n            while (j < num) {\\n                final String word = s.substring(i + j * len, i + (j + 1) * len);\\n                if (counts.containsKey(word)) {\\n                    seen.put(word, seen.getOrDefault(word, 0) + 1);\\n                    if (seen.get(word) > counts.getOrDefault(word, 0)) {\\n                        break;\\n                    }\\n                } else {\\n                    break;\\n                }\\n                j++;\\n            }\\n            if (j == num) {\\n                indexes.add(i);\\n            }\\n        }\\n        return indexes;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13656,
                "title": "an-o-n-solution-with-detailed-explanation",
                "content": "        // travel all the words combinations to maintain a window\\n        // there are wl(word len) times travel\\n        // each time, n/wl words, mostly 2 times travel for each word\\n        // one left side of the window, the other right side of the window\\n        // so, time complexity O(wl * 2 * N/wl) = O(2N)\\n        vector<int> findSubstring(string S, vector<string> &L) {\\n            vector<int> ans;\\n            int n = S.size(), cnt = L.size();\\n            if (n <= 0 || cnt <= 0) return ans;\\n            \\n            // init word occurence\\n            unordered_map<string, int> dict;\\n            for (int i = 0; i < cnt; ++i) dict[L[i]]++;\\n            \\n            // travel all sub string combinations\\n            int wl = L[0].size();\\n            for (int i = 0; i < wl; ++i) {\\n                int left = i, count = 0;\\n                unordered_map<string, int> tdict;\\n                for (int j = i; j <= n - wl; j += wl) {\\n                    string str = S.substr(j, wl);\\n                    // a valid word, accumulate results\\n                    if (dict.count(str)) {\\n                        tdict[str]++;\\n                        if (tdict[str] <= dict[str]) \\n                            count++;\\n                        else {\\n                            // a more word, advance the window left side possiablly\\n                            while (tdict[str] > dict[str]) {\\n                                string str1 = S.substr(left, wl);\\n                                tdict[str1]--;\\n                                if (tdict[str1] < dict[str1]) count--;\\n                                left += wl;\\n                            }\\n                        }\\n                        // come to a result\\n                        if (count == cnt) {\\n                            ans.push_back(left);\\n                            // advance one word\\n                            tdict[S.substr(left, wl)]--;\\n                            count--;\\n                            left += wl;\\n                        }\\n                    }\\n                    // not a valid word, reset all vars\\n                    else {\\n                        tdict.clear();\\n                        count = 0;\\n                        left = j + wl;\\n                    }\\n                }\\n            }\\n            \\n            return ans;\\n        }",
                "solutionTags": [],
                "code": "        // travel all the words combinations to maintain a window\\n        // there are wl(word len) times travel\\n        // each time, n/wl words, mostly 2 times travel for each word\\n        // one left side of the window, the other right side of the window\\n        // so, time complexity O(wl * 2 * N/wl) = O(2N)\\n        vector<int> findSubstring(string S, vector<string> &L) {\\n            vector<int> ans;\\n            int n = S.size(), cnt = L.size();\\n            if (n <= 0 || cnt <= 0) return ans;\\n            \\n            // init word occurence\\n            unordered_map<string, int> dict;\\n            for (int i = 0; i < cnt; ++i) dict[L[i]]++;\\n            \\n            // travel all sub string combinations\\n            int wl = L[0].size();\\n            for (int i = 0; i < wl; ++i) {\\n                int left = i, count = 0;\\n                unordered_map<string, int> tdict;\\n                for (int j = i; j <= n - wl; j += wl) {\\n                    string str = S.substr(j, wl);\\n                    // a valid word, accumulate results\\n                    if (dict.count(str)) {\\n                        tdict[str]++;\\n                        if (tdict[str] <= dict[str]) \\n                            count++;\\n                        else {\\n                            // a more word, advance the window left side possiablly\\n                            while (tdict[str] > dict[str]) {\\n                                string str1 = S.substr(left, wl);\\n                                tdict[str1]--;\\n                                if (tdict[str1] < dict[str1]) count--;\\n                                left += wl;\\n                            }\\n                        }\\n                        // come to a result\\n                        if (count == cnt) {\\n                            ans.push_back(left);\\n                            // advance one word\\n                            tdict[S.substr(left, wl)]--;\\n                            count--;\\n                            left += wl;\\n                        }\\n                    }\\n                    // not a valid word, reset all vars\\n                    else {\\n                        tdict.clear();\\n                        count = 0;\\n                        left = j + wl;\\n                    }\\n                }\\n            }\\n            \\n            return ans;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 13673,
                "title": "accepted-java-solution-12ms-with-explanation",
                "content": "It's not too hard to find some resemblance between this problem and [minimum-window-substring][1]. Actually the main difference is the fact that we are interested at some interval length: we want intervals with fixed length K * M, where K is the number of strings in the \"words\" array and M the length of each target string. In order to apply the same idea we used for that problem, all we need to do is to map each string from the \"words\" array to something we are able to index (I prefer to use hashing for this). Also, in order to speed up the algorithm, we can find all occurrences of those strings in S (which is equivalent to do it on demand, but we will potentially do the same matching twice). Notice that, we can simply apply these occurrences as they appear because we are assured that no word is contained by some other. Finally, we use all this information to process each possibility. Notice here that, the fact that all strings has the same length, implies that we have just M (being M the length of each target string) possible starting points, hence we end up performing M linear scans over array with length O(N/M) (being N the length of S) and that makes the scanning stage of the algorithm to be linear on the length of S.\\n\\n\\tpublic List<Integer> findSubstring(String s, String[] words) {\\n\\t\\tint N = s.length();\\n\\t\\tList<Integer> indexes = new ArrayList<Integer>(s.length());\\n\\t\\tif (words.length == 0) {\\n\\t\\t\\treturn indexes;\\n\\t\\t}\\n\\t\\tint M = words[0].length();\\n\\t\\tif (N < M * words.length) {\\n\\t\\t\\treturn indexes;\\n\\t\\t}\\n\\t\\tint last = N - M + 1;\\n\\t\\t\\n\\t\\t//map each string in words array to some index and compute target counters\\n\\t\\tMap<String, Integer> mapping = new HashMap<String, Integer>(words.length);\\n\\t\\tint [][] table = new int[2][words.length];\\n\\t\\tint failures = 0, index = 0;\\n\\t\\tfor (int i = 0; i < words.length; ++i) {\\n\\t\\t\\tInteger mapped = mapping.get(words[i]);\\n\\t\\t\\tif (mapped == null) {\\n\\t\\t\\t\\t++failures;\\n\\t\\t\\t\\tmapping.put(words[i], index);\\n\\t\\t\\t\\tmapped = index++;\\n\\t\\t\\t}\\n\\t\\t\\t++table[0][mapped];\\n\\t\\t}\\n\\t\\t\\n\\t\\t//find all occurrences at string S and map them to their current integer, -1 means no such string is in words array\\n\\t\\tint [] smapping = new int[last];\\n\\t\\tfor (int i = 0; i < last; ++i) {\\n\\t\\t\\tString section = s.substring(i, i + M);\\n\\t\\t\\tInteger mapped = mapping.get(section);\\n\\t\\t\\tif (mapped == null) {\\n\\t\\t\\t\\tsmapping[i] = -1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsmapping[i] = mapped;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t//fix the number of linear scans\\n\\t\\tfor (int i = 0; i < M; ++i) {\\n\\t\\t\\t//reset scan variables\\n\\t\\t\\tint currentFailures = failures; //number of current mismatches\\n\\t\\t\\tint left = i, right = i;\\n\\t\\t\\tArrays.fill(table[1], 0);\\n\\t\\t\\t//here, simple solve the minimum-window-substring problem\\n\\t\\t\\twhile (right < last) {\\n\\t\\t\\t\\twhile (currentFailures > 0 && right < last) {\\n\\t\\t\\t\\t\\tint target = smapping[right];\\n\\t\\t\\t\\t\\tif (target != -1 && ++table[1][target] == table[0][target]) {\\n\\t\\t\\t\\t\\t\\t--currentFailures;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tright += M;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\twhile (currentFailures == 0 && left < right) {\\n\\t\\t\\t\\t\\tint target = smapping[left];\\n\\t\\t\\t\\t\\tif (target != -1 && --table[1][target] == table[0][target] - 1) {\\n\\t\\t\\t\\t\\t\\tint length = right - left;\\n\\t\\t\\t\\t\\t\\t//instead of checking every window, we know exactly the length we want\\n\\t\\t\\t\\t\\t\\tif ((length / M) ==  words.length) {\\n\\t\\t\\t\\t\\t\\t\\tindexes.add(left);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t++currentFailures;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tleft += M;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\treturn indexes;\\n\\t}\\n\\n\\n  [1]: https://leetcode.com/problems/minimum-window-substring/",
                "solutionTags": [
                    "Java"
                ],
                "code": "It's not too hard to find some resemblance between this problem and [minimum-window-substring][1]. Actually the main difference is the fact that we are interested at some interval length: we want intervals with fixed length K * M, where K is the number of strings in the \"words\" array and M the length of each target string. In order to apply the same idea we used for that problem, all we need to do is to map each string from the \"words\" array to something we are able to index (I prefer to use hashing for this). Also, in order to speed up the algorithm, we can find all occurrences of those strings in S (which is equivalent to do it on demand, but we will potentially do the same matching twice). Notice that, we can simply apply these occurrences as they appear because we are assured that no word is contained by some other. Finally, we use all this information to process each possibility. Notice here that, the fact that all strings has the same length, implies that we have just M (being M the length of each target string) possible starting points, hence we end up performing M linear scans over array with length O(N/M) (being N the length of S) and that makes the scanning stage of the algorithm to be linear on the length of S.\\n\\n\\tpublic List<Integer> findSubstring(String s, String[] words) {\\n\\t\\tint N = s.length();\\n\\t\\tList<Integer> indexes = new ArrayList<Integer>(s.length());\\n\\t\\tif (words.length == 0) {\\n\\t\\t\\treturn indexes;\\n\\t\\t}\\n\\t\\tint M = words[0].length();\\n\\t\\tif (N < M * words.length) {\\n\\t\\t\\treturn indexes;\\n\\t\\t}\\n\\t\\tint last = N - M + 1;\\n\\t\\t\\n\\t\\t//map each string in words array to some index and compute target counters\\n\\t\\tMap<String, Integer> mapping = new HashMap<String, Integer>(words.length);\\n\\t\\tint [][] table = new int[2][words.length];\\n\\t\\tint failures = 0, index = 0;\\n\\t\\tfor (int i = 0; i < words.length; ++i) {\\n\\t\\t\\tInteger mapped = mapping.get(words[i]);\\n\\t\\t\\tif (mapped == null) {\\n\\t\\t\\t\\t++failures;\\n\\t\\t\\t\\tmapping.put(words[i], index);\\n\\t\\t\\t\\tmapped = index++;\\n\\t\\t\\t}\\n\\t\\t\\t++table[0][mapped];\\n\\t\\t}\\n\\t\\t\\n\\t\\t//find all occurrences at string S and map them to their current integer, -1 means no such string is in words array\\n\\t\\tint [] smapping = new int[last];\\n\\t\\tfor (int i = 0; i < last; ++i) {\\n\\t\\t\\tString section = s.substring(i, i + M);\\n\\t\\t\\tInteger mapped = mapping.get(section);\\n\\t\\t\\tif (mapped == null) {\\n\\t\\t\\t\\tsmapping[i] = -1;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tsmapping[i] = mapped;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\t//fix the number of linear scans\\n\\t\\tfor (int i = 0; i < M; ++i) {\\n\\t\\t\\t//reset scan variables\\n\\t\\t\\tint currentFailures = failures; //number of current mismatches\\n\\t\\t\\tint left = i, right = i;\\n\\t\\t\\tArrays.fill(table[1], 0);\\n\\t\\t\\t//here, simple solve the minimum-window-substring problem\\n\\t\\t\\twhile (right < last) {\\n\\t\\t\\t\\twhile (currentFailures > 0 && right < last) {\\n\\t\\t\\t\\t\\tint target = smapping[right];\\n\\t\\t\\t\\t\\tif (target != -1 && ++table[1][target] == table[0][target]) {\\n\\t\\t\\t\\t\\t\\t--currentFailures;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tright += M;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\twhile (currentFailures == 0 && left < right) {\\n\\t\\t\\t\\t\\tint target = smapping[left];\\n\\t\\t\\t\\t\\tif (target != -1 && --table[1][target] == table[0][target] - 1) {\\n\\t\\t\\t\\t\\t\\tint length = right - left;\\n\\t\\t\\t\\t\\t\\t//instead of checking every window, we know exactly the length we want\\n\\t\\t\\t\\t\\t\\tif ((length / M) ==  words.length) {\\n\\t\\t\\t\\t\\t\\t\\tindexes.add(left);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t++currentFailures;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tleft += M;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t}\\n\\t\\treturn indexes;\\n\\t}\\n\\n\\n  [1]: https://leetcode.com/problems/minimum-window-substring/",
                "codeTag": "Unknown"
            },
            {
                "id": 2418173,
                "title": "c-unordered-map-sliding-window-simple-easy-to-understand",
                "content": "**Approach :**  We are using Hashing & Sliding Window Technique to solve the above problem.\\n \\n**Let\\u2019s see the steps :**\\n\\n1. Declare a map `wordCount` which stores all words count\\n2. Select a window of size `wordsWindow` (total number of characters produced if all the words are concatenated).\\n3. Check if that window is possible to build using our `wordCount` map.\\n4. If `True`, add the starting index to our result vector\\n5. Increasing the window by 1 & check until we are able to select `wordsWindow` size window.\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    bool checkSubstring(unordered_map<string, int> wordCount, string s, int wordLen) {\\n        for(int j=0; j<s.size(); j+=wordLen) {\\n            string w = s.substr(j, wordLen);\\n            if(wordCount.find(w) != wordCount.end()) {\\n                if(--wordCount[w] == -1) {\\n                    return false;\\n                }\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> res;\\n        int wordLen = words[0].size();\\n        int sLen = s.size();\\n        int wordsWindow = words.size() * wordLen;\\n        \\n        unordered_map<string, int> wordCount;\\n        for(int i=0; i<words.size(); i++) {\\n            wordCount[words[i]]++;\\n        }\\n        \\n        int i = 0;\\n        while(i + wordsWindow <= sLen) {\\n            if(checkSubstring(wordCount, s.substr(i, wordsWindow), wordLen)) {\\n                res.push_back(i);\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    bool checkSubstring(unordered_map<string, int> wordCount, string s, int wordLen) {\\n        for(int j=0; j<s.size(); j+=wordLen) {\\n            string w = s.substr(j, wordLen);\\n            if(wordCount.find(w) != wordCount.end()) {\\n                if(--wordCount[w] == -1) {\\n                    return false;\\n                }\\n            } else {\\n                return false;\\n            }\\n        }\\n        return true;\\n    }\\n\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> res;\\n        int wordLen = words[0].size();\\n        int sLen = s.size();\\n        int wordsWindow = words.size() * wordLen;\\n        \\n        unordered_map<string, int> wordCount;\\n        for(int i=0; i<words.size(); i++) {\\n            wordCount[words[i]]++;\\n        }\\n        \\n        int i = 0;\\n        while(i + wordsWindow <= sLen) {\\n            if(checkSubstring(wordCount, s.substr(i, wordsWindow), wordLen)) {\\n                res.push_back(i);\\n            }\\n            i++;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1753357,
                "title": "clear-solution-easy-to-understand-with-diagrams-o-n-x-w-approach",
                "content": "Let\\'s just take one example for reference: \\n\\n\\n**Input**: \\n\\n**s** = \"wordbestgoodwordword\", **words** = [\"word\",\"good\",\"best\",\"word\"]\\n\\nlet **w** be the length of each word in words array.\\nlet **m** be the length of words array.\\nlet **n** be the lenth of s string. \\n\\nNow let\\'s define a subproblem(i) as whether index i is present in our answer or not ? (let\\'s take i = 0 for example)\\n\\nNow, index i will be present in our answer if substring of s ( i,  i+(m x w) ), if broken to w length pieces, contains all the words in the words array in any order.\\n\\n![image](https://assets.leetcode.com/users/images/7c57e142-edca-44f5-889b-4697398bad03_1644254764.2690675.png)\\n\\n\\nSo, in a standard brute force approach **how can we just solve subproblem(i) ???**\\n\\nCreate a hashmap storing what all is present in words array. \\nStart from index i consumng w length m sub-strings, storing in another hashmap to keep track of what is observed. \\nif two hash-maps match at the end, subproblem(i) tells i should be present in our answer. \\n\\nQuick time complexity check for solving a single subproblem(i) is O(w x m)\\n\\n*This is very easy, and I hope everyone reached till here.* \\n\\nNow, we can finally solve subproblem(i) like above for each possible i the s string, ie i can range from 0 to n-1,\\n\\nQuick time complexity check for solving a single subproblem(i) is O(n x (w x m)). Now this is cubic complexity and we do not want this. \\n\\nNow, always remember whenever we want to optimise an approach, we want to re-use already done computations. \\n\\n### Can we re-use previously done computations in this problem ???\\n\\nLet us assume we solved the sub-problem(i), where can be re-use it: \\n\\nNow, while solving the sub-problem(i), we generate a hash-map of observed words. Can we reuse this hash-map for other sub-problems ?? \\n\\n![image](https://assets.leetcode.com/users/images/4b034119-e729-436d-8ebb-9ae0dc230ca7_1644255347.323178.png)\\n\\nNow let\\'s see how the sub-problem(i+1) looks ? \\n\\n![image](https://assets.leetcode.com/users/images/f6c00157-6b27-4ce8-9aab-854c7598ea97_1644255670.64441.png)\\n\\nNow the hash-map created in sub-problem(i) cannot be used in sub-problem(i+1) because w length words have completely changed now. \\n\\nBut, the hash-map created in sub-problem(i), can be re-used (after removing w length word starting with i) for sub-problem(i+w) because intermediate 3 words of length w remain same. \\n\\n![image](https://assets.leetcode.com/users/images/1530055a-0e3c-4ca0-8040-14765662a1f4_1644255864.0705793.png)\\n\\nSo, computations made in subproblem(i) can be re-used in sub-problem(i+w).\\nSimilarly, computations made in subproblem(i+w) can be re-used in sub-problem(i+2 x w) \\n\\n     i  ---> i+w ---> i+2w ----> i+3w ----> i+4w  (These all can re-use their computations)\\n\\t \\nQuick, time complexity check: \\n           solving for sub-problems i, i+w, i+2xw,..... sequentially would require O(n) time complexity. \\n\\t\\t                for solving sub-problem(i), it took us O(m x w).\\n\\t\\t\\t\\t\\t\\tfor next sub-problem(i+w), it took us just O(w), removing initial w character, adding latter w character.\\n\\t\\t\\t\\t\\t\\tso, to solve all problems, we effectively consume all array elements atmost O(1) \\n\\t\\t\\t\\t\\t\\tSo, total time complexity for this is O(n)\\nSimilarly, we can solve many such subproblems together, using computations of previous sub-problems\\n\\nThese all go together re-using previous computations: *(this alone is a standard sliding window problem)*\\n\\n            i  ---> i+w ---> i+2w ----> i+3w ----> i+4w \\n\\t\\t\\t\\nThese all go together re-using previous computations: *(this alone is a standard sliding window problem)*\\n\\n            (i+1)  ---> (i+1)+w ---> (i+1)+2w ----> (i+1)+3w ----> (i+1)+4w \\n\\nThese all go together re-using previous computations: *(this alone is a standard sliding window problem)*\\n\\n            (i+2)  ---> (i+2)+w ---> (i+2)+2w ----> (i+2)+3w ----> (i+2)+4w \\n\\t\\t\\t\\nThese all go together re-using previous computations: *(this alone is a standard sliding window problem)*\\n\\n            (i+3)  ---> (i+3)+w ---> (i+3)+2w ----> (i+3)+3w ----> (i+3)+4w \\n\\t\\t\\t\\nNow, we realise all the subproblems are solved: because i+4 was solved in first iteration as w here is 4.\\n\\nSo, we need to do w such iterations above and each iteration take O(n) time. So, total time complexity is O(n x w).\\n\\nSo, this problem effectively is a combination of w sliding window problems. \\n\\n\\n\\n",
                "solutionTags": [],
                "code": "Let\\'s just take one example for reference: \\n\\n\\n**Input**: \\n\\n**s** = \"wordbestgoodwordword\", **words** = [\"word\",\"good\",\"best\",\"word\"]\\n\\nlet **w** be the length of each word in words array.\\nlet **m** be the length of words array.\\nlet **n** be the lenth of s string. \\n\\nNow let\\'s define a subproblem(i) as whether index i is present in our answer or not ? (let\\'s take i = 0 for example)\\n\\nNow, index i will be present in our answer if substring of s ( i,  i+(m x w) ), if broken to w length pieces, contains all the words in the words array in any order.\\n\\n![image](https://assets.leetcode.com/users/images/7c57e142-edca-44f5-889b-4697398bad03_1644254764.2690675.png)\\n\\n\\nSo, in a standard brute force approach **how can we just solve subproblem(i) ???**\\n\\nCreate a hashmap storing what all is present in words array. \\nStart from index i consumng w length m sub-strings, storing in another hashmap to keep track of what is observed. \\nif two hash-maps match at the end, subproblem(i) tells i should be present in our answer. \\n\\nQuick time complexity check for solving a single subproblem(i) is O(w x m)\\n\\n*This is very easy, and I hope everyone reached till here.* \\n\\nNow, we can finally solve subproblem(i) like above for each possible i the s string, ie i can range from 0 to n-1,\\n\\nQuick time complexity check for solving a single subproblem(i) is O(n x (w x m)). Now this is cubic complexity and we do not want this. \\n\\nNow, always remember whenever we want to optimise an approach, we want to re-use already done computations. \\n\\n### Can we re-use previously done computations in this problem ???\\n\\nLet us assume we solved the sub-problem(i), where can be re-use it: \\n\\nNow, while solving the sub-problem(i), we generate a hash-map of observed words. Can we reuse this hash-map for other sub-problems ?? \\n\\n![image](https://assets.leetcode.com/users/images/4b034119-e729-436d-8ebb-9ae0dc230ca7_1644255347.323178.png)\\n\\nNow let\\'s see how the sub-problem(i+1) looks ? \\n\\n![image](https://assets.leetcode.com/users/images/f6c00157-6b27-4ce8-9aab-854c7598ea97_1644255670.64441.png)\\n\\nNow the hash-map created in sub-problem(i) cannot be used in sub-problem(i+1) because w length words have completely changed now. \\n\\nBut, the hash-map created in sub-problem(i), can be re-used (after removing w length word starting with i) for sub-problem(i+w) because intermediate 3 words of length w remain same. \\n\\n![image](https://assets.leetcode.com/users/images/1530055a-0e3c-4ca0-8040-14765662a1f4_1644255864.0705793.png)\\n\\nSo, computations made in subproblem(i) can be re-used in sub-problem(i+w).\\nSimilarly, computations made in subproblem(i+w) can be re-used in sub-problem(i+2 x w) \\n\\n     i  ---> i+w ---> i+2w ----> i+3w ----> i+4w  (These all can re-use their computations)\\n\\t \\nQuick, time complexity check: \\n           solving for sub-problems i, i+w, i+2xw,..... sequentially would require O(n) time complexity. \\n\\t\\t                for solving sub-problem(i), it took us O(m x w).\\n\\t\\t\\t\\t\\t\\tfor next sub-problem(i+w), it took us just O(w), removing initial w character, adding latter w character.\\n\\t\\t\\t\\t\\t\\tso, to solve all problems, we effectively consume all array elements atmost O(1) \\n\\t\\t\\t\\t\\t\\tSo, total time complexity for this is O(n)\\nSimilarly, we can solve many such subproblems together, using computations of previous sub-problems\\n\\nThese all go together re-using previous computations: *(this alone is a standard sliding window problem)*\\n\\n            i  ---> i+w ---> i+2w ----> i+3w ----> i+4w \\n\\t\\t\\t\\nThese all go together re-using previous computations: *(this alone is a standard sliding window problem)*\\n\\n            (i+1)  ---> (i+1)+w ---> (i+1)+2w ----> (i+1)+3w ----> (i+1)+4w \\n\\nThese all go together re-using previous computations: *(this alone is a standard sliding window problem)*\\n\\n            (i+2)  ---> (i+2)+w ---> (i+2)+2w ----> (i+2)+3w ----> (i+2)+4w \\n\\t\\t\\t\\nThese all go together re-using previous computations: *(this alone is a standard sliding window problem)*\\n\\n            (i+3)  ---> (i+3)+w ---> (i+3)+2w ----> (i+3)+3w ----> (i+3)+4w \\n\\t\\t\\t\\nNow, we realise all the subproblems are solved: because i+4 was solved in first iteration as w here is 4.\\n\\nSo, we need to do w such iterations above and each iteration take O(n) time. So, total time complexity is O(n x w).\\n\\nSo, this problem effectively is a combination of w sliding window problems. \\n\\n\\n\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 13664,
                "title": "simple-java-solution-with-two-pointers-and-map",
                "content": "My idea is pretty simple. Just build a map for the words and their relative count in L. Then we traverse through S to check whether there is a match.\\n\\n    public static List<Integer> findSubstring(String S, String[] L) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        if (S == null || L == null || L.length == 0) return res;\\n        int len = L[0].length(); // length of each word\\n        \\n        Map<String, Integer> map = new HashMap<String, Integer>(); // map for L\\n        for (String w : L) map.put(w, map.containsKey(w) ? map.get(w) + 1 : 1);\\n        \\n        for (int i = 0; i <= S.length() - len * L.length; i++) {\\n            Map<String, Integer> copy = new HashMap<String, Integer>(map);\\n            for (int j = 0; j < L.length; j++) { // checkc if match\\n                String str = S.substring(i + j*len, i + j*len + len); // next word\\n                if (copy.containsKey(str)) { // is in remaining words\\n                    int count = copy.get(str);\\n                    if (count == 1) copy.remove(str);\\n                    else copy.put(str, count - 1);\\n                    if (copy.isEmpty()) { // matches\\n                        res.add(i);\\n                        break;\\n                    }\\n                } else break; // not in L\\n            }\\n        }\\n        return res;\\n    }\\n\\nAt first I was gonna to use a set for words. Owing to the fact that duplicate is allowed in L, we need to use map instead.",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "My idea is pretty simple. Just build a map for the words and their relative count in L. Then we traverse through S to check whether there is a match.\\n\\n    public static List<Integer> findSubstring(String S, String[] L) {\\n        List<Integer> res = new ArrayList<Integer>();\\n        if (S == null || L == null || L.length == 0) return res;\\n        int len = L[0].length(); // length of each word\\n        \\n        Map<String, Integer> map = new HashMap<String, Integer>(); // map for L\\n        for (String w : L) map.put(w, map.containsKey(w) ? map.get(w) + 1 : 1);\\n        \\n        for (int i = 0; i <= S.length() - len * L.length; i++) {\\n            Map<String, Integer> copy = new HashMap<String, Integer>(map);\\n            for (int j = 0; j < L.length; j++) { // checkc if match\\n                String str = S.substring(i + j*len, i + j*len + len); // next word\\n                if (copy.containsKey(str)) { // is in remaining words\\n                    int count = copy.get(str);\\n                    if (count == 1) copy.remove(str);\\n                    else copy.put(str, count - 1);\\n                    if (copy.isEmpty()) { // matches\\n                        res.add(i);\\n                        break;\\n                    }\\n                } else break; // not in L\\n            }\\n        }\\n        return res;\\n    }\\n\\nAt first I was gonna to use a set for words. Owing to the fact that duplicate is allowed in L, we need to use map instead.",
                "codeTag": "Unknown"
            },
            {
                "id": 2419817,
                "title": "python-easily-understood-faster-than-96-less-than-78-o-nm",
                "content": "Method: `Hash Table`\\n\\nFirst we can create a `dict` to store the occurrence times for each word in `words`.\\n\\nFor example,\\nIf `s = \"barfoofoobarthefoobarman\"` and `words = [\"bar\",\"foo\",\"the\"]`, \\nthe dict will be `word_count = {\\'bar\\': 1, \\'foo\\': 1, \\'the\\': 1}`,\\n\\nSince all the strings stored in `words` have the same length, the size of **sliding window** will be the word length of a single string. In the example above, the **sliding window** will be `3`\\n\\n![image](https://assets.leetcode.com/users/images/e6551130-deeb-49fe-a6a6-bf16815b413b_1660394841.6954787.png)\\n```\\nbar -> foo -> foo -> bar -> the -> foo -> bar -> man\\nignore b -> arf -> oof -> oob -> art -> hef -> oob -> arm -> ignore an\\nignore ba -> rfo -> ofo -> oba -> rth -> efo -> oba -> rma -> ignore n\\n```\\nThen, we can scan `s` in these 3 ways one by one\\n\\nLet the word in **sliding window** be `word`.\\nAlso, we will create a `queue` to store the scan history.\\n```\\n1) word_count.get(word, 0) >= 0 \\n    -> word_count[word] -= 1 as it uses one of the string in words\\n\\t-> queue.append(word)\\n\\t\\n2) word_count.get(word, 0) == 0 \\n    -> while queue.pop()\\n\\t\\t-> queue.pop() == word\\n\\t\\t\\t-> queue.append(queue.pop()) # Only the beginning word is dropped, the remaining words are still in use\\n\\t\\t\\t-> break\\n\\t\\t-> queue.pop() != word\\n\\t\\t\\t# Since the beginning word is dropped, the count of beginning word should be added 1.\\n\\t\\t\\t-> word_dict[last_element] += 1\\n\\t\\t\\t\\t-> word_dict[last_element] exceeds its original value, reset the whole word_dict\\n\\t\\t\\t-> continue\\n```\\nCode:\\n```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        word_len = len(words[0])\\n        ori_word_dict = defaultdict(int)\\n\\t\\t\\n        for word in words:\\n            ori_word_dict[word] += 1\\n        \\n        all_word_len = len(words) * word_len\\n        result = []\\n        for i in range(word_len):\\n            queue = deque()\\n            word_dict = ori_word_dict.copy()\\n            for j in range(i, len(s) - word_len + 1, word_len):\\n                word = s[j:j + word_len]\\n                if word_dict.get(word, 0) != 0:\\n                    word_dict[word] -= 1\\n                    queue.append(word)\\n                    if sum(word_dict.values()) == 0:\\n                        result.append(j - all_word_len + word_len)\\n                        last_element = queue.popleft()\\n                        word_dict[last_element] = word_dict.get(last_element, 0) + 1\\n                else:\\n                    while len(queue):\\n                        last_element = queue.popleft()\\n                        if last_element == word:\\n                            queue.append(word)\\n                            break\\n                        else:\\n                            word_dict[last_element] = word_dict.get(last_element, 0) + 1\\n                            if word_dict[last_element] > ori_word_dict[last_element]:\\n                                word_dict = ori_word_dict.copy()\\n\\n        return result\\n```\\n\\nLet `n` be the length of a word in `words`\\nand `m` be the total number of words in `words`\\n\\n**Time complexity**: `O(n * m)`\\n**Space complexity**: `O(n + m)`\\n<br/>",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nbar -> foo -> foo -> bar -> the -> foo -> bar -> man\\nignore b -> arf -> oof -> oob -> art -> hef -> oob -> arm -> ignore an\\nignore ba -> rfo -> ofo -> oba -> rth -> efo -> oba -> rma -> ignore n\\n```\n```\\n1) word_count.get(word, 0) >= 0 \\n    -> word_count[word] -= 1 as it uses one of the string in words\\n\\t-> queue.append(word)\\n\\t\\n2) word_count.get(word, 0) == 0 \\n    -> while queue.pop()\\n\\t\\t-> queue.pop() == word\\n\\t\\t\\t-> queue.append(queue.pop()) # Only the beginning word is dropped, the remaining words are still in use\\n\\t\\t\\t-> break\\n\\t\\t-> queue.pop() != word\\n\\t\\t\\t# Since the beginning word is dropped, the count of beginning word should be added 1.\\n\\t\\t\\t-> word_dict[last_element] += 1\\n\\t\\t\\t\\t-> word_dict[last_element] exceeds its original value, reset the whole word_dict\\n\\t\\t\\t-> continue\\n```\n```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        word_len = len(words[0])\\n        ori_word_dict = defaultdict(int)\\n\\t\\t\\n        for word in words:\\n            ori_word_dict[word] += 1\\n        \\n        all_word_len = len(words) * word_len\\n        result = []\\n        for i in range(word_len):\\n            queue = deque()\\n            word_dict = ori_word_dict.copy()\\n            for j in range(i, len(s) - word_len + 1, word_len):\\n                word = s[j:j + word_len]\\n                if word_dict.get(word, 0) != 0:\\n                    word_dict[word] -= 1\\n                    queue.append(word)\\n                    if sum(word_dict.values()) == 0:\\n                        result.append(j - all_word_len + word_len)\\n                        last_element = queue.popleft()\\n                        word_dict[last_element] = word_dict.get(last_element, 0) + 1\\n                else:\\n                    while len(queue):\\n                        last_element = queue.popleft()\\n                        if last_element == word:\\n                            queue.append(word)\\n                            break\\n                        else:\\n                            word_dict[last_element] = word_dict.get(last_element, 0) + 1\\n                            if word_dict[last_element] > ori_word_dict[last_element]:\\n                                word_dict = ori_word_dict.copy()\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13700,
                "title": "my-ac-c-code-o-n-complexity-26ms",
                "content": "    class Solution {\\n    // The general idea:\\n    // Construct a hash function f for L, f: vector<string> -> int, \\n    // Then use the return value of f to check whether a substring is a concatenation \\n    // of all words in L.\\n    // f has two levels, the first level is a hash function f1 for every single word in L.\\n    // f1 : string -> double\\n    // So with f1, L is converted into a vector of float numbers\\n    // Then another hash function f2 is defined to convert a vector of doubles into a single int.\\n    // Finally f(L) := f2(f1(L))\\n    // To obtain lower complexity, we require f1 and f2 can be computed through moving window.\\n    // The following corner case also needs to be considered:\\n    // f2(f1([\"ab\", \"cd\"])) != f2(f1([\"ac\", \"bd\"]))\\n    // There are many possible options for f2 and f1. \\n    // The following code only shows one possibility (probably not the best), \\n    // f2 is the function \"hash\" in the class,\\n    // f1([a1, a2, ... , an]) := int( decimal_part(log(a1) + log(a2) + ... + log(an)) * 1000000000 )\\n    public:\\n        // The complexity of this function is O(nW).\\n        double hash(double f, double code[], string &word) {\\n            double result = 0.;\\n            for (auto &c : word) result = result * f + code[c];\\n            return result;\\n        }\\n        vector<int> findSubstring(string S, vector<string> &L) {\\n            uniform_real_distribution<double> unif(0., 1.);\\n            default_random_engine seed;\\n            double code[128];\\n            for (auto &d : code) d = unif(seed);\\n            double f = unif(seed) / 5. + 0.8;\\n            double value = 0;\\n\\n            // The complexity of the following for loop is O(L.size( ) * nW).\\n            for (auto &str : L) value += log(hash(f, code, str));\\n\\n            int unit = 1e9;\\n            int key = (value-floor(value))*unit;\\n            int nS = S.size(), nL = L.size(), nW = L[0].size();\\n            double fn = pow(f, nW-1.);\\n            vector<int> result;\\n            if (nS < nW) return result;\\n            vector<double> values(nS-nW+1);\\n            string word(S.begin(), S.begin()+nW);\\n            values[0] = hash(f, code, word);\\n\\n            // Use a moving window to hash every word with length nW in S to a float number, \\n            // which is stored in vector values[]\\n            // The complexity of this step is O(nS).\\n            for (int i=1; i<=nS-nW; ++i) values[i] = (values[i-1] - code[S[i-1]]*fn)*f + code[S[i+nW-1]];\\n\\n            // This for loop will run nW times, each iteration has a complexity O(nS/nW)\\n            // So the overall complexity is O(nW * (nS / nW)) = O(nS)\\n            for (int i=0; i<nW; ++i) {\\n                int j0=i, j1=i, k=0;\\n                double sum = 0.;\\n\\n                // Use a moving window to hash every L.size() continuous words with length nW in S.\\n                // This while loop will terminate within nS/nW iterations since the increasement of j1 is nW,\\n                // So the complexity of this while loop is O(nS / nW).\\n                while(j1<=nS-nW) {\\n                    sum += log(values[j1]);\\n                    ++k;\\n                    j1 += nW;\\n                    if (k==nL) {\\n                        int key1 = (sum-floor(sum)) * unit;\\n                        if (key1==key) result.push_back(j0);\\n                        sum -= log(values[j0]);\\n                        --k;\\n                        j0 += nW;\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    };\\n\\nThough theoretically it has a very small chance to fail.",
                "solutionTags": [],
                "code": "class Solution {\\n    // The general idea:\\n    // Construct a hash function f for L, f: vector<string> -> int, \\n    // Then use the return value of f to check whether a substring is a concatenation \\n    // of all words in L.\\n    // f has two levels, the first level is a hash function f1 for every single word in L.\\n    // f1 : string -> double\\n    // So with f1, L is converted into a vector of float numbers\\n    // Then another hash function f2 is defined to convert a vector of doubles into a single int.\\n    // Finally f(L) := f2(f1(L))\\n    // To obtain lower complexity, we require f1 and f2 can be computed through moving window.\\n    // The following corner case also needs to be considered:\\n    // f2(f1([\"ab\", \"cd\"])) != f2(f1([\"ac\", \"bd\"]))\\n    // There are many possible options for f2 and f1. \\n    // The following code only shows one possibility (probably not the best), \\n    // f2 is the function \"hash\" in the class,\\n    // f1([a1, a2, ... , an]) := int( decimal_part(log(a1) + log(a2) + ... + log(an)) * 1000000000 )\\n    public:\\n        // The complexity of this function is O(nW).\\n        double hash(double f, double code[], string &word) {\\n            double result = 0.;\\n            for (auto &c : word) result = result * f + code[c];\\n            return result;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 13667,
                "title": "ac-python-80ms-solution-dictionary-and-two-pointers",
                "content": "    def _findSubstring(self, l, r, n, k, t, s, req, ans):\\n        curr = {}\\n        while r + k <= n:\\n            w = s[r:r + k]\\n            r += k\\n            if w not in req:\\n                l = r\\n                curr.clear()\\n            else:\\n                curr[w] = curr[w] + 1 if w in curr else 1\\n                while curr[w] > req[w]:\\n                    curr[s[l:l + k]] -= 1\\n                    l += k\\n                if r - l == t:\\n                    ans.append(l)\\n\\n    def findSubstring(self, s, words):\\n        if not s or not words or not words[0]:\\n            return []\\n        n = len(s)\\n        k = len(words[0])\\n        t = len(words) * k\\n        req = {}\\n        for w in words:\\n            req[w] = req[w] + 1 if w in req else 1\\n        ans = []\\n        for i in xrange(min(k, n - t + 1)):\\n            self._findSubstring(i, i, n, k, t, s, req, ans)\\n        return ans\\n\\n\\n    # 169 / 169 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 80 ms\\n    # 98.60%\\n\\n\\nFirst of all consider s as several series of  words with length k starting at [0, k-1]. For example \"barfoothe\" with k = 3, can be view as [\"bar\", \"foo\", \"the\"] for i=0 and [\"arf\", \"oot\"] for i = 1 and [\"rfo\", \"oth\"] for i = 2.\\nThus we need to check each  of these series and find out the valid index by definition.\\n\\nFor each series, we just need to check if there exist a range [l, r) where the occurrence or \"spectrum\" of the words in the range is the same as our given word list's \"spectrum\". We use dictionary to store the spectrum and maintain it as we loop through s.\\n\\ncollections.Counter class may save a bit of code on updating the counts of the dictionary. However plain dict wins on the speed.",
                "solutionTags": [],
                "code": "    def _findSubstring(self, l, r, n, k, t, s, req, ans):\\n        curr = {}\\n        while r + k <= n:\\n            w = s[r:r + k]\\n            r += k\\n            if w not in req:\\n                l = r\\n                curr.clear()\\n            else:\\n                curr[w] = curr[w] + 1 if w in curr else 1\\n                while curr[w] > req[w]:\\n                    curr[s[l:l + k]] -= 1\\n                    l += k\\n                if r - l == t:\\n                    ans.append(l)\\n\\n    def findSubstring(self, s, words):\\n        if not s or not words or not words[0]:\\n            return []\\n        n = len(s)\\n        k = len(words[0])\\n        t = len(words) * k\\n        req = {}\\n        for w in words:\\n            req[w] = req[w] + 1 if w in req else 1\\n        ans = []\\n        for i in xrange(min(k, n - t + 1)):\\n            self._findSubstring(i, i, n, k, t, s, req, ans)\\n        return ans\\n\\n\\n    # 169 / 169 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 80 ms\\n    # 98.60%\\n\\n\\nFirst of all consider s as several series of  words with length k starting at [0, k-1]. For example \"barfoothe\" with k = 3, can be view as [\"bar\", \"foo\", \"the\"] for i=0 and [\"arf\", \"oot\"] for i = 1 and [\"rfo\", \"oth\"] for i = 2.\\nThus we need to check each  of these series and find out the valid index by definition.\\n\\nFor each series, we just need to check if there exist a range [l, r) where the occurrence or \"spectrum\" of the words in the range is the same as our given word list's \"spectrum\". We use dictionary to store the spectrum and maintain it as we loop through s.\\n\\ncollections.Counter class may save a bit of code on updating the counts of the dictionary. However plain dict wins on the speed.",
                "codeTag": "Java"
            },
            {
                "id": 13669,
                "title": "99ms-python-o-kmn-solution",
                "content": "The idea comes from [https://leetcode.com/discuss/20151/an-o-n-solution-with-detailed-explanation]\\n\\nUsing a counter and a sliding window, we push the window from left to right, counting the number of valid words in the window. When the number of a word in the window is more than the times it appears in **words** or we meet a invalid word, push the window.\\n\\n    class Solution:\\n\\t# @param {string} s\\n\\t# @param {string[]} words\\n\\t# @return {integer[]}\\n\\tdef findSubstring(self, s, words):\\n\\t\\tif len(words) == 0:\\n\\t\\t\\treturn []\\n\\t\\t# initialize d, l, ans\\n\\t\\tl = len(words[0])\\n\\t\\td = {}\\n\\t\\tfor w in words:\\n\\t\\t\\tif w in d:\\n\\t\\t\\t\\td[w] += 1\\n\\t\\t\\telse:\\n\\t\\t\\t\\td[w] = 1\\n\\t\\ti = 0\\n\\t\\tans = []\\n\\n\\t\\t# sliding window(s)\\n\\t\\tfor k in range(l):\\n\\t\\t\\tleft = k\\n\\t\\t\\tsubd = {}\\n\\t\\t\\tcount = 0\\n\\t\\t\\tfor j in xrange(k, len(s)-l+1, l):\\n\\t\\t\\t\\ttword = s[j:j+l]\\n\\t\\t\\t\\t# valid word\\n\\t\\t\\t\\tif tword in d:\\n\\t\\t\\t\\t\\tif tword in subd:\\n\\t\\t\\t\\t\\t\\tsubd[tword] += 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\tsubd[tword] = 1\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\t\\twhile subd[tword] > d[tword]:\\n\\t\\t\\t\\t\\t\\tsubd[s[left:left+l]] -= 1\\n\\t\\t\\t\\t\\t\\tleft += l\\n\\t\\t\\t\\t\\t\\tcount -= 1\\n\\t\\t\\t\\t\\tif count == len(words):\\n\\t\\t\\t\\t\\t\\tans.append(left)\\n\\t\\t\\t\\t# not valid\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tleft = j + l\\n\\t\\t\\t\\t\\tsubd = {}\\n\\t\\t\\t\\t\\tcount = 0\\n\\n\\t\\treturn ans\\n\\nAssuming we have k words in **words**, and there are m substrings in the string, the complexity is O(kmn) because we need to adjust the window when more valid words are found.\\n\\nThis solution runs 99ms on OJ.",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n\\t# @param {string}",
                "codeTag": "Java"
            },
            {
                "id": 2417727,
                "title": "python-90-with-detailed-explanation-sliding-windows-using-counter",
                "content": "![image](https://assets.leetcode.com/users/images/4a450c74-27dd-4de5-a764-d70851ce0378_1660399303.2203338.jpeg)\\n\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wlen = len(words[0])\\n        wslen = len(words) * len(words[0])\\n        res = []\\n        \\n        for pos in range(wlen):\\n            i = pos\\n            d = Counter(words)\\n            \\n            for j in range(i, len(s) + 1 - wlen, wlen):\\n                word = s[j: j + wlen]\\n                d[word] -= 1\\n                \\n                while d[word] < 0:\\n                    d[s[i: i + wlen]] += 1\\n                    i += wlen\\n                if i + wslen == j + wlen:\\n                    res. append(i)\\n        \\n        return res\\n```\\n**Please UPVOTE if you LIKE**\\n![image](https://assets.leetcode.com/users/images/962eda17-1c28-4f38-be08-3d812101817c_1660399631.2653482.png)\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wlen = len(words[0])\\n        wslen = len(words) * len(words[0])\\n        res = []\\n        \\n        for pos in range(wlen):\\n            i = pos\\n            d = Counter(words)\\n            \\n            for j in range(i, len(s) + 1 - wlen, wlen):\\n                word = s[j: j + wlen]\\n                d[word] -= 1\\n                \\n                while d[word] < 0:\\n                    d[s[i: i + wlen]] += 1\\n                    i += wlen\\n                if i + wslen == j + wlen:\\n                    res. append(i)\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2992611,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n\\tstruct matcher {\\n\\t\\tstruct info { int mtindex, count; };\\n\\t\\tunordered_map<string_view, info>dict;\\n\\t\\tint different_word_count;\\n\\n\\t\\tvector<int>slot;\\n\\t\\tint maching_slot_count;\\n\\n\\t\\tmatcher(const vector<string>& words) {\\n\\t\\t\\tint mtind = 0;\\n\\t\\t\\tfor (auto& word : words) {\\n\\t\\t\\t\\tauto find = dict.find(word);\\n\\t\\t\\t\\tif (find != dict.end()) {\\n\\t\\t\\t\\t\\t++find->second.count;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse { dict[word] = { mtind++,1 }; }\\n\\t\\t\\t}\\n\\t\\t\\tdifferent_word_count = mtind;\\n\\t\\t\\tslot = vector<int>(different_word_count, 0);\\n\\t\\t\\tmaching_slot_count = 0;\\n\\t\\t}\\n\\n\\t\\tvoid reset() {\\n\\t\\t\\tfor (auto& i : slot) { i = 0; }\\n\\t\\t\\tmaching_slot_count = 0;\\n\\t\\t}\\n\\t\\tbool match() {\\n\\t\\t\\treturn maching_slot_count == different_word_count;\\n\\t\\t}\\n\\t\\tvoid push(string_view sv) {\\n\\t\\t\\tauto find = dict.find(sv);\\n\\t\\t\\tif (find == dict.end())return;\\n\\t\\t\\tif (++slot[find->second.mtindex] == find->second.count) {\\n\\t\\t\\t\\t++maching_slot_count;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvoid pop(string_view sv) {\\n\\t\\t\\tauto find = dict.find(sv);\\n\\t\\t\\tif (find == dict.end())return;\\n\\t\\t\\tif (--slot[find->second.mtindex] == find->second.count - 1) {\\n\\t\\t\\t\\t--maching_slot_count;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\tvector<int> findSubstring(string s, const vector<string>& words) {\\n\\t\\tint word_count = words.size();\\n\\t\\tint word_len = words[0].size();\\n\\n\\t\\tmatcher matcher(words);\\n\\n\\t\\tconst char* str = s.c_str();\\n\\t\\tint len = s.size();\\n\\t\\tvector<int> ret;\\n\\n\\t\\tfor (int off = 0; off < word_len; off++) {\\n\\t\\t\\tconst char* beg = str + off, * end = str + len;\\n\\t\\t\\tif (beg + word_len * word_count <= end) {\\n\\t\\t\\t\\tmatcher.reset();\\n\\t\\t\\t\\tfor (int i = 0; i < word_count; i++) {\\n\\t\\t\\t\\t\\tstring_view sv(beg + i * word_len, word_len);\\n\\t\\t\\t\\t\\tmatcher.push(sv);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (matcher.match()) {\\n\\t\\t\\t\\t\\tret.push_back(beg - str);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tconst char* pos = beg + word_len * word_count;\\n\\t\\t\\t\\twhile (pos + word_len <= end) {\\n\\t\\t\\t\\t\\tstring_view del(beg, word_len);\\n\\t\\t\\t\\t\\tstring_view add(pos, word_len);\\n\\t\\t\\t\\t\\tbeg += word_len;\\n\\t\\t\\t\\t\\tpos += word_len;\\n\\t\\t\\t\\t\\tmatcher.pop(del);\\n\\t\\t\\t\\t\\tmatcher.push(add);\\n\\t\\t\\t\\t\\tif (matcher.match()) {\\n\\t\\t\\t\\t\\t\\tret.push_back(beg - str);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        n_word = len(words)\\n        n_char = len(words[0])\\n        word2freq = {}\\n        for word in words:\\n            if word in word2freq:\\n                word2freq[word] += 1\\n            else:\\n                word2freq[word] = 1\\n\\n        all_start_ind = []\\n        for start_ind in range(n_char):\\n            curr_map = {}\\n            curr_total = 0\\n            excessive = False\\n            for i in range(start_ind, len(s), n_char):\\n                word = s[i:i+n_char]\\n                if word in word2freq: # a valid word for permutation \\n                    curr_total += 1\\n                    if word in curr_map: # found valid word\\n                        curr_map[word] += 1\\n                        if curr_map[word] > word2freq[word]: \\n                            excessive = word\\n                    else:\\n                        curr_map[word] = 1\\n\\n                    earliest_ind = i - (curr_total-1)*n_char\\n                    while excessive:\\n                        earliest_word = s[earliest_ind: earliest_ind+n_char]\\n                        curr_map[earliest_word] -= 1\\n                        curr_total -= 1\\n                        if earliest_word == excessive:\\n                            excessive = False\\n                            break\\n                        earliest_ind += n_char\\n                    if curr_total == n_word:\\n                        earliest_ind = i - (n_word-1)*n_char\\n\\n                        all_start_ind.append(earliest_ind)\\n\\n                        earliest_word = s[earliest_ind: earliest_ind+n_char]\\n                        curr_total -= 1\\n                        curr_map[earliest_word] -= 1\\n                else:\\n                    curr_total = 0\\n                    curr_map = {}\\n        return all_start_ind\\n    \\n    def check_map_equal(self, curr_map, ref_map) -> bool:\\n        for word, freq in curr_map.items():\\n            if word not in ref_map or freq != ref_map[word]:\\n                return False\\n        return True\\n```\\n\\n```Java []\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        int wordLength = words[0].length();\\n        int totalWordsLength = wordLength * words.length;\\n        Map<String, Integer> hash = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n        char[] s2 = s.toCharArray();\\n        for (String value : words) {\\n            hash.putIfAbsent(value, hash.size());\\n        }\\n        int[] count = new int[hash.size()];\\n        for (String word : words) {\\n            count[hash.get(word)]++;\\n        }\\n        for (int i = 0; i < wordLength; i++) {\\n            for (int j = i; j <= s.length() - totalWordsLength; j += wordLength) {\\n                int[] localCount = new int[hash.size()];\\n                for (int k = j + totalWordsLength - wordLength; k >= j; k -= wordLength) {\\n                    String str = new String(s2, k, wordLength);     // [ k, k+wordLength )\\n                    Integer key = hash.get(str);\\n                    if (!(key != null && count[key] >= ++localCount[key])) {\\n                        j = k;\\n                        break;\\n                    }\\n                    if (j == k) {\\n                        ans.add(j);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n\\tstruct matcher {\\n\\t\\tstruct info { int mtindex, count; };\\n\\t\\tunordered_map<string_view, info>dict;\\n\\t\\tint different_word_count;\\n\\n\\t\\tvector<int>slot;\\n\\t\\tint maching_slot_count;\\n\\n\\t\\tmatcher(const vector<string>& words) {\\n\\t\\t\\tint mtind = 0;\\n\\t\\t\\tfor (auto& word : words) {\\n\\t\\t\\t\\tauto find = dict.find(word);\\n\\t\\t\\t\\tif (find != dict.end()) {\\n\\t\\t\\t\\t\\t++find->second.count;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse { dict[word] = { mtind++,1 }; }\\n\\t\\t\\t}\\n\\t\\t\\tdifferent_word_count = mtind;\\n\\t\\t\\tslot = vector<int>(different_word_count, 0);\\n\\t\\t\\tmaching_slot_count = 0;\\n\\t\\t}\\n\\n\\t\\tvoid reset() {\\n\\t\\t\\tfor (auto& i : slot) { i = 0; }\\n\\t\\t\\tmaching_slot_count = 0;\\n\\t\\t}\\n\\t\\tbool match() {\\n\\t\\t\\treturn maching_slot_count == different_word_count;\\n\\t\\t}\\n\\t\\tvoid push(string_view sv) {\\n\\t\\t\\tauto find = dict.find(sv);\\n\\t\\t\\tif (find == dict.end())return;\\n\\t\\t\\tif (++slot[find->second.mtindex] == find->second.count) {\\n\\t\\t\\t\\t++maching_slot_count;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvoid pop(string_view sv) {\\n\\t\\t\\tauto find = dict.find(sv);\\n\\t\\t\\tif (find == dict.end())return;\\n\\t\\t\\tif (--slot[find->second.mtindex] == find->second.count - 1) {\\n\\t\\t\\t\\t--maching_slot_count;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\tvector<int> findSubstring(string s, const vector<string>& words) {\\n\\t\\tint word_count = words.size();\\n\\t\\tint word_len = words[0].size();\\n\\n\\t\\tmatcher matcher(words);\\n\\n\\t\\tconst char* str = s.c_str();\\n\\t\\tint len = s.size();\\n\\t\\tvector<int> ret;\\n\\n\\t\\tfor (int off = 0; off < word_len; off++) {\\n\\t\\t\\tconst char* beg = str + off, * end = str + len;\\n\\t\\t\\tif (beg + word_len * word_count <= end) {\\n\\t\\t\\t\\tmatcher.reset();\\n\\t\\t\\t\\tfor (int i = 0; i < word_count; i++) {\\n\\t\\t\\t\\t\\tstring_view sv(beg + i * word_len, word_len);\\n\\t\\t\\t\\t\\tmatcher.push(sv);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif (matcher.match()) {\\n\\t\\t\\t\\t\\tret.push_back(beg - str);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tconst char* pos = beg + word_len * word_count;\\n\\t\\t\\t\\twhile (pos + word_len <= end) {\\n\\t\\t\\t\\t\\tstring_view del(beg, word_len);\\n\\t\\t\\t\\t\\tstring_view add(pos, word_len);\\n\\t\\t\\t\\t\\tbeg += word_len;\\n\\t\\t\\t\\t\\tpos += word_len;\\n\\t\\t\\t\\t\\tmatcher.pop(del);\\n\\t\\t\\t\\t\\tmatcher.push(add);\\n\\t\\t\\t\\t\\tif (matcher.match()) {\\n\\t\\t\\t\\t\\t\\tret.push_back(beg - str);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn ret;\\n\\t}\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        n_word = len(words)\\n        n_char = len(words[0])\\n        word2freq = {}\\n        for word in words:\\n            if word in word2freq:\\n                word2freq[word] += 1\\n            else:\\n                word2freq[word] = 1\\n\\n        all_start_ind = []\\n        for start_ind in range(n_char):\\n            curr_map = {}\\n            curr_total = 0\\n            excessive = False\\n            for i in range(start_ind, len(s), n_char):\\n                word = s[i:i+n_char]\\n                if word in word2freq: # a valid word for permutation \\n                    curr_total += 1\\n                    if word in curr_map: # found valid word\\n                        curr_map[word] += 1\\n                        if curr_map[word] > word2freq[word]: \\n                            excessive = word\\n                    else:\\n                        curr_map[word] = 1\\n\\n                    earliest_ind = i - (curr_total-1)*n_char\\n                    while excessive:\\n                        earliest_word = s[earliest_ind: earliest_ind+n_char]\\n                        curr_map[earliest_word] -= 1\\n                        curr_total -= 1\\n                        if earliest_word == excessive:\\n                            excessive = False\\n                            break\\n                        earliest_ind += n_char\\n                    if curr_total == n_word:\\n                        earliest_ind = i - (n_word-1)*n_char\\n\\n                        all_start_ind.append(earliest_ind)\\n\\n                        earliest_word = s[earliest_ind: earliest_ind+n_char]\\n                        curr_total -= 1\\n                        curr_map[earliest_word] -= 1\\n                else:\\n                    curr_total = 0\\n                    curr_map = {}\\n        return all_start_ind\\n    \\n    def check_map_equal(self, curr_map, ref_map) -> bool:\\n        for word, freq in curr_map.items():\\n            if word not in ref_map or freq != ref_map[word]:\\n                return False\\n        return True\\n```\n```Java []\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        int wordLength = words[0].length();\\n        int totalWordsLength = wordLength * words.length;\\n        Map<String, Integer> hash = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n        char[] s2 = s.toCharArray();\\n        for (String value : words) {\\n            hash.putIfAbsent(value, hash.size());\\n        }\\n        int[] count = new int[hash.size()];\\n        for (String word : words) {\\n            count[hash.get(word)]++;\\n        }\\n        for (int i = 0; i < wordLength; i++) {\\n            for (int j = i; j <= s.length() - totalWordsLength; j += wordLength) {\\n                int[] localCount = new int[hash.size()];\\n                for (int k = j + totalWordsLength - wordLength; k >= j; k -= wordLength) {\\n                    String str = new String(s2, k, wordLength);     // [ k, k+wordLength )\\n                    Integer key = hash.get(str);\\n                    if (!(key != null && count[key] >= ++localCount[key])) {\\n                        j = k;\\n                        break;\\n                    }\\n                    if (j == k) {\\n                        ans.add(j);\\n                    }\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1349245,
                "title": "solution-swift-substring-with-concatenation-of-all-words-test-cases",
                "content": "```swift\\nclass Solution {\\n    func findSubstring(_ s: String, _ words: [String]) -> [Int] {\\n        guard !(s.isEmpty) || !(words.isEmpty) else { return [] }\\n        \\n        let lenS = s.count, chars = Array(s)\\n        let size = words[0].count, count = words.count * size\\n        \\n        guard lenS >= count else { return [] }\\n        \\n        var wordDict = [[Character]:Int]()\\n        \\n        for word in words {\\n            let arr: [Character] = word.map({$0})\\n            wordDict[arr, default: 0] = (wordDict[arr] ?? 0) + 1\\n        }\\n        \\n        var result = [Int]()\\n        \\n        for i in 0..<size {\\n            var val = i\\n            while val <= (lenS - count) {\\n                var diff = (val + count)\\n                var dict = [[Character]:Int]()\\n                var equal: Bool = true\\n                while val < diff {\\n                    let temp: [Character] = chars[(diff - size)..<diff].map({$0})\\n                    dict[temp] = (dict[temp] ?? 0) + 1\\n                    if let char = dict[temp], char > (wordDict[temp] ?? 0) {\\n                        equal = false\\n                        break\\n                    }\\n                    diff -= size\\n                }\\n                if dict == wordDict { result.append(val) }\\n                if equal { val += size } else { val = diff }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 3 tests, with 0 failures (0 unexpected) in 0.050 (0.052) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively.\\n    /// The output order does not matter, returning [9,0] is fine too.\\n    func test0() {\\n        let value = solution.findSubstring(\"barfoothefoobarman\", [\"foo\",\"bar\"])\\n        XCTAssertEqual(value, [0,9])\\n    }\\n    \\n    func test1() {\\n        let value = solution.findSubstring(\"wordgoodgoodgoodbestword\", [\"word\",\"good\",\"best\",\"word\"])\\n        XCTAssertEqual(value, [])\\n    }\\n    \\n    func test2() {\\n        let value = solution.findSubstring(\"barfoofoobarthefoobarman\", [\"bar\",\"foo\",\"the\"])\\n        XCTAssertEqual(value, [6,9,12])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```swift\\nclass Solution {\\n    func findSubstring(_ s: String, _ words: [String]) -> [Int] {\\n        guard !(s.isEmpty) || !(words.isEmpty) else { return [] }\\n        \\n        let lenS = s.count, chars = Array(s)\\n        let size = words[0].count, count = words.count * size\\n        \\n        guard lenS >= count else { return [] }\\n        \\n        var wordDict = [[Character]:Int]()\\n        \\n        for word in words {\\n            let arr: [Character] = word.map({$0})\\n            wordDict[arr, default: 0] = (wordDict[arr] ?? 0) + 1\\n        }\\n        \\n        var result = [Int]()\\n        \\n        for i in 0..<size {\\n            var val = i\\n            while val <= (lenS - count) {\\n                var diff = (val + count)\\n                var dict = [[Character]:Int]()\\n                var equal: Bool = true\\n                while val < diff {\\n                    let temp: [Character] = chars[(diff - size)..<diff].map({$0})\\n                    dict[temp] = (dict[temp] ?? 0) + 1\\n                    if let char = dict[temp], char > (wordDict[temp] ?? 0) {\\n                        equal = false\\n                        break\\n                    }\\n                    diff -= size\\n                }\\n                if dict == wordDict { result.append(val) }\\n                if equal { val += size } else { val = diff }\\n            }\\n        }\\n        return result\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// Substrings starting at index 0 and 9 are \"barfoo\" and \"foobar\" respectively.\\n    /// The output order does not matter, returning [9,0] is fine too.\\n    func test0() {\\n        let value = solution.findSubstring(\"barfoothefoobarman\", [\"foo\",\"bar\"])\\n        XCTAssertEqual(value, [0,9])\\n    }\\n    \\n    func test1() {\\n        let value = solution.findSubstring(\"wordgoodgoodgoodbestword\", [\"word\",\"good\",\"best\",\"word\"])\\n        XCTAssertEqual(value, [])\\n    }\\n    \\n    func test2() {\\n        let value = solution.findSubstring(\"barfoofoobarthefoobarman\", [\"bar\",\"foo\",\"the\"])\\n        XCTAssertEqual(value, [6,9,12])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 969070,
                "title": "approach-using-hashmap-and-sliding-window-concepts-in-c-easy-understandable-code",
                "content": "Please give a upvote if you like this solutions. Comment if you didn\\'t get it.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n        unordered_map<string, int> M, temp;\\n        vector<int> Ans;\\n        int N = words.size();\\n        int L = words[0].size();\\n        \\n        // Store all the frequencies of all strings\\n        // in the array words[]\\n        for(auto &it : words) {\\n            M[it]++;\\n        }\\n        int size = s.length();\\n        \\n        // Loop till possible number of starting\\n        // index of the valid indices\\n        for(int i = 0; i < size - N*L + 1; i++) {\\n            \\n            // Iterate the current window of\\n            // length N*L over the range\\n            // [i, i + N*L] and extract the\\n            // substring of length L and store\\n            // it\\'s frequency\\n            for(int j = i; j < i + N*L; j+= L) {\\n                string ans = s.substr(j, L);\\n                temp[ans]++;\\n            }\\n            \\n            int flag = 1;\\n            \\n            // Now, check if the frequency of each string\\n            // in map M is the same as the frequency in\\n            // map temp. This ensure that the current\\n            // window is of the same concatenation of\\n            // the strings in the array words[]\\n            for(auto &it : M) {\\n                if(M[it.first] != temp[it.first]) {\\n                    flag = 0;\\n                    break;\\n                }\\n            }\\n            \\n            // If the current window is the possible\\n\\t\\t\\t// result then store the starting index of it\\n            if(flag) Ans.push_back(i);\\n            \\n            // Clear the temp for another window\\n            temp.clear();\\n        }\\n        \\n        // Return the resultant vector of indices\\n        return Ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n        unordered_map<string, int> M, temp;\\n        vector<int> Ans;\\n        int N = words.size();\\n        int L = words[0].size();\\n        \\n        // Store all the frequencies of all strings\\n        // in the array words[]\\n        for(auto &it : words) {\\n            M[it]++;\\n        }\\n        int size = s.length();\\n        \\n        // Loop till possible number of starting\\n        // index of the valid indices\\n        for(int i = 0; i < size - N*L + 1; i++) {\\n            \\n            // Iterate the current window of\\n            // length N*L over the range\\n            // [i, i + N*L] and extract the\\n            // substring of length L and store\\n            // it\\'s frequency\\n            for(int j = i; j < i + N*L; j+= L) {\\n                string ans = s.substr(j, L);\\n                temp[ans]++;\\n            }\\n            \\n            int flag = 1;\\n            \\n            // Now, check if the frequency of each string\\n            // in map M is the same as the frequency in\\n            // map temp. This ensure that the current\\n            // window is of the same concatenation of\\n            // the strings in the array words[]\\n            for(auto &it : M) {\\n                if(M[it.first] != temp[it.first]) {\\n                    flag = 0;\\n                    break;\\n                }\\n            }\\n            \\n            // If the current window is the possible\\n\\t\\t\\t// result then store the starting index of it\\n            if(flag) Ans.push_back(i);\\n            \\n            // Clear the temp for another window\\n            temp.clear();\\n        }\\n        \\n        // Return the resultant vector of indices\\n        return Ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13699,
                "title": "92-java-o-n-with-explaination",
                "content": "```java\\npublic class Solution {\\n\\t\\n\\t/*\\n\\t\\tA time & space O(n) solution\\n\\t\\tRun a moving window for wordLen times.\\n\\t\\tEach time we keep a window of size windowLen (= wordLen * numWord), each step length is wordLen.\\n\\t\\tSo each scan takes O(sLen / wordLen), totally takes O(sLen / wordLen * wordLen) = O(sLen) time.\\n\\t\\t\\n\\t\\tOne trick here is use count to record the number of exceeded occurrences of word in current window\\n\\t*/\\n    public static List<Integer> findSubstring(String s, String[] words) {\\n        List<Integer> res = new ArrayList<>();\\n        if(words == null || words.length == 0 || s.length() == 0) return res;\\n        int wordLen = words[0].length();\\n        int numWord = words.length;\\n        int windowLen = wordLen * numWord;\\n        int sLen = s.length();\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String word : words) map.put(word, map.getOrDefault(word, 0) + 1);\\n\\n        for(int i = 0; i < wordLen; i++) {  // Run wordLen scans\\n            HashMap<String, Integer> curMap = new HashMap<>();\\n            for(int j = i, count = 0, start = i; j + wordLen <= sLen; j += wordLen) {  // Move window in step of wordLen\\n                // count: number of exceeded occurences in current window\\n                // start: start index of current window of size windowLen\\n                if(start + windowLen > sLen) break;\\n                String word = s.substring(j, j + wordLen);\\n                if(!map.containsKey(word)) {\\n                    curMap.clear();\\n                    count = 0;\\n                    start = j + wordLen;\\n                }\\n                else {\\n                    if(j == start + windowLen) { // Remove previous word of current window\\n                        String preWord = s.substring(start, start + wordLen);\\n                        start += wordLen;\\n                        int val = curMap.get(preWord);\\n                        if(val == 1) curMap.remove(preWord);\\n                        else curMap.put(preWord, val - 1);\\n                        if(val - 1 >= map.get(preWord)) count--;  // Reduce count of exceeded word\\n                    }\\n                    // Add new word\\n                    curMap.put(word, curMap.getOrDefault(word, 0) + 1);\\n                    if(curMap.get(word) > map.get(word)) count++;  // More than expected, increase count\\n                    // Check if current window valid\\n                    if(count == 0 && start + windowLen == j + wordLen) {\\n                        res.add(start);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n\\t\\n\\t/*\\n\\t\\tA time & space O(n) solution\\n\\t\\tRun a moving window for wordLen times.\\n\\t\\tEach time we keep a window of size windowLen (= wordLen * numWord), each step length is wordLen.\\n\\t\\tSo each scan takes O(sLen / wordLen), totally takes O(sLen / wordLen * wordLen) = O(sLen) time.\\n\\t\\t\\n\\t\\tOne trick here is use count to record the number of exceeded occurrences of word in current window\\n\\t*/\\n    public static List<Integer> findSubstring(String s, String[] words) {\\n        List<Integer> res = new ArrayList<>();\\n        if(words == null || words.length == 0 || s.length() == 0) return res;\\n        int wordLen = words[0].length();\\n        int numWord = words.length;\\n        int windowLen = wordLen * numWord;\\n        int sLen = s.length();\\n        HashMap<String, Integer> map = new HashMap<>();\\n        for(String word : words) map.put(word, map.getOrDefault(word, 0) + 1);\\n\\n        for(int i = 0; i < wordLen; i++) {  // Run wordLen scans\\n            HashMap<String, Integer> curMap = new HashMap<>();\\n            for(int j = i, count = 0, start = i; j + wordLen <= sLen; j += wordLen) {  // Move window in step of wordLen\\n                // count: number of exceeded occurences in current window\\n                // start: start index of current window of size windowLen\\n                if(start + windowLen > sLen) break;\\n                String word = s.substring(j, j + wordLen);\\n                if(!map.containsKey(word)) {\\n                    curMap.clear();\\n                    count = 0;\\n                    start = j + wordLen;\\n                }\\n                else {\\n                    if(j == start + windowLen) { // Remove previous word of current window\\n                        String preWord = s.substring(start, start + wordLen);\\n                        start += wordLen;\\n                        int val = curMap.get(preWord);\\n                        if(val == 1) curMap.remove(preWord);\\n                        else curMap.put(preWord, val - 1);\\n                        if(val - 1 >= map.get(preWord)) count--;  // Reduce count of exceeded word\\n                    }\\n                    // Add new word\\n                    curMap.put(word, curMap.getOrDefault(word, 0) + 1);\\n                    if(curMap.get(word) > map.get(word)) count++;  // More than expected, increase count\\n                    // Check if current window valid\\n                    if(count == 0 && start + windowLen == j + wordLen) {\\n                        res.add(start);\\n                    }\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13812,
                "title": "hash-idea-and-exception-case",
                "content": "The following python code is accepted by OJ. It is based on the following idea (assumption)\\n\\n -  We know that two multisets consist of same elements and size of the multisets are equal. if sum of hashes of all elements are the same for these multisets ->  those multisets are identical\\n\\n \\nThis is not true for same very very rare cases. Please describe such a case.\\n\\n    def findSubstring(self, S, L):\\n        n = len(L) #num words\\n        w = len(L[0])  #length of each word\\n        t = n*w    # total length\\n    \\n        hashsum = sum([hash(x) for x in L])\\n        h = [hash(S[i:i+w])*(S[i:i+w] in L) for i in xrange(len(S)-w+1)]\\n        return [i for i in xrange(len(S)-t+1) if sum(h[i:i+t:w])==hashsum]",
                "solutionTags": [],
                "code": "The following python code is accepted by OJ. It is based on the following idea (assumption)\\n\\n -  We know that two multisets consist of same elements and size of the multisets are equal. if sum of hashes of all elements are the same for these multisets ->  those multisets are identical\\n\\n \\nThis is not true for same very very rare cases. Please describe such a case.\\n\\n    def findSubstring(self, S, L):\\n        n = len(L) #num words\\n        w = len(L[0])  #length of each word\\n        t = n*w    # total length\\n    \\n        hashsum = sum([hash(x) for x in L])\\n        h = [hash(S[i:i+w])*(S[i:i+w] in L) for i in xrange(len(S)-w+1)]\\n        return [i for i in xrange(len(S)-t+1) if sum(h[i:i+t:w])==hashsum]",
                "codeTag": "Python3"
            },
            {
                "id": 13691,
                "title": "java-12ms-beats-100",
                "content": "The two pointers method with hashmap is known by many other solutions. The idea is to slide the scan window as far as possible, and keep throwing the impossible cases based on the length test.\\n\\n    public List<Integer> findSubstring(String s, String[] words) {\\n\\t\\t\\t/**\\n\\t\\t\\t * Let n=s.length, k=words[0].length traverse s with indices i, i+k,\\n\\t\\t\\t * i+2k, ... for 0<=i<k, so that the time complexity is O(n).\\n\\t\\t\\t */\\n\\t\\t\\tList<Integer> res = new ArrayList<Integer>();\\n\\t\\t\\tint n = s.length(), m = words.length, k;\\n\\t\\t\\tif (n == 0 || m == 0 || (k = words[0].length()) == 0)\\n\\t\\t\\t\\treturn res;\\n\\n\\t\\t\\tHashMap<String, Integer> wDict = new HashMap<String, Integer>();\\n\\n\\t\\t\\tfor (String word : words) {\\n\\t\\t\\t\\tif (wDict.containsKey(word))\\n\\t\\t\\t\\t\\twDict.put(word, wDict.get(word) + 1);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\twDict.put(word, 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint i, j, start, x, wordsLen = m * k;\\n\\t\\t\\tHashMap<String, Integer> curDict = new HashMap<String, Integer>();\\n\\t\\t\\tString test, temp;\\n\\t\\t\\tfor (i = 0; i < k; i++) {\\n\\t\\t\\t\\tcurDict.clear();\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\tfor (j = i; j + k <= n; j += k) {\\n\\t\\t\\t\\t\\ttest = s.substring(j, j + k);\\n\\n\\t\\t\\t\\t\\tif (wDict.containsKey(test)) {\\n\\t\\t\\t\\t\\t\\tif (!curDict.containsKey(test)) {\\n\\t\\t\\t\\t\\t\\t\\tcurDict.put(test, 1);\\n\\n\\t\\t\\t\\t\\t\\t\\tstart = checkFound(res, start, wordsLen, j, k, curDict, s);\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// curDict.containsKey(test)\\n\\t\\t\\t\\t\\t\\tx = curDict.get(test);\\n\\t\\t\\t\\t\\t\\tif (x < wDict.get(test)) {\\n\\t\\t\\t\\t\\t\\t\\tcurDict.put(test, x + 1);\\n\\n\\t\\t\\t\\t\\t\\t\\tstart = checkFound(res, start, wordsLen, j, k, curDict, s);\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// curDict.get(test)==wDict.get(test), slide start to\\n\\t\\t\\t\\t\\t\\t// the next word of the first same word as test\\n\\t\\t\\t\\t\\t\\twhile (!(temp = s.substring(start, start + k)).equals(test)) {\\n\\t\\t\\t\\t\\t\\t\\tdecreaseCount(curDict, temp);\\n\\t\\t\\t\\t\\t\\t\\tstart += k;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tstart += k;\\n\\t\\t\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// totally failed up to index j+k, slide start and reset all\\n\\t\\t\\t\\t\\tstart = j + k;\\n\\t\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcurDict.clear();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tpublic int checkFound(List<Integer> res, int start, int wordsLen, int j, int k,\\n\\t\\t\\t\\tHashMap<String, Integer> curDict, String s) {\\n\\t\\t\\tif (start + wordsLen == j + k) {\\n\\t\\t\\t\\tres.add(start);\\n\\t\\t\\t\\t// slide start to the next word\\n\\t\\t\\t\\tdecreaseCount(curDict, s.substring(start, start + k));\\n\\t\\t\\t\\treturn start + k;\\n\\t\\t\\t}\\n\\t\\t\\treturn start;\\n\\t\\t}\\n\\n\\t\\tpublic void decreaseCount(HashMap<String, Integer> curDict, String key) {\\n\\t\\t\\t// remove key if curDict.get(key)==1, otherwise decrease it by 1\\n\\t\\t\\tint x = curDict.get(key);\\n\\t\\t\\tif (x == 1)\\n\\t\\t\\t\\tcurDict.remove(key);\\n\\t\\t\\telse\\n\\t\\t\\t\\tcurDict.put(key, x - 1);\\n\\t\\t}",
                "solutionTags": [
                    "Java"
                ],
                "code": "The two pointers method with hashmap is known by many other solutions. The idea is to slide the scan window as far as possible, and keep throwing the impossible cases based on the length test.\\n\\n    public List<Integer> findSubstring(String s, String[] words) {\\n\\t\\t\\t/**\\n\\t\\t\\t * Let n=s.length, k=words[0].length traverse s with indices i, i+k,\\n\\t\\t\\t * i+2k, ... for 0<=i<k, so that the time complexity is O(n).\\n\\t\\t\\t */\\n\\t\\t\\tList<Integer> res = new ArrayList<Integer>();\\n\\t\\t\\tint n = s.length(), m = words.length, k;\\n\\t\\t\\tif (n == 0 || m == 0 || (k = words[0].length()) == 0)\\n\\t\\t\\t\\treturn res;\\n\\n\\t\\t\\tHashMap<String, Integer> wDict = new HashMap<String, Integer>();\\n\\n\\t\\t\\tfor (String word : words) {\\n\\t\\t\\t\\tif (wDict.containsKey(word))\\n\\t\\t\\t\\t\\twDict.put(word, wDict.get(word) + 1);\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t\\twDict.put(word, 1);\\n\\t\\t\\t}\\n\\n\\t\\t\\tint i, j, start, x, wordsLen = m * k;\\n\\t\\t\\tHashMap<String, Integer> curDict = new HashMap<String, Integer>();\\n\\t\\t\\tString test, temp;\\n\\t\\t\\tfor (i = 0; i < k; i++) {\\n\\t\\t\\t\\tcurDict.clear();\\n\\t\\t\\t\\tstart = i;\\n\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\treturn res;\\n\\t\\t\\t\\tfor (j = i; j + k <= n; j += k) {\\n\\t\\t\\t\\t\\ttest = s.substring(j, j + k);\\n\\n\\t\\t\\t\\t\\tif (wDict.containsKey(test)) {\\n\\t\\t\\t\\t\\t\\tif (!curDict.containsKey(test)) {\\n\\t\\t\\t\\t\\t\\t\\tcurDict.put(test, 1);\\n\\n\\t\\t\\t\\t\\t\\t\\tstart = checkFound(res, start, wordsLen, j, k, curDict, s);\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// curDict.containsKey(test)\\n\\t\\t\\t\\t\\t\\tx = curDict.get(test);\\n\\t\\t\\t\\t\\t\\tif (x < wDict.get(test)) {\\n\\t\\t\\t\\t\\t\\t\\tcurDict.put(test, x + 1);\\n\\n\\t\\t\\t\\t\\t\\t\\tstart = checkFound(res, start, wordsLen, j, k, curDict, s);\\n\\t\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t\\t// curDict.get(test)==wDict.get(test), slide start to\\n\\t\\t\\t\\t\\t\\t// the next word of the first same word as test\\n\\t\\t\\t\\t\\t\\twhile (!(temp = s.substring(start, start + k)).equals(test)) {\\n\\t\\t\\t\\t\\t\\t\\tdecreaseCount(curDict, temp);\\n\\t\\t\\t\\t\\t\\t\\tstart += k;\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tstart += k;\\n\\t\\t\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// totally failed up to index j+k, slide start and reset all\\n\\t\\t\\t\\t\\tstart = j + k;\\n\\t\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcurDict.clear();\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn res;\\n\\t\\t}\\n\\n\\t\\tpublic int checkFound(List<Integer> res, int start, int wordsLen, int j, int k,\\n\\t\\t\\t\\tHashMap<String, Integer> curDict, String s) {\\n\\t\\t\\tif (start + wordsLen == j + k) {\\n\\t\\t\\t\\tres.add(start);\\n\\t\\t\\t\\t// slide start to the next word\\n\\t\\t\\t\\tdecreaseCount(curDict, s.substring(start, start + k));\\n\\t\\t\\t\\treturn start + k;\\n\\t\\t\\t}\\n\\t\\t\\treturn start;\\n\\t\\t}\\n\\n\\t\\tpublic void decreaseCount(HashMap<String, Integer> curDict, String key) {\\n\\t\\t\\t// remove key if curDict.get(key)==1, otherwise decrease it by 1\\n\\t\\t\\tint x = curDict.get(key);\\n\\t\\t\\tif (x == 1)\\n\\t\\t\\t\\tcurDict.remove(key);\\n\\t\\t\\telse\\n\\t\\t\\t\\tcurDict.put(key, x - 1);\\n\\t\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2417602,
                "title": "c-easy-solution-using-hashmap",
                "content": "# **C++ Easy Solution Using Hashmap**\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int>ans;\\n        int n=words.size();\\n        int m=words[0].size();\\n        int total=n*m;\\n        if(s.size()<total){\\n            return ans;\\n        }\\n        for(int i=0;i<=s.size()-total;i++){\\n            unordered_map<string,int>mp;\\n            \\n            for(int j=0;j<words.size();j++){\\n                mp[words[j]]++;\\n            }\\n            int k;\\n            for(k=0;k<n;k++){\\n                \\n                string temp=s.substr(i+k*m,m);\\n                // cout<<temp<<\" \"<<i<<endl;\\n                if(mp.count(temp)==0){\\n                    break;\\n                }\\n                else{\\n                    if(mp[temp]!=0){\\n                        mp[temp]--;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            }\\n            if(k==n){\\n                ans.push_back(i);\\n            }\\n            \\n        }\\n        return ans ;\\n    }\\n};\\n```\\n# **Please Share and Upvote**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int>ans;\\n        int n=words.size();\\n        int m=words[0].size();\\n        int total=n*m;\\n        if(s.size()<total){\\n            return ans;\\n        }\\n        for(int i=0;i<=s.size()-total;i++){\\n            unordered_map<string,int>mp;\\n            \\n            for(int j=0;j<words.size();j++){\\n                mp[words[j]]++;\\n            }\\n            int k;\\n            for(k=0;k<n;k++){\\n                \\n                string temp=s.substr(i+k*m,m);\\n                // cout<<temp<<\" \"<<i<<endl;\\n                if(mp.count(temp)==0){\\n                    break;\\n                }\\n                else{\\n                    if(mp[temp]!=0){\\n                        mp[temp]--;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n            }\\n            if(k==n){\\n                ans.push_back(i);\\n            }\\n            \\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 13733,
                "title": "accepted-short-java-solution",
                "content": "Hey, guys!\\n\\nActually, there's nothing special in my solution except the comparably short Java code. It's just a simple sliding window approach which is greatly described in other posts.\\n\\nIn short, we got the source histogram from the dictionary L and build the new histogram for each possible window comparing it with the help of Java's *equals* method to the source one. Additionally, for the sake of tiny optimization, we check the starting word for being in the dictionary. \\n\\n\\n    public List<Integer> findSubstring(String S, String[] L) {\\n        List<Integer> result = new ArrayList<>();\\n        int size = L[0].length();\\n        if (L.length == 0 || L[0].isEmpty() || L[0].length() > S.length()) \\n            return result;\\n        Map<String, Integer> hist = new HashMap<>();\\n        for (String w : L) {\\n            hist.put(w, !hist.containsKey(w) ? 1 : hist.get(w)+1);\\n        }\\n        for (int i = 0; i+size*L.length <= S.length(); i++) {\\n            if (hist.containsKey(S.substring(i, i+size))) {\\n                Map<String, Integer> currHist = new HashMap<>();\\n                for (int j = 0; j < L.length; j++) {\\n                    String word = S.substring(i+j*size, i+(j+1)*size);\\n                    currHist.put(word, !currHist.containsKey(word) ? \\n                            1 : currHist.get(word)+1);\\n                }\\n                if (currHist.equals(hist)) result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n\\nHope it helps!",
                "solutionTags": [
                    "Java"
                ],
                "code": "Hey, guys!\\n\\nActually, there's nothing special in my solution except the comparably short Java code. It's just a simple sliding window approach which is greatly described in other posts.\\n\\nIn short, we got the source histogram from the dictionary L and build the new histogram for each possible window comparing it with the help of Java's *equals* method to the source one. Additionally, for the sake of tiny optimization, we check the starting word for being in the dictionary. \\n\\n\\n    public List<Integer> findSubstring(String S, String[] L) {\\n        List<Integer> result = new ArrayList<>();\\n        int size = L[0].length();\\n        if (L.length == 0 || L[0].isEmpty() || L[0].length() > S.length()) \\n            return result;\\n        Map<String, Integer> hist = new HashMap<>();\\n        for (String w : L) {\\n            hist.put(w, !hist.containsKey(w) ? 1 : hist.get(w)+1);\\n        }\\n        for (int i = 0; i+size*L.length <= S.length(); i++) {\\n            if (hist.containsKey(S.substring(i, i+size))) {\\n                Map<String, Integer> currHist = new HashMap<>();\\n                for (int j = 0; j < L.length; j++) {\\n                    String word = S.substring(i+j*size, i+(j+1)*size);\\n                    currHist.put(word, !currHist.containsKey(word) ? \\n                            1 : currHist.get(word)+1);\\n                }\\n                if (currHist.equals(hist)) result.add(i);\\n            }\\n        }\\n        return result;\\n    }\\n\\nHope it helps!",
                "codeTag": "Unknown"
            },
            {
                "id": 163145,
                "title": "clean-python-o-n-k-with-two-maps-and-detailed-explanation",
                "content": "* Count the occurance of each word in words and store in a dict\\n* Have a temp dict to check for the number of word used\\n* Iterate through string s and check substring of len(word[0]) each time (note all words in words have the same length)\\n\\t* Two things can happen when we check \\n\\t\\t* substring match and we haven\\'t used the word yet -> word_used += 1 and decrease count of word in counter\\n\\t\\t* substring either doesn\\'t match or we already used the substring -> break and move to the next substring\\n* if we have used all of the words in word list then we have found a index\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def findSubstring(self, s, words):\\n        \"\"\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        if not s or not words:\\n            return []\\n        \\n        word_map = Counter(words)\\n        results = []\\n        word_size = len(words[0])\\n        num_word = len(words)\\n        list_size = word_size*num_word\\n        for i in range(len(s) - list_size + 1):\\n            seen = dict(word_map)\\n            word_used = 0\\n            for j in range(i, i + list_size, word_size):\\n                sub_str = s[j: j + word_size]\\n                if sub_str in seen and seen[sub_str] > 0:\\n                    seen[sub_str] -= 1\\n                    word_used += 1\\n                else:\\n                    break\\n            if word_used == num_word:\\n                results.append(i)\\n        return results\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def findSubstring(self, s, words):\\n        \"\"\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        if not s or not words:\\n            return []\\n        \\n        word_map = Counter(words)\\n        results = []\\n        word_size = len(words[0])\\n        num_word = len(words)\\n        list_size = word_size*num_word\\n        for i in range(len(s) - list_size + 1):\\n            seen = dict(word_map)\\n            word_used = 0\\n            for j in range(i, i + list_size, word_size):\\n                sub_str = s[j: j + word_size]\\n                if sub_str in seen and seen[sub_str] > 0:\\n                    seen[sub_str] -= 1\\n                    word_used += 1\\n                else:\\n                    break\\n            if word_used == num_word:\\n                results.append(i)\\n        return results\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418368,
                "title": "java-clean-solution-using-hashmap",
                "content": "The fact that all words are the same length makes it easy to iterate over a string. \\n\\tFor each potential substring, we make a map of the words in it and compare it with the map of the words of the input set \\n\\t(with the condition of an early exit, if the word is not in the input set or is present fewer times)\\n\\n```java\\npublic List<Integer> findSubstring(String s, String[] words) {\\n        List<Integer> indices = new ArrayList<>();\\n        Map<String, Integer> wordsMap = new HashMap<>();\\n        Arrays.stream(words).forEach(word -> wordsMap.put(word, wordsMap.getOrDefault(word, 0) + 1));\\n\\n        int wordLength = words[0].length(), count = words.length;\\n        for (int index = 0; index <= s.length() - wordLength * count; ++index) {\\n            if (isContainsAllWords(wordsMap, s.substring(index, index + wordLength * count), wordLength))\\n                indices.add(index);\\n        }\\n\\n        return indices;\\n    }\\n\\n    private boolean isContainsAllWords(Map<String, Integer> wordsMap, String substring, int wordLength) {\\n        Map<String, Integer> substringWordsMap = new HashMap<>();\\n        for (int i = 0; i < substring.length(); i += wordLength) {\\n            String word = substring.substring(i, i + wordLength);\\n            substringWordsMap.put(word, substringWordsMap.getOrDefault(word, 0) + 1);\\n            \\n\\t\\t\\tif (substringWordsMap.get(word) > wordsMap.getOrDefault(word, 0))\\n                return false;\\n        }\\n        return substringWordsMap.equals(wordsMap);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic List<Integer> findSubstring(String s, String[] words) {\\n        List<Integer> indices = new ArrayList<>();\\n        Map<String, Integer> wordsMap = new HashMap<>();\\n        Arrays.stream(words).forEach(word -> wordsMap.put(word, wordsMap.getOrDefault(word, 0) + 1));\\n\\n        int wordLength = words[0].length(), count = words.length;\\n        for (int index = 0; index <= s.length() - wordLength * count; ++index) {\\n            if (isContainsAllWords(wordsMap, s.substring(index, index + wordLength * count), wordLength))\\n                indices.add(index);\\n        }\\n\\n        return indices;\\n    }\\n\\n    private boolean isContainsAllWords(Map<String, Integer> wordsMap, String substring, int wordLength) {\\n        Map<String, Integer> substringWordsMap = new HashMap<>();\\n        for (int i = 0; i < substring.length(); i += wordLength) {\\n            String word = substring.substring(i, i + wordLength);\\n            substringWordsMap.put(word, substringWordsMap.getOrDefault(word, 0) + 1);\\n            \\n\\t\\t\\tif (substringWordsMap.get(word) > wordsMap.getOrDefault(word, 0))\\n                return false;\\n        }\\n        return substringWordsMap.equals(wordsMap);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1082532,
                "title": "javascript-solution",
                "content": "Thank you to jianchao-li for the great solution!\\n\\n```\\nvar findSubstring = function(s, words) {\\n    \\n    let res = [];\\n\\n    let wordLength = words[0].length;\\n    let wordCount = words.length;\\n    let len = wordCount * wordLength; //Length of sliding window\\n    \\n    let map = {}\\n    \\n    for (let word of words) map[word] = map[word] + 1 || 1; //Hash word freq\\n\\n  \\tfor (let i = 0; i < s.length - len + 1; i++) {\\n            let sub = s.slice(i, i + len); //Generate substring of sliding window length\\n            if (isConcat(sub, map, wordLength)) res.push(i)\\n        }\\n    \\n    return res;\\n};\\n\\nfunction isConcat(sub,map,wordLength){\\n    \\n    let seen = {};\\n    for (let i = 0; i < sub.length; i+=wordLength) {\\n        let word = sub.slice(i,i + wordLength);\\n        seen[word] = seen[word] + 1 || 1\\n    }\\n    \\n    for(let key in map){\\n        if(map[key] !== seen[key]) return false; //Word freq must match between map and seen\\n    }\\n    return true;\\n}```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar findSubstring = function(s, words) {\\n    \\n    let res = [];\\n\\n    let wordLength = words[0].length;\\n    let wordCount = words.length;\\n    let len = wordCount * wordLength; //Length of sliding window\\n    \\n    let map = {}\\n    \\n    for (let word of words) map[word] = map[word] + 1 || 1; //Hash word freq\\n\\n  \\tfor (let i = 0; i < s.length - len + 1; i++) {\\n            let sub = s.slice(i, i + len); //Generate substring of sliding window length\\n            if (isConcat(sub, map, wordLength)) res.push(i)\\n        }\\n    \\n    return res;\\n};\\n\\nfunction isConcat(sub,map,wordLength){\\n    \\n    let seen = {};\\n    for (let i = 0; i < sub.length; i+=wordLength) {\\n        let word = sub.slice(i,i + wordLength);\\n        seen[word] = seen[word] + 1 || 1\\n    }\\n    \\n    for(let key in map){\\n        if(map[key] !== seen[key]) return false; //Word freq must match between map and seen\\n    }\\n    return true;\\n}```",
                "codeTag": "Unknown"
            },
            {
                "id": 13797,
                "title": "accepted-recursive-solution-using-trie-tree",
                "content": "The idea is quite simple. Just use a trie tree to accelerate testing whether a substring is valid. The value of each TrieNode is used to deal with duplication and to mark whether the word is used before.\\n\\n          static class TrieNode {\\n               int value = 0;\\n               Map<Character, TrieNode> children = new HashMap<Character, TrieNode>();\\n           }\\n    \\n           TrieNode trie;\\n    \\n\\t    // build a trie tree\\n\\t    public List<Integer> findSubstring(String S, String[] L) {\\n\\t        trie = buildTrie(L);\\n\\t        int length = getTotalLength(L);\\n\\t        List<Integer> result = new LinkedList<Integer>();\\n\\t        for (int i = 0; i < S.length() - length + 1; i++) {\\n\\t            if (isSubString(S, i, i + length))\\n\\t                result.add(i);\\n\\t        }\\n\\t        return result;\\n\\t    }\\n\\t    \\n\\t    private int getTotalLength(String[] L) {\\n\\t        int sum = 0;\\n\\t        for (String l : L)\\n\\t            sum += l.length();\\n\\t        return sum;\\n\\t    }\\n\\t    \\n\\t    private TrieNode buildTrie(String[] L) {\\n\\t        TrieNode root = new TrieNode();\\n\\t        for (String l : L)\\n\\t            addWord(root, l);\\n\\t        return root;\\n\\t    }\\n\\t    \\n\\t    private void addWord(TrieNode root, String s) {\\n\\t        TrieNode node = root;\\n\\t        for (int i = 0; i < s.length(); i++) {\\n\\t            char c = s.charAt(i);\\n\\t            TrieNode next = node.children.get(c);\\n\\t            if (next == null) {\\n\\t                next = new TrieNode();\\n\\t                node.children.put(c, next);\\n\\t            }\\n\\t            node = next;\\n\\t        }\\n\\t        node.value++;\\n\\t    }\\n\\t    \\n\\t    private boolean isSubString(String S, int start, int end) {\\n\\t    \\tif (start == end)\\n\\t    \\t\\treturn true;\\n\\t        // search in the trie tree\\n\\t        TrieNode node = trie;\\n\\t        for (int i = start; i < end; i++) {\\n\\t            char c = S.charAt(i);\\n\\t            if (node.children.get(c) == null)\\n\\t                return false;\\n\\t            node = node.children.get(c);\\n\\t            if (node.value > 0) {  // leaf & can be used\\n\\t                node.value--; // mark as used\\n\\t                if (isSubString(S, i + 1, end)) {\\n\\t                    node.value++; // mark as unused\\n\\t                    return true;\\n\\t                }\\n\\t                node.value++; // mark as unused\\n\\t            }\\n\\t        }\\n\\t        return false;\\n\\t    }",
                "solutionTags": [],
                "code": "The idea is quite simple. Just use a trie tree to accelerate testing whether a substring is valid. The value of each TrieNode is used to deal with duplication and to mark whether the word is used before.\\n\\n          static class TrieNode {\\n               int value = 0;\\n               Map<Character, TrieNode> children = new HashMap<Character, TrieNode>();\\n           }\\n    \\n           TrieNode trie;\\n    \\n\\t    // build a trie tree\\n\\t    public List<Integer> findSubstring(String S, String[] L) {\\n\\t        trie = buildTrie(L);\\n\\t        int length = getTotalLength(L);\\n\\t        List<Integer> result = new LinkedList<Integer>();\\n\\t        for (int i = 0; i < S.length() - length + 1; i++) {\\n\\t            if (isSubString(S, i, i + length))\\n\\t                result.add(i);\\n\\t        }\\n\\t        return result;\\n\\t    }\\n\\t    \\n\\t    private int getTotalLength(String[] L) {\\n\\t        int sum = 0;\\n\\t        for (String l : L)\\n\\t            sum += l.length();\\n\\t        return sum;\\n\\t    }\\n\\t    \\n\\t    private TrieNode buildTrie(String[] L) {\\n\\t        TrieNode root = new TrieNode();\\n\\t        for (String l : L)\\n\\t            addWord(root, l);\\n\\t        return root;\\n\\t    }\\n\\t    \\n\\t    private void addWord(TrieNode root, String s) {\\n\\t        TrieNode node = root;\\n\\t        for (int i = 0; i < s.length(); i++) {\\n\\t            char c = s.charAt(i);\\n\\t            TrieNode next = node.children.get(c);\\n\\t            if (next == null) {\\n\\t                next = new TrieNode();\\n\\t                node.children.put(c, next);\\n\\t            }\\n\\t            node = next;\\n\\t        }\\n\\t        node.value++;\\n\\t    }\\n\\t    \\n\\t    private boolean isSubString(String S, int start, int end) {\\n\\t    \\tif (start == end)\\n\\t    \\t\\treturn true;\\n\\t        // search in the trie tree\\n\\t        TrieNode node = trie;\\n\\t        for (int i = start; i < end; i++) {\\n\\t            char c = S.charAt(i);\\n\\t            if (node.children.get(c) == null)\\n\\t                return false;\\n\\t            node = node.children.get(c);\\n\\t            if (node.value > 0) {  // leaf & can be used\\n\\t                node.value--; // mark as used\\n\\t                if (isSubString(S, i + 1, end)) {\\n\\t                    node.value++; // mark as unused\\n\\t                    return true;\\n\\t                }\\n\\t                node.value++; // mark as unused\\n\\t            }\\n\\t        }\\n\\t        return false;\\n\\t    }",
                "codeTag": "Java"
            },
            {
                "id": 13668,
                "title": "python-solution-k-sliding-window",
                "content": "````\\ndef findSubstring(self, s, words):\\n        if not words: return []\\n        k = len(words[0])\\n        res = []\\n        for left in range(k):\\n            d = collections.Counter(words)\\n            for right in range(left + k, len(s) + 1, k):\\n                word = s[right - k: right]\\n                d[word] -= 1\\n                while d[word] < 0:\\n                    d[s[left:left + k]] += 1\\n                    left += k\\n                if left + k * len(words) == right:\\n                    res.append(left)\\n        return res",
                "solutionTags": [],
                "code": "````\\ndef findSubstring(self, s, words):\\n        if not words: return []\\n        k = len(words[0])\\n        res = []\\n        for left in range(k):\\n            d = collections.Counter(words)\\n            for right in range(left + k, len(s) + 1, k):\\n                word = s[right - k: right]\\n                d[word] -= 1\\n                while d[word] < 0:\\n                    d[s[left:left + k]] += 1\\n                    left += k\\n                if left + k * len(words) == right:\\n                    res.append(left)\\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 2418640,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n***Watch this video for the better explanation of the code.*\\nAlso you can SUBSCRIBE \\uD83E\\uDC83 this channel for the daily leetcode challange solution.**\\n\\nhttps://www.youtube.com/watch?v=JbCcTa7vyBE\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int wordsquan= words.size();\\n        int wordsleng= words[0].size();\\n        int target= wordsquan * wordsleng;\\n        unordered_map<string, int> unmap;\\n        \\n    for(int j=0; j< wordsquan; j++)\\n    {\\n        unmap[words[j]]++; \\n    }\\n        vector<int > ans;\\n        if(s.size()<target)\\n        {\\n            return ans;\\n        }\\n    for(int i=0; i<=s.size()-target; i++)\\n    {\\n        unordered_map<string, int> unmap2;\\n        unmap2= unmap; \\n        int k;\\n        for( k=0; k< wordsquan; k++)\\n        {\\n                string s1= s.substr(i+k*wordsleng, wordsleng);\\n                if(unmap2.count(s1)==0)\\n                break;\\n                else if(unmap2[s1]!=0)\\n                    unmap2[s1]--;\\n                else\\n                    break;       \\n        }\\n            \\n                if(k==wordsquan)\\n                {\\n                ans.push_back(i);\\n                }\\n            \\n            \\n    }\\n        return ans;\\n    }\\n};\\n```\\n**JAVA**(Copied)\\n```\\nclass Solution \\n{\\n    public List<Integer> findSubstring(String s, String[] words) \\n    {\\n        if(words[0].length()*words.length>s.length())\\n            return new ArrayList<>();\\n        \\n        Map<String,Integer> word_frq=new HashMap<>();\\n        List<Integer> ans=new ArrayList<>();\\n        \\n        // Map store the frequency of every word in words[]\\n        \\n        for(String str:words)\\n            word_frq.put(str,word_frq.getOrDefault(str,0)+1);\\n        \\n        int wordlen=words[0].length();  \\n        \\n        String[] str=new String[s.length()];\\n        \\n        for(int i=0;i<wordlen;i++)\\n        {\\n            Map<String,Integer> frq=new HashMap<>();  // count frequency of words inside the window\\n            \\n            int begin=i,size=0; // size is the no. of window and begin is the starting index of window\\n            \\n            // s.length()-wordlen -> based on observation\\n            \\n            for(int j=i;j<=s.length()-wordlen;j+=wordlen)\\n            {\\n                str[j]=s.substring(j,j+wordlen);  // window\\n                if(word_frq.containsKey(str[j]))\\n                {\\n                    begin= begin==-1? j:begin; // begin=-1 means new window need to be started\\n                    frq.put(str[j],frq.getOrDefault(str[j],0)+1); \\n                    size++; \\n                    \\n                    if(size==words.length)  // substring may be possible\\n                    {\\n                        if(frq.equals(word_frq))\\n                            ans.add(begin);\\n                        \\n                        // sliding the window \\n                        \\n                        frq.put(str[begin],frq.get(str[begin])-1); \\n                        begin+=wordlen;  // new starting index\\n                        size--;\\n                    }\\n                }\\n                else  // reset window\\n                {\\n                    begin=-1;\\n                    size=0;\\n                    frq.clear();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**PYTHON**((Copied)\\n```\\n   res = []\\n    WordLen = [len(s) for s in words]\\n    WordIni = [  s[0] for s in words]\\n    TotWordLen =     sum(WordLen)\\n    LongestWordLen = max(WordLen)\\n    \\n    d = {}\\n    for i in range(len(words)):\\n        if words[i] not in d:\\n            d[words[i]] = [i]\\n        else:\\n            d[words[i]].append(i) \\n            \\n    \\n    def isCCT(string):\\n        \\n        copy_d = copy.deepcopy(d)\\n        temp = \\'\\'\\n        #print(\\'isCCT:\\',string,copy_d)\\n        \\n        for c in string:\\n            temp += c\\n            if temp in copy_d:\\n                \\n                if len(copy_d[temp]) > 1:\\n                    copy_d[temp].pop()\\n                else:\\n                    del copy_d[temp]\\n                temp = \\'\\'\\n            elif len(temp) >= LongestWordLen:\\n                #print(\\'isCCT:\\',string, temp, \\'zero patience\\')\\n                return False\\n        \\n        #print(\\'isCCT:\\',string, temp)    \\n        if temp == \\'\\' and len(copy_d) == 0:\\n            return True\\n        else:\\n            return False\\n    \\n    \\n    for i in range(len(s)):\\n        if s[i] in WordIni:\\n            if (i + TotWordLen - 1) <= len(s): \\n                testSubStr = s[i:i + TotWordLen]\\n                #print(i,testSubStr)\\n                if isCCT(testSubStr) == True:\\n                    res.append(i)\\n                \\n    return res\\n```**Please Don\\'t forget to UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int wordsquan= words.size();\\n        int wordsleng= words[0].size();\\n        int target= wordsquan * wordsleng;\\n        unordered_map<string, int> unmap;\\n        \\n    for(int j=0; j< wordsquan; j++)\\n    {\\n        unmap[words[j]]++; \\n    }\\n        vector<int > ans;\\n        if(s.size()<target)\\n        {\\n            return ans;\\n        }\\n    for(int i=0; i<=s.size()-target; i++)\\n    {\\n        unordered_map<string, int> unmap2;\\n        unmap2= unmap; \\n        int k;\\n        for( k=0; k< wordsquan; k++)\\n        {\\n                string s1= s.substr(i+k*wordsleng, wordsleng);\\n                if(unmap2.count(s1)==0)\\n                break;\\n                else if(unmap2[s1]!=0)\\n                    unmap2[s1]--;\\n                else\\n                    break;       \\n        }\\n            \\n                if(k==wordsquan)\\n                {\\n                ans.push_back(i);\\n                }\\n            \\n            \\n    }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\n    public List<Integer> findSubstring(String s, String[] words) \\n    {\\n        if(words[0].length()*words.length>s.length())\\n            return new ArrayList<>();\\n        \\n        Map<String,Integer> word_frq=new HashMap<>();\\n        List<Integer> ans=new ArrayList<>();\\n        \\n        // Map store the frequency of every word in words[]\\n        \\n        for(String str:words)\\n            word_frq.put(str,word_frq.getOrDefault(str,0)+1);\\n        \\n        int wordlen=words[0].length();  \\n        \\n        String[] str=new String[s.length()];\\n        \\n        for(int i=0;i<wordlen;i++)\\n        {\\n            Map<String,Integer> frq=new HashMap<>();  // count frequency of words inside the window\\n            \\n            int begin=i,size=0; // size is the no. of window and begin is the starting index of window\\n            \\n            // s.length()-wordlen -> based on observation\\n            \\n            for(int j=i;j<=s.length()-wordlen;j+=wordlen)\\n            {\\n                str[j]=s.substring(j,j+wordlen);  // window\\n                if(word_frq.containsKey(str[j]))\\n                {\\n                    begin= begin==-1? j:begin; // begin=-1 means new window need to be started\\n                    frq.put(str[j],frq.getOrDefault(str[j],0)+1); \\n                    size++; \\n                    \\n                    if(size==words.length)  // substring may be possible\\n                    {\\n                        if(frq.equals(word_frq))\\n                            ans.add(begin);\\n                        \\n                        // sliding the window \\n                        \\n                        frq.put(str[begin],frq.get(str[begin])-1); \\n                        begin+=wordlen;  // new starting index\\n                        size--;\\n                    }\\n                }\\n                else  // reset window\\n                {\\n                    begin=-1;\\n                    size=0;\\n                    frq.clear();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\n   res = []\\n    WordLen = [len(s) for s in words]\\n    WordIni = [  s[0] for s in words]\\n    TotWordLen =     sum(WordLen)\\n    LongestWordLen = max(WordLen)\\n    \\n    d = {}\\n    for i in range(len(words)):\\n        if words[i] not in d:\\n            d[words[i]] = [i]\\n        else:\\n            d[words[i]].append(i) \\n            \\n    \\n    def isCCT(string):\\n        \\n        copy_d = copy.deepcopy(d)\\n        temp = \\'\\'\\n        #print(\\'isCCT:\\',string,copy_d)\\n        \\n        for c in string:\\n            temp += c\\n            if temp in copy_d:\\n                \\n                if len(copy_d[temp]) > 1:\\n                    copy_d[temp].pop()\\n                else:\\n                    del copy_d[temp]\\n                temp = \\'\\'\\n            elif len(temp) >= LongestWordLen:\\n                #print(\\'isCCT:\\',string, temp, \\'zero patience\\')\\n                return False\\n        \\n        #print(\\'isCCT:\\',string, temp)    \\n        if temp == \\'\\' and len(copy_d) == 0:\\n            return True\\n        else:\\n            return False\\n    \\n    \\n    for i in range(len(s)):\\n        if s[i] in WordIni:\\n            if (i + TotWordLen - 1) <= len(s): \\n                testSubStr = s[i:i + TotWordLen]\\n                #print(i,testSubStr)\\n                if isCCT(testSubStr) == True:\\n                    res.append(i)\\n                \\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1367134,
                "title": "c-simple-and-easy-sliding-window-solution-28-ms-faster-than-97",
                "content": "We start from each i and count the words we find starting from i till the end.\\nIf we found a word more times than the frequency of it in the list, then we have to start from the beginning.\\nIf we found n words, then we have a solution.\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].size(), n = words.size(), ssize = s.size(), left, found;\\n        vector<int> res;\\n        \\n        unordered_map<string, int> freq, tmp;\\n        for (auto word : words) freq[word]++;\\n            \\n        for (int i = 0; i < len; i++) {\\n            tmp.clear();\\n            left = i, found = 0;\\n            \\n            for (int j = i; j <= ssize - len; j += len) {\\n                string curr = s.substr(j, len);\\n                \\n                if (freq.find(curr) != freq.end()) {\\n                    tmp[curr]++;\\n                    found++;\\n\\n                    while (freq[curr] < tmp[curr]) {\\n                        tmp[s.substr(left, len)]--;\\n                        found--;\\n                        left += len;\\n                    }\\n\\n                    if (found == n) res.push_back(left);\\n                }\\n                \\n                else {\\n                    tmp.clear();\\n                    found = 0;\\n                    left = j + len;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].size(), n = words.size(), ssize = s.size(), left, found;\\n        vector<int> res;\\n        \\n        unordered_map<string, int> freq, tmp;\\n        for (auto word : words) freq[word]++;\\n            \\n        for (int i = 0; i < len; i++) {\\n            tmp.clear();\\n            left = i, found = 0;\\n            \\n            for (int j = i; j <= ssize - len; j += len) {\\n                string curr = s.substr(j, len);\\n                \\n                if (freq.find(curr) != freq.end()) {\\n                    tmp[curr]++;\\n                    found++;\\n\\n                    while (freq[curr] < tmp[curr]) {\\n                        tmp[s.substr(left, len)]--;\\n                        found--;\\n                        left += len;\\n                    }\\n\\n                    if (found == n) res.push_back(left);\\n                }\\n                \\n                else {\\n                    tmp.clear();\\n                    found = 0;\\n                    left = j + len;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418859,
                "title": "python-elegant-short-sliding-window-98-89-faster",
                "content": "![image](https://assets.leetcode.com/users/images/85899573-7ca7-4b61-9499-b4ba0c46df99_1660381001.113569.png)\\n\\n```\\nfrom collections import Counter, defaultdict\\n\\n\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(n*k), n = length of s, k = length of each word\\n\\tMemory: O(m*k), m = length of words, k = length of each word\\n\\t\"\"\"\\n\\n\\tdef findSubstring(self, s: str, words: List[str]) -> List[int]:\\n\\t\\tlength = len(words[0])\\n\\t\\tword_count = Counter(words)\\n\\t\\tindexes = []\\n\\n\\t\\tfor i in range(length):\\n\\t\\t\\tstart = i\\n\\t\\t\\twindow = defaultdict(int)\\n\\t\\t\\twords_used = 0\\n\\n\\t\\t\\tfor j in range(i, len(s) - length + 1, length):\\n\\t\\t\\t\\tword = s[j:j + length]\\n\\n\\t\\t\\t\\tif word not in word_count:\\n\\t\\t\\t\\t\\tstart = j + length\\n\\t\\t\\t\\t\\twindow = defaultdict(int)\\n\\t\\t\\t\\t\\twords_used = 0\\n\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\twords_used += 1\\n\\t\\t\\t\\twindow[word] += 1\\n\\n\\t\\t\\t\\twhile window[word] > word_count[word]:\\n\\t\\t\\t\\t\\twindow[s[start:start + length]] -= 1\\n\\t\\t\\t\\t\\tstart += length\\n\\t\\t\\t\\t\\twords_used -= 1\\n\\n\\t\\t\\t\\tif words_used == len(words):\\n\\t\\t\\t\\t\\tindexes.append(start)\\n\\n\\t\\treturn indexes\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nfrom collections import Counter, defaultdict\\n\\n\\nclass Solution:\\n\\t\"\"\"\\n\\tTime:   O(n*k), n = length of s, k = length of each word\\n\\tMemory: O(m*k), m = length of words, k = length of each word\\n\\t\"\"\"\\n\\n\\tdef findSubstring(self, s: str, words: List[str]) -> List[int]:\\n\\t\\tlength = len(words[0])\\n\\t\\tword_count = Counter(words)\\n\\t\\tindexes = []\\n\\n\\t\\tfor i in range(length):\\n\\t\\t\\tstart = i\\n\\t\\t\\twindow = defaultdict(int)\\n\\t\\t\\twords_used = 0\\n\\n\\t\\t\\tfor j in range(i, len(s) - length + 1, length):\\n\\t\\t\\t\\tword = s[j:j + length]\\n\\n\\t\\t\\t\\tif word not in word_count:\\n\\t\\t\\t\\t\\tstart = j + length\\n\\t\\t\\t\\t\\twindow = defaultdict(int)\\n\\t\\t\\t\\t\\twords_used = 0\\n\\t\\t\\t\\t\\tcontinue\\n\\n\\t\\t\\t\\twords_used += 1\\n\\t\\t\\t\\twindow[word] += 1\\n\\n\\t\\t\\t\\twhile window[word] > word_count[word]:\\n\\t\\t\\t\\t\\twindow[s[start:start + length]] -= 1\\n\\t\\t\\t\\t\\tstart += length\\n\\t\\t\\t\\t\\twords_used -= 1\\n\\n\\t\\t\\t\\tif words_used == len(words):\\n\\t\\t\\t\\t\\tindexes.append(start)\\n\\n\\t\\treturn indexes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 373766,
                "title": "c-solution-32ms-based-on-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> result;\\n\\t\\tif (words.empty())return result;\\n\\t\\tunordered_map<string, int> counts, record;\\n\\t\\tfor (string word : words) {\\n\\t\\t\\tcounts[word]++;\\n\\t\\t}\\n\\t\\tint len = words[0].size(), num = words.size(), sl = s.size();\\n\\t\\tfor (int i = 0; i < len; ++i) {\\n\\t\\t\\tint left = i, sum = 0;\\n            record.clear();\\n\\t\\t\\tfor (int j = i; j <= sl - len; j+=len) {\\n\\t\\t\\t\\tstring word = s.substr(j, len);\\n\\t\\t\\t\\tif (counts.count(word)) {\\n\\t\\t\\t\\t\\trecord[word]++;\\n                    sum++;\\n                    while (record[word] > counts[word])\\n                    {\\n                        //remove the most left word\\n                        record[s.substr(left, len)]--;\\n                        left += len;\\n                        sum--;\\n                    }\\n\\t\\t\\t\\t\\tif (sum == num) \\n\\t\\t\\t\\t\\t\\tresult.push_back(left);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\trecord.clear();\\n\\t\\t\\t\\t\\tsum = 0;\\n\\t\\t\\t\\t\\tleft = j + len;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> result;\\n\\t\\tif (words.empty())return result;\\n\\t\\tunordered_map<string, int> counts, record;\\n\\t\\tfor (string word : words) {\\n\\t\\t\\tcounts[word]++;\\n\\t\\t}\\n\\t\\tint len = words[0].size(), num = words.size(), sl = s.size();\\n\\t\\tfor (int i = 0; i < len; ++i) {\\n\\t\\t\\tint left = i, sum = 0;\\n            record.clear();\\n\\t\\t\\tfor (int j = i; j <= sl - len; j+=len) {\\n\\t\\t\\t\\tstring word = s.substr(j, len);\\n\\t\\t\\t\\tif (counts.count(word)) {\\n\\t\\t\\t\\t\\trecord[word]++;\\n                    sum++;\\n                    while (record[word] > counts[word])\\n                    {\\n                        //remove the most left word\\n                        record[s.substr(left, len)]--;\\n                        left += len;\\n                        sum--;\\n                    }\\n\\t\\t\\t\\t\\tif (sum == num) \\n\\t\\t\\t\\t\\t\\tresult.push_back(left);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\trecord.clear();\\n\\t\\t\\t\\t\\tsum = 0;\\n\\t\\t\\t\\t\\tleft = j + len;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 263684,
                "title": "sliding-window-solution-in-python",
                "content": "```\\n    def findSubstring(self, s: str, words: \\'List[str]\\') -> \\'List[int]\\':\\n        if not words:\\n            return []\\n        \\n        word_len, res = len(words[0]), []\\n        \\n        # start offset from 0 to word_len, and step is word_len\\n        for i in range(word_len):\\n            # reset state every epoch\\n\\t\\t\\t# counter maintain current state\\n            counter = Counter(words)\\n\\t\\t\\t# two-pointer as boundary of sliding window to traverse, and count as condition checker, update it when trigger some key changes\\n            start, end, count = i, i, len(words)\\n            while end < len(s):\\n                cur_word = s[end:end + word_len]\\n                # check is not necessary here, just for performance\\n                if cur_word in counter:\\n                    counter[cur_word] -= 1\\n                    if counter[cur_word] >= 0:\\n                        count -= 1\\n                end += word_len\\n\\n                if count == 0:\\n                    res.append(start)\\n\\n                # ensure consecutive words\\n                if end - start == word_len * len(words):\\n                    cur_word = s[start:start + word_len]\\n                    if cur_word in counter:\\n                        counter[cur_word] += 1\\n                        if counter[cur_word] > 0:\\n                            count += 1\\n                    start += word_len\\n\\n        # the order is not necessary here\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\n    def findSubstring(self, s: str, words: \\'List[str]\\') -> \\'List[int]\\':\\n        if not words:\\n            return []\\n        \\n        word_len, res = len(words[0]), []\\n        \\n        # start offset from 0 to word_len, and step is word_len\\n        for i in range(word_len):\\n            # reset state every epoch\\n\\t\\t\\t# counter maintain current state\\n            counter = Counter(words)\\n\\t\\t\\t# two-pointer as boundary of sliding window to traverse, and count as condition checker, update it when trigger some key changes\\n            start, end, count = i, i, len(words)\\n            while end < len(s):\\n                cur_word = s[end:end + word_len]\\n                # check is not necessary here, just for performance\\n                if cur_word in counter:\\n                    counter[cur_word] -= 1\\n                    if counter[cur_word] >= 0:\\n                        count -= 1\\n                end += word_len\\n\\n                if count == 0:\\n                    res.append(start)\\n\\n                # ensure consecutive words\\n                if end - start == word_len * len(words):\\n                    cur_word = s[start:start + word_len]\\n                    if cur_word in counter:\\n                        counter[cur_word] += 1\\n                        if counter[cur_word] > 0:\\n                            count += 1\\n                    start += word_len\\n\\n        # the order is not necessary here\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 181494,
                "title": "share-my-concise-javascript-solution",
                "content": "```javascript\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nconst findSubstring = (s, words) => {\\n    // Sanity check\\n    if (!words || words.length === 0) return [];\\n\\n    const m = words.length, n = words[0].length, len = m * n, result = [];\\n    \\n    // Build the word-count hash map\\n    const map = {};\\n    for (word of words) map[word] = ~~map[word] + 1;\\n\\n    // Try every possible start position i\\n    for (let i = 0; i < s.length - len + 1; i++) {\\n        // Make a copy of the hash map\\n        const temp = Object.assign({}, map);\\n\\n        for (let j = i; j < i + len; j += n) {\\n            const str = s.substr(j, n);\\n            // Cannot find the word in hash map (words list), try another position\\n            if (!(str in temp)) break;\\n            // All the same word str are found, remove it from the hash map\\n            if (--temp[str] === 0) delete temp[str];\\n        }\\n        \\n        // We have gone through the whole s and used all our words in the list\\n        if (Object.keys(temp).length === 0) result.push(i);\\n    }\\n    \\n    return result;\\n};\\n```",
                "solutionTags": [],
                "code": "```javascript\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nconst findSubstring = (s, words) => {\\n    // Sanity check\\n    if (!words || words.length === 0) return [];\\n\\n    const m = words.length, n = words[0].length, len = m * n, result = [];\\n    \\n    // Build the word-count hash map\\n    const map = {};\\n    for (word of words) map[word] = ~~map[word] + 1;\\n\\n    // Try every possible start position i\\n    for (let i = 0; i < s.length - len + 1; i++) {\\n        // Make a copy of the hash map\\n        const temp = Object.assign({}, map);\\n\\n        for (let j = i; j < i + len; j += n) {\\n            const str = s.substr(j, n);\\n            // Cannot find the word in hash map (words list), try another position\\n            if (!(str in temp)) break;\\n            // All the same word str are found, remove it from the hash map\\n            if (--temp[str] === 0) delete temp[str];\\n        }\\n        \\n        // We have gone through the whole s and used all our words in the list\\n        if (Object.keys(temp).length === 0) result.push(i);\\n    }\\n    \\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2182261,
                "title": "sliding-window-hashmap-java-solution-simple-code",
                "content": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        int n = words.length;\\n        HashMap<String, Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(words[i],map.getOrDefault(words[i],0)+1);\\n        }\\n        int k = words[0].length() * words.length;\\n        int z = words[0].length();\\n        int i = 0, j = 0;\\n        while (j < s.length()) {\\n            if (j - i + 1 == k) {\\n                String sub = s.substring(i, j + 1);\\n                HashMap<String, Integer> map2 = new HashMap<>();\\n                int p = 0;\\n                while (p < sub.length()) {\\n                    String temp = sub.substring(p, p + z);\\n                    map2.put(temp,map2.getOrDefault(temp,0)+1);\\n                    p +=z;\\n                }\\n                if (map.equals(map2)){\\n                    ans.add(i);\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        int n = words.length;\\n        HashMap<String, Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n        for (int i = 0; i < n; i++) {\\n            map.put(words[i],map.getOrDefault(words[i],0)+1);\\n        }\\n        int k = words[0].length() * words.length;\\n        int z = words[0].length();\\n        int i = 0, j = 0;\\n        while (j < s.length()) {\\n            if (j - i + 1 == k) {\\n                String sub = s.substring(i, j + 1);\\n                HashMap<String, Integer> map2 = new HashMap<>();\\n                int p = 0;\\n                while (p < sub.length()) {\\n                    String temp = sub.substring(p, p + z);\\n                    map2.put(temp,map2.getOrDefault(temp,0)+1);\\n                    p +=z;\\n                }\\n                if (map.equals(map2)){\\n                    ans.add(i);\\n                }\\n                i++;\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417760,
                "title": "hashmap",
                "content": "class Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n        int n = words.size();\\n        int len = words[0].size();\\n        vector<int> ans;\\n        \\n        unordered_map<string, int> mp;\\n        \\n        for(string &str : words) {\\n            mp[str]++;\\n        }\\n        \\n        for(int i=0; i<s.size()-(n*len)+1; i++) {\\n            unordered_map<string, int>m;\\n            for(int j=i; j<i+n*len; j+=len) {\\n                string str = s.substr(j, len);\\n                m[str]++;\\n            }\\n            if(mp == m) {\\n                ans.push_back(i);\\n            }\\n           \\n        }\\n        return ans;\\n    }\\n};****",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n        int n = words.size();\\n        int len = words[0].size();\\n        vector<int> ans;\\n        \\n        unordered_map<string, int> mp;\\n        \\n        for(string &str : words) {\\n            mp[str]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2136167,
                "title": "c-faster-than-92-72-of-c-less-than-91-23-of-c",
                "content": "Runtime: 40 ms, faster than 92.72% of C++ online submissions for Substring with Concatenation of All Words.\\nMemory Usage: 16.5 MB, less than 91.23% of C++ online submissions for Substring with Concatenation of All Words.\\n\\nHere we are using the concept of longest-substring-without-repeating-characters\\nLink: https://leetcode.com/problems/longest-substring-without-repeating-characters/\\n\\nLets understand the approach with example:\\n\\n\"wordgoodgoodgoodbestword\", \\nwords = [\"word\",\"good\",\"best\",\"word\"]\\n\\nWe will store the word and its freq in a map, lets name the map as \"contain\".\\ncontain[words[i]]++\\n\\nOur map will look like:\\nword = 2\\ngood = 1\\nbest = 1\\n\\nlet len = length of words in words, ie len = words[0].length()\\n\\nThen we will use two loops to iterate \\nOutermost loop will determine the starting which is from 0 to  len - 1\\nInnermost loop will do a jump of i += len\\nand within this we will implement longest substring without repeating.\\n\\nLets try to visualise why we used two loop\\n\\ns = \"wordgoodgoodgoodbestword\", \\nwords = [\"word\",\"good\",\"best\",\"word\"]\\n\\nWe can break this as\\n\\nword good good good best word \\nor\\nw ordg oodg oodg oodb estw ord\\nor\\nwo rdgo odgo odgo odbe stwo rd\\nor\\nwor dgoo dgoo dgoo dbes twor d\\n\\nif we further break it then it will be identical to the first \\n\\nNow after breaking, we just need to find the  longest substring without repeating-characters\\nBut here our words may repeat as per the freq so instead of > 1 we will use > contain[word[i]] (contain is the map we made earlier) in our if condition.\\n\\nCode:\\n```\\n    vector<int> findSubstring(string str, vector<string>& words) {\\n        int len = words[0].length();\\n        \\n        unordered_map<string, int> contain;\\n        for(string s: words) contain[s]++;\\n        \\n        vector<int> res;\\n        for(int j = 0; j < len; j++) {\\n            unordered_map<string, int> found;\\n            int st = j;\\n            for(int i = 0 + j; i < str.size() - len + 1; i += len) {\\n                string curr = str.substr(i, len);\\n                if(contain.find(curr) != contain.end()) {\\n                    found[curr]++;\\n                    while(found[curr] > contain[curr]) {\\n                        found[str.substr(st, len)]--;\\n                        st += len;\\n                    }\\n                    int size = (i - st + len) / len;\\n                    if(size == words.size()) {\\n                        cout << j << \" \" << st << \" \" << i << endl;\\n                        res.push_back(st);\\n                    }\\n                } else {\\n                    found.clear();\\n                    st = i + len;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```\\n\\nPS: I am not a good with writing explanations so please bear with that\\nIf it helped please upvote.\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    vector<int> findSubstring(string str, vector<string>& words) {\\n        int len = words[0].length();\\n        \\n        unordered_map<string, int> contain;\\n        for(string s: words) contain[s]++;\\n        \\n        vector<int> res;\\n        for(int j = 0; j < len; j++) {\\n            unordered_map<string, int> found;\\n            int st = j;\\n            for(int i = 0 + j; i < str.size() - len + 1; i += len) {\\n                string curr = str.substr(i, len);\\n                if(contain.find(curr) != contain.end()) {\\n                    found[curr]++;\\n                    while(found[curr] > contain[curr]) {\\n                        found[str.substr(st, len)]--;\\n                        st += len;\\n                    }\\n                    int size = (i - st + len) / len;\\n                    if(size == words.size()) {\\n                        cout << j << \" \" << st << \" \" << i << endl;\\n                        res.push_back(st);\\n                    }\\n                } else {\\n                    found.clear();\\n                    st = i + len;\\n                }\\n            }\\n        }\\n        \\n        return res;\\n    }\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1902490,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    let map: [Character: Int] = [\\n        \"a\": 11,\\n        \"b\": 13,\\n        \"c\": 17,\\n        \"d\": 19,\\n        \"e\": 23,\\n        \"f\": 29,\\n        \"g\": 31,\\n        \"h\": 37,\\n        \"i\": 39,\\n        \"j\": 41,\\n        \"k\": 43,\\n        \"l\": 47,\\n        \"m\": 53,\\n        \"n\": 59,\\n        \"o\": 61,\\n        \"p\": 67,\\n        \"q\": 71,\\n        \"r\": 73,\\n        \"s\": 79,\\n        \"t\": 83,\\n        \"u\": 89,\\n        \"v\": 97,\\n        \"w\": 101,\\n        \"x\": 103,\\n        \"y\": 107,\\n        \"z\": 109\\n    ]\\n\\n\\n    func hash(_ s: [Character]) -> Int {\\n        var hashvalue: Int = 0\\n        for c in s {  hashvalue += map[c]! }\\n        return hashvalue\\n    }\\n\\n\\n    func findSubstring(_ s: String, _ words: [String]) -> [Int] {\\n        let s = Array(s)\\n        let words = words.map({ Array($0) })\\n        let sLength = s.count\\n        let wLength = words.reduce(0, { $0 + $1.count })\\n        \\n        if sLength < wLength { return [] }\\n        \\n        let wHash = words.reduce(0, { $0 + hash($1) })\\n        let wSubLength = words.count > 0 ? words[0].count : 0\\n        var invalidStringList: [[Character]] = []\\n        var validStringList: [[Character]] = []\\n        var res: [Int] = []\\n        var i = 0\\n        var sHash = 0\\n\\n        while i <= sLength - wLength {\\n            if i == 0 {\\n                sHash = hash(Array(s[i..<i+wLength]))\\n            } else {\\n                sHash += map[s[i + wLength - 1]]! - map[s[i - 1]]!\\n            }\\n            if wHash == sHash {\\n                let subString = Array(s[i..<i + wLength])\\n                if invalidStringList.contains(subString) {\\n                    i += 1\\n                    continue\\n                }\\n                if validStringList.contains(subString) {\\n                    res.append(i)\\n                    i += 1\\n                    continue\\n                }\\n                var is_match = true\\n                var words = words\\n                for j in 0..<words.count {\\n                    let word = Array(s[(i + j * wSubLength)..<(i + (j + 1) * wSubLength)])\\n                    if !words.contains(word) {\\n                        is_match = false\\n                        break\\n                    } else {\\n                        let index = words.firstIndex(of: word)!\\n                        words.remove(at: index)\\n                    }\\n                }\\n                if is_match {\\n                    res.append(i)\\n                    validStringList.append(subString)\\n                } else {\\n                    invalidStringList.append(subString)\\n                }\\n            }\\n            i += 1\\n        }\\n        return res\\n    }\\n\\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    let map: [Character: Int] = [\\n        \"a\": 11,\\n        \"b\": 13,\\n        \"c\": 17,\\n        \"d\": 19,\\n        \"e\": 23,\\n        \"f\": 29,\\n        \"g\": 31,\\n        \"h\": 37,\\n        \"i\": 39,\\n        \"j\": 41,\\n        \"k\": 43,\\n        \"l\": 47,\\n        \"m\": 53,\\n        \"n\": 59,\\n        \"o\": 61,\\n        \"p\": 67,\\n        \"q\": 71,\\n        \"r\": 73,\\n        \"s\": 79,\\n        \"t\": 83,\\n        \"u\": 89,\\n        \"v\": 97,\\n        \"w\": 101,\\n        \"x\": 103,\\n        \"y\": 107,\\n        \"z\": 109\\n    ]\\n\\n\\n    func hash(_ s: [Character]) -> Int {\\n        var hashvalue: Int = 0\\n        for c in s {  hashvalue += map[c]! }\\n        return hashvalue\\n    }\\n\\n\\n    func findSubstring(_ s: String, _ words: [String]) -> [Int] {\\n        let s = Array(s)\\n        let words = words.map({ Array($0) })\\n        let sLength = s.count\\n        let wLength = words.reduce(0, { $0 + $1.count })\\n        \\n        if sLength < wLength { return [] }\\n        \\n        let wHash = words.reduce(0, { $0 + hash($1) })\\n        let wSubLength = words.count > 0 ? words[0].count : 0\\n        var invalidStringList: [[Character]] = []\\n        var validStringList: [[Character]] = []\\n        var res: [Int] = []\\n        var i = 0\\n        var sHash = 0\\n\\n        while i <= sLength - wLength {\\n            if i == 0 {\\n                sHash = hash(Array(s[i..<i+wLength]))\\n            } else {\\n                sHash += map[s[i + wLength - 1]]! - map[s[i - 1]]!\\n            }\\n            if wHash == sHash {\\n                let subString = Array(s[i..<i + wLength])\\n                if invalidStringList.contains(subString) {\\n                    i += 1\\n                    continue\\n                }\\n                if validStringList.contains(subString) {\\n                    res.append(i)\\n                    i += 1\\n                    continue\\n                }\\n                var is_match = true\\n                var words = words\\n                for j in 0..<words.count {\\n                    let word = Array(s[(i + j * wSubLength)..<(i + (j + 1) * wSubLength)])\\n                    if !words.contains(word) {\\n                        is_match = false\\n                        break\\n                    } else {\\n                        let index = words.firstIndex(of: word)!\\n                        words.remove(at: index)\\n                    }\\n                }\\n                if is_match {\\n                    res.append(i)\\n                    validStringList.append(subString)\\n                } else {\\n                    invalidStringList.append(subString)\\n                }\\n            }\\n            i += 1\\n        }\\n        return res\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 175458,
                "title": "sliding-window-logical-thinking-reuse-lc-438",
                "content": ">All words share the same length, if we regard each word as a character,  we could apply the same idea as [Solution for 438. Find All Anagrams in a String](https://leetcode.com/problems/find-all-anagrams-in-a-string/discuss/175381/Beats-96-Sliding-Window-Java-with-Explanations).\\n\\n>Current window `[i, j]` for `i`, `j` move `wordLength` characters per step.\\n\\n>As long as window\\'s length equals to `wordsTotalLength`, we validate current window.\\n\\n>To cover all possible starting indices of concatenation, we should do LC438 for `wordLength` rounds. In each round, `i` starts at `round`.\\n\\n****\\n```\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        if (s == null || s.isEmpty() || words == null || words.length == 0) return new ArrayList<>();\\n        \\n        int wordLength = words[0].length(), wordsTotalLength = wordLength * words.length;\\n        List<Integer> startIndices = new ArrayList<>();\\n        \\n        // Map word to its frequency in words.\\n        Map<String, Integer> wordToFreqWords = new HashMap<>();\\n        for (String word : words) {\\n            wordToFreqWords.put(word, wordToFreqWords.getOrDefault(word, 0) + 1);\\n        }\\n        \\n        Map<String, Integer> wordToFreqWindow;\\n        \\n        for (int round = 0; round < wordLength; round++) {\\n            int j = round + wordLength - 1;\\n            wordToFreqWindow = new HashMap<>();\\n            for (int i = round; i + wordsTotalLength - 1 < s.length(); i += wordLength) {\\n                while (j - i + 1 <= wordsTotalLength) { \\n                    String word = s.substring(j - wordLength + 1, j + 1);\\n                    wordToFreqWindow.put(word, wordToFreqWindow.getOrDefault(word, 0) + 1);\\n                    j += wordLength;\\n                }\\n\\n                if (wordToFreqWindow.equals(wordToFreqWords)) startIndices.add(i);\\n                \\n                String word = s.substring(i, i + wordLength);\\n                wordToFreqWindow.put(word, wordToFreqWindow.getOrDefault(word, 0) - 1);\\n                if (wordToFreqWindow.get(word) == 0) wordToFreqWindow.remove(word);\\n            }\\n        }\\n        \\n        return startIndices;\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        if (s == null || s.isEmpty() || words == null || words.length == 0) return new ArrayList<>();\\n        \\n        int wordLength = words[0].length(), wordsTotalLength = wordLength * words.length;\\n        List<Integer> startIndices = new ArrayList<>();\\n        \\n        // Map word to its frequency in words.\\n        Map<String, Integer> wordToFreqWords = new HashMap<>();\\n        for (String word : words) {\\n            wordToFreqWords.put(word, wordToFreqWords.getOrDefault(word, 0) + 1);\\n        }\\n        \\n        Map<String, Integer> wordToFreqWindow;\\n        \\n        for (int round = 0; round < wordLength; round++) {\\n            int j = round + wordLength - 1;\\n            wordToFreqWindow = new HashMap<>();\\n            for (int i = round; i + wordsTotalLength - 1 < s.length(); i += wordLength) {\\n                while (j - i + 1 <= wordsTotalLength) { \\n                    String word = s.substring(j - wordLength + 1, j + 1);\\n                    wordToFreqWindow.put(word, wordToFreqWindow.getOrDefault(word, 0) + 1);\\n                    j += wordLength;\\n                }\\n\\n                if (wordToFreqWindow.equals(wordToFreqWords)) startIndices.add(i);\\n                \\n                String word = s.substring(i, i + wordLength);\\n                wordToFreqWindow.put(word, wordToFreqWindow.getOrDefault(word, 0) - 1);\\n                if (wordToFreqWindow.get(word) == 0) wordToFreqWindow.remove(word);\\n            }\\n        }\\n        \\n        return startIndices;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13766,
                "title": "very-very-straightforward-python-solution",
                "content": "When we saw this problem at the first sight, we can come up with `O(n*k)` solution easily. That is, for every position `s[i]`, we check that whether the `k` words is `s[i:i + k*length)]`. But unfortunately it got TLE.\\n\\nAnd then we found that there are a lot of situations we calculated duplicately. If we use the result we have calculated, it would be faster. Based on above thought, we have solution below.\\n\\n    class Solution(object):\\n        '''\\n        Variables:\\n          - window:    words queue appeared in order.\\n          - localCout:     appeared times of each word in current window.\\n    \\n        Processing:\\n          - if current word is not in `words`, then we should re-start calculating from\\n            next word.\\n          - if current word is in `words` and it's appeared times beyond that in `words`,\\n            then we should set the left boundary of `window` to position next to that in\\n            which current word appeared the first time.\\n          - if the length of window equals to that of `words`, then we get one pefect\\n            position.\\n        '''\\n        def findSubstring(self, s, words):\\n            n, m, r = len(words), len(words[0]) if words else 0, []\\n            counter = collections.Counter(words)\\n    \\n            for i in xrange(m):\\n                localCout = collections.defaultdict(int)\\n                window = collections.deque()\\n    \\n                for j in xrange(i, len(s), m):\\n                    word = s[j:j + m]\\n                    if word in counter:\\n                        localCout[word] += 1\\n                        window.append(word)\\n    \\n                        while localCout[word] > counter[word]:\\n                            localCout[window.popleft()] -= 1\\n    \\n                        if len(window) == n:\\n                            r.append(j - (n - 1) * m)\\n                    else:\\n                        localCout.clear()\\n                        window.clear()\\n            return r",
                "solutionTags": [
                    "Python"
                ],
                "code": "When we saw this problem at the first sight, we can come up with `O(n*k)` solution easily. That is, for every position `s[i]`, we check that whether the `k` words is `s[i:i + k*length)]`. But unfortunately it got TLE.\\n\\nAnd then we found that there are a lot of situations we calculated duplicately. If we use the result we have calculated, it would be faster. Based on above thought, we have solution below.\\n\\n    class Solution(object):\\n        '''\\n        Variables:\\n          - window:    words queue appeared in order.\\n          - localCout:     appeared times of each word in current window.\\n    \\n        Processing:\\n          - if current word is not in `words`, then we should re-start calculating from\\n            next word.\\n          - if current word is in `words` and it's appeared times beyond that in `words`,\\n            then we should set the left boundary of `window` to position next to that in\\n            which current word appeared the first time.\\n          - if the length of window equals to that of `words`, then we get one pefect\\n            position.\\n        '''\\n        def findSubstring(self, s, words):\\n            n, m, r = len(words), len(words[0]) if words else 0, []\\n            counter = collections.Counter(words)\\n    \\n            for i in xrange(m):\\n                localCout = collections.defaultdict(int)\\n                window = collections.deque()\\n    \\n                for j in xrange(i, len(s), m):\\n                    word = s[j:j + m]\\n                    if word in counter:\\n                        localCout[word] += 1\\n                        window.append(word)\\n    \\n                        while localCout[word] > counter[word]:\\n                            localCout[window.popleft()] -= 1\\n    \\n                        if len(window) == n:\\n                            r.append(j - (n - 1) * m)\\n                    else:\\n                        localCout.clear()\\n                        window.clear()\\n            return r",
                "codeTag": "Java"
            },
            {
                "id": 3188059,
                "title": "c-sliding-window-hash-map-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIdea is store the words in a map and then check in string s if the words are present in a particular window or not if yes thwn push the index in ans vector else move to next window.\\nSo here window size = m*p \\nwhere m=words.size() , p=words[0].size();\\nSo if we check each  window of this size in s whther the words are present or not.\\nWe can have a map that will check the occurence of word in s = occurence in words vector. So if there is some word in s in a particular window which is not present in words vector that window is invalid, we will move to next window and check for the same again . If all the words are presnet then push the starting index of window in the answer vector.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n*m*p)-(m*p)^2$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(m*p)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        map<string,int>mp;\\n        int ws=words.size();\\n        int wsz=words[0].size();\\n        for(auto w:words)mp[w]++;\\n        int window=ws*wsz;\\n        vector<int>ans;\\n        for(int i=0;i<s.size()-window+1;i++){\\n           unordered_map<string,int>seen;\\n           bool f=true;\\n           for(int j=0;j<ws;j++){\\n              string t=s.substr(i+j*wsz,wsz);\\n               seen[t]++;\\n               if(seen[t]>mp[t]){\\n                   f=false;\\n                   break;\\n               }\\n           }\\n           if(f)\\n           ans.push_back(i);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        map<string,int>mp;\\n        int ws=words.size();\\n        int wsz=words[0].size();\\n        for(auto w:words)mp[w]++;\\n        int window=ws*wsz;\\n        vector<int>ans;\\n        for(int i=0;i<s.size()-window+1;i++){\\n           unordered_map<string,int>seen;\\n           bool f=true;\\n           for(int j=0;j<ws;j++){\\n              string t=s.substr(i+j*wsz,wsz);\\n               seen[t]++;\\n               if(seen[t]>mp[t]){\\n                   f=false;\\n                   break;\\n               }\\n           }\\n           if(f)\\n           ans.push_back(i);\\n\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568181,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n***Watch this video for the better explanation of the code.*\\nAlso you can SUBSCRIBE \\uD83E\\uDC83 this channel for the daily leetcode challange solution.**\\n\\nhttps://www.youtube.com/watch?v=JbCcTa7vyBE\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int wordsquan= words.size();\\n        int wordsleng= words[0].size();\\n        int target= wordsquan * wordsleng;\\n        unordered_map<string, int> unmap;\\n        \\n    for(int j=0; j< wordsquan; j++)\\n    {\\n        unmap[words[j]]++; \\n    }\\n        vector<int > ans;\\n        if(s.size()<target)\\n        {\\n            return ans;\\n        }\\n    for(int i=0; i<=s.size()-target; i++)\\n    {\\n        unordered_map<string, int> unmap2;\\n        unmap2= unmap; \\n        int k;\\n        for( k=0; k< wordsquan; k++)\\n        {\\n                string s1= s.substr(i+k*wordsleng, wordsleng);\\n                if(unmap2.count(s1)==0)\\n                break;\\n                else if(unmap2[s1]!=0)\\n                    unmap2[s1]--;\\n                else\\n                    break;       \\n        }\\n            \\n                if(k==wordsquan)\\n                {\\n                ans.push_back(i);\\n                }\\n            \\n            \\n    }\\n        return ans;\\n    }\\n};\\n```\\n**JAVA**(Copied)\\n```\\nclass Solution \\n{\\n    public List<Integer> findSubstring(String s, String[] words) \\n    {\\n        if(words[0].length()*words.length>s.length())\\n            return new ArrayList<>();\\n        \\n        Map<String,Integer> word_frq=new HashMap<>();\\n        List<Integer> ans=new ArrayList<>();\\n        \\n        // Map store the frequency of every word in words[]\\n        \\n        for(String str:words)\\n            word_frq.put(str,word_frq.getOrDefault(str,0)+1);\\n        \\n        int wordlen=words[0].length();  \\n        \\n        String[] str=new String[s.length()];\\n        \\n        for(int i=0;i<wordlen;i++)\\n        {\\n            Map<String,Integer> frq=new HashMap<>();  // count frequency of words inside the window\\n            \\n            int begin=i,size=0; // size is the no. of window and begin is the starting index of window\\n            \\n            // s.length()-wordlen -> based on observation\\n            \\n            for(int j=i;j<=s.length()-wordlen;j+=wordlen)\\n            {\\n                str[j]=s.substring(j,j+wordlen);  // window\\n                if(word_frq.containsKey(str[j]))\\n                {\\n                    begin= begin==-1? j:begin; // begin=-1 means new window need to be started\\n                    frq.put(str[j],frq.getOrDefault(str[j],0)+1); \\n                    size++; \\n                    \\n                    if(size==words.length)  // substring may be possible\\n                    {\\n                        if(frq.equals(word_frq))\\n                            ans.add(begin);\\n                        \\n                        // sliding the window \\n                        \\n                        frq.put(str[begin],frq.get(str[begin])-1); \\n                        begin+=wordlen;  // new starting index\\n                        size--;\\n                    }\\n                }\\n                else  // reset window\\n                {\\n                    begin=-1;\\n                    size=0;\\n                    frq.clear();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**PYTHON**((Copied)\\n```\\n   res = []\\n    WordLen = [len(s) for s in words]\\n    WordIni = [  s[0] for s in words]\\n    TotWordLen =     sum(WordLen)\\n    LongestWordLen = max(WordLen)\\n    \\n    d = {}\\n    for i in range(len(words)):\\n        if words[i] not in d:\\n            d[words[i]] = [i]\\n        else:\\n            d[words[i]].append(i) \\n            \\n    \\n    def isCCT(string):\\n        \\n        copy_d = copy.deepcopy(d)\\n        temp = \\'\\'\\n        #print(\\'isCCT:\\',string,copy_d)\\n        \\n        for c in string:\\n            temp += c\\n            if temp in copy_d:\\n                \\n                if len(copy_d[temp]) > 1:\\n                    copy_d[temp].pop()\\n                else:\\n                    del copy_d[temp]\\n                temp = \\'\\'\\n            elif len(temp) >= LongestWordLen:\\n                #print(\\'isCCT:\\',string, temp, \\'zero patience\\')\\n                return False\\n        \\n        #print(\\'isCCT:\\',string, temp)    \\n        if temp == \\'\\' and len(copy_d) == 0:\\n            return True\\n        else:\\n            return False\\n    \\n    \\n    for i in range(len(s)):\\n        if s[i] in WordIni:\\n            if (i + TotWordLen - 1) <= len(s): \\n                testSubStr = s[i:i + TotWordLen]\\n                #print(i,testSubStr)\\n                if isCCT(testSubStr) == True:\\n                    res.append(i)\\n                \\n    return res\\n```**Please Don\\'t forget to UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int wordsquan= words.size();\\n        int wordsleng= words[0].size();\\n        int target= wordsquan * wordsleng;\\n        unordered_map<string, int> unmap;\\n        \\n    for(int j=0; j< wordsquan; j++)\\n    {\\n        unmap[words[j]]++; \\n    }\\n        vector<int > ans;\\n        if(s.size()<target)\\n        {\\n            return ans;\\n        }\\n    for(int i=0; i<=s.size()-target; i++)\\n    {\\n        unordered_map<string, int> unmap2;\\n        unmap2= unmap; \\n        int k;\\n        for( k=0; k< wordsquan; k++)\\n        {\\n                string s1= s.substr(i+k*wordsleng, wordsleng);\\n                if(unmap2.count(s1)==0)\\n                break;\\n                else if(unmap2[s1]!=0)\\n                    unmap2[s1]--;\\n                else\\n                    break;       \\n        }\\n            \\n                if(k==wordsquan)\\n                {\\n                ans.push_back(i);\\n                }\\n            \\n            \\n    }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\n    public List<Integer> findSubstring(String s, String[] words) \\n    {\\n        if(words[0].length()*words.length>s.length())\\n            return new ArrayList<>();\\n        \\n        Map<String,Integer> word_frq=new HashMap<>();\\n        List<Integer> ans=new ArrayList<>();\\n        \\n        // Map store the frequency of every word in words[]\\n        \\n        for(String str:words)\\n            word_frq.put(str,word_frq.getOrDefault(str,0)+1);\\n        \\n        int wordlen=words[0].length();  \\n        \\n        String[] str=new String[s.length()];\\n        \\n        for(int i=0;i<wordlen;i++)\\n        {\\n            Map<String,Integer> frq=new HashMap<>();  // count frequency of words inside the window\\n            \\n            int begin=i,size=0; // size is the no. of window and begin is the starting index of window\\n            \\n            // s.length()-wordlen -> based on observation\\n            \\n            for(int j=i;j<=s.length()-wordlen;j+=wordlen)\\n            {\\n                str[j]=s.substring(j,j+wordlen);  // window\\n                if(word_frq.containsKey(str[j]))\\n                {\\n                    begin= begin==-1? j:begin; // begin=-1 means new window need to be started\\n                    frq.put(str[j],frq.getOrDefault(str[j],0)+1); \\n                    size++; \\n                    \\n                    if(size==words.length)  // substring may be possible\\n                    {\\n                        if(frq.equals(word_frq))\\n                            ans.add(begin);\\n                        \\n                        // sliding the window \\n                        \\n                        frq.put(str[begin],frq.get(str[begin])-1); \\n                        begin+=wordlen;  // new starting index\\n                        size--;\\n                    }\\n                }\\n                else  // reset window\\n                {\\n                    begin=-1;\\n                    size=0;\\n                    frq.clear();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\n   res = []\\n    WordLen = [len(s) for s in words]\\n    WordIni = [  s[0] for s in words]\\n    TotWordLen =     sum(WordLen)\\n    LongestWordLen = max(WordLen)\\n    \\n    d = {}\\n    for i in range(len(words)):\\n        if words[i] not in d:\\n            d[words[i]] = [i]\\n        else:\\n            d[words[i]].append(i) \\n            \\n    \\n    def isCCT(string):\\n        \\n        copy_d = copy.deepcopy(d)\\n        temp = \\'\\'\\n        #print(\\'isCCT:\\',string,copy_d)\\n        \\n        for c in string:\\n            temp += c\\n            if temp in copy_d:\\n                \\n                if len(copy_d[temp]) > 1:\\n                    copy_d[temp].pop()\\n                else:\\n                    del copy_d[temp]\\n                temp = \\'\\'\\n            elif len(temp) >= LongestWordLen:\\n                #print(\\'isCCT:\\',string, temp, \\'zero patience\\')\\n                return False\\n        \\n        #print(\\'isCCT:\\',string, temp)    \\n        if temp == \\'\\' and len(copy_d) == 0:\\n            return True\\n        else:\\n            return False\\n    \\n    \\n    for i in range(len(s)):\\n        if s[i] in WordIni:\\n            if (i + TotWordLen - 1) <= len(s): \\n                testSubStr = s[i:i + TotWordLen]\\n                #print(i,testSubStr)\\n                if isCCT(testSubStr) == True:\\n                    res.append(i)\\n                \\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2450785,
                "title": "short-c-java-python-explained-solution-beginner-friendly-by-mr-coder",
                "content": "**Please UPVOTE if you LIKE!!**\\n***Watch this video for the better explanation of the code.*\\nAlso you can SUBSCRIBE \\uD83E\\uDC83 this channel for the daily leetcode challange solution.**\\n\\nhttps://www.youtube.com/watch?v=JbCcTa7vyBE\\nhttps://t.me/dsacoder  \\u2B05\\u2B05 **Telegram link** to discuss leetcode daily questions and other dsa problems\\n\\n\\n**C++**\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int wordsquan= words.size();\\n        int wordsleng= words[0].size();\\n        int target= wordsquan * wordsleng;\\n        unordered_map<string, int> unmap;\\n        \\n    for(int j=0; j< wordsquan; j++)\\n    {\\n        unmap[words[j]]++; \\n    }\\n        vector<int > ans;\\n        if(s.size()<target)\\n        {\\n            return ans;\\n        }\\n    for(int i=0; i<=s.size()-target; i++)\\n    {\\n        unordered_map<string, int> unmap2;\\n        unmap2= unmap; \\n        int k;\\n        for( k=0; k< wordsquan; k++)\\n        {\\n                string s1= s.substr(i+k*wordsleng, wordsleng);\\n                if(unmap2.count(s1)==0)\\n                break;\\n                else if(unmap2[s1]!=0)\\n                    unmap2[s1]--;\\n                else\\n                    break;       \\n        }\\n            \\n                if(k==wordsquan)\\n                {\\n                ans.push_back(i);\\n                }\\n            \\n            \\n    }\\n        return ans;\\n    }\\n};\\n```\\n**JAVA**(Copied)\\n```\\nclass Solution \\n{\\n    public List<Integer> findSubstring(String s, String[] words) \\n    {\\n        if(words[0].length()*words.length>s.length())\\n            return new ArrayList<>();\\n        \\n        Map<String,Integer> word_frq=new HashMap<>();\\n        List<Integer> ans=new ArrayList<>();\\n        \\n        // Map store the frequency of every word in words[]\\n        \\n        for(String str:words)\\n            word_frq.put(str,word_frq.getOrDefault(str,0)+1);\\n        \\n        int wordlen=words[0].length();  \\n        \\n        String[] str=new String[s.length()];\\n        \\n        for(int i=0;i<wordlen;i++)\\n        {\\n            Map<String,Integer> frq=new HashMap<>();  // count frequency of words inside the window\\n            \\n            int begin=i,size=0; // size is the no. of window and begin is the starting index of window\\n            \\n            // s.length()-wordlen -> based on observation\\n            \\n            for(int j=i;j<=s.length()-wordlen;j+=wordlen)\\n            {\\n                str[j]=s.substring(j,j+wordlen);  // window\\n                if(word_frq.containsKey(str[j]))\\n                {\\n                    begin= begin==-1? j:begin; // begin=-1 means new window need to be started\\n                    frq.put(str[j],frq.getOrDefault(str[j],0)+1); \\n                    size++; \\n                    \\n                    if(size==words.length)  // substring may be possible\\n                    {\\n                        if(frq.equals(word_frq))\\n                            ans.add(begin);\\n                        \\n                        // sliding the window \\n                        \\n                        frq.put(str[begin],frq.get(str[begin])-1); \\n                        begin+=wordlen;  // new starting index\\n                        size--;\\n                    }\\n                }\\n                else  // reset window\\n                {\\n                    begin=-1;\\n                    size=0;\\n                    frq.clear();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**PYTHON**((Copied)\\n```\\n   res = []\\n    WordLen = [len(s) for s in words]\\n    WordIni = [  s[0] for s in words]\\n    TotWordLen =     sum(WordLen)\\n    LongestWordLen = max(WordLen)\\n    \\n    d = {}\\n    for i in range(len(words)):\\n        if words[i] not in d:\\n            d[words[i]] = [i]\\n        else:\\n            d[words[i]].append(i) \\n            \\n    \\n    def isCCT(string):\\n        \\n        copy_d = copy.deepcopy(d)\\n        temp = \\'\\'\\n        #print(\\'isCCT:\\',string,copy_d)\\n        \\n        for c in string:\\n            temp += c\\n            if temp in copy_d:\\n                \\n                if len(copy_d[temp]) > 1:\\n                    copy_d[temp].pop()\\n                else:\\n                    del copy_d[temp]\\n                temp = \\'\\'\\n            elif len(temp) >= LongestWordLen:\\n                #print(\\'isCCT:\\',string, temp, \\'zero patience\\')\\n                return False\\n        \\n        #print(\\'isCCT:\\',string, temp)    \\n        if temp == \\'\\' and len(copy_d) == 0:\\n            return True\\n        else:\\n            return False\\n    \\n    \\n    for i in range(len(s)):\\n        if s[i] in WordIni:\\n            if (i + TotWordLen - 1) <= len(s): \\n                testSubStr = s[i:i + TotWordLen]\\n                #print(i,testSubStr)\\n                if isCCT(testSubStr) == True:\\n                    res.append(i)\\n                \\n    return res\\n```**Please Don\\'t forget to UPVOTE if you LIKE!!**",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int wordsquan= words.size();\\n        int wordsleng= words[0].size();\\n        int target= wordsquan * wordsleng;\\n        unordered_map<string, int> unmap;\\n        \\n    for(int j=0; j< wordsquan; j++)\\n    {\\n        unmap[words[j]]++; \\n    }\\n        vector<int > ans;\\n        if(s.size()<target)\\n        {\\n            return ans;\\n        }\\n    for(int i=0; i<=s.size()-target; i++)\\n    {\\n        unordered_map<string, int> unmap2;\\n        unmap2= unmap; \\n        int k;\\n        for( k=0; k< wordsquan; k++)\\n        {\\n                string s1= s.substr(i+k*wordsleng, wordsleng);\\n                if(unmap2.count(s1)==0)\\n                break;\\n                else if(unmap2[s1]!=0)\\n                    unmap2[s1]--;\\n                else\\n                    break;       \\n        }\\n            \\n                if(k==wordsquan)\\n                {\\n                ans.push_back(i);\\n                }\\n            \\n            \\n    }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\n    public List<Integer> findSubstring(String s, String[] words) \\n    {\\n        if(words[0].length()*words.length>s.length())\\n            return new ArrayList<>();\\n        \\n        Map<String,Integer> word_frq=new HashMap<>();\\n        List<Integer> ans=new ArrayList<>();\\n        \\n        // Map store the frequency of every word in words[]\\n        \\n        for(String str:words)\\n            word_frq.put(str,word_frq.getOrDefault(str,0)+1);\\n        \\n        int wordlen=words[0].length();  \\n        \\n        String[] str=new String[s.length()];\\n        \\n        for(int i=0;i<wordlen;i++)\\n        {\\n            Map<String,Integer> frq=new HashMap<>();  // count frequency of words inside the window\\n            \\n            int begin=i,size=0; // size is the no. of window and begin is the starting index of window\\n            \\n            // s.length()-wordlen -> based on observation\\n            \\n            for(int j=i;j<=s.length()-wordlen;j+=wordlen)\\n            {\\n                str[j]=s.substring(j,j+wordlen);  // window\\n                if(word_frq.containsKey(str[j]))\\n                {\\n                    begin= begin==-1? j:begin; // begin=-1 means new window need to be started\\n                    frq.put(str[j],frq.getOrDefault(str[j],0)+1); \\n                    size++; \\n                    \\n                    if(size==words.length)  // substring may be possible\\n                    {\\n                        if(frq.equals(word_frq))\\n                            ans.add(begin);\\n                        \\n                        // sliding the window \\n                        \\n                        frq.put(str[begin],frq.get(str[begin])-1); \\n                        begin+=wordlen;  // new starting index\\n                        size--;\\n                    }\\n                }\\n                else  // reset window\\n                {\\n                    begin=-1;\\n                    size=0;\\n                    frq.clear();\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\n   res = []\\n    WordLen = [len(s) for s in words]\\n    WordIni = [  s[0] for s in words]\\n    TotWordLen =     sum(WordLen)\\n    LongestWordLen = max(WordLen)\\n    \\n    d = {}\\n    for i in range(len(words)):\\n        if words[i] not in d:\\n            d[words[i]] = [i]\\n        else:\\n            d[words[i]].append(i) \\n            \\n    \\n    def isCCT(string):\\n        \\n        copy_d = copy.deepcopy(d)\\n        temp = \\'\\'\\n        #print(\\'isCCT:\\',string,copy_d)\\n        \\n        for c in string:\\n            temp += c\\n            if temp in copy_d:\\n                \\n                if len(copy_d[temp]) > 1:\\n                    copy_d[temp].pop()\\n                else:\\n                    del copy_d[temp]\\n                temp = \\'\\'\\n            elif len(temp) >= LongestWordLen:\\n                #print(\\'isCCT:\\',string, temp, \\'zero patience\\')\\n                return False\\n        \\n        #print(\\'isCCT:\\',string, temp)    \\n        if temp == \\'\\' and len(copy_d) == 0:\\n            return True\\n        else:\\n            return False\\n    \\n    \\n    for i in range(len(s)):\\n        if s[i] in WordIni:\\n            if (i + TotWordLen - 1) <= len(s): \\n                testSubStr = s[i:i + TotWordLen]\\n                #print(i,testSubStr)\\n                if isCCT(testSubStr) == True:\\n                    res.append(i)\\n                \\n    return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1279986,
                "title": "easy-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> v1;\\n       \\n        int n=words.size();\\n        int len=words[0].length();\\n        int k=n*len;\\n       if(s.length()<k)return v1;\\n        unordered_map <string,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[words[i]]++;\\n        }\\n        for(int i=0;i<=s.length()-k;i++)\\n        {\\n            \\n            int count=n;\\n            int st=i;\\n            unordered_map<string,int> mp1;\\n            while(count)\\n            {\\n               \\n                string s1=s.substr(st,len);\\n                mp1[s1]++;\\n                if(mp.find(s1)!=mp.end() && mp[s1]>=mp1[s1])\\n                {\\n                    count--;\\n                    st+=len;\\n                }\\n                else break;\\n                \\n            }\\n            if(count==0)\\n            {\\n                v1.push_back(i);\\n                \\n            }\\n           \\n        }\\n        return v1;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> v1;\\n       \\n        int n=words.size();\\n        int len=words[0].length();\\n        int k=n*len;\\n       if(s.length()<k)return v1;\\n        unordered_map <string,int> mp;\\n        for(int i=0;i<n;i++)\\n        {\\n            mp[words[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 457214,
                "title": "python-easy-sliding-window-solution-with-explanation",
                "content": "The intuition of this problem is using sliding window concept, because apparently we are looking for a ***substring*** having some particular pattern.\\n\\nWe then introduce a counter to represent this pattern - how many does each word should have in this particular range of substring? To do so, we remove the word from the counter if it is in the sliding window, and when the window size equals the total characters in `words` list (`wordlen * nwords`), we append the left index into the answer list if all values in the counters is `0`.\\n\\nLastly, we need to do this process for `wordlen` times, such that each character in string `s` can be iterated over as a start index.\\n\\n``` python\\nclass Solution:\\n    def findSubstring(self, s, words):\\n        \"\"\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        if not words or not s:\\n            return []\\n        \\n        wordlen, nwords = len(words[0]), len(words)\\n        indices = []\\n        \\n\\t\\t# iterative over `wordlen` times\\n        for i in range(wordlen):\\n            counter = collections.Counter(words)\\n\\t\\t\\t# start index of sliding window left and right pointer\\n            l = r = i\\n            while r + wordlen <= len(s):\\n\\t\\t\\t    # remove the substring from the counter\\n                counter[s[r:r+wordlen]] -= 1\\n                r += wordlen\\n\\t\\t\\t\\t# move left pointer one word offset to the right once the window size exceeds\\n                if r - l > wordlen * nwords:\\n                    counter[s[l:l+wordlen]] += 1\\n                    l += wordlen\\n\\t\\t\\t\\t# if the window size is what we want and we found that all values in counter are 0\\n\\t\\t\\t\\t# we can make sure that the substring in this window is one of the answer\\n\\t\\t\\t\\t# we are looking for\\n                if r - l == wordlen * nwords and all(count == 0 for count in counter.values()):\\n                    indices.append(l)\\n        \\n        return indices\\n            \\n```\\n\\nThe time complexity is `O(NL + WL)` where `N` is length of input string `s`, `L` is the word length, and `W` is the number of words in the `words` list.",
                "solutionTags": [],
                "code": "``` python\\nclass Solution:\\n    def findSubstring(self, s, words):\\n        \"\"\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        if not words or not s:\\n            return []\\n        \\n        wordlen, nwords = len(words[0]), len(words)\\n        indices = []\\n        \\n\\t\\t# iterative over `wordlen` times\\n        for i in range(wordlen):\\n            counter = collections.Counter(words)\\n\\t\\t\\t# start index of sliding window left and right pointer\\n            l = r = i\\n            while r + wordlen <= len(s):\\n\\t\\t\\t    # remove the substring from the counter\\n                counter[s[r:r+wordlen]] -= 1\\n                r += wordlen\\n\\t\\t\\t\\t# move left pointer one word offset to the right once the window size exceeds\\n                if r - l > wordlen * nwords:\\n                    counter[s[l:l+wordlen]] += 1\\n                    l += wordlen\\n\\t\\t\\t\\t# if the window size is what we want and we found that all values in counter are 0\\n\\t\\t\\t\\t# we can make sure that the substring in this window is one of the answer\\n\\t\\t\\t\\t# we are looking for\\n                if r - l == wordlen * nwords and all(count == 0 for count in counter.values()):\\n                    indices.append(l)\\n        \\n        return indices\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417915,
                "title": "java-very-easy-hashmap-graphical-representation-algorithm-explanation",
                "content": "# Please Upvote\\n\\n**Algorithm**\\n\\n1. Initialize some variables:\\n\\n* n as the length of s.\\n* k as the length of words\\n* wordLength as the length of each word in words.\\n* substringSize as wordLength * k, which represents the size of each valid substring.\\n* wordCount as a hash table that tracks how many times a word occurs in words.\\n\\n\\n2. Create a function check that takes a starting index i and returns if a valid substring starts at index i:\\n\\n* Create a copy of wordCount to make use of for this particular index. Let\\'s call it remaining. Also, initialize an integer wordsUsed which tracks how many matches we have found so far.\\n* Iterate starting from i. Iterate until i + substringSize - we know that each valid substring will have this size, so we don\\'t need to go further. At each iteration, we will be checking for a word - and we know each word has a length of wordLength, so increment by wordLength each time.\\n* If the variable we are iterating with is j, then at each iteration, check for a word sub = s.substring(j, j + wordLength).\\n* If sub is in remaining and has a value greater than 0, then decrease its count by 1 and increase wordsUsed by 1. Otherwise, break out of the loop.\\n* At the end of it all, if wordsUsed == k, that means we used up all the words in words and have found a valid substring. Return true if so, false otherwise.\\n\\n3. Now that we have this function check, we can just check all possible starting indices. Because a valid substring has a length of substringSize, we only need to iterate up to n - substringSize. Build an array with all indices that pass check and return it.\\n\\n![image](https://assets.leetcode.com/users/images/87443bc5-0518-4085-810e-61a19a102871_1660365761.2647388.png)\\n\\n**CODE**\\n\\n```\\nclass Solution {\\n    private HashMap<String, Integer> wordCount = new HashMap<String, Integer>();\\n    private int wordLength;\\n    private int substringSize;\\n    private int k;\\n    \\n    private boolean check(int i, String s) {\\n        // Copy the original dictionary to use for this index\\n        HashMap<String, Integer> remaining = new HashMap<>(wordCount);\\n        int wordsUsed = 0;\\n        \\n        // Each iteration will check for a match in words\\n        for (int j = i; j < i + substringSize; j += wordLength) {\\n            String sub = s.substring(j, j + wordLength);\\n            if (remaining.getOrDefault(sub, 0) != 0) {\\n                remaining.put(sub, remaining.get(sub) - 1);\\n                wordsUsed++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return wordsUsed == k;\\n    }\\n    \\n    public List<Integer> findSubstring(String s, String[] words) {\\n        int n = s.length();\\n        k = words.length;\\n        wordLength = words[0].length();\\n        substringSize = wordLength * k;\\n        \\n        for (String word : words) {\\n            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\\n        }\\n        \\n        List<Integer> answer = new ArrayList<>();\\n        for (int i = 0; i < n - substringSize + 1; i++) {\\n            if (check(i, s)) {\\n                answer.add(i);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private HashMap<String, Integer> wordCount = new HashMap<String, Integer>();\\n    private int wordLength;\\n    private int substringSize;\\n    private int k;\\n    \\n    private boolean check(int i, String s) {\\n        // Copy the original dictionary to use for this index\\n        HashMap<String, Integer> remaining = new HashMap<>(wordCount);\\n        int wordsUsed = 0;\\n        \\n        // Each iteration will check for a match in words\\n        for (int j = i; j < i + substringSize; j += wordLength) {\\n            String sub = s.substring(j, j + wordLength);\\n            if (remaining.getOrDefault(sub, 0) != 0) {\\n                remaining.put(sub, remaining.get(sub) - 1);\\n                wordsUsed++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return wordsUsed == k;\\n    }\\n    \\n    public List<Integer> findSubstring(String s, String[] words) {\\n        int n = s.length();\\n        k = words.length;\\n        wordLength = words[0].length();\\n        substringSize = wordLength * k;\\n        \\n        for (String word : words) {\\n            wordCount.put(word, wordCount.getOrDefault(word, 0) + 1);\\n        }\\n        \\n        List<Integer> answer = new ArrayList<>();\\n        for (int i = 0; i < n - substringSize + 1; i++) {\\n            if (check(i, s)) {\\n                answer.add(i);\\n            }\\n        }\\n        return answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417431,
                "title": "daily-leetcoding-challenge-august-day-13",
                "content": "This problem is the Daily LeetCoding Challenge for August, Day 13.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/substring-with-concatenation-of-all-words/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Check All Indices Using a Hash Table\n\n  \n**Approach 2:** Sliding Window\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>",
                "solutionTags": [],
                "code": "  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/substring-with-concatenation-of-all-words/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />",
                "codeTag": "Unknown"
            },
            {
                "id": 1931775,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool check(unordered_map<string, int> hash, string current, int wordSize){\\n        for(int i = 0; i < current.size(); i += wordSize){\\n            string word = current.substr(i, wordSize);\\n            \\n            if(!hash[word]) return false;\\n            hash[word]--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int size = words[0].size() * words.size();\\n        vector<int> result;\\n        unordered_map<string, int> hash;\\n        \\n        if(s.size() < size) return {};\\n    \\n        for(string word : words) hash[word]++;\\n        \\n        for(int i = 0; i <= s.size() - size; i++){\\n            if(check(hash, s.substr(i, size), words[0].size()))\\n                result.push_back(i);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```\\n\\n**Please upvote if this solution helped**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(unordered_map<string, int> hash, string current, int wordSize){\\n        for(int i = 0; i < current.size(); i += wordSize){\\n            string word = current.substr(i, wordSize);\\n            \\n            if(!hash[word]) return false;\\n            hash[word]--;\\n        }\\n        \\n        return true;\\n    }\\n    \\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int size = words[0].size() * words.size();\\n        vector<int> result;\\n        unordered_map<string, int> hash;\\n        \\n        if(s.size() < size) return {};\\n    \\n        for(string word : words) hash[word]++;\\n        \\n        for(int i = 0; i <= s.size() - size; i++){\\n            if(check(hash, s.substr(i, size), words[0].size()))\\n                result.push_back(i);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1224626,
                "title": "c-solution-with-comments",
                "content": "```\\n#include <unordered_map>\\n#include <stdio.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int wordLength = wordLength = words[0].length(); //each word in the words vector is the same length, so we can just check the first entry. Normally I would check the size of the vector before writing a line of code like this to prevent a seg fault, but the conditions of this test gauruntee the vector size will be at least 1 or greater\\n        int numberOfWords = words.size();\\n        vector<int> resultIndices; //we\\'ll use this to store the results that this function will return\\n        \\n        //copy the vector of words into an unordered_map. This map will contain a count of how many times that word appears in the words vector\\n        unordered_map<string, int> wordBankMap;\\n        for (int i = 0; i < words.size(); i++) {\\n            if (wordBankMap.find(words[i]) == wordBankMap.end()) {\\n                wordBankMap[words[i]] = 1; //if it\\'s the first time this string has been added, set the counter to 1\\n            }\\n            else {\\n                wordBankMap[words[i]] = wordBankMap[words[i]] + 1; //otherwise, increment the counter, because the vector of words can contain repeated words\\n            }\\n        }\\n        \\n        \\n        /*this is a simple check to return nothing in the case that the \"s\" string is not\\n        sufficiently long enough to check for a concatenation of the words in the vector of words*/\\n        if (wordLength * numberOfWords > s.length()) {\\n            return resultIndices;\\n        }\\n        \\n        //iterate through the whole s string, a wordLength at a time\\n        for (int idx = 0; idx <= s.length() - (numberOfWords * wordLength); idx++) {\\n            unordered_map<string, int> wordsUsedMap;\\n            \\n            //now we\\'re checking a subset to see if it matches a concatenation of the words in the words vector\\n            for (int chunkIdx = idx; chunkIdx < idx + (numberOfWords * wordLength); chunkIdx += wordLength) {\\n                //check to see if that chunk matches a word in the vector of words\\n                if (wordBankMap.find(s.substr(chunkIdx, wordLength)) == wordBankMap.end()) { //in this case, it doesn\\'t match\\n                    break;\\n                }\\n                else if (wordsUsedMap.find(s.substr(chunkIdx, wordLength)) == wordsUsedMap.end()) { //in this case, the word exists in the wordBankMap, but it hasn\\'t been accounted for in our wordsUsedMap\\n                    wordsUsedMap[s.substr(chunkIdx, wordLength)] = 1; //assign the counter to 1\\n                }\\n                else { //in this case, there already has been at least 1 entry into the wordsUsedMap, so now we just increment the counter and check if we went past our allowed count\\n                    wordsUsedMap[s.substr(chunkIdx, wordLength)] = wordsUsedMap[s.substr(chunkIdx, wordLength)] + 1;\\n                    if (wordsUsedMap[s.substr(chunkIdx, wordLength)] > wordBankMap[s.substr(chunkIdx, wordLength)]) {\\n                        break; //we went past our allotted count, so we can break out of this loop and move on\\n                    }\\n                }\\n            }\\n            \\n            if (wordsUsedMap == wordBankMap) { //if what was used matches what\\'s in the word bank, we have a winner!\\n                resultIndices.push_back(idx); //add to the results\\n            }\\n        }\\n        \\n        return resultIndices;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#include <unordered_map>\\n#include <stdio.h>\\nusing namespace std;\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int wordLength = wordLength = words[0].length(); //each word in the words vector is the same length, so we can just check the first entry. Normally I would check the size of the vector before writing a line of code like this to prevent a seg fault, but the conditions of this test gauruntee the vector size will be at least 1 or greater\\n        int numberOfWords = words.size();\\n        vector<int> resultIndices; //we\\'ll use this to store the results that this function will return\\n        \\n        //copy the vector of words into an unordered_map. This map will contain a count of how many times that word appears in the words vector\\n        unordered_map<string, int> wordBankMap;\\n        for (int i = 0; i < words.size(); i++) {\\n            if (wordBankMap.find(words[i]) == wordBankMap.end()) {\\n                wordBankMap[words[i]] = 1; //if it\\'s the first time this string has been added, set the counter to 1\\n            }\\n            else {\\n                wordBankMap[words[i]] = wordBankMap[words[i]] + 1; //otherwise, increment the counter, because the vector of words can contain repeated words\\n            }\\n        }\\n        \\n        \\n        /*this is a simple check to return nothing in the case that the \"s\" string is not\\n        sufficiently long enough to check for a concatenation of the words in the vector of words*/\\n        if (wordLength * numberOfWords > s.length()) {\\n            return resultIndices;\\n        }\\n        \\n        //iterate through the whole s string, a wordLength at a time\\n        for (int idx = 0; idx <= s.length() - (numberOfWords * wordLength); idx++) {\\n            unordered_map<string, int> wordsUsedMap;\\n            \\n            //now we\\'re checking a subset to see if it matches a concatenation of the words in the words vector\\n            for (int chunkIdx = idx; chunkIdx < idx + (numberOfWords * wordLength); chunkIdx += wordLength) {\\n                //check to see if that chunk matches a word in the vector of words\\n                if (wordBankMap.find(s.substr(chunkIdx, wordLength)) == wordBankMap.end()) { //in this case, it doesn\\'t match\\n                    break;\\n                }\\n                else if (wordsUsedMap.find(s.substr(chunkIdx, wordLength)) == wordsUsedMap.end()) { //in this case, the word exists in the wordBankMap, but it hasn\\'t been accounted for in our wordsUsedMap\\n                    wordsUsedMap[s.substr(chunkIdx, wordLength)] = 1; //assign the counter to 1\\n                }\\n                else { //in this case, there already has been at least 1 entry into the wordsUsedMap, so now we just increment the counter and check if we went past our allowed count\\n                    wordsUsedMap[s.substr(chunkIdx, wordLength)] = wordsUsedMap[s.substr(chunkIdx, wordLength)] + 1;\\n                    if (wordsUsedMap[s.substr(chunkIdx, wordLength)] > wordBankMap[s.substr(chunkIdx, wordLength)]) {\\n                        break; //we went past our allotted count, so we can break out of this loop and move on\\n                    }\\n                }\\n            }\\n            \\n            if (wordsUsedMap == wordBankMap) { //if what was used matches what\\'s in the word bank, we have a winner!\\n                resultIndices.push_back(idx); //add to the results\\n            }\\n        }\\n        \\n        return resultIndices;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 13791,
                "title": "my-24ms-c-solution-o-n-time-using-an-unordered-map",
                "content": "We can leverage the fact that the strings in words have the same length to speed up our algorithm. We can divide all the possible starting points (i.e. 0..sLen-1) into wordL sequences and the i-th sequence is \\n(i, i+wordL, i+2*wordL, ...) (I=0..wordL-1). Each time we scan one sequence (for j loop). First, we need to build a dictionary based on words and unordered_map is used to simplify look-up operation (key is string, value is count). Then for each sequence starting at i, we check if s[i..i+wordL-1] is a word in dict, if no (which means it is not a word in words), then we reset count (the number of words we found in the current window starting at start), and move start to i+wordL to skip the current word and also we need to recover dict. If s[i..i+wordL-1] is a word in dict, then we check if we already found all such words before in the current window (i.e. --dict[s.substr(i, wordL)] < 0). If so, the current one is a redundant one, then we have to move forward start to remove one occurence of the current word (i.e. to make dict[s.substr(i, wordL)] == 0) so that the current word can be included in the window. We also need to update count accordingly. If we find all the words in the current window ( i.e. (++count == wSize)), then we save start to res and move start to remove one occurence of the current word to continue the search. \\nWe repeat the above process for each word sequence (i.e. each i). remember after each i iteration, we need to recover dict(map).\\n\\n    class Solution {\\n    public:\\n        vector<int> findSubstring(string s, vector<string>& words) {\\n            unordered_map<string, int> map;\\n            int i, wSize = words.size(), wL=words[0].size(), start, cur, sL=s.size(), wCnt;\\n            vector<int> res;\\n            if(sL<wL*wSize) return res;\\n            \\n            //build the map\\n            for(i=0; i<wSize; ++i)\\n                map[words[i]] = map.count(words[i])>0? ++map[words[i]]:1;\\n                \\n            for(i=0; i<wL; ++i)\\n            {// go through each possible starting point sequences\\n                start = cur = i; // start is the starting point of the current search window, cur is the end of the current search window\\n                wCnt = wSize; // reset the words to be searched\\n                while(start<=sL-wL*wSize)\\n                { // if it is a valid start\\n                    if(map.count(s.substr(cur,wL))==0){// if the current word is not one in the map, then move the starting window to the next word positon, reset wCnt and recover map counts.\\n                            for(wCnt = wSize; start!=cur; start+=wL) ++map[s.substr(start,wL)];\\n                            start +=wL; //skip the current invalid word;\\n                    }\\n                    else if(map[s.substr(cur,wL)]==0){\\n                     // if the current word is a valid word in the map, but it is already found in the current search window, then we have to move start to skip the previously found one, and update wCnt and map counts accordingly.\\n                        for(;s.substr(cur,wL)!=s.substr(start,wL); start+=wL)\\n                        {\\n                            ++map[s.substr(start,wL)];\\n                            ++wCnt;\\n                        }\\n                        start += wL;//skip the previously found one\\n                    }\\n                    else{\\n                    // if the current word is a valid one and it is not found before in the current search window\\n                        --map[s.substr(cur,wL)]; // then reduce its counter\\n                        if(--wCnt == 0) { // update wCnt, if we find all the words\\n                            res.push_back(start); // save start\\n                            ++map[s.substr(start,wL)]; //moving start to skip the first word in the current search window\\n                            start +=wL;\\n                            ++wCnt;\\n                        }\\n                    }\\n                    cur+=wL; // update cur\\n                }\\n                for(;start<cur;start+=wL)  ++map[s.substr(start,wL)];//reset the map count\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> findSubstring(string s, vector<string>& words) {\\n            unordered_map<string, int> map;\\n            int i, wSize = words.size(), wL=words[0].size(), start, cur, sL=s.size(), wCnt;\\n            vector<int> res;\\n            if(sL<wL*wSize) return res;\\n            \\n            //build the map\\n            for(i=0; i<wSize; ++i)\\n                map[words[i]] = map.count(words[i])>0? ++map[words[i]]:1;\\n                \\n            for(i=0; i<wL; ++i)\\n            {// go through each possible starting point sequences\\n                start = cur = i; // start is the starting point of the current search window, cur is the end of the current search window\\n                wCnt = wSize; // reset the words to be searched\\n                while(start<=sL-wL*wSize)\\n                { // if it is a valid start\\n                    if(map.count(s.substr(cur,wL))==0){// if the current word is not one in the map, then move the starting window to the next word positon, reset wCnt and recover map counts.\\n                            for(wCnt = wSize; start!=cur; start+=wL) ++map[s.substr(start,wL)];\\n                            start +=wL; //skip the current invalid word;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 1859027,
                "title": "c-solution-with-full-explanations-including-time-complexity",
                "content": "> **If you\\u2019re interested in coding you can join my Discord Server, link in the comment section. Also if you find any mistake please let me know. Thank you!\\u2764\\uFE0F**\\n> \\n\\n---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- We have to find all the permutations of words present in a fix size string,\\n- The possible size is the ***(length of any word * size of words).***\\n- If the given string has a size less than ***(length of any word * size of words),*** simply return ans.\\n- If not then put given words into an unordered map `unordered_map<string, int> mp`\\n- Now in the next loop, we\\u2019ll iterate elements from start till ***n-(len*size)*** & take another map to keep the word track of the current substring.\\n- In the next loop, we took the string that can be the ans. we\\u2019re keeping the words in current & check if this is present in the given words, if not then break the loop.\\n- Else we keep track of this in another map, if any point current element value in the present map became greater than the given words map then break the loop.\\n- Finally, if both map matches then push the index to ans vector.\\n- **Time complexity:** O(n^2).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\n****class Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\n//Solution 01:\\n****class Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1847319,
                "title": "javascript-using-sliding-window",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar findSubstring = function(s, words) {\\n    let totalCharCount = 0\\n    let map = new Map()\\n    \\n    let wordLength = words[0].length\\n    let wordCount = words.length\\n    \\n    let slideWindow = wordLength * wordCount\\n    \\n    for (let word of words) {\\n        map.has(word) ? map.set(word, map.get(word) + 1) : map.set(word, 1)\\n    }\\n    \\n    let leftIndex = 0\\n    let rightIndex = slideWindow - 1\\n    let result = []\\n    \\n    const helper = (tempStr) => {\\n        let visited = new Map()\\n        \\n        for (let i = 0; i < tempStr.length; i+= wordLength) {\\n            let word = tempStr.substr(i, wordLength)\\n            \\n            visited.has(word) ? visited.set(word, visited.get(word) + 1) : visited.set(word, 1)\\n        }\\n        \\n        for (let [key, val] of visited) {\\n            if (map.get(key) != val) return false\\n        }\\n        \\n        return true\\n    }\\n    \\n    while (rightIndex < s.length) {\\n        \\n        if (rightIndex - leftIndex + 1 == slideWindow) {\\n            let tempStr = s.substring(leftIndex, rightIndex + 1)\\n            \\n            if (helper(tempStr)) result.push(leftIndex)\\n            \\n            leftIndex++\\n        }\\n        \\n        \\n        rightIndex++\\n    }\\n    \\n    return result\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar findSubstring = function(s, words) {\\n    let totalCharCount = 0\\n    let map = new Map()\\n    \\n    let wordLength = words[0].length\\n    let wordCount = words.length\\n    \\n    let slideWindow = wordLength * wordCount\\n    \\n    for (let word of words) {\\n        map.has(word) ? map.set(word, map.get(word) + 1) : map.set(word, 1)\\n    }\\n    \\n    let leftIndex = 0\\n    let rightIndex = slideWindow - 1\\n    let result = []\\n    \\n    const helper = (tempStr) => {\\n        let visited = new Map()\\n        \\n        for (let i = 0; i < tempStr.length; i+= wordLength) {\\n            let word = tempStr.substr(i, wordLength)\\n            \\n            visited.has(word) ? visited.set(word, visited.get(word) + 1) : visited.set(word, 1)\\n        }\\n        \\n        for (let [key, val] of visited) {\\n            if (map.get(key) != val) return false\\n        }\\n        \\n        return true\\n    }\\n    \\n    while (rightIndex < s.length) {\\n        \\n        if (rightIndex - leftIndex + 1 == slideWindow) {\\n            let tempStr = s.substring(leftIndex, rightIndex + 1)\\n            \\n            if (helper(tempStr)) result.push(leftIndex)\\n            \\n            leftIndex++\\n        }\\n        \\n        \\n        rightIndex++\\n    }\\n    \\n    return result\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 484588,
                "title": "python-3-three-lines-counter",
                "content": "```\\nclass Solution:\\n    def findSubstring(self, S: str, W: List[str]) -> List[int]:\\n        if not W: return []\\n        LS, M, N, C = len(S), len(W), len(W[0]), collections.Counter(W)\\n        return [i for i in range(LS-M*N+1) if collections.Counter([S[a:a+N] for a in range(i,i+M*N,N)]) == C]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, S: str, W: List[str]) -> List[int]:\\n        if not W: return []\\n        LS, M, N, C = len(S), len(W), len(W[0]), collections.Counter(W)\\n        return [i for i in range(LS-M*N+1) if collections.Counter([S[a:a+N] for a in range(i,i+M*N,N)]) == C]\\n\\t\\t\\n\\t\\t\\n- Junaid Mansuri\\n- Chicago, IL",
                "codeTag": "Java"
            },
            {
                "id": 2417993,
                "title": "c-use-hashmap-easy-and-efficient-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n        vector<int> res;\\n        int n=words.size();\\n        int m=words[0].size(); // each word has the same length;\\n        int t = m*n;\\n        \\n        if(s.size() < t) return res;\\n        \\n        unordered_map<string, int> freq;\\n            \\n        for(auto it:words)\\n            freq[it]++;\\n        \\n        for(int i=0; i<=s.size()-t; i++)\\n        {\\n            unordered_map<string, int> mp = freq;\\n            \\n            int j;\\n            for(j=0; j<s.size(); j++)\\n            {\\n                string temp = s.substr(i+j*m, m); //create string of size m and starting index i+j*m\\n                \\n                if(mp[temp]==0)\\n                    break;\\n                else\\n                    mp[temp]--;\\n            }\\n            if(j==n) //check whether all word in words are in the string or not \\n                res.push_back(i);\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n        vector<int> res;\\n        int n=words.size();\\n        int m=words[0].size(); // each word has the same length;\\n        int t = m*n;\\n        \\n        if(s.size() < t) return res;\\n        \\n        unordered_map<string, int> freq;\\n            \\n        for(auto it:words)\\n            freq[it]++;\\n        \\n        for(int i=0; i<=s.size()-t; i++)\\n        {\\n            unordered_map<string, int> mp = freq;\\n            \\n            int j;\\n            for(j=0; j<s.size(); j++)\\n            {\\n                string temp = s.substr(i+j*m, m); //create string of size m and starting index i+j*m\\n                \\n                if(mp[temp]==0)\\n                    break;\\n                else\\n                    mp[temp]--;\\n            }\\n            if(j==n) //check whether all word in words are in the string or not \\n                res.push_back(i);\\n            \\n        }\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1805387,
                "title": "sliding-window-intuitive-python-solution-with-counter",
                "content": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        word_len = len(words[0])\\n        counter = collections.Counter(words)\\n        window_size = len(words) * word_len\\n        ans = []\\n        for i in range(len(s) - window_size + 1):\\n            temp = s[i:i+window_size]\\n            temp = [temp[j:j+word_len] for j in range(0, window_size, word_len)]\\n            if collections.Counter(temp) == counter:\\n                ans.append(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        word_len = len(words[0])\\n        counter = collections.Counter(words)\\n        window_size = len(words) * word_len\\n        ans = []\\n        for i in range(len(s) - window_size + 1):\\n            temp = s[i:i+window_size]\\n            temp = [temp[j:j+word_len] for j in range(0, window_size, word_len)]\\n            if collections.Counter(temp) == counter:\\n                ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 345983,
                "title": "straightforward-python-solution",
                "content": "```\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        n, num_words = len(s), len(words)\\n        if n == 0 or num_words == 0:\\n            return []\\n        count = collections.Counter(words)\\n        word_len = len(words[0])\\n        total_len = num_words * word_len\\n        res = []\\n        i = 0\\n        while i <= n - total_len:\\n            # determine whether s[i:i+total_len] is valid\\n            seen = collections.defaultdict(int)\\n            for j in range(i, i + total_len, word_len):\\n                w = s[j:j + word_len]\\n                if w in count:\\n                    seen[w] += 1\\n                    if seen[w] > count[w]:\\n                        break\\n                else:\\n                    break    \\n            if seen == count:\\n                res.append(i)\\n            i = i + 1\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        n, num_words = len(s), len(words)\\n        if n == 0 or num_words == 0:\\n            return []\\n        count = collections.Counter(words)\\n        word_len = len(words[0])\\n        total_len = num_words * word_len\\n        res = []\\n        i = 0\\n        while i <= n - total_len:\\n            # determine whether s[i:i+total_len] is valid\\n            seen = collections.defaultdict(int)\\n            for j in range(i, i + total_len, word_len):\\n                w = s[j:j + word_len]\\n                if w in count:\\n                    seen[w] += 1\\n                    if seen[w] > count[w]:\\n                        break\\n                else:\\n                    break    \\n            if seen == count:\\n                res.append(i)\\n            i = i + 1\\n        return res\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 300985,
                "title": "c-99-9-beat-single-map-solution",
                "content": "The trick with using one single hash map... Instead of simply skipping on an invalid chunk, close out the existing window and THEN skip the chunk. It\\'s like matter and anti-matter. Your dictionary must always be accurate.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n        vector <int> aResult;\\n        \\n        int aWordCount = words.size();\\n        if (aWordCount <= 0) { return aResult; }\\n        \\n        int aLen = words[0].size();\\n        if (aLen <= 0 || aLen > s.size()) { return aResult; }\\n        \\n        int aKeySize = aWordCount * aLen;\\n        if (aKeySize > s.size()) { return aResult; }\\n        \\n        unordered_map <string, int> aDic;\\n        for (auto aWord : words) { aDic[aWord]++; }\\n        \\n        int aCap = s.size() - aKeySize;\\n        \\n        //Start index of sliding window. Our stride will be aLen.\\n        for (int i=0;i<aLen;i++) {\\n            \\n            int aFront = i;\\n            int aRear = i;\\n            \\n            while (aFront <= aCap) {\\n                \\n                string aChunk = s.substr(aRear, aLen);\\n                \\n                if (aDic.find(aChunk) == aDic.end()) {\\n                    \\n                    //Close the front of the sliding window.\\n                    while (aFront < aRear) {\\n                        aDic[s.substr(aFront, aLen)]++;\\n                        aWordCount += 1;\\n                        aFront += aLen;\\n                    }\\n                    \\n                    //Advance past the current rear.\\n                    aRear += aLen;\\n                    aFront = aRear;\\n                    \\n                    continue;\\n                }\\n                \\n                if (aDic[aChunk] > 0) {\\n                    //We need to eliminate more of this word to match-all\\n                    aDic[aChunk]--;\\n                    aWordCount -= 1;\\n                    if (aWordCount == 0) {\\n                        aResult.push_back(aFront);\\n                    }\\n                    aRear += aLen;\\n                } else {\\n                    //We have too many of this word, advance the front of the window...\\n                    aDic[s.substr(aFront, aLen)]++;\\n                    aWordCount += 1;\\n                    aFront += aLen;\\n                }\\n            }\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```\\n\\nProps to the original solution provider. I have simply learned this from studying them. \\n\\nStill not 100% sure why we KNOW that we can ADVANCE the FRONT of the sliding window when (aDic[aChunk] <= 0)\\n\\nSeems like Harry Potter sorcery and wizard magic to me.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n        vector <int> aResult;\\n        \\n        int aWordCount = words.size();\\n        if (aWordCount <= 0) { return aResult; }\\n        \\n        int aLen = words[0].size();\\n        if (aLen <= 0 || aLen > s.size()) { return aResult; }\\n        \\n        int aKeySize = aWordCount * aLen;\\n        if (aKeySize > s.size()) { return aResult; }\\n        \\n        unordered_map <string, int> aDic;\\n        for (auto aWord : words) { aDic[aWord]++; }\\n        \\n        int aCap = s.size() - aKeySize;\\n        \\n        //Start index of sliding window. Our stride will be aLen.\\n        for (int i=0;i<aLen;i++) {\\n            \\n            int aFront = i;\\n            int aRear = i;\\n            \\n            while (aFront <= aCap) {\\n                \\n                string aChunk = s.substr(aRear, aLen);\\n                \\n                if (aDic.find(aChunk) == aDic.end()) {\\n                    \\n                    //Close the front of the sliding window.\\n                    while (aFront < aRear) {\\n                        aDic[s.substr(aFront, aLen)]++;\\n                        aWordCount += 1;\\n                        aFront += aLen;\\n                    }\\n                    \\n                    //Advance past the current rear.\\n                    aRear += aLen;\\n                    aFront = aRear;\\n                    \\n                    continue;\\n                }\\n                \\n                if (aDic[aChunk] > 0) {\\n                    //We need to eliminate more of this word to match-all\\n                    aDic[aChunk]--;\\n                    aWordCount -= 1;\\n                    if (aWordCount == 0) {\\n                        aResult.push_back(aFront);\\n                    }\\n                    aRear += aLen;\\n                } else {\\n                    //We have too many of this word, advance the front of the window...\\n                    aDic[s.substr(aFront, aLen)]++;\\n                    aWordCount += 1;\\n                    aFront += aLen;\\n                }\\n            }\\n        }\\n        \\n        return aResult;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166076,
                "title": "python-3-solution-with-explanation",
                "content": "Might not be the most effiecent solution but easy to understand and explained\\n\\n```\\nclass Solution:\\n    def findSubstring(self, s, words):\\n        \"\"\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        # the solution should be appended in the below list\\n        result = []\\n        \\n        # ignoring any action if the string or the list of words has 0 length\\n        if len(s) == 0 or len(words) == 0:\\n            return result\\n        \\n        from collections import Counter\\n        \\n        word_length = len(words[0])\\n        words_count = len(words)\\n        \\n        # the window size that we are going to slide\\n        window_length = words_count * word_length\\n   \\n        # temp list to store splitted window size part of the string \\n        temp = []\\n   \\n        # checking from 0 till word length before the sting end   \\n        for i in range(0,len(s) - window_length + 1):\\n            # the sliding window from the string to be checked against the words\\n            word_window = s[i:i + window_length]\\n            # splitting the window string to a list of splitted words\\n            temp = [word_window[j:j+word_length] for j in range(0, window_length, word_length)]\\n            # checking if the splitted words and original words are the same\\n            if Counter(temp) == Counter(words):\\n                # append the value of i which is the index of the first letter in the sliding window\\n                result.append(i)\\n    \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s, words):\\n        \"\"\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        # the solution should be appended in the below list\\n        result = []\\n        \\n        # ignoring any action if the string or the list of words has 0 length\\n        if len(s) == 0 or len(words) == 0:\\n            return result\\n        \\n        from collections import Counter\\n        \\n        word_length = len(words[0])\\n        words_count = len(words)\\n        \\n        # the window size that we are going to slide\\n        window_length = words_count * word_length\\n   \\n        # temp list to store splitted window size part of the string \\n        temp = []\\n   \\n        # checking from 0 till word length before the sting end   \\n        for i in range(0,len(s) - window_length + 1):\\n            # the sliding window from the string to be checked against the words\\n            word_window = s[i:i + window_length]\\n            # splitting the window string to a list of splitted words\\n            temp = [word_window[j:j+word_length] for j in range(0, window_length, word_length)]\\n            # checking if the splitted words and original words are the same\\n            if Counter(temp) == Counter(words):\\n                # append the value of i which is the index of the first letter in the sliding window\\n                result.append(i)\\n    \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3643371,
                "title": "explained-simple-and-clear-python3-code",
                "content": "\\n# Approach\\n\\nThe solution iterates through possible starting points in the given string and checks if the substring starting from each point forms a concatenated substring. It maintains a dictionary to track the occurrences of words encountered and compares it with the expected occurrences. By updating the counts while scanning the string, it identifies valid concatenated substrings and records their starting indices. The solution effectively ensures that all the words in any permutation of the input words array are present in the substring, returning the starting indices of all such valid substrings.\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wlen= len(words[0])\\n        slen= wlen*len(words)\\n        track=dict()\\n        \\n        occ = collections.Counter(words)\\n\\n        def test():\\n            for key, val in track.items():\\n                if val !=occ[key]:\\n                    return False\\n            return True\\n        res=[]\\n        #first look\\n\\n        for k in range(wlen):\\n            for i in words:\\n                track.update({i : 0})\\n            for i in range(k,slen+k,wlen):\\n                w=s[i:i+wlen]\\n                if w in words:\\n                    track.update({w: track[w]+1})\\n            if test():\\n                res.append(k)\\n            #complete\\n            for i in range(wlen+k, len(s)-slen+1,wlen):\\n                \\n                nw=s[i+slen-wlen:i+slen]\\n                pw=s[i-wlen:i]\\n                if nw in words:\\n                    track.update({nw: track[nw]+1})\\n                if pw in words:\\n                    track.update({pw: track[pw]-1})\\n                if test():\\n                    res.append(i)\\n        return res\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wlen= len(words[0])\\n        slen= wlen*len(words)\\n        track=dict()\\n        \\n        occ = collections.Counter(words)\\n\\n        def test():\\n            for key, val in track.items():\\n                if val !=occ[key]:\\n                    return False\\n            return True\\n        res=[]\\n        #first look\\n\\n        for k in range(wlen):\\n            for i in words:\\n                track.update({i : 0})\\n            for i in range(k,slen+k,wlen):\\n                w=s[i:i+wlen]\\n                if w in words:\\n                    track.update({w: track[w]+1})\\n            if test():\\n                res.append(k)\\n            #complete\\n            for i in range(wlen+k, len(s)-slen+1,wlen):\\n                \\n                nw=s[i+slen-wlen:i+slen]\\n                pw=s[i-wlen:i]\\n                if nw in words:\\n                    track.update({nw: track[nw]+1})\\n                if pw in words:\\n                    track.update({pw: track[pw]-1})\\n                if test():\\n                    res.append(i)\\n        return res\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306644,
                "title": "c-with-explanation",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach (Gives TLE)\\n- The function first initializes an empty vector **a** to store the starting indices of the substrings. It then calculates the length **n** of each word in the vector **words**, sorts the vector **words**, and calculates the total length **N** of all the words combined.\\n- The function then loops through each possible starting index **i** in **s** where a substring of length **N** can be formed. For each starting index, it uses a stringstream **ss** to concatenate substrings of length **n** starting from that index, until it has concatenated **N** characters.\\n- It then extracts the concatenated substrings from the stringstream **ss** and stores them in a vector **b**. The vector **b** is sorted and compared with the sorted vector **words**. If they are equal, it means that the substring is a concatenation of all the words in **words**, and its starting index is added to the vector **a**.\\n- If **b** is not equal to **words**, it means that the substring is not a concatenation of all the words in **words**, so the function moves to the next possible starting index by incrementing **i** by 1.\\n- Finally, the function returns the vector **a** containing all the starting indices of the substrings that are a concatenation of all the words in **words**.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(len * NlogN)$$\\n    - The time complexity of this function is $$O(len * NlogN)$$, where **len** is the length of the input string **s** and **N** is the length of all the words combined.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(N)$$\\n    - The space complexity is $$O(N)$$ for the vector **b**.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> a;\\n        int n = words.front().length();\\n        sort(words.begin(), words.end());\\n        int N = n * words.size();\\n        int len = s.length();\\n        for(int i = 0; i < len - N + 1;i++ ) {\\n            stringstream ss;\\n            for(int j = i; j < i + N; j += n) {\\n                string c = s.substr(j, n);\\n                ss << c;\\n            }\\n            vector<string> b;\\n            string str = ss.str();\\n            for(int k = 0; k < N; k += n) {\\n                b.push_back(str.substr(k, n));\\n            }\\n            sort(b.begin(), b.end());\\n            if(b == words) {\\n                a.push_back(i);  \\n            } \\n        }\\n        return a;\\n    }\\n};\\n```\\n\\n# 2nd Approach (Optimized):  Sliding Window with Hashing for Word Frequency\\n- Initialize an empty vector **result** to store the starting indices of valid concatenated substrings.\\n- Retrieve the length **n** of the input string **s** and the number of words **numWords** in the **words** array. If n is 0 or **numWords** is 0, return an empty **result** vector.\\n- Determine the length of each word **wordLen** by considering the length of the first word in the **words** array.\\n- Calculate the total length **totalLen** required for a valid concatenated substring (**totalLen = numWords * wordLen**).\\n- Create an unordered map **wordCount** to store the frequency count of each word in the **words** array.\\n- Iterate through the **words** array and update the frequency count of each word in the **wordCount** map.\\n- Begin the main loop from index 0 up to **wordLen - 1** (the length of each word).\\n- Initialize two pointers, **left** and **right**, both set to the current index of the loop.\\n- Initialize a variable **count** to keep track of the number of valid words in the current window.\\n- Create an unordered map **currentCount** to store the frequency count of words present in the current window.\\n- Enter a nested loop where **right** is iterated over the input string s using the condition **right + wordLen <= n.**\\n- Extract the **currentWord** of length **wordLen** starting from the index **right**.\\n- Increment **right** by **wordLen**.\\n- Check if **currentWord** is present in the **wordCount** map. If so, it is a valid word.\\n  - Increment the frequency count of **currentWord** in the **currentCount** map.\\n  - Increment the **count** variable.\\n  - If the frequency count of **currentWord** in **currentCount** exceeds its frequency count in **wordCount**, it means there are extra occurrences of the word. Move the **left** pointer and decrease the count and frequency until the extra occurrence is resolved.\\n  - If **count** becomes equal to **numWords**, it implies all required words are present in the current window. Add the **left** index to the **result** vector.\\n- If **currentWord** is not present in the **wordCount** map, reset **currentCount**, reset **count** to 0, and move the **left** pointer to **right**.\\n- Once the loop completes, return the **result** vector containing starting indices of valid concatenated substrings.\\n\\n\\n# Complexity\\n- Time complexity: $$O(len * wordLen)$$\\n    - where **len** is the length of the input string **s** and **wordLen** is the length of each word in the **words** array.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(wordCount)$$\\n    - the space required for the **wordCount** and **currentCount** unordered maps.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> result;\\n        int n = s.length();\\n        int numWords = words.size();\\n        if (n == 0 || numWords == 0) {\\n            return result;\\n        }\\n        \\n        int wordLen = words[0].length();\\n        int totalLen = numWords * wordLen;\\n        unordered_map<string, int> wordCount; // Stores the count of each word\\n        \\n        for (const string& word : words) {\\n            wordCount[word]++;\\n        }\\n        \\n        for (int i = 0; i < wordLen; ++i) {\\n            int left = i, right = i, count = 0;\\n            unordered_map<string, int> currentCount; // Stores count of words in current window\\n            \\n            while (right + wordLen <= n) {\\n                string currentWord = s.substr(right, wordLen);\\n                right += wordLen;\\n                \\n                if (wordCount.find(currentWord) != wordCount.end()) {\\n                    currentCount[currentWord]++;\\n                    count++;\\n                    \\n                    while (currentCount[currentWord] > wordCount[currentWord]) {\\n                        string leftWord = s.substr(left, wordLen);\\n                        left += wordLen;\\n                        currentCount[leftWord]--;\\n                        count--;\\n                    }\\n                    \\n                    if (count == numWords) {\\n                        result.push_back(left);\\n                    }\\n                } else {\\n                    currentCount.clear();\\n                    count = 0;\\n                    left = right;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sort",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> a;\\n        int n = words.front().length();\\n        sort(words.begin(), words.end());\\n        int N = n * words.size();\\n        int len = s.length();\\n        for(int i = 0; i < len - N + 1;i++ ) {\\n            stringstream ss;\\n            for(int j = i; j < i + N; j += n) {\\n                string c = s.substr(j, n);\\n                ss << c;\\n            }\\n            vector<string> b;\\n            string str = ss.str();\\n            for(int k = 0; k < N; k += n) {\\n                b.push_back(str.substr(k, n));\\n            }\\n            sort(b.begin(), b.end());\\n            if(b == words) {\\n                a.push_back(i);  \\n            } \\n        }\\n        return a;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> result;\\n        int n = s.length();\\n        int numWords = words.size();\\n        if (n == 0 || numWords == 0) {\\n            return result;\\n        }\\n        \\n        int wordLen = words[0].length();\\n        int totalLen = numWords * wordLen;\\n        unordered_map<string, int> wordCount; // Stores the count of each word\\n        \\n        for (const string& word : words) {\\n            wordCount[word]++;\\n        }\\n        \\n        for (int i = 0; i < wordLen; ++i) {\\n            int left = i, right = i, count = 0;\\n            unordered_map<string, int> currentCount; // Stores count of words in current window\\n            \\n            while (right + wordLen <= n) {\\n                string currentWord = s.substr(right, wordLen);\\n                right += wordLen;\\n                \\n                if (wordCount.find(currentWord) != wordCount.end()) {\\n                    currentCount[currentWord]++;\\n                    count++;\\n                    \\n                    while (currentCount[currentWord] > wordCount[currentWord]) {\\n                        string leftWord = s.substr(left, wordLen);\\n                        left += wordLen;\\n                        currentCount[leftWord]--;\\n                        count--;\\n                    }\\n                    \\n                    if (count == numWords) {\\n                        result.push_back(left);\\n                    }\\n                } else {\\n                    currentCount.clear();\\n                    count = 0;\\n                    left = right;\\n                }\\n            }\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3233323,
                "title": "substring-with-concatenation-of-all-words",
                "content": "[https://leetcode.com/problems/substring-with-concatenation-of-all-words/description/]()\\n[https://www.linkedin.com/in/shivansh-srivastava-cs/]()\\n# DO UPVOTE IF YOU FIND IT SUITABLE AND HELPFUL AND FOR ANY DOUBTS COMMENT.\\n# DO LIKE AS EACH VOTE COUNTS\\n\\n\\n# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> Refer and take the refernce from the find all anagrams and permutations in a string question of leetcode 438.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->  Sliding window + hashtable for each word in words list and then inside nested loop use substrcount each time new and compare for equivalence\\\\.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->The first for-loop iterates over all words in the input list words and takes O(N) time where N is the number of words in the list.\\nThe second for-loop iterates over all substrings of length len(words)*len(words[0]) in the input string s. The number of substrings will be O(M) where M is the length of the input string. For each substring, the code creates a new dictionary substrcount and iterates over all words of length len(words[0]) in the substring. This takes O(len(substr)/len(words[0])) time for each substring. Therefore, the overall time complexity of the second for-loop is O(M * len(substr)/len(words[0])) = O(M*N), where N and M are defined as before.\\nThe dictionary operations (insertion, lookup) in the code take O(1) time.\\nThus, the overall time complexity of the code is O(M*N), where N is the number of words in the input list and M is the length of the input string.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->The code uses two dictionaries, wordcount and substrcount, to store word frequencies. The maximum size of each dictionary is N (the number of words in the input list).\\nThe code stores the input string s, which takes O(M) space.\\nThe code stores the result list result, which can take up to O(M/N) space in the worst case (when all substrings are valid).\\nThus, the overall space complexity of the code is O(M + N).\\n\\nIn summary, the time complexity of the given code is O(M*N) and the space complexity is O(M + N), where N is the number of words in the input list and M is the length of the input string.\\n\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wordcount={}\\n        for word in words:\\n            wordcount[word]=1+wordcount.get(word,0)\\n        result=[]\\n        substringlength=len(words)*len(words[0])\\n        for i in range(len(s)-substringlength+1):\\n            substr=s[i:i+substringlength]\\n            substrcount={}\\n            for j in range(0,len(substr),len(words[0])):\\n                word=substr[j:j+len(words[0])]\\n                substrcount[word]=1+substrcount.get(word,0)\\n            if substrcount==wordcount:\\n                result.append(i)\\n        return result\\n\\n#         m=\\'\\'.join(words)\\n#         pcount=dict()\\n#         scount=dict()\\n#         if len(m)>len(s):\\n#             print([])\\n#         for i in range(len(m)):\\n#                  pcount[m[i]]=1+pcount.get(m[i],0)\\n#                  scount[s[i]]=1+scount.get(s[i],0)\\n# # print(pcount)\\n# # print(scount)\\n#         res=[0]if pcount==scount else []\\n#         l=0\\n#         for i in range(len(m),len(s),1):\\n#               scount[s[i]]=1+scount.get(s[i],0)\\n#               scount[s[l]]-=1 \\n#               if scount[s[l]]==0:\\n#                   del scount[s[l]]\\n#               l+=1 \\n#               if scount==pcount:\\n#                 res.append(l)\\n# #@print(res)\\n#         return res\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wordcount={}\\n        for word in words:\\n            wordcount[word]=1+wordcount.get(word,0)\\n        result=[]\\n        substringlength=len(words)*len(words[0])\\n        for i in range(len(s)-substringlength+1):\\n            substr=s[i:i+substringlength]\\n            substrcount={}\\n            for j in range(0,len(substr),len(words[0])):\\n                word=substr[j:j+len(words[0])]\\n                substrcount[word]=1+substrcount.get(word,0)\\n            if substrcount==wordcount:\\n                result.append(i)\\n        return result\\n\\n#         m=\\'\\'.join(words)\\n#         pcount=dict()\\n#         scount=dict()\\n#         if len(m)>len(s):\\n#             print([])\\n#         for i in range(len(m)):\\n#                  pcount[m[i]]=1+pcount.get(m[i],0)\\n#                  scount[s[i]]=1+scount.get(s[i],0)\\n# # print(pcount)\\n# # print(scount)\\n#         res=[0]if pcount==scount else []\\n#         l=0\\n#         for i in range(len(m),len(s),1):\\n#               scount[s[i]]=1+scount.get(s[i],0)\\n#               scount[s[l]]-=1 \\n#               if scount[s[l]]==0:\\n#                   del scount[s[l]]\\n#               l+=1 \\n#               if scount==pcount:\\n#                 res.append(l)\\n# #@print(res)\\n#         return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2103559,
                "title": "easy-and-commented-2-map-solution-with-example",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n        unordered_map < string, int > map;\\n        int l = 0, r = 0 ,cnt = words.size(), len = words[0].size(), winSize = len * cnt;\\n        \\n        //checking if string size is enough or not\\n        if(winSize > s.size() )return {};\\n        \\n        // filling all words in map\\n        for(auto str: words) map[str]++;\\n        \\n        string str = \"\";\\n        vector<int> ans; //vector to store starting ind of valid substring\\n        \\n        // as all words are of len l so to check over all possibilities of combinations words can start from 0,1,..., len-1\\n        for(int i = 0; i < len; i++){\\n            \\n            ///l,r -> starting and ending indexes of window\\n            r = i, l = i;\\n            unordered_map<string ,int> map_s;\\n            \\n            while(r < s.size()){\\n                \\n                str = s.substr( r, len );\\n                cout<<str<<\" \";\\n                r += len;\\n                map_s[str]++;\\n                \\n                // maps are equal means cur substr in window is valid so storing starting index of it\\n                if(map_s == map) \\n                    ans.push_back( l );\\n                \\n                // minimising the window\\n                if( r-l == winSize ){\\n                    \\n                    string x = s.substr( l, len );\\n                    map_s[x]-- ;\\n                    \\n                    if(map_s[x] == 0) \\n                        map_s.erase(x);\\n                    //moving starting ptr of window to next position\\n                    l+=len;\\n                    \\n                }   \\n            }\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n\"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\n\\n`outer for loop from 0->len-1 , can be understood from this example `\\n\\nling mind rabo ofoo owin gdin gbar rwin gmon keyp ound cake \\ningm indr aboo fooo wing ding barr wing monk eypo undc ake \\nngmi ndra boof ooow ingd ingb arrw ingm onke ypou ndca ke \\ngmin drab oofo oowi ngdi ngba rrwi ngmo nkey poun dcak e \\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Two Pointers"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n        unordered_map < string, int > map;\\n        int l = 0, r = 0 ,cnt = words.size(), len = words[0].size(), winSize = len * cnt;\\n        \\n        //checking if string size is enough or not\\n        if(winSize > s.size() )return {};\\n        \\n        // filling all words in map\\n        for(auto str: words) map[str]++;\\n        \\n        string str = \"\";\\n        vector<int> ans; //vector to store starting ind of valid substring\\n        \\n        // as all words are of len l so to check over all possibilities of combinations words can start from 0,1,..., len-1\\n        for(int i = 0; i < len; i++){\\n            \\n            ///l,r -> starting and ending indexes of window\\n            r = i, l = i;\\n            unordered_map<string ,int> map_s;\\n            \\n            while(r < s.size()){\\n                \\n                str = s.substr( r, len );\\n                cout<<str<<\" \";\\n                r += len;\\n                map_s[str]++;\\n                \\n                // maps are equal means cur substr in window is valid so storing starting index of it\\n                if(map_s == map) \\n                    ans.push_back( l );\\n                \\n                // minimising the window\\n                if( r-l == winSize ){\\n                    \\n                    string x = s.substr( l, len );\\n                    map_s[x]-- ;\\n                    \\n                    if(map_s[x] == 0) \\n                        map_s.erase(x);\\n                    //moving starting ptr of window to next position\\n                    l+=len;\\n                    \\n                }   \\n            }\\n            cout<<endl;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1799300,
                "title": "c-two-map-solution-commented",
                "content": "```\\nvector<int> findSubstring(string s, vector<string>& words) {\\n        int n = s.length(), wlen = words[0].length(), m = words.size();\\n        int tot = m*wlen;   //length of the window\\n        \\n        vector<int> ans;\\n        \\n        unordered_map<string, int> mp;\\n        for(auto i : words)                 //store the words in a map\\n            mp[i]++;\\n        \\n        for(int i=0;i<=n-tot; i++){\\n            unordered_map<string,int> cur;  //make a map for the words of the current window\\n            \\n            for(int j=i; j<i+tot; j+=wlen){ //add the words to the map\\n                string w = \"\";\\n                for(int k=j; k<j+wlen; k++){\\n                    w+=s[k];\\n                }\\n                cur[w]++;\\n            }\\n            if(cur==mp) ans.push_back(i);   //compare both maps\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nvector<int> findSubstring(string s, vector<string>& words) {\\n        int n = s.length(), wlen = words[0].length(), m = words.size();\\n        int tot = m*wlen;   //length of the window\\n        \\n        vector<int> ans;\\n        \\n        unordered_map<string, int> mp;\\n        for(auto i : words)                 //store the words in a map\\n            mp[i]++;\\n        \\n        for(int i=0;i<=n-tot; i++){\\n            unordered_map<string,int> cur;  //make a map for the words of the current window\\n            \\n            for(int j=i; j<i+tot; j+=wlen){ //add the words to the map\\n                string w = \"\";\\n                for(int k=j; k<j+wlen; k++){\\n                    w+=s[k];\\n                }\\n                cur[w]++;\\n            }\\n            if(cur==mp) ans.push_back(i);   //compare both maps\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1691161,
                "title": "c-solution-easy-to-understand-free-from-tle",
                "content": "class Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int n=words.size(),x=words[0].size(),window=x*n;\\n        vector<int> result;\\n        if(s.size()<n*x) return {};\\n        unordered_map<string,int> f;\\n        for(auto &x:words){\\n            f[x]++;\\n        }\\n        int limit=s.size()-window;\\n        for(int i=0;i<=limit;i++){\\n            unordered_map<string,int> m;\\n            int flag=0;\\n            \\n            for(int j=i;j<i+window;j+=x){\\n                string temp=s.substr(j,x);\\n                if(f[temp]>m[temp]){\\n                    m[temp]++;\\n                    flag++;\\n                }\\n                else break;  //important for tle\\n            }\\n            if(flag==n) result.push_back(i);\\n        }\\n        return result;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int n=words.size(),x=words[0].size(),window=x*n;\\n        vector<int> result;\\n        if(s.size()<n*x) return {}",
                "codeTag": "Java"
            },
            {
                "id": 1423256,
                "title": "js-o-l-n-m-solution-beats-98-18-in-runtime-and-43-77-in-memory-usage",
                "content": "```\\nvar findSubstring = function(s, words) {\\n    let result = [],\\n        pattern = {},\\n        wordLength = words[0].length;\\n\\n    for (const word of words) {\\n        pattern[word] = (pattern[word] || 0) + 1;\\n    }\\n\\n    for (let i = 0; i < wordLength; i++) {\\n        let back = i,\\n            front = back + wordLength,\\n            matches = {},\\n            count = 0\\n\\n        while (front <= s.length) {\\n            let word = s.slice(front - wordLength, front);\\n\\n            if (pattern[word]) {\\n                matches[word] = (matches[word] ?? 0) + 1;\\n                count++;\\n\\n                while (matches[word] > pattern[word]) {\\n                    matches[s.slice(back, back + wordLength)] -= 1;\\n                    back += wordLength;\\n                    count--;\\n                }\\n\\n                if (count === words.length) {\\n                    result.push(back)\\n                }                \\n            } else {\\n                matches = {}\\n                count = 0;\\n                back = front;\\n            }\\n\\n            front += wordLength;\\n        }\\n    }\\n\\n    return result;\\n};\\n```\\n\\ntime complexity: O(L * N + M) where L is the length of a word in \\'words\\', N is the number of letters in \\'s\\' and M is the number of words in \\'words\\'.",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nvar findSubstring = function(s, words) {\\n    let result = [],\\n        pattern = {},\\n        wordLength = words[0].length;\\n\\n    for (const word of words) {\\n        pattern[word] = (pattern[word] || 0) + 1;\\n    }\\n\\n    for (let i = 0; i < wordLength; i++) {\\n        let back = i,\\n            front = back + wordLength,\\n            matches = {},\\n            count = 0\\n\\n        while (front <= s.length) {\\n            let word = s.slice(front - wordLength, front);\\n\\n            if (pattern[word]) {\\n                matches[word] = (matches[word] ?? 0) + 1;\\n                count++;\\n\\n                while (matches[word] > pattern[word]) {\\n                    matches[s.slice(back, back + wordLength)] -= 1;\\n                    back += wordLength;\\n                    count--;\\n                }\\n\\n                if (count === words.length) {\\n                    result.push(back)\\n                }                \\n            } else {\\n                matches = {}\\n                count = 0;\\n                back = front;\\n            }\\n\\n            front += wordLength;\\n        }\\n    }\\n\\n    return result;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 816466,
                "title": "java-o-n-m-len-clear-easy-to-understand-sliding-window-solution-beats-70-of-submissions",
                "content": "I was struggling to find the intuitive solution so gonna post my own, hope that helps someone to get the clue faster.\\nPls look up numbered comments in the code to link certain pseudocode steps to actual code\\nPseudo:\\n1.  Create a map of words and store their frequencies as by the definition there can be several the same wordsin sequence f.e. \\'foodfoodfood\\'\\n2.  We are going to iterate all over the search string and lookup for our window, so in case of search string like \\'likefoodfoodfoodstring\\' and words=[food,food] we will make a sliding window of word.length()*words.length\\n3.  Create another map to track what have we seen so far and the count\\n4.  Now start another loop which will compare substrings of current words window starting from *i* position\\n5.  As the order is not important we will make substring candidate of word\\'s size \\n6.  Check if the candidate is not in our words list (fq map) than the entire substring will be invalid, so we break from the inner loop\\n7.  Now we woul like to track frequency of candidate words in substring so if the candidate matches for 3 times like in \\'foodfoodfood\\' but search sequence is \\'foodfoodlike\\' we would exit the inner loop \\n8.  if we have managed to reach till the last substring candidate that means entire sequence matches our words list so we can add start position i into our result\\n9.   return result and enjoy :) \\n\\n\\n```\\npublic List<Integer> findSubstring(String s, String[] words) {\\n       if(words.length==0) return Collections.emptyList();\\n        \\n        // 1\\n        Map<String, Integer> fqMap = new HashMap<>();\\n        for(String w: words){\\n            fqMap.put(w, fqMap.getOrDefault(w, 0)+1);\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        int count=words.length, len=words[0].length();\\n        //2\\n        for(int i=0; i<=s.length()-(count*len); i++){\\n            //3\\n            Map<String, Integer> seen = new HashMap<>();\\n            //4\\n            for(int j=0; j<count; j++){\\n                int nextIdx = i+j*len;\\n                //5\\n                String candidate = s.substring(nextIdx,nextIdx+len);\\n                //6\\n                if(!fqMap.containsKey(candidate))\\n                    break;\\n                //7\\n                seen.put(candidate, seen.getOrDefault(candidate, 0)+1);\\n                if(seen.get(candidate)>fqMap.get(candidate))\\n                    break;\\n                //8\\n                if(j == count-1){\\n                    result.add(i);\\n                }\\n            }\\n        }\\n        //9\\n        return result;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\npublic List<Integer> findSubstring(String s, String[] words) {\\n       if(words.length==0) return Collections.emptyList();\\n        \\n        // 1\\n        Map<String, Integer> fqMap = new HashMap<>();\\n        for(String w: words){\\n            fqMap.put(w, fqMap.getOrDefault(w, 0)+1);\\n        }\\n        \\n        List<Integer> result = new ArrayList<>();\\n        int count=words.length, len=words[0].length();\\n        //2\\n        for(int i=0; i<=s.length()-(count*len); i++){\\n            //3\\n            Map<String, Integer> seen = new HashMap<>();\\n            //4\\n            for(int j=0; j<count; j++){\\n                int nextIdx = i+j*len;\\n                //5\\n                String candidate = s.substring(nextIdx,nextIdx+len);\\n                //6\\n                if(!fqMap.containsKey(candidate))\\n                    break;\\n                //7\\n                seen.put(candidate, seen.getOrDefault(candidate, 0)+1);\\n                if(seen.get(candidate)>fqMap.get(candidate))\\n                    break;\\n                //8\\n                if(j == count-1){\\n                    result.add(i);\\n                }\\n            }\\n        }\\n        //9\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 739338,
                "title": "java-simple-solution-sliding-window-hashmap",
                "content": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        for (String word: words) {\\n            map.put(word, map.getOrDefault(word, 0) + 1);\\n        }\\n        \\n        \\n        List<Integer> resultIndices = new ArrayList<>();\\n        \\n        if (s == \"\" || words.length == 0) {\\n            return resultIndices;\\n        }\\n        \\n        int wordsCount = words.length;\\n        int wordLength = words[0].length();\\n        \\n        for (int i=0; i<=s.length() - wordsCount * wordLength; i++) {\\n            Map<String, Integer> wordsSeen = new HashMap<>();\\n            \\n            for (int j=0; j<wordsCount; j++) {\\n                int nextWordIndex = i + j * wordLength;\\n                String word = s.substring(nextWordIndex, nextWordIndex + wordLength);\\n                \\n                if (!map.containsKey(word)) {\\n                    break;\\n                }\\n                \\n                wordsSeen.put(word, wordsSeen.getOrDefault(word, 0) + 1);\\n                \\n                if (wordsSeen.get(word) > map.getOrDefault(word, 0)) {\\n                    break;\\n                }\\n                \\n                if (j + 1 == wordsCount) {\\n                    resultIndices.add(i);\\n                }\\n                \\n            }\\n        }\\n        \\n        return resultIndices;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        Map<String, Integer> map = new HashMap<>();\\n        \\n        for (String word: words) {\\n            map.put(word, map.getOrDefault(word, 0) + 1);\\n        }\\n        \\n        \\n        List<Integer> resultIndices = new ArrayList<>();\\n        \\n        if (s == \"\" || words.length == 0) {\\n            return resultIndices;\\n        }\\n        \\n        int wordsCount = words.length;\\n        int wordLength = words[0].length();\\n        \\n        for (int i=0; i<=s.length() - wordsCount * wordLength; i++) {\\n            Map<String, Integer> wordsSeen = new HashMap<>();\\n            \\n            for (int j=0; j<wordsCount; j++) {\\n                int nextWordIndex = i + j * wordLength;\\n                String word = s.substring(nextWordIndex, nextWordIndex + wordLength);\\n                \\n                if (!map.containsKey(word)) {\\n                    break;\\n                }\\n                \\n                wordsSeen.put(word, wordsSeen.getOrDefault(word, 0) + 1);\\n                \\n                if (wordsSeen.get(word) > map.getOrDefault(word, 0)) {\\n                    break;\\n                }\\n                \\n                if (j + 1 == wordsCount) {\\n                    resultIndices.add(i);\\n                }\\n                \\n            }\\n        }\\n        \\n        return resultIndices;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 568460,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public IList<int> FindSubstring(string s, string[] words) {\\n        \\n        List<int> res = new List<int>();      \\n        \\n        if(words.Length == 0)\\n            return res;\\n        \\n        int n = words.Length, len = words[0].Length;        \\n        Dictionary<string, int> expect = new Dictionary<string, int>();\\n        \\n        foreach(string word in words)\\n        {\\n            if(expect.ContainsKey(word))\\n                expect[word]++;\\n            else\\n                expect.Add(word, 1);\\n        }\\n        \\n        Dictionary<string, int> seen = new Dictionary<string, int>();\\n\\t\\t\\n\\t\\t// (s.Length - 1) - i + 1 = n * len --> i = s.Length - n * len\\n        for(int i = 0; i < s.Length - n * len + 1; i++)\\n        {\\n            seen.Clear();\\n            int count = 0;\\n            while(count < n)\\n            {\\n                string curr = s.Substring(i + count * len, len);\\n                \\n                if(expect.ContainsKey(curr))\\n                {\\n                    if(seen.ContainsKey(curr))\\n                        seen[curr]++;\\n                    else\\n                        seen.Add(curr, 1);\\n\\n                    if(seen[curr] > expect[curr])\\n                        break;\\n                }\\n                else\\n                    break;\\n\\n                count++;\\n            }\\n            \\n            if(count == n)\\n                res.Add(i);            \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public IList<int> FindSubstring(string s, string[] words) {\\n        \\n        List<int> res = new List<int>();      \\n        \\n        if(words.Length == 0)\\n            return res;\\n        \\n        int n = words.Length, len = words[0].Length;        \\n        Dictionary<string, int> expect = new Dictionary<string, int>();\\n        \\n        foreach(string word in words)\\n        {\\n            if(expect.ContainsKey(word))\\n                expect[word]++;\\n            else\\n                expect.Add(word, 1);\\n        }\\n        \\n        Dictionary<string, int> seen = new Dictionary<string, int>();\\n\\t\\t\\n\\t\\t// (s.Length - 1) - i + 1 = n * len --> i = s.Length - n * len\\n        for(int i = 0; i < s.Length - n * len + 1; i++)\\n        {\\n            seen.Clear();\\n            int count = 0;\\n            while(count < n)\\n            {\\n                string curr = s.Substring(i + count * len, len);\\n                \\n                if(expect.ContainsKey(curr))\\n                {\\n                    if(seen.ContainsKey(curr))\\n                        seen[curr]++;\\n                    else\\n                        seen.Add(curr, 1);\\n\\n                    if(seen[curr] > expect[curr])\\n                        break;\\n                }\\n                else\\n                    break;\\n\\n                count++;\\n            }\\n            \\n            if(count == n)\\n                res.Add(i);            \\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13655,
                "title": "aho-corasick-algorithm-o-s-length-words-len-word-count",
                "content": "The time complexity is Great.\\n1. Using Aho-Corasick algorithm to build a Trie.\\n1. Separate the string S into totally words.count numbers substring.\\n1. For each substring, scanning from first to last, and get the answer.\\n\\n**e.g.:**\\n**1. Using Aho-Corasick algorithm.**\\n```txt\\n    S : \"wwwwwopowwwoww\";\\nwords : {\"opo\",\"www\",\"oww\"};\\nwords Id:  0     1     2\\n\\n 0  1  2  3  4  5  6  7  8  9 10 11 12 13  << index\\n w  w  w  w  w  o  p  o  w  w  w  o  w  w  << string\\n-1 -1  1  1  1 -1 -1  0 -1  2  1 -1 -1  2  << Assigned ID\\n```\\n\\n**2. Separate the string S into totally 3 numbers substrings.**\\n```txt\\nS1: w(2) o(5) w(8)  o(11)  ==>  1 -1 -1  2\\nS2: w(3) p(6) w(9)  w(12)  ==>  1 -1  2 -1\\nS3: w(4) o(7) w(10) w(13)  ==>  1  0  1  2\\n```\\n\\n**3. And check each substring whether it have the ans in it.**\\nif we found continuously \"012\"/\"021\"/\"102\"/etc.. , we got the answer.\\n``` S3: 1 0 1 2 ``` have a continuously sequence \"0 1 2\" that meet the require.\\n\\n**Be aware the strings with same content in dictionary(words[])!**\\n\\n```cpp\\nclass Solution {\\n    int wordIdPtr=0;\\n    vector<int> wordIdCount;\\n    \\n    struct Trie {\\n        Trie *failure;\\n        int id=-1;\\n        Trie *next[26];\\n        Trie () {\\n            memset(next,0,sizeof(next));\\n        }\\n    }*root;\\n    void buildTrie (vector<string>& dict) {\\n        root = new Trie();\\n        for (auto it : dict) {\\n            Trie *p=root;\\n            for (int i=0; i<it.length(); i++) {\\n                if (p->next[it[i]-'a'] == nullptr)\\n                    p->next[it[i]-'a'] = new Trie();\\n                p=p->next[it[i]-'a'];\\n            }\\n            if (p->id == -1)\\n                p->id = wordIdPtr++;\\n            wordIdCount[p->id]++;\\n        }\\n        queue<Trie*> Q;\\n        for (int i=0; i<26; i++) {\\n            if (root->next[i]) {\\n                root->next[i]->failure = root;\\n                Q.push(root->next[i]);\\n            }else\\n                root->next[i] = root;\\n        }\\n        while (!Q.empty()) {\\n            Trie *x = Q.front(); Q.pop();\\n            for (int i=0; i<26; i++)\\n                if (x->next[i]) {\\n                    Trie *seek=x->failure;\\n                    while (!seek->next[i])\\n                        seek = seek->failure;\\n                    x->next[i]->failure = seek->next[i];\\n                    if (seek->next[i]->id != -1)\\n                        x->next[i]->id = seek->next[i]->id;\\n                    Q.push(x->next[i]);\\n                }\\n        }\\n    }\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> ans;\\n        if (s.length()==0 || words.size()==0 || words[0].size()==0)\\n            return ans;\\n        wordIdCount.assign(words.size(), 0);\\n        buildTrie(words);\\n        \\n        //find all words in s. O(s.length() + wordlen*wordcount)\\n        vector<int> sid(s.length());\\n        Trie *p=root;\\n        for (int i=0; i<s.length(); i++) {\\n            int chIdx = s[i]-'a';\\n            while (!p->next[chIdx])\\n                p=p->failure;\\n            p = p->next[chIdx];\\n            sid[i]=p->id;\\n            cout<<setw(2)<<sid[i]<<\" \";\\n        }\\n        cout<<\" << Assigned ID\"<<endl;\\n        for (int i=0; i<s.length(); i++)\\n            cout<<setw(2)<<s[i]<<\" \";\\n        cout<<\" << string\"<<endl;\\n        for (int i=0; i<s.length(); i++)\\n            cout<<setw(2)<<i<<\" \";\\n        cout<<\" << index\"<<endl;\\n        \\n        //getAnswer\\n        int wlen = words[0].length();\\n        for (int offset=wlen-1; offset<wlen-1+wlen; offset++) {\\n            auto idx = [&](int k) {return offset+k*wlen;};\\n            int count=0;\\n            //each item at most push and pop once.\\n            vector<queue<int>> appearPos(wordIdPtr);\\n            for (int i=0; idx(i)<s.length(); i++)\\n                if(sid[idx(i)]!=-1) {\\n                    int nowSid = sid[idx(i)];\\n                    if (appearPos[nowSid].size()+1 > wordIdCount[nowSid]) {\\n                        int stopborder=i-count;\\n                        for (int j=appearPos[nowSid].front(); j >= stopborder; j--) {\\n                            appearPos[sid[idx(j)]].pop(), count--;\\n                        }\\n                    }\\n                    appearPos[nowSid].push(i), count++;\\n                    cout<<\"\\\\twork at: \"<<idx(i)<<\" count=\"<<count<<endl;\\n                    if (count == words.size()) {\\n                        ans.push_back(idx(i)-words.size()*wlen+1);\\n                        cout<<\"Got Ans At=\"<<idx(i)<<endl;\\n                    }\\n                }else if (count){\\n                    count=0;\\n                    appearPos.assign(wordIdPtr, queue<int>());\\n                }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```txt\\n    S : \"wwwwwopowwwoww\";\\nwords : {\"opo\",\"www\",\"oww\"};\\nwords Id:  0     1     2\\n\\n 0  1  2  3  4  5  6  7  8  9 10 11 12 13  << index\\n w  w  w  w  w  o  p  o  w  w  w  o  w  w  << string\\n-1 -1  1  1  1 -1 -1  0 -1  2  1 -1 -1  2  << Assigned ID\\n```\n```txt\\nS1: w(2) o(5) w(8)  o(11)  ==>  1 -1 -1  2\\nS2: w(3) p(6) w(9)  w(12)  ==>  1 -1  2 -1\\nS3: w(4) o(7) w(10) w(13)  ==>  1  0  1  2\\n```\n``` S3: 1 0 1 2 ```\n```cpp\\nclass Solution {\\n    int wordIdPtr=0;\\n    vector<int> wordIdCount;\\n    \\n    struct Trie {\\n        Trie *failure;\\n        int id=-1;\\n        Trie *next[26];\\n        Trie () {\\n            memset(next,0,sizeof(next));\\n        }\\n    }*root;\\n    void buildTrie (vector<string>& dict) {\\n        root = new Trie();\\n        for (auto it : dict) {\\n            Trie *p=root;\\n            for (int i=0; i<it.length(); i++) {\\n                if (p->next[it[i]-'a'] == nullptr)\\n                    p->next[it[i]-'a'] = new Trie();\\n                p=p->next[it[i]-'a'];\\n            }\\n            if (p->id == -1)\\n                p->id = wordIdPtr++;\\n            wordIdCount[p->id]++;\\n        }\\n        queue<Trie*> Q;\\n        for (int i=0; i<26; i++) {\\n            if (root->next[i]) {\\n                root->next[i]->failure = root;\\n                Q.push(root->next[i]);\\n            }else\\n                root->next[i] = root;\\n        }\\n        while (!Q.empty()) {\\n            Trie *x = Q.front(); Q.pop();\\n            for (int i=0; i<26; i++)\\n                if (x->next[i]) {\\n                    Trie *seek=x->failure;\\n                    while (!seek->next[i])\\n                        seek = seek->failure;\\n                    x->next[i]->failure = seek->next[i];\\n                    if (seek->next[i]->id != -1)\\n                        x->next[i]->id = seek->next[i]->id;\\n                    Q.push(x->next[i]);\\n                }\\n        }\\n    }\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> ans;\\n        if (s.length()==0 || words.size()==0 || words[0].size()==0)\\n            return ans;\\n        wordIdCount.assign(words.size(), 0);\\n        buildTrie(words);\\n        \\n        //find all words in s. O(s.length() + wordlen*wordcount)\\n        vector<int> sid(s.length());\\n        Trie *p=root;\\n        for (int i=0; i<s.length(); i++) {\\n            int chIdx = s[i]-'a';\\n            while (!p->next[chIdx])\\n                p=p->failure;\\n            p = p->next[chIdx];\\n            sid[i]=p->id;\\n            cout<<setw(2)<<sid[i]<<\" \";\\n        }\\n        cout<<\" << Assigned ID\"<<endl;\\n        for (int i=0; i<s.length(); i++)\\n            cout<<setw(2)<<s[i]<<\" \";\\n        cout<<\" << string\"<<endl;\\n        for (int i=0; i<s.length(); i++)\\n            cout<<setw(2)<<i<<\" \";\\n        cout<<\" << index\"<<endl;\\n        \\n        //getAnswer\\n        int wlen = words[0].length();\\n        for (int offset=wlen-1; offset<wlen-1+wlen; offset++) {\\n            auto idx = [&](int k) {return offset+k*wlen;};\\n            int count=0;\\n            //each item at most push and pop once.\\n            vector<queue<int>> appearPos(wordIdPtr);\\n            for (int i=0; idx(i)<s.length(); i++)\\n                if(sid[idx(i)]!=-1) {\\n                    int nowSid = sid[idx(i)];\\n                    if (appearPos[nowSid].size()+1 > wordIdCount[nowSid]) {\\n                        int stopborder=i-count;\\n                        for (int j=appearPos[nowSid].front(); j >= stopborder; j--) {\\n                            appearPos[sid[idx(j)]].pop(), count--;\\n                        }\\n                    }\\n                    appearPos[nowSid].push(i), count++;\\n                    cout<<\"\\\\twork at: \"<<idx(i)<<\" count=\"<<count<<endl;\\n                    if (count == words.size()) {\\n                        ans.push_back(idx(i)-words.size()*wlen+1);\\n                        cout<<\"Got Ans At=\"<<idx(i)<<endl;\\n                    }\\n                }else if (count){\\n                    count=0;\\n                    appearPos.assign(wordIdPtr, queue<int>());\\n                }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 13736,
                "title": "consice-and-clear-python-solution-o-len-s-len-word-80ms",
                "content": "    class Solution(object):\\n        def findSubstring(self, s, words):\\n            \"\"\"\\n            :type s: str\\n            :type words: List[str]\\n            :rtype: List[int]\\n            \"\"\"\\n            from collections import deque, defaultdict, Counter\\n            s_len, word_len = len(s), len(words[0])\\n            word_len_total = len(words) * word_len\\n            count = Counter(words)\\n            footprint = defaultdict(deque)\\n            result = []\\n            for start in range(word_len):\\n                footprint.clear()\\n                end = start\\n                while start + word_len_total <= s_len:\\n                    sub = s[end:end+word_len]\\n                    end += word_len\\n                    if sub in count:\\n                        queue = footprint[sub]\\n                        queue.append(end)\\n                        while queue[0] < start:\\n                            queue.popleft()\\n                        if len(queue) > count[sub]:\\n                            start = queue.popleft()\\n                        if start + word_len_total == end:\\n                            result.append(start)\\n                    else:\\n                        start = end\\n            return result",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def findSubstring(self, s, words):\\n            \"\"\"\\n            :type s: str\\n            :type words: List[str]\\n            :rtype: List[int]\\n            \"\"\"\\n            from collections import deque, defaultdict, Counter\\n            s_len, word_len = len(s), len(words[0])\\n            word_len_total = len(words) * word_len\\n            count = Counter(words)\\n            footprint = defaultdict(deque)\\n            result = []\\n            for start in range(word_len):\\n                footprint.clear()\\n                end = start\\n                while start + word_len_total <= s_len:\\n                    sub = s[end:end+word_len]\\n                    end += word_len\\n                    if sub in count:\\n                        queue = footprint[sub]\\n                        queue.append(end)\\n                        while queue[0] < start:\\n                            queue.popleft()\\n                        if len(queue) > count[sub]:\\n                            start = queue.popleft()\\n                        if start + word_len_total == end:\\n                            result.append(start)\\n                    else:\\n                        start = end\\n            return result",
                "codeTag": "Java"
            },
            {
                "id": 13754,
                "title": "java-o-n-solution-when-consider-substring-as-o-1",
                "content": "Maybe this is the so called window technique. The window was moved right by the while(){} loop. Since substring() is actually expensive in Java, each time I store the substring in a variable to avoid repeatedly calling the substring() function.\\n\\nMore specifically, there are three cases that the window changes: \\n\\n1.The substring at the right of the window is not in words dictionary, then we **move the whole window to the right** side of this substring and set the window back to an **empty window**.\\n\\n2.The substring at the right of window is a candidate word and not used out by the current window, then we add this substring into window. **The window's right boundary extends**. Now **if** the window is a valid solution, add the start index of window to result and cut off the head word of the window for further checking, **the window's left boundary shrinks**.\\n\\n3.The substring at the right of window is a candidate word and is used out by the current window. Then we cut off the head word of the window, **the window's left boundary shrinks** (This would be done **repeatedly** by the while loop until the substring is not used out by the current window and could be added into the window).\\n\\n\\n\\n    public class Solution {\\n        public List<Integer> findSubstring(String s, String[] words) {\\n            List<Integer> res = new ArrayList<Integer>();\\n            if(words.length==0||words[0].length()==0) return res;\\n            Map<String,Integer> wordDict = new HashMap<String,Integer>();\\n            for(String word : words) {\\n                if(!wordDict.containsKey(word)) wordDict.put(word,1);\\n                else wordDict.put(word,wordDict.get(word) + 1);\\n            }\\n            Map<String,Integer> currWords = new HashMap<String,Integer>();\\n            int len = words[0].length();\\n            for(int i = 0; i < len; i++) {\\n                int k = i, j = i; //k is at the head of the window and j is the last.\\n                int addedCount = 0; //to indicate whether we add index to res.\\n                while(k<= s.length()-len*words.length&&j + len <= s.length()) { //make sure the remaining length is enough.\\n                    String subWord = s.substring(j,j+len);\\n                    if(!wordDict.containsKey(subWord)) { //the substring is not in words, head jumps to the right of this substring.\\n                        addedCount = 0;\\n                        currWords.clear();\\n                        j += len;\\n                        k = j;\\n                        continue;\\n                    }\\n                    if(!currWords.containsKey(subWord)||currWords.get(subWord)!=wordDict.get(subWord)) {\\n                        if(!currWords.containsKey(subWord)) currWords.put(subWord,1);\\n                        else currWords.put(subWord,currWords.get(subWord) + 1); //update the current words we used.\\n                        addedCount++;\\n                        if(addedCount == words.length) { //if get a index, add it to res. And we need to continue checking\\n                            res.add(k);\\n                            addedCount--; //remove the head and check new substring, so count-- and move head to new position.\\n                            String preHead = s.substring(k,k+len);\\n                            if(currWords.get(preHead)==1) currWords.remove(preHead); //update the currWords map.\\n                            else currWords.put(preHead,currWords.get(preHead)-1);\\n                            k += len;\\n                        }\\n                        j += len;\\n                    }\\n                    else { //the current substring was used out before. Move head len steps right.\\n                        String preHead = s.substring(k,k+len);\\n                        addedCount--;\\n                        if(currWords.get(preHead)==1) currWords.remove(preHead); //update the currWords map.\\n                        else currWords.put(preHead,currWords.get(preHead)-1);\\n                        k += len; //don't move j this case.\\n                    }\\n                }\\n                currWords.clear();\\n            }\\n            return res;\\n        }\\n    }'",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> findSubstring(String s, String[] words) {\\n            List<Integer> res = new ArrayList<Integer>();\\n            if(words.length==0||words[0].length()==0) return res;\\n            Map<String,Integer> wordDict = new HashMap<String,Integer>();\\n            for(String word : words) {\\n                if(!wordDict.containsKey(word)) wordDict.put(word,1);\\n                else wordDict.put(word,wordDict.get(word) + 1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 13800,
                "title": "520-ms-c-two-pointer-solution-o-n-len-word-with-explanations",
                "content": "520ms is the fastest C# solution in OJ so far.\\n\\nThe idea is to pick up starting point from 0 to Len(word) - 1, so we will take advantage of Hashmap for each starting point in the loop to avoid repeating creating hashmap and clear history data to save time.\\n\\nSay we have input pair (\"wordgoodgoodgoodbestword\", { \"word\", \"good\", \"best\", \"good\"}), we will loop from starting point of 'w', 'o', 'r' and 'd', and in each loop of starting point, we are checking word by word by using another right point with step of the word's length, so the hashmap will be updated at real time as the right point going ahead.\\n\\nOnce there is no matching word, the starting point will jump to right point, or word's count exceeding the dictionary's count, starting point will go ahead until hashmap refreshed to have word's count == dictionary's word count.\\n\\nCode as follow:\\n\\n    public IList<int> FindSubstring(string s, string[] words) {\\n        List<int> result = new List<int>();\\n        int wordCount = words[0].Length;\\n        IDictionary<string, int> hist = new Dictionary<string, int>(), currHist = new Dictionary<string, int>();\\n        foreach (string w in words) hist[w] = hist.ContainsKey(w) ? hist[w] + 1 : 1;\\n        for (int i = 0; i < wordCount; i++){\\n            currHist.Clear();\\n            for (int j = i, k = i; j + words.Length * wordCount <= s.Length; k += wordCount){\\n                string word = s.Substring(k, wordCount);\\n                if (!hist.ContainsKey(word)){\\n                    currHist.Clear();\\n                    j = k + wordCount;\\n                    continue;\\n                }\\n                currHist[word] = currHist.ContainsKey(word) ? currHist[word] + 1 : 1;\\n                if (currHist[word] > hist[word])\\n                    while (currHist[word] > hist[word]){\\n                        currHist[s.Substring(j, wordCount)]--;\\n                        j += wordCount;\\n                    }\\n                else if ((k - j) / wordCount == words.Length - 1){\\n                    result.Add(j);\\n                    currHist[s.Substring(j, wordCount)]--;\\n                    j += wordCount;\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "solutionTags": [
                    "Two Pointers"
                ],
                "code": "520ms is the fastest C# solution in OJ so far.\\n\\nThe idea is to pick up starting point from 0 to Len(word) - 1, so we will take advantage of Hashmap for each starting point in the loop to avoid repeating creating hashmap and clear history data to save time.\\n\\nSay we have input pair (\"wordgoodgoodgoodbestword\", { \"word\", \"good\", \"best\", \"good\"}), we will loop from starting point of 'w', 'o', 'r' and 'd', and in each loop of starting point, we are checking word by word by using another right point with step of the word's length, so the hashmap will be updated at real time as the right point going ahead.\\n\\nOnce there is no matching word, the starting point will jump to right point, or word's count exceeding the dictionary's count, starting point will go ahead until hashmap refreshed to have word's count == dictionary's word count.\\n\\nCode as follow:\\n\\n    public IList<int> FindSubstring(string s, string[] words) {\\n        List<int> result = new List<int>();\\n        int wordCount = words[0].Length;\\n        IDictionary<string, int> hist = new Dictionary<string, int>(), currHist = new Dictionary<string, int>();\\n        foreach (string w in words) hist[w] = hist.ContainsKey(w) ? hist[w] + 1 : 1;\\n        for (int i = 0; i < wordCount; i++){\\n            currHist.Clear();\\n            for (int j = i, k = i; j + words.Length * wordCount <= s.Length; k += wordCount){\\n                string word = s.Substring(k, wordCount);\\n                if (!hist.ContainsKey(word)){\\n                    currHist.Clear();\\n                    j = k + wordCount;\\n                    continue;\\n                }\\n                currHist[word] = currHist.ContainsKey(word) ? currHist[word] + 1 : 1;\\n                if (currHist[word] > hist[word])\\n                    while (currHist[word] > hist[word]){\\n                        currHist[s.Substring(j, wordCount)]--;\\n                        j += wordCount;\\n                    }\\n                else if ((k - j) / wordCount == words.Length - 1){\\n                    result.Add(j);\\n                    currHist[s.Substring(j, wordCount)]--;\\n                    j += wordCount;\\n                }\\n            }\\n        }\\n        return result;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 13755,
                "title": "accepted-java-o-n-solution-using-histogram",
                "content": "    public List<Integer> findSubstring(String S, String[] L) {\\n        List<Integer> res = new ArrayList<>();\\n        if (L.length == 0) {\\n            return res;\\n        }\\n        int len = L[0].length();\\n        int num = L.length;\\n        if (len * num > S.length()) {\\n            return res;\\n        }\\n\\n        //histogram of words in L\\n        HashMap<String, Integer> dic = new HashMap<>();\\n        for (String s : L) {\\n            if (dic.containsKey(s)) {\\n                dic.put(s, dic.get(s) + 1);\\n            } else {\\n                dic.put(s, 1);\\n            }\\n        }\\n\\n        //the word that starts from i in S\\n        String[] sDic = new String[S.length() - len + 1];\\n        for (int i = 0; i < sDic.length; i++) {\\n            String sub = S.substring(i, i + len);\\n            if (dic.containsKey(sub)) {\\n                sDic[i] = sub;\\n            } else {\\n                sDic[i] = \"\";\\n            }\\n        }\\n\\n        //traverse in order of 0,0+len,...,1,1+len,...len-1,len-1+len...therefore it is O(n) despite of two loops\\n        for (int i = 0; i < len; i++) {\\n\\n            //start of concatenation\\n            int start = i;\\n            //number of words found\\n            int found = 0;\\n            //dynamic word histogram of words in substring(start,j);\\n            HashMap<String, Integer> tempDic = new HashMap<>();\\n            for (int j = i; j <= S.length() - len; j = j + len) {\\n                String word = sDic[j];\\n                if (word.equals(\"\")) {\\n                    tempDic = new HashMap<>();\\n                    start = j + len;\\n                    found = 0;\\n                    continue;\\n                } else {\\n                    if (!tempDic.containsKey(word)) {\\n                        tempDic.put(word, 1);\\n                    } else {\\n                        tempDic.put(word, tempDic.get(word) + 1);\\n                    }\\n                    found++;\\n                }\\n                //if we over-count a word, delete the first word in front. Also delete the words before that.\\n                if (tempDic.get(word) > dic.get(word)) {\\n                    while (!sDic[start].equals(word)) {\\n                        tempDic.put(sDic[start], tempDic.get(sDic[start]) - 1);\\n                        start += len;\\n                        found--;\\n                    }\\n                    tempDic.put(word, tempDic.get(word) - 1);\\n                    start += len;\\n                    found--;\\n                }\\n                if (found == num) {\\n                    res.add(start);\\n                }\\n\\n            }\\n\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public List<Integer> findSubstring(String S, String[] L) {\\n        List<Integer> res = new ArrayList<>();\\n        if (L.length == 0) {\\n            return res;\\n        }\\n        int len = L[0].length();\\n        int num = L.length;\\n        if (len * num > S.length()) {\\n            return res;\\n        }\\n\\n        //histogram of words in L\\n        HashMap<String, Integer> dic = new HashMap<>();\\n        for (String s : L) {\\n            if (dic.containsKey(s)) {\\n                dic.put(s, dic.get(s) + 1);\\n            } else {\\n                dic.put(s, 1);\\n            }\\n        }\\n\\n        //the word that starts from i in S\\n        String[] sDic = new String[S.length() - len + 1];\\n        for (int i = 0; i < sDic.length; i++) {\\n            String sub = S.substring(i, i + len);\\n            if (dic.containsKey(sub)) {\\n                sDic[i] = sub;\\n            } else {\\n                sDic[i] = \"\";\\n            }\\n        }\\n\\n        //traverse in order of 0,0+len,...,1,1+len,...len-1,len-1+len...therefore it is O(n) despite of two loops\\n        for (int i = 0; i < len; i++) {\\n\\n            //start of concatenation\\n            int start = i;\\n            //number of words found\\n            int found = 0;\\n            //dynamic word histogram of words in substring(start,j);\\n            HashMap<String, Integer> tempDic = new HashMap<>();\\n            for (int j = i; j <= S.length() - len; j = j + len) {\\n                String word = sDic[j];\\n                if (word.equals(\"\")) {\\n                    tempDic = new HashMap<>();\\n                    start = j + len;\\n                    found = 0;\\n                    continue;\\n                } else {\\n                    if (!tempDic.containsKey(word)) {\\n                        tempDic.put(word, 1);\\n                    } else {\\n                        tempDic.put(word, tempDic.get(word) + 1);\\n                    }\\n                    found++;\\n                }\\n                //if we over-count a word, delete the first word in front. Also delete the words before that.\\n                if (tempDic.get(word) > dic.get(word)) {\\n                    while (!sDic[start].equals(word)) {\\n                        tempDic.put(sDic[start], tempDic.get(sDic[start]) - 1);\\n                        start += len;\\n                        found--;\\n                    }\\n                    tempDic.put(word, tempDic.get(word) - 1);\\n                    start += len;\\n                    found--;\\n                }\\n                if (found == num) {\\n                    res.add(start);\\n                }\\n\\n            }\\n\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 13821,
                "title": "o-s-length-word-length-c-solution-36-ms",
                "content": "1. Assign id to each word and count repeating words. Store counts of words into baseline_counts array.\\n2. Split the string into chunks of word length and thus convert the string into a vector of word id\\'s. After that move a sliding window of size N, maintain count for each word id in this window and recalculate the distance between the current count vector and the baseline count vector. The distance is calculated as Sum{i=1..N}(abs(count[i] - baseline_count[i])) and is updated in constant time on each step.\\n3. The procedure 2 is repeated (word_length-1) times by moving staring position in the string.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string S, vector<string> &L) {\\n        vector<int> res;\\n\\n        if (L.empty() || L.size()*L[0].size()>S.length())\\n            return res;\\n\\n        int l = S.length();             // string length\\n        long long int n = L.size();     // number of words\\n        int wl = L[0].size();           // word length\\n        \\n        // give 1..n id\\'s to words\\n        unordered_map<string, int> dict;\\n        dict.reserve(n);\\n        vector<int> dc(n+1,0);          // baseline counts (needed for repeating words)\\n        for (int i = 0; i < n; ++i) {\\n            if (dict[L[i]] == 0)\\n                dict[L[i]] = i+1;\\n            dc[dict[L[i]]]++;\\n        }\\n        \\n        vector<int> cc;\\n        cc.reserve(l/wl);\\n            \\n        // shift start position from 0 to wl-1\\n        for (int sh = 0; sh < wl; ++sh) {\\n            cc.clear();\\n            // convert words to their id\\'s\\n            for (int p = sh; p + wl <= l; p += wl) {\\n                auto di = dict.find(S.substr(p, wl));\\n                if (di != dict.end())\\n                    cc.push_back(di->second);   // replace known word with id\\n                else\\n                    cc.push_back(-1);           // replace unknown word with -1\\n            }\\n            \\n            // Fill the sliding window with first n-1 elements\\n            // we keep the count of each word and calculate error as the distance\\n            // between the current counts vector and the baseline count vector\\n            vector<int> cnt(n+1,0);\\n            long long int err = n;\\n            for (int k = 0; k < n-1; ++k) {\\n                int id = cc[k];\\n                if (id > 0) {\\n                    int cp = cnt[id];\\n                    err -= abs(cp - dc[id]);\\n                    err += abs(cp + 1 -dc[id]);\\n                    cnt[id]++;\\n                }\\n            }\\n            \\n            // move the window of size n maintaining the counts\\n            for (int j = 0; j + n <= cc.size(); ++j) {\\n                // add next element\\n                int id = cc[j+n-1];\\n                if (id > 0) {\\n                    int cp = cnt[id];\\n                    err -= abs(cp - dc[id]);\\n                    err += abs(cp+1 -dc[id]);\\n                    cnt[id]++;\\n                }\\n                \\n                // if counts match\\n                if (err == 0)\\n                    res.push_back(sh + j*wl);\\n                \\n                // remove first element\\n                id = cc[j];\\n                if (id > 0) {\\n                    int cp = cnt[id];\\n                    err -= abs(cp - dc[id]);\\n                    err += abs(cp-1 - dc[id]);\\n                    cnt[id]--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string S, vector<string> &L) {\\n        vector<int> res;\\n\\n        if (L.empty() || L.size()*L[0].size()>S.length())\\n            return res;\\n\\n        int l = S.length();             // string length\\n        long long int n = L.size();     // number of words\\n        int wl = L[0].size();           // word length\\n        \\n        // give 1..n id\\'s to words\\n        unordered_map<string, int> dict;\\n        dict.reserve(n);\\n        vector<int> dc(n+1,0);          // baseline counts (needed for repeating words)\\n        for (int i = 0; i < n; ++i) {\\n            if (dict[L[i]] == 0)\\n                dict[L[i]] = i+1;\\n            dc[dict[L[i]]]++;\\n        }\\n        \\n        vector<int> cc;\\n        cc.reserve(l/wl);\\n            \\n        // shift start position from 0 to wl-1\\n        for (int sh = 0; sh < wl; ++sh) {\\n            cc.clear();\\n            // convert words to their id\\'s\\n            for (int p = sh; p + wl <= l; p += wl) {\\n                auto di = dict.find(S.substr(p, wl));\\n                if (di != dict.end())\\n                    cc.push_back(di->second);   // replace known word with id\\n                else\\n                    cc.push_back(-1);           // replace unknown word with -1\\n            }\\n            \\n            // Fill the sliding window with first n-1 elements\\n            // we keep the count of each word and calculate error as the distance\\n            // between the current counts vector and the baseline count vector\\n            vector<int> cnt(n+1,0);\\n            long long int err = n;\\n            for (int k = 0; k < n-1; ++k) {\\n                int id = cc[k];\\n                if (id > 0) {\\n                    int cp = cnt[id];\\n                    err -= abs(cp - dc[id]);\\n                    err += abs(cp + 1 -dc[id]);\\n                    cnt[id]++;\\n                }\\n            }\\n            \\n            // move the window of size n maintaining the counts\\n            for (int j = 0; j + n <= cc.size(); ++j) {\\n                // add next element\\n                int id = cc[j+n-1];\\n                if (id > 0) {\\n                    int cp = cnt[id];\\n                    err -= abs(cp - dc[id]);\\n                    err += abs(cp+1 -dc[id]);\\n                    cnt[id]++;\\n                }\\n                \\n                // if counts match\\n                if (err == 0)\\n                    res.push_back(sh + j*wl);\\n                \\n                // remove first element\\n                id = cc[j];\\n                if (id > 0) {\\n                    int cp = cnt[id];\\n                    err -= abs(cp - dc[id]);\\n                    err += abs(cp-1 - dc[id]);\\n                    cnt[id]--;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13848,
                "title": "some-clarification-about-the-characteristics-of-the-input-s-l-by-trial",
                "content": "I found that the description of the problem does not give much detail about the input string and the words list. Here are a few of them that I figured out by trials. I list as follows as a supplementary information. All the examples below are the real cases from OJ.\\n\\n1). The words in the list L do NOT have to be unique. \\ne.g. \\n\\n    S = \\u201clingmindraboofooowingdingbarrwingmonkeypoundcake\\u201d\\n    L = {\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"}   // expected {13}\\n\\n2). The words in the list might have certain parts overlapping, which makes the input a bit of tricky for certain algorithm\\u2026\\ne.g. \\n\\n    S = \"aaaaaa\";\\n    L = {\"aaa\", \"aaa\"}; // expected {0}\\n\\n\\t\\n\\n3). If we consider the entire word list as a slide window, then the windows might overlap with each other in the result.\\ne.g.\\n\\n    S = \"abaababbaba\";\\n    L = {\"ab\",\"ba\",\"ab\",\"ba\"};  // expected {1, 3}",
                "solutionTags": [],
                "code": "I found that the description of the problem does not give much detail about the input string and the words list. Here are a few of them that I figured out by trials. I list as follows as a supplementary information. All the examples below are the real cases from OJ.\\n\\n1). The words in the list L do NOT have to be unique. \\ne.g. \\n\\n    S = \\u201clingmindraboofooowingdingbarrwingmonkeypoundcake\\u201d\\n    L = {\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"}   // expected {13}\\n\\n2). The words in the list might have certain parts overlapping, which makes the input a bit of tricky for certain algorithm\\u2026\\ne.g. \\n\\n    S = \"aaaaaa\";\\n    L = {\"aaa\", \"aaa\"}; // expected {0}\\n\\n\\t\\n\\n3). If we consider the entire word list as a slide window, then the windows might overlap with each other in the result.\\ne.g.\\n\\n    S = \"abaababbaba\";\\n    L = {\"ab\",\"ba\",\"ab\",\"ba\"};  // expected {1, 3}",
                "codeTag": "Unknown"
            },
            {
                "id": 3928025,
                "title": "c-two-approaches-explained-with-comments",
                "content": "# SOL-1\\n\\n## Intuition\\nThe problem asks us to find all starting indices of substrings in a given string `s` such that the concatenation of these substrings forms all the words from a given list `words`. The order of the words in the concatenated substring doesn\\'t matter. To solve this problem, we need to devise a method to efficiently check and track the occurrence of valid concatenated substrings within the given string `s`.\\n\\n## Approach\\nThe approach to solving this problem involves using the sliding window technique and hash maps.\\n\\n1. We start by constructing a hash map called `wordFreqMap` to store the frequency of each word from the given list `words`.\\n\\n2. Next, we iterate through each possible starting position for the substring. For each starting position, we create a new hash map called `currWordFreqMap` to track the frequency of words in the current substring. We also maintain a `wordCount` variable to count the total number of valid words in the current substring.\\n\\n3. Within each substring, we process each word of length `wordLen` (length of any word from the given list) and update the `currWordFreqMap` and `wordCount`. If the word is valid (its frequency doesn\\'t exceed that of `wordFreqMap`), we increment `wordCount`.\\n\\n4. If at any point `wordCount` matches the total number of words (`numWords`), we consider the starting position as a potential result index and add it to the result vector.\\n\\n5. After processing the initial substring, we slide the window to the right by considering the next character. We remove the word that\\'s no longer part of the sliding window and update the `wordCount`. Then, we add the new word to the sliding window and update the `wordCount`. Again, if `wordCount` matches `numWords`, we add the starting position to the result vector.\\n\\n6. We repeat steps 3-5 for each possible starting position within the string `s`.\\n\\n7. Finally, we return the vector containing the result indices.\\n\\n## Complexity\\n- Time complexity: O(N * M * L), where N is the length of the input string `s`, M is the number of words in the list `words`, and L is the length of each word.\\n- Space complexity: O(M + L), where M is the number of words and L is the length of each word. The space is used to store the frequency of words in the hash maps `wordFreqMap` and `currWordFreqMap`.\\n\\n# Code-\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = s.size();\\n        int numWords = words.size();\\n        int wordLen = words[0].size();\\n        \\n        // Check if the input string length is less than the minimum required length\\n        if (len < (wordLen * numWords)) {\\n            return {};\\n        }\\n        \\n        vector<int> resultIndices;\\n\\n        // Create a map to store the frequency of words\\n        unordered_map<string, int> wordFreqMap;\\n        for (string word : words) {\\n            wordFreqMap[word]++;\\n        }\\n\\n        // Iterate through different starting positions for the substring\\n        for (int startPos = 0; startPos < wordLen; startPos++) {\\n            unordered_map<string, int> currWordFreqMap;\\n            int wordCount = 0;\\n\\n            // Process each substring with a fixed starting position\\n            for (int i = startPos; i < startPos + (numWords * wordLen); i += wordLen) {\\n                string currentWord = s.substr(i, wordLen);\\n                currWordFreqMap[currentWord]++;\\n                if (currWordFreqMap[currentWord] <= wordFreqMap[currentWord]) {\\n                    wordCount++;\\n                }\\n            }\\n\\n            if (wordCount == numWords) {\\n                resultIndices.push_back(startPos);\\n            }\\n\\n            int endIndex = startPos + numWords * wordLen;\\n            for (int j = startPos + numWords * wordLen; j <= len - wordLen; j += wordLen) {\\n                string removedWord = s.substr(j - numWords * wordLen, wordLen);\\n                if (currWordFreqMap.find(removedWord) != currWordFreqMap.end()) {\\n                    currWordFreqMap[removedWord]--;\\n                    if (currWordFreqMap[removedWord] < wordFreqMap[removedWord]) {\\n                        wordCount--;\\n                    }\\n                }\\n\\n                string addedWord = s.substr(j, wordLen);\\n                currWordFreqMap[addedWord]++;\\n                if (currWordFreqMap[addedWord] <= wordFreqMap[addedWord]) {\\n                    wordCount++;\\n                }\\n\\n                if (wordCount == numWords) {\\n                    resultIndices.push_back(j - (numWords - 1) * wordLen);\\n                }\\n            }\\n        }\\n\\n        return resultIndices;\\n    }\\n};\\n\\n```\\n\\n\\n# SOL-2 : Simple Nested Iterations\\n\\n## Approach\\n\\n1. Initialize variables `len`, `n`, and `wordlen` to store the length of the input string, the number of words, and the length of each word respectively.\\n2. Check if the length of the input string is sufficient to accommodate concatenated words. If not, return an empty vector.\\n3. Create an unordered map `map` to store the frequencies of words from the given list.\\n4. Iterate through possible starting positions of the substring in `s`:\\n   - Create a new unordered map `wordmap` to track the frequencies of words in the current substring.\\n   - Initialize `j`, `cnt`, and other variables.\\n   - Process each word in the current substring using a nested loop and update `wordmap` and `cnt`.\\n   - If the word frequency in `wordmap` does not exceed that in `map`, increment `cnt`.\\n   - If `cnt` equals `n`, push the current starting position to the `ans` vector.\\n5. Return the `ans` vector containing the valid starting positions.\\n\\n## Complexity\\n\\n- Time complexity: The code iterates through different starting positions and nested loops to match concatenated words, resulting in a time complexity of O(N * M * L), where N is the length of the input string, M is the number of words, and L is the length of each word.\\n- Space complexity: The code uses additional space to store the unordered maps `map` and `wordmap`, as well as the `ans` vector, leading to a space complexity of O(M + N).\\n\\n## CODE-\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int totalLength = s.size();\\n        int numWords = words.size();\\n        int wordLength = words[0].size();\\n        \\n        // If the total length of the string is less than the combined length of all words, return an empty vector.\\n        if (totalLength < (wordLength * numWords)) {\\n            return {};\\n        }\\n        \\n        vector<int> resultIndices;\\n\\n        // Create a frequency map to store the occurrences of each word in the given list.\\n        unordered_map<string, int> wordFrequencyMap;\\n        for (string word : words) {\\n            wordFrequencyMap[word]++;\\n        }\\n\\n        // Iterate through possible starting positions for the substring.\\n        for (int startPos = 0; startPos <= totalLength - (numWords * wordLength); startPos++) {\\n            unordered_map<string, int> currentWordFrequencyMap;\\n            int wordCount = 0;\\n\\n            // Process each word in the current substring.\\n            for (int j = startPos; j < startPos + (numWords * wordLength); j += wordLength) {\\n                string currentWord = s.substr(j, wordLength);\\n                currentWordFrequencyMap[currentWord]++;\\n                if (currentWordFrequencyMap[currentWord] <= wordFrequencyMap[currentWord]) {\\n                    wordCount++;\\n                } else {\\n                    // If the word occurs more times than needed, break out of the loop.\\n                    break;\\n                }\\n            }\\n\\n            // If all words are found in the current substring, add the starting position to the result vector.\\n            if (wordCount == numWords) {\\n                resultIndices.push_back(startPos);\\n            }\\n        }\\n\\n        return resultIndices;\\n    }\\n};\\n```\\n\\nTry understanding and implementing the code on your own instead of mugging it up. It\\'s not that difficult, just get the glimpse of the approach from these solutions. Thanks for reading.",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = s.size();\\n        int numWords = words.size();\\n        int wordLen = words[0].size();\\n        \\n        // Check if the input string length is less than the minimum required length\\n        if (len < (wordLen * numWords)) {\\n            return {};\\n        }\\n        \\n        vector<int> resultIndices;\\n\\n        // Create a map to store the frequency of words\\n        unordered_map<string, int> wordFreqMap;\\n        for (string word : words) {\\n            wordFreqMap[word]++;\\n        }\\n\\n        // Iterate through different starting positions for the substring\\n        for (int startPos = 0; startPos < wordLen; startPos++) {\\n            unordered_map<string, int> currWordFreqMap;\\n            int wordCount = 0;\\n\\n            // Process each substring with a fixed starting position\\n            for (int i = startPos; i < startPos + (numWords * wordLen); i += wordLen) {\\n                string currentWord = s.substr(i, wordLen);\\n                currWordFreqMap[currentWord]++;\\n                if (currWordFreqMap[currentWord] <= wordFreqMap[currentWord]) {\\n                    wordCount++;\\n                }\\n            }\\n\\n            if (wordCount == numWords) {\\n                resultIndices.push_back(startPos);\\n            }\\n\\n            int endIndex = startPos + numWords * wordLen;\\n            for (int j = startPos + numWords * wordLen; j <= len - wordLen; j += wordLen) {\\n                string removedWord = s.substr(j - numWords * wordLen, wordLen);\\n                if (currWordFreqMap.find(removedWord) != currWordFreqMap.end()) {\\n                    currWordFreqMap[removedWord]--;\\n                    if (currWordFreqMap[removedWord] < wordFreqMap[removedWord]) {\\n                        wordCount--;\\n                    }\\n                }\\n\\n                string addedWord = s.substr(j, wordLen);\\n                currWordFreqMap[addedWord]++;\\n                if (currWordFreqMap[addedWord] <= wordFreqMap[addedWord]) {\\n                    wordCount++;\\n                }\\n\\n                if (wordCount == numWords) {\\n                    resultIndices.push_back(j - (numWords - 1) * wordLen);\\n                }\\n            }\\n        }\\n\\n        return resultIndices;\\n    }\\n};\\n\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int totalLength = s.size();\\n        int numWords = words.size();\\n        int wordLength = words[0].size();\\n        \\n        // If the total length of the string is less than the combined length of all words, return an empty vector.\\n        if (totalLength < (wordLength * numWords)) {\\n            return {};\\n        }\\n        \\n        vector<int> resultIndices;\\n\\n        // Create a frequency map to store the occurrences of each word in the given list.\\n        unordered_map<string, int> wordFrequencyMap;\\n        for (string word : words) {\\n            wordFrequencyMap[word]++;\\n        }\\n\\n        // Iterate through possible starting positions for the substring.\\n        for (int startPos = 0; startPos <= totalLength - (numWords * wordLength); startPos++) {\\n            unordered_map<string, int> currentWordFrequencyMap;\\n            int wordCount = 0;\\n\\n            // Process each word in the current substring.\\n            for (int j = startPos; j < startPos + (numWords * wordLength); j += wordLength) {\\n                string currentWord = s.substr(j, wordLength);\\n                currentWordFrequencyMap[currentWord]++;\\n                if (currentWordFrequencyMap[currentWord] <= wordFrequencyMap[currentWord]) {\\n                    wordCount++;\\n                } else {\\n                    // If the word occurs more times than needed, break out of the loop.\\n                    break;\\n                }\\n            }\\n\\n            // If all words are found in the current substring, add the starting position to the result vector.\\n            if (wordCount == numWords) {\\n                resultIndices.push_back(startPos);\\n            }\\n        }\\n\\n        return resultIndices;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490497,
                "title": "java-solution-for-substring-with-concatenation-of-all-words-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this approach is to use a sliding window technique to traverse the string s and check if each substring of length len starting from the current index is a concatenation of all the words in the array words. We maintain a frequency map of the words in words and a current frequency map of the words in the current substring. We also maintain a count of the number of words in the current substring that match the words in words. If the current frequency map of the words in the current substring exceeds the frequency map of the words in words, we move the start of the window to the next index and update the frequency maps and count accordingly. If the count equals the length of words, we add the start index of the current substring to the result.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Check if the input string s is null or empty, or if the input array words is null or empty. If so, return an empty list, as there are no substrings to find.\\n- Initialize an empty ArrayList result to store the starting indices of the substrings.\\n- Initialize a frequency map map to store the frequency of the words in words.\\n- Initialize the length len to the length of the first word in words.\\n- Traverse the string s from left to right for each starting index j from 0 to len-1.\\n- Initialize a current frequency map currentMap to store the frequency of the words in the current substring.\\n- Initialize the start index start to j and the count count to 0.\\n- Traverse the string s from the current index i to the end of the string in steps of len.\\n- Extract the substring of length len starting from the current index i.\\n- If the substring is in the frequency map map, update the current frequency map currentMap and the count count.\\n- If the frequency of the substring in currentMap exceeds the frequency of the substring in map, move the start index start to the next index and update the current frequency map currentMap and the count count accordingly.\\n- If the count count equals the length of words, add the start index start to the result and move the start index start to the next index.\\n- Repeat steps 9-12 until the end of the string is reached.\\nReturn the ArrayList result.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*m), where n is the length of the input string s and m is the length of the input array words. The algorithm iterates through the string s once and performs constant-time operations for each substring of length len.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(m), as the algorithm uses a frequency map map of the words in words and a current frequency map currentMap of the words in the current substring.\\n\\n# Code\\n```\\nclass Solution \\n{\\n    public List<Integer> findSubstring(String s, String[] words) \\n    {\\n        ArrayList<Integer> result = new ArrayList<Integer>();\\n        if(s==null||s.length()==0||words==null||words.length==0)\\n        {\\n            return result;\\n        }\\n        //frequency of words\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\\n        for(String w: words)\\n        {\\n            if(map.containsKey(w))\\n            {\\n                map.put(w, map.get(w)+1);\\n            }\\n            else\\n            {\\n                map.put(w, 1);\\n            }\\n        }\\n        int len = words[0].length();\\n        for(int j=0; j<len; j++)\\n        {\\n            HashMap<String, Integer> currentMap = new HashMap<String, Integer>();\\n            int start = j;//start index of start\\n            int count = 0;//count totoal qualified words so far\\n            for(int i=j; i<=s.length()-len; i=i+len)\\n            {\\n                String sub = s.substring(i, i+len);\\n                if(map.containsKey(sub))\\n                {\\n                    //set frequency in current map\\n                    if(currentMap.containsKey(sub))\\n                    {\\n                        currentMap.put(sub, currentMap.get(sub)+1);\\n                    }\\n                    else\\n                    {\\n                        currentMap.put(sub, 1);\\n                    }\\n                    count++;\\n                    while(currentMap.get(sub)>map.get(sub))\\n                    {\\n                        String left = s.substring(start, start+len);\\n                        currentMap.put(left, currentMap.get(left)-1);\\n                        count--;\\n                        start = start + len;\\n                    }\\n                    if(count==words.length)\\n                    {\\n                        result.add(start); //add to result\\n                        //shift right and reset currentMap, count & start point\\n                        String left = s.substring(start, start+len);\\n                        currentMap.put(left, currentMap.get(left)-1);\\n                        count--;\\n                        start = start + len;\\n                    }\\n                }\\n                else\\n                {\\n                    currentMap.clear();\\n                    start = i+len;\\n                    count = 0;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public List<Integer> findSubstring(String s, String[] words) \\n    {\\n        ArrayList<Integer> result = new ArrayList<Integer>();\\n        if(s==null||s.length()==0||words==null||words.length==0)\\n        {\\n            return result;\\n        }\\n        //frequency of words\\n        HashMap<String, Integer> map = new HashMap<String, Integer>();\\n        for(String w: words)\\n        {\\n            if(map.containsKey(w))\\n            {\\n                map.put(w, map.get(w)+1);\\n            }\\n            else\\n            {\\n                map.put(w, 1);\\n            }\\n        }\\n        int len = words[0].length();\\n        for(int j=0; j<len; j++)\\n        {\\n            HashMap<String, Integer> currentMap = new HashMap<String, Integer>();\\n            int start = j;//start index of start\\n            int count = 0;//count totoal qualified words so far\\n            for(int i=j; i<=s.length()-len; i=i+len)\\n            {\\n                String sub = s.substring(i, i+len);\\n                if(map.containsKey(sub))\\n                {\\n                    //set frequency in current map\\n                    if(currentMap.containsKey(sub))\\n                    {\\n                        currentMap.put(sub, currentMap.get(sub)+1);\\n                    }\\n                    else\\n                    {\\n                        currentMap.put(sub, 1);\\n                    }\\n                    count++;\\n                    while(currentMap.get(sub)>map.get(sub))\\n                    {\\n                        String left = s.substring(start, start+len);\\n                        currentMap.put(left, currentMap.get(left)-1);\\n                        count--;\\n                        start = start + len;\\n                    }\\n                    if(count==words.length)\\n                    {\\n                        result.add(start); //add to result\\n                        //shift right and reset currentMap, count & start point\\n                        String left = s.substring(start, start+len);\\n                        currentMap.put(left, currentMap.get(left)-1);\\n                        count--;\\n                        start = start + len;\\n                    }\\n                }\\n                else\\n                {\\n                    currentMap.clear();\\n                    start = i+len;\\n                    count = 0;\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3077316,
                "title": "c-fast-and-easy-solution-using-map-and-sliding-window",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> mp, temp;\\n        vector<int> ans;\\n        for(string &w:words) mp[w]++;\\n\\n        int ws = words[0].size(), sn = s.size(), wn = words.size();\\n        int k = ws*wn;\\n\\n        for(int i=0;i+k<=sn;i++)\\n        {\\n            bool flag = true;\\n            temp = mp;\\n            for(int j=0;j<wn and flag;j++)\\n            {\\n                string substr=\"\";\\n                for(int d=0;d<ws;d++)\\n                substr+=s[i+j*ws+d];\\n\\n                if(temp[substr])\\n                {\\n                    temp[substr]--;\\n                }\\n                else\\n                flag = false;\\n            }\\n            if(flag)\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> mp, temp;\\n        vector<int> ans;\\n        for(string &w:words) mp[w]++;\\n\\n        int ws = words[0].size(), sn = s.size(), wn = words.size();\\n        int k = ws*wn;\\n\\n        for(int i=0;i+k<=sn;i++)\\n        {\\n            bool flag = true;\\n            temp = mp;\\n            for(int j=0;j<wn and flag;j++)\\n            {\\n                string substr=\"\";\\n                for(int d=0;d<ws;d++)\\n                substr+=s[i+j*ws+d];\\n\\n                if(temp[substr])\\n                {\\n                    temp[substr]--;\\n                }\\n                else\\n                flag = false;\\n            }\\n            if(flag)\\n            ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2724345,
                "title": "faster-than-99-python-solution",
                "content": "\\nLet n be the length of a word in words\\nand m be the total number of words in words\\n\\n**Space Complexity - O(n+m)\\nTime Complexity - O(n+m)**\\n\\n\\n```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        word_len = len(words[0])\\n        ori_word_dict = defaultdict(int)\\n\\t\\t\\n        for word in words:\\n            ori_word_dict[word] += 1\\n        \\n        all_word_len = len(words) * word_len\\n        result = []\\n        for i in range(word_len):\\n            queue = deque()\\n            word_dict = ori_word_dict.copy()\\n            for j in range(i, len(s) - word_len + 1, word_len):\\n                word = s[j:j + word_len]\\n                if word_dict.get(word, 0) != 0:\\n                    word_dict[word] -= 1\\n                    queue.append(word)\\n                    if sum(word_dict.values()) == 0:\\n                        result.append(j - all_word_len + word_len)\\n                        last_element = queue.popleft()\\n                        word_dict[last_element] = word_dict.get(last_element, 0) + 1\\n                else:\\n                    while len(queue):\\n                        last_element = queue.popleft()\\n                        if last_element == word:\\n                            queue.append(word)\\n                            break\\n                        else:\\n                            word_dict[last_element] = word_dict.get(last_element, 0) + 1\\n                            if word_dict[last_element] > ori_word_dict[last_element]:\\n                                word_dict = ori_word_dict.copy()\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom collections import deque, defaultdict\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        word_len = len(words[0])\\n        ori_word_dict = defaultdict(int)\\n\\t\\t\\n        for word in words:\\n            ori_word_dict[word] += 1\\n        \\n        all_word_len = len(words) * word_len\\n        result = []\\n        for i in range(word_len):\\n            queue = deque()\\n            word_dict = ori_word_dict.copy()\\n            for j in range(i, len(s) - word_len + 1, word_len):\\n                word = s[j:j + word_len]\\n                if word_dict.get(word, 0) != 0:\\n                    word_dict[word] -= 1\\n                    queue.append(word)\\n                    if sum(word_dict.values()) == 0:\\n                        result.append(j - all_word_len + word_len)\\n                        last_element = queue.popleft()\\n                        word_dict[last_element] = word_dict.get(last_element, 0) + 1\\n                else:\\n                    while len(queue):\\n                        last_element = queue.popleft()\\n                        if last_element == word:\\n                            queue.append(word)\\n                            break\\n                        else:\\n                            word_dict[last_element] = word_dict.get(last_element, 0) + 1\\n                            if word_dict[last_element] > ori_word_dict[last_element]:\\n                                word_dict = ori_word_dict.copy()\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2425998,
                "title": "java-simple-sliding-window",
                "content": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        Map<String, Integer> map = new HashMap<>();\\n        for(String word: words)\\n            map.put(word, map.getOrDefault(word, 0) + 1);\\n        \\n        int wLength = words[0].length();\\n        int tLength = words[0].length() * words.length; \\n        \\n        int i = 0, j = 0;\\n        while (j < s.length()) {\\n            \\n            if(j - i + 1 < tLength)\\n                j++;\\n            \\n            else if (j - i + 1 == tLength) {\\n                String sub = s.substring(i, j + 1);\\n                Map<String, Integer> map2 = new HashMap<>();\\n                int index = 0;\\n                while (index < sub.length()) {\\n                    String temp = sub.substring(index, index + wLength);\\n                    map2.put(temp,map2.getOrDefault(temp, 0) + 1);\\n                    index += wLength;\\n                }\\n                \\n                if (map.equals(map2))\\n                    ans.add(i);\\n                i++;   j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        List<Integer> ans = new ArrayList<>();\\n        Map<String, Integer> map = new HashMap<>();\\n        for(String word: words)\\n            map.put(word, map.getOrDefault(word, 0) + 1);\\n        \\n        int wLength = words[0].length();\\n        int tLength = words[0].length() * words.length; \\n        \\n        int i = 0, j = 0;\\n        while (j < s.length()) {\\n            \\n            if(j - i + 1 < tLength)\\n                j++;\\n            \\n            else if (j - i + 1 == tLength) {\\n                String sub = s.substring(i, j + 1);\\n                Map<String, Integer> map2 = new HashMap<>();\\n                int index = 0;\\n                while (index < sub.length()) {\\n                    String temp = sub.substring(index, index + wLength);\\n                    map2.put(temp,map2.getOrDefault(temp, 0) + 1);\\n                    index += wLength;\\n                }\\n                \\n                if (map.equals(map2))\\n                    ans.add(i);\\n                i++;   j++;\\n            }\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418661,
                "title": "simple-easy-to-understand-80-faster-solution-java",
                "content": "```\\nclass Solution { // 110ms 74.97% Faster\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        int res=0,i,lens=s.length(),lenw=words[0].length(),n=words.length,j;\\n        HashMap<String,Integer> map = new HashMap<String,Integer>();\\n        List<Integer> list = new ArrayList<Integer>();\\n        for(String w : words) map.put(w,map.getOrDefault(w,0)+1);\\n        \\n        HashMap<String,Integer> hashmap = new HashMap<String,Integer>();;\\n        for(i=0;i<=(lens-lenw*n);i++){\\n            hashmap.clear();\\n            for(j=0;j<n;j++){\\n                String str = s.substring(i+lenw*j,i+lenw*(j+1));\\n                hashmap.put(str,hashmap.getOrDefault(str,0)+1);\\n                if(map.getOrDefault(str,Integer.MIN_VALUE)<hashmap.get(str)) break;\\n            }\\n            if(j==n) list.add(i);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution { // 110ms 74.97% Faster\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        int res=0,i,lens=s.length(),lenw=words[0].length(),n=words.length,j;\\n        HashMap<String,Integer> map = new HashMap<String,Integer>();\\n        List<Integer> list = new ArrayList<Integer>();\\n        for(String w : words) map.put(w,map.getOrDefault(w,0)+1);\\n        \\n        HashMap<String,Integer> hashmap = new HashMap<String,Integer>();;\\n        for(i=0;i<=(lens-lenw*n);i++){\\n            hashmap.clear();\\n            for(j=0;j<n;j++){\\n                String str = s.substring(i+lenw*j,i+lenw*(j+1));\\n                hashmap.put(str,hashmap.getOrDefault(str,0)+1);\\n                if(map.getOrDefault(str,Integer.MIN_VALUE)<hashmap.get(str)) break;\\n            }\\n            if(j==n) list.add(i);\\n        }\\n        return list;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2308956,
                "title": "40-line-of-codes-n-n-m",
                "content": "```\\nfunc findSubstring(s string, words []string) []int {\\n    wordFrequency := make(map[string]int)\\n    \\n    for _, word := range words {\\n        wordFrequency[word]++\\n    }\\n    \\n    var res []int\\n    \\n    length := len(words[0])\\n    \\n    for i := 0; i < len(s)-length*len(words)+1; i++ {\\n        seen := make(map[string]int)\\n        \\n        for j := 0; j < len(words); j++ {\\n            nextIndex := i + j*length\\n            word := s[nextIndex: nextIndex + length]\\n\\n            if _, ok := wordFrequency[word]; !ok {\\n                break\\n            }\\n            \\n            seen[word]++\\n            \\n            seenFrequency, _ := seen[word]\\n            originFrequency, _ := wordFrequency[word]\\n            \\n            if seenFrequency > originFrequency {\\n                break\\n            }\\n \\n            if j + 1 == len(words) {\\n                res = append(res, i)\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findSubstring(s string, words []string) []int {\\n    wordFrequency := make(map[string]int)\\n    \\n    for _, word := range words {\\n        wordFrequency[word]++\\n    }\\n    \\n    var res []int\\n    \\n    length := len(words[0])\\n    \\n    for i := 0; i < len(s)-length*len(words)+1; i++ {\\n        seen := make(map[string]int)\\n        \\n        for j := 0; j < len(words); j++ {\\n            nextIndex := i + j*length\\n            word := s[nextIndex: nextIndex + length]\\n\\n            if _, ok := wordFrequency[word]; !ok {\\n                break\\n            }\\n            \\n            seen[word]++\\n            \\n            seenFrequency, _ := seen[word]\\n            originFrequency, _ := wordFrequency[word]\\n            \\n            if seenFrequency > originFrequency {\\n                break\\n            }\\n \\n            if j + 1 == len(words) {\\n                res = append(res, i)\\n            }\\n        }\\n    }\\n    \\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1270670,
                "title": "python-counter-sliding-window-explained",
                "content": "The idea is to check if each sliding window from i to j (inclusive) has the same frequency with the \\'words\\'. I use \\'tmp\\' to record the frequency in each sliding window. During the sliding window, if I found that the frequency of one word is higher than the frequency in \\'words\\', just ditch the current sliding window using \\'break\\'.\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        ans = []\\n        n,m = len(words), len(words[0])\\n        words = collections.Counter(words)\\n        \\n        for i in range(len(s)-n*m+1):\\n            tmp = collections.Counter()\\n            cnt = 0\\n            for j in range(i,i+n*m,m): # at most n*m characters in the sliding window \\n                w = s[j:j+m]\\n                if w in words:\\n                    tmp[w]+=1\\n                    cnt+=1\\n                    if tmp[w]>words[w]: # ditch current sliding window\\n                        break\\n                    if cnt==n:\\n                        ans.append(i)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        ans = []\\n        n,m = len(words), len(words[0])\\n        words = collections.Counter(words)\\n        \\n        for i in range(len(s)-n*m+1):\\n            tmp = collections.Counter()\\n            cnt = 0\\n            for j in range(i,i+n*m,m): # at most n*m characters in the sliding window \\n                w = s[j:j+m]\\n                if w in words:\\n                    tmp[w]+=1\\n                    cnt+=1\\n                    if tmp[w]>words[w]: # ditch current sliding window\\n                        break\\n                    if cnt==n:\\n                        ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1181581,
                "title": "python3-2-solutions-easy-to-understand-fastest-and-use-least-memory",
                "content": "```\\n#This is the solution 1............this is the fastest solution with 52 ms speed..\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        if not s or not words:\\n            return []\\n        \\n        count = {}\\n        for word in words:\\n            count[word] = count.get(word,0) + 1\\n        \\n        lw = len(words[0])\\n        fin = []\\n        \\n        for i in range(lw):\\n            l = r = i\\n            window = {}\\n           \\n            while r < len(s):\\n                curr_w = s[r:r+lw]\\n                \\n                if curr_w not in count:\\n                    window.clear()\\n                    r += lw\\n                    l = r\\n                else:\\n                    window[curr_w] = window.get(curr_w,0) + 1\\n                    \\n                    if window[curr_w] <= count[curr_w]:\\n                        r += lw\\n\\n                    else:\\n                        while l <= r and window[curr_w]>count[curr_w]:\\n                            w = s[l:l+lw]\\n                            window[w] -= 1\\n                            l += lw\\n                        r += lw\\n                   \\n                    if window == count:\\n                            fin.append(l)\\n        return fin\\n```\\n\\n\\n```\\n#This is the solution 2............this solution is not the fastest but easiest to understand......\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n\\t    from itertools import permutations\\n\\t\\tlength=len(words)\\n\\t\\tk=[]\\n\\t\\tg=[]\\n\\t\\ta=list(set(permutations(words,length)))\\n\\t\\tfor i in a:\\n\\t\\t\\ts1=\\'\\'.join(i)\\n\\t\\t\\tl1=len(s1)\\n\\t\\t\\tk.append(s1)\\n\\t\\tfor i in range(0,(len(s)-l1)+1):\\n\\t\\t\\ts2=s[i:(l1+i)]\\n\\t\\t\\tif s2 in k:\\n\\t\\t\\t\\tg.append(i)\\n\\t\\treturn(g)        \\n\\t\\t\\n\\t    \\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n#This is the solution 1............this is the fastest solution with 52 ms speed..\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        if not s or not words:\\n            return []\\n        \\n        count = {}\\n        for word in words:\\n            count[word] = count.get(word,0) + 1\\n        \\n        lw = len(words[0])\\n        fin = []\\n        \\n        for i in range(lw):\\n            l = r = i\\n            window = {}\\n           \\n            while r < len(s):\\n                curr_w = s[r:r+lw]\\n                \\n                if curr_w not in count:\\n                    window.clear()\\n                    r += lw\\n                    l = r\\n                else:\\n                    window[curr_w] = window.get(curr_w,0) + 1\\n                    \\n                    if window[curr_w] <= count[curr_w]:\\n                        r += lw\\n\\n                    else:\\n                        while l <= r and window[curr_w]>count[curr_w]:\\n                            w = s[l:l+lw]\\n                            window[w] -= 1\\n                            l += lw\\n                        r += lw\\n                   \\n                    if window == count:\\n                            fin.append(l)\\n        return fin\\n```\n```\\n#This is the solution 2............this solution is not the fastest but easiest to understand......\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n\\t    from itertools import permutations\\n\\t\\tlength=len(words)\\n\\t\\tk=[]\\n\\t\\tg=[]\\n\\t\\ta=list(set(permutations(words,length)))\\n\\t\\tfor i in a:\\n\\t\\t\\ts1=\\'\\'.join(i)\\n\\t\\t\\tl1=len(s1)\\n\\t\\t\\tk.append(s1)\\n\\t\\tfor i in range(0,(len(s)-l1)+1):\\n\\t\\t\\ts2=s[i:(l1+i)]\\n\\t\\t\\tif s2 in k:\\n\\t\\t\\t\\tg.append(i)\\n\\t\\treturn(g)        \\n\\t\\t\\n\\t    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 862010,
                "title": "simple-java-solution-with-explanation-using-2-hashmaps-o-m-n-m-no-of-words-in-words",
                "content": "**Approach:**\\n\\nThe idea to solve the problem is - \\n- Search for each word in given string in every substring window of length = sum of length of concatenated words from words[]. \\n- Whenever all the words are found in the substring window, then we store the starting index of that substring window.\\n\\n**Algo:**\\n\\nWe can break the solution of the problem into 4 steps - \\n1. Store all the words from the `words[]` in a `wordsMap` with the count of each word.\\n2. Calculate the total length of concatenated words in the `words[]` and store it in a variable say `concatWordLen`.\\n3. Iterate through the actual string and extract words of length of `words[0]` (any word in words[] as all length are same) from the string upto `concatWordLen`. Store the extracted words in another `substringWordsMap`. If at any point of time if we find a word that is not in the original `wordsMap` OR the count of any particular word in the `substringWordsMap` is greater than the count of that word in `wordsMap`, we break out of that window.\\n4.  Once all the words from the substring are matched till the length of `concatWordLen`, we check if the contents of this substring map is equal to the contents of the word map. If the contents match, we add to the indices list.\\n\\n**Code:**\\n\\n```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        Map<String, Integer> wordsMap = new HashMap<>();\\n        List<Integer> indices = new ArrayList<>();\\n\\n        for(String word : words)\\n            wordsMap.put(word, wordsMap.getOrDefault(word, 0) + 1);\\n\\n        int wordLen = words[0].length();\\n        int concatWordLen = wordLen * words.length;\\n\\n        for (int i=0; i<= s.length() - concatWordLen; i++){\\n            int startingWordIdx = i;\\n            Map<String, Integer> substringWordsMap = new HashMap<>();\\n            while(startingWordIdx < i + concatWordLen){\\n                String word = s.substring(startingWordIdx, startingWordIdx + wordLen);\\n                if (!wordsMap.containsKey(word) || \\n                    (wordsMap.containsKey(word) && substringWordsMap.containsKey(word) &&\\n                     substringWordsMap.get(word) > wordsMap.get(word)))\\n                    break;\\n                substringWordsMap.put(word, substringWordsMap.getOrDefault(word, 0) + 1);\\n                startingWordIdx = startingWordIdx + wordLen;\\n            }\\n            if (wordsMap.equals(substringWordsMap))\\n                indices.add(i);\\n        }\\n        return indices;\\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        Map<String, Integer> wordsMap = new HashMap<>();\\n        List<Integer> indices = new ArrayList<>();\\n\\n        for(String word : words)\\n            wordsMap.put(word, wordsMap.getOrDefault(word, 0) + 1);\\n\\n        int wordLen = words[0].length();\\n        int concatWordLen = wordLen * words.length;\\n\\n        for (int i=0; i<= s.length() - concatWordLen; i++){\\n            int startingWordIdx = i;\\n            Map<String, Integer> substringWordsMap = new HashMap<>();\\n            while(startingWordIdx < i + concatWordLen){\\n                String word = s.substring(startingWordIdx, startingWordIdx + wordLen);\\n                if (!wordsMap.containsKey(word) || \\n                    (wordsMap.containsKey(word) && substringWordsMap.containsKey(word) &&\\n                     substringWordsMap.get(word) > wordsMap.get(word)))\\n                    break;\\n                substringWordsMap.put(word, substringWordsMap.getOrDefault(word, 0) + 1);\\n                startingWordIdx = startingWordIdx + wordLen;\\n            }\\n            if (wordsMap.equals(substringWordsMap))\\n                indices.add(i);\\n        }\\n        return indices;\\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 565286,
                "title": "pure-o-n-number-of-words-runtime-beats-84-in-runtime-and-100-in-memory",
                "content": "To understand what will be going on inside my solution, let\\'s discuss some hashing concepts for comparing two sets.\\n\\n**Concept**\\nLet\\'s consider we have two unordered sets (it can be multisets too, no problem) as **s1** and **s2**. Now, we need to determine whether these two sets are equal or not. Here, being **equal** means if we sort these two sets, they will eventually turn out to be the same sets.\\n\\n**Solution:**\\nConsidering both sets are of equal size, the solution is O(|s|) in runtime and O(1) in space complexity. All we need to do is: find hash values for both sets and compare whether they are the same or not! That\\'s it!\\nOur hashing function will be:\\n![image](https://assets.leetcode.com/users/bonchitoboys/image_1586102364.png)\\nwhere,\\n* initially **h = 1** and OFFSET is any random value greater than 0. \\n* n = size of set\\n\\nProbability of Collision: O(N / MOD) where N is the number of items in one set. This probability can be written as our hash function is nothing but a polynomial of degree N. (from **Schwartz-Zippel lemma**)\\n\\n**Main Solution:**\\n\\nConsider each word from **words** as a single integer! Now the problem can be reduced to the following:\\n\\n*Find the number of sets in **S** those are equal to set **words***\\n\\nExample:\\n s = \"barfoothefoobarman\",\\n words = [\"foo\",\"bar\"]\\n \\n converted words = [\"123\", \"456\"] (just assumed their hash values)\\n hash of words = [\"999999\"] (another assumption)\\n\\nNow, iterate over each 3 length substring from **S**, calculate their hash values with polynomial string hashing, add the same OFFSET previously used, consider this hash value as an integer from the set and calculate the final hash value for the contiguous substring. It\\'s kind of running a sliding window of length **|words| * |words[0]|** and checking whether the contiguous substring forms an equal set as **words**.\\n\\nSo, that\\'s all!\\n\\nTotal runtime complexity: **O(N * number of words)**\\nTotal space complexity: **O(|s|)**\\n\\n```\\n#define MAX 10000\\n#define MOD 1000000007\\n#define ll long long\\n#define OFFSET 7\\n\\nll h[MAX + 5], po[MAX + 5];\\n\\nvoid pre(string &s)\\n{\\n    h[0] = s[0];\\n    po[0] = 1;\\n    for(int i = 1; i < s.size(); i++)\\n    {\\n        h[i] = ((h[i - 1] * 263) + (s[i])) % MOD;\\n        po[i] = (po[i - 1] * 263) % MOD;\\n    }\\n}\\n\\nll getHash(int L, int R)\\n{\\n    if(!L) return h[R];\\n    return (h[R] - ((h[L - 1] * po[R - L + 1])%MOD) + MOD) % MOD;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        if(s.size() == 0 || words.size() == 0) return vector<int>();\\n        pre(s);\\n        ll wH = 1;\\n        for(auto &word : words)\\n        {\\n            ll h = 0;\\n            for(auto &ch : word)\\n            {\\n                h = ((h * 263) + ch) % MOD;\\n            }\\n            wH = (wH * (h + OFFSET)) % MOD;\\n        }\\n        int tot_len = words[0].size();\\n        tot_len *= words.size();\\n        int plen = words[0].size();\\n        vector<int>indices;\\n        for(int i = 0; i + tot_len <= s.size(); i++)\\n        {\\n            ll substr_hash = 1;\\n            for(int j = i, idx = 0; idx < words.size(); idx++, j += plen)\\n            {\\n                int L = j;\\n                int R = j + plen - 1;\\n                if(R >= s.size()) break;\\n                substr_hash = (substr_hash * (getHash(L, R) + OFFSET)) % MOD;\\n            }\\n            if(substr_hash == wH) indices.push_back(i);\\n        }\\n        return indices;\\n    }\\n};\\n```\\n\\n\\n\\n",
                "solutionTags": [],
                "code": "```\\n#define MAX 10000\\n#define MOD 1000000007\\n#define ll long long\\n#define OFFSET 7\\n\\nll h[MAX + 5], po[MAX + 5];\\n\\nvoid pre(string &s)\\n{\\n    h[0] = s[0];\\n    po[0] = 1;\\n    for(int i = 1; i < s.size(); i++)\\n    {\\n        h[i] = ((h[i - 1] * 263) + (s[i])) % MOD;\\n        po[i] = (po[i - 1] * 263) % MOD;\\n    }\\n}\\n\\nll getHash(int L, int R)\\n{\\n    if(!L) return h[R];\\n    return (h[R] - ((h[L - 1] * po[R - L + 1])%MOD) + MOD) % MOD;\\n}\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        if(s.size() == 0 || words.size() == 0) return vector<int>();\\n        pre(s);\\n        ll wH = 1;\\n        for(auto &word : words)\\n        {\\n            ll h = 0;\\n            for(auto &ch : word)\\n            {\\n                h = ((h * 263) + ch) % MOD;\\n            }\\n            wH = (wH * (h + OFFSET)) % MOD;\\n        }\\n        int tot_len = words[0].size();\\n        tot_len *= words.size();\\n        int plen = words[0].size();\\n        vector<int>indices;\\n        for(int i = 0; i + tot_len <= s.size(); i++)\\n        {\\n            ll substr_hash = 1;\\n            for(int j = i, idx = 0; idx < words.size(); idx++, j += plen)\\n            {\\n                int L = j;\\n                int R = j + plen - 1;\\n                if(R >= s.size()) break;\\n                substr_hash = (substr_hash * (getHash(L, R) + OFFSET)) % MOD;\\n            }\\n            if(substr_hash == wH) indices.push_back(i);\\n        }\\n        return indices;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 380143,
                "title": "javascript-solution-faster-than-100",
                "content": "Javascript solution, faster than 100% of solutions\\n\\nIf you enjoyed the solution, don\\'t forget to like\\nAlso, if you have questions or ideas, I appreciate if you write them in the comments\\nHave fun, and more solutions to come ))\\n\\nLink to run: https://leetcode.com/submissions/detail/259635818/\\n\\n```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar findSubstring = (s, words) => {\\n    const result = [];\\n    if (words.length > 0) {\\n        const wordsCount = words.length;\\n        const wordLength = words[0] ? words[0].length : 0;\\n        const offset = wordLength * (wordsCount - 1);\\n        const map = createHashTable(words);\\n\\n        for (let i = 0; i < wordLength; i++) {\\n            let wordsFound = 0;\\n            let tempMap = new Map();\\n\\n            let sequenceStart = i;\\n\\n            const endLength = s.length - wordLength;\\n            for (let j = i; j <= endLength; j += wordLength) {\\n                const word = s.substr(j, wordLength);\\n                const wordEntriesNeeded = map.get(word);\\n                const wordEntriesUsed = tempMap.get(word);\\n                if (wordEntriesUsed !== wordEntriesNeeded) {\\n                    wordsFound++;\\n                    tempMap.set(word, wordEntriesUsed ? wordEntriesUsed + 1 : 1);\\n                } else if (!wordEntriesNeeded) {\\n                    wordsFound = 0;\\n                    tempMap = new Map();\\n                    sequenceStart = j + wordLength;\\n                } else {\\n                    let wordToRemove;\\n\\n                    do {\\n                        wordToRemove = s.substr(sequenceStart, wordLength);\\n                        sequenceStart += wordLength;\\n                        tempMap.set(wordToRemove, tempMap.get(wordToRemove) - 1);\\n                        wordsFound--;\\n                    }\\n                    while (wordToRemove !== word && sequenceStart <= j);\\n\\n                    wordsFound++;\\n                    tempMap.set(word, tempMap.get(word) + 1);\\n                }\\n                if (wordsFound === wordsCount) {\\n                    result.push(j - offset);\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n};\\n\\nconst createHashTable = (words) => {\\n    const map = new Map();\\n    words.forEach(word => {\\n        const oldValue = map.get(word);\\n        if (map.has(word)) {\\n            map.set(word, oldValue + 1);\\n        } else {\\n            map.set(word, 1);\\n        }\\n    });\\n    return map;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar findSubstring = (s, words) => {\\n    const result = [];\\n    if (words.length > 0) {\\n        const wordsCount = words.length;\\n        const wordLength = words[0] ? words[0].length : 0;\\n        const offset = wordLength * (wordsCount - 1);\\n        const map = createHashTable(words);\\n\\n        for (let i = 0; i < wordLength; i++) {\\n            let wordsFound = 0;\\n            let tempMap = new Map();\\n\\n            let sequenceStart = i;\\n\\n            const endLength = s.length - wordLength;\\n            for (let j = i; j <= endLength; j += wordLength) {\\n                const word = s.substr(j, wordLength);\\n                const wordEntriesNeeded = map.get(word);\\n                const wordEntriesUsed = tempMap.get(word);\\n                if (wordEntriesUsed !== wordEntriesNeeded) {\\n                    wordsFound++;\\n                    tempMap.set(word, wordEntriesUsed ? wordEntriesUsed + 1 : 1);\\n                } else if (!wordEntriesNeeded) {\\n                    wordsFound = 0;\\n                    tempMap = new Map();\\n                    sequenceStart = j + wordLength;\\n                } else {\\n                    let wordToRemove;\\n\\n                    do {\\n                        wordToRemove = s.substr(sequenceStart, wordLength);\\n                        sequenceStart += wordLength;\\n                        tempMap.set(wordToRemove, tempMap.get(wordToRemove) - 1);\\n                        wordsFound--;\\n                    }\\n                    while (wordToRemove !== word && sequenceStart <= j);\\n\\n                    wordsFound++;\\n                    tempMap.set(word, tempMap.get(word) + 1);\\n                }\\n                if (wordsFound === wordsCount) {\\n                    result.push(j - offset);\\n                }\\n            }\\n        }\\n    }\\n    return result;\\n};\\n\\nconst createHashTable = (words) => {\\n    const map = new Map();\\n    words.forEach(word => {\\n        const oldValue = map.get(word);\\n        if (map.has(word)) {\\n            map.set(word, oldValue + 1);\\n        } else {\\n            map.set(word, 1);\\n        }\\n    });\\n    return map;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 360060,
                "title": "python-brute-force-super-short-passed-all-test-cases",
                "content": "The idea is:\\n1). Sort the words list, and concatenate it to a single string **words_cat**. \\n2). Loop over the string **s**. At each position **i**, get the substring starting at **i** with the same length as **words_cat**. Then, sort this substring and compare it with **words_cat**. If they are the same, add **i** into the list of valid index.\\n\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        if len(words) == 0 or len(s) == 0: return []\\n        if len(s) < len(\\'\\'.join(words)): return []\\n        \\n        rst = []\\n        words_cat = \\'\\'.join(sorted(words))\\n        l, m = len(words[0]), len(words)\\n        l_all = len(words_cat)\\n        \\n        for i in range(len(s) - l_all + 1): \\n            s_sub = []\\n            for j in range(m):\\n                s_sub.append(s[i + l * j : i + l * (j+1)])       \\n            s_sub = \\'\\'.join(sorted(s_sub))\\n            if s_sub == words_cat: rst.append(i)\\n        \\n        return rst \\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        if len(words) == 0 or len(s) == 0: return []\\n        if len(s) < len(\\'\\'.join(words)): return []\\n        \\n        rst = []\\n        words_cat = \\'\\'.join(sorted(words))\\n        l, m = len(words[0]), len(words)\\n        l_all = len(words_cat)\\n        \\n        for i in range(len(s) - l_all + 1): \\n            s_sub = []\\n            for j in range(m):\\n                s_sub.append(s[i + l * j : i + l * (j+1)])       \\n            s_sub = \\'\\'.join(sorted(s_sub))\\n            if s_sub == words_cat: rst.append(i)\\n        \\n        return rst \\n```",
                "codeTag": "Java"
            },
            {
                "id": 238924,
                "title": "solved-by-js",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar findSubstring = function(s, words) {\\n    let res=[];\\n    if(s.length==0 || words.length==0) return res;\\n    let n=words.length,m=words[0].length;\\n    let m1={};\\n//     \\u5C06\\u6240\\u6709\\u5355\\u8BCD\\u5B58\\u5165\\u54C8\\u5E0C\\u8868\\n    for(let w of words){  \\n        m1[w]?m1[w]++:(m1[w]=1)\\n    }\\n\\n    for(let i=0;i<=s.length-n*m;i++){\\n        let m2={};\\n        let j=0;\\n        for(j=0;j<n;j++){\\n//             \\u83B7\\u53D6\\u957F\\u5EA6\\u4E3Am\\u7684\\u5B57\\u4E32t\\n            let t=s.substr(i+j*m,m);\\n//             \\u5982\\u679Cm1\\u4E2D\\u4E0D\\u5B58\\u5728\\u5219\\u8DF3\\u51FA\\u5FAA\\u73AF\\n            if(!m1[t]) break;\\n//             \\u5982\\u679Cm1\\u4E2D\\u5B58\\u5728\\u5B57\\u4E32t,\\u5219\\u5B58\\u5165m2\\n            m2[t]?m2[t]++:(m2[t]=1);\\n//             \\u5982\\u679Cm2\\u4E2D\\u51FA\\u73B0\\u7684\\u5355\\u8BCD\\u6B21\\u6570\\u6BD4m1\\u591A\\uFF0C\\u8DF3\\u51FA\\u5FAA\\u73AF\\n            if(m2[t]>m1[t]) break;\\n        }\\n        if(j==n) res.push(i);\\n    }\\n    return res;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar findSubstring = function(s, words) {\\n    let res=[];\\n    if(s.length==0 || words.length==0) return res;\\n    let n=words.length,m=words[0].length;\\n    let m1={};\\n//     \\u5C06\\u6240\\u6709\\u5355\\u8BCD\\u5B58\\u5165\\u54C8\\u5E0C\\u8868\\n    for(let w of words){  \\n        m1[w]?m1[w]++:(m1[w]=1)\\n    }\\n\\n    for(let i=0;i<=s.length-n*m;i++){\\n        let m2={};\\n        let j=0;\\n        for(j=0;j<n;j++){\\n//             \\u83B7\\u53D6\\u957F\\u5EA6\\u4E3Am\\u7684\\u5B57\\u4E32t\\n            let t=s.substr(i+j*m,m);\\n//             \\u5982\\u679Cm1\\u4E2D\\u4E0D\\u5B58\\u5728\\u5219\\u8DF3\\u51FA\\u5FAA\\u73AF\\n            if(!m1[t]) break;\\n//             \\u5982\\u679Cm1\\u4E2D\\u5B58\\u5728\\u5B57\\u4E32t,\\u5219\\u5B58\\u5165m2\\n            m2[t]?m2[t]++:(m2[t]=1);\\n//             \\u5982\\u679Cm2\\u4E2D\\u51FA\\u73B0\\u7684\\u5355\\u8BCD\\u6B21\\u6570\\u6BD4m1\\u591A\\uFF0C\\u8DF3\\u51FA\\u5FAA\\u73AF\\n            if(m2[t]>m1[t]) break;\\n        }\\n        if(j==n) res.push(i);\\n    }\\n    return res;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13741,
                "title": "key-idea-maintain-multiple-windows-o-n-solution",
                "content": "because every word in the words list has the same length. We can maintain multiple sliding windows and go through String s only once. The number of the windows needed is the length of the word.\\n\\n For example suppose s=123456789, word length =3, all substrings we need to check are:\\n\\n123, 234, 345, 456, 567, 678, 789, \\nIf we group them by their first char index % word length and we get:\\n\\n0: 123, 456, 789\\n\\n1: 234, 567\\n\\n2: 345, 678\\n\\nNow we only need to check if we find a match in each window. For each window, the match algorithm is same as single sliding window problem.\\n\\n    public class Solution {\\n        public List<Integer> findSubstring(String s, String[] words) {\\n            ArrayList<Integer> ret = new ArrayList<Integer>();\\n            if (s==null || s.length()==0 || words==null || words.length==0) return ret;\\n            int wordL=words[0].length();\\n            if (s.length()<(wordL*words.length)) return ret;\\n            \\n\\n            HashMap<String, Integer> wordId = new HashMap<String,Integer>();\\n            int[] wordCount = new int[words.length];\\n            int distinctCount=0;\\n            for (int i=0;i<words.length;i++){\\n                if (wordId.containsKey(words[i])){\\n                    int idx = wordId.get(words[i]);\\n                    wordCount[idx]++;\\n                }else{\\n                    wordId.put(words[i],distinctCount);\\n                    wordCount[distinctCount++]=1;\\n                }\\n            }\\n            \\n           \\n            int[][] windows = new int[wordL][distinctCount];\\n            int[] matchCount = new int[wordL];\\n            for (int i=0;i<=s.length()-wordL;i++){\\n                String subS = s.substring(i,i+wordL);\\n            \\n                if (wordId.containsKey(subS)){\\n                    int idx = wordId.get(subS);\\n                    if (windows[i%wordL][idx]>=wordCount[idx]) {\\n                        for (int j=i-matchCount[i%wordL]*wordL;j<i;j+=wordL){\\n                            String sRemove=s.substring(j,j+wordL);\\n                            int idxRemove = wordId.get(sRemove);\\n                            windows[i%wordL][idxRemove]--;\\n                            matchCount[i%wordL]--;\\n                            if (idxRemove==idx) break;\\n                        }\\n                    }\\n                    windows[i%wordL][idx]++;\\n                    if (++matchCount[i%wordL]==words.length) ret.add(i-(matchCount[i%wordL]-1)*wordL);\\n                    \\n                    \\n                }else {\\n                     for (int j=i-matchCount[i%wordL]*wordL;j<i;j+=wordL){\\n                        String sRemove=s.substring(j,j+wordL);\\n                        int idxRemove = wordId.get(sRemove);\\n                        windows[i%wordL][idxRemove]--;\\n                        matchCount[i%wordL]--;\\n                       \\n                    }\\n                }\\n                \\n            }\\n            return ret;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> findSubstring(String s, String[] words) {\\n            ArrayList<Integer> ret = new ArrayList<Integer>();\\n            if (s==null || s.length()==0 || words==null || words.length==0) return ret;\\n            int wordL=words[0].length();\\n            if (s.length()<(wordL*words.length)) return ret;\\n            \\n\\n            HashMap<String, Integer> wordId = new HashMap<String,Integer>();\\n            int[] wordCount = new int[words.length];\\n            int distinctCount=0;\\n            for (int i=0;i<words.length;i++){\\n                if (wordId.containsKey(words[i])){\\n                    int idx = wordId.get(words[i]);\\n                    wordCount[idx]++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 13761,
                "title": "c-16ms-beating-99-86-simple-idea-easy-to-understand",
                "content": "**Basic idea**, in each position, check whether satisfies conditions.\\n\\n**Problem**, the check operation is tooooo slow. So, how to reduce the operation frequency? Using **Hash**.\\n\\n**Hash 1**, hash(str=c1c2..cn) = c1 + c2 + .. cn. Too simple? Yes, yet efficient. You could try!\\n\\n**Hash 2**, improved version, grouping by different position. For example, dict = [\"abc\", \"def\"], then our hash array is ['a' + 'd', 'b' + 'e', 'c' + 'f']. Given a str \"123456\", its hash is ['1' + '4', '2' + '5', '3' + '6']. Then compare this hash array with standard dict hash!\\n\\nIn my code, all member variables have a suffix '_'; the hash array is called FingerPrint.\\n\\n   \\n\\n    // Author: Tian Xia\\n    class Solution {\\n     public:\\n      typedef vector<int> FingerPrint;\\n    \\n      vector<int> findSubstring(const string str, const vector<string>& dict) {\\n        vector<int> ret;\\n        word_len_ = SIZE(dict[0]);\\n        char_size_ = dict.size() * word_len_; \\n    \\n        if (SIZE(str) < char_size_) {\\n          return ret;\\n        }\\n    \\n        dict_.clear();\\n        for (auto &w: dict) {\\n          dict_[w] += 1;\\n        }\\n    \\n        fp_ = gen_fingerprint();\\n        decltype(fp_) lfp(word_len_, 0);\\n        for (int p = 0; p < char_size_; ++p) {\\n          lfp[p % word_len_] += str[p];\\n        }\\n        if (equal(lfp, 0) && check(str, 0)) {\\n          ret.push_back(0);\\n        }\\n    \\n        for (int p = char_size_; p < SIZE(str); ++p) {\\n          lfp[(p) % word_len_] += -str[p - char_size_] + str[p];\\n          if (equal(lfp, p + 1) && check(str, p + 1 - char_size_)) {\\n            ret.push_back(p + 1 - char_size_);\\n          }\\n        }\\n    \\n        return ret;\\n      }\\n    \\n     protected:\\n      bool equal(const FingerPrint &fp, int start) {\\n        for (int p = 0; p < word_len_; ++p) {\\n          if (fp[(start + p) % word_len_] != fp_[p]) {\\n            return false;\\n          }\\n        }\\n        return true;\\n      }\\n    \\n      bool check(const string &str, int p) {\\n        map<string, int> freqs; \\n        for (int d = p; d < p + char_size_; d += word_len_) {\\n          string substr = str.substr(d, word_len_);\\n          freqs[substr] += 1;\\n        }\\n    \\n        auto ite1 = freqs.begin(), ite2 = dict_.begin();\\n        while (ite1 != freqs.end() && ite2 != freqs.end()) {\\n          if (ite1->first == ite2->first && ite1->second == ite2->second) {\\n            ++ite1;\\n            ++ite2;\\n            continue;\\n          }\\n          return false;\\n        }\\n    \\n        return true;\\n      }\\n    \\n      FingerPrint gen_fingerprint() {\\n        FingerPrint ret(word_len_, 0);\\n        for (auto &pair: dict_) {\\n          for (int p = 0; p < word_len_; ++p) {\\n            ret[p] += pair.first[p] * pair.second;\\n          }\\n        }\\n    \\n        return ret;\\n      }\\n    \\n      map<string, int> dict_;\\n      int char_size_, word_len_;\\n      FingerPrint fp_;\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n     public:\\n      typedef vector<int> FingerPrint;\\n    \\n      vector<int> findSubstring(const string str, const vector<string>& dict) {\\n        vector<int> ret;\\n        word_len_ = SIZE(dict[0]);\\n        char_size_ = dict.size() * word_len_; \\n    \\n        if (SIZE(str) < char_size_) {\\n          return ret;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 13771,
                "title": "short-ac-java-solution-with-o-n",
                "content": "        public List<Integer> findSubstring(String s, String[] words) {\\n            if(words.length==0||words[0].length()==0)   return new ArrayList<>();\\n            HashMap<String, Integer> map = new HashMap<>();\\n            for(String word:words)  map.put(word,map.getOrDefault(word,0)+1);\\n            List<Integer> list = new ArrayList<>();\\n            int gap = words[0].length();\\n            int nlen = words.length*gap;\\n            for(int k=0;k<gap;k++){\\n                HashMap<String,Integer> wordmap = new HashMap<>(map);\\n                for(int i=k,j=0;i<s.length()-nlen+1&&i+j<=s.length()-gap;){\\n                    String temp = s.substring(i+j,i+j+gap);\\n                    if(wordmap.containsKey(temp)){\\n                        wordmap.put(temp,wordmap.get(temp)-1);\\n                        if(wordmap.get(temp)==0)    wordmap.remove(temp);\\n                        if(wordmap.isEmpty())   list.add(i);\\n                        j+=gap;\\n                    }\\n                    else{\\n                        if(j==0)    i+=gap;\\n                        else{\\n                            wordmap.put(s.substring(i,i+gap),wordmap.getOrDefault(s.substring(i,i+gap),0)+1);\\n                            i+=gap;\\n                            j-=gap;\\n                        }\\n                    }\\n                }\\n            }\\n            return list;\\n        }\\nI made k as first word-length indexes starting from 0.  The number of all indexes that the two pointers i and j move in total is 2*N/gap (N = s.length()) because i+j does not move backwards.  Together with k, total runtime is O(N).",
                "solutionTags": [
                    "Java",
                    "Two Pointers"
                ],
                "code": "        public List<Integer> findSubstring(String s, String[] words) {\\n            if(words.length==0||words[0].length()==0)   return new ArrayList<>();\\n            HashMap<String, Integer> map = new HashMap<>();\\n            for(String word:words)  map.put(word,map.getOrDefault(word,0)+1);\\n            List<Integer> list = new ArrayList<>();\\n            int gap = words[0].length();\\n            int nlen = words.length*gap;\\n            for(int k=0;k<gap;k++){\\n                HashMap<String,Integer> wordmap = new HashMap<>(map);\\n                for(int i=k,j=0;i<s.length()-nlen+1&&i+j<=s.length()-gap;){\\n                    String temp = s.substring(i+j,i+j+gap);\\n                    if(wordmap.containsKey(temp)){\\n                        wordmap.put(temp,wordmap.get(temp)-1);\\n                        if(wordmap.get(temp)==0)    wordmap.remove(temp);\\n                        if(wordmap.isEmpty())   list.add(i);\\n                        j+=gap;\\n                    }\\n                    else{\\n                        if(j==0)    i+=gap;\\n                        else{\\n                            wordmap.put(s.substring(i,i+gap),wordmap.getOrDefault(s.substring(i,i+gap),0)+1);\\n                            i+=gap;\\n                            j-=gap;\\n                        }\\n                    }\\n                }\\n            }\\n            return list;\\n        }\\nI made k as first word-length indexes starting from 0.  The number of all indexes that the two pointers i and j move in total is 2*N/gap (N = s.length()) because i+j does not move backwards.  Together with k, total runtime is O(N).",
                "codeTag": "Unknown"
            },
            {
                "id": 13747,
                "title": "my-68ms-c-solution-without-hashing",
                "content": "it's a good idea to using Aho-Corasick to match all words, if so, the entire algorithm may down to O(n) where n is the total character count of all input strings.\\n\\n**Edition 2015/09/02:** this algorithm behaves like [Accepted Java O(n) solution using histogram][1].\\n\\n    #define newArray(type, size) ((type*)calloc(size, sizeof(type)))\\n    #define resizeArray(ptr, type, size) ((type*)realloc(ptr, (size) * sizeof(type)))\\n    \\n    int *pushback(int *array, int *size, int value) {\\n        int *output = resizeArray(array, int, *size + 1);\\n        output[(*size)++] = value;\\n        return output;\\n    }\\n    \\n    typedef struct {\\n        char *word;\\n        int occurs;\\n    } wordEntry;\\n    \\n    /**\\n     * Return an array of size *returnSize.\\n     * Note: The returned array must be malloced, assume caller calls free().\\n     */\\n    int* findSubstring(char* s, char** words, int wordsSize, int* returnSize) {\\n        int *result = NULL;\\n        *returnSize = 0;\\n    \\n        // edge conditions\\n        if (wordsSize <= 0)\\n            return result;\\n        int slength = strlen(s), wlength = strlen(words[0]);\\n        if (slength < wlength * wordsSize)\\n            return result;\\n    \\n        // handle words, count the duplicates.\\n        wordEntry *ws = newArray(wordEntry, wordsSize);\\n        int wsSize = 0, i, j, k;\\n        for (i = 0; i < wordsSize; ++i) {\\n            char *word = words[i];\\n            for (k = -1, j = 0; k < 0 && j < wsSize; ++j)\\n                if (strcmp(ws[j].word, word) == 0)\\n                    k = j;\\n            if (k < 0)\\n                k = wsSize++;\\n            ws[k].word = word;\\n            ws[k].occurs++;\\n        }\\n    \\n        // calulate word matched at each position.\\n        slength -= wlength - 1;\\n        int *ms = newArray(int, slength);\\n        for (i = 0; i < slength; ++i) {\\n            for (k = -1, j = 0; k < 0 && j < wsSize; ++j)\\n                if (strncmp(s + i, ws[j].word, wlength) == 0)\\n                    k = j;\\n            // store matched index in word list without duplicates.\\n            ms[i] = k;\\n        }\\n    \\n        // scan all possible chains, cached word indices stored in os.\\n        int *os = newArray(int, wordsSize);\\n        for (i = 0; i < wlength; ++i) {\\n            int start = i, found = 0;\\n            for (j = i; j < slength; j += wlength) {\\n                int windex = ms[j];\\n                if (windex < 0) {\\n                    // no matched word here, simply reset the marker,\\n                    // and write back all cached words.\\n                    start = j + wlength;\\n                    while (found > 0) {\\n                        ws[os[--found]].occurs++;\\n                    }\\n                    continue;\\n                }\\n                // move the matched word from word list to cache,\\n                // write back the leading cached words if necessary.\\n                if (ws[windex].occurs == 0) {\\n                    for (k = 0; k < found; ++k) {\\n                        ws[os[k]].occurs++;\\n                        start += wlength;\\n                        if (os[k] == windex) {\\n                            ++k;\\n                            break;\\n                        }\\n                    }\\n                    found -= k;\\n                    if (found)\\n                        memmove(os, os + k, found * sizeof(*os));\\n                }\\n                ws[windex].occurs--;\\n                os[found++] = windex;\\n                // push the marker position if matched all words.\\n                if (found == wordsSize)\\n                    result = pushback(result, returnSize, start);\\n            }\\n            // after scanning, write back all cached words.\\n            while (found > 0) {\\n                ws[os[--found]].occurs++;\\n            }\\n        }\\n    \\n        free(ws);\\n        free(ms);\\n        free(os);\\n    \\n        return result;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/45050/accepted-java-o-n-solution-using-histogram",
                "solutionTags": [],
                "code": "it's a good idea to using Aho-Corasick to match all words, if so, the entire algorithm may down to O(n) where n is the total character count of all input strings.\\n\\n**Edition 2015/09/02:** this algorithm behaves like [Accepted Java O(n) solution using histogram][1].\\n\\n    #define newArray(type, size) ((type*)calloc(size, sizeof(type)))\\n    #define resizeArray(ptr, type, size) ((type*)realloc(ptr, (size) * sizeof(type)))\\n    \\n    int *pushback(int *array, int *size, int value) {\\n        int *output = resizeArray(array, int, *size + 1);\\n        output[(*size)++] = value;\\n        return output;\\n    }\\n    \\n    typedef struct {\\n        char *word;\\n        int occurs;\\n    } wordEntry;\\n    \\n    /**\\n     * Return an array of size *returnSize.\\n     * Note: The returned array must be malloced, assume caller calls free().\\n     */\\n    int* findSubstring(char* s, char** words, int wordsSize, int* returnSize) {\\n        int *result = NULL;\\n        *returnSize = 0;\\n    \\n        // edge conditions\\n        if (wordsSize <= 0)\\n            return result;\\n        int slength = strlen(s), wlength = strlen(words[0]);\\n        if (slength < wlength * wordsSize)\\n            return result;\\n    \\n        // handle words, count the duplicates.\\n        wordEntry *ws = newArray(wordEntry, wordsSize);\\n        int wsSize = 0, i, j, k;\\n        for (i = 0; i < wordsSize; ++i) {\\n            char *word = words[i];\\n            for (k = -1, j = 0; k < 0 && j < wsSize; ++j)\\n                if (strcmp(ws[j].word, word) == 0)\\n                    k = j;\\n            if (k < 0)\\n                k = wsSize++;\\n            ws[k].word = word;\\n            ws[k].occurs++;\\n        }\\n    \\n        // calulate word matched at each position.\\n        slength -= wlength - 1;\\n        int *ms = newArray(int, slength);\\n        for (i = 0; i < slength; ++i) {\\n            for (k = -1, j = 0; k < 0 && j < wsSize; ++j)\\n                if (strncmp(s + i, ws[j].word, wlength) == 0)\\n                    k = j;\\n            // store matched index in word list without duplicates.\\n            ms[i] = k;\\n        }\\n    \\n        // scan all possible chains, cached word indices stored in os.\\n        int *os = newArray(int, wordsSize);\\n        for (i = 0; i < wlength; ++i) {\\n            int start = i, found = 0;\\n            for (j = i; j < slength; j += wlength) {\\n                int windex = ms[j];\\n                if (windex < 0) {\\n                    // no matched word here, simply reset the marker,\\n                    // and write back all cached words.\\n                    start = j + wlength;\\n                    while (found > 0) {\\n                        ws[os[--found]].occurs++;\\n                    }\\n                    continue;\\n                }\\n                // move the matched word from word list to cache,\\n                // write back the leading cached words if necessary.\\n                if (ws[windex].occurs == 0) {\\n                    for (k = 0; k < found; ++k) {\\n                        ws[os[k]].occurs++;\\n                        start += wlength;\\n                        if (os[k] == windex) {\\n                            ++k;\\n                            break;\\n                        }\\n                    }\\n                    found -= k;\\n                    if (found)\\n                        memmove(os, os + k, found * sizeof(*os));\\n                }\\n                ws[windex].occurs--;\\n                os[found++] = windex;\\n                // push the marker position if matched all words.\\n                if (found == wordsSize)\\n                    result = pushback(result, returnSize, start);\\n            }\\n            // after scanning, write back all cached words.\\n            while (found > 0) {\\n                ws[os[--found]].occurs++;\\n            }\\n        }\\n    \\n        free(ws);\\n        free(ms);\\n        free(os);\\n    \\n        return result;\\n    }\\n\\n\\n  [1]: https://leetcode.com/discuss/45050/accepted-java-o-n-solution-using-histogram",
                "codeTag": "Python3"
            },
            {
                "id": 13823,
                "title": "my-java-solution-with-recursion",
                "content": "    public class Solution {\\n        public List<Integer> findSubstring(String s, String[] words) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if (s==null || words.length == 0){\\n                return result;\\n            }\\n           \\n            HashMap<String, Integer> allWords = new HashMap<String, Integer>();\\n            for (int i=0;i<words.length;i++){\\n            \\tString w = words[i];\\n            \\tif (!allWords.containsKey(w)){\\n            \\t\\tallWords.put(w, 1);\\n            \\t}\\n            \\telse{\\n            \\t\\tInteger count = allWords.get(w);\\n            \\t\\tcount++;\\n            \\t\\tallWords.put(w, count);\\n            \\t}\\n            }\\n            int wordLength = words[0].length();\\n            int length = words.length*wordLength;\\n            for (int i=0;i<=s.length()-length;i++){\\n            \\tboolean b = findWords(s, i, (Map)allWords.clone(), wordLength);\\n            \\tif (b){\\n            \\t\\tresult.add(i);\\n            \\t}\\n            }\\n            return result;\\n    \\t}\\n    \\t\\n    \\tprivate boolean findWords(String s, int startIndex, Map<String, Integer> allWords, int wordLength){\\n    \\t\\tif (allWords.isEmpty()){\\n    \\t\\t\\treturn true;\\n    \\t\\t}\\n    \\t\\tString s1 = s.substring(startIndex, startIndex+wordLength);\\n    \\t\\tif (allWords.containsKey(s1)){\\n    \\t\\t\\tint result = allWords.get(s1);\\n    \\t\\t\\tresult--;\\n    \\t\\t\\tif (result == 0){\\n    \\t\\t\\t\\tallWords.remove(s1);\\n    \\t\\t\\t}\\n    \\t\\t\\telse{\\n    \\t\\t\\t\\tallWords.put(s1, result);\\n    \\t\\t\\t}\\n    \\t\\t\\treturn findWords(s, startIndex+wordLength, allWords, wordLength);\\n    \\t\\t}\\n    \\t\\treturn false;\\n    \\t}\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> findSubstring(String s, String[] words) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if (s==null || words.length == 0){\\n                return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 13825,
                "title": "my-c-code-with-hashtable-with-queue-for-o-n-runtime-71ms-runtime",
                "content": "I would like share my linear solution with HashTable and Queue with runtime only 71ms. The Queue is used to store the last appearance position of the first word of that type. You need to update the Queue each time.\\n\\n   \\n\\n    vector<int> findSubstring(string S, vector<string> &L) {\\n            vector<int> res;\\n            if (L.size() == 0) return res;\\n            if (S.size() == 0) return res;\\n            int wordLen = L[0].size();\\n            if (S.size() < wordLen) return res;\\n            \\n            unordered_map<string, queue<int> > wordhash; // word and appearing positions.\\n            unordered_map<string, queue<int> >::iterator it;\\n            queue<int> Q;\\n            Q.push(-1);\\n            for (int i = 0; i<L.size(); ++i) {\\n                it = wordhash.find(L[i]);\\n                if (it == wordhash.end()) {\\n                    wordhash[L[i]] = Q;\\n                } else {\\n                    it->second.push(-1);\\n                }\\n            }\\n            unordered_map<string, queue<int> > temp = wordhash;\\n            for (int i = 0; i<wordLen; ++i) {\\n                int currWordCnt = 0;\\n                wordhash = temp;\\n                for (int index = i; index<=S.size()-wordLen; index += wordLen) {\\n                    it = wordhash.find(S.substr(index, wordLen));\\n                    if (it == wordhash.end()) {\\n                        currWordCnt = 0;\\n                    } else {\\n                        int lastPos = it->second.front();\\n                        if (lastPos == -1) {\\n                            currWordCnt++;\\n                        } else if (currWordCnt*wordLen < index-lastPos) {\\n                            currWordCnt++;\\n                        } else {\\n                            currWordCnt = (index-lastPos)/wordLen;\\n                        }\\n                        it->second.pop();\\n                        it->second.push(index);\\n                        if (currWordCnt == L.size()) {\\n                            res.push_back(index-wordLen*(L.size()-1));\\n                        }\\n                    }\\n                }\\n            }\\n            return res;\\n        }",
                "solutionTags": [
                    "Queue"
                ],
                "code": "I would like share my linear solution with HashTable and Queue with runtime only 71ms. The Queue is used to store the last appearance position of the first word of that type. You need to update the Queue each time.\\n\\n   \\n\\n    vector<int> findSubstring(string S, vector<string> &L) {\\n            vector<int> res;\\n            if (L.size() == 0) return res;\\n            if (S.size() == 0) return res;\\n            int wordLen = L[0].size();\\n            if (S.size() < wordLen) return res;\\n            \\n            unordered_map<string, queue<int> > wordhash; // word and appearing positions.\\n            unordered_map<string, queue<int> >::iterator it;\\n            queue<int> Q;\\n            Q.push(-1);\\n            for (int i = 0; i<L.size(); ++i) {\\n                it = wordhash.find(L[i]);\\n                if (it == wordhash.end()) {\\n                    wordhash[L[i]] = Q;\\n                } else {\\n                    it->second.push(-1);\\n                }\\n            }\\n            unordered_map<string, queue<int> > temp = wordhash;\\n            for (int i = 0; i<wordLen; ++i) {\\n                int currWordCnt = 0;\\n                wordhash = temp;\\n                for (int index = i; index<=S.size()-wordLen; index += wordLen) {\\n                    it = wordhash.find(S.substr(index, wordLen));\\n                    if (it == wordhash.end()) {\\n                        currWordCnt = 0;\\n                    } else {\\n                        int lastPos = it->second.front();\\n                        if (lastPos == -1) {\\n                            currWordCnt++;\\n                        } else if (currWordCnt*wordLen < index-lastPos) {\\n                            currWordCnt++;\\n                        } else {\\n                            currWordCnt = (index-lastPos)/wordLen;\\n                        }\\n                        it->second.pop();\\n                        it->second.push(index);\\n                        if (currWordCnt == L.size()) {\\n                            res.push_back(index-wordLen*(L.size()-1));\\n                        }\\n                    }\\n                }\\n            }\\n            return res;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 3732123,
                "title": "easy-solution-with-o-n-tc",
                "content": "# Intuition\\nWe can reduce the Time Complexity to O(N) by checking for starting points only lets asume if we are at index i and if this is starting point of a string then next string will start from i+k, each required substring will start from : P+ MxK\\nwhere 0<=P<K and m is some int, K is length of individual string\\n\\n \\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string,int> cnt,record;\\n        for(auto w: words) cnt[w]++;\\n        vector <int> ans;\\n        int n = s.size(),m = words.size(),k = words[0].size();\\n        \\n        for(int P = 0;P < k;P++){\\n            int left =P;int sum = 0;record.clear();\\n            for(int j = P;j <=n - k;j+=k){\\n                string tmp = s.substr(j,k);\\n                if(cnt.count(tmp)){\\n                    record[tmp]++;sum++;\\n                    while(record[tmp] > cnt[tmp]){\\n                        string rem = s.substr(left,k);\\n                        record[rem]--;\\n                        if(record[rem]==0) record.erase(rem);\\n                        left += k;\\n                        sum--;\\n                    }\\n                    if(sum==m){\\n                        ans.push_back(left);\\n                    }\\n                }else{\\n                    left = j+k;\\n                    record.clear();\\n                    sum=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string,int> cnt,record;\\n        for(auto w: words) cnt[w]++;\\n        vector <int> ans;\\n        int n = s.size(),m = words.size(),k = words[0].size();\\n        \\n        for(int P = 0;P < k;P++){\\n            int left =P;int sum = 0;record.clear();\\n            for(int j = P;j <=n - k;j+=k){\\n                string tmp = s.substr(j,k);\\n                if(cnt.count(tmp)){\\n                    record[tmp]++;sum++;\\n                    while(record[tmp] > cnt[tmp]){\\n                        string rem = s.substr(left,k);\\n                        record[rem]--;\\n                        if(record[rem]==0) record.erase(rem);\\n                        left += k;\\n                        sum--;\\n                    }\\n                    if(sum==m){\\n                        ans.push_back(left);\\n                    }\\n                }else{\\n                    left = j+k;\\n                    record.clear();\\n                    sum=0;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3580379,
                "title": "simple-o-n-solution-typescript-regex",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRather than doing a recursive solution, it seemed simpler and more efficient to use a moving window.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nInitialize the `right` pointer as the lentgh of all the `words` items lengths.\\n\\nFor each letter in the `s` string, create a substring from `i` to the `right` pointer, and run a RegEx to break up the result string into an array, where each item length is equal to the `words[0]` length. Sort the array, and compare the string values of both arrays. If they match, save the `i` index.\\n\\nRetun results.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunction findSubstring(s: string, words: string[]): number[] {\\n    words.sort();\\n    let right = words.reduce((acc, curr) => acc += curr.length, 0);\\n    const results = [];\\n    for (let i = 0 ; right < s.length + 1 ; i++, right++) {\\n        let subString = s.substring(i, right).match(new RegExp(`.{1,${words[0].length}}`, \\'g\\')).sort();\\n        if (JSON.stringify(subString) === JSON.stringify(words)) results.push(i)\\n    };\\n    return results;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "String Matching"
                ],
                "code": "```\\nfunction findSubstring(s: string, words: string[]): number[] {\\n    words.sort();\\n    let right = words.reduce((acc, curr) => acc += curr.length, 0);\\n    const results = [];\\n    for (let i = 0 ; right < s.length + 1 ; i++, right++) {\\n        let subString = s.substring(i, right).match(new RegExp(`.{1,${words[0].length}}`, \\'g\\')).sort();\\n        if (JSON.stringify(subString) === JSON.stringify(words)) results.push(i)\\n    };\\n    return results;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3565841,
                "title": "not-easy-but-you-can-take-a-look",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> res;\\n        if (words.empty()) return res;\\n        int n = s.size(), m = words.size(), k = words[0].size();\\n        unordered_map<string, int> mp;\\n        for (string& word : words) mp[word]++;\\n        for (int i = 0; i < k; i++) {\\n            int left = i, count = 0;\\n            unordered_map<string, int> t;\\n            for (int j = i; j <= n - k; j += k) {\\n                string str = s.substr(j, k);\\n                if (mp.count(str)) {\\n                    t[str]++;\\n                    if (t[str] <= mp[str]) count++;\\n                    else {\\n                        while (t[str] > mp[str]) {\\n                            string str1 = s.substr(left, k);\\n                            t[str1]--;\\n                            if (t[str1] < mp[str1]) count--;\\n                            left += k;\\n                        }\\n                    }\\n                    if (count == m) {\\n                        res.push_back(left);\\n                        t[s.substr(left, k)]--;\\n                        count--;\\n                        left += k;\\n                    }\\n                } else {\\n                    t.clear();\\n                    count = 0;\\n                    left = j + k;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\nUpvote if you understood.\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> res;\\n        if (words.empty()) return res;\\n        int n = s.size(), m = words.size(), k = words[0].size();\\n        unordered_map<string, int> mp;\\n        for (string& word : words) mp[word]++;\\n        for (int i = 0; i < k; i++) {\\n            int left = i, count = 0;\\n            unordered_map<string, int> t;\\n            for (int j = i; j <= n - k; j += k) {\\n                string str = s.substr(j, k);\\n                if (mp.count(str)) {\\n                    t[str]++;\\n                    if (t[str] <= mp[str]) count++;\\n                    else {\\n                        while (t[str] > mp[str]) {\\n                            string str1 = s.substr(left, k);\\n                            t[str1]--;\\n                            if (t[str1] < mp[str1]) count--;\\n                            left += k;\\n                        }\\n                    }\\n                    if (count == m) {\\n                        res.push_back(left);\\n                        t[s.substr(left, k)]--;\\n                        count--;\\n                        left += k;\\n                    }\\n                } else {\\n                    t.clear();\\n                    count = 0;\\n                    left = j + k;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\nUpvote if you understood.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952804,
                "title": "well-explained-code-in-java-with-space-and-time-complexity",
                "content": "**UPVOTE IF YOU LIKED THE SOLUTION!**\\n# Approach\\nThe code is a solution in Java that returns the starting indices of all concatenated substrings in a given input string. The function takes in two arguments: a string s and an array of strings words.\\n\\nThe function first handles an edge case where the input string is empty or the array of words is empty, in which case it returns an empty list. It then initializes a list to store the starting indices of the concatenated substrings and a map to store the counts of each word in the words array. The function then loops through the words array and increments the count for each word in the map.\\n\\nNext, the function initializes a map to store the counts of each word in the current substring and variables to keep track of the length of each word and the total length of all the words. It then loops through the input string, checking for concatenated substrings at each position. For each position, it clears the current counts map and loops through the words in the current substring, updating their counts in the current counts map.\\n\\nFinally, the function checks if the current counts map is equal to the original word counts map using the equals() method. If they are equal, it means that the current substring is a concatenation of all the words in the words array, so the function adds the starting index of the current substring to the list of indices.\\n\\n\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is O(n * m), where n is the length of the input string and m is the total length of all the words in the words array. The outer loop iterates through the input string with a time complexity of O(n), and the inner loop iterates through the words in the current substring with a time complexity of O(m).\\n\\n- Space complexity:\\nThe space complexity is O(m), because it stores the counts of each word in the words array in a map.\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n    // Edge case: return an empty list if the input string is empty or the array of words is empty\\n    if (s.isEmpty() || words.length == 0) {\\n      return new ArrayList<>();\\n    }\\n\\n    // Initialize a list to store the starting indices of the concatenated substrings\\n    List<Integer> indices = new ArrayList<>();\\n\\n    // Initialize a map to store the counts of each word in the array of words\\n    Map<String, Integer> wordCounts = new HashMap<>();\\n    for (String word : words) {\\n      wordCounts.put(word, wordCounts.getOrDefault(word, 0) + 1);\\n    }\\n\\n    // Initialize a map to store the counts of each word in the current substring\\n    Map<String, Integer> currentCounts = new HashMap<>();\\n\\n    // Initialize variables to keep track of the length of each word and the total length of all the words\\n    int wordLength = words[0].length();\\n    int totalLength = wordLength * words.length;\\n\\n    // Loop through the input string, checking for concatenated substrings at each position\\n    for (int i = 0; i < s.length() - totalLength + 1; i++) {\\n      // Initialize the current counts map for the new substring\\n      currentCounts.clear();\\n\\n      // Loop through the words in the current substring and update their counts in the current counts map\\n      for (int j = 0; j < words.length; j++) {\\n        String word = s.substring(i + j * wordLength, i + (j + 1) * wordLength);\\n        currentCounts.put(word, currentCounts.getOrDefault(word, 0) + 1);\\n      }\\n\\n      // Check if the current counts map is equal to the original word counts map\\n      if (currentCounts.equals(wordCounts)) {\\n        // If they are equal, add the starting index of the current substring to the list of indices\\n        indices.add(i);\\n      }\\n    }\\n\\n    // Return the list of indices\\n    return indices;\\n  }\\n}\\n\\n    \\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n    // Edge case: return an empty list if the input string is empty or the array of words is empty\\n    if (s.isEmpty() || words.length == 0) {\\n      return new ArrayList<>();\\n    }\\n\\n    // Initialize a list to store the starting indices of the concatenated substrings\\n    List<Integer> indices = new ArrayList<>();\\n\\n    // Initialize a map to store the counts of each word in the array of words\\n    Map<String, Integer> wordCounts = new HashMap<>();\\n    for (String word : words) {\\n      wordCounts.put(word, wordCounts.getOrDefault(word, 0) + 1);\\n    }\\n\\n    // Initialize a map to store the counts of each word in the current substring\\n    Map<String, Integer> currentCounts = new HashMap<>();\\n\\n    // Initialize variables to keep track of the length of each word and the total length of all the words\\n    int wordLength = words[0].length();\\n    int totalLength = wordLength * words.length;\\n\\n    // Loop through the input string, checking for concatenated substrings at each position\\n    for (int i = 0; i < s.length() - totalLength + 1; i++) {\\n      // Initialize the current counts map for the new substring\\n      currentCounts.clear();\\n\\n      // Loop through the words in the current substring and update their counts in the current counts map\\n      for (int j = 0; j < words.length; j++) {\\n        String word = s.substring(i + j * wordLength, i + (j + 1) * wordLength);\\n        currentCounts.put(word, currentCounts.getOrDefault(word, 0) + 1);\\n      }\\n\\n      // Check if the current counts map is equal to the original word counts map\\n      if (currentCounts.equals(wordCounts)) {\\n        // If they are equal, add the starting index of the current substring to the list of indices\\n        indices.add(i);\\n      }\\n    }\\n\\n    // Return the list of indices\\n    return indices;\\n  }\\n}\\n\\n    \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2792019,
                "title": "c-unordered-map-easy-approach",
                "content": "Here is my c++ code for this problem.\\n\\'\\'\\'\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<int> findSubstring(string s, vector<string>& words) {\\n\\t\\t\\tunordered_map<string, int>m;\\n\\t\\t\\tint sz=0, len=words[0].size();\\n\\t\\t\\tfor(int i=0; i<words.size(); i++){\\n\\t\\t\\t\\tm[words[i]]++;\\n\\t\\t\\t\\tsz+=words[i].size();\\n\\t\\t\\t}\\n\\t\\t\\tvector<int>ans;\\n\\t\\t\\tfor(int i=0; i<s.size()-sz+1; i++){\\n\\t\\t\\t\\tunordered_map<string, int>m1(m);\\n\\t\\t\\t\\t//vector<int>v;\\n\\t\\t\\t\\tint i1=i, j1=i+sz-1;\\n\\t\\t\\t\\t//cout<<i1<<\" \"<<j1<<endl;\\n\\t\\t\\t\\twhile(i1<=j1){\\n\\t\\t\\t\\t\\t//cout<<s.substr(i1, len)<<\" \"<<i1<<endl;\\n\\t\\t\\t\\t\\tif(m1[s.substr(i1, len)]>0){\\n\\t\\t\\t\\t\\t\\t//v.push_back(i1);\\n\\t\\t\\t\\t\\t\\t//cout<<s.substr(i1, len)<<\" \"<<i1<<endl;\\n\\t\\t\\t\\t\\t\\tm1[s.substr(i1, len)]--;\\n\\t\\t\\t\\t\\t\\tif(m1[s.substr(i1, len)]==0){\\n\\t\\t\\t\\t\\t\\t\\tm1.erase(s.substr(i1, len));\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\t\\t//cout<<\"here\"<<endl;\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\ti1+=len;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//cout<<m1.size()<<endl;\\n\\t\\t\\t\\tif(m1.size()==0){ans.push_back(i);}\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};\\n\\'\\'\\'",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<int> findSubstring(string s, vector<string>& words) {\\n\\t\\t\\tunordered_map<string, int>m;\\n\\t\\t\\tint sz=0, len=words[0].size();\\n\\t\\t\\tfor(int i=0; i<words.size(); i++){\\n\\t\\t\\t\\tm[words[i]]++;\\n\\t\\t\\t\\tsz+=words[i].size();\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2782961,
                "title": "js-multiple-approaches-easy-to-understand",
                "content": "I just found this Blog and Github repository with solutions to Leetcode problems.\\nhttps://leet-codes.blogspot.com/2022/10/substring-with-concatenation-of-all.html\\nIt has solutions to almost every problem on Leetcode, and I recommend checking it out.\\nNote: You can bookmark it as a resource, and approach. Other approaches are in above blog\\n<br>\\n\\n```\\nvar findSubstring = function (s, words) {\\n    // Initialise an array to store our answers in\\n    let answers = [];\\n\\n    // Calculate the total length of the words\\n    const totalLengthOfWords = words.reduce(\\n        (total, word) => (total += word.length),\\n        0\\n    );\\n\\n    // Loop through the string, until there is insufficient space left to find all words\\n    for (let i = 0; i <= s.length - totalLengthOfWords; i++) {\\n        // If the string from this point contains all target words, store the starting position\\n        if (doesStringContainAllWords(s.substring(i), words.slice())) {\\n            answers.push(i);\\n        }\\n    }\\n\\n    return answers;\\n};\\n\\nfunction doesStringContainAllWords(string, words) {\\n    // If all words have been found\\n    if (!words.length) return true;\\n\\n    // Loop through all words\\n    for (let i = 0; i < words.length; i++) {\\n        // Store the length of the target word (as it may be spliced)\\n        const targetWordLength = words[i].length;\\n\\n        // Check if the word in question matches is found at the start of the string\\n        if (string.substring(0, targetWordLength) === words[i]) {\\n            // Remove the found word from the words array\\n            words.splice(i, 1);\\n\\n            // Look for the remaining words in the rest of the string\\n            return doesStringContainAllWords(\\n                string.substring(targetWordLength),\\n                words\\n            );\\n        }\\n    }\\n\\n    // If no words were found in the current string\\n    return false;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findSubstring = function (s, words) {\\n    // Initialise an array to store our answers in\\n    let answers = [];\\n\\n    // Calculate the total length of the words\\n    const totalLengthOfWords = words.reduce(\\n        (total, word) => (total += word.length),\\n        0\\n    );\\n\\n    // Loop through the string, until there is insufficient space left to find all words\\n    for (let i = 0; i <= s.length - totalLengthOfWords; i++) {\\n        // If the string from this point contains all target words, store the starting position\\n        if (doesStringContainAllWords(s.substring(i), words.slice())) {\\n            answers.push(i);\\n        }\\n    }\\n\\n    return answers;\\n};\\n\\nfunction doesStringContainAllWords(string, words) {\\n    // If all words have been found\\n    if (!words.length) return true;\\n\\n    // Loop through all words\\n    for (let i = 0; i < words.length; i++) {\\n        // Store the length of the target word (as it may be spliced)\\n        const targetWordLength = words[i].length;\\n\\n        // Check if the word in question matches is found at the start of the string\\n        if (string.substring(0, targetWordLength) === words[i]) {\\n            // Remove the found word from the words array\\n            words.splice(i, 1);\\n\\n            // Look for the remaining words in the rest of the string\\n            return doesStringContainAllWords(\\n                string.substring(targetWordLength),\\n                words\\n            );\\n        }\\n    }\\n\\n    // If no words were found in the current string\\n    return false;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2681911,
                "title": "using-hashmap",
                "content": "```class Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len=words[0].size();\\n        int noofWords=words.size();\\n        vector<int> ans;\\n        unordered_map<string,int> umap;\\n        if(len*noofWords>s.length())\\n        {\\n            return ans;\\n        }\\n        for(string word:words)\\n        {\\n            umap[word]++;\\n        }\\n        for(int i=0;i<=s.length()-(noofWords*len);i++)\\n        {\\n            unordered_map<string,int> mp;\\n            for(int j=i;j<i+(noofWords*len);j+=len)\\n            {\\n                string str=s.substr(j,len);\\n                if(umap.find(str)==mp.end())break;\\n                else\\n                {\\n                    mp[str]++;\\n                }\\n                if(mp[str]>umap[str])break;\\n            }\\n            if(mp==umap)ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n      \\n};\\n```\\n**UPVOTE IF U FOUND IT HELPFUL**",
                "solutionTags": [
                    "Hash Table"
                ],
                "code": "```class Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len=words[0].size();\\n        int noofWords=words.size();\\n        vector<int> ans;\\n        unordered_map<string,int> umap;\\n        if(len*noofWords>s.length())\\n        {\\n            return ans;\\n        }\\n        for(string word:words)\\n        {\\n            umap[word]++;\\n        }\\n        for(int i=0;i<=s.length()-(noofWords*len);i++)\\n        {\\n            unordered_map<string,int> mp;\\n            for(int j=i;j<i+(noofWords*len);j+=len)\\n            {\\n                string str=s.substr(j,len);\\n                if(umap.find(str)==mp.end())break;\\n                else\\n                {\\n                    mp[str]++;\\n                }\\n                if(mp[str]>umap[str])break;\\n            }\\n            if(mp==umap)ans.push_back(i);\\n        }\\n        return ans;\\n    }\\n      \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419835,
                "title": "c-most-optimal-solution-beats-96-easy-readable-and-commented-code",
                "content": "```\\nclass Solution {\\n\\t// function to remove a word from usedWords hasmap\\n    void remove(unordered_map<string, int> &hashmap, string &key)\\n    {\\n        hashmap[key]--;\\n        if(hashmap[key] <= 0)\\n            hashmap.erase(key);\\n    }\\n    \\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> wordDict;\\n        unordered_map<string, int> usedWords;\\n        int word_len = words[0].length(), total_words = words.size();\\n        int left = 0, right = 0, n = s.length();\\n        int words_used = 0;\\n        vector<int> ans;\\n        \\n\\t\\t// wordDict contains all words with their frequencies\\n        for(auto &word: words)\\n            wordDict[word]++;\\n        \\n\\t\\t// We iterate staring from every index in range [0, word_len] to get every possible combination\\n        for(int i=0; i<word_len; i++)\\n        {\\n\\t\\t\\t// right pointer is used to expand the current window and \\n\\t\\t\\t// left pointer is used to shrink the current window whenever the window becomes invalid\\n            left = i, right = i;\\n            usedWords.clear();\\n            words_used = 0;\\n\\t\\t\\t\\n\\t\\t\\t// We start iterating till end of string\\n\\t\\t\\t// Once we pick a word of length \\'word_len\\' then we go to next index = \\'right + word_len\\'\\n            while(right < n)\\n            {\\n                auto curr = s.substr(right, min(n-right, word_len));\\n                \\n\\t\\t\\t\\t// If the curr picked word does not exist in the words array given to us then the current window is no longer usefull and so we discard all the words we have used untill now and increment our right and left pointer to point to the next word in sequence\\n                if(wordDict.find(curr) == wordDict.end())\\n                {\\n                    usedWords.clear();\\n                    words_used = 0;\\n                    right += word_len;\\n                    left = right;\\n                    continue;\\n                }\\n                \\n\\t\\t\\t\\t// If freq of curr word is less then required freq of that word we can add it to our usedWords and also increment the no of words that we have used in the current window\\n                if(usedWords[curr] < wordDict[curr])\\n                    usedWords[curr]++, words_used++;\\n\\t\\t\\t\\t// If the freq gets higher then we start removing words from the begining of window until the window becomes valid again\\n                else\\n                {\\n                    while(left < right)\\n                    {\\n                        auto to_remove = s.substr(left, word_len);\\n                        remove(usedWords, to_remove);\\n                        words_used--;\\n                        left += word_len;\\n                        if(usedWords[curr] < wordDict[curr])\\n                            break;\\n                    }\\n\\t\\t\\t\\t\\t// Now the window has becomes valid so we can add the curr word to the usedWords\\n                    usedWords[curr]++, words_used++;\\n                }\\n                right += word_len;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if the words of our current window get equal to the total words required the we can add the index of the starting of the window(left pointer) to our answer array and move the left pointer one step forward.\\n\\t\\t\\t\\t// We cant set the left pointer to point to right because we might have an answer starting from \\'left+word_len\\'. So we only increment it one step forward.\\n                if(words_used == total_words)\\n                {                    \\n                    ans.push_back(left);\\n                    auto to_remove = s.substr(left, word_len);\\n                    remove(usedWords, to_remove);\\n                    words_used--;\\n                    left += word_len;\\n                }\\n            \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n```\\nTC: O(n * word_len)\\nwhere n = length of string s\\nword_len = length of word[i] (max value = 30)\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n\\t// function to remove a word from usedWords hasmap\\n    void remove(unordered_map<string, int> &hashmap, string &key)\\n    {\\n        hashmap[key]--;\\n        if(hashmap[key] <= 0)\\n            hashmap.erase(key);\\n    }\\n    \\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> wordDict;\\n        unordered_map<string, int> usedWords;\\n        int word_len = words[0].length(), total_words = words.size();\\n        int left = 0, right = 0, n = s.length();\\n        int words_used = 0;\\n        vector<int> ans;\\n        \\n\\t\\t// wordDict contains all words with their frequencies\\n        for(auto &word: words)\\n            wordDict[word]++;\\n        \\n\\t\\t// We iterate staring from every index in range [0, word_len] to get every possible combination\\n        for(int i=0; i<word_len; i++)\\n        {\\n\\t\\t\\t// right pointer is used to expand the current window and \\n\\t\\t\\t// left pointer is used to shrink the current window whenever the window becomes invalid\\n            left = i, right = i;\\n            usedWords.clear();\\n            words_used = 0;\\n\\t\\t\\t\\n\\t\\t\\t// We start iterating till end of string\\n\\t\\t\\t// Once we pick a word of length \\'word_len\\' then we go to next index = \\'right + word_len\\'\\n            while(right < n)\\n            {\\n                auto curr = s.substr(right, min(n-right, word_len));\\n                \\n\\t\\t\\t\\t// If the curr picked word does not exist in the words array given to us then the current window is no longer usefull and so we discard all the words we have used untill now and increment our right and left pointer to point to the next word in sequence\\n                if(wordDict.find(curr) == wordDict.end())\\n                {\\n                    usedWords.clear();\\n                    words_used = 0;\\n                    right += word_len;\\n                    left = right;\\n                    continue;\\n                }\\n                \\n\\t\\t\\t\\t// If freq of curr word is less then required freq of that word we can add it to our usedWords and also increment the no of words that we have used in the current window\\n                if(usedWords[curr] < wordDict[curr])\\n                    usedWords[curr]++, words_used++;\\n\\t\\t\\t\\t// If the freq gets higher then we start removing words from the begining of window until the window becomes valid again\\n                else\\n                {\\n                    while(left < right)\\n                    {\\n                        auto to_remove = s.substr(left, word_len);\\n                        remove(usedWords, to_remove);\\n                        words_used--;\\n                        left += word_len;\\n                        if(usedWords[curr] < wordDict[curr])\\n                            break;\\n                    }\\n\\t\\t\\t\\t\\t// Now the window has becomes valid so we can add the curr word to the usedWords\\n                    usedWords[curr]++, words_used++;\\n                }\\n                right += word_len;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// if the words of our current window get equal to the total words required the we can add the index of the starting of the window(left pointer) to our answer array and move the left pointer one step forward.\\n\\t\\t\\t\\t// We cant set the left pointer to point to right because we might have an answer starting from \\'left+word_len\\'. So we only increment it one step forward.\\n                if(words_used == total_words)\\n                {                    \\n                    ans.push_back(left);\\n                    auto to_remove = s.substr(left, word_len);\\n                    remove(usedWords, to_remove);\\n                    words_used--;\\n                    left += word_len;\\n                }\\n            \\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nTC: O(n * word_len)\\nwhere n = length of string s\\nword_len = length of word[i] (max value = 30)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419138,
                "title": "c-using-sliding-window-approach-easy-solution",
                "content": "Approach\\n*  In this question we\\'ve to return all start index of substring in s that form is a concatenation of each word in words\\n*  We solve this question using Sliding window approach and Hashing\\n   for example:\\n   s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"];\\n   check \"bar\" is available in  words or not\\n*  We\\'ll stored frequency in freq map\\n*  Then we\\'ll run a from i=0 to s.size()-(m*n) because  \\n    s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]; \\n\\ti=10 then only 3 character left but we\\'ve to find 4 character so in this case we run our loop till s.size()-(m*n)\\n*  then create a temporary map that store frequency of words we\\'ll erase frequency to that word  when we got word\\n*   string substre=s.substr(i+m*j,m); This will give us string that we compare with map with if it is present then we\\'ll erase that word from map or it is not present then we\\'ll break the loop\\n*  if j==n it mean we find n character so we\\'ll push in res vector\\n\\n```\\nclass Solution \\n{\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n       vector<int> res;\\n        int n=words.size();\\n        int m=words[0].size();\\n        unordered_map<string,int> freq;\\n        for(auto i:words)\\n        {\\n            freq[i]++;\\n        }\\n        if(s.size()==0||s.size()<n*m)\\n        {\\n            return res;\\n        }\\n        for(int i=0;i<=s.size()-(m*n);i++)\\n        {\\n            unordered_map<string,int> ourfreq=freq;\\n            int j;\\n            for( j=0;j<n;j++)\\n            {\\n                \\n                string substre=s.substr(i+m*j,m);\\n                \\n                if(ourfreq[substre]==0)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    ourfreq[substre]--;\\n                }\\n                \\n            }\\n            cout<<endl;\\n            if(j==n)\\n            {\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    \\n        \\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "Hash Table",
                    "String",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n       vector<int> res;\\n        int n=words.size();\\n        int m=words[0].size();\\n        unordered_map<string,int> freq;\\n        for(auto i:words)\\n        {\\n            freq[i]++;\\n        }\\n        if(s.size()==0||s.size()<n*m)\\n        {\\n            return res;\\n        }\\n        for(int i=0;i<=s.size()-(m*n);i++)\\n        {\\n            unordered_map<string,int> ourfreq=freq;\\n            int j;\\n            for( j=0;j<n;j++)\\n            {\\n                \\n                string substre=s.substr(i+m*j,m);\\n                \\n                if(ourfreq[substre]==0)\\n                {\\n                    break;\\n                }\\n                else\\n                {\\n                    ourfreq[substre]--;\\n                }\\n                \\n            }\\n            cout<<endl;\\n            if(j==n)\\n            {\\n                res.push_back(i);\\n            }\\n        }\\n        return res;\\n    \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2418534,
                "title": "6-ms-faster-than-97-hashmap-sliding-window-golang",
                "content": "I\\'m a new user of Golang, so if there any part where it can be improved, please let me know ^^.\\n\\n- The main idea is that, if we put each string in ```words``` into the hashmap ```cnt```, we would get some kind of frequency table. Thus, a range that satisfy the statement condition, must have the frequency of each word match our frequency table ```cnt``` right?\\n- Now, applying sliding window, we will slide a window through ```s```.\\n- Since each word in ```words``` has the same length (the problem will be a lot more difficult if they are of different length), we can slide the window through that length, and remove the rightmost string from ```cnt``` (remember if the leftmost string go out of the window, add that string to the ```cnt``` again). \\n- If at a point, every key in ```cnt``` has the value 0, that means the current window satisfy the statement condition. Thus we can simply add the current window into ```ans```.\\n- One small problem, we might need to offset our range from ```0``` to ```len(words[0])```, since otherwise, we might miss some ranges from our answer.\\n- The rest is just implementation detail\\n```\\nfunc findSubstring(s string, words []string) []int {\\n    ans := make([]int, 0) // Initialize the answer as a slice\\n    cnt, dif := make(map[string]int), 0 // Create the hashmap, also count the different elements in words\\n        for _, curString := range words {\\n            cnt[curString]++;\\n            if cnt[curString] == 1 {\\n                dif++\\n            }\\n        }\\n    sz, totSz := len(words[0]), len(words[0]) * len(words) // Initialize some length for sliding window\\n    for st := 0; st < sz; st++ { // Offset\\n        for k := range cnt { // Reset the map\\n            delete(cnt, k)\\n        }\\n        for _, curString := range words {\\n            cnt[curString]++;\\n        }        \\n        \\n        cntOk := 0 // Number of key in cnt has the value 0\\n        for i := st; i + sz - 1 < len(s); i += sz {\\n            if i >= totSz { // Remove the left part\\n                cur := s[i-totSz:i-totSz+sz]\\n                if _, ok := cnt[cur]; ok {\\n                    cnt[cur]++\\n                    if cnt[cur] == 1 {\\n                        cntOk--\\n                    }\\n                }\\n            }\\n            cur := s[i:i+sz]; // Insert the right part\\n            if _, ok := cnt[cur]; ok {\\n                cnt[cur]--\\n                if cnt[cur] == 0 {\\n                    cntOk++\\n                }\\n            }\\n            if cntOk == dif { // If everything is good\\n                ans = append(ans, i - totSz + sz) // Then add the current range into the answer\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```words```\n```cnt```\n```cnt```\n```s```\n```words```\n```cnt```\n```cnt```\n```cnt```\n```ans```\n```0```\n```len(words[0])```\n```\\nfunc findSubstring(s string, words []string) []int {\\n    ans := make([]int, 0) // Initialize the answer as a slice\\n    cnt, dif := make(map[string]int), 0 // Create the hashmap, also count the different elements in words\\n        for _, curString := range words {\\n            cnt[curString]++;\\n            if cnt[curString] == 1 {\\n                dif++\\n            }\\n        }\\n    sz, totSz := len(words[0]), len(words[0]) * len(words) // Initialize some length for sliding window\\n    for st := 0; st < sz; st++ { // Offset\\n        for k := range cnt { // Reset the map\\n            delete(cnt, k)\\n        }\\n        for _, curString := range words {\\n            cnt[curString]++;\\n        }        \\n        \\n        cntOk := 0 // Number of key in cnt has the value 0\\n        for i := st; i + sz - 1 < len(s); i += sz {\\n            if i >= totSz { // Remove the left part\\n                cur := s[i-totSz:i-totSz+sz]\\n                if _, ok := cnt[cur]; ok {\\n                    cnt[cur]++\\n                    if cnt[cur] == 1 {\\n                        cntOk--\\n                    }\\n                }\\n            }\\n            cur := s[i:i+sz]; // Insert the right part\\n            if _, ok := cnt[cur]; ok {\\n                cnt[cur]--\\n                if cnt[cur] == 0 {\\n                    cntOk++\\n                }\\n            }\\n            if cntOk == dif { // If everything is good\\n                ans = append(ans, i - totSz + sz) // Then add the current range into the answer\\n            }\\n        }\\n    }\\n    return ans\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2418153,
                "title": "python-fastest-solution-explained",
                "content": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        # remove empty cases\\n        if not s or words==[]:\\n            return []  \\n        len_str=len(s)\\n        len_word=len(words[0])\\n        len_substr=len(words)*len_word\\n\\n        # creating dict of the number of appearance that should be in s for each word\\n        appearance={}\\n        for word in words:\\n            if word in appearance:\\n                appearance[word]+=1\\n            else:\\n                appearance[word]=1\\n\\n        ans=[]\\n        for str_start in range(min(len_word,len_str-len_substr+1)):\\n            ans += self.findAnswer(str_start,len_word,len_substr,s,appearance)\\n        return ans\\n\\n\\n    def findAnswer(self,str_start,len_word,len_substr,s,appearance):\\n        word_start=str_start\\n        curr_appearance={}\\n        res = []\\n\\n        while str_start + len_substr <= len(s):\\n            word = s[word_start:word_start+len_word]\\n            word_start += len_word\\n            # if we encountered word that is not in words, start checking again\\n            if word not in appearance:\\n                str_start=word_start\\n                curr_appearance.clear()\\n\\n            else:\\n                # add the word to the current appearance\\n                if word in curr_appearance:\\n                    curr_appearance[word]+=1\\n                else:\\n                    curr_appearance[word]=1\\n\\n                # as long as this word appears in our counting more than it should, \\n                # update the substring to be one less word, until we reach to\\n                # this word (sub 1 from the count of the first word count again)\\n                while curr_appearance[word] > appearance[word]:\\n                    curr_appearance[s[str_start:str_start+len_word]]-=1\\n                    str_start += len_word\\n\\n                # if we handled the last word missing in substring- we found res!\\n                if word_start-str_start==len_substr:\\n                    res.append(str_start)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        # remove empty cases\\n        if not s or words==[]:\\n            return []  \\n        len_str=len(s)\\n        len_word=len(words[0])\\n        len_substr=len(words)*len_word\\n\\n        # creating dict of the number of appearance that should be in s for each word\\n        appearance={}\\n        for word in words:\\n            if word in appearance:\\n                appearance[word]+=1\\n            else:\\n                appearance[word]=1\\n\\n        ans=[]\\n        for str_start in range(min(len_word,len_str-len_substr+1)):\\n            ans += self.findAnswer(str_start,len_word,len_substr,s,appearance)\\n        return ans\\n\\n\\n    def findAnswer(self,str_start,len_word,len_substr,s,appearance):\\n        word_start=str_start\\n        curr_appearance={}\\n        res = []\\n\\n        while str_start + len_substr <= len(s):\\n            word = s[word_start:word_start+len_word]\\n            word_start += len_word\\n            # if we encountered word that is not in words, start checking again\\n            if word not in appearance:\\n                str_start=word_start\\n                curr_appearance.clear()\\n\\n            else:\\n                # add the word to the current appearance\\n                if word in curr_appearance:\\n                    curr_appearance[word]+=1\\n                else:\\n                    curr_appearance[word]=1\\n\\n                # as long as this word appears in our counting more than it should, \\n                # update the substring to be one less word, until we reach to\\n                # this word (sub 1 from the count of the first word count again)\\n                while curr_appearance[word] > appearance[word]:\\n                    curr_appearance[s[str_start:str_start+len_word]]-=1\\n                    str_start += len_word\\n\\n                # if we handled the last word missing in substring- we found res!\\n                if word_start-str_start==len_substr:\\n                    res.append(str_start)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418146,
                "title": "c-short-simple-code",
                "content": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n\\tvector<int> findSubstring(string s, vector<string>& words) \\n    {\\n        vector<int> res;\\n        int n=words.size();\\n        int m=words[0].size(); // each word has the same length;\\n        int t = m*n;           // total letters in words vector \\n        \\n        if(s.size() < t) return res;\\n        \\n        unordered_map<string, int> freq;\\n            \\n        for(auto it:words)\\n            freq[it]++;     // update frequency of each word\\n        \\n        for(int i=0; i<=s.size()-t; i++)\\n        {\\n            unordered_map<string, int> mp = freq;  // new map equivalent to freq map\\n            \\n            int j;\\n            for(j=0; j<s.size(); j++)\\n            {\\n                string temp = s.substr(i+j*m, m); //create string of size m and starting index i+j*m\\n                \\n                if(mp[temp]==0)\\n                    break;\\n                else\\n                    mp[temp]--;\\n            }\\n            if(j==n) //check whether all word in words are in the string or not \\n                res.push_back(i);\\n            \\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "***DO UPVOTE IF IT HELPS !!!!!***\\n\\t\\n\\tvector<int> findSubstring(string s, vector<string>& words) \\n    {\\n        vector<int> res;\\n        int n=words.size();\\n        int m=words[0].size(); // each word has the same length;\\n        int t = m*n;           // total letters in words vector \\n        \\n        if(s.size() < t) return res;\\n        \\n        unordered_map<string, int> freq;\\n            \\n        for(auto it:words)\\n            freq[it]++;     // update frequency of each word\\n        \\n        for(int i=0; i<=s.size()-t; i++)\\n        {\\n            unordered_map<string, int> mp = freq;  // new map equivalent to freq map\\n            \\n            int j;\\n            for(j=0; j<s.size(); j++)\\n            {\\n                string temp = s.substr(i+j*m, m); //create string of size m and starting index i+j*m\\n                \\n                if(mp[temp]==0)\\n                    break;\\n                else\\n                    mp[temp]--;\\n            }\\n            if(j==n) //check whether all word in words are in the string or not \\n                res.push_back(i);\\n            \\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2418055,
                "title": "explained-with-comments-c",
                "content": "To get a valid substring , the size of the window has to be words.size()* words[0].size() .So we will check for every window of this size .\\n```\\nclass Solution {\\npublic:\\n    bool isPossible(string &s,int i,int j , unordered_map<string,int> &hm,int len){\\n        \\n        unordered_map<string,int> freq;   // map frequency of each word occuring in this window \\n        int k = i;\\n        while(k<j-len+2){\\n           string str = s.substr(k,len);\\n            freq[str]++;\\n            k+=len;\\n        }\\n        \\n        for(auto i : freq){\\n            if(i.second != hm[i.first])return false;   // if frequency of any word differs from the frequency we want ( stored in hm) return false\\n        }\\n        \\n  \\n        return true;\\n        \\n    }\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n    \\n        \\n       unordered_map<string,int> hm;\\n        for(int k = 0;k<words.size();k++){  // store frequency of words \\n            hm[words[k]]++;\\n        }\\n        \\n      int windowSize = words.size()*(words[0].size());  // take window size such that it cover each word\\n       int i =0,j = windowSize-1;\\n        \\n        vector<int> ans;    // ans vector  \\n        \\n        while(j<s.size()){    // apply sliding window \\n            \\n         if(isPossible(s,i,j,hm,words[0].size()))ans.push_back(i);  // if the window contains all words (see function above)  push the index in ans  \\n            i++;\\n            j++;  \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isPossible(string &s,int i,int j , unordered_map<string,int> &hm,int len){\\n        \\n        unordered_map<string,int> freq;   // map frequency of each word occuring in this window \\n        int k = i;\\n        while(k<j-len+2){\\n           string str = s.substr(k,len);\\n            freq[str]++;\\n            k+=len;\\n        }\\n        \\n        for(auto i : freq){\\n            if(i.second != hm[i.first])return false;   // if frequency of any word differs from the frequency we want ( stored in hm) return false\\n        }\\n        \\n  \\n        return true;\\n        \\n    }\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n    \\n        \\n       unordered_map<string,int> hm;\\n        for(int k = 0;k<words.size();k++){  // store frequency of words \\n            hm[words[k]]++;\\n        }\\n        \\n      int windowSize = words.size()*(words[0].size());  // take window size such that it cover each word\\n       int i =0,j = windowSize-1;\\n        \\n        vector<int> ans;    // ans vector  \\n        \\n        while(j<s.size()){    // apply sliding window \\n            \\n         if(isPossible(s,i,j,hm,words[0].size()))ans.push_back(i);  // if the window contains all words (see function above)  push the index in ans  \\n            i++;\\n            j++;  \\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417593,
                "title": "python",
                "content": "```python\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wslen, wlen = len(words), len(words[0])\\n        words, res = Counter(words), []\\n        for i in range(0, len(s) - wslen*wlen + 1):\\n            hmap = words.copy()\\n            for j in range(i, i + wslen*wlen, wlen):\\n                if not hmap[s[j:j + wlen]]:\\n                    break\\n                hmap[s[j:j + wlen]] -= 1\\n            if not any(hmap.values()):\\n                res.append(i)\\n        return res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```python\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wslen, wlen = len(words), len(words[0])\\n        words, res = Counter(words), []\\n        for i in range(0, len(s) - wslen*wlen + 1):\\n            hmap = words.copy()\\n            for j in range(i, i + wslen*wlen, wlen):\\n                if not hmap[s[j:j + wlen]]:\\n                    break\\n                hmap[s[j:j + wlen]] -= 1\\n            if not any(hmap.values()):\\n                res.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417571,
                "title": "c-hashmaps-and-stuff",
                "content": "let wordCharacters = the number of characters in words\\nlet n = the length of s\\n\\ncheck every index up until n - wordCharacters + 1  to see if it is a potential answer.\\n\\n**Tune in LIVE ON TWITCH to watch the solution happen in real time.  Everyday 6pm PT.  Link in profile**\\n\\n\\n\\n```\\nclass Solution {   \\n    bool checkIt(string& s, unordered_map<string,int>& ogMap, int start, int size, int checkSize) {\\n        int i = start;\\n        int n = s.length();\\n        unordered_map<string, int> winMap;\\n        while(i < n) {\\n            string right = s.substr(i, size);\\n            if(ogMap.find(right) == ogMap.end()) return false;\\n            else {\\n                winMap[right]++;\\n                if(winMap[right] > ogMap[right]) return false;\\n                if(winMap == ogMap) return true;\\n                i += size;\\n            }\\n        }\\n        return false;\\n    }\\n    \\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> ans;\\n        int size = words[0].size();\\n        int checkSize = words.size();\\n        int superLen = size*checkSize;\\n        unordered_map<string, int> ogMap;\\n        for(auto& word : words) {\\n            ogMap[word]++;\\n        }\\n        \\n        int n = s.length();\\n        for(int i = 0; i < n - superLen + 1; i++) {\\n            if(checkIt(s, ogMap, i, size, checkSize)) {\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {   \\n    bool checkIt(string& s, unordered_map<string,int>& ogMap, int start, int size, int checkSize) {\\n        int i = start;\\n        int n = s.length();\\n        unordered_map<string, int> winMap;\\n        while(i < n) {\\n            string right = s.substr(i, size);\\n            if(ogMap.find(right) == ogMap.end()) return false;\\n            else {\\n                winMap[right]++;\\n                if(winMap[right] > ogMap[right]) return false;\\n                if(winMap == ogMap) return true;\\n                i += size;\\n            }\\n        }\\n        return false;\\n    }\\n    \\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> ans;\\n        int size = words[0].size();\\n        int checkSize = words.size();\\n        int superLen = size*checkSize;\\n        unordered_map<string, int> ogMap;\\n        for(auto& word : words) {\\n            ogMap[word]++;\\n        }\\n        \\n        int n = s.length();\\n        for(int i = 0; i < n - superLen + 1; i++) {\\n            if(checkIt(s, ogMap, i, size, checkSize)) {\\n                ans.push_back(i);\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417563,
                "title": "java-100-faster-code-with-explanation",
                "content": "\\tPLEASE UPVOTE IF YOU LIKE\\n```\\nclass Solution {\\n   public List<Integer> findSubstring(String s, String[] words) {\\n\\t\\t/**\\n\\t\\t * Let n=s.length, k=words[0].length traverse s with indices i, i+k,\\n\\t\\t * i+2k, ... for 0<=i<k, so that the time complexity is O(n).\\n\\t\\t */\\n\\t\\tList<Integer> res = new ArrayList<Integer>();\\n\\t\\tint n = s.length(), m = words.length, k;\\n\\t\\tif (n == 0 || m == 0 || (k = words[0].length()) == 0)\\n\\t\\t\\treturn res;\\n\\n\\t\\tHashMap<String, Integer> wDict = new HashMap<String, Integer>();\\n\\n\\t\\tfor (String word : words) {\\n\\t\\t\\tif (wDict.containsKey(word))\\n\\t\\t\\t\\twDict.put(word, wDict.get(word) + 1);\\n\\t\\t\\telse\\n\\t\\t\\t\\twDict.put(word, 1);\\n\\t\\t}\\n\\n\\t\\tint i, j, start, x, wordsLen = m * k;\\n\\t\\tHashMap<String, Integer> curDict = new HashMap<String, Integer>();\\n\\t\\tString test, temp;\\n\\t\\tfor (i = 0; i < k; i++) {\\n\\t\\t\\tcurDict.clear();\\n\\t\\t\\tstart = i;\\n\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\tfor (j = i; j + k <= n; j += k) {\\n\\t\\t\\t\\ttest = s.substring(j, j + k);\\n\\n\\t\\t\\t\\tif (wDict.containsKey(test)) {\\n\\t\\t\\t\\t\\tif (!curDict.containsKey(test)) {\\n\\t\\t\\t\\t\\t\\tcurDict.put(test, 1);\\n\\n\\t\\t\\t\\t\\t\\tstart = checkFound(res, start, wordsLen, j, k, curDict, s);\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// curDict.containsKey(test)\\n\\t\\t\\t\\t\\tx = curDict.get(test);\\n\\t\\t\\t\\t\\tif (x < wDict.get(test)) {\\n\\t\\t\\t\\t\\t\\tcurDict.put(test, x + 1);\\n\\n\\t\\t\\t\\t\\t\\tstart = checkFound(res, start, wordsLen, j, k, curDict, s);\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// curDict.get(test)==wDict.get(test), slide start to\\n\\t\\t\\t\\t\\t// the next word of the first same word as test\\n\\t\\t\\t\\t\\twhile (!(temp = s.substring(start, start + k)).equals(test)) {\\n\\t\\t\\t\\t\\t\\tdecreaseCount(curDict, temp);\\n\\t\\t\\t\\t\\t\\tstart += k;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tstart += k;\\n\\t\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// totally failed up to index j+k, slide start and reset all\\n\\t\\t\\t\\tstart = j + k;\\n\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcurDict.clear();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n\\tpublic int checkFound(List<Integer> res, int start, int wordsLen, int j, int k,\\n\\t\\t\\tHashMap<String, Integer> curDict, String s) {\\n\\t\\tif (start + wordsLen == j + k) {\\n\\t\\t\\tres.add(start);\\n\\t\\t\\t// slide start to the next word\\n\\t\\t\\tdecreaseCount(curDict, s.substring(start, start + k));\\n\\t\\t\\treturn start + k;\\n\\t\\t}\\n\\t\\treturn start;\\n\\t}\\n\\n\\tpublic void decreaseCount(HashMap<String, Integer> curDict, String key) {\\n\\t\\t// remove key if curDict.get(key)==1, otherwise decrease it by 1\\n\\t\\tint x = curDict.get(key);\\n\\t\\tif (x == 1)\\n\\t\\t\\tcurDict.remove(key);\\n\\t\\telse\\n\\t\\t\\tcurDict.put(key, x - 1);\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n   public List<Integer> findSubstring(String s, String[] words) {\\n\\t\\t/**\\n\\t\\t * Let n=s.length, k=words[0].length traverse s with indices i, i+k,\\n\\t\\t * i+2k, ... for 0<=i<k, so that the time complexity is O(n).\\n\\t\\t */\\n\\t\\tList<Integer> res = new ArrayList<Integer>();\\n\\t\\tint n = s.length(), m = words.length, k;\\n\\t\\tif (n == 0 || m == 0 || (k = words[0].length()) == 0)\\n\\t\\t\\treturn res;\\n\\n\\t\\tHashMap<String, Integer> wDict = new HashMap<String, Integer>();\\n\\n\\t\\tfor (String word : words) {\\n\\t\\t\\tif (wDict.containsKey(word))\\n\\t\\t\\t\\twDict.put(word, wDict.get(word) + 1);\\n\\t\\t\\telse\\n\\t\\t\\t\\twDict.put(word, 1);\\n\\t\\t}\\n\\n\\t\\tint i, j, start, x, wordsLen = m * k;\\n\\t\\tHashMap<String, Integer> curDict = new HashMap<String, Integer>();\\n\\t\\tString test, temp;\\n\\t\\tfor (i = 0; i < k; i++) {\\n\\t\\t\\tcurDict.clear();\\n\\t\\t\\tstart = i;\\n\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\treturn res;\\n\\t\\t\\tfor (j = i; j + k <= n; j += k) {\\n\\t\\t\\t\\ttest = s.substring(j, j + k);\\n\\n\\t\\t\\t\\tif (wDict.containsKey(test)) {\\n\\t\\t\\t\\t\\tif (!curDict.containsKey(test)) {\\n\\t\\t\\t\\t\\t\\tcurDict.put(test, 1);\\n\\n\\t\\t\\t\\t\\t\\tstart = checkFound(res, start, wordsLen, j, k, curDict, s);\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// curDict.containsKey(test)\\n\\t\\t\\t\\t\\tx = curDict.get(test);\\n\\t\\t\\t\\t\\tif (x < wDict.get(test)) {\\n\\t\\t\\t\\t\\t\\tcurDict.put(test, x + 1);\\n\\n\\t\\t\\t\\t\\t\\tstart = checkFound(res, start, wordsLen, j, k, curDict, s);\\n\\t\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t\\t// curDict.get(test)==wDict.get(test), slide start to\\n\\t\\t\\t\\t\\t// the next word of the first same word as test\\n\\t\\t\\t\\t\\twhile (!(temp = s.substring(start, start + k)).equals(test)) {\\n\\t\\t\\t\\t\\t\\tdecreaseCount(curDict, temp);\\n\\t\\t\\t\\t\\t\\tstart += k;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tstart += k;\\n\\t\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\t// totally failed up to index j+k, slide start and reset all\\n\\t\\t\\t\\tstart = j + k;\\n\\t\\t\\t\\tif (start + wordsLen > n)\\n\\t\\t\\t\\t\\tbreak;\\n\\t\\t\\t\\tcurDict.clear();\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n\\tpublic int checkFound(List<Integer> res, int start, int wordsLen, int j, int k,\\n\\t\\t\\tHashMap<String, Integer> curDict, String s) {\\n\\t\\tif (start + wordsLen == j + k) {\\n\\t\\t\\tres.add(start);\\n\\t\\t\\t// slide start to the next word\\n\\t\\t\\tdecreaseCount(curDict, s.substring(start, start + k));\\n\\t\\t\\treturn start + k;\\n\\t\\t}\\n\\t\\treturn start;\\n\\t}\\n\\n\\tpublic void decreaseCount(HashMap<String, Integer> curDict, String key) {\\n\\t\\t// remove key if curDict.get(key)==1, otherwise decrease it by 1\\n\\t\\tint x = curDict.get(key);\\n\\t\\tif (x == 1)\\n\\t\\t\\tcurDict.remove(key);\\n\\t\\telse\\n\\t\\t\\tcurDict.put(key, x - 1);\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2417525,
                "title": "python-counters-with-lookback",
                "content": "**Solution**:\\nIterate through s and check every possible substrings. For each substring, count all words and their counts. If the counter of the substring is equal to the counter of words, add the starting index to to the resulting list.     \\n\\nWe can optimize the counter calculation by performing some lookback. A counter at some arbitrary i is the counter at i-w removed the first word of i-w and added the last word of i where w is the length of each word. \\n\\n```\\n   ie: words = 1,2,3,4,5 and numWord = 3\\n   counter(0) = [1,2,3]\\n   counter(1) = [2,3,4]\\n   counter(3) = [3,4,5]\\n  ```\\n\\nHowever, since each counter represents words of size w, we have to maintain at most w counters to account for all possible starting characters.\\n\\n```\\n   Ex: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\\n    i   substring   counterNum  counter                 result\\n    0   barfoo      0           {\\'bar\\': 1, \\'foo\\': 1}    [0]\\n    1   arfoot      1           {\\'arf\\': 1, \\'oot\\': 1}    [0]\\n    2   rfooth      2           {\\'rfo\\': 1, \\'oth\\': 1}    [0]\\n    3   foothe      0           {\\'foo\\': 1, \\'the\\': 1}    [0]\\n    4   oothef      1           {\\'oot\\': 1, \\'hef\\': 1}    [0]\\n    5   othefo      2           {\\'oth\\': 1, \\'efo\\': 1}    [0]\\n    6   thefoo      0           {\\'the\\': 1, \\'foo\\': 1}    [0]\\n    7   hefoob      1           {\\'hef\\': 1, \\'oob\\': 1}    [0]\\n    8   efooba      2           {\\'efo\\': 1, \\'oba\\': 1}    [0]\\n    9   foobar      0           {\\'foo\\': 1, \\'bar\\': 1}    [0,9]\\n    10  oobarm      1           {\\'oob\\': 1, \\'arm\\': 1}    [0,9]\\n    11  obarma      2           {\\'oba\\': 1, \\'rma\\': 1}    [0,9]\\n    12  barman      0           {\\'bar\\': 1, \\'man\\': 1}    [0,9]\\n```\\n\\nSpecial thank to this [post](https://leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/1753357/Clear-solution!-Easy-to-understand-with-diagrams%5C) for the counter lookback.\\n\\n**Complexity**:\\n    Time: O(mn) where m is the length of s and n is the length of words\\n    Space: O(nw) where n is the length of words and w is the length of each word\\n\\n```\\nfrom collections import Counter, defaultdict\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: list[str]) -> list[int]:\\n\\n\\t# Find the length of s, words, and each word\\n\\tm, n, w = len(s), len(words), len(words[0])\\n\\n\\t# Count words\\n\\twords = Counter(words)\\n\\n\\t# Cache to store previously calculated counter\\n\\tcache = {}\\n\\n\\t# Count words in a substring\\n\\tdef counts(i):\\n\\n\\t\\t# Initialize the counter\\n\\t\\tcounter = defaultdict(int) if 0 <= i < w else cache[i % w]\\n\\n\\t\\t# Calcualte the start and end of the current substring\\n\\t\\tstart, end = i, i + n * w\\n\\n\\t\\t# We have to do a full counter calculation for the first w characters\\n\\t\\tif 0 <= i < w:\\n\\t\\t\\tfor j in range(start, end, w):\\n\\t\\t\\t\\tcounter[s[j : j + w]] += 1\\n\\n\\t\\t# Else, we can reused i-w counter\\n\\t\\telse:\\n\\n\\t\\t\\t# Remove the first word of i-w substring from the counter\\n\\n\\t\\t\\t# First word of i-w substring\\n\\t\\t\\tfirstWordPrevCounter = s[start - w : start]\\n\\n\\t\\t\\t# Remove the first word of the i-w substring from the counter\\n\\t\\t\\tcounter[firstWordPrevCounter] -= 1\\n\\n\\t\\t\\t# Remove the word if its count is 0\\n\\t\\t\\tif counter[firstWordPrevCounter] == 0:\\n\\t\\t\\t\\tcounter.pop(firstWordPrevCounter)\\n\\n\\t\\t\\t# Add the last word of i substring\\n\\n\\t\\t\\t# Lastword of i substring\\n\\t\\t\\tlastWord = s[end - w : end]\\n\\n\\t\\t\\t# Add such word to the counter\\n\\t\\t\\tcounter[lastWord] += 1\\n\\n\\t\\t# Save the counter to cache\\n\\t\\tcache[i % w] = counter\\n\\n\\t\\t# Return the counter\\n\\t\\treturn cache[i % w]\\n\\n\\t# Initialize the result\\n\\tres = []\\n\\n\\t# Iterate through all possible substrings\\n\\tfor i in range(0, m - n * w + 1):\\n\\n\\t\\t# If counters of substring and words are equal, add the starting index to the result\\n\\t\\tif counts(i) == words:\\n\\t\\t\\tres.append(i)\\n\\n\\treturn res\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n   ie: words = 1,2,3,4,5 and numWord = 3\\n   counter(0) = [1,2,3]\\n   counter(1) = [2,3,4]\\n   counter(3) = [3,4,5]\\n  ```\n```\\n   Ex: s = \"barfoothefoobarman\", words = [\"foo\",\"bar\"]\\n    i   substring   counterNum  counter                 result\\n    0   barfoo      0           {\\'bar\\': 1, \\'foo\\': 1}    [0]\\n    1   arfoot      1           {\\'arf\\': 1, \\'oot\\': 1}    [0]\\n    2   rfooth      2           {\\'rfo\\': 1, \\'oth\\': 1}    [0]\\n    3   foothe      0           {\\'foo\\': 1, \\'the\\': 1}    [0]\\n    4   oothef      1           {\\'oot\\': 1, \\'hef\\': 1}    [0]\\n    5   othefo      2           {\\'oth\\': 1, \\'efo\\': 1}    [0]\\n    6   thefoo      0           {\\'the\\': 1, \\'foo\\': 1}    [0]\\n    7   hefoob      1           {\\'hef\\': 1, \\'oob\\': 1}    [0]\\n    8   efooba      2           {\\'efo\\': 1, \\'oba\\': 1}    [0]\\n    9   foobar      0           {\\'foo\\': 1, \\'bar\\': 1}    [0,9]\\n    10  oobarm      1           {\\'oob\\': 1, \\'arm\\': 1}    [0,9]\\n    11  obarma      2           {\\'oba\\': 1, \\'rma\\': 1}    [0,9]\\n    12  barman      0           {\\'bar\\': 1, \\'man\\': 1}    [0,9]\\n```\n```\\nfrom collections import Counter, defaultdict\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: list[str]) -> list[int]:\\n\\n\\t# Find the length of s, words, and each word\\n\\tm, n, w = len(s), len(words), len(words[0])\\n\\n\\t# Count words\\n\\twords = Counter(words)\\n\\n\\t# Cache to store previously calculated counter\\n\\tcache = {}\\n\\n\\t# Count words in a substring\\n\\tdef counts(i):\\n\\n\\t\\t# Initialize the counter\\n\\t\\tcounter = defaultdict(int) if 0 <= i < w else cache[i % w]\\n\\n\\t\\t# Calcualte the start and end of the current substring\\n\\t\\tstart, end = i, i + n * w\\n\\n\\t\\t# We have to do a full counter calculation for the first w characters\\n\\t\\tif 0 <= i < w:\\n\\t\\t\\tfor j in range(start, end, w):\\n\\t\\t\\t\\tcounter[s[j : j + w]] += 1\\n\\n\\t\\t# Else, we can reused i-w counter\\n\\t\\telse:\\n\\n\\t\\t\\t# Remove the first word of i-w substring from the counter\\n\\n\\t\\t\\t# First word of i-w substring\\n\\t\\t\\tfirstWordPrevCounter = s[start - w : start]\\n\\n\\t\\t\\t# Remove the first word of the i-w substring from the counter\\n\\t\\t\\tcounter[firstWordPrevCounter] -= 1\\n\\n\\t\\t\\t# Remove the word if its count is 0\\n\\t\\t\\tif counter[firstWordPrevCounter] == 0:\\n\\t\\t\\t\\tcounter.pop(firstWordPrevCounter)\\n\\n\\t\\t\\t# Add the last word of i substring\\n\\n\\t\\t\\t# Lastword of i substring\\n\\t\\t\\tlastWord = s[end - w : end]\\n\\n\\t\\t\\t# Add such word to the counter\\n\\t\\t\\tcounter[lastWord] += 1\\n\\n\\t\\t# Save the counter to cache\\n\\t\\tcache[i % w] = counter\\n\\n\\t\\t# Return the counter\\n\\t\\treturn cache[i % w]\\n\\n\\t# Initialize the result\\n\\tres = []\\n\\n\\t# Iterate through all possible substrings\\n\\tfor i in range(0, m - n * w + 1):\\n\\n\\t\\t# If counters of substring and words are equal, add the starting index to the result\\n\\t\\tif counts(i) == words:\\n\\t\\t\\tres.append(i)\\n\\n\\treturn res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2352807,
                "title": "python-my-soln-sliding-window",
                "content": "class Solution:\\n\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        word_len = len(words[0])\\n        counter = Counter(words)\\n        window_size = len(words) * word_len\\n        ans = []\\n        for i in range(len(s) - window_size + 1):\\n            temp = s[i:i+window_size]\\n            \\n            lst = []\\n            while temp:\\n                lst.append(temp[:word_len])\\n                temp = temp[word_len:]\\n           \\n            if Counter(lst) == counter:\\n                ans.append(i)\\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "class Solution:\\n\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        word_len = len(words[0])\\n        counter = Counter(words)\\n        window_size = len(words) * word_len\\n        ans = []\\n        for i in range(len(s) - window_size + 1):\\n            temp = s[i:i+window_size]\\n            \\n            lst = []\\n            while temp:\\n                lst.append(temp[:word_len])\\n                temp = temp[word_len:]\\n           \\n            if Counter(lst) == counter:\\n                ans.append(i)\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 1622909,
                "title": "easy-solution-using-map-in-js",
                "content": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar findSubstring = function(s, words) {\\n   let m2 = new Map()\\n for(let i = 0; i< words.length; i++){\\n     m2.set(words[i] , (m2.get(words[i]) || 0 ) + 1)\\n }\\n    let ans= []\\n    let m1  = new Map()\\n let len =  words.length  * words[0].length\\nfor(let i = 0  ; i< s.length-len+1; i++){\\n let curr = s.substring(i, i+len)\\n     if(check(curr, m2, words[0].length)) ans.push(i)\\n}\\nreturn ans\\n}\\n    function check(curr, m2, length){\\n        let m1 =  new Map()\\n        for(let i = 0; i< curr.length; i+=length){\\n            let sub = curr.substring(i, i+length)\\n            m1.set(sub, (m1.get(sub)|| 0 ) +1 )\\n        }\\n          for(let [key, val] of  m2){\\n            if(m1.get(key) !== m2.get(key)) return false\\n        }\\n        return true\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {string[]} words\\n * @return {number[]}\\n */\\nvar findSubstring = function(s, words) {\\n   let m2 = new Map()\\n for(let i = 0; i< words.length; i++){\\n     m2.set(words[i] , (m2.get(words[i]) || 0 ) + 1)\\n }\\n    let ans= []\\n    let m1  = new Map()\\n let len =  words.length  * words[0].length\\nfor(let i = 0  ; i< s.length-len+1; i++){\\n let curr = s.substring(i, i+len)\\n     if(check(curr, m2, words[0].length)) ans.push(i)\\n}\\nreturn ans\\n}\\n    function check(curr, m2, length){\\n        let m1 =  new Map()\\n        for(let i = 0; i< curr.length; i+=length){\\n            let sub = curr.substring(i, i+length)\\n            m1.set(sub, (m1.get(sub)|| 0 ) +1 )\\n        }\\n          for(let [key, val] of  m2){\\n            if(m1.get(key) !== m2.get(key)) return false\\n        }\\n        return true\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1483223,
                "title": "c-sliding-window-logic-explained",
                "content": "```\\nvector<int> findSubstring(string s, vector<string>& a) {\\n        int wordLen = a[0].size(), windowSize = wordLen * a.size(); \\n        vector<int> res;\\n        if(windowSize > s.size()) return res;\\n        unordered_map<string, int> original;        \\n        for(auto &g:a) original[g]++;\\n\\t\\t\\n        //The task of this for loop is to move the window, 1 index at a time.\\n        for(int i=0; i<=s.size()-windowSize; i++){\\n            unordered_map<string, int> m;\\n            \\n            //The task of this for loop is to check whether all words of vector a are present in window are not.\\n            for(int windowIndex=i; windowIndex < i+windowSize; windowIndex+=wordLen){\\n                string curWord = s.substr(windowIndex, wordLen);\\n\\t\\t\\t\\t\\n                //If current word of window doesn\\'t exist in map -> break. Break from 2nd for loop, i.e. window will now move further to next index due to first for loop.\\n                if(original.find(curWord) == original.end()) break;\\n                \\n                m[curWord]++;\\n                \\n                //This for loop saves extra iterations if window contains extra duplicates than required\\n                if(m[curWord] > original[curWord]) break;\\n                \\n            }\\n            \\n            //Now after exiting window check whether both the maps are identical, if they are we have a result.\\n            if(m == original) res.push_back(i);\\n            \\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nvector<int> findSubstring(string s, vector<string>& a) {\\n        int wordLen = a[0].size(), windowSize = wordLen * a.size(); \\n        vector<int> res;\\n        if(windowSize > s.size()) return res;\\n        unordered_map<string, int> original;        \\n        for(auto &g:a) original[g]++;\\n\\t\\t\\n        //The task of this for loop is to move the window, 1 index at a time.\\n        for(int i=0; i<=s.size()-windowSize; i++){\\n            unordered_map<string, int> m;\\n            \\n            //The task of this for loop is to check whether all words of vector a are present in window are not.\\n            for(int windowIndex=i; windowIndex < i+windowSize; windowIndex+=wordLen){\\n                string curWord = s.substr(windowIndex, wordLen);\\n\\t\\t\\t\\t\\n                //If current word of window doesn\\'t exist in map -> break. Break from 2nd for loop, i.e. window will now move further to next index due to first for loop.\\n                if(original.find(curWord) == original.end()) break;\\n                \\n                m[curWord]++;\\n                \\n                //This for loop saves extra iterations if window contains extra duplicates than required\\n                if(m[curWord] > original[curWord]) break;\\n                \\n            }\\n            \\n            //Now after exiting window check whether both the maps are identical, if they are we have a result.\\n            if(m == original) res.push_back(i);\\n            \\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1450731,
                "title": "python-1-intuitive-1-fast-sliding",
                "content": "Solution 1: Short, intuitive and simple, but rebuilds matches\\n\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n\\n        c = Counter(words)\\n        word_len = len(words[0])\\n        seq_len = len(words)*word_len\\n        \\n        def success(i, word):\\n\\t\\t\\t# Copy of word counts to remove from as needed\\n            counter = c.copy()\\n            counter[word] -= 1\\n            \\n            # Continue removing as long as sequence is not complete or until invalid word is encountered\\n            for i in range(i, i+seq_len-word_len, word_len):\\n                if not counter[(w := s[i:i+word_len])]:\\n                    return False\\n                counter[w] -= 1\\n            \\n            # Sequence built successfully\\n            return True\\n        \\n        # Return indices where there is a valid word and valid combo of words from thereafter \\n        return [i for i in range(len(s)-seq_len+1) if c[(w := s[i:i+word_len])] and success(i+word_len, w)]\\n```\\n\\nSolution 2: Maintains matches (Inspired by https://leetcode.com/problems/substring-with-concatenation-of-all-words/discuss/1439131/Simple-Python-solution \\'s solution)\\n\\n```\\nfrom collections import Counter\\n\\ndef findSubstring(s: str, words: List[str]) -> List[int]:\\n    indices = set()\\n    counts = Counter(words)\\n\\n    word_len = len(words[0])\\n    list_len = len(words)\\n\\tseq_len_remove_1 = (list_len-1)*word_len\\n\\n    for start in range(word_len): \\n        matches = 0\\n        counts_copy = counts.copy()\\n        \\n        # Iterate through s in steps of word_len starting at start in [0, word_len) \\n        for ind in range(start, len(s), word_len): \\n            # Not in words list\\n            if not (word := s[ind:ind+word_len]) in counts_copy:\\n                if matches: # We were building and must reset since we encountered a non-word\\n                    matches = 0\\n                    counts_copy = counts.copy()\\n            # Unused word from words list\\n            elif counts_copy[word]:\\n                counts_copy[word] -= 1\\n                matches += 1\\n\\n                if matches == list_len:\\n                    indices.add(ind-seq_len_remove_1)\\n            # In words list, but used (trickiest part of solution, think of it as a sliding left pointer)\\n            else:\\n                # Find leftmost occurunce of word in matches (we know it has been used)\\n                k = next(k for k in range(ind - matches*word_len, ind, word_len) if s[k:k+word_len]==word)\\n                # Everything before this occurence is not part of matches anymore\\n                counts_copy.update([s[p:p+word_len] for p in range(ind - matches*word_len, k, word_len)])\\n                matches = (ind-k)//word_len\\n\\n                if matches == list_len:\\n                    indices.add(ind-seq_len_remove_1)\\n\\n    return indices\\n\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n\\n        c = Counter(words)\\n        word_len = len(words[0])\\n        seq_len = len(words)*word_len\\n        \\n        def success(i, word):\\n\\t\\t\\t# Copy of word counts to remove from as needed\\n            counter = c.copy()\\n            counter[word] -= 1\\n            \\n            # Continue removing as long as sequence is not complete or until invalid word is encountered\\n            for i in range(i, i+seq_len-word_len, word_len):\\n                if not counter[(w := s[i:i+word_len])]:\\n                    return False\\n                counter[w] -= 1\\n            \\n            # Sequence built successfully\\n            return True\\n        \\n        # Return indices where there is a valid word and valid combo of words from thereafter \\n        return [i for i in range(len(s)-seq_len+1) if c[(w := s[i:i+word_len])] and success(i+word_len, w)]\\n```\n```\\nfrom collections import Counter\\n\\ndef findSubstring(s: str, words: List[str]) -> List[int]:\\n    indices = set()\\n    counts = Counter(words)\\n\\n    word_len = len(words[0])\\n    list_len = len(words)\\n\\tseq_len_remove_1 = (list_len-1)*word_len\\n\\n    for start in range(word_len): \\n        matches = 0\\n        counts_copy = counts.copy()\\n        \\n        # Iterate through s in steps of word_len starting at start in [0, word_len) \\n        for ind in range(start, len(s), word_len): \\n            # Not in words list\\n            if not (word := s[ind:ind+word_len]) in counts_copy:\\n                if matches: # We were building and must reset since we encountered a non-word\\n                    matches = 0\\n                    counts_copy = counts.copy()\\n            # Unused word from words list\\n            elif counts_copy[word]:\\n                counts_copy[word] -= 1\\n                matches += 1\\n\\n                if matches == list_len:\\n                    indices.add(ind-seq_len_remove_1)\\n            # In words list, but used (trickiest part of solution, think of it as a sliding left pointer)\\n            else:\\n                # Find leftmost occurunce of word in matches (we know it has been used)\\n                k = next(k for k in range(ind - matches*word_len, ind, word_len) if s[k:k+word_len]==word)\\n                # Everything before this occurence is not part of matches anymore\\n                counts_copy.update([s[p:p+word_len] for p in range(ind - matches*word_len, k, word_len)])\\n                matches = (ind-k)//word_len\\n\\n                if matches == list_len:\\n                    indices.add(ind-seq_len_remove_1)\\n\\n    return indices\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1419019,
                "title": "c-simple-multiset",
                "content": "Was able to make sliding window approach, but was curious about multiset solution I thought of earlier\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), n = words.size(), m = s.length();\\n        multiset<string> db;\\n        vector<int> results;\\n        \\n        for(auto& word : words) {\\n            db.insert(word);\\n        }\\n        \\n        auto temp = db;\\n        for(int i = 0; i < m - n * len + 1; i += 1) {\\n            string word = s.substr(i, len);\\n            auto it = temp.find(word);\\n            \\n            if(it != temp.end()) {\\n                temp.erase(it);\\n                int j = i + len;\\n                \\n                while(j < m) {\\n                    word = s.substr(j, len);\\n                    it = temp.find(word);\\n                    \\n                    if(it != temp.end()) {\\n                        temp.erase(it);\\n                    }\\n                    else {\\n                        break;\\n                    }\\n                    \\n                    j += len;\\n                }\\n                \\n                if(temp.empty()) {\\n                    results.push_back(i);\\n                }\\n                \\n                temp = db;\\n            }\\n        }\\n        \\n        return results;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), n = words.size(), m = s.length();\\n        multiset<string> db;\\n        vector<int> results;\\n        \\n        for(auto& word : words) {\\n            db.insert(word);\\n        }\\n        \\n        auto temp = db;\\n        for(int i = 0; i < m - n * len + 1; i += 1) {\\n            string word = s.substr(i, len);\\n            auto it = temp.find(word);\\n            \\n            if(it != temp.end()) {\\n                temp.erase(it);\\n                int j = i + len;\\n                \\n                while(j < m) {\\n                    word = s.substr(j, len);\\n                    it = temp.find(word);\\n                    \\n                    if(it != temp.end()) {\\n                        temp.erase(it);\\n                    }\\n                    else {\\n                        break;\\n                    }\\n                    \\n                    j += len;\\n                }\\n                \\n                if(temp.empty()) {\\n                    results.push_back(i);\\n                }\\n                \\n                temp = db;\\n            }\\n        }\\n        \\n        return results;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1380395,
                "title": "clean-python-solution-explained-o-n-wl-with-other-similar-problems",
                "content": "```python\\n\"\"\"\\nTime: O(N*wl), N is the length of the input string s; wl is the length of each word.\\nSpace: O(N)\\n\\nFor word count wc and word length wl, the string we are looking for will be between i and j (s[i:j]).\\n`test()` all s[i:j]. If pass, append into ans.\\n\\nEach `test()` will test the sub-string s[i:j]`.\\nIf any \"word\" in the sub-string is not in the countExpected, the test failed.\\nIf the word is used too many times (more than \"countExpected\"), the test failed.\\nOtherwise, the test pass.\\n\\nThis is the solution I learn from @gabbu.\\n\\n\"\"\"\\nimport collections\\n\\nclass Solution(object):\\n    def findSubstring(self, s, words):\\n        if not words: return []\\n        \\n        wc = len(words) #word count\\n        wl = len(words[0]) #word length\\n        ans = []\\n        \\n        i = 0\\n        j = wc*wl\\n        \\n        countExpected = collections.Counter(words)\\n        \\n        while j<=len(s):\\n            if self.test(s[i:j], wl, countExpected): ans.append(i)\\n            i += 1\\n            j += 1\\n        \\n        return ans\\n    \\n    \\n    def test(self, s, wl, countExpected):\\n        counter = collections.Counter() #{word:how many time the word is used}\\n        i = 0\\n        \\n        while i<len(s):\\n            word = s[i:i+wl]\\n            if word not in countExpected or counter[word]>=countExpected[word]: return False\\n            i += wl\\n            counter[word] += 1\\n            \\n        return True\\n        \\n\"\"\"\\nRelated Problems:\\nLongest Substring Without Repeating Characters\\nLongest Substring that contains k unique characters\\nSubstring with Concatenation of All Words\\nMinimum Window Substring\\nLongest Substring with At Least K Repeating Characters\\nPermutation in String\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "solutionTags": [],
                "code": "```python\\n\"\"\"\\nTime: O(N*wl), N is the length of the input string s; wl is the length of each word.\\nSpace: O(N)\\n\\nFor word count wc and word length wl, the string we are looking for will be between i and j (s[i:j]).\\n`test()` all s[i:j]. If pass, append into ans.\\n\\nEach `test()` will test the sub-string s[i:j]`.\\nIf any \"word\" in the sub-string is not in the countExpected, the test failed.\\nIf the word is used too many times (more than \"countExpected\"), the test failed.\\nOtherwise, the test pass.\\n\\nThis is the solution I learn from @gabbu.\\n\\n\"\"\"\\nimport collections\\n\\nclass Solution(object):\\n    def findSubstring(self, s, words):\\n        if not words: return []\\n        \\n        wc = len(words) #word count\\n        wl = len(words[0]) #word length\\n        ans = []\\n        \\n        i = 0\\n        j = wc*wl\\n        \\n        countExpected = collections.Counter(words)\\n        \\n        while j<=len(s):\\n            if self.test(s[i:j], wl, countExpected): ans.append(i)\\n            i += 1\\n            j += 1\\n        \\n        return ans\\n    \\n    \\n    def test(self, s, wl, countExpected):\\n        counter = collections.Counter() #{word:how many time the word is used}\\n        i = 0\\n        \\n        while i<len(s):\\n            word = s[i:i+wl]\\n            if word not in countExpected or counter[word]>=countExpected[word]: return False\\n            i += wl\\n            counter[word] += 1\\n            \\n        return True\\n        \\n\"\"\"\\nRelated Problems:\\nLongest Substring Without Repeating Characters\\nLongest Substring that contains k unique characters\\nSubstring with Concatenation of All Words\\nMinimum Window Substring\\nLongest Substring with At Least K Repeating Characters\\nPermutation in String\\n\\nFor more other topics similar problems, check out my GitHub.\\nIt took me a lots of time to make the solution. Becuase I want to help others like me.\\nPlease give me a star if you like it. Means a lot to me.\\nhttps://github.com/wuduhren/leetcode-python\\n\"\"\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188946,
                "title": "c-196ms-72-hashmap-three-versions",
                "content": "Runtime: 196 ms, faster than 71.52% of C++ online submissions for Substring with Concatenation of All Words.\\nMemory Usage: 20 MB, less than 77.86% of C++ online submissions for Substring with Concatenation of All Words.\\n**General idea:**\\n1. Consruct hash_map <word from words , pair <number of \"word\" in words, number of \"word\" in words>> (first number we will use in our seeking and second number for \"refresh\" first number for next seeking)\\n2. try to put all words from map from current index from string s\\n\\n\\n**If we refresh all map** \\n```\\nclass Solution {\\npublic:\\n  vector<int> findSubstring(string s, vector<string>& words){\\n    unordered_map<string,pair<int,int>>mp;\\n    for(auto &w : words) mp[w].first++,mp[w].second++;\\n    \\n    vector<int> answer;\\n    int n = words[0].size(), N = words.size();\\n    int limit = s.size() - n * N + 1;\\n    if(limit < 0) return answer;\\n    \\n    for(int i = 0; i != limit; i++){\\n      int tN = 0, j = i;\\n      for(; ;j += n){\\n        string tmp = s.substr(j,n);\\n        if(mp[tmp].first) tN++, mp[tmp].first--;\\n        else break;\\n      }\\n      if(tN == N) answer.push_back(i);\\n      \\n      for(auto &it: mp) it.second.first = it.second.second;\\n    }\\n    \\n  return answer;     \\n  }\\n};\\n```\\n**if we refresh only \"worked\" words from map** \\nRuntime: 240 ms, faster than 52.97% of C++ online submissions for Substring with Concatenation of All Words.\\nMemory Usage: 22.8 MB, less than 72.96% of C++ online submissions for Substring with Concatenation of All Words.\\n```\\nclass Solution {\\npublic:\\n  vector<int> findSubstring(string s, vector<string>& words){\\n    unordered_map<string,pair<int,int>>mp;\\n    for(auto &w : words) mp[w].first++,mp[w].second++;\\n    \\n    vector<int> answer;\\n    int n = words[0].size(), N = words.size();\\n    int limit = s.size() - n * N + 1;\\n    if(limit < 0) return answer;\\n    \\n    for(int i = 0; i != limit;i++){\\n      int tN = 0, j = i;\\n      for(; ;j += n){\\n        string tmp = s.substr(j,n);\\n        if(mp[tmp].first) tN++, mp[tmp].first--;\\n        else break;\\n      }\\n      if(tN == N) answer.push_back(i);\\n      \\n      for(int k = i; k <= j; k += n){\\n        string tmp = s.substr(k,n);\\n        int p = mp[tmp].second;\\n        mp[tmp] = {p,p};\\n      } \\n    }\\n    \\n  return answer;     \\n  }\\n};\\n```\\n\\n**If we replace \"bad\" pair with \"good\"** \\nRuntime: 892 ms, faster than 17.72% of C++ online submissions for Substring with Concatenation of All Words.\\nMemory Usage: 20 MB, less than 77.65% of C++ online submissions for Substring with Concatenation of All Words.\\n```\\nclass Solution {\\npublic:\\n  vector<int> findSubstring(string s, vector<string>& words){\\n    unordered_map<string,pair<int,int>>mp;\\n    for(auto &w : words) mp[w].first++,mp[w].second++;\\n    \\n    vector<int> answer;\\n    int n = words[0].size(), N = words.size();\\n    int limit = s.size() - n * N + 1;\\n    if(limit < 0) return answer;\\n    \\n    for(int i = 0; i != limit;i++){\\n      int tN = 0;\\n      for(int j = i; ;j += n){\\n        string tmp = s.substr(j,n);\\n        if(mp[tmp].first) tN++, mp[tmp].first--;\\n        else break;\\n      }\\n      if(tN == N) answer.push_back(i);\\n      for(unordered_map<string,pair<int,int>>::iterator it = mp.begin(); it != mp.end();it++){\\n        mp[it->first] = {it->second.second,it->second.second};\\n      } \\n    }\\n    \\n  return answer;     \\n  }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  vector<int> findSubstring(string s, vector<string>& words){\\n    unordered_map<string,pair<int,int>>mp;\\n    for(auto &w : words) mp[w].first++,mp[w].second++;\\n    \\n    vector<int> answer;\\n    int n = words[0].size(), N = words.size();\\n    int limit = s.size() - n * N + 1;\\n    if(limit < 0) return answer;\\n    \\n    for(int i = 0; i != limit; i++){\\n      int tN = 0, j = i;\\n      for(; ;j += n){\\n        string tmp = s.substr(j,n);\\n        if(mp[tmp].first) tN++, mp[tmp].first--;\\n        else break;\\n      }\\n      if(tN == N) answer.push_back(i);\\n      \\n      for(auto &it: mp) it.second.first = it.second.second;\\n    }\\n    \\n  return answer;     \\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  vector<int> findSubstring(string s, vector<string>& words){\\n    unordered_map<string,pair<int,int>>mp;\\n    for(auto &w : words) mp[w].first++,mp[w].second++;\\n    \\n    vector<int> answer;\\n    int n = words[0].size(), N = words.size();\\n    int limit = s.size() - n * N + 1;\\n    if(limit < 0) return answer;\\n    \\n    for(int i = 0; i != limit;i++){\\n      int tN = 0, j = i;\\n      for(; ;j += n){\\n        string tmp = s.substr(j,n);\\n        if(mp[tmp].first) tN++, mp[tmp].first--;\\n        else break;\\n      }\\n      if(tN == N) answer.push_back(i);\\n      \\n      for(int k = i; k <= j; k += n){\\n        string tmp = s.substr(k,n);\\n        int p = mp[tmp].second;\\n        mp[tmp] = {p,p};\\n      } \\n    }\\n    \\n  return answer;     \\n  }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n  vector<int> findSubstring(string s, vector<string>& words){\\n    unordered_map<string,pair<int,int>>mp;\\n    for(auto &w : words) mp[w].first++,mp[w].second++;\\n    \\n    vector<int> answer;\\n    int n = words[0].size(), N = words.size();\\n    int limit = s.size() - n * N + 1;\\n    if(limit < 0) return answer;\\n    \\n    for(int i = 0; i != limit;i++){\\n      int tN = 0;\\n      for(int j = i; ;j += n){\\n        string tmp = s.substr(j,n);\\n        if(mp[tmp].first) tN++, mp[tmp].first--;\\n        else break;\\n      }\\n      if(tN == N) answer.push_back(i);\\n      for(unordered_map<string,pair<int,int>>::iterator it = mp.begin(); it != mp.end();it++){\\n        mp[it->first] = {it->second.second,it->second.second};\\n      } \\n    }\\n    \\n  return answer;     \\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1158065,
                "title": "c-solution-sliding-window-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    #define pb push_back\\n    vector<int> findSubstring(string str, vector<string>& words) {\\n        int a=words.size();\\n        vector<int >ans;\\n\\tunordered_map<string , int >m;\\n\\tfor (int i = 0; i < a; i++) {\\n\\t\\tm[words[i]]++;\\n\\t}\\n\\tint word = words[0].length();\\n\\tint window = word * a;\\n        if(window>str.length()){\\n            return ans;\\n        }\\n\\tfor (int i = 0; i <= str.size() - window; i++) {\\n\\t\\tstring temp = str.substr(i, window);\\n\\t\\tunordered_map<string , int >t;\\n\\t\\tint j = 0;\\n\\t\\tint index = 0;\\n\\t\\twhile (index < a) {\\n\\t\\t\\tstring rest = temp.substr(j, word);\\n\\t\\t\\tt[rest]++;\\n\\t\\t\\tj += word;\\n\\t\\t\\tindex++;\\n\\t\\t}\\n\\t\\t//cout << m.size() << \" \" << t.size() << endl;\\n\\t\\tif (m == t) {\\n\\t\\t\\tans.pb(i);\\n\\t\\t}\\n\\n//\\t\\treturn 0;\\n\\t}\\n\\treturn ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    #define pb push_back\\n    vector<int> findSubstring(string str, vector<string>& words) {\\n        int a=words.size();\\n        vector<int >ans;\\n\\tunordered_map<string , int >m;\\n\\tfor (int i = 0; i < a; i++) {\\n\\t\\tm[words[i]]++;\\n\\t}\\n\\tint word = words[0].length();\\n\\tint window = word * a;\\n        if(window>str.length()){\\n            return ans;\\n        }\\n\\tfor (int i = 0; i <= str.size() - window; i++) {\\n\\t\\tstring temp = str.substr(i, window);\\n\\t\\tunordered_map<string , int >t;\\n\\t\\tint j = 0;\\n\\t\\tint index = 0;\\n\\t\\twhile (index < a) {\\n\\t\\t\\tstring rest = temp.substr(j, word);\\n\\t\\t\\tt[rest]++;\\n\\t\\t\\tj += word;\\n\\t\\t\\tindex++;\\n\\t\\t}\\n\\t\\t//cout << m.size() << \" \" << t.size() << endl;\\n\\t\\tif (m == t) {\\n\\t\\t\\tans.pb(i);\\n\\t\\t}\\n\\n//\\t\\treturn 0;\\n\\t}\\n\\treturn ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1090701,
                "title": "python-easy-to-follow",
                "content": "```\\n        w_len = len(words[0])\\n        tot_len = w_len*len(words)\\n        rtn = []\\n        words.sort()\\n\\n        for i in range(0, len(s)-tot_len+1):\\n\\n            temp = s[i:i+tot_len]\\n            temp_list = []\\n\\n            for j in range(0 , len(temp) , w_len):\\n\\n                temp_list.append(temp[j:j+w_len])\\n\\n            temp_list.sort()\\n\\n            if(temp_list == words):\\n                rtn.append(i)\\n\\n        return rtn",
                "solutionTags": [],
                "code": "```\\n        w_len = len(words[0])\\n        tot_len = w_len*len(words)\\n        rtn = []\\n        words.sort()\\n\\n        for i in range(0, len(s)-tot_len+1):\\n\\n            temp = s[i:i+tot_len]\\n            temp_list = []\\n\\n            for j in range(0 , len(temp) , w_len):\\n\\n                temp_list.append(temp[j:j+w_len])\\n\\n            temp_list.sort()\\n\\n            if(temp_list == words):\\n                rtn.append(i)\\n\\n        return rtn",
                "codeTag": "Unknown"
            },
            {
                "id": 1058574,
                "title": "java-7ms-faster-than-97",
                "content": "**Use sliding window**\\n\\n*Intuition* : Given that each word is N-characters-long (N-long), a valid subtring is formed by concatenating N-long words from words array in any order without intervening characters. Our task is to return a list of possible starting indices of valid substrings of s.\\n\\n*Algorithm* : \\n\\tFirst off, there are N possible ways to choose the starting index from which we traverse string s, \\n    so such a variable holds values from 0 to N-1.\\n    As we traverse s in N-long strides, we build a potential valid substring by enqueueing each \\n    encountered N-long substring. \\n    If this N-long substring is a word in words array, we verify if it features in substrWordToCount,a map which counts the frequency of N-long substrings in the potential valid substring, more than once. \\n    If it doesn\\'t, then we put it in the map.\\n\\tIf it does, then we decrement the frequency of the word at the front of the potential valid substring, removing it from the map if it featured once and moving the possible starting index N-long places to the right of s.\\n     The, we enqueue the N-long substring into our potential valid substring.\\n     Finally, we check that the valid substring has as many words as the words array. If so, we have a valid substring and we add our current starting index to the final list of possible starting indices of valid substrings in s.\\n    If this N-long substring is not in words array, we\\'ve encounter a word-long intervening substring which invalidates our potential valid substring so that we reset our queue, reset the map which stores the frequency of N-long substrings in the potential valid substring and move the possible starting index just after this N-long substring in s.\\n\\t\\n*Complexity* : \\t\\nLet M be the length of words array and N be length of each word, then our Time complexity is O(N^2) and our Space complexity is O(M!)\\n\\n\\t ```\\n\\t    public List<Integer> findSubstring(String s, String[] words) {\\n\\t\\t\\tList<Integer> indices = new ArrayList<>();\\n        \\n\\t\\t\\tif (s == null || words == null || s.length() == 0 || words.length == 0) {\\n\\t\\t\\t\\treturn indices;\\n\\t\\t\\t}\\n        \\n\\t\\t\\tint wordLen = words[0].length(), wordsCount = words.length;\\n        \\n\\t\\t\\tMap<String, Integer> wordToCount = new HashMap<>();\\n\\t\\t\\tfor (String word : words)\\n\\t\\t\\t\\twordToCount.put(word, wordToCount.getOrDefault(word, 0) + 1);\\n        \\n\\t\\t\\tfor (int start = 0; start < wordLen; start++) {\\n\\t\\t\\t\\tQueue<String> queue = new LinkedList<>();\\n\\t\\t\\t\\tMap<String, Integer> substrWordToCount = new HashMap<>();\\n\\t\\t\\t\\tfor (int lo = start, hi = start; hi <= s.length() - wordLen; hi += wordLen) {\\n\\t\\t\\t\\t\\tString word = s.substring(hi, hi + wordLen);\\n\\t\\t\\t\\t\\tif (!wordToCount.containsKey(word)) {\\n\\t\\t\\t\\t\\t\\tqueue = new LinkedList<>();\\n\\t\\t\\t\\t\\t\\tlo = hi + wordLen;\\n\\t\\t\\t\\t\\t\\tsubstrWordToCount = new HashMap<>();\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tint substrWordCount = substrWordToCount.getOrDefault(word, 0);\\n\\t\\t\\t\\t\\t\\tif (substrWordCount >= wordToCount.get(word)) {\\n\\t\\t\\t\\t\\t\\t\\twhile (!queue.peek().equals(word)) {\\n\\t\\t\\t\\t\\t\\t\\t\\tString wordToRemove = queue.poll();\\n\\t\\t\\t\\t\\t\\t\\t\\tint count = substrWordToCount.get(wordToRemove);\\n\\t\\t\\t\\t\\t\\t\\t\\tif (count == 1) substrWordToCount.remove(wordToRemove);\\n\\t\\t\\t\\t\\t\\t\\t\\telse substrWordToCount.put(wordToRemove, count - 1);\\n\\t\\t\\t\\t\\t\\t\\t\\tlo += wordLen;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tlo += wordLen;\\n\\t\\t\\t\\t\\t\\t\\tqueue.poll();\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tsubstrWordToCount.put(word, substrWordCount + 1);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tqueue.offer(word);\\n\\t\\t\\t\\t\\t\\tif (queue.size() == wordsCount) {\\n\\t\\t\\t\\t\\t\\t\\tindices.add(lo);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn indices;\\n\\t\\t}\\n\\t ```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\n\\t    public List<Integer> findSubstring(String s, String[] words) {\\n\\t\\t\\tList<Integer> indices = new ArrayList<>();\\n        \\n\\t\\t\\tif (s == null || words == null || s.length() == 0 || words.length == 0) {\\n\\t\\t\\t\\treturn indices;\\n\\t\\t\\t}\\n        \\n\\t\\t\\tint wordLen = words[0].length(), wordsCount = words.length;\\n        \\n\\t\\t\\tMap<String, Integer> wordToCount = new HashMap<>();\\n\\t\\t\\tfor (String word : words)\\n\\t\\t\\t\\twordToCount.put(word, wordToCount.getOrDefault(word, 0) + 1);\\n        \\n\\t\\t\\tfor (int start = 0; start < wordLen; start++) {\\n\\t\\t\\t\\tQueue<String> queue = new LinkedList<>();\\n\\t\\t\\t\\tMap<String, Integer> substrWordToCount = new HashMap<>();\\n\\t\\t\\t\\tfor (int lo = start, hi = start; hi <= s.length() - wordLen; hi += wordLen) {\\n\\t\\t\\t\\t\\tString word = s.substring(hi, hi + wordLen);\\n\\t\\t\\t\\t\\tif (!wordToCount.containsKey(word)) {\\n\\t\\t\\t\\t\\t\\tqueue = new LinkedList<>();\\n\\t\\t\\t\\t\\t\\tlo = hi + wordLen;\\n\\t\\t\\t\\t\\t\\tsubstrWordToCount = new HashMap<>();\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tint substrWordCount = substrWordToCount.getOrDefault(word, 0);\\n\\t\\t\\t\\t\\t\\tif (substrWordCount >= wordToCount.get(word)) {\\n\\t\\t\\t\\t\\t\\t\\twhile (!queue.peek().equals(word)) {\\n\\t\\t\\t\\t\\t\\t\\t\\tString wordToRemove = queue.poll();\\n\\t\\t\\t\\t\\t\\t\\t\\tint count = substrWordToCount.get(wordToRemove);\\n\\t\\t\\t\\t\\t\\t\\t\\tif (count == 1) substrWordToCount.remove(wordToRemove);\\n\\t\\t\\t\\t\\t\\t\\t\\telse substrWordToCount.put(wordToRemove, count - 1);\\n\\t\\t\\t\\t\\t\\t\\t\\tlo += wordLen;\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\tlo += wordLen;\\n\\t\\t\\t\\t\\t\\t\\tqueue.poll();\\n\\t\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\t\\tsubstrWordToCount.put(word, substrWordCount + 1);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\tqueue.offer(word);\\n\\t\\t\\t\\t\\t\\tif (queue.size() == wordsCount) {\\n\\t\\t\\t\\t\\t\\t\\tindices.add(lo);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn indices;\\n\\t\\t}\\n\\t ```",
                "codeTag": "Unknown"
            },
            {
                "id": 912023,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string,int>m,aux;\\n        for(int i=0;i<words.size();i++)\\n        {\\n                m[words[i]]++;\\n        }\\n        aux=m;\\n        int num=words[0].length();   //you have to skip this much i, if it matches\\n        int count=words.size(); //total number of words that should match!\\n        vector<int>ans;\\n        if(num*count>s.length()) return ans;\\n        for(int i=0;i<s.length()-num*count+1;i++)\\n        {\\n            if(aux.find(s.substr(i,num))!=aux.end()) \\n            {\\n                aux[s.substr(i,num)]--;\\n                int rep=1;\\n                int j=i+num;\\n                while(1)\\n                {\\n                    if(aux[s.substr(j,num)]>0)\\n                    {\\n                        rep++;\\n                        aux[s.substr(j,num)]--;\\n                    }\\n                    else break;\\n                    j=j+num;\\n                }\\n                if(rep==count) \\n                {\\n                    ans.push_back(i);\\n                }\\n                aux=m;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string,int>m,aux;\\n        for(int i=0;i<words.size();i++)\\n        {\\n                m[words[i]]++;\\n        }\\n        aux=m;\\n        int num=words[0].length();   //you have to skip this much i, if it matches\\n        int count=words.size(); //total number of words that should match!\\n        vector<int>ans;\\n        if(num*count>s.length()) return ans;\\n        for(int i=0;i<s.length()-num*count+1;i++)\\n        {\\n            if(aux.find(s.substr(i,num))!=aux.end()) \\n            {\\n                aux[s.substr(i,num)]--;\\n                int rep=1;\\n                int j=i+num;\\n                while(1)\\n                {\\n                    if(aux[s.substr(j,num)]>0)\\n                    {\\n                        rep++;\\n                        aux[s.substr(j,num)]--;\\n                    }\\n                    else break;\\n                    j=j+num;\\n                }\\n                if(rep==count) \\n                {\\n                    ans.push_back(i);\\n                }\\n                aux=m;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 871132,
                "title": "python-3-simple-fast-and-easy-to-understand",
                "content": "```\\ndef wrap(s, n):\\n    return [s[i:i+n] for i in range(0, len(s), n)]\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wordlength = len(words[0])\\n        wordset = set(words)\\n        strlength = len(s)     \\n        matchlength = len(words) * wordlength\\n        sortedmatch = \"\".join(sorted(words))\\n        result = []\\n        for i in range(0,(strlength - matchlength) + 1):\\n            if s[i:i + wordlength] in wordset:\\n                cursortedmatch = \"\".join(sorted(wrap(s[i:i + matchlength], wordlength)))\\n                if cursortedmatch == sortedmatch:\\n                    result.append(i)                \\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\ndef wrap(s, n):\\n    return [s[i:i+n] for i in range(0, len(s), n)]\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        wordlength = len(words[0])\\n        wordset = set(words)\\n        strlength = len(s)     \\n        matchlength = len(words) * wordlength\\n        sortedmatch = \"\".join(sorted(words))\\n        result = []\\n        for i in range(0,(strlength - matchlength) + 1):\\n            if s[i:i + wordlength] in wordset:\\n                cursortedmatch = \"\".join(sorted(wrap(s[i:i + matchlength], wordlength)))\\n                if cursortedmatch == sortedmatch:\\n                    result.append(i)                \\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 827924,
                "title": "amazing-solution-easier-than-ever-1-please-up-vote",
                "content": "class Solution {\\n    \\n    public List<Integer> findSubstring(String s, String[] words) {\\n        ArrayList<Integer> al = new ArrayList<Integer>();\\n       HashMap<String,Integer> hm = new HashMap<String,Integer>();\\n        int n = s.length();\\n        int eachWordLength = words[0].length();\\n        int totalWordsLength = words.length*eachWordLength;\\n        for(String word: words){\\n            hm.put(word,hm.getOrDefault(word,0)+1);\\n        }\\n       for(int i=0;i<=n-totalWordsLength;i++){\\n           int j = i;\\n           int count = words.length;\\n            HashMap<String, Integer> temp = (HashMap<String, Integer>) hm.clone(); \\n           while(j<i+totalWordsLength){\\n               String str = s.substring(j,j+eachWordLength);\\n               if(!hm.containsKey(str)||temp.get(str)==0){\\n                   break;\\n               }else{\\n                   temp.put(str,temp.get(str)-1);\\n                   count--;\\n               }\\n               j=j+eachWordLength;\\n           }\\n           if(count==0){\\n               al.add(i);\\n           }\\n       } \\n        return al;\\n    }\\n    \\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n    public List<Integer> findSubstring(String s, String[] words) {\\n        ArrayList<Integer> al = new ArrayList<Integer>();\\n       HashMap<String,Integer> hm = new HashMap<String,Integer>();\\n        int n = s.length();\\n        int eachWordLength = words[0].length();\\n        int totalWordsLength = words.length*eachWordLength;\\n        for(String word: words){\\n            hm.put(word,hm.getOrDefault(word,0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 769615,
                "title": "bug-wrong-expected-result-for-a-specific-case",
                "content": "Hello @LeetCode,\\n\\nI tested my code (Python3) with the case below, I got a wrong expected output:\\n\\n```\\n\"bar\"\\n[\"\"]\\nexpected: [0,1,2,3] \\n```\\nThe index 3 **isn\\'t in the range** of the string `bar`\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n\"bar\"\\n[\"\"]\\nexpected: [0,1,2,3] \\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 737563,
                "title": "python-1-liner",
                "content": "```\\nclass Solution:\\n    def findSubstring(self, s: str, w: List[str]) -> List[int]:\\n        return [i for i in range(len(s)-len(w)*len(w[0])+1)\\n                if Counter([s[a:a+len(w[0])]for a in range(i,i+len(w)*len(w[0]),len(w[0]))]) == Counter(w)] if w else []\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s: str, w: List[str]) -> List[int]:\\n        return [i for i in range(len(s)-len(w)*len(w[0])+1)\\n                if Counter([s[a:a+len(w[0])]for a in range(i,i+len(w)*len(w[0]),len(w[0]))]) == Counter(w)] if w else []\\n```",
                "codeTag": "Java"
            },
            {
                "id": 674099,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string str, vector<string>& words) {\\n        if (str.empty() or words.empty()) {return vector<int> ();}\\n        if (str.size() < words.size()*words[0].size()) {return vector<int> ();}\\n        vector<int> resultIndices;\\n        unordered_map<string, int> wordFrequencyMap;\\n        for (auto word : words) {\\n          wordFrequencyMap[word]++;\\n        }\\n        int wordsCount = words.size(), wordLength = words[0].length();\\n\\n        for (int i = 0; i <= str.length() - wordsCount * wordLength; i++) {\\n          unordered_map<string, int> wordsSeen;\\n          for (int j = 0; j < wordsCount; j++) {\\n            int nextWordIndex = i + j * wordLength;\\n            string word = str.substr(nextWordIndex, wordLength);\\n            if (!wordFrequencyMap.count(word)) { \\n              break;\\n            }\\n            wordsSeen[word]++;  \\n            if (wordsSeen[word] > wordFrequencyMap[word]) {\\n              break;\\n            }\\n            if (j + 1 == wordsCount) { \\n              resultIndices.push_back(i);\\n            }\\n          }\\n        }\\n\\n        return resultIndices;    \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> findSubstring(string str, vector<string>& words) {\\n        if (str.empty() or words.empty()) {return vector<int> ();}",
                "codeTag": "Java"
            },
            {
                "id": 572222,
                "title": "python-3-easy-to-understand-solution-o-n-no-of-words",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        if not s or not words:\\n            return []\\n        res=[]\\n        chk=defaultdict(int)\\n        ln_chk=len(words)\\n        for i in words:\\n            chk[i]+=1\\n            \\n        ln=len(words[0])\\n        n=len(s)\\n        i=0\\n        \\n        for i in range(n-(ln*ln_chk)+1):\\n            temp=chk.copy() # copy of dict. chk\\n            k=i\\n            test=0\\n            for j in range(ln_chk):\\n                word=s[k:k+ln]\\n                if temp[word]>0:\\n                    temp[word]-=1\\n                else:\\n                    test=1\\n                    break\\n                k+=ln\\n            \\n            if test!=1:\\n                res.append(i)\\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        if not s or not words:\\n            return []\\n        res=[]\\n        chk=defaultdict(int)\\n        ln_chk=len(words)\\n        for i in words:\\n            chk[i]+=1\\n            \\n        ln=len(words[0])\\n        n=len(s)\\n        i=0\\n        \\n        for i in range(n-(ln*ln_chk)+1):\\n            temp=chk.copy() # copy of dict. chk\\n            k=i\\n            test=0\\n            for j in range(ln_chk):\\n                word=s[k:k+ln]\\n                if temp[word]>0:\\n                    temp[word]-=1\\n                else:\\n                    test=1\\n                    break\\n                k+=ln\\n            \\n            if test!=1:\\n                res.append(i)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 538906,
                "title": "two-map-solution-with-clear-explanation-and-reasonable-variable-names",
                "content": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        if not s or not words:\\n            return []\\n        \\n        allwords = {}\\n        for word in words:\\n            if word in allwords:\\n                allwords[word] += 1\\n            else:\\n                allwords[word] = 1\\n       \\n\\t    lens = len(s)\\n        lenoneword = len(words[0])\\n        lenallwords = len(words) * lenoneword\\n        ans = []\\n       \\n        for i in range(lens - lenallwords + 1):\\n            thissegmentwords = {}\\n            for start in range(i, i + lenallwords, lenoneword): \\n                temp_word = s[start: start + lenoneword] \\n                #print(temp_word)\\n                \\n                if temp_word in allwords:\\n                    if temp_word in thissegmentwords:\\n                        thissegmentwords[temp_word] += 1\\n                        if thissegmentwords[temp_word] > allwords[temp_word]:\\n                            break\\n                    else:\\n                        thissegmentwords[temp_word] = 1\\n                else:\\n                    break\\n            if allwords == thissegmentwords:\\n                ans.append(i)\\n        return ans\\n```\\nUse two dictionaries to solve the problem. The first dict `allwords` stores all the word in `words` as key and accumulates their respective required counts as value.  \\n\\nThen, for each starting position `i` in string `s`, we refer to another dict `thissegmentwords`, which store the word:count pair in the `s[i:i+lenallwords]`. At each step, we check the substring `s[i:i+lenoneword]` and then increases `i` by `lenoneword`. During the scanning, if the substring your are checking is not presented in the first dict `allwords` or if its count is larger than its required count (`thissegmentwords[temp_word] > allwords[temp_word]`), then you can directly `break` and go check the next position `i`. Else, you can keep scanning. If at the end of the first loop, you find out that the two dicts are identical, then this current substring `s[i:i+lenallwords]` is a legit substring so you save the index `i`.\\n\\nBy checking every starting position, you will get all the index you want. Hope this help!\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        if not s or not words:\\n            return []\\n        \\n        allwords = {}\\n        for word in words:\\n            if word in allwords:\\n                allwords[word] += 1\\n            else:\\n                allwords[word] = 1\\n       \\n\\t    lens = len(s)\\n        lenoneword = len(words[0])\\n        lenallwords = len(words) * lenoneword\\n        ans = []\\n       \\n        for i in range(lens - lenallwords + 1):\\n            thissegmentwords = {}\\n            for start in range(i, i + lenallwords, lenoneword): \\n                temp_word = s[start: start + lenoneword] \\n                #print(temp_word)\\n                \\n                if temp_word in allwords:\\n                    if temp_word in thissegmentwords:\\n                        thissegmentwords[temp_word] += 1\\n                        if thissegmentwords[temp_word] > allwords[temp_word]:\\n                            break\\n                    else:\\n                        thissegmentwords[temp_word] = 1\\n                else:\\n                    break\\n            if allwords == thissegmentwords:\\n                ans.append(i)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 357817,
                "title": "c-o-n-solution-aho-corasick-automaton-sliding-window",
                "content": "Let `w` be the length of a word.\\nA key observation: for every `i`, `s[i..i+w-1]` matches at most one word in the word list (after removing duplicates), since all words have same length `w`.\\nSo, we can first find all matches and memorize which word matches `s[i..i+w-1]` .\\nThen, for every `0 <= j < w`, we can use a sliding window to find desired substrings starting at `s[j + k * w]` for some integer `k`.\\nThus, this solution runs strictly in `O(|s| + |words| * w)` time.\\n\\nCode (C++):\\n```c++\\nclass Solution {\\nprivate:\\n  class AcAutomaton {\\n  private:\\n    struct Node {\\n      Node* child[26]{};\\n      Node* fail{};\\n      // no next needed since all words have same length\\n      // Node* next{};\\n      size_t id{};\\n    };\\n  public:\\n    inline AcAutomaton(size_t nNode) :\\n      nodes(new Node[nNode]), queue(new Node*[nNode]) {}\\n\\n    inline void add(string_view sv, vector<int>& ctr) {\\n      auto cur = &root;\\n      for (auto ch : sv) {\\n        auto key = (size_t) (ch - \\'a\\');\\n        if (!cur->child[key])\\n          cur->child[key] = &nodes[nNode++];\\n        cur = cur->child[key];\\n      }\\n      if (cur->id)\\n        ++ctr[cur->id - 1];\\n      else {\\n        ctr.emplace_back(1);\\n        cur->id = ctr.size();\\n      }\\n    }\\n\\n    inline void build() {\\n      root.fail = &root;\\n      size_t qEnd = 0;\\n      for (auto key = 0; key < 26; ++key)\\n        if (root.child[key]) {\\n          auto cur = root.child[key];\\n          cur->fail = &root;\\n          queue[qEnd++] = cur;\\n        }\\n      for (size_t qBeg = 0; qBeg != qEnd; ++qBeg)\\n        for (auto key = 0; key < 26; ++key)\\n          if (queue[qBeg]->child[key]) {\\n            auto cur = queue[qBeg]->child[key];\\n            auto fail = queue[qBeg]->fail;\\n            while (fail != &root && !fail->child[key])\\n              fail = fail->fail;\\n            cur->fail = fail->child[key] ? fail->child[key] : &root;\\n            queue[qEnd++] = cur;\\n          }\\n    }\\n\\n    inline void match(vector<size_t>& ids, string_view sv, size_t lenWord) {\\n      auto fail = &root;\\n      for (size_t i = 0; i != sv.size(); ++i) {\\n        auto key = sv[i] - \\'a\\';\\n        while (fail != &root && !fail->child[key])\\n          fail = fail->fail;\\n        if (fail->child[key]) {\\n          fail = fail->child[key];\\n          if (fail->id)\\n            ids[i - lenWord + 1] = fail->id;\\n        }\\n      }\\n    }\\n\\n  private:\\n    unique_ptr<Node[]> nodes;\\n    unique_ptr<Node*[]> queue;\\n    Node root{};\\n    size_t nNode{};\\n  };\\npublic:\\n  vector<int> findSubstring(string text, vector<string>& words) {\\n    if (text.empty() || words.empty() || words[0].empty())\\n      return {};\\n    auto lenText = text.size();\\n    auto nWord = words.size();\\n    auto lenWord = words[0].size();\\n    auto lenPattern = nWord * lenWord;\\n    if (lenText < lenPattern)\\n      return {};\\n    vector<size_t> ids(text.size());\\n    vector<int> ctrDict;\\n    ctrDict.reserve(nWord);\\n    {\\n      AcAutomaton aca(nWord * lenWord);\\n      for (auto& word : words)\\n        aca.add(word, ctrDict);\\n      aca.build();\\n      aca.match(ids, text, lenWord);\\n    }\\n    auto nDistWord = ctrDict.size();\\n    vector<int> ctrText(nDistWord);\\n    vector<int> res;\\n    for (size_t i = 0; i < lenWord && i + lenPattern <= lenText; ++i) {\\n      fill(ctrText.begin(), ctrText.end(), 0);\\n      auto nMatchedDistWord = 0;\\n      for (size_t j = i; j < i + lenPattern; j += lenWord) {\\n        if (ids[j]) {\\n          auto idx = ids[j] - 1;\\n          if (ctrText[idx]++ == ctrDict[idx])\\n            --nMatchedDistWord;\\n          if (ctrText[idx] == ctrDict[idx])\\n            ++nMatchedDistWord;\\n        }\\n      }\\n      if (nMatchedDistWord == nDistWord)\\n        res.emplace_back(i);\\n      for (size_t j = i + lenPattern; j < lenText; j += lenWord) {\\n        if (ids[j]) {\\n          auto idx = ids[j] - 1;\\n          if (ctrText[idx]++ == ctrDict[idx])\\n            --nMatchedDistWord;\\n          if (ctrText[idx] == ctrDict[idx])\\n            ++nMatchedDistWord;\\n        }\\n        if (ids[j - lenPattern]) {\\n          auto idx = ids[j - lenPattern] - 1;\\n          if (ctrText[idx]-- == ctrDict[idx])\\n            --nMatchedDistWord;\\n          if (ctrText[idx] == ctrDict[idx])\\n            ++nMatchedDistWord;\\n        }\\n        if (nMatchedDistWord == nDistWord)\\n          res.emplace_back(j - lenPattern + lenWord);\\n      }\\n    }\\n    return res;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```c++\\nclass Solution {\\nprivate:\\n  class AcAutomaton {\\n  private:\\n    struct Node {\\n      Node* child[26]{};\\n      Node* fail{};\\n      // no next needed since all words have same length\\n      // Node* next{};\\n      size_t id{};\\n    };\\n  public:\\n    inline AcAutomaton(size_t nNode) :\\n      nodes(new Node[nNode]), queue(new Node*[nNode]) {}\\n\\n    inline void add(string_view sv, vector<int>& ctr) {\\n      auto cur = &root;\\n      for (auto ch : sv) {\\n        auto key = (size_t) (ch - \\'a\\');\\n        if (!cur->child[key])\\n          cur->child[key] = &nodes[nNode++];\\n        cur = cur->child[key];\\n      }\\n      if (cur->id)\\n        ++ctr[cur->id - 1];\\n      else {\\n        ctr.emplace_back(1);\\n        cur->id = ctr.size();\\n      }\\n    }\\n\\n    inline void build() {\\n      root.fail = &root;\\n      size_t qEnd = 0;\\n      for (auto key = 0; key < 26; ++key)\\n        if (root.child[key]) {\\n          auto cur = root.child[key];\\n          cur->fail = &root;\\n          queue[qEnd++] = cur;\\n        }\\n      for (size_t qBeg = 0; qBeg != qEnd; ++qBeg)\\n        for (auto key = 0; key < 26; ++key)\\n          if (queue[qBeg]->child[key]) {\\n            auto cur = queue[qBeg]->child[key];\\n            auto fail = queue[qBeg]->fail;\\n            while (fail != &root && !fail->child[key])\\n              fail = fail->fail;\\n            cur->fail = fail->child[key] ? fail->child[key] : &root;\\n            queue[qEnd++] = cur;\\n          }\\n    }\\n\\n    inline void match(vector<size_t>& ids, string_view sv, size_t lenWord) {\\n      auto fail = &root;\\n      for (size_t i = 0; i != sv.size(); ++i) {\\n        auto key = sv[i] - \\'a\\';\\n        while (fail != &root && !fail->child[key])\\n          fail = fail->fail;\\n        if (fail->child[key]) {\\n          fail = fail->child[key];\\n          if (fail->id)\\n            ids[i - lenWord + 1] = fail->id;\\n        }\\n      }\\n    }\\n\\n  private:\\n    unique_ptr<Node[]> nodes;\\n    unique_ptr<Node*[]> queue;\\n    Node root{};\\n    size_t nNode{};\\n  };\\npublic:\\n  vector<int> findSubstring(string text, vector<string>& words) {\\n    if (text.empty() || words.empty() || words[0].empty())\\n      return {};\\n    auto lenText = text.size();\\n    auto nWord = words.size();\\n    auto lenWord = words[0].size();\\n    auto lenPattern = nWord * lenWord;\\n    if (lenText < lenPattern)\\n      return {};\\n    vector<size_t> ids(text.size());\\n    vector<int> ctrDict;\\n    ctrDict.reserve(nWord);\\n    {\\n      AcAutomaton aca(nWord * lenWord);\\n      for (auto& word : words)\\n        aca.add(word, ctrDict);\\n      aca.build();\\n      aca.match(ids, text, lenWord);\\n    }\\n    auto nDistWord = ctrDict.size();\\n    vector<int> ctrText(nDistWord);\\n    vector<int> res;\\n    for (size_t i = 0; i < lenWord && i + lenPattern <= lenText; ++i) {\\n      fill(ctrText.begin(), ctrText.end(), 0);\\n      auto nMatchedDistWord = 0;\\n      for (size_t j = i; j < i + lenPattern; j += lenWord) {\\n        if (ids[j]) {\\n          auto idx = ids[j] - 1;\\n          if (ctrText[idx]++ == ctrDict[idx])\\n            --nMatchedDistWord;\\n          if (ctrText[idx] == ctrDict[idx])\\n            ++nMatchedDistWord;\\n        }\\n      }\\n      if (nMatchedDistWord == nDistWord)\\n        res.emplace_back(i);\\n      for (size_t j = i + lenPattern; j < lenText; j += lenWord) {\\n        if (ids[j]) {\\n          auto idx = ids[j] - 1;\\n          if (ctrText[idx]++ == ctrDict[idx])\\n            --nMatchedDistWord;\\n          if (ctrText[idx] == ctrDict[idx])\\n            ++nMatchedDistWord;\\n        }\\n        if (ids[j - lenPattern]) {\\n          auto idx = ids[j - lenPattern] - 1;\\n          if (ctrText[idx]-- == ctrDict[idx])\\n            --nMatchedDistWord;\\n          if (ctrText[idx] == ctrDict[idx])\\n            ++nMatchedDistWord;\\n        }\\n        if (nMatchedDistWord == nDistWord)\\n          res.emplace_back(j - lenPattern + lenWord);\\n      }\\n    }\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 315292,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n     \\n        List<Integer> ans = new ArrayList<>();\\n        if(words.length == 0) return ans;\\n        \\n        Map<String, Integer> t = new HashMap<>();\\n        for(String word : words)\\n            t.put(word, t.getOrDefault(word,0) +1);\\n        \\n        int k = words[0].length() * words.length;\\n        int inc = words[0].length();\\n        int n = s.length();\\n        \\n        \\n        for(int i=0; i< n-k+1; i++) { // Iterate through all windows\\n            Map<String, Integer> copy = new HashMap<String, Integer>(t);\\n            int counter = copy.size();\\n            for(int j =i; j < i+k ; j+=inc) { // For each window, check if  each word is in the hashmap.\\n                String word = s.substring(j,j+inc);\\n                if(copy.containsKey(word)) {\\n                    if(copy.get(word) == 1) counter--;\\n                    \\n                    copy.put(word,copy.get(word)-1);\\n                }\\n            }\\n            if(counter == 0) ans.add(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n     \\n        List<Integer> ans = new ArrayList<>();\\n        if(words.length == 0) return ans;\\n        \\n        Map<String, Integer> t = new HashMap<>();\\n        for(String word : words)\\n            t.put(word, t.getOrDefault(word,0) +1);\\n        \\n        int k = words[0].length() * words.length;\\n        int inc = words[0].length();\\n        int n = s.length();\\n        \\n        \\n        for(int i=0; i< n-k+1; i++) { // Iterate through all windows\\n            Map<String, Integer> copy = new HashMap<String, Integer>(t);\\n            int counter = copy.size();\\n            for(int j =i; j < i+k ; j+=inc) { // For each window, check if  each word is in the hashmap.\\n                String word = s.substring(j,j+inc);\\n                if(copy.containsKey(word)) {\\n                    if(copy.get(word) == 1) counter--;\\n                    \\n                    copy.put(word,copy.get(word)-1);\\n                }\\n            }\\n            if(counter == 0) ans.add(i);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 286590,
                "title": "java-9ms-slide-window-and-map-solution-with-detailed-explanation",
                "content": "This problem is similar to [3. Longest Substring Without Repeating Characters](https://leetcode.com/problems/longest-substring-without-repeating-characters/).  As mentioned in the title, we can use slide window and hashmap to solve the problem. The key though is sliding by a **word** instead of a **character**.\\n\\nThe slide window includes three parameters:\\n1. ```begin``` denotes the begin index of current window\\n2. ```current``` denotes the frequency of words contained in the current window\\n3. ```size``` denotes the number of words contained in current window\\n\\n```\\npublic List<Integer> findSubstring(String s, String[] words) {\\n    List<Integer> resultList = new ArrayList<Integer>();\\n    if( s == null || s.length() < 1 || words.length < 1)\\n        return resultList;\\n\\t\\t\\n    Map<String, Integer> wordToFreq = new HashMap<String, Integer>();\\n    for(int i = 0; i < words.length; i++) {\\n        wordToFreq.put(words[i], wordToFreq.getOrDefault(words[i], 0) + 1);\\n    }\\n\\t\\n    int length = words[0].length();\\n    String str[] = new String[s.length()];\\n    for(int i = 0; i < length; i++) { \\n\\t\\t// initialize slide window\\n        int begin = i;\\n        Map<String, Integer> current = new HashMap<String, Integer>();\\n        int size = 0;\\t\\n\\t\\t\\n        for(int j = i; j <= s.length() - length; j += length) { // slide by the length of word\\n            str[j] = s.substring(j, j + length);\\n            if( wordToFreq.containsKey(str[j]) ) { // update slide window\\n                begin = begin == -1 ? j : begin;\\n                current.put(str[j], current.getOrDefault(str[j], 0) + 1);\\n                size++;\\n                if( size == words.length ) {\\n                    if( current.equals(wordToFreq) )\\n                        resultList.add(begin);\\n                    current.put(str[begin], current.get(str[begin]) - 1);\\n                    size--;\\n                    begin += length;\\n                }\\n            } else { // reset the slide window\\n                begin = -1;\\n                current.clear();\\n                size = 0;\\n            }\\n        }\\n    }\\n    return resultList;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```begin```\n```current```\n```size```\n```\\npublic List<Integer> findSubstring(String s, String[] words) {\\n    List<Integer> resultList = new ArrayList<Integer>();\\n    if( s == null || s.length() < 1 || words.length < 1)\\n        return resultList;\\n\\t\\t\\n    Map<String, Integer> wordToFreq = new HashMap<String, Integer>();\\n    for(int i = 0; i < words.length; i++) {\\n        wordToFreq.put(words[i], wordToFreq.getOrDefault(words[i], 0) + 1);\\n    }\\n\\t\\n    int length = words[0].length();\\n    String str[] = new String[s.length()];\\n    for(int i = 0; i < length; i++) { \\n\\t\\t// initialize slide window\\n        int begin = i;\\n        Map<String, Integer> current = new HashMap<String, Integer>();\\n        int size = 0;\\t\\n\\t\\t\\n        for(int j = i; j <= s.length() - length; j += length) { // slide by the length of word\\n            str[j] = s.substring(j, j + length);\\n            if( wordToFreq.containsKey(str[j]) ) { // update slide window\\n                begin = begin == -1 ? j : begin;\\n                current.put(str[j], current.getOrDefault(str[j], 0) + 1);\\n                size++;\\n                if( size == words.length ) {\\n                    if( current.equals(wordToFreq) )\\n                        resultList.add(begin);\\n                    current.put(str[begin], current.get(str[begin]) - 1);\\n                    size--;\\n                    begin += length;\\n                }\\n            } else { // reset the slide window\\n                begin = -1;\\n                current.clear();\\n                size = 0;\\n            }\\n        }\\n    }\\n    return resultList;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 218762,
                "title": "10-line-python-solution",
                "content": "```\\nclass Solution:\\n    def findSubstring(self, s, words):\\n        if not words: return []\\n        m, n, o, target = len(s), len(words), len(words[0]), []\\n        for i in range(m-n*o+1):\\n            word_target = words[:]\\n            for k in range(n):\\n                word = s[i+k*o:i+k*o+o]\\n                if word in word_target: word_target.remove(word)\\n                else: break\\n            if not word_target: target.append(i)\\n        return target\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s, words):\\n        if not words: return []\\n        m, n, o, target = len(s), len(words), len(words[0]), []\\n        for i in range(m-n*o+1):\\n            word_target = words[:]\\n            for k in range(n):\\n                word = s[i+k*o:i+k*o+o]\\n                if word in word_target: word_target.remove(word)\\n                else: break\\n            if not word_target: target.append(i)\\n        return target\\n```",
                "codeTag": "Java"
            },
            {
                "id": 192123,
                "title": "o-n-c-solution-8ms-beats-100",
                "content": "Basic idea is that you hash each word and sum the results. Then you can do a sliding window over the string (backwards) to see if you can match the hash. An additional optimization is present to achieve O(n) when looping over the string - rather than re-calculating the hash for every letter, we iterate using a stride of wordlength, drop the least recently hashed entry, and add the new entry. We need to repeat this wordlength times to ensure we match patterns with offsets not equal to wordlength.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> retVal;\\n        if (words.size()<1 || s.size()<1) return retVal;\\n        // Hash all the words seperately then add them together to get a magic number\\n        std::hash<std::string> hash_fn;\\n        size_t magicNumber = 0;\\n        for (int i=0; i<words.size(); i++) {\\n            magicNumber += hash_fn(words[i]);\\n        }\\n        int wordLength = words[0].size();\\n        // Concatenated substring will be a given length\\n        int minimumSize = words.size()*wordLength;\\n        // We do a sliding window calculation for each \\'offset\\' a pattern might have\\n        // This is faster than re-hashing the entire window because we can just drop the least recently hashed value\\n        for (int startOffset=0; startOffset<wordLength; startOffset++) {\\n            int i;\\n            size_t hashSum = 0;\\n            int minimum = 0LL-minimumSize-startOffset+s.size();\\n            // This means that the requested offset does not leave us with enough characters in the string!\\n            if (minimum < 0) return retVal;\\n            for (i=s.size()-startOffset-wordLength; i>=minimum; i-=wordLength) {\\n                hashSum+=hash_fn(s.substr(i,wordLength));\\n            }\\n            if (hashSum==magicNumber) retVal.push_back(i+wordLength);\\n            for (;i>=0; i-=wordLength) {\\n                hashSum-=hash_fn(s.substr(i+minimumSize,wordLength));\\n                hashSum+=hash_fn(s.substr(i,wordLength));\\n                if (hashSum==magicNumber) retVal.push_back(i);\\n            }\\n        }        \\n        return retVal;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> retVal;\\n        if (words.size()<1 || s.size()<1) return retVal;\\n        // Hash all the words seperately then add them together to get a magic number\\n        std::hash<std::string> hash_fn;\\n        size_t magicNumber = 0;\\n        for (int i=0; i<words.size(); i++) {\\n            magicNumber += hash_fn(words[i]);\\n        }\\n        int wordLength = words[0].size();\\n        // Concatenated substring will be a given length\\n        int minimumSize = words.size()*wordLength;\\n        // We do a sliding window calculation for each \\'offset\\' a pattern might have\\n        // This is faster than re-hashing the entire window because we can just drop the least recently hashed value\\n        for (int startOffset=0; startOffset<wordLength; startOffset++) {\\n            int i;\\n            size_t hashSum = 0;\\n            int minimum = 0LL-minimumSize-startOffset+s.size();\\n            // This means that the requested offset does not leave us with enough characters in the string!\\n            if (minimum < 0) return retVal;\\n            for (i=s.size()-startOffset-wordLength; i>=minimum; i-=wordLength) {\\n                hashSum+=hash_fn(s.substr(i,wordLength));\\n            }\\n            if (hashSum==magicNumber) retVal.push_back(i+wordLength);\\n            for (;i>=0; i-=wordLength) {\\n                hashSum-=hash_fn(s.substr(i+minimumSize,wordLength));\\n                hashSum+=hash_fn(s.substr(i,wordLength));\\n                if (hashSum==magicNumber) retVal.push_back(i);\\n            }\\n        }        \\n        return retVal;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 124256,
                "title": "clean-code-in-java-beats-100",
                "content": "```\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        List<Integer> indices = new ArrayList<>();\\n        if (words.length == 0) {\\n            return indices;\\n        }\\n        //Put each word into a HashMap and calculate word frequency\\n        Map<String, Integer> wordMap = new HashMap<>();\\n        for (String word : words) {\\n            wordMap.put(word, wordMap.getOrDefault(word, 0) + 1);\\n        }\\n        int wordLength = words[0].length();\\n        int window = words.length * wordLength;\\n        for (int i = 0; i < wordLength; i++) {\\n            //move a word\\'s length each time\\n            for (int j = i; j + window <= s.length(); j = j + wordLength) {\\n                //get the subStr\\n                String subStr = s.substring(j, j + window);\\n                Map<String, Integer> map = new HashMap<>();\\n                //start from the last word\\n                for (int k = words.length - 1; k >= 0 ; k--) {\\n                    //get the word from subStr\\n                    String word = subStr.substring(k * wordLength, (k + 1)* wordLength);\\n                    int count = map.getOrDefault(word, 0) + 1;\\n                    //if the num of the word is greater than wordMap\\'s, move (k * wordLength) and break\\n                    if (count > wordMap.getOrDefault(word, 0)) {\\n                        j = j + k * wordLength;\\n                        break;\\n                    } else if (k == 0){\\n                        indices.add(j);\\n                    } else {\\n                        map.put(word, count);\\n                    }\\n                }\\n            }\\n\\n        }\\n        return indices;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        List<Integer> indices = new ArrayList<>();\\n        if (words.length == 0) {\\n            return indices;\\n        }\\n        //Put each word into a HashMap and calculate word frequency\\n        Map<String, Integer> wordMap = new HashMap<>();\\n        for (String word : words) {\\n            wordMap.put(word, wordMap.getOrDefault(word, 0) + 1);\\n        }\\n        int wordLength = words[0].length();\\n        int window = words.length * wordLength;\\n        for (int i = 0; i < wordLength; i++) {\\n            //move a word\\'s length each time\\n            for (int j = i; j + window <= s.length(); j = j + wordLength) {\\n                //get the subStr\\n                String subStr = s.substring(j, j + window);\\n                Map<String, Integer> map = new HashMap<>();\\n                //start from the last word\\n                for (int k = words.length - 1; k >= 0 ; k--) {\\n                    //get the word from subStr\\n                    String word = subStr.substring(k * wordLength, (k + 1)* wordLength);\\n                    int count = map.getOrDefault(word, 0) + 1;\\n                    //if the num of the word is greater than wordMap\\'s, move (k * wordLength) and break\\n                    if (count > wordMap.getOrDefault(word, 0)) {\\n                        j = j + k * wordLength;\\n                        break;\\n                    } else if (k == 0){\\n                        indices.add(j);\\n                    } else {\\n                        map.put(word, count);\\n                    }\\n                }\\n            }\\n\\n        }\\n        return indices;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 13697,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Substring with Concatenation of All Words** https://leetcode.com/problems/substring-with-concatenation-of-all-words/\\n\\n**Two Pointer Sliding Window**\\n* Say length of each word is wl and we have wc words. total_len of substring = wl * wc\\n* Two pointer sliding window solution. Initialize a window [start, end] = [0, total_len-1]\\n* Now we slide through s and capture every substring. We then test if this substring is valid and meets our conditions.\\n* We prepare a frequency map of input words. We call it ctr.\\n* We initialize a dictionary called seen.\\n* Now we pick every word (called next_word) sequentially in our window. Note there will be only wc words each of length wl.\\n* If next_word is not in ctr then we know the window is invalid. If it is, but the frequency in seen is already equal to the frequency in ctr, then we know we have an extra occurence of this word in the window and the window is invalid. Otherwise, we increment its frequency in seen.\\n* If every word in this window is valid, then the entire window is valid.\\n* Time complexity: (len(s) - wl * wc) * wc or number_of_windows * words_per_window\\n* Space complexity: O(wc) + O(wc)\\n```\\nfrom collections import Counter, defaultdict\\nclass Solution(object):\\n    def test(self, sub_str, word_len, ctr):\\n        i, seen = 0, defaultdict(int)\\n        while i < len(sub_str):\\n            next_word = sub_str[i:i+word_len]\\n            if next_word not in ctr or seen[next_word] == ctr[next_word]:\\n                return False\\n            seen[next_word], i = seen[next_word] + 1, i+word_len\\n        return True\\n    \\n    def findSubstring(self, s, words):\\n        \"\"\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        start, end, result = 0, len(words)*len(words[0])-1, []\\n        ctr = Counter(words)\\n        while end < len(s):\\n            if self.test(s[start:end+1], len(words[0]), ctr):\\n                result.append(start)\\n            start, end = start+1, end+1\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter, defaultdict\\nclass Solution(object):\\n    def test(self, sub_str, word_len, ctr):\\n        i, seen = 0, defaultdict(int)\\n        while i < len(sub_str):\\n            next_word = sub_str[i:i+word_len]\\n            if next_word not in ctr or seen[next_word] == ctr[next_word]:\\n                return False\\n            seen[next_word], i = seen[next_word] + 1, i+word_len\\n        return True\\n    \\n    def findSubstring(self, s, words):\\n        \"\"\"\\n        :type s: str\\n        :type words: List[str]\\n        :rtype: List[int]\\n        \"\"\"\\n        start, end, result = 0, len(words)*len(words[0])-1, []\\n        ctr = Counter(words)\\n        while end < len(s):\\n            if self.test(s[start:end+1], len(words[0]), ctr):\\n                result.append(start)\\n            start, end = start+1, end+1\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 13781,
                "title": "time-limit-exceed",
                "content": "    public class Solution {\\n        public List<Integer> findSubstring(String s, String[] words) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if (words == null || words.length == 0) {\\n                return result;\\n            }\\n            \\n            HashMap<String, Integer> wordLeft = new HashMap<String, Integer>();\\n            HashMap<String, Integer> wordFind = new HashMap<String, Integer>();\\n            \\n            for (String word : words) {\\n                if (!wordLeft.containsKey(word)) {\\n                    wordLeft.put(word, 1);\\n                }\\n                else {\\n                    wordLeft.put(word, wordLeft.get(word) + 1);\\n                }\\n            }\\n            \\n            int nWords = words.length, wordLength = words[0].length();\\n            for (int i = 0; i <= s.length() - nWords*wordLength; i++) {\\n                wordFind.clear();\\n                int j = 0;\\n                for (j = 0; j < nWords; j++) {\\n                    String sub = s.substring(i + j*wordLength, i + (j + 1)*wordLength);\\n                    if (!wordLeft.containsKey(sub)) break;\\n                    \\n                    if (!wordFind.containsKey(sub)) {\\n                        wordFind.put(sub,1);\\n                    }\\n                    else {\\n                        wordFind.put(sub, wordFind.get(sub) + 1);\\n                    }\\n                    \\n                    if (wordFind.get(sub) > wordLeft.get(sub)) break;\\n                }\\n                \\n                if (j == nWords) result.add(i);\\n            }\\n            \\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public List<Integer> findSubstring(String s, String[] words) {\\n            List<Integer> result = new ArrayList<Integer>();\\n            if (words == null || words.length == 0) {\\n                return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 13789,
                "title": "concise-c-o-kn-solution-with-explanation-68-ms",
                "content": "After realizing this problem is a variant of \"Longest Substring Without Repeating Characters\" and \"Minimum Window Substring\", I finally found this can be solved in the same way.\\n<br>Just replace the single character comparison with string comparison and original algorithm still works!\\n<br>Here is the algorithm.<br>\\n1. Maintain a sliding window and its start position.<br>\\n2. If the window is full of words, push start position to result vector and move start position to the right by one word length.<br>\\n3. Memorize each occurrence for each word. When adding a word to the window, check if the start position needs to be adjusted. If start position needs to be changed, use the memorized word position to update the start position. <br>\\nFor example, given input = (\"baa\", {\"a\", \"b\"}). When we encounter the second 'a', we know the start position should be moved to index 2 as the memorized occurrence indicates previous 'a' appears in the index 1.\\n<br>\\n\\n    class Solution {\\n    public:\\n        vector<int> findSubstring(string s, vector<string>& words) {\\n            vector<int> result;\\n            if (s.empty() || words.empty()) {\\n                return result;\\n            }\\n            const int wordlen = (int) words[0].length();\\n            const int offset = ((int) words.size() - 1) * wordlen;\\n            const int slen = (int) s.length();\\n            int start = -1;\\n            unordered_map<string, int> word_count;\\n            unordered_map<string, vector<int>> word_pos;\\n            for (string word : words) {\\n                word_count[word]++;\\n            }\\n            for (int i = 0; i < wordlen; ++i) {\\n                start = -1;\\n                word_pos.clear();\\n                for (int j = i; j <= slen - wordlen; j += wordlen) {\\n                    string candidate = s.substr(j, wordlen);\\n                    auto iter = word_count.find(candidate);\\n                    if (iter == word_count.end()) {\\n                        start = -1;\\n                        word_pos.clear();\\n                    } else {\\n                        if (-1 == start) {\\n                            start = j;\\n                        }\\n                        auto positer = word_pos.find(candidate);\\n                        if (positer == word_pos.end()) {\\n                            positer = word_pos.insert({candidate, vector<int>()}).first;\\n                        }\\n                        positer->second.push_back(j);\\n                        if (positer->second.size() > iter->second) {\\n                            if (positer->second[0] >= start) {\\n                                start = positer->second[0] + wordlen;\\n                            }\\n                            positer->second.erase(positer->second.begin());\\n                        }\\n                        if (offset == j - start) {\\n                            result.push_back(start);\\n                            start += wordlen;\\n                        }\\n                    }\\n                }\\n            }\\n            return result;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> findSubstring(string s, vector<string>& words) {\\n            vector<int> result;\\n            if (s.empty() || words.empty()) {\\n                return result;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 13814,
                "title": "concise-c-solution",
                "content": "Idea is to store the occurrence of words in the dictionary in a hashtable and then try to construct a hashtable from the given string that will be equal to the constructed one from the dictionary\\n\\n    class Solution {\\n    public:\\n        vector<int> findSubstring(string s, vector<string>& W) {\\n            vector<int> R;\\n            if (W.empty() || W[0].empty() || W[0].size() > s.size()) return R;\\n            int n = W[0].size();\\n            unordered_map<string, int> H;\\n            for (string w : W) H[w]++;\\n            for (int i = 0; i + n * W.size() <= s.size(); ++i) {\\n                string c = s.substr(i, n);\\n                if (H.count(c) != 0) {\\n                    unordered_map<string, int> C;\\n                    for (int j = 0; j < W.size(); ++j) {\\n                        c = s.substr(i + j * n, n);\\n                        if (H.count(c) != 0) C[c]++;\\n                        else break;\\n                    }\\n                    \\n                    bool equals = true;\\n                    for (auto p : H) equals &= (C.count(p.first) != 0) && (C[p.first] == p.second);\\n                    if (equals) R.push_back(i);\\n                }\\n            }\\n            \\n            return R;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        vector<int> findSubstring(string s, vector<string>& W) {\\n            vector<int> R;\\n            if (W.empty() || W[0].empty() || W[0].size() > s.size()) return R;\\n            int n = W[0].size();\\n            unordered_map<string, int> H;\\n            for (string w : W) H[w]++;\\n            for (int i = 0; i + n * W.size() <= s.size(); ++i) {\\n                string c = s.substr(i, n);\\n                if (H.count(c) != 0) {\\n                    unordered_map<string, int> C;\\n                    for (int j = 0; j < W.size(); ++j) {\\n                        c = s.substr(i + j * n, n);\\n                        if (H.count(c) != 0) C[c]++;\\n                        else break;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 3881353,
                "title": "other-posts-give-tle-sliding-window-hash-map-time-o-nw-space-o-mw2-beats-95-76-74-40",
                "content": "I notice that a lot of solutions given by the community is not optimal or even get TLE. So I am contributing my solution here.\\n\\n# Notation\\nLet $n$ be length of s, $w$ be length of a word, $m$ be the number of words.\\n\\n# Observation\\n- It\\'s obvious that this is a fix-length sliding window problem\\n- The string of appropriate length ending at $i$th character extends the string ending at the $i-w$th character\\n\\n# Intuition and Approach\\n- Maintain a dictionary for each coset (or say index shift) (i.e., $i \\\\to i+w \\\\to i+2w \\\\dots$)\\n- For each endpoint $i$\\n\\t- update the dictionary in $O(w)$, the code speaks for itself\\n\\t- check if the condition is satisfied in $O(1)$\\n  \\n# Complexity\\n- Time complexity: $O(nw)$\\n- Space complexity: $O(mw^2)$\\nIf we use rolling string hash, the complexity can be further reduced to Time $O(n)$, space $O(mw)$\\n\\n# Code\\n```\\n// by Maxwill Lin, O(w) time O(mw^2) space, beats 95.76%/74.40%\\n// can use rolling hash to optimize to O(n) tine O(m) space (and becomes probabilistic algorithm)\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int n = s.size(), m = words.size(), w = words[0].size();\\n        unordered_map<string, int> dict;\\n        vector<int> ans;\\n        vector<unordered_map<string, int>> dp(w);\\n        vector<int> passes(w);\\n        for(auto &word: words) ++dict[word];\\n        for(int i = 0; i < n; ++i) {\\n            auto& cur = dp[i%w];\\n            auto& pass = passes[i%w];\\n            // add new word\\n            if(i >= w-1) {\\n                string curS = s.substr(i-w+1, w);\\n                if(dict.contains(curS)) {\\n                    if(++cur[curS] == dict[curS]) ++pass;\\n                }\\n            }\\n            // remove old word\\n            if(i >= (m+1)*w-1) {\\n                string preS = s.substr(i-(m+1)*w+1, w);\\n                if(dict.contains(preS)) {\\n                    if(--cur[preS] == dict[preS]-1) --pass;\\n                }\\n            }\\n            // check if satisfied\\n            if(pass == dict.size()) ans.emplace_back(i-m*w+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n// by Maxwill Lin, O(w) time O(mw^2) space, beats 95.76%/74.40%\\n// can use rolling hash to optimize to O(n) tine O(m) space (and becomes probabilistic algorithm)\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int n = s.size(), m = words.size(), w = words[0].size();\\n        unordered_map<string, int> dict;\\n        vector<int> ans;\\n        vector<unordered_map<string, int>> dp(w);\\n        vector<int> passes(w);\\n        for(auto &word: words) ++dict[word];\\n        for(int i = 0; i < n; ++i) {\\n            auto& cur = dp[i%w];\\n            auto& pass = passes[i%w];\\n            // add new word\\n            if(i >= w-1) {\\n                string curS = s.substr(i-w+1, w);\\n                if(dict.contains(curS)) {\\n                    if(++cur[curS] == dict[curS]) ++pass;\\n                }\\n            }\\n            // remove old word\\n            if(i >= (m+1)*w-1) {\\n                string preS = s.substr(i-(m+1)*w+1, w);\\n                if(dict.contains(preS)) {\\n                    if(--cur[preS] == dict[preS]-1) --pass;\\n                }\\n            }\\n            // check if satisfied\\n            if(pass == dict.size()) ans.emplace_back(i-m*w+1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3364752,
                "title": "python-sliding-window-solution-for-reference",
                "content": "1. First thing that comes in our minds is to generate all permutations\\nof the wordlist, store them in a hashmap, and do a sliding window on string \\'s\\'. This works but gives TLE . \\nHere is the code if anyone wants to take a look : \\n[BRUTE FORCE](https://leetcode.com/submissions/detail/925721567/) 151 / 178 test cases passed.\\n\\n3. But the act to generate all the permutations is suboptimal, \\nand will lead to T(n) ~ O(n!) or O(len(words)!)\\n\\n2. Now, since every word needs to be in our substring and every word has a same len. \\nFirst, we need to check every substing of \\'s\\'\\n2nd. This substring needs to have every word frm our wordlist\\n3rd. For this, we just count occurence of each word of our wordlist using a hashmap\\n4rd. In the substring , we check at the indexes in following order ( 0, wordlen, 2*wordlen, 3*wordlen ... ), because every word has the same length.\\n5th. And if we don\\'t have a word in  hashmap, the substring is invalid, if it is not invalid at any point, it was already totallen, so it contains all the occurence, we return True, and add the index to our result.\\n4. T(n) = O(len(s) * len(wordlist) )\\n( Every Substring of s )* \\n( Checking for each word in substring with slicing and hashing )\\n\\n5. Solution refernce [1](https://leetcode.com/problems/substring-with-concatenation-of-all-words/solutions/2418173/c-unordered-map-sliding-window-simple-easy-to-understand/)\\n# Code\\n```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:  \\n        hmap = Counter(words)\\n        wlen =len(words[0]) \\n        tlen = len(words)*wlen\\n        def checksubstr(substr,hmap):\\n            # every word is of same len, so we skip that amount \\n            for i in range(0,len(substr),wlen):\\n                if(hmap[substr[i:i+wlen]] != 0 ):\\n                    hmap[substr[i:i+wlen]] -= 1\\n                else:\\n                    return False\\n            return True \\n        res = []\\n        start = 0 ;\\n        for i in range(tlen,len(s)+1):\\n            if( checksubstr(s[start:i] , copy.deepcopy(hmap) ) ):\\n                res.append(start)\\n            start += 1\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:  \\n        hmap = Counter(words)\\n        wlen =len(words[0]) \\n        tlen = len(words)*wlen\\n        def checksubstr(substr,hmap):\\n            # every word is of same len, so we skip that amount \\n            for i in range(0,len(substr),wlen):\\n                if(hmap[substr[i:i+wlen]] != 0 ):\\n                    hmap[substr[i:i+wlen]] -= 1\\n                else:\\n                    return False\\n            return True \\n        res = []\\n        start = 0 ;\\n        for i in range(tlen,len(s)+1):\\n            if( checksubstr(s[start:i] , copy.deepcopy(hmap) ) ):\\n                res.append(start)\\n            start += 1\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926750,
                "title": "java-sliding-window-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        List<Integer> answer = new ArrayList<>();\\n        \\n        int wordLength = words[0].length();\\n        int concatenatedStringLength = words.length * wordLength;\\n\\n        if(s.length() < concatenatedStringLength) return answer;\\n        \\n        Map<String, Integer> freqMap = new HashMap<>();\\n        for(String word: words) {\\n            freqMap.put(word, freqMap.getOrDefault(word, 0) + 1); \\n        }\\n\\n        for(int i=0;i<=s.length()-concatenatedStringLength;i++) {\\n            Map<String, Integer> tempMap = new HashMap<>();\\n            boolean found = true;\\n            for(int j=i; j < i + concatenatedStringLength; j+=wordLength) {\\n                String substr = s.substring(j, j+wordLength);\\n                if(!freqMap.containsKey(substr)) {\\n                    found = false;\\n                    break;\\n                }\\n                tempMap.put(substr, tempMap.getOrDefault(substr, 0) + 1);\\n            }\\n\\n            if(found) {\\n                for(Map.Entry<String, Integer> entry: tempMap.entrySet()) {\\n                    if(entry.getValue().intValue() != freqMap.get(entry.getKey()).intValue()) {\\n                        found = false;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            if(found) answer.add(i);\\n        }\\n        return answer;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        List<Integer> answer = new ArrayList<>();\\n        \\n        int wordLength = words[0].length();\\n        int concatenatedStringLength = words.length * wordLength;\\n\\n        if(s.length() < concatenatedStringLength) return answer;\\n        \\n        Map<String, Integer> freqMap = new HashMap<>();\\n        for(String word: words) {\\n            freqMap.put(word, freqMap.getOrDefault(word, 0) + 1); \\n        }\\n\\n        for(int i=0;i<=s.length()-concatenatedStringLength;i++) {\\n            Map<String, Integer> tempMap = new HashMap<>();\\n            boolean found = true;\\n            for(int j=i; j < i + concatenatedStringLength; j+=wordLength) {\\n                String substr = s.substring(j, j+wordLength);\\n                if(!freqMap.containsKey(substr)) {\\n                    found = false;\\n                    break;\\n                }\\n                tempMap.put(substr, tempMap.getOrDefault(substr, 0) + 1);\\n            }\\n\\n            if(found) {\\n                for(Map.Entry<String, Integer> entry: tempMap.entrySet()) {\\n                    if(entry.getValue().intValue() != freqMap.get(entry.getKey()).intValue()) {\\n                        found = false;\\n                        break;\\n                    }\\n                }\\n            }\\n\\n            if(found) answer.add(i);\\n        }\\n        return answer;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2833905,
                "title": "java-hashmap-83-memory-solution",
                "content": "# Code\\n```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int len = 0, wordLength = words[0].length();\\n        for (String word : words) {\\n            if (map.containsKey(word)) {\\n                map.put(word, map.get(word) + 1);\\n            } else {\\n                map.put(word, 1);\\n            }\\n            len += word.length();\\n        }\\n\\n        List<Integer> indices = new ArrayList<>();\\n        int times = s.length() - len;\\n        for (int i = 0; i <= times; i++) {\\n            if (map.isEmpty()) {\\n                for (String word : words) {\\n                    if (map.containsKey(word)) {\\n                        map.put(word, map.get(word) + 1);\\n                    } else {\\n                        map.put(word, 1);\\n                    }\\n                }\\n            }\\n            String sub = s.substring(i, i + len);\\n            int count = 0;\\n            while (count < words.length) {\\n                String word = sub.substring(0, wordLength);\\n                Integer freq = map.get(word);\\n                if (freq != null && freq > 0) {\\n                    map.put(word, freq - 1);\\n                    sub = sub.substring(wordLength);\\n                    count++;\\n                } else break;\\n            }\\n            if (count == words.length) {\\n                indices.add(i);\\n            }\\n            map.clear();\\n        }\\n        return indices;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        Map<String, Integer> map = new HashMap<>();\\n        int len = 0, wordLength = words[0].length();\\n        for (String word : words) {\\n            if (map.containsKey(word)) {\\n                map.put(word, map.get(word) + 1);\\n            } else {\\n                map.put(word, 1);\\n            }\\n            len += word.length();\\n        }\\n\\n        List<Integer> indices = new ArrayList<>();\\n        int times = s.length() - len;\\n        for (int i = 0; i <= times; i++) {\\n            if (map.isEmpty()) {\\n                for (String word : words) {\\n                    if (map.containsKey(word)) {\\n                        map.put(word, map.get(word) + 1);\\n                    } else {\\n                        map.put(word, 1);\\n                    }\\n                }\\n            }\\n            String sub = s.substring(i, i + len);\\n            int count = 0;\\n            while (count < words.length) {\\n                String word = sub.substring(0, wordLength);\\n                Integer freq = map.get(word);\\n                if (freq != null && freq > 0) {\\n                    map.put(word, freq - 1);\\n                    sub = sub.substring(wordLength);\\n                    count++;\\n                } else break;\\n            }\\n            if (count == words.length) {\\n                indices.add(i);\\n            }\\n            map.clear();\\n        }\\n        return indices;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2812038,
                "title": "c-simple-solution",
                "content": "\\n\\n# Code\\n```\\n    public class Solution\\n    {\\n        public IList<int> FindSubstring(string s, string[] words)\\n        {\\n            int oneWordLength = words[0].Length;\\n            int permLength = words.Length * oneWordLength;\\n            var result = new List<int>();\\n\\n            int sLength = s.Length;\\n\\n            for (int i = 0; i <= sLength - permLength; i++)\\n            {\\n                string temp = s.Substring(i, permLength);\\n                if (IsPerm(temp, words, oneWordLength, permLength))\\n                {\\n                    result.Add(i);\\n                }\\n            }\\n            return result;\\n        }\\n\\n        private bool IsPerm(string s, string[] words, int oneWordLength, int permLength)\\n        {\\n            bool result = true;\\n            int num = permLength / oneWordLength;\\n            List<string> wordList = words.ToList();\\n\\n            for (int i = 0; i < num; i++)\\n            {\\n                int index = i * oneWordLength;\\n                string temp = s.Substring(index, oneWordLength);\\n                if (!wordList.Contains(temp))\\n                {\\n                    result = false;\\n                    break;\\n                }\\n                else\\n                {\\n                    wordList.Remove(temp);\\n                }\\n            }\\n\\n            return result;\\n        }\\n    }\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n    public class Solution\\n    {\\n        public IList<int> FindSubstring(string s, string[] words)\\n        {\\n            int oneWordLength = words[0].Length;\\n            int permLength = words.Length * oneWordLength;\\n            var result = new List<int>();\\n\\n            int sLength = s.Length;\\n\\n            for (int i = 0; i <= sLength - permLength; i++)\\n            {\\n                string temp = s.Substring(i, permLength);\\n                if (IsPerm(temp, words, oneWordLength, permLength))\\n                {\\n                    result.Add(i);\\n                }\\n            }\\n            return result;\\n        }\\n\\n        private bool IsPerm(string s, string[] words, int oneWordLength, int permLength)\\n        {\\n            bool result = true;\\n            int num = permLength / oneWordLength;\\n            List<string> wordList = words.ToList();\\n\\n            for (int i = 0; i < num; i++)\\n            {\\n                int index = i * oneWordLength;\\n                string temp = s.Substring(index, oneWordLength);\\n                if (!wordList.Contains(temp))\\n                {\\n                    result = false;\\n                    break;\\n                }\\n                else\\n                {\\n                    wordList.Remove(temp);\\n                }\\n            }\\n\\n            return result;\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2713095,
                "title": "using-memoization",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom functools import reduce\\nimport textwrap\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        # Dynamic Programming: Recursion, Memoize* & Bottom-Up Approach\\n\\n        # get the length of each word in `words`\\n        word_length = len(words[0])\\n        # get the total length of the concatenated words as `nth`\\n        total_words_length = word_length * len(words)\\n\\n        # word_dict = {}\\n\\n        # # make hashmap of words\\n        # for k in range(len(words)):\\n        #     word_dict[words[k]] = 0\\n\\n        # traverse through the string and get each `nt` clips:\\n\\n        result_indexes = []\\n\\n        memo = []\\n\\n        for i in range(len(s)):\\n            # divide them equally and check if everyone of them fit equally to words\\n            search = s[i:total_words_length+i]\\n\\n            if len(search) == total_words_length:\\n                # [Keep a hashmap of the count of each words, if not satifisfied, change all back to 0]\\n                if search in memo:\\n                    result_indexes.append(i)\\n                else:\\n                    # sorted `words`\\n                    _words = sorted(words)\\n                    _test_words = sorted(textwrap.wrap(search, word_length))\\n\\n                    if _words == _test_words:\\n                        memo.append(search)\\n                        result_indexes.append(i)\\n\\n        return result_indexes\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom functools import reduce\\nimport textwrap\\n\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        # Dynamic Programming: Recursion, Memoize* & Bottom-Up Approach\\n\\n        # get the length of each word in `words`\\n        word_length = len(words[0])\\n        # get the total length of the concatenated words as `nth`\\n        total_words_length = word_length * len(words)\\n\\n        # word_dict = {}\\n\\n        # # make hashmap of words\\n        # for k in range(len(words)):\\n        #     word_dict[words[k]] = 0\\n\\n        # traverse through the string and get each `nt` clips:\\n\\n        result_indexes = []\\n\\n        memo = []\\n\\n        for i in range(len(s)):\\n            # divide them equally and check if everyone of them fit equally to words\\n            search = s[i:total_words_length+i]\\n\\n            if len(search) == total_words_length:\\n                # [Keep a hashmap of the count of each words, if not satifisfied, change all back to 0]\\n                if search in memo:\\n                    result_indexes.append(i)\\n                else:\\n                    # sorted `words`\\n                    _words = sorted(words)\\n                    _test_words = sorted(textwrap.wrap(search, word_length))\\n\\n                    if _words == _test_words:\\n                        memo.append(search)\\n                        result_indexes.append(i)\\n\\n        return result_indexes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419625,
                "title": "c-hashmap-easy-to-follow",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> v;\\n        unordered_map<string,int> m;\\n        for(auto x:words)\\n            m[x]++;\\n        \\n        int l=words[0].length();\\n        int len=words.size()*l;\\n        len=s.length()-len;\\n        if(len<0)// none is possible\\n            return v;\\n        for(int i=0;i<=len;i++)\\n        {\\n            unordered_map<string,int> mp=m;\\n            int c=0;\\n            for(int j=i;j<s.size();j+=l)\\n            {\\n                string x=s.substr(j,l);\\n                if(mp[x]>0)\\n                {\\n                    c++;\\n                    mp[x]--;\\n                }\\n                else\\n                    break;\\n            }\\n            if(c==words.size())\\n                v.push_back(i);\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n\\nRecursive Method ( Faster then above ) : \\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> v;\\n        unordered_map<string,int> m;\\n        for(auto x:words)\\n            m[x]++;\\n        \\n        int l=words[0].length();\\n        int len=words.size()*l;\\n        int temp=s.length()-len;\\n        if(len<0)// none is possible\\n            return v;\\n        for(int i=0;i<=temp;i++)\\n        {\\n            int c=fun(s,m,i,i+len,l);\\n            if(c==words.size())\\n                v.push_back(i);\\n        }\\n        return v;\\n    }\\n    int fun(string& s,unordered_map<string,int>& m,int i,int len,int l)\\n    {\\n        if(i==len)\\n            return 0;\\n        \\n        string x=s.substr(i,l);\\n        int t;\\n        if(m.find(x)!=m.end() && m[x]>0)\\n        {\\n            m[x]--;\\n            t=1+fun(s,m,i+l,len,l);\\n            m[x]++;\\n        }\\n        else\\n            t=0;\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> v;\\n        unordered_map<string,int> m;\\n        for(auto x:words)\\n            m[x]++;\\n        \\n        int l=words[0].length();\\n        int len=words.size()*l;\\n        len=s.length()-len;\\n        if(len<0)// none is possible\\n            return v;\\n        for(int i=0;i<=len;i++)\\n        {\\n            unordered_map<string,int> mp=m;\\n            int c=0;\\n            for(int j=i;j<s.size();j+=l)\\n            {\\n                string x=s.substr(j,l);\\n                if(mp[x]>0)\\n                {\\n                    c++;\\n                    mp[x]--;\\n                }\\n                else\\n                    break;\\n            }\\n            if(c==words.size())\\n                v.push_back(i);\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int> v;\\n        unordered_map<string,int> m;\\n        for(auto x:words)\\n            m[x]++;\\n        \\n        int l=words[0].length();\\n        int len=words.size()*l;\\n        int temp=s.length()-len;\\n        if(len<0)// none is possible\\n            return v;\\n        for(int i=0;i<=temp;i++)\\n        {\\n            int c=fun(s,m,i,i+len,l);\\n            if(c==words.size())\\n                v.push_back(i);\\n        }\\n        return v;\\n    }\\n    int fun(string& s,unordered_map<string,int>& m,int i,int len,int l)\\n    {\\n        if(i==len)\\n            return 0;\\n        \\n        string x=s.substr(i,l);\\n        int t;\\n        if(m.find(x)!=m.end() && m[x]>0)\\n        {\\n            m[x]--;\\n            t=1+fun(s,m,i+l,len,l);\\n            m[x]++;\\n        }\\n        else\\n            t=0;\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2419096,
                "title": "c-hashmap-sliding-window",
                "content": "**Approach: Sliding Window + Hashmap**\\n**Steps:**\\n1. Insert the word counts into a hahsmap.\\n2. Iterate through every substring `str` in `s` with size `len`.\\n3. Use `l` and `r` to keep track on the starting and ending index.\\n4. If  `str` in `hashmap` is greater than 0,  `str` can be used for concatenation. Set `str` to in used by decreasing the count of `str` in hashmap. \\n3. If `str` in `hashmap` is 0, the `str` might be already in used. Remove the substring starting from `l` until the `str` is not in used. If still `str` in `hashmap` is 0, `str` is not a string in `words`. Move to next iteration.\\n5. Add `l` to the result when the window size `r - l` is equals to  `number of word * length of word`. \\n\\n**Example:**\\nIf the length of word is 3, we can iterate through every substring in 3 iterations by changing the starting index to `0, 1 and 2`. \\n\\n1st iteration:\\n![image](https://assets.leetcode.com/users/images/612a06de-d098-4c5e-b9a0-5137e3b5d242_1660380232.6132529.png)\\n\\n2nd iteration:\\n![image](https://assets.leetcode.com/users/images/3cc8e0ce-661a-4e5a-a749-238fa6ceb16c_1660380274.0505571.png)\\n\\n3rd iteration:\\n![image](https://assets.leetcode.com/users/images/105ab42a-6c17-462d-b205-09399988f2e8_1660380293.1976612.png)\\n\\n**Code**\\n\\n```\\nvector<int> findSubstring(string s, vector<string>& words) {\\n    int len = words.front().size();\\n\\n    vector<int> res;\\n    for (int i = 0; i < len; i++) {\\n        unordered_map<string, int> counter;\\n        for (const string& s: words) counter[s]++;\\n\\n        for (int l = i, r = i + len; r <= s.size(); r += len) {\\n            const string& str = s.substr(r - len, len);\\n            while (counter[str] == 0 && l < r - len) {\\n                counter[s.substr(l, len)]++;\\n                l += len;\\n            }\\n\\n            if (counter[str] == 0) {\\n                l += len;\\n                continue;\\n            }\\n\\n            counter[str]--;\\n\\n            if (r - l == words.size() * len) {\\n                res.push_back(l);\\n            }\\n        }\\n    }\\n\\n    return res;\\n}\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nvector<int> findSubstring(string s, vector<string>& words) {\\n    int len = words.front().size();\\n\\n    vector<int> res;\\n    for (int i = 0; i < len; i++) {\\n        unordered_map<string, int> counter;\\n        for (const string& s: words) counter[s]++;\\n\\n        for (int l = i, r = i + len; r <= s.size(); r += len) {\\n            const string& str = s.substr(r - len, len);\\n            while (counter[str] == 0 && l < r - len) {\\n                counter[s.substr(l, len)]++;\\n                l += len;\\n            }\\n\\n            if (counter[str] == 0) {\\n                l += len;\\n                continue;\\n            }\\n\\n            counter[str]--;\\n\\n            if (r - l == words.size() * len) {\\n                res.push_back(l);\\n            }\\n        }\\n    }\\n\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2418838,
                "title": "c-best-soln-with-explanation",
                "content": "class Solution {\\npublic:\\n\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int>res;\\n        unordered_map<string,int>wmap;\\n        int slen = s.size();           //lenght of string(18)\\n        int noOfWord = words.size();   //no of word in word vector(2)\\n        int wordLen = words[0].size(); //length of a single word(3)\\n        int TotalWSize = noOfWord*wordLen;  //total word size(6)\\n        \\n        if(TotalWSize > slen)      //if the total word size is more than slen (6>18)\\n            return res;\\n        \\n        //word map wth all entry wmap[\"foo\":1, \"bar\":1]\\n        for(auto it:words)        \\n            wmap[it]++;\\n        \\n        for(int i=0;i<=slen-TotalWSize;i++){   //i<slen-TotalWSize this means i<18-6 / i<12\\n            //count of a freq in give length\\n            unordered_map<string,int>wfreq;\\n            for(int j=i;j<i+TotalWSize;j+=wordLen){ //taking the length of wordlen to jump\\n                string str = s.substr(j,wordLen);  //cal the sub string\\n                if(wmap.find(str)==wmap.end())   //if sub str is not present then break\\n                    break;\\n                wfreq[str]++;\\n                if(wfreq[str]>wmap[str])       //if str cnt is more than break \\n                        break;\\n            }\\n            if(wfreq == wmap)        //if we get all value same then add the start index\\n                res.push_back(i);\\n        }       \\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "class Solution {\\npublic:\\n\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int>res;\\n        unordered_map<string,int>wmap;\\n        int slen = s.size();           //lenght of string(18)\\n        int noOfWord = words.size();   //no of word in word vector(2)\\n        int wordLen = words[0].size(); //length of a single word(3)\\n        int TotalWSize = noOfWord*wordLen;  //total word size(6)\\n        \\n        if(TotalWSize > slen)      //if the total word size is more than slen (6>18)\\n            return res;\\n        \\n        //word map wth all entry wmap[\"foo\":1, \"bar\":1]\\n        for(auto it:words)        \\n            wmap[it]++;\\n        \\n        for(int i=0;i<=slen-TotalWSize;i++){   //i<slen-TotalWSize this means i<18-6 / i<12\\n            //count of a freq in give length\\n            unordered_map<string,int>wfreq;\\n            for(int j=i;j<i+TotalWSize;j+=wordLen){ //taking the length of wordlen to jump\\n                string str = s.substr(j,wordLen);  //cal the sub string\\n                if(wmap.find(str)==wmap.end())   //if sub str is not present then break\\n                    break;\\n                wfreq[str]++;\\n                if(wfreq[str]>wmap[str])       //if str cnt is more than break \\n                        break;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2418758,
                "title": "c-easy-explanation-sliding-window-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        int n = words[0].length(), ln = s.length();\\n        vector<int>m1(26, 0), m2(26, 0), ans;\\n        map<string, int>mapp;\\n        \\n        for(int i=0; i<words.size(); i++){\\n            string str = words[i];\\n            for(int j=0; j<n; j++){\\n                m1[str[j] - \\'a\\']++;   // just mapping all the character from words vector\\n            }\\n            mapp[str]++; // and also store just word into map\\n        } \\n        int k = n*words.size(); // length of the substring\\n        \\n        for(int i=0, j=0; i<ln; i++){\\n            m2[s[i] - \\'a\\']++;   //putting through the every character from s into m2 map\\n            \\n            if(i+1 >= k){\\n                if(m1 == m2){ // if the character map same  \\n                    string str = \"\";\\n                    map<string, int> mapp2;\\n                    for(int x = i-k+1; x<i+1; x++){ \\n                        str += s[x];\\n                        if(str.length() == n){ // then insert the word corresponding the m2 mapp with n(each word length) length\\n                            mapp2[str]++;\\n                            str.clear();\\n                        }\\n                    }\\n                    if(mapp == mapp2) ans.push_back(i-k+1); // then check if they are same or not\\n                }\\n                m2[s[j++] - \\'a\\']--; // every iteration removing the first character just slide the window\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        \\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0), cout.tie(0);\\n        \\n        int n = words[0].length(), ln = s.length();\\n        vector<int>m1(26, 0), m2(26, 0), ans;\\n        map<string, int>mapp;\\n        \\n        for(int i=0; i<words.size(); i++){\\n            string str = words[i];\\n            for(int j=0; j<n; j++){\\n                m1[str[j] - \\'a\\']++;   // just mapping all the character from words vector\\n            }\\n            mapp[str]++; // and also store just word into map\\n        } \\n        int k = n*words.size(); // length of the substring\\n        \\n        for(int i=0, j=0; i<ln; i++){\\n            m2[s[i] - \\'a\\']++;   //putting through the every character from s into m2 map\\n            \\n            if(i+1 >= k){\\n                if(m1 == m2){ // if the character map same  \\n                    string str = \"\";\\n                    map<string, int> mapp2;\\n                    for(int x = i-k+1; x<i+1; x++){ \\n                        str += s[x];\\n                        if(str.length() == n){ // then insert the word corresponding the m2 mapp with n(each word length) length\\n                            mapp2[str]++;\\n                            str.clear();\\n                        }\\n                    }\\n                    if(mapp == mapp2) ans.push_back(i-k+1); // then check if they are same or not\\n                }\\n                m2[s[j++] - \\'a\\']--; // every iteration removing the first character just slide the window\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2418466,
                "title": "finding-problem-statement-confusing-read-this",
                "content": "It took me some time to understand what exactly the problem meant.\\nSo adding some clarifications for anyone having similar confusion.\\n\\n_____________\\n\\n**Statement 1 :** You are given a string `s` and an array of strings `words` of the same length.\\n\\nThough \"you are given A & B of same length\" can mean lengths of A & B are same. It isn\\'t the case here.\\nThe \"same length\" in the statement means that all the words contained in `words` are of the same length.\\n\\n**Read it as :** You are given a string `s` and an array of strings `words` containing words of same lengths.\\n\\n_______________\\n\\n**Statement 2 :** Return all starting indices of substring(s) in `s` that is a concatenation of each word in `words` exactly once, in any order, and without any intervening characters.\\n\\nBy \"concatenation of each word in `words`\", it means that the substring should have all the words present in `words`.\\nNot only each word in the substring should be from `words` but also every word in `words` should be present in the substring.\\n\\n**Read it as :** Return all starting indices of substring(s) in `s` that is a concatenation of all the words in `words` exactly once, in any order, and without any intervening characters.",
                "solutionTags": [],
                "code": "It took me some time to understand what exactly the problem meant.\\nSo adding some clarifications for anyone having similar confusion.\\n\\n_____________\\n\\n**Statement 1 :** You are given a string `s` and an array of strings `words` of the same length.\\n\\nThough \"you are given A & B of same length\" can mean lengths of A & B are same. It isn\\'t the case here.\\nThe \"same length\" in the statement means that all the words contained in `words` are of the same length.\\n\\n**Read it as :** You are given a string `s` and an array of strings `words` containing words of same lengths.\\n\\n_______________\\n\\n**Statement 2 :** Return all starting indices of substring(s) in `s` that is a concatenation of each word in `words` exactly once, in any order, and without any intervening characters.\\n\\nBy \"concatenation of each word in `words`\", it means that the substring should have all the words present in `words`.\\nNot only each word in the substring should be from `words` but also every word in `words` should be present in the substring.\\n\\n**Read it as :** Return all starting indices of substring(s) in `s` that is a concatenation of all the words in `words` exactly once, in any order, and without any intervening characters.",
                "codeTag": "Unknown"
            },
            {
                "id": 2418397,
                "title": "c-strict-o-n-o-n-30-multiple-approaches-rolling-hash-sliding-window",
                "content": "Firstly we will see the O(N*30) approach and then later we will optimise it using rolling hash to get exact O(N) solution.\\n\\n```\\nclass Solution\\n{\\npublic:\\n    vector<int> findSubstring(string s, vector<string> &w)\\n    {\\n        int len = w[0].size(), n = w.size();\\n        int k = n * len, l = 0, r = 0;\\n        unordered_map<string, int> mp;\\n        string sub[s.size()];\\n        for (int i = 0; i < w.size(); i++)\\n            mp[w[i]]++;// add all the strings of the given list in the unordered map\\n        for (int i = 0; i < s.size() - len + 1; i++)\\n            sub[i] = s.substr(i, len);\\n        vector<int> v;\\n        for (int i = 0; i < min((int)s.size(), len); i++) // we will only start with index<len as remaining index will be coveered by sliding window\\n        {\\n            int l = i, r = i, cn = mp.size();   // cn variable will denote the count of strings remaining to be matched\\n            unordered_map<string, int> mps;\\n            if (i + k > s.size())\\n                break;\\n            while (r + len <= s.size())\\n            {\\n                mps[sub[r]]++;\\n                if (mp.count(sub[r]))\\n                {\\n                    if (mps[sub[r]] == mp[sub[r]])\\n                        cn--; // decrease the count only when both map have equal count of strings\\n                    while (mps[sub[r]] > mp[sub[r]]) // remove occurence of string from left until count of string is greater in current map\\n                    {\\n                        if (mps[sub[l]] == mp[sub[l]])\\n                            cn++; // increment the count only when both maps have same count of current string\\n                        mps[sub[l]]--;\\n                        l += len;\\n                    }\\n                    if (cn == 0)\\n                        v.push_back(l);\\n                    r += len;\\n                }\\n                else\\n                {   // if the string is not found in the word list then we will start our search from r+len\\n                    // as all index before r+len will also contain this given string\\n                    mps.clear();\\n                    cn = mp.size();\\n                    r += len;\\n                    l = r;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\nNow to optimise it, we will use the hash value of the strings which will reduce our solution to O(N).\\n\\nIn the **sub** array we will add the hash value of all the string and rest code will be the same.\\n**34ms Accepted**\\n\\n\\n```\\nclass Solution\\n{\\npublic:\\n    long long mod = 1e9 + 7, base = 17;\\n    int get(string &s) // this function returns the hashed value of the string\\n    {\\n        long long h = 0;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            h *= base;\\n            h += (s[i] - \\'a\\');\\n            h %= mod;\\n        }\\n        return h;\\n    }\\n    vector<int> findSubstring(string s, vector<string> &w)\\n    {\\n        int len = w[0].size(), n = w.size();\\n        int k = n * len;\\n        unordered_map<int, int> mp;\\n        int sub[s.size()];\\n        for (int i = 0; i < w.size(); i++)\\n            mp[get(w[i])]++;\\n        string ss = s.substr(0, len);\\n        long long bb = 1;\\n        for (int i = 0; i < len - 1; i++)\\n            bb *= base, bb %= mod;\\n        sub[0] = get(ss);\\n        for (int i = 1; i < s.size() - len + 1; i++)\\n        {\\n            sub[i] = sub[i - 1];\\n            long long x = (s[i - 1] - \\'a\\') * bb; // removing the previous char from hash\\n            x %= mod;\\n            sub[i] -= x;\\n            if (sub[i] < 0)\\n                sub[i] += mod;\\n            long long y = sub[i];\\n            y *= base;\\n            y %= mod;\\n            sub[i] = y;\\n            sub[i] += (s[i + len - 1] - \\'a\\'); // adding current character in the hash\\n            sub[i] %= mod;\\n        }\\n\\n        // this part is same as above\\n        vector<int> v;\\n        for (int i = 0; i < min((int)s.size(), len); i++)\\n        {\\n            int l = i, r = i, cn = mp.size();\\n            unordered_map<int, int> mps;\\n            if (i + k > s.size())\\n                break;\\n            while (r + len <= s.size())\\n            {\\n                mps[sub[r]]++;\\n                if (mp.count(sub[r]))\\n                {\\n                    if (mps[sub[r]] == mp[sub[r]])\\n                        cn--;\\n                    while (mps[sub[r]] > mp[sub[r]])\\n                    {\\n                        if (mps[sub[l]] == mp[sub[l]])\\n                            cn++;\\n                        mps[sub[l]]--;\\n                        l += len;\\n                    }\\n                    if (cn == 0)\\n                        v.push_back(l);\\n                    r += len;\\n                }\\n                else\\n                {\\n                    mps.clear();\\n                    cn = mp.size();\\n                    r += len;\\n                    l = r;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C",
                    "Sliding Window",
                    "Rolling Hash"
                ],
                "code": "```\\nclass Solution\\n{\\npublic:\\n    vector<int> findSubstring(string s, vector<string> &w)\\n    {\\n        int len = w[0].size(), n = w.size();\\n        int k = n * len, l = 0, r = 0;\\n        unordered_map<string, int> mp;\\n        string sub[s.size()];\\n        for (int i = 0; i < w.size(); i++)\\n            mp[w[i]]++;// add all the strings of the given list in the unordered map\\n        for (int i = 0; i < s.size() - len + 1; i++)\\n            sub[i] = s.substr(i, len);\\n        vector<int> v;\\n        for (int i = 0; i < min((int)s.size(), len); i++) // we will only start with index<len as remaining index will be coveered by sliding window\\n        {\\n            int l = i, r = i, cn = mp.size();   // cn variable will denote the count of strings remaining to be matched\\n            unordered_map<string, int> mps;\\n            if (i + k > s.size())\\n                break;\\n            while (r + len <= s.size())\\n            {\\n                mps[sub[r]]++;\\n                if (mp.count(sub[r]))\\n                {\\n                    if (mps[sub[r]] == mp[sub[r]])\\n                        cn--; // decrease the count only when both map have equal count of strings\\n                    while (mps[sub[r]] > mp[sub[r]]) // remove occurence of string from left until count of string is greater in current map\\n                    {\\n                        if (mps[sub[l]] == mp[sub[l]])\\n                            cn++; // increment the count only when both maps have same count of current string\\n                        mps[sub[l]]--;\\n                        l += len;\\n                    }\\n                    if (cn == 0)\\n                        v.push_back(l);\\n                    r += len;\\n                }\\n                else\\n                {   // if the string is not found in the word list then we will start our search from r+len\\n                    // as all index before r+len will also contain this given string\\n                    mps.clear();\\n                    cn = mp.size();\\n                    r += len;\\n                    l = r;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```\n```\\nclass Solution\\n{\\npublic:\\n    long long mod = 1e9 + 7, base = 17;\\n    int get(string &s) // this function returns the hashed value of the string\\n    {\\n        long long h = 0;\\n        for (int i = 0; i < s.size(); i++)\\n        {\\n            h *= base;\\n            h += (s[i] - \\'a\\');\\n            h %= mod;\\n        }\\n        return h;\\n    }\\n    vector<int> findSubstring(string s, vector<string> &w)\\n    {\\n        int len = w[0].size(), n = w.size();\\n        int k = n * len;\\n        unordered_map<int, int> mp;\\n        int sub[s.size()];\\n        for (int i = 0; i < w.size(); i++)\\n            mp[get(w[i])]++;\\n        string ss = s.substr(0, len);\\n        long long bb = 1;\\n        for (int i = 0; i < len - 1; i++)\\n            bb *= base, bb %= mod;\\n        sub[0] = get(ss);\\n        for (int i = 1; i < s.size() - len + 1; i++)\\n        {\\n            sub[i] = sub[i - 1];\\n            long long x = (s[i - 1] - \\'a\\') * bb; // removing the previous char from hash\\n            x %= mod;\\n            sub[i] -= x;\\n            if (sub[i] < 0)\\n                sub[i] += mod;\\n            long long y = sub[i];\\n            y *= base;\\n            y %= mod;\\n            sub[i] = y;\\n            sub[i] += (s[i + len - 1] - \\'a\\'); // adding current character in the hash\\n            sub[i] %= mod;\\n        }\\n\\n        // this part is same as above\\n        vector<int> v;\\n        for (int i = 0; i < min((int)s.size(), len); i++)\\n        {\\n            int l = i, r = i, cn = mp.size();\\n            unordered_map<int, int> mps;\\n            if (i + k > s.size())\\n                break;\\n            while (r + len <= s.size())\\n            {\\n                mps[sub[r]]++;\\n                if (mp.count(sub[r]))\\n                {\\n                    if (mps[sub[r]] == mp[sub[r]])\\n                        cn--;\\n                    while (mps[sub[r]] > mp[sub[r]])\\n                    {\\n                        if (mps[sub[l]] == mp[sub[l]])\\n                            cn++;\\n                        mps[sub[l]]--;\\n                        l += len;\\n                    }\\n                    if (cn == 0)\\n                        v.push_back(l);\\n                    r += len;\\n                }\\n                else\\n                {\\n                    mps.clear();\\n                    cn = mp.size();\\n                    r += len;\\n                    l = r;\\n                }\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418389,
                "title": "using-unordered-map-easy-to-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    bool found(unordered_map<string, int> ump, string curr, int wordsize)\\n    {\\n        for(int i = 0 ; i < curr.size() ; i+=wordsize)\\n        {\\n            if(!ump[curr.substr(i, wordsize)]) return false;\\n            ump[curr.substr(i, wordsize)]--;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int>indexes;\\n        unordered_map<string, int>ump;\\n        int no_of_words = words.size();\\n        int len_of_words = no_of_words*words[0].length();\\n        if(s.size() < len_of_words) return {};\\n        for(auto it : words) ump[it]++;\\n        \\n        for(int i = 0 ; i <= s.size()-len_of_words ; i++)\\n        {\\n            if(found(ump, s.substr(i, len_of_words), words[0].size())) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool found(unordered_map<string, int> ump, string curr, int wordsize)\\n    {\\n        for(int i = 0 ; i < curr.size() ; i+=wordsize)\\n        {\\n            if(!ump[curr.substr(i, wordsize)]) return false;\\n            ump[curr.substr(i, wordsize)]--;\\n        }\\n        return true;\\n    }\\n    \\n    \\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        vector<int>indexes;\\n        unordered_map<string, int>ump;\\n        int no_of_words = words.size();\\n        int len_of_words = no_of_words*words[0].length();\\n        if(s.size() < len_of_words) return {};\\n        for(auto it : words) ump[it]++;\\n        \\n        for(int i = 0 ; i <= s.size()-len_of_words ; i++)\\n        {\\n            if(found(ump, s.substr(i, len_of_words), words[0].size())) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2418376,
                "title": "sliding-window-aditya-verma-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<char, int>mp;\\n        unordered_map<string, int>chk;\\n        int totSize = 0;\\n        for(auto it: words){\\n            chk[it]++;\\n            for(auto ele: it){\\n                mp[ele]++;\\n                totSize++;\\n            }\\n        }\\n        int wordSize = words[0].size();\\n        vector<int>ans;\\n        int cnt = mp.size(), i = 0, j = 0, n = s.size(), m = words.size();\\n        while(j<s.size()){\\n            if(mp.find(s[j]) != mp.end()){\\n                mp[s[j]]--;\\n                if(mp[s[j]] == 0){\\n                    cnt--;\\n                }\\n            }\\n            if(cnt == 0){\\n                while(cnt == 0){\\n                    if(mp.find(s[i]) != mp.end()){\\n                        mp[s[i]]++;\\n                            if(mp[s[i]] == 1){\\n                            cnt++;\\n                            int size = j-i+1, yo = chk.size();\\n                            for(int k = i; k<= j; k++){\\n                                string temp = s.substr(k, wordSize);\\n                                k+=wordSize-1;\\n                                if(chk.find(temp) != chk.end()){\\n                                    chk[temp]--;\\n                                    if(chk[temp] == 0){\\n                                        yo--;\\n                                    }\\n                                }\\n                            }\\n                            if(yo == 0 && size == totSize){\\n                                ans.push_back(i);\\n                            }\\n                            chk.clear();\\n                            for(auto it: words){\\n                                chk[it]++;\\n                            }\\n                        }\\n                    }\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<char, int>mp;\\n        unordered_map<string, int>chk;\\n        int totSize = 0;\\n        for(auto it: words){\\n            chk[it]++;\\n            for(auto ele: it){\\n                mp[ele]++;\\n                totSize++;\\n            }\\n        }\\n        int wordSize = words[0].size();\\n        vector<int>ans;\\n        int cnt = mp.size(), i = 0, j = 0, n = s.size(), m = words.size();\\n        while(j<s.size()){\\n            if(mp.find(s[j]) != mp.end()){\\n                mp[s[j]]--;\\n                if(mp[s[j]] == 0){\\n                    cnt--;\\n                }\\n            }\\n            if(cnt == 0){\\n                while(cnt == 0){\\n                    if(mp.find(s[i]) != mp.end()){\\n                        mp[s[i]]++;\\n                            if(mp[s[i]] == 1){\\n                            cnt++;\\n                            int size = j-i+1, yo = chk.size();\\n                            for(int k = i; k<= j; k++){\\n                                string temp = s.substr(k, wordSize);\\n                                k+=wordSize-1;\\n                                if(chk.find(temp) != chk.end()){\\n                                    chk[temp]--;\\n                                    if(chk[temp] == 0){\\n                                        yo--;\\n                                    }\\n                                }\\n                            }\\n                            if(yo == 0 && size == totSize){\\n                                ans.push_back(i);\\n                            }\\n                            chk.clear();\\n                            for(auto it: words){\\n                                chk[it]++;\\n                            }\\n                        }\\n                    }\\n                    i++;\\n                }\\n            }\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564822,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1568692,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1575750,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 2016360,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1568260,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1565448,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1716239,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1568069,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1567322,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1574392,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1564822,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1568692,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1575750,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 2016360,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1568260,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1565448,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1716239,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1568069,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1567322,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1574392,
                "content": [
                    {
                        "username": "cornellouis",
                        "content": "I thought the question assumed all words were the same length?"
                    },
                    {
                        "username": "_run",
                        "content": "it is given in question that all words are of same length"
                    },
                    {
                        "username": "leolin479",
                        "content": "For the example case\\n\\nInput: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\n\\nThe standard answer was \"output: [8]\", which preventing my code to be submitted."
                    },
                    {
                        "username": "markjreed",
                        "content": "The 16-char substring starting at position 8 is \"goodgoodbestword\", which has two \"good\"s and only one \"word\"; it needs to match the list, which has only one \"good\" and two \"word\"s."
                    },
                    {
                        "username": "roshanmathew89",
                        "content": "good appears twice in words , that needs to considers in while checking for permutation match"
                    },
                    {
                        "username": "KingSaeid",
                        "content": "if your condition i < s.size() - len * words.size()\\n\\nthen, use i < s.size() - len * words.size() + 1"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "i think u r using indexof method into ur solution\\n"
                    },
                    {
                        "username": "kraabhi",
                        "content": "Description of question is not good , various points are missing"
                    },
                    {
                        "username": "Yash-Dev-Solanki",
                        "content": "There is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "darcylmx",
                        "content": "Ignoring the key information(all the words are the SAME length) will cause exponential time complexity.\\n\\nOtherwise, it is just linear time to check a match."
                    },
                    {
                        "username": "Jerrysuu",
                        "content": "This example waste me lots of time until I saw others\\' answer."
                    },
                    {
                        "username": "zwright8",
                        "content": "Can LeetCode start adding the efficiency requirements to all the Description sections? It would make problem solving much less tedious"
                    },
                    {
                        "username": "serdaroquai",
                        "content": " `s = \"wordgoodstudentgoodword\", words = [\"word\",\"student\"]` I just failed this test case so they are not.."
                    },
                    {
                        "username": "EswarAleti",
                        "content": "All words must be of same length"
                    },
                    {
                        "username": "bcronrath",
                        "content": "Should it not be \"barfoo\" in the explanation of example 1?"
                    },
                    {
                        "username": "ConjureLain",
                        "content": "I notice that given String S might not be a lenght of multi-times of the length of string in words[]. For example, s=\"Ftimerunsfast\"(len=4*3+1=13), word=[\"time\",\"runs\",\"fast\"], should give a an out put [1] for the beginning \"F\" should be skipped, we start counting from 1. So for the situation mentioned in title ,  for\"aaaaaaaaaaaaaa\"(len=14), words =[\"aa\",\"aa\"], [1,3,5,7,9] should count as output too, for we can treat the first \"a\" is skipped. \\n\\nIs a bug of this question or a trap prepared for us?\\n\\nThanks for all kinds of answers!\\n"
                    }
                ]
            },
            {
                "id": 1655036,
                "content": [
                    {
                        "username": "user6770yv",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\nwords = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nThis test case how ever have the answer at index 13 but 13 in not the multiple of len(words[0]), isn\\'t we supposed to put in dictionary in len(words[0]) characters from s ???"
                    },
                    {
                        "username": "markjreed",
                        "content": "Where did you get the idea that the match can\\'t start at absolutely any index in the string? The _length_ of the substring has to match the total length of the words, but the _starting point_ can be anywhere."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Dany__Guty](/Dany__Guty) try sliding window approach. increment pointer by one and check for each substring of size(sum of lengths of all elements in words)"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "I have the same issue... I think that it is a wrong testcase, because the substrings you get with the 4 multipliers are: \"ling\", \"mind\", \"rabo\" \"ofoo\" never going to get \"fooo\" as a value of the temporal hash....\\n"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What\\'s going with the last testcase. It seems to be empty, but after running it I don\\'t have green or red dot. It\\'s just gray. There is no visible exprected output?\\nWhat is the right solution?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "ya same\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "God freaking heck,wasted so much time trying to optimize it to just a O(n) solution and passed 143 test cases,gave up and looked at solution and it turned out a O(n*w) solution which is effectively a brute force ish solution,where we simply generate substrings of concat length(wordlength*number of words) and check each such substring if it contains the required number of words."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "This will save you: you need to increment the window one by one, there\\'s no way to pass the testcases in increments in the window of n = words[0].size()"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "my solution is easy to understand but i am getting TLE in my program "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "same bro ,but how should we use sliding here? I\\'m using inbuild substring method.\\n"
                    },
                    {
                        "username": "mortimerXIV",
                        "content": "I\\'m trying to test for the following (python2):\\n\\n\"aaaaaaaa\"\\n[\"aa\", \"aa\", \"aa\"]\\nwhich correctly brings back [0, 1, 2]\\n\\nhowever when I modify my test case for:\\n\\n\"aaaaaaaa\"\\n[\"a\", \"aa\", \"aa\"] \\nwhich my code responds with [0, 1, 2, 3], \\nthe test checking code thinks the correct answer is []"
                    },
                    {
                        "username": "lnmiitmanish",
                        "content": "equal length\\n"
                    },
                    {
                        "username": "kdano",
                        "content": "I got a wrong answer for failing this test case:\\n\\nInput: \"\"\\n[]\\nOutput: [0]\\nExpected: []\\n\\nNow why would the expected answer be an empty list here? As far as I\\'m concerned, the empty string is the concatenation of the empty list of words.."
                    },
                    {
                        "username": "kuelf",
                        "content": "You\\'re thinking wrong. To match an empty string, the word list should have  one or more empty strings."
                    },
                    {
                        "username": "sukhija86",
                        "content": "\"wordgoodgoodgoodbestword\"\\n[\"word\",\"good\",\"best\",\"word\"]\\n\\nWhy is this test case does return any indices. The concatenated word \"wordgood\" is at index 0."
                    },
                    {
                        "username": "trungbn",
                        "content": "\"wordgood\" is not concatenated word, you must concatenate all the word in array to make a concatenated word. Got it?"
                    },
                    {
                        "username": "iAutoparkCars",
                        "content": "Assuming you've read the problem:\\nI coded up an answer, then ran test cases, only to find:\\n\\nInput:\\n`String s`: \"barfoofoobarthefoobarman\"\\n`String[] words`: [_\"bar\",\"foo\",\"the\"_]\\n\\n_My_ Output:\\n[0,3,6,9,12,15]\\n\\nExpected:\\n[6,9,12]\\n\\n**_\"barfoo\"_ in `String s` starting at index 0 is a concatenation of\\n_\"bar\"_  and _\"foo\"_ in `String[] words`** so why is index 0 not part of the correct (Expected) answer?\\n\\nSo my algorithm didn't address the question, **meaning I didn't understand the problem!**\\n\\n\\nSimply, my algorithm is, \\n\\n>if current (first) substring of length 3 is inside `String[] words`, \\n>check if the next substring of length 3 is also in `words`.\\n>>save current (first) index of substring"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "you have to find a substring index which has concatenation of ALL WORDS IN THE ARRAY WORDS[]. if a substring is concatenation of just two or three words out of the words[] array, but does not contain all elements if the words array, then it is to be ignored"
                    },
                    {
                        "username": "martijnhoekstra",
                        "content": "The question doesn't include which characters are allowed in the haystack string. In practice, it turns out to only include the characters 'a'-'z'.\\n\\nThis limitation opens up a solution strategy that would be unavailable if that weren't the case (my own C# solution exploits this).\\n\\nIs this intentional? If so, the instructions should probably include that. If not, there should probably be test-cases that include other characters."
                    }
                ]
            },
            {
                "id": 2005832,
                "content": [
                    {
                        "username": "user6770yv",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\nwords = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nThis test case how ever have the answer at index 13 but 13 in not the multiple of len(words[0]), isn\\'t we supposed to put in dictionary in len(words[0]) characters from s ???"
                    },
                    {
                        "username": "markjreed",
                        "content": "Where did you get the idea that the match can\\'t start at absolutely any index in the string? The _length_ of the substring has to match the total length of the words, but the _starting point_ can be anywhere."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Dany__Guty](/Dany__Guty) try sliding window approach. increment pointer by one and check for each substring of size(sum of lengths of all elements in words)"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "I have the same issue... I think that it is a wrong testcase, because the substrings you get with the 4 multipliers are: \"ling\", \"mind\", \"rabo\" \"ofoo\" never going to get \"fooo\" as a value of the temporal hash....\\n"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What\\'s going with the last testcase. It seems to be empty, but after running it I don\\'t have green or red dot. It\\'s just gray. There is no visible exprected output?\\nWhat is the right solution?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "ya same\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "God freaking heck,wasted so much time trying to optimize it to just a O(n) solution and passed 143 test cases,gave up and looked at solution and it turned out a O(n*w) solution which is effectively a brute force ish solution,where we simply generate substrings of concat length(wordlength*number of words) and check each such substring if it contains the required number of words."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "This will save you: you need to increment the window one by one, there\\'s no way to pass the testcases in increments in the window of n = words[0].size()"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "my solution is easy to understand but i am getting TLE in my program "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "same bro ,but how should we use sliding here? I\\'m using inbuild substring method.\\n"
                    },
                    {
                        "username": "mortimerXIV",
                        "content": "I\\'m trying to test for the following (python2):\\n\\n\"aaaaaaaa\"\\n[\"aa\", \"aa\", \"aa\"]\\nwhich correctly brings back [0, 1, 2]\\n\\nhowever when I modify my test case for:\\n\\n\"aaaaaaaa\"\\n[\"a\", \"aa\", \"aa\"] \\nwhich my code responds with [0, 1, 2, 3], \\nthe test checking code thinks the correct answer is []"
                    },
                    {
                        "username": "lnmiitmanish",
                        "content": "equal length\\n"
                    },
                    {
                        "username": "kdano",
                        "content": "I got a wrong answer for failing this test case:\\n\\nInput: \"\"\\n[]\\nOutput: [0]\\nExpected: []\\n\\nNow why would the expected answer be an empty list here? As far as I\\'m concerned, the empty string is the concatenation of the empty list of words.."
                    },
                    {
                        "username": "kuelf",
                        "content": "You\\'re thinking wrong. To match an empty string, the word list should have  one or more empty strings."
                    },
                    {
                        "username": "sukhija86",
                        "content": "\"wordgoodgoodgoodbestword\"\\n[\"word\",\"good\",\"best\",\"word\"]\\n\\nWhy is this test case does return any indices. The concatenated word \"wordgood\" is at index 0."
                    },
                    {
                        "username": "trungbn",
                        "content": "\"wordgood\" is not concatenated word, you must concatenate all the word in array to make a concatenated word. Got it?"
                    },
                    {
                        "username": "iAutoparkCars",
                        "content": "Assuming you've read the problem:\\nI coded up an answer, then ran test cases, only to find:\\n\\nInput:\\n`String s`: \"barfoofoobarthefoobarman\"\\n`String[] words`: [_\"bar\",\"foo\",\"the\"_]\\n\\n_My_ Output:\\n[0,3,6,9,12,15]\\n\\nExpected:\\n[6,9,12]\\n\\n**_\"barfoo\"_ in `String s` starting at index 0 is a concatenation of\\n_\"bar\"_  and _\"foo\"_ in `String[] words`** so why is index 0 not part of the correct (Expected) answer?\\n\\nSo my algorithm didn't address the question, **meaning I didn't understand the problem!**\\n\\n\\nSimply, my algorithm is, \\n\\n>if current (first) substring of length 3 is inside `String[] words`, \\n>check if the next substring of length 3 is also in `words`.\\n>>save current (first) index of substring"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "you have to find a substring index which has concatenation of ALL WORDS IN THE ARRAY WORDS[]. if a substring is concatenation of just two or three words out of the words[] array, but does not contain all elements if the words array, then it is to be ignored"
                    },
                    {
                        "username": "martijnhoekstra",
                        "content": "The question doesn't include which characters are allowed in the haystack string. In practice, it turns out to only include the characters 'a'-'z'.\\n\\nThis limitation opens up a solution strategy that would be unavailable if that weren't the case (my own C# solution exploits this).\\n\\nIs this intentional? If so, the instructions should probably include that. If not, there should probably be test-cases that include other characters."
                    }
                ]
            },
            {
                "id": 1892675,
                "content": [
                    {
                        "username": "user6770yv",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\nwords = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nThis test case how ever have the answer at index 13 but 13 in not the multiple of len(words[0]), isn\\'t we supposed to put in dictionary in len(words[0]) characters from s ???"
                    },
                    {
                        "username": "markjreed",
                        "content": "Where did you get the idea that the match can\\'t start at absolutely any index in the string? The _length_ of the substring has to match the total length of the words, but the _starting point_ can be anywhere."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Dany__Guty](/Dany__Guty) try sliding window approach. increment pointer by one and check for each substring of size(sum of lengths of all elements in words)"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "I have the same issue... I think that it is a wrong testcase, because the substrings you get with the 4 multipliers are: \"ling\", \"mind\", \"rabo\" \"ofoo\" never going to get \"fooo\" as a value of the temporal hash....\\n"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What\\'s going with the last testcase. It seems to be empty, but after running it I don\\'t have green or red dot. It\\'s just gray. There is no visible exprected output?\\nWhat is the right solution?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "ya same\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "God freaking heck,wasted so much time trying to optimize it to just a O(n) solution and passed 143 test cases,gave up and looked at solution and it turned out a O(n*w) solution which is effectively a brute force ish solution,where we simply generate substrings of concat length(wordlength*number of words) and check each such substring if it contains the required number of words."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "This will save you: you need to increment the window one by one, there\\'s no way to pass the testcases in increments in the window of n = words[0].size()"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "my solution is easy to understand but i am getting TLE in my program "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "same bro ,but how should we use sliding here? I\\'m using inbuild substring method.\\n"
                    },
                    {
                        "username": "mortimerXIV",
                        "content": "I\\'m trying to test for the following (python2):\\n\\n\"aaaaaaaa\"\\n[\"aa\", \"aa\", \"aa\"]\\nwhich correctly brings back [0, 1, 2]\\n\\nhowever when I modify my test case for:\\n\\n\"aaaaaaaa\"\\n[\"a\", \"aa\", \"aa\"] \\nwhich my code responds with [0, 1, 2, 3], \\nthe test checking code thinks the correct answer is []"
                    },
                    {
                        "username": "lnmiitmanish",
                        "content": "equal length\\n"
                    },
                    {
                        "username": "kdano",
                        "content": "I got a wrong answer for failing this test case:\\n\\nInput: \"\"\\n[]\\nOutput: [0]\\nExpected: []\\n\\nNow why would the expected answer be an empty list here? As far as I\\'m concerned, the empty string is the concatenation of the empty list of words.."
                    },
                    {
                        "username": "kuelf",
                        "content": "You\\'re thinking wrong. To match an empty string, the word list should have  one or more empty strings."
                    },
                    {
                        "username": "sukhija86",
                        "content": "\"wordgoodgoodgoodbestword\"\\n[\"word\",\"good\",\"best\",\"word\"]\\n\\nWhy is this test case does return any indices. The concatenated word \"wordgood\" is at index 0."
                    },
                    {
                        "username": "trungbn",
                        "content": "\"wordgood\" is not concatenated word, you must concatenate all the word in array to make a concatenated word. Got it?"
                    },
                    {
                        "username": "iAutoparkCars",
                        "content": "Assuming you've read the problem:\\nI coded up an answer, then ran test cases, only to find:\\n\\nInput:\\n`String s`: \"barfoofoobarthefoobarman\"\\n`String[] words`: [_\"bar\",\"foo\",\"the\"_]\\n\\n_My_ Output:\\n[0,3,6,9,12,15]\\n\\nExpected:\\n[6,9,12]\\n\\n**_\"barfoo\"_ in `String s` starting at index 0 is a concatenation of\\n_\"bar\"_  and _\"foo\"_ in `String[] words`** so why is index 0 not part of the correct (Expected) answer?\\n\\nSo my algorithm didn't address the question, **meaning I didn't understand the problem!**\\n\\n\\nSimply, my algorithm is, \\n\\n>if current (first) substring of length 3 is inside `String[] words`, \\n>check if the next substring of length 3 is also in `words`.\\n>>save current (first) index of substring"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "you have to find a substring index which has concatenation of ALL WORDS IN THE ARRAY WORDS[]. if a substring is concatenation of just two or three words out of the words[] array, but does not contain all elements if the words array, then it is to be ignored"
                    },
                    {
                        "username": "martijnhoekstra",
                        "content": "The question doesn't include which characters are allowed in the haystack string. In practice, it turns out to only include the characters 'a'-'z'.\\n\\nThis limitation opens up a solution strategy that would be unavailable if that weren't the case (my own C# solution exploits this).\\n\\nIs this intentional? If so, the instructions should probably include that. If not, there should probably be test-cases that include other characters."
                    }
                ]
            },
            {
                "id": 1797665,
                "content": [
                    {
                        "username": "user6770yv",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\nwords = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nThis test case how ever have the answer at index 13 but 13 in not the multiple of len(words[0]), isn\\'t we supposed to put in dictionary in len(words[0]) characters from s ???"
                    },
                    {
                        "username": "markjreed",
                        "content": "Where did you get the idea that the match can\\'t start at absolutely any index in the string? The _length_ of the substring has to match the total length of the words, but the _starting point_ can be anywhere."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Dany__Guty](/Dany__Guty) try sliding window approach. increment pointer by one and check for each substring of size(sum of lengths of all elements in words)"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "I have the same issue... I think that it is a wrong testcase, because the substrings you get with the 4 multipliers are: \"ling\", \"mind\", \"rabo\" \"ofoo\" never going to get \"fooo\" as a value of the temporal hash....\\n"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What\\'s going with the last testcase. It seems to be empty, but after running it I don\\'t have green or red dot. It\\'s just gray. There is no visible exprected output?\\nWhat is the right solution?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "ya same\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "God freaking heck,wasted so much time trying to optimize it to just a O(n) solution and passed 143 test cases,gave up and looked at solution and it turned out a O(n*w) solution which is effectively a brute force ish solution,where we simply generate substrings of concat length(wordlength*number of words) and check each such substring if it contains the required number of words."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "This will save you: you need to increment the window one by one, there\\'s no way to pass the testcases in increments in the window of n = words[0].size()"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "my solution is easy to understand but i am getting TLE in my program "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "same bro ,but how should we use sliding here? I\\'m using inbuild substring method.\\n"
                    },
                    {
                        "username": "mortimerXIV",
                        "content": "I\\'m trying to test for the following (python2):\\n\\n\"aaaaaaaa\"\\n[\"aa\", \"aa\", \"aa\"]\\nwhich correctly brings back [0, 1, 2]\\n\\nhowever when I modify my test case for:\\n\\n\"aaaaaaaa\"\\n[\"a\", \"aa\", \"aa\"] \\nwhich my code responds with [0, 1, 2, 3], \\nthe test checking code thinks the correct answer is []"
                    },
                    {
                        "username": "lnmiitmanish",
                        "content": "equal length\\n"
                    },
                    {
                        "username": "kdano",
                        "content": "I got a wrong answer for failing this test case:\\n\\nInput: \"\"\\n[]\\nOutput: [0]\\nExpected: []\\n\\nNow why would the expected answer be an empty list here? As far as I\\'m concerned, the empty string is the concatenation of the empty list of words.."
                    },
                    {
                        "username": "kuelf",
                        "content": "You\\'re thinking wrong. To match an empty string, the word list should have  one or more empty strings."
                    },
                    {
                        "username": "sukhija86",
                        "content": "\"wordgoodgoodgoodbestword\"\\n[\"word\",\"good\",\"best\",\"word\"]\\n\\nWhy is this test case does return any indices. The concatenated word \"wordgood\" is at index 0."
                    },
                    {
                        "username": "trungbn",
                        "content": "\"wordgood\" is not concatenated word, you must concatenate all the word in array to make a concatenated word. Got it?"
                    },
                    {
                        "username": "iAutoparkCars",
                        "content": "Assuming you've read the problem:\\nI coded up an answer, then ran test cases, only to find:\\n\\nInput:\\n`String s`: \"barfoofoobarthefoobarman\"\\n`String[] words`: [_\"bar\",\"foo\",\"the\"_]\\n\\n_My_ Output:\\n[0,3,6,9,12,15]\\n\\nExpected:\\n[6,9,12]\\n\\n**_\"barfoo\"_ in `String s` starting at index 0 is a concatenation of\\n_\"bar\"_  and _\"foo\"_ in `String[] words`** so why is index 0 not part of the correct (Expected) answer?\\n\\nSo my algorithm didn't address the question, **meaning I didn't understand the problem!**\\n\\n\\nSimply, my algorithm is, \\n\\n>if current (first) substring of length 3 is inside `String[] words`, \\n>check if the next substring of length 3 is also in `words`.\\n>>save current (first) index of substring"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "you have to find a substring index which has concatenation of ALL WORDS IN THE ARRAY WORDS[]. if a substring is concatenation of just two or three words out of the words[] array, but does not contain all elements if the words array, then it is to be ignored"
                    },
                    {
                        "username": "martijnhoekstra",
                        "content": "The question doesn't include which characters are allowed in the haystack string. In practice, it turns out to only include the characters 'a'-'z'.\\n\\nThis limitation opens up a solution strategy that would be unavailable if that weren't the case (my own C# solution exploits this).\\n\\nIs this intentional? If so, the instructions should probably include that. If not, there should probably be test-cases that include other characters."
                    }
                ]
            },
            {
                "id": 1670347,
                "content": [
                    {
                        "username": "user6770yv",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\nwords = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nThis test case how ever have the answer at index 13 but 13 in not the multiple of len(words[0]), isn\\'t we supposed to put in dictionary in len(words[0]) characters from s ???"
                    },
                    {
                        "username": "markjreed",
                        "content": "Where did you get the idea that the match can\\'t start at absolutely any index in the string? The _length_ of the substring has to match the total length of the words, but the _starting point_ can be anywhere."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Dany__Guty](/Dany__Guty) try sliding window approach. increment pointer by one and check for each substring of size(sum of lengths of all elements in words)"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "I have the same issue... I think that it is a wrong testcase, because the substrings you get with the 4 multipliers are: \"ling\", \"mind\", \"rabo\" \"ofoo\" never going to get \"fooo\" as a value of the temporal hash....\\n"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What\\'s going with the last testcase. It seems to be empty, but after running it I don\\'t have green or red dot. It\\'s just gray. There is no visible exprected output?\\nWhat is the right solution?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "ya same\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "God freaking heck,wasted so much time trying to optimize it to just a O(n) solution and passed 143 test cases,gave up and looked at solution and it turned out a O(n*w) solution which is effectively a brute force ish solution,where we simply generate substrings of concat length(wordlength*number of words) and check each such substring if it contains the required number of words."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "This will save you: you need to increment the window one by one, there\\'s no way to pass the testcases in increments in the window of n = words[0].size()"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "my solution is easy to understand but i am getting TLE in my program "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "same bro ,but how should we use sliding here? I\\'m using inbuild substring method.\\n"
                    },
                    {
                        "username": "mortimerXIV",
                        "content": "I\\'m trying to test for the following (python2):\\n\\n\"aaaaaaaa\"\\n[\"aa\", \"aa\", \"aa\"]\\nwhich correctly brings back [0, 1, 2]\\n\\nhowever when I modify my test case for:\\n\\n\"aaaaaaaa\"\\n[\"a\", \"aa\", \"aa\"] \\nwhich my code responds with [0, 1, 2, 3], \\nthe test checking code thinks the correct answer is []"
                    },
                    {
                        "username": "lnmiitmanish",
                        "content": "equal length\\n"
                    },
                    {
                        "username": "kdano",
                        "content": "I got a wrong answer for failing this test case:\\n\\nInput: \"\"\\n[]\\nOutput: [0]\\nExpected: []\\n\\nNow why would the expected answer be an empty list here? As far as I\\'m concerned, the empty string is the concatenation of the empty list of words.."
                    },
                    {
                        "username": "kuelf",
                        "content": "You\\'re thinking wrong. To match an empty string, the word list should have  one or more empty strings."
                    },
                    {
                        "username": "sukhija86",
                        "content": "\"wordgoodgoodgoodbestword\"\\n[\"word\",\"good\",\"best\",\"word\"]\\n\\nWhy is this test case does return any indices. The concatenated word \"wordgood\" is at index 0."
                    },
                    {
                        "username": "trungbn",
                        "content": "\"wordgood\" is not concatenated word, you must concatenate all the word in array to make a concatenated word. Got it?"
                    },
                    {
                        "username": "iAutoparkCars",
                        "content": "Assuming you've read the problem:\\nI coded up an answer, then ran test cases, only to find:\\n\\nInput:\\n`String s`: \"barfoofoobarthefoobarman\"\\n`String[] words`: [_\"bar\",\"foo\",\"the\"_]\\n\\n_My_ Output:\\n[0,3,6,9,12,15]\\n\\nExpected:\\n[6,9,12]\\n\\n**_\"barfoo\"_ in `String s` starting at index 0 is a concatenation of\\n_\"bar\"_  and _\"foo\"_ in `String[] words`** so why is index 0 not part of the correct (Expected) answer?\\n\\nSo my algorithm didn't address the question, **meaning I didn't understand the problem!**\\n\\n\\nSimply, my algorithm is, \\n\\n>if current (first) substring of length 3 is inside `String[] words`, \\n>check if the next substring of length 3 is also in `words`.\\n>>save current (first) index of substring"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "you have to find a substring index which has concatenation of ALL WORDS IN THE ARRAY WORDS[]. if a substring is concatenation of just two or three words out of the words[] array, but does not contain all elements if the words array, then it is to be ignored"
                    },
                    {
                        "username": "martijnhoekstra",
                        "content": "The question doesn't include which characters are allowed in the haystack string. In practice, it turns out to only include the characters 'a'-'z'.\\n\\nThis limitation opens up a solution strategy that would be unavailable if that weren't the case (my own C# solution exploits this).\\n\\nIs this intentional? If so, the instructions should probably include that. If not, there should probably be test-cases that include other characters."
                    }
                ]
            },
            {
                "id": 1574127,
                "content": [
                    {
                        "username": "user6770yv",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\nwords = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nThis test case how ever have the answer at index 13 but 13 in not the multiple of len(words[0]), isn\\'t we supposed to put in dictionary in len(words[0]) characters from s ???"
                    },
                    {
                        "username": "markjreed",
                        "content": "Where did you get the idea that the match can\\'t start at absolutely any index in the string? The _length_ of the substring has to match the total length of the words, but the _starting point_ can be anywhere."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Dany__Guty](/Dany__Guty) try sliding window approach. increment pointer by one and check for each substring of size(sum of lengths of all elements in words)"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "I have the same issue... I think that it is a wrong testcase, because the substrings you get with the 4 multipliers are: \"ling\", \"mind\", \"rabo\" \"ofoo\" never going to get \"fooo\" as a value of the temporal hash....\\n"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What\\'s going with the last testcase. It seems to be empty, but after running it I don\\'t have green or red dot. It\\'s just gray. There is no visible exprected output?\\nWhat is the right solution?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "ya same\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "God freaking heck,wasted so much time trying to optimize it to just a O(n) solution and passed 143 test cases,gave up and looked at solution and it turned out a O(n*w) solution which is effectively a brute force ish solution,where we simply generate substrings of concat length(wordlength*number of words) and check each such substring if it contains the required number of words."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "This will save you: you need to increment the window one by one, there\\'s no way to pass the testcases in increments in the window of n = words[0].size()"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "my solution is easy to understand but i am getting TLE in my program "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "same bro ,but how should we use sliding here? I\\'m using inbuild substring method.\\n"
                    },
                    {
                        "username": "mortimerXIV",
                        "content": "I\\'m trying to test for the following (python2):\\n\\n\"aaaaaaaa\"\\n[\"aa\", \"aa\", \"aa\"]\\nwhich correctly brings back [0, 1, 2]\\n\\nhowever when I modify my test case for:\\n\\n\"aaaaaaaa\"\\n[\"a\", \"aa\", \"aa\"] \\nwhich my code responds with [0, 1, 2, 3], \\nthe test checking code thinks the correct answer is []"
                    },
                    {
                        "username": "lnmiitmanish",
                        "content": "equal length\\n"
                    },
                    {
                        "username": "kdano",
                        "content": "I got a wrong answer for failing this test case:\\n\\nInput: \"\"\\n[]\\nOutput: [0]\\nExpected: []\\n\\nNow why would the expected answer be an empty list here? As far as I\\'m concerned, the empty string is the concatenation of the empty list of words.."
                    },
                    {
                        "username": "kuelf",
                        "content": "You\\'re thinking wrong. To match an empty string, the word list should have  one or more empty strings."
                    },
                    {
                        "username": "sukhija86",
                        "content": "\"wordgoodgoodgoodbestword\"\\n[\"word\",\"good\",\"best\",\"word\"]\\n\\nWhy is this test case does return any indices. The concatenated word \"wordgood\" is at index 0."
                    },
                    {
                        "username": "trungbn",
                        "content": "\"wordgood\" is not concatenated word, you must concatenate all the word in array to make a concatenated word. Got it?"
                    },
                    {
                        "username": "iAutoparkCars",
                        "content": "Assuming you've read the problem:\\nI coded up an answer, then ran test cases, only to find:\\n\\nInput:\\n`String s`: \"barfoofoobarthefoobarman\"\\n`String[] words`: [_\"bar\",\"foo\",\"the\"_]\\n\\n_My_ Output:\\n[0,3,6,9,12,15]\\n\\nExpected:\\n[6,9,12]\\n\\n**_\"barfoo\"_ in `String s` starting at index 0 is a concatenation of\\n_\"bar\"_  and _\"foo\"_ in `String[] words`** so why is index 0 not part of the correct (Expected) answer?\\n\\nSo my algorithm didn't address the question, **meaning I didn't understand the problem!**\\n\\n\\nSimply, my algorithm is, \\n\\n>if current (first) substring of length 3 is inside `String[] words`, \\n>check if the next substring of length 3 is also in `words`.\\n>>save current (first) index of substring"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "you have to find a substring index which has concatenation of ALL WORDS IN THE ARRAY WORDS[]. if a substring is concatenation of just two or three words out of the words[] array, but does not contain all elements if the words array, then it is to be ignored"
                    },
                    {
                        "username": "martijnhoekstra",
                        "content": "The question doesn't include which characters are allowed in the haystack string. In practice, it turns out to only include the characters 'a'-'z'.\\n\\nThis limitation opens up a solution strategy that would be unavailable if that weren't the case (my own C# solution exploits this).\\n\\nIs this intentional? If so, the instructions should probably include that. If not, there should probably be test-cases that include other characters."
                    }
                ]
            },
            {
                "id": 1572750,
                "content": [
                    {
                        "username": "user6770yv",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\nwords = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nThis test case how ever have the answer at index 13 but 13 in not the multiple of len(words[0]), isn\\'t we supposed to put in dictionary in len(words[0]) characters from s ???"
                    },
                    {
                        "username": "markjreed",
                        "content": "Where did you get the idea that the match can\\'t start at absolutely any index in the string? The _length_ of the substring has to match the total length of the words, but the _starting point_ can be anywhere."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Dany__Guty](/Dany__Guty) try sliding window approach. increment pointer by one and check for each substring of size(sum of lengths of all elements in words)"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "I have the same issue... I think that it is a wrong testcase, because the substrings you get with the 4 multipliers are: \"ling\", \"mind\", \"rabo\" \"ofoo\" never going to get \"fooo\" as a value of the temporal hash....\\n"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What\\'s going with the last testcase. It seems to be empty, but after running it I don\\'t have green or red dot. It\\'s just gray. There is no visible exprected output?\\nWhat is the right solution?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "ya same\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "God freaking heck,wasted so much time trying to optimize it to just a O(n) solution and passed 143 test cases,gave up and looked at solution and it turned out a O(n*w) solution which is effectively a brute force ish solution,where we simply generate substrings of concat length(wordlength*number of words) and check each such substring if it contains the required number of words."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "This will save you: you need to increment the window one by one, there\\'s no way to pass the testcases in increments in the window of n = words[0].size()"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "my solution is easy to understand but i am getting TLE in my program "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "same bro ,but how should we use sliding here? I\\'m using inbuild substring method.\\n"
                    },
                    {
                        "username": "mortimerXIV",
                        "content": "I\\'m trying to test for the following (python2):\\n\\n\"aaaaaaaa\"\\n[\"aa\", \"aa\", \"aa\"]\\nwhich correctly brings back [0, 1, 2]\\n\\nhowever when I modify my test case for:\\n\\n\"aaaaaaaa\"\\n[\"a\", \"aa\", \"aa\"] \\nwhich my code responds with [0, 1, 2, 3], \\nthe test checking code thinks the correct answer is []"
                    },
                    {
                        "username": "lnmiitmanish",
                        "content": "equal length\\n"
                    },
                    {
                        "username": "kdano",
                        "content": "I got a wrong answer for failing this test case:\\n\\nInput: \"\"\\n[]\\nOutput: [0]\\nExpected: []\\n\\nNow why would the expected answer be an empty list here? As far as I\\'m concerned, the empty string is the concatenation of the empty list of words.."
                    },
                    {
                        "username": "kuelf",
                        "content": "You\\'re thinking wrong. To match an empty string, the word list should have  one or more empty strings."
                    },
                    {
                        "username": "sukhija86",
                        "content": "\"wordgoodgoodgoodbestword\"\\n[\"word\",\"good\",\"best\",\"word\"]\\n\\nWhy is this test case does return any indices. The concatenated word \"wordgood\" is at index 0."
                    },
                    {
                        "username": "trungbn",
                        "content": "\"wordgood\" is not concatenated word, you must concatenate all the word in array to make a concatenated word. Got it?"
                    },
                    {
                        "username": "iAutoparkCars",
                        "content": "Assuming you've read the problem:\\nI coded up an answer, then ran test cases, only to find:\\n\\nInput:\\n`String s`: \"barfoofoobarthefoobarman\"\\n`String[] words`: [_\"bar\",\"foo\",\"the\"_]\\n\\n_My_ Output:\\n[0,3,6,9,12,15]\\n\\nExpected:\\n[6,9,12]\\n\\n**_\"barfoo\"_ in `String s` starting at index 0 is a concatenation of\\n_\"bar\"_  and _\"foo\"_ in `String[] words`** so why is index 0 not part of the correct (Expected) answer?\\n\\nSo my algorithm didn't address the question, **meaning I didn't understand the problem!**\\n\\n\\nSimply, my algorithm is, \\n\\n>if current (first) substring of length 3 is inside `String[] words`, \\n>check if the next substring of length 3 is also in `words`.\\n>>save current (first) index of substring"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "you have to find a substring index which has concatenation of ALL WORDS IN THE ARRAY WORDS[]. if a substring is concatenation of just two or three words out of the words[] array, but does not contain all elements if the words array, then it is to be ignored"
                    },
                    {
                        "username": "martijnhoekstra",
                        "content": "The question doesn't include which characters are allowed in the haystack string. In practice, it turns out to only include the characters 'a'-'z'.\\n\\nThis limitation opens up a solution strategy that would be unavailable if that weren't the case (my own C# solution exploits this).\\n\\nIs this intentional? If so, the instructions should probably include that. If not, there should probably be test-cases that include other characters."
                    }
                ]
            },
            {
                "id": 1572399,
                "content": [
                    {
                        "username": "user6770yv",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\nwords = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nThis test case how ever have the answer at index 13 but 13 in not the multiple of len(words[0]), isn\\'t we supposed to put in dictionary in len(words[0]) characters from s ???"
                    },
                    {
                        "username": "markjreed",
                        "content": "Where did you get the idea that the match can\\'t start at absolutely any index in the string? The _length_ of the substring has to match the total length of the words, but the _starting point_ can be anywhere."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Dany__Guty](/Dany__Guty) try sliding window approach. increment pointer by one and check for each substring of size(sum of lengths of all elements in words)"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "I have the same issue... I think that it is a wrong testcase, because the substrings you get with the 4 multipliers are: \"ling\", \"mind\", \"rabo\" \"ofoo\" never going to get \"fooo\" as a value of the temporal hash....\\n"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What\\'s going with the last testcase. It seems to be empty, but after running it I don\\'t have green or red dot. It\\'s just gray. There is no visible exprected output?\\nWhat is the right solution?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "ya same\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "God freaking heck,wasted so much time trying to optimize it to just a O(n) solution and passed 143 test cases,gave up and looked at solution and it turned out a O(n*w) solution which is effectively a brute force ish solution,where we simply generate substrings of concat length(wordlength*number of words) and check each such substring if it contains the required number of words."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "This will save you: you need to increment the window one by one, there\\'s no way to pass the testcases in increments in the window of n = words[0].size()"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "my solution is easy to understand but i am getting TLE in my program "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "same bro ,but how should we use sliding here? I\\'m using inbuild substring method.\\n"
                    },
                    {
                        "username": "mortimerXIV",
                        "content": "I\\'m trying to test for the following (python2):\\n\\n\"aaaaaaaa\"\\n[\"aa\", \"aa\", \"aa\"]\\nwhich correctly brings back [0, 1, 2]\\n\\nhowever when I modify my test case for:\\n\\n\"aaaaaaaa\"\\n[\"a\", \"aa\", \"aa\"] \\nwhich my code responds with [0, 1, 2, 3], \\nthe test checking code thinks the correct answer is []"
                    },
                    {
                        "username": "lnmiitmanish",
                        "content": "equal length\\n"
                    },
                    {
                        "username": "kdano",
                        "content": "I got a wrong answer for failing this test case:\\n\\nInput: \"\"\\n[]\\nOutput: [0]\\nExpected: []\\n\\nNow why would the expected answer be an empty list here? As far as I\\'m concerned, the empty string is the concatenation of the empty list of words.."
                    },
                    {
                        "username": "kuelf",
                        "content": "You\\'re thinking wrong. To match an empty string, the word list should have  one or more empty strings."
                    },
                    {
                        "username": "sukhija86",
                        "content": "\"wordgoodgoodgoodbestword\"\\n[\"word\",\"good\",\"best\",\"word\"]\\n\\nWhy is this test case does return any indices. The concatenated word \"wordgood\" is at index 0."
                    },
                    {
                        "username": "trungbn",
                        "content": "\"wordgood\" is not concatenated word, you must concatenate all the word in array to make a concatenated word. Got it?"
                    },
                    {
                        "username": "iAutoparkCars",
                        "content": "Assuming you've read the problem:\\nI coded up an answer, then ran test cases, only to find:\\n\\nInput:\\n`String s`: \"barfoofoobarthefoobarman\"\\n`String[] words`: [_\"bar\",\"foo\",\"the\"_]\\n\\n_My_ Output:\\n[0,3,6,9,12,15]\\n\\nExpected:\\n[6,9,12]\\n\\n**_\"barfoo\"_ in `String s` starting at index 0 is a concatenation of\\n_\"bar\"_  and _\"foo\"_ in `String[] words`** so why is index 0 not part of the correct (Expected) answer?\\n\\nSo my algorithm didn't address the question, **meaning I didn't understand the problem!**\\n\\n\\nSimply, my algorithm is, \\n\\n>if current (first) substring of length 3 is inside `String[] words`, \\n>check if the next substring of length 3 is also in `words`.\\n>>save current (first) index of substring"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "you have to find a substring index which has concatenation of ALL WORDS IN THE ARRAY WORDS[]. if a substring is concatenation of just two or three words out of the words[] array, but does not contain all elements if the words array, then it is to be ignored"
                    },
                    {
                        "username": "martijnhoekstra",
                        "content": "The question doesn't include which characters are allowed in the haystack string. In practice, it turns out to only include the characters 'a'-'z'.\\n\\nThis limitation opens up a solution strategy that would be unavailable if that weren't the case (my own C# solution exploits this).\\n\\nIs this intentional? If so, the instructions should probably include that. If not, there should probably be test-cases that include other characters."
                    }
                ]
            },
            {
                "id": 1571081,
                "content": [
                    {
                        "username": "user6770yv",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\nwords = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nThis test case how ever have the answer at index 13 but 13 in not the multiple of len(words[0]), isn\\'t we supposed to put in dictionary in len(words[0]) characters from s ???"
                    },
                    {
                        "username": "markjreed",
                        "content": "Where did you get the idea that the match can\\'t start at absolutely any index in the string? The _length_ of the substring has to match the total length of the words, but the _starting point_ can be anywhere."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Dany__Guty](/Dany__Guty) try sliding window approach. increment pointer by one and check for each substring of size(sum of lengths of all elements in words)"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "I have the same issue... I think that it is a wrong testcase, because the substrings you get with the 4 multipliers are: \"ling\", \"mind\", \"rabo\" \"ofoo\" never going to get \"fooo\" as a value of the temporal hash....\\n"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What\\'s going with the last testcase. It seems to be empty, but after running it I don\\'t have green or red dot. It\\'s just gray. There is no visible exprected output?\\nWhat is the right solution?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "ya same\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "God freaking heck,wasted so much time trying to optimize it to just a O(n) solution and passed 143 test cases,gave up and looked at solution and it turned out a O(n*w) solution which is effectively a brute force ish solution,where we simply generate substrings of concat length(wordlength*number of words) and check each such substring if it contains the required number of words."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "This will save you: you need to increment the window one by one, there\\'s no way to pass the testcases in increments in the window of n = words[0].size()"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "my solution is easy to understand but i am getting TLE in my program "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "same bro ,but how should we use sliding here? I\\'m using inbuild substring method.\\n"
                    },
                    {
                        "username": "mortimerXIV",
                        "content": "I\\'m trying to test for the following (python2):\\n\\n\"aaaaaaaa\"\\n[\"aa\", \"aa\", \"aa\"]\\nwhich correctly brings back [0, 1, 2]\\n\\nhowever when I modify my test case for:\\n\\n\"aaaaaaaa\"\\n[\"a\", \"aa\", \"aa\"] \\nwhich my code responds with [0, 1, 2, 3], \\nthe test checking code thinks the correct answer is []"
                    },
                    {
                        "username": "lnmiitmanish",
                        "content": "equal length\\n"
                    },
                    {
                        "username": "kdano",
                        "content": "I got a wrong answer for failing this test case:\\n\\nInput: \"\"\\n[]\\nOutput: [0]\\nExpected: []\\n\\nNow why would the expected answer be an empty list here? As far as I\\'m concerned, the empty string is the concatenation of the empty list of words.."
                    },
                    {
                        "username": "kuelf",
                        "content": "You\\'re thinking wrong. To match an empty string, the word list should have  one or more empty strings."
                    },
                    {
                        "username": "sukhija86",
                        "content": "\"wordgoodgoodgoodbestword\"\\n[\"word\",\"good\",\"best\",\"word\"]\\n\\nWhy is this test case does return any indices. The concatenated word \"wordgood\" is at index 0."
                    },
                    {
                        "username": "trungbn",
                        "content": "\"wordgood\" is not concatenated word, you must concatenate all the word in array to make a concatenated word. Got it?"
                    },
                    {
                        "username": "iAutoparkCars",
                        "content": "Assuming you've read the problem:\\nI coded up an answer, then ran test cases, only to find:\\n\\nInput:\\n`String s`: \"barfoofoobarthefoobarman\"\\n`String[] words`: [_\"bar\",\"foo\",\"the\"_]\\n\\n_My_ Output:\\n[0,3,6,9,12,15]\\n\\nExpected:\\n[6,9,12]\\n\\n**_\"barfoo\"_ in `String s` starting at index 0 is a concatenation of\\n_\"bar\"_  and _\"foo\"_ in `String[] words`** so why is index 0 not part of the correct (Expected) answer?\\n\\nSo my algorithm didn't address the question, **meaning I didn't understand the problem!**\\n\\n\\nSimply, my algorithm is, \\n\\n>if current (first) substring of length 3 is inside `String[] words`, \\n>check if the next substring of length 3 is also in `words`.\\n>>save current (first) index of substring"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "you have to find a substring index which has concatenation of ALL WORDS IN THE ARRAY WORDS[]. if a substring is concatenation of just two or three words out of the words[] array, but does not contain all elements if the words array, then it is to be ignored"
                    },
                    {
                        "username": "martijnhoekstra",
                        "content": "The question doesn't include which characters are allowed in the haystack string. In practice, it turns out to only include the characters 'a'-'z'.\\n\\nThis limitation opens up a solution strategy that would be unavailable if that weren't the case (my own C# solution exploits this).\\n\\nIs this intentional? If so, the instructions should probably include that. If not, there should probably be test-cases that include other characters."
                    }
                ]
            },
            {
                "id": 1571082,
                "content": [
                    {
                        "username": "user6770yv",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\"\\nwords = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nThis test case how ever have the answer at index 13 but 13 in not the multiple of len(words[0]), isn\\'t we supposed to put in dictionary in len(words[0]) characters from s ???"
                    },
                    {
                        "username": "markjreed",
                        "content": "Where did you get the idea that the match can\\'t start at absolutely any index in the string? The _length_ of the substring has to match the total length of the words, but the _starting point_ can be anywhere."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "[@Dany__Guty](/Dany__Guty) try sliding window approach. increment pointer by one and check for each substring of size(sum of lengths of all elements in words)"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "I have the same issue... I think that it is a wrong testcase, because the substrings you get with the 4 multipliers are: \"ling\", \"mind\", \"rabo\" \"ofoo\" never going to get \"fooo\" as a value of the temporal hash....\\n"
                    },
                    {
                        "username": "AJordanek",
                        "content": "What\\'s going with the last testcase. It seems to be empty, but after running it I don\\'t have green or red dot. It\\'s just gray. There is no visible exprected output?\\nWhat is the right solution?"
                    },
                    {
                        "username": "Dominating_",
                        "content": "ya same\\n"
                    },
                    {
                        "username": "Deathangel5677",
                        "content": "God freaking heck,wasted so much time trying to optimize it to just a O(n) solution and passed 143 test cases,gave up and looked at solution and it turned out a O(n*w) solution which is effectively a brute force ish solution,where we simply generate substrings of concat length(wordlength*number of words) and check each such substring if it contains the required number of words."
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "This will save you: you need to increment the window one by one, there\\'s no way to pass the testcases in increments in the window of n = words[0].size()"
                    },
                    {
                        "username": "Bivek_Shaw",
                        "content": "my solution is easy to understand but i am getting TLE in my program "
                    },
                    {
                        "username": "dasarisairam",
                        "content": "same bro ,but how should we use sliding here? I\\'m using inbuild substring method.\\n"
                    },
                    {
                        "username": "mortimerXIV",
                        "content": "I\\'m trying to test for the following (python2):\\n\\n\"aaaaaaaa\"\\n[\"aa\", \"aa\", \"aa\"]\\nwhich correctly brings back [0, 1, 2]\\n\\nhowever when I modify my test case for:\\n\\n\"aaaaaaaa\"\\n[\"a\", \"aa\", \"aa\"] \\nwhich my code responds with [0, 1, 2, 3], \\nthe test checking code thinks the correct answer is []"
                    },
                    {
                        "username": "lnmiitmanish",
                        "content": "equal length\\n"
                    },
                    {
                        "username": "kdano",
                        "content": "I got a wrong answer for failing this test case:\\n\\nInput: \"\"\\n[]\\nOutput: [0]\\nExpected: []\\n\\nNow why would the expected answer be an empty list here? As far as I\\'m concerned, the empty string is the concatenation of the empty list of words.."
                    },
                    {
                        "username": "kuelf",
                        "content": "You\\'re thinking wrong. To match an empty string, the word list should have  one or more empty strings."
                    },
                    {
                        "username": "sukhija86",
                        "content": "\"wordgoodgoodgoodbestword\"\\n[\"word\",\"good\",\"best\",\"word\"]\\n\\nWhy is this test case does return any indices. The concatenated word \"wordgood\" is at index 0."
                    },
                    {
                        "username": "trungbn",
                        "content": "\"wordgood\" is not concatenated word, you must concatenate all the word in array to make a concatenated word. Got it?"
                    },
                    {
                        "username": "iAutoparkCars",
                        "content": "Assuming you've read the problem:\\nI coded up an answer, then ran test cases, only to find:\\n\\nInput:\\n`String s`: \"barfoofoobarthefoobarman\"\\n`String[] words`: [_\"bar\",\"foo\",\"the\"_]\\n\\n_My_ Output:\\n[0,3,6,9,12,15]\\n\\nExpected:\\n[6,9,12]\\n\\n**_\"barfoo\"_ in `String s` starting at index 0 is a concatenation of\\n_\"bar\"_  and _\"foo\"_ in `String[] words`** so why is index 0 not part of the correct (Expected) answer?\\n\\nSo my algorithm didn't address the question, **meaning I didn't understand the problem!**\\n\\n\\nSimply, my algorithm is, \\n\\n>if current (first) substring of length 3 is inside `String[] words`, \\n>check if the next substring of length 3 is also in `words`.\\n>>save current (first) index of substring"
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "you have to find a substring index which has concatenation of ALL WORDS IN THE ARRAY WORDS[]. if a substring is concatenation of just two or three words out of the words[] array, but does not contain all elements if the words array, then it is to be ignored"
                    },
                    {
                        "username": "martijnhoekstra",
                        "content": "The question doesn't include which characters are allowed in the haystack string. In practice, it turns out to only include the characters 'a'-'z'.\\n\\nThis limitation opens up a solution strategy that would be unavailable if that weren't the case (my own C# solution exploits this).\\n\\nIs this intentional? If so, the instructions should probably include that. If not, there should probably be test-cases that include other characters."
                    }
                ]
            },
            {
                "id": 1573907,
                "content": [
                    {
                        "username": "alitugrulcebe",
                        "content": "\\n![image](https://assets.leetcode.com/users/alitugrulcebe/image_1591754569.png)\\n\\nHow is the expected result become [8]?"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "\"goodgoodbestword\" is a possible concatenated permutation which is why 8 is the answer\\n"
                    },
                    {
                        "username": "emcc1990",
                        "content": "Isn\\'t that the correct one? "
                    },
                    {
                        "username": "ykanivets",
                        "content": "I\\'d like to share the approach I was using to solve this problem with all who were using std::unordered_map<std::string, value_type> to store the words.\\n\\nThe main problem is that when you put something into the map or just find an element int the map the string gets copied + you are using std::striung::substr() which makes another copy.\\n\\nWhat if to use a map of const char*? std::unordered_map<const char*, value_type> will not work of couse, it needs to provide a custom hasher and a comparer, and since all the words have the same length, it will be easy. So, you\\'ll end up with std::unordered_map<const char*, value_type, your_str_hash, your_str_eq>, just find a good hash function.\\n\\nIf you have the latest compiler you can use std::string_view, I think there\\'s no need to implement the hasher and comparer."
                    },
                    {
                        "username": "cattishToast",
                        "content": "This is one of the LeetCode problems of all time"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "The correct solution is pretty much brute force. This should be medium not a hard."
                    },
                    {
                        "username": "Abhishek_Maurya2028",
                        "content": "s=\"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words =\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] showing ans =[13]\\nbut my ans is[] wrong problem discription"
                    },
                    {
                        "username": "Pragya_9ps",
                        "content": "why this code is giving tle on the second last testcase, if there is any optimal solution please suggest.\\n   vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }"
                    },
                    {
                        "username": "MaxBr123",
                        "content": "Is this question not supposed to be completed with recrusion (C++)?  My solution seems correct and fully optimized, but excceds time limit at testcase 169/179."
                    },
                    {
                        "username": "pizdinio",
                        "content": "i don\\'t know"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\\nWe return an empty array.\\n\\nThis test case should be 8? \\nI used backtracking to solve the problem but It\\'s not able to pass the TC"
                    },
                    {
                        "username": "markjreed",
                        "content": "The substring starting at 8 has two \"good\" and one \"word\"; the list has one \"good\" and two \"word\". They don\\'t match, so 8 isn\\'t a valid answer."
                    },
                    {
                        "username": "r0hitm",
                        "content": "what is going on, I have wasted my 2hrs and now the last test case is nothing \"s = \" and no words provided, there is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "jk_sharath",
                        "content": "My code is not working only for one test case...178/179 passed...please help me out if i need to optimise anything....please mention...thankyou!\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        \\n        d={}\\n        res=[]\\n        for i in words:\\n            d[i]=1+d.get(i,0)\\n        k=len(words[0])\\n        i=0\\n        l1=len(d)\\n        while(i<len(s)):\\n            right=i\\n            d1=d.copy()\\n            l=l1\\n            while right+k<=len(s) and (s[right:right+k] in d1):\\n                tmp= s[right:right+k]\\n                \\n                d1[tmp]-=1\\n                if d1[tmp]==0:\\n                    d1.pop(tmp)\\n                    l-=1\\n                if l==0:\\n                    res.append(i)\\n                right+=k\\n            i+=1\\n        return res\\n                \\n                \\n\\n                \\n            \\n"
                    }
                ]
            },
            {
                "id": 1576065,
                "content": [
                    {
                        "username": "alitugrulcebe",
                        "content": "\\n![image](https://assets.leetcode.com/users/alitugrulcebe/image_1591754569.png)\\n\\nHow is the expected result become [8]?"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "\"goodgoodbestword\" is a possible concatenated permutation which is why 8 is the answer\\n"
                    },
                    {
                        "username": "emcc1990",
                        "content": "Isn\\'t that the correct one? "
                    },
                    {
                        "username": "ykanivets",
                        "content": "I\\'d like to share the approach I was using to solve this problem with all who were using std::unordered_map<std::string, value_type> to store the words.\\n\\nThe main problem is that when you put something into the map or just find an element int the map the string gets copied + you are using std::striung::substr() which makes another copy.\\n\\nWhat if to use a map of const char*? std::unordered_map<const char*, value_type> will not work of couse, it needs to provide a custom hasher and a comparer, and since all the words have the same length, it will be easy. So, you\\'ll end up with std::unordered_map<const char*, value_type, your_str_hash, your_str_eq>, just find a good hash function.\\n\\nIf you have the latest compiler you can use std::string_view, I think there\\'s no need to implement the hasher and comparer."
                    },
                    {
                        "username": "cattishToast",
                        "content": "This is one of the LeetCode problems of all time"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "The correct solution is pretty much brute force. This should be medium not a hard."
                    },
                    {
                        "username": "Abhishek_Maurya2028",
                        "content": "s=\"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words =\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] showing ans =[13]\\nbut my ans is[] wrong problem discription"
                    },
                    {
                        "username": "Pragya_9ps",
                        "content": "why this code is giving tle on the second last testcase, if there is any optimal solution please suggest.\\n   vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }"
                    },
                    {
                        "username": "MaxBr123",
                        "content": "Is this question not supposed to be completed with recrusion (C++)?  My solution seems correct and fully optimized, but excceds time limit at testcase 169/179."
                    },
                    {
                        "username": "pizdinio",
                        "content": "i don\\'t know"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\\nWe return an empty array.\\n\\nThis test case should be 8? \\nI used backtracking to solve the problem but It\\'s not able to pass the TC"
                    },
                    {
                        "username": "markjreed",
                        "content": "The substring starting at 8 has two \"good\" and one \"word\"; the list has one \"good\" and two \"word\". They don\\'t match, so 8 isn\\'t a valid answer."
                    },
                    {
                        "username": "r0hitm",
                        "content": "what is going on, I have wasted my 2hrs and now the last test case is nothing \"s = \" and no words provided, there is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "jk_sharath",
                        "content": "My code is not working only for one test case...178/179 passed...please help me out if i need to optimise anything....please mention...thankyou!\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        \\n        d={}\\n        res=[]\\n        for i in words:\\n            d[i]=1+d.get(i,0)\\n        k=len(words[0])\\n        i=0\\n        l1=len(d)\\n        while(i<len(s)):\\n            right=i\\n            d1=d.copy()\\n            l=l1\\n            while right+k<=len(s) and (s[right:right+k] in d1):\\n                tmp= s[right:right+k]\\n                \\n                d1[tmp]-=1\\n                if d1[tmp]==0:\\n                    d1.pop(tmp)\\n                    l-=1\\n                if l==0:\\n                    res.append(i)\\n                right+=k\\n            i+=1\\n        return res\\n                \\n                \\n\\n                \\n            \\n"
                    }
                ]
            },
            {
                "id": 2052213,
                "content": [
                    {
                        "username": "alitugrulcebe",
                        "content": "\\n![image](https://assets.leetcode.com/users/alitugrulcebe/image_1591754569.png)\\n\\nHow is the expected result become [8]?"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "\"goodgoodbestword\" is a possible concatenated permutation which is why 8 is the answer\\n"
                    },
                    {
                        "username": "emcc1990",
                        "content": "Isn\\'t that the correct one? "
                    },
                    {
                        "username": "ykanivets",
                        "content": "I\\'d like to share the approach I was using to solve this problem with all who were using std::unordered_map<std::string, value_type> to store the words.\\n\\nThe main problem is that when you put something into the map or just find an element int the map the string gets copied + you are using std::striung::substr() which makes another copy.\\n\\nWhat if to use a map of const char*? std::unordered_map<const char*, value_type> will not work of couse, it needs to provide a custom hasher and a comparer, and since all the words have the same length, it will be easy. So, you\\'ll end up with std::unordered_map<const char*, value_type, your_str_hash, your_str_eq>, just find a good hash function.\\n\\nIf you have the latest compiler you can use std::string_view, I think there\\'s no need to implement the hasher and comparer."
                    },
                    {
                        "username": "cattishToast",
                        "content": "This is one of the LeetCode problems of all time"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "The correct solution is pretty much brute force. This should be medium not a hard."
                    },
                    {
                        "username": "Abhishek_Maurya2028",
                        "content": "s=\"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words =\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] showing ans =[13]\\nbut my ans is[] wrong problem discription"
                    },
                    {
                        "username": "Pragya_9ps",
                        "content": "why this code is giving tle on the second last testcase, if there is any optimal solution please suggest.\\n   vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }"
                    },
                    {
                        "username": "MaxBr123",
                        "content": "Is this question not supposed to be completed with recrusion (C++)?  My solution seems correct and fully optimized, but excceds time limit at testcase 169/179."
                    },
                    {
                        "username": "pizdinio",
                        "content": "i don\\'t know"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\\nWe return an empty array.\\n\\nThis test case should be 8? \\nI used backtracking to solve the problem but It\\'s not able to pass the TC"
                    },
                    {
                        "username": "markjreed",
                        "content": "The substring starting at 8 has two \"good\" and one \"word\"; the list has one \"good\" and two \"word\". They don\\'t match, so 8 isn\\'t a valid answer."
                    },
                    {
                        "username": "r0hitm",
                        "content": "what is going on, I have wasted my 2hrs and now the last test case is nothing \"s = \" and no words provided, there is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "jk_sharath",
                        "content": "My code is not working only for one test case...178/179 passed...please help me out if i need to optimise anything....please mention...thankyou!\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        \\n        d={}\\n        res=[]\\n        for i in words:\\n            d[i]=1+d.get(i,0)\\n        k=len(words[0])\\n        i=0\\n        l1=len(d)\\n        while(i<len(s)):\\n            right=i\\n            d1=d.copy()\\n            l=l1\\n            while right+k<=len(s) and (s[right:right+k] in d1):\\n                tmp= s[right:right+k]\\n                \\n                d1[tmp]-=1\\n                if d1[tmp]==0:\\n                    d1.pop(tmp)\\n                    l-=1\\n                if l==0:\\n                    res.append(i)\\n                right+=k\\n            i+=1\\n        return res\\n                \\n                \\n\\n                \\n            \\n"
                    }
                ]
            },
            {
                "id": 2049814,
                "content": [
                    {
                        "username": "alitugrulcebe",
                        "content": "\\n![image](https://assets.leetcode.com/users/alitugrulcebe/image_1591754569.png)\\n\\nHow is the expected result become [8]?"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "\"goodgoodbestword\" is a possible concatenated permutation which is why 8 is the answer\\n"
                    },
                    {
                        "username": "emcc1990",
                        "content": "Isn\\'t that the correct one? "
                    },
                    {
                        "username": "ykanivets",
                        "content": "I\\'d like to share the approach I was using to solve this problem with all who were using std::unordered_map<std::string, value_type> to store the words.\\n\\nThe main problem is that when you put something into the map or just find an element int the map the string gets copied + you are using std::striung::substr() which makes another copy.\\n\\nWhat if to use a map of const char*? std::unordered_map<const char*, value_type> will not work of couse, it needs to provide a custom hasher and a comparer, and since all the words have the same length, it will be easy. So, you\\'ll end up with std::unordered_map<const char*, value_type, your_str_hash, your_str_eq>, just find a good hash function.\\n\\nIf you have the latest compiler you can use std::string_view, I think there\\'s no need to implement the hasher and comparer."
                    },
                    {
                        "username": "cattishToast",
                        "content": "This is one of the LeetCode problems of all time"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "The correct solution is pretty much brute force. This should be medium not a hard."
                    },
                    {
                        "username": "Abhishek_Maurya2028",
                        "content": "s=\"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words =\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] showing ans =[13]\\nbut my ans is[] wrong problem discription"
                    },
                    {
                        "username": "Pragya_9ps",
                        "content": "why this code is giving tle on the second last testcase, if there is any optimal solution please suggest.\\n   vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }"
                    },
                    {
                        "username": "MaxBr123",
                        "content": "Is this question not supposed to be completed with recrusion (C++)?  My solution seems correct and fully optimized, but excceds time limit at testcase 169/179."
                    },
                    {
                        "username": "pizdinio",
                        "content": "i don\\'t know"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\\nWe return an empty array.\\n\\nThis test case should be 8? \\nI used backtracking to solve the problem but It\\'s not able to pass the TC"
                    },
                    {
                        "username": "markjreed",
                        "content": "The substring starting at 8 has two \"good\" and one \"word\"; the list has one \"good\" and two \"word\". They don\\'t match, so 8 isn\\'t a valid answer."
                    },
                    {
                        "username": "r0hitm",
                        "content": "what is going on, I have wasted my 2hrs and now the last test case is nothing \"s = \" and no words provided, there is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "jk_sharath",
                        "content": "My code is not working only for one test case...178/179 passed...please help me out if i need to optimise anything....please mention...thankyou!\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        \\n        d={}\\n        res=[]\\n        for i in words:\\n            d[i]=1+d.get(i,0)\\n        k=len(words[0])\\n        i=0\\n        l1=len(d)\\n        while(i<len(s)):\\n            right=i\\n            d1=d.copy()\\n            l=l1\\n            while right+k<=len(s) and (s[right:right+k] in d1):\\n                tmp= s[right:right+k]\\n                \\n                d1[tmp]-=1\\n                if d1[tmp]==0:\\n                    d1.pop(tmp)\\n                    l-=1\\n                if l==0:\\n                    res.append(i)\\n                right+=k\\n            i+=1\\n        return res\\n                \\n                \\n\\n                \\n            \\n"
                    }
                ]
            },
            {
                "id": 2049221,
                "content": [
                    {
                        "username": "alitugrulcebe",
                        "content": "\\n![image](https://assets.leetcode.com/users/alitugrulcebe/image_1591754569.png)\\n\\nHow is the expected result become [8]?"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "\"goodgoodbestword\" is a possible concatenated permutation which is why 8 is the answer\\n"
                    },
                    {
                        "username": "emcc1990",
                        "content": "Isn\\'t that the correct one? "
                    },
                    {
                        "username": "ykanivets",
                        "content": "I\\'d like to share the approach I was using to solve this problem with all who were using std::unordered_map<std::string, value_type> to store the words.\\n\\nThe main problem is that when you put something into the map or just find an element int the map the string gets copied + you are using std::striung::substr() which makes another copy.\\n\\nWhat if to use a map of const char*? std::unordered_map<const char*, value_type> will not work of couse, it needs to provide a custom hasher and a comparer, and since all the words have the same length, it will be easy. So, you\\'ll end up with std::unordered_map<const char*, value_type, your_str_hash, your_str_eq>, just find a good hash function.\\n\\nIf you have the latest compiler you can use std::string_view, I think there\\'s no need to implement the hasher and comparer."
                    },
                    {
                        "username": "cattishToast",
                        "content": "This is one of the LeetCode problems of all time"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "The correct solution is pretty much brute force. This should be medium not a hard."
                    },
                    {
                        "username": "Abhishek_Maurya2028",
                        "content": "s=\"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words =\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] showing ans =[13]\\nbut my ans is[] wrong problem discription"
                    },
                    {
                        "username": "Pragya_9ps",
                        "content": "why this code is giving tle on the second last testcase, if there is any optimal solution please suggest.\\n   vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }"
                    },
                    {
                        "username": "MaxBr123",
                        "content": "Is this question not supposed to be completed with recrusion (C++)?  My solution seems correct and fully optimized, but excceds time limit at testcase 169/179."
                    },
                    {
                        "username": "pizdinio",
                        "content": "i don\\'t know"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\\nWe return an empty array.\\n\\nThis test case should be 8? \\nI used backtracking to solve the problem but It\\'s not able to pass the TC"
                    },
                    {
                        "username": "markjreed",
                        "content": "The substring starting at 8 has two \"good\" and one \"word\"; the list has one \"good\" and two \"word\". They don\\'t match, so 8 isn\\'t a valid answer."
                    },
                    {
                        "username": "r0hitm",
                        "content": "what is going on, I have wasted my 2hrs and now the last test case is nothing \"s = \" and no words provided, there is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "jk_sharath",
                        "content": "My code is not working only for one test case...178/179 passed...please help me out if i need to optimise anything....please mention...thankyou!\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        \\n        d={}\\n        res=[]\\n        for i in words:\\n            d[i]=1+d.get(i,0)\\n        k=len(words[0])\\n        i=0\\n        l1=len(d)\\n        while(i<len(s)):\\n            right=i\\n            d1=d.copy()\\n            l=l1\\n            while right+k<=len(s) and (s[right:right+k] in d1):\\n                tmp= s[right:right+k]\\n                \\n                d1[tmp]-=1\\n                if d1[tmp]==0:\\n                    d1.pop(tmp)\\n                    l-=1\\n                if l==0:\\n                    res.append(i)\\n                right+=k\\n            i+=1\\n        return res\\n                \\n                \\n\\n                \\n            \\n"
                    }
                ]
            },
            {
                "id": 2043431,
                "content": [
                    {
                        "username": "alitugrulcebe",
                        "content": "\\n![image](https://assets.leetcode.com/users/alitugrulcebe/image_1591754569.png)\\n\\nHow is the expected result become [8]?"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "\"goodgoodbestword\" is a possible concatenated permutation which is why 8 is the answer\\n"
                    },
                    {
                        "username": "emcc1990",
                        "content": "Isn\\'t that the correct one? "
                    },
                    {
                        "username": "ykanivets",
                        "content": "I\\'d like to share the approach I was using to solve this problem with all who were using std::unordered_map<std::string, value_type> to store the words.\\n\\nThe main problem is that when you put something into the map or just find an element int the map the string gets copied + you are using std::striung::substr() which makes another copy.\\n\\nWhat if to use a map of const char*? std::unordered_map<const char*, value_type> will not work of couse, it needs to provide a custom hasher and a comparer, and since all the words have the same length, it will be easy. So, you\\'ll end up with std::unordered_map<const char*, value_type, your_str_hash, your_str_eq>, just find a good hash function.\\n\\nIf you have the latest compiler you can use std::string_view, I think there\\'s no need to implement the hasher and comparer."
                    },
                    {
                        "username": "cattishToast",
                        "content": "This is one of the LeetCode problems of all time"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "The correct solution is pretty much brute force. This should be medium not a hard."
                    },
                    {
                        "username": "Abhishek_Maurya2028",
                        "content": "s=\"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words =\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] showing ans =[13]\\nbut my ans is[] wrong problem discription"
                    },
                    {
                        "username": "Pragya_9ps",
                        "content": "why this code is giving tle on the second last testcase, if there is any optimal solution please suggest.\\n   vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }"
                    },
                    {
                        "username": "MaxBr123",
                        "content": "Is this question not supposed to be completed with recrusion (C++)?  My solution seems correct and fully optimized, but excceds time limit at testcase 169/179."
                    },
                    {
                        "username": "pizdinio",
                        "content": "i don\\'t know"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\\nWe return an empty array.\\n\\nThis test case should be 8? \\nI used backtracking to solve the problem but It\\'s not able to pass the TC"
                    },
                    {
                        "username": "markjreed",
                        "content": "The substring starting at 8 has two \"good\" and one \"word\"; the list has one \"good\" and two \"word\". They don\\'t match, so 8 isn\\'t a valid answer."
                    },
                    {
                        "username": "r0hitm",
                        "content": "what is going on, I have wasted my 2hrs and now the last test case is nothing \"s = \" and no words provided, there is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "jk_sharath",
                        "content": "My code is not working only for one test case...178/179 passed...please help me out if i need to optimise anything....please mention...thankyou!\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        \\n        d={}\\n        res=[]\\n        for i in words:\\n            d[i]=1+d.get(i,0)\\n        k=len(words[0])\\n        i=0\\n        l1=len(d)\\n        while(i<len(s)):\\n            right=i\\n            d1=d.copy()\\n            l=l1\\n            while right+k<=len(s) and (s[right:right+k] in d1):\\n                tmp= s[right:right+k]\\n                \\n                d1[tmp]-=1\\n                if d1[tmp]==0:\\n                    d1.pop(tmp)\\n                    l-=1\\n                if l==0:\\n                    res.append(i)\\n                right+=k\\n            i+=1\\n        return res\\n                \\n                \\n\\n                \\n            \\n"
                    }
                ]
            },
            {
                "id": 2037178,
                "content": [
                    {
                        "username": "alitugrulcebe",
                        "content": "\\n![image](https://assets.leetcode.com/users/alitugrulcebe/image_1591754569.png)\\n\\nHow is the expected result become [8]?"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "\"goodgoodbestword\" is a possible concatenated permutation which is why 8 is the answer\\n"
                    },
                    {
                        "username": "emcc1990",
                        "content": "Isn\\'t that the correct one? "
                    },
                    {
                        "username": "ykanivets",
                        "content": "I\\'d like to share the approach I was using to solve this problem with all who were using std::unordered_map<std::string, value_type> to store the words.\\n\\nThe main problem is that when you put something into the map or just find an element int the map the string gets copied + you are using std::striung::substr() which makes another copy.\\n\\nWhat if to use a map of const char*? std::unordered_map<const char*, value_type> will not work of couse, it needs to provide a custom hasher and a comparer, and since all the words have the same length, it will be easy. So, you\\'ll end up with std::unordered_map<const char*, value_type, your_str_hash, your_str_eq>, just find a good hash function.\\n\\nIf you have the latest compiler you can use std::string_view, I think there\\'s no need to implement the hasher and comparer."
                    },
                    {
                        "username": "cattishToast",
                        "content": "This is one of the LeetCode problems of all time"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "The correct solution is pretty much brute force. This should be medium not a hard."
                    },
                    {
                        "username": "Abhishek_Maurya2028",
                        "content": "s=\"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words =\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] showing ans =[13]\\nbut my ans is[] wrong problem discription"
                    },
                    {
                        "username": "Pragya_9ps",
                        "content": "why this code is giving tle on the second last testcase, if there is any optimal solution please suggest.\\n   vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }"
                    },
                    {
                        "username": "MaxBr123",
                        "content": "Is this question not supposed to be completed with recrusion (C++)?  My solution seems correct and fully optimized, but excceds time limit at testcase 169/179."
                    },
                    {
                        "username": "pizdinio",
                        "content": "i don\\'t know"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\\nWe return an empty array.\\n\\nThis test case should be 8? \\nI used backtracking to solve the problem but It\\'s not able to pass the TC"
                    },
                    {
                        "username": "markjreed",
                        "content": "The substring starting at 8 has two \"good\" and one \"word\"; the list has one \"good\" and two \"word\". They don\\'t match, so 8 isn\\'t a valid answer."
                    },
                    {
                        "username": "r0hitm",
                        "content": "what is going on, I have wasted my 2hrs and now the last test case is nothing \"s = \" and no words provided, there is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "jk_sharath",
                        "content": "My code is not working only for one test case...178/179 passed...please help me out if i need to optimise anything....please mention...thankyou!\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        \\n        d={}\\n        res=[]\\n        for i in words:\\n            d[i]=1+d.get(i,0)\\n        k=len(words[0])\\n        i=0\\n        l1=len(d)\\n        while(i<len(s)):\\n            right=i\\n            d1=d.copy()\\n            l=l1\\n            while right+k<=len(s) and (s[right:right+k] in d1):\\n                tmp= s[right:right+k]\\n                \\n                d1[tmp]-=1\\n                if d1[tmp]==0:\\n                    d1.pop(tmp)\\n                    l-=1\\n                if l==0:\\n                    res.append(i)\\n                right+=k\\n            i+=1\\n        return res\\n                \\n                \\n\\n                \\n            \\n"
                    }
                ]
            },
            {
                "id": 2027071,
                "content": [
                    {
                        "username": "alitugrulcebe",
                        "content": "\\n![image](https://assets.leetcode.com/users/alitugrulcebe/image_1591754569.png)\\n\\nHow is the expected result become [8]?"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "\"goodgoodbestword\" is a possible concatenated permutation which is why 8 is the answer\\n"
                    },
                    {
                        "username": "emcc1990",
                        "content": "Isn\\'t that the correct one? "
                    },
                    {
                        "username": "ykanivets",
                        "content": "I\\'d like to share the approach I was using to solve this problem with all who were using std::unordered_map<std::string, value_type> to store the words.\\n\\nThe main problem is that when you put something into the map or just find an element int the map the string gets copied + you are using std::striung::substr() which makes another copy.\\n\\nWhat if to use a map of const char*? std::unordered_map<const char*, value_type> will not work of couse, it needs to provide a custom hasher and a comparer, and since all the words have the same length, it will be easy. So, you\\'ll end up with std::unordered_map<const char*, value_type, your_str_hash, your_str_eq>, just find a good hash function.\\n\\nIf you have the latest compiler you can use std::string_view, I think there\\'s no need to implement the hasher and comparer."
                    },
                    {
                        "username": "cattishToast",
                        "content": "This is one of the LeetCode problems of all time"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "The correct solution is pretty much brute force. This should be medium not a hard."
                    },
                    {
                        "username": "Abhishek_Maurya2028",
                        "content": "s=\"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words =\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] showing ans =[13]\\nbut my ans is[] wrong problem discription"
                    },
                    {
                        "username": "Pragya_9ps",
                        "content": "why this code is giving tle on the second last testcase, if there is any optimal solution please suggest.\\n   vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }"
                    },
                    {
                        "username": "MaxBr123",
                        "content": "Is this question not supposed to be completed with recrusion (C++)?  My solution seems correct and fully optimized, but excceds time limit at testcase 169/179."
                    },
                    {
                        "username": "pizdinio",
                        "content": "i don\\'t know"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\\nWe return an empty array.\\n\\nThis test case should be 8? \\nI used backtracking to solve the problem but It\\'s not able to pass the TC"
                    },
                    {
                        "username": "markjreed",
                        "content": "The substring starting at 8 has two \"good\" and one \"word\"; the list has one \"good\" and two \"word\". They don\\'t match, so 8 isn\\'t a valid answer."
                    },
                    {
                        "username": "r0hitm",
                        "content": "what is going on, I have wasted my 2hrs and now the last test case is nothing \"s = \" and no words provided, there is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "jk_sharath",
                        "content": "My code is not working only for one test case...178/179 passed...please help me out if i need to optimise anything....please mention...thankyou!\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        \\n        d={}\\n        res=[]\\n        for i in words:\\n            d[i]=1+d.get(i,0)\\n        k=len(words[0])\\n        i=0\\n        l1=len(d)\\n        while(i<len(s)):\\n            right=i\\n            d1=d.copy()\\n            l=l1\\n            while right+k<=len(s) and (s[right:right+k] in d1):\\n                tmp= s[right:right+k]\\n                \\n                d1[tmp]-=1\\n                if d1[tmp]==0:\\n                    d1.pop(tmp)\\n                    l-=1\\n                if l==0:\\n                    res.append(i)\\n                right+=k\\n            i+=1\\n        return res\\n                \\n                \\n\\n                \\n            \\n"
                    }
                ]
            },
            {
                "id": 2017979,
                "content": [
                    {
                        "username": "alitugrulcebe",
                        "content": "\\n![image](https://assets.leetcode.com/users/alitugrulcebe/image_1591754569.png)\\n\\nHow is the expected result become [8]?"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "\"goodgoodbestword\" is a possible concatenated permutation which is why 8 is the answer\\n"
                    },
                    {
                        "username": "emcc1990",
                        "content": "Isn\\'t that the correct one? "
                    },
                    {
                        "username": "ykanivets",
                        "content": "I\\'d like to share the approach I was using to solve this problem with all who were using std::unordered_map<std::string, value_type> to store the words.\\n\\nThe main problem is that when you put something into the map or just find an element int the map the string gets copied + you are using std::striung::substr() which makes another copy.\\n\\nWhat if to use a map of const char*? std::unordered_map<const char*, value_type> will not work of couse, it needs to provide a custom hasher and a comparer, and since all the words have the same length, it will be easy. So, you\\'ll end up with std::unordered_map<const char*, value_type, your_str_hash, your_str_eq>, just find a good hash function.\\n\\nIf you have the latest compiler you can use std::string_view, I think there\\'s no need to implement the hasher and comparer."
                    },
                    {
                        "username": "cattishToast",
                        "content": "This is one of the LeetCode problems of all time"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "The correct solution is pretty much brute force. This should be medium not a hard."
                    },
                    {
                        "username": "Abhishek_Maurya2028",
                        "content": "s=\"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words =\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] showing ans =[13]\\nbut my ans is[] wrong problem discription"
                    },
                    {
                        "username": "Pragya_9ps",
                        "content": "why this code is giving tle on the second last testcase, if there is any optimal solution please suggest.\\n   vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }"
                    },
                    {
                        "username": "MaxBr123",
                        "content": "Is this question not supposed to be completed with recrusion (C++)?  My solution seems correct and fully optimized, but excceds time limit at testcase 169/179."
                    },
                    {
                        "username": "pizdinio",
                        "content": "i don\\'t know"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\\nWe return an empty array.\\n\\nThis test case should be 8? \\nI used backtracking to solve the problem but It\\'s not able to pass the TC"
                    },
                    {
                        "username": "markjreed",
                        "content": "The substring starting at 8 has two \"good\" and one \"word\"; the list has one \"good\" and two \"word\". They don\\'t match, so 8 isn\\'t a valid answer."
                    },
                    {
                        "username": "r0hitm",
                        "content": "what is going on, I have wasted my 2hrs and now the last test case is nothing \"s = \" and no words provided, there is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "jk_sharath",
                        "content": "My code is not working only for one test case...178/179 passed...please help me out if i need to optimise anything....please mention...thankyou!\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        \\n        d={}\\n        res=[]\\n        for i in words:\\n            d[i]=1+d.get(i,0)\\n        k=len(words[0])\\n        i=0\\n        l1=len(d)\\n        while(i<len(s)):\\n            right=i\\n            d1=d.copy()\\n            l=l1\\n            while right+k<=len(s) and (s[right:right+k] in d1):\\n                tmp= s[right:right+k]\\n                \\n                d1[tmp]-=1\\n                if d1[tmp]==0:\\n                    d1.pop(tmp)\\n                    l-=1\\n                if l==0:\\n                    res.append(i)\\n                right+=k\\n            i+=1\\n        return res\\n                \\n                \\n\\n                \\n            \\n"
                    }
                ]
            },
            {
                "id": 2016419,
                "content": [
                    {
                        "username": "alitugrulcebe",
                        "content": "\\n![image](https://assets.leetcode.com/users/alitugrulcebe/image_1591754569.png)\\n\\nHow is the expected result become [8]?"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "\"goodgoodbestword\" is a possible concatenated permutation which is why 8 is the answer\\n"
                    },
                    {
                        "username": "emcc1990",
                        "content": "Isn\\'t that the correct one? "
                    },
                    {
                        "username": "ykanivets",
                        "content": "I\\'d like to share the approach I was using to solve this problem with all who were using std::unordered_map<std::string, value_type> to store the words.\\n\\nThe main problem is that when you put something into the map or just find an element int the map the string gets copied + you are using std::striung::substr() which makes another copy.\\n\\nWhat if to use a map of const char*? std::unordered_map<const char*, value_type> will not work of couse, it needs to provide a custom hasher and a comparer, and since all the words have the same length, it will be easy. So, you\\'ll end up with std::unordered_map<const char*, value_type, your_str_hash, your_str_eq>, just find a good hash function.\\n\\nIf you have the latest compiler you can use std::string_view, I think there\\'s no need to implement the hasher and comparer."
                    },
                    {
                        "username": "cattishToast",
                        "content": "This is one of the LeetCode problems of all time"
                    },
                    {
                        "username": "ProtocolCheese",
                        "content": "The correct solution is pretty much brute force. This should be medium not a hard."
                    },
                    {
                        "username": "Abhishek_Maurya2028",
                        "content": "s=\"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words =\\n[\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"] showing ans =[13]\\nbut my ans is[] wrong problem discription"
                    },
                    {
                        "username": "Pragya_9ps",
                        "content": "why this code is giving tle on the second last testcase, if there is any optimal solution please suggest.\\n   vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words[0].length(), size = words.size(), n = s.size();\\n        vector<int> ans;\\n        unordered_map<string, int> mp;\\n        \\n        if(len*size > n)\\n            return ans;\\n        \\n        for(auto x:words)\\n            mp[x]++;\\n        \\n        for(int i = 0; i <= n-(len*size); i++){\\n            unordered_map<string, int> m;\\n            \\n            for(int j = i; j < i+(len*size); j += len){\\n                string current = s.substr(j, len);\\n                \\n                if(mp.find(current) == mp.end())\\n                    break;\\n                \\n                m[current]++;\\n                \\n                if(m[current] > mp[current])\\n                    break;\\n            }\\n            if(mp == m)\\n                ans.push_back(i);\\n        }\\n        \\n        return ans;\\n    }"
                    },
                    {
                        "username": "MaxBr123",
                        "content": "Is this question not supposed to be completed with recrusion (C++)?  My solution seems correct and fully optimized, but excceds time limit at testcase 169/179."
                    },
                    {
                        "username": "pizdinio",
                        "content": "i don\\'t know"
                    },
                    {
                        "username": "nhienlh94",
                        "content": "Input: s = \"wordgoodgoodgoodbestword\", words = [\"word\",\"good\",\"best\",\"word\"]\\nOutput: []\\nExplanation: Since words.length == 4 and words[i].length == 4, the concatenated substring has to be of length 16.\\nThere is no substring of length 16 is s that is equal to the concatenation of any permutation of words.\\nWe return an empty array.\\n\\nThis test case should be 8? \\nI used backtracking to solve the problem but It\\'s not able to pass the TC"
                    },
                    {
                        "username": "markjreed",
                        "content": "The substring starting at 8 has two \"good\" and one \"word\"; the list has one \"good\" and two \"word\". They don\\'t match, so 8 isn\\'t a valid answer."
                    },
                    {
                        "username": "r0hitm",
                        "content": "what is going on, I have wasted my 2hrs and now the last test case is nothing \"s = \" and no words provided, there is a problem with the last testcase. The parameters seem to be missing."
                    },
                    {
                        "username": "jk_sharath",
                        "content": "My code is not working only for one test case...178/179 passed...please help me out if i need to optimise anything....please mention...thankyou!\\nclass Solution:\\n    def findSubstring(self, s: str, words: List[str]) -> List[int]:\\n        \\n        d={}\\n        res=[]\\n        for i in words:\\n            d[i]=1+d.get(i,0)\\n        k=len(words[0])\\n        i=0\\n        l1=len(d)\\n        while(i<len(s)):\\n            right=i\\n            d1=d.copy()\\n            l=l1\\n            while right+k<=len(s) and (s[right:right+k] in d1):\\n                tmp= s[right:right+k]\\n                \\n                d1[tmp]-=1\\n                if d1[tmp]==0:\\n                    d1.pop(tmp)\\n                    l-=1\\n                if l==0:\\n                    res.append(i)\\n                right+=k\\n            i+=1\\n        return res\\n                \\n                \\n\\n                \\n            \\n"
                    }
                ]
            },
            {
                "id": 2013854,
                "content": [
                    {
                        "username": "vladgenyuk29",
                        "content": "Is \"ab\" * 5000 and [\\'ab\\', \\'ba\\'] * 100 an edge case, my code works well by wtf is this hell (175/179)?"
                    },
                    {
                        "username": "dpw82",
                        "content": "Memory limit exceeded. s3 the biggest string to test the final length for the answer. \n\n\n` public void helper(String s, String s2, String[] words){\n        if(leg == words.length){\n            s3+=s2;\n            s2 = \"\";\n            leg = 0;\n        }\n\n        for(int i = 0; i < words.length; i++){\n            helper(s, s2 + words[i], words);\n            leg++;\n        }\n    }`\n\n"
                    },
                    {
                        "username": "niclim65",
                        "content": "Got TLE with 179/179 testcases passed., why?"
                    },
                    {
                        "username": "niclim65",
                        "content": "[@Vibhor_1435](/Vibhor_1435) I got it, the way I reset my map was just a little more inefficient. Overall time complexity did not change"
                    },
                    {
                        "username": "Vibhor_1435",
                        "content": "yes same problem\\n"
                    },
                    {
                        "username": "SekharGanesh97",
                        "content": "Can we use this Package over here :  import com.google.common.base.Splitter\\ni could not able to use this above package here."
                    },
                    {
                        "username": "shivanihibare",
                        "content": "last expected input is empty which is causing TLE\\n"
                    },
                    {
                        "username": "anantverma711",
                        "content": "Passed all the testcases, still got a TLE"
                    },
                    {
                        "username": "edcr1790",
                        "content": "You might need to read this: https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "How sliding window gives us the solution ,I am able to generate concatenated string permutations but after that I am using a substring method which is giving TLE. Should I use algorithm like LPS array to find the substring.Thanks in advance."
                    },
                    {
                        "username": "snehel4510",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> counts;\\n        vector<int> indexes;\\n        for(string word : words)\\n            counts[word]++;\\n        int n = s.length(), num = words.size();\\n        if (n == 0 || num == 0) return indexes;\\n        int len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            unordered_map<string, int> seen;\\n            int j = 0;\\n            for (; j < num; j++) {\\n                string word = s.substr(i + j * len, len);\\n                if (counts.find(word) != counts.end()) {\\n                    seen[word]++;\\n                    if (seen[word] > counts[word])\\n                        break;\\n                }\\n                else break;\\n            }\\n            if (j == num) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```\\n\\nThis is my solution which gives TLE on 179/179 test case, and i don\\'t know why. The test case itself is an empty string and an empty words array which should be an invalid testcase."
                    },
                    {
                        "username": "Chirag27",
                        "content": "can someone explain why the s =\"aaaaaaaaaa\"(like 1000 times) and words=[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"](like 10000 time sagain is the only test case that is giving tle wth this approach, not able to find or figure out the ans to this case.\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n      \\n        //DEFINE WINDOW LENGTH;\\n        int n = words.size();\\n        int slen = s.length();\\n        int wordlen = words[0].length();\\n        int windowsize = n*wordlen;\\n\\n   \\n\\n        //put in map\\n        unordered_map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[words[i]]++;\\n        }\\n\\n        if(slen==windowsize && m.size()==1)\\n        {\\n            return {0};\\n        }\\n\\n        int si = 0;\\n        int ei = 0;\\n\\n        unordered_map<string,int> temp;\\n\\n        vector<int> ans;\\n\\n        while(ei<slen)\\n        {\\n            if((ei-si+1)<windowsize)\\n            {\\n                ei++;\\n            }\\n            else if((ei-si+1)==windowsize)\\n            {\\n                //do some work\\n                temp = m;\\n                string t = s.substr(si,ei-si+1);\\n        \\n               \\n                int i =0;\\n\\n                while(i<t.length())\\n                {\\n                    string sub = t.substr(i,wordlen);\\n                    if(temp.find(sub)!=temp.end())\\n                    {\\n                        temp[sub]--;\\n                    }\\n                    if(temp[sub]==0)\\n                    {\\n                        temp.erase(sub);\\n                    }\\n                    i = i + wordlen;\\n                }\\n                if(temp.size()==0)\\n                {\\n                    ans.push_back(si);\\n                }\\n                si = si+1;\\n                ei = ei+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "lucifer870",
                        "content": "Why my sol is giving tle\\n\\n\\nclass Solution {\\nprivate:\\n    map<string,int> mp,mp1;\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words.size()*(words[0].length());\\n        int nn = words[0].length();\\n        for(auto i : words)mp[i]++;\\n        vector<int> ans;\\n        for(int i=0;s.length()-len+1>i;i++){\\n            string x = s.substr(i,len);\\n            for(int j=0;x.length()>j;j = j + nn)\\n            {\\n                mp1[x.substr(j,nn)]++;\\n            }   \\n            if(mp == mp1)ans.push_back(i);\\n            mp1.clear();\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2005994,
                "content": [
                    {
                        "username": "vladgenyuk29",
                        "content": "Is \"ab\" * 5000 and [\\'ab\\', \\'ba\\'] * 100 an edge case, my code works well by wtf is this hell (175/179)?"
                    },
                    {
                        "username": "dpw82",
                        "content": "Memory limit exceeded. s3 the biggest string to test the final length for the answer. \n\n\n` public void helper(String s, String s2, String[] words){\n        if(leg == words.length){\n            s3+=s2;\n            s2 = \"\";\n            leg = 0;\n        }\n\n        for(int i = 0; i < words.length; i++){\n            helper(s, s2 + words[i], words);\n            leg++;\n        }\n    }`\n\n"
                    },
                    {
                        "username": "niclim65",
                        "content": "Got TLE with 179/179 testcases passed., why?"
                    },
                    {
                        "username": "niclim65",
                        "content": "[@Vibhor_1435](/Vibhor_1435) I got it, the way I reset my map was just a little more inefficient. Overall time complexity did not change"
                    },
                    {
                        "username": "Vibhor_1435",
                        "content": "yes same problem\\n"
                    },
                    {
                        "username": "SekharGanesh97",
                        "content": "Can we use this Package over here :  import com.google.common.base.Splitter\\ni could not able to use this above package here."
                    },
                    {
                        "username": "shivanihibare",
                        "content": "last expected input is empty which is causing TLE\\n"
                    },
                    {
                        "username": "anantverma711",
                        "content": "Passed all the testcases, still got a TLE"
                    },
                    {
                        "username": "edcr1790",
                        "content": "You might need to read this: https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "How sliding window gives us the solution ,I am able to generate concatenated string permutations but after that I am using a substring method which is giving TLE. Should I use algorithm like LPS array to find the substring.Thanks in advance."
                    },
                    {
                        "username": "snehel4510",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> counts;\\n        vector<int> indexes;\\n        for(string word : words)\\n            counts[word]++;\\n        int n = s.length(), num = words.size();\\n        if (n == 0 || num == 0) return indexes;\\n        int len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            unordered_map<string, int> seen;\\n            int j = 0;\\n            for (; j < num; j++) {\\n                string word = s.substr(i + j * len, len);\\n                if (counts.find(word) != counts.end()) {\\n                    seen[word]++;\\n                    if (seen[word] > counts[word])\\n                        break;\\n                }\\n                else break;\\n            }\\n            if (j == num) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```\\n\\nThis is my solution which gives TLE on 179/179 test case, and i don\\'t know why. The test case itself is an empty string and an empty words array which should be an invalid testcase."
                    },
                    {
                        "username": "Chirag27",
                        "content": "can someone explain why the s =\"aaaaaaaaaa\"(like 1000 times) and words=[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"](like 10000 time sagain is the only test case that is giving tle wth this approach, not able to find or figure out the ans to this case.\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n      \\n        //DEFINE WINDOW LENGTH;\\n        int n = words.size();\\n        int slen = s.length();\\n        int wordlen = words[0].length();\\n        int windowsize = n*wordlen;\\n\\n   \\n\\n        //put in map\\n        unordered_map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[words[i]]++;\\n        }\\n\\n        if(slen==windowsize && m.size()==1)\\n        {\\n            return {0};\\n        }\\n\\n        int si = 0;\\n        int ei = 0;\\n\\n        unordered_map<string,int> temp;\\n\\n        vector<int> ans;\\n\\n        while(ei<slen)\\n        {\\n            if((ei-si+1)<windowsize)\\n            {\\n                ei++;\\n            }\\n            else if((ei-si+1)==windowsize)\\n            {\\n                //do some work\\n                temp = m;\\n                string t = s.substr(si,ei-si+1);\\n        \\n               \\n                int i =0;\\n\\n                while(i<t.length())\\n                {\\n                    string sub = t.substr(i,wordlen);\\n                    if(temp.find(sub)!=temp.end())\\n                    {\\n                        temp[sub]--;\\n                    }\\n                    if(temp[sub]==0)\\n                    {\\n                        temp.erase(sub);\\n                    }\\n                    i = i + wordlen;\\n                }\\n                if(temp.size()==0)\\n                {\\n                    ans.push_back(si);\\n                }\\n                si = si+1;\\n                ei = ei+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "lucifer870",
                        "content": "Why my sol is giving tle\\n\\n\\nclass Solution {\\nprivate:\\n    map<string,int> mp,mp1;\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words.size()*(words[0].length());\\n        int nn = words[0].length();\\n        for(auto i : words)mp[i]++;\\n        vector<int> ans;\\n        for(int i=0;s.length()-len+1>i;i++){\\n            string x = s.substr(i,len);\\n            for(int j=0;x.length()>j;j = j + nn)\\n            {\\n                mp1[x.substr(j,nn)]++;\\n            }   \\n            if(mp == mp1)ans.push_back(i);\\n            mp1.clear();\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 2003621,
                "content": [
                    {
                        "username": "vladgenyuk29",
                        "content": "Is \"ab\" * 5000 and [\\'ab\\', \\'ba\\'] * 100 an edge case, my code works well by wtf is this hell (175/179)?"
                    },
                    {
                        "username": "dpw82",
                        "content": "Memory limit exceeded. s3 the biggest string to test the final length for the answer. \n\n\n` public void helper(String s, String s2, String[] words){\n        if(leg == words.length){\n            s3+=s2;\n            s2 = \"\";\n            leg = 0;\n        }\n\n        for(int i = 0; i < words.length; i++){\n            helper(s, s2 + words[i], words);\n            leg++;\n        }\n    }`\n\n"
                    },
                    {
                        "username": "niclim65",
                        "content": "Got TLE with 179/179 testcases passed., why?"
                    },
                    {
                        "username": "niclim65",
                        "content": "[@Vibhor_1435](/Vibhor_1435) I got it, the way I reset my map was just a little more inefficient. Overall time complexity did not change"
                    },
                    {
                        "username": "Vibhor_1435",
                        "content": "yes same problem\\n"
                    },
                    {
                        "username": "SekharGanesh97",
                        "content": "Can we use this Package over here :  import com.google.common.base.Splitter\\ni could not able to use this above package here."
                    },
                    {
                        "username": "shivanihibare",
                        "content": "last expected input is empty which is causing TLE\\n"
                    },
                    {
                        "username": "anantverma711",
                        "content": "Passed all the testcases, still got a TLE"
                    },
                    {
                        "username": "edcr1790",
                        "content": "You might need to read this: https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "How sliding window gives us the solution ,I am able to generate concatenated string permutations but after that I am using a substring method which is giving TLE. Should I use algorithm like LPS array to find the substring.Thanks in advance."
                    },
                    {
                        "username": "snehel4510",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> counts;\\n        vector<int> indexes;\\n        for(string word : words)\\n            counts[word]++;\\n        int n = s.length(), num = words.size();\\n        if (n == 0 || num == 0) return indexes;\\n        int len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            unordered_map<string, int> seen;\\n            int j = 0;\\n            for (; j < num; j++) {\\n                string word = s.substr(i + j * len, len);\\n                if (counts.find(word) != counts.end()) {\\n                    seen[word]++;\\n                    if (seen[word] > counts[word])\\n                        break;\\n                }\\n                else break;\\n            }\\n            if (j == num) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```\\n\\nThis is my solution which gives TLE on 179/179 test case, and i don\\'t know why. The test case itself is an empty string and an empty words array which should be an invalid testcase."
                    },
                    {
                        "username": "Chirag27",
                        "content": "can someone explain why the s =\"aaaaaaaaaa\"(like 1000 times) and words=[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"](like 10000 time sagain is the only test case that is giving tle wth this approach, not able to find or figure out the ans to this case.\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n      \\n        //DEFINE WINDOW LENGTH;\\n        int n = words.size();\\n        int slen = s.length();\\n        int wordlen = words[0].length();\\n        int windowsize = n*wordlen;\\n\\n   \\n\\n        //put in map\\n        unordered_map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[words[i]]++;\\n        }\\n\\n        if(slen==windowsize && m.size()==1)\\n        {\\n            return {0};\\n        }\\n\\n        int si = 0;\\n        int ei = 0;\\n\\n        unordered_map<string,int> temp;\\n\\n        vector<int> ans;\\n\\n        while(ei<slen)\\n        {\\n            if((ei-si+1)<windowsize)\\n            {\\n                ei++;\\n            }\\n            else if((ei-si+1)==windowsize)\\n            {\\n                //do some work\\n                temp = m;\\n                string t = s.substr(si,ei-si+1);\\n        \\n               \\n                int i =0;\\n\\n                while(i<t.length())\\n                {\\n                    string sub = t.substr(i,wordlen);\\n                    if(temp.find(sub)!=temp.end())\\n                    {\\n                        temp[sub]--;\\n                    }\\n                    if(temp[sub]==0)\\n                    {\\n                        temp.erase(sub);\\n                    }\\n                    i = i + wordlen;\\n                }\\n                if(temp.size()==0)\\n                {\\n                    ans.push_back(si);\\n                }\\n                si = si+1;\\n                ei = ei+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "lucifer870",
                        "content": "Why my sol is giving tle\\n\\n\\nclass Solution {\\nprivate:\\n    map<string,int> mp,mp1;\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words.size()*(words[0].length());\\n        int nn = words[0].length();\\n        for(auto i : words)mp[i]++;\\n        vector<int> ans;\\n        for(int i=0;s.length()-len+1>i;i++){\\n            string x = s.substr(i,len);\\n            for(int j=0;x.length()>j;j = j + nn)\\n            {\\n                mp1[x.substr(j,nn)]++;\\n            }   \\n            if(mp == mp1)ans.push_back(i);\\n            mp1.clear();\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1999649,
                "content": [
                    {
                        "username": "vladgenyuk29",
                        "content": "Is \"ab\" * 5000 and [\\'ab\\', \\'ba\\'] * 100 an edge case, my code works well by wtf is this hell (175/179)?"
                    },
                    {
                        "username": "dpw82",
                        "content": "Memory limit exceeded. s3 the biggest string to test the final length for the answer. \n\n\n` public void helper(String s, String s2, String[] words){\n        if(leg == words.length){\n            s3+=s2;\n            s2 = \"\";\n            leg = 0;\n        }\n\n        for(int i = 0; i < words.length; i++){\n            helper(s, s2 + words[i], words);\n            leg++;\n        }\n    }`\n\n"
                    },
                    {
                        "username": "niclim65",
                        "content": "Got TLE with 179/179 testcases passed., why?"
                    },
                    {
                        "username": "niclim65",
                        "content": "[@Vibhor_1435](/Vibhor_1435) I got it, the way I reset my map was just a little more inefficient. Overall time complexity did not change"
                    },
                    {
                        "username": "Vibhor_1435",
                        "content": "yes same problem\\n"
                    },
                    {
                        "username": "SekharGanesh97",
                        "content": "Can we use this Package over here :  import com.google.common.base.Splitter\\ni could not able to use this above package here."
                    },
                    {
                        "username": "shivanihibare",
                        "content": "last expected input is empty which is causing TLE\\n"
                    },
                    {
                        "username": "anantverma711",
                        "content": "Passed all the testcases, still got a TLE"
                    },
                    {
                        "username": "edcr1790",
                        "content": "You might need to read this: https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "How sliding window gives us the solution ,I am able to generate concatenated string permutations but after that I am using a substring method which is giving TLE. Should I use algorithm like LPS array to find the substring.Thanks in advance."
                    },
                    {
                        "username": "snehel4510",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> counts;\\n        vector<int> indexes;\\n        for(string word : words)\\n            counts[word]++;\\n        int n = s.length(), num = words.size();\\n        if (n == 0 || num == 0) return indexes;\\n        int len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            unordered_map<string, int> seen;\\n            int j = 0;\\n            for (; j < num; j++) {\\n                string word = s.substr(i + j * len, len);\\n                if (counts.find(word) != counts.end()) {\\n                    seen[word]++;\\n                    if (seen[word] > counts[word])\\n                        break;\\n                }\\n                else break;\\n            }\\n            if (j == num) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```\\n\\nThis is my solution which gives TLE on 179/179 test case, and i don\\'t know why. The test case itself is an empty string and an empty words array which should be an invalid testcase."
                    },
                    {
                        "username": "Chirag27",
                        "content": "can someone explain why the s =\"aaaaaaaaaa\"(like 1000 times) and words=[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"](like 10000 time sagain is the only test case that is giving tle wth this approach, not able to find or figure out the ans to this case.\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n      \\n        //DEFINE WINDOW LENGTH;\\n        int n = words.size();\\n        int slen = s.length();\\n        int wordlen = words[0].length();\\n        int windowsize = n*wordlen;\\n\\n   \\n\\n        //put in map\\n        unordered_map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[words[i]]++;\\n        }\\n\\n        if(slen==windowsize && m.size()==1)\\n        {\\n            return {0};\\n        }\\n\\n        int si = 0;\\n        int ei = 0;\\n\\n        unordered_map<string,int> temp;\\n\\n        vector<int> ans;\\n\\n        while(ei<slen)\\n        {\\n            if((ei-si+1)<windowsize)\\n            {\\n                ei++;\\n            }\\n            else if((ei-si+1)==windowsize)\\n            {\\n                //do some work\\n                temp = m;\\n                string t = s.substr(si,ei-si+1);\\n        \\n               \\n                int i =0;\\n\\n                while(i<t.length())\\n                {\\n                    string sub = t.substr(i,wordlen);\\n                    if(temp.find(sub)!=temp.end())\\n                    {\\n                        temp[sub]--;\\n                    }\\n                    if(temp[sub]==0)\\n                    {\\n                        temp.erase(sub);\\n                    }\\n                    i = i + wordlen;\\n                }\\n                if(temp.size()==0)\\n                {\\n                    ans.push_back(si);\\n                }\\n                si = si+1;\\n                ei = ei+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "lucifer870",
                        "content": "Why my sol is giving tle\\n\\n\\nclass Solution {\\nprivate:\\n    map<string,int> mp,mp1;\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words.size()*(words[0].length());\\n        int nn = words[0].length();\\n        for(auto i : words)mp[i]++;\\n        vector<int> ans;\\n        for(int i=0;s.length()-len+1>i;i++){\\n            string x = s.substr(i,len);\\n            for(int j=0;x.length()>j;j = j + nn)\\n            {\\n                mp1[x.substr(j,nn)]++;\\n            }   \\n            if(mp == mp1)ans.push_back(i);\\n            mp1.clear();\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1999303,
                "content": [
                    {
                        "username": "vladgenyuk29",
                        "content": "Is \"ab\" * 5000 and [\\'ab\\', \\'ba\\'] * 100 an edge case, my code works well by wtf is this hell (175/179)?"
                    },
                    {
                        "username": "dpw82",
                        "content": "Memory limit exceeded. s3 the biggest string to test the final length for the answer. \n\n\n` public void helper(String s, String s2, String[] words){\n        if(leg == words.length){\n            s3+=s2;\n            s2 = \"\";\n            leg = 0;\n        }\n\n        for(int i = 0; i < words.length; i++){\n            helper(s, s2 + words[i], words);\n            leg++;\n        }\n    }`\n\n"
                    },
                    {
                        "username": "niclim65",
                        "content": "Got TLE with 179/179 testcases passed., why?"
                    },
                    {
                        "username": "niclim65",
                        "content": "[@Vibhor_1435](/Vibhor_1435) I got it, the way I reset my map was just a little more inefficient. Overall time complexity did not change"
                    },
                    {
                        "username": "Vibhor_1435",
                        "content": "yes same problem\\n"
                    },
                    {
                        "username": "SekharGanesh97",
                        "content": "Can we use this Package over here :  import com.google.common.base.Splitter\\ni could not able to use this above package here."
                    },
                    {
                        "username": "shivanihibare",
                        "content": "last expected input is empty which is causing TLE\\n"
                    },
                    {
                        "username": "anantverma711",
                        "content": "Passed all the testcases, still got a TLE"
                    },
                    {
                        "username": "edcr1790",
                        "content": "You might need to read this: https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "How sliding window gives us the solution ,I am able to generate concatenated string permutations but after that I am using a substring method which is giving TLE. Should I use algorithm like LPS array to find the substring.Thanks in advance."
                    },
                    {
                        "username": "snehel4510",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> counts;\\n        vector<int> indexes;\\n        for(string word : words)\\n            counts[word]++;\\n        int n = s.length(), num = words.size();\\n        if (n == 0 || num == 0) return indexes;\\n        int len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            unordered_map<string, int> seen;\\n            int j = 0;\\n            for (; j < num; j++) {\\n                string word = s.substr(i + j * len, len);\\n                if (counts.find(word) != counts.end()) {\\n                    seen[word]++;\\n                    if (seen[word] > counts[word])\\n                        break;\\n                }\\n                else break;\\n            }\\n            if (j == num) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```\\n\\nThis is my solution which gives TLE on 179/179 test case, and i don\\'t know why. The test case itself is an empty string and an empty words array which should be an invalid testcase."
                    },
                    {
                        "username": "Chirag27",
                        "content": "can someone explain why the s =\"aaaaaaaaaa\"(like 1000 times) and words=[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"](like 10000 time sagain is the only test case that is giving tle wth this approach, not able to find or figure out the ans to this case.\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n      \\n        //DEFINE WINDOW LENGTH;\\n        int n = words.size();\\n        int slen = s.length();\\n        int wordlen = words[0].length();\\n        int windowsize = n*wordlen;\\n\\n   \\n\\n        //put in map\\n        unordered_map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[words[i]]++;\\n        }\\n\\n        if(slen==windowsize && m.size()==1)\\n        {\\n            return {0};\\n        }\\n\\n        int si = 0;\\n        int ei = 0;\\n\\n        unordered_map<string,int> temp;\\n\\n        vector<int> ans;\\n\\n        while(ei<slen)\\n        {\\n            if((ei-si+1)<windowsize)\\n            {\\n                ei++;\\n            }\\n            else if((ei-si+1)==windowsize)\\n            {\\n                //do some work\\n                temp = m;\\n                string t = s.substr(si,ei-si+1);\\n        \\n               \\n                int i =0;\\n\\n                while(i<t.length())\\n                {\\n                    string sub = t.substr(i,wordlen);\\n                    if(temp.find(sub)!=temp.end())\\n                    {\\n                        temp[sub]--;\\n                    }\\n                    if(temp[sub]==0)\\n                    {\\n                        temp.erase(sub);\\n                    }\\n                    i = i + wordlen;\\n                }\\n                if(temp.size()==0)\\n                {\\n                    ans.push_back(si);\\n                }\\n                si = si+1;\\n                ei = ei+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "lucifer870",
                        "content": "Why my sol is giving tle\\n\\n\\nclass Solution {\\nprivate:\\n    map<string,int> mp,mp1;\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words.size()*(words[0].length());\\n        int nn = words[0].length();\\n        for(auto i : words)mp[i]++;\\n        vector<int> ans;\\n        for(int i=0;s.length()-len+1>i;i++){\\n            string x = s.substr(i,len);\\n            for(int j=0;x.length()>j;j = j + nn)\\n            {\\n                mp1[x.substr(j,nn)]++;\\n            }   \\n            if(mp == mp1)ans.push_back(i);\\n            mp1.clear();\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1994425,
                "content": [
                    {
                        "username": "vladgenyuk29",
                        "content": "Is \"ab\" * 5000 and [\\'ab\\', \\'ba\\'] * 100 an edge case, my code works well by wtf is this hell (175/179)?"
                    },
                    {
                        "username": "dpw82",
                        "content": "Memory limit exceeded. s3 the biggest string to test the final length for the answer. \n\n\n` public void helper(String s, String s2, String[] words){\n        if(leg == words.length){\n            s3+=s2;\n            s2 = \"\";\n            leg = 0;\n        }\n\n        for(int i = 0; i < words.length; i++){\n            helper(s, s2 + words[i], words);\n            leg++;\n        }\n    }`\n\n"
                    },
                    {
                        "username": "niclim65",
                        "content": "Got TLE with 179/179 testcases passed., why?"
                    },
                    {
                        "username": "niclim65",
                        "content": "[@Vibhor_1435](/Vibhor_1435) I got it, the way I reset my map was just a little more inefficient. Overall time complexity did not change"
                    },
                    {
                        "username": "Vibhor_1435",
                        "content": "yes same problem\\n"
                    },
                    {
                        "username": "SekharGanesh97",
                        "content": "Can we use this Package over here :  import com.google.common.base.Splitter\\ni could not able to use this above package here."
                    },
                    {
                        "username": "shivanihibare",
                        "content": "last expected input is empty which is causing TLE\\n"
                    },
                    {
                        "username": "anantverma711",
                        "content": "Passed all the testcases, still got a TLE"
                    },
                    {
                        "username": "edcr1790",
                        "content": "You might need to read this: https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "How sliding window gives us the solution ,I am able to generate concatenated string permutations but after that I am using a substring method which is giving TLE. Should I use algorithm like LPS array to find the substring.Thanks in advance."
                    },
                    {
                        "username": "snehel4510",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> counts;\\n        vector<int> indexes;\\n        for(string word : words)\\n            counts[word]++;\\n        int n = s.length(), num = words.size();\\n        if (n == 0 || num == 0) return indexes;\\n        int len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            unordered_map<string, int> seen;\\n            int j = 0;\\n            for (; j < num; j++) {\\n                string word = s.substr(i + j * len, len);\\n                if (counts.find(word) != counts.end()) {\\n                    seen[word]++;\\n                    if (seen[word] > counts[word])\\n                        break;\\n                }\\n                else break;\\n            }\\n            if (j == num) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```\\n\\nThis is my solution which gives TLE on 179/179 test case, and i don\\'t know why. The test case itself is an empty string and an empty words array which should be an invalid testcase."
                    },
                    {
                        "username": "Chirag27",
                        "content": "can someone explain why the s =\"aaaaaaaaaa\"(like 1000 times) and words=[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"](like 10000 time sagain is the only test case that is giving tle wth this approach, not able to find or figure out the ans to this case.\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n      \\n        //DEFINE WINDOW LENGTH;\\n        int n = words.size();\\n        int slen = s.length();\\n        int wordlen = words[0].length();\\n        int windowsize = n*wordlen;\\n\\n   \\n\\n        //put in map\\n        unordered_map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[words[i]]++;\\n        }\\n\\n        if(slen==windowsize && m.size()==1)\\n        {\\n            return {0};\\n        }\\n\\n        int si = 0;\\n        int ei = 0;\\n\\n        unordered_map<string,int> temp;\\n\\n        vector<int> ans;\\n\\n        while(ei<slen)\\n        {\\n            if((ei-si+1)<windowsize)\\n            {\\n                ei++;\\n            }\\n            else if((ei-si+1)==windowsize)\\n            {\\n                //do some work\\n                temp = m;\\n                string t = s.substr(si,ei-si+1);\\n        \\n               \\n                int i =0;\\n\\n                while(i<t.length())\\n                {\\n                    string sub = t.substr(i,wordlen);\\n                    if(temp.find(sub)!=temp.end())\\n                    {\\n                        temp[sub]--;\\n                    }\\n                    if(temp[sub]==0)\\n                    {\\n                        temp.erase(sub);\\n                    }\\n                    i = i + wordlen;\\n                }\\n                if(temp.size()==0)\\n                {\\n                    ans.push_back(si);\\n                }\\n                si = si+1;\\n                ei = ei+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "lucifer870",
                        "content": "Why my sol is giving tle\\n\\n\\nclass Solution {\\nprivate:\\n    map<string,int> mp,mp1;\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words.size()*(words[0].length());\\n        int nn = words[0].length();\\n        for(auto i : words)mp[i]++;\\n        vector<int> ans;\\n        for(int i=0;s.length()-len+1>i;i++){\\n            string x = s.substr(i,len);\\n            for(int j=0;x.length()>j;j = j + nn)\\n            {\\n                mp1[x.substr(j,nn)]++;\\n            }   \\n            if(mp == mp1)ans.push_back(i);\\n            mp1.clear();\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1993064,
                "content": [
                    {
                        "username": "vladgenyuk29",
                        "content": "Is \"ab\" * 5000 and [\\'ab\\', \\'ba\\'] * 100 an edge case, my code works well by wtf is this hell (175/179)?"
                    },
                    {
                        "username": "dpw82",
                        "content": "Memory limit exceeded. s3 the biggest string to test the final length for the answer. \n\n\n` public void helper(String s, String s2, String[] words){\n        if(leg == words.length){\n            s3+=s2;\n            s2 = \"\";\n            leg = 0;\n        }\n\n        for(int i = 0; i < words.length; i++){\n            helper(s, s2 + words[i], words);\n            leg++;\n        }\n    }`\n\n"
                    },
                    {
                        "username": "niclim65",
                        "content": "Got TLE with 179/179 testcases passed., why?"
                    },
                    {
                        "username": "niclim65",
                        "content": "[@Vibhor_1435](/Vibhor_1435) I got it, the way I reset my map was just a little more inefficient. Overall time complexity did not change"
                    },
                    {
                        "username": "Vibhor_1435",
                        "content": "yes same problem\\n"
                    },
                    {
                        "username": "SekharGanesh97",
                        "content": "Can we use this Package over here :  import com.google.common.base.Splitter\\ni could not able to use this above package here."
                    },
                    {
                        "username": "shivanihibare",
                        "content": "last expected input is empty which is causing TLE\\n"
                    },
                    {
                        "username": "anantverma711",
                        "content": "Passed all the testcases, still got a TLE"
                    },
                    {
                        "username": "edcr1790",
                        "content": "You might need to read this: https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "How sliding window gives us the solution ,I am able to generate concatenated string permutations but after that I am using a substring method which is giving TLE. Should I use algorithm like LPS array to find the substring.Thanks in advance."
                    },
                    {
                        "username": "snehel4510",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> counts;\\n        vector<int> indexes;\\n        for(string word : words)\\n            counts[word]++;\\n        int n = s.length(), num = words.size();\\n        if (n == 0 || num == 0) return indexes;\\n        int len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            unordered_map<string, int> seen;\\n            int j = 0;\\n            for (; j < num; j++) {\\n                string word = s.substr(i + j * len, len);\\n                if (counts.find(word) != counts.end()) {\\n                    seen[word]++;\\n                    if (seen[word] > counts[word])\\n                        break;\\n                }\\n                else break;\\n            }\\n            if (j == num) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```\\n\\nThis is my solution which gives TLE on 179/179 test case, and i don\\'t know why. The test case itself is an empty string and an empty words array which should be an invalid testcase."
                    },
                    {
                        "username": "Chirag27",
                        "content": "can someone explain why the s =\"aaaaaaaaaa\"(like 1000 times) and words=[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"](like 10000 time sagain is the only test case that is giving tle wth this approach, not able to find or figure out the ans to this case.\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n      \\n        //DEFINE WINDOW LENGTH;\\n        int n = words.size();\\n        int slen = s.length();\\n        int wordlen = words[0].length();\\n        int windowsize = n*wordlen;\\n\\n   \\n\\n        //put in map\\n        unordered_map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[words[i]]++;\\n        }\\n\\n        if(slen==windowsize && m.size()==1)\\n        {\\n            return {0};\\n        }\\n\\n        int si = 0;\\n        int ei = 0;\\n\\n        unordered_map<string,int> temp;\\n\\n        vector<int> ans;\\n\\n        while(ei<slen)\\n        {\\n            if((ei-si+1)<windowsize)\\n            {\\n                ei++;\\n            }\\n            else if((ei-si+1)==windowsize)\\n            {\\n                //do some work\\n                temp = m;\\n                string t = s.substr(si,ei-si+1);\\n        \\n               \\n                int i =0;\\n\\n                while(i<t.length())\\n                {\\n                    string sub = t.substr(i,wordlen);\\n                    if(temp.find(sub)!=temp.end())\\n                    {\\n                        temp[sub]--;\\n                    }\\n                    if(temp[sub]==0)\\n                    {\\n                        temp.erase(sub);\\n                    }\\n                    i = i + wordlen;\\n                }\\n                if(temp.size()==0)\\n                {\\n                    ans.push_back(si);\\n                }\\n                si = si+1;\\n                ei = ei+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "lucifer870",
                        "content": "Why my sol is giving tle\\n\\n\\nclass Solution {\\nprivate:\\n    map<string,int> mp,mp1;\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words.size()*(words[0].length());\\n        int nn = words[0].length();\\n        for(auto i : words)mp[i]++;\\n        vector<int> ans;\\n        for(int i=0;s.length()-len+1>i;i++){\\n            string x = s.substr(i,len);\\n            for(int j=0;x.length()>j;j = j + nn)\\n            {\\n                mp1[x.substr(j,nn)]++;\\n            }   \\n            if(mp == mp1)ans.push_back(i);\\n            mp1.clear();\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1990459,
                "content": [
                    {
                        "username": "vladgenyuk29",
                        "content": "Is \"ab\" * 5000 and [\\'ab\\', \\'ba\\'] * 100 an edge case, my code works well by wtf is this hell (175/179)?"
                    },
                    {
                        "username": "dpw82",
                        "content": "Memory limit exceeded. s3 the biggest string to test the final length for the answer. \n\n\n` public void helper(String s, String s2, String[] words){\n        if(leg == words.length){\n            s3+=s2;\n            s2 = \"\";\n            leg = 0;\n        }\n\n        for(int i = 0; i < words.length; i++){\n            helper(s, s2 + words[i], words);\n            leg++;\n        }\n    }`\n\n"
                    },
                    {
                        "username": "niclim65",
                        "content": "Got TLE with 179/179 testcases passed., why?"
                    },
                    {
                        "username": "niclim65",
                        "content": "[@Vibhor_1435](/Vibhor_1435) I got it, the way I reset my map was just a little more inefficient. Overall time complexity did not change"
                    },
                    {
                        "username": "Vibhor_1435",
                        "content": "yes same problem\\n"
                    },
                    {
                        "username": "SekharGanesh97",
                        "content": "Can we use this Package over here :  import com.google.common.base.Splitter\\ni could not able to use this above package here."
                    },
                    {
                        "username": "shivanihibare",
                        "content": "last expected input is empty which is causing TLE\\n"
                    },
                    {
                        "username": "anantverma711",
                        "content": "Passed all the testcases, still got a TLE"
                    },
                    {
                        "username": "edcr1790",
                        "content": "You might need to read this: https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "How sliding window gives us the solution ,I am able to generate concatenated string permutations but after that I am using a substring method which is giving TLE. Should I use algorithm like LPS array to find the substring.Thanks in advance."
                    },
                    {
                        "username": "snehel4510",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> counts;\\n        vector<int> indexes;\\n        for(string word : words)\\n            counts[word]++;\\n        int n = s.length(), num = words.size();\\n        if (n == 0 || num == 0) return indexes;\\n        int len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            unordered_map<string, int> seen;\\n            int j = 0;\\n            for (; j < num; j++) {\\n                string word = s.substr(i + j * len, len);\\n                if (counts.find(word) != counts.end()) {\\n                    seen[word]++;\\n                    if (seen[word] > counts[word])\\n                        break;\\n                }\\n                else break;\\n            }\\n            if (j == num) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```\\n\\nThis is my solution which gives TLE on 179/179 test case, and i don\\'t know why. The test case itself is an empty string and an empty words array which should be an invalid testcase."
                    },
                    {
                        "username": "Chirag27",
                        "content": "can someone explain why the s =\"aaaaaaaaaa\"(like 1000 times) and words=[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"](like 10000 time sagain is the only test case that is giving tle wth this approach, not able to find or figure out the ans to this case.\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n      \\n        //DEFINE WINDOW LENGTH;\\n        int n = words.size();\\n        int slen = s.length();\\n        int wordlen = words[0].length();\\n        int windowsize = n*wordlen;\\n\\n   \\n\\n        //put in map\\n        unordered_map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[words[i]]++;\\n        }\\n\\n        if(slen==windowsize && m.size()==1)\\n        {\\n            return {0};\\n        }\\n\\n        int si = 0;\\n        int ei = 0;\\n\\n        unordered_map<string,int> temp;\\n\\n        vector<int> ans;\\n\\n        while(ei<slen)\\n        {\\n            if((ei-si+1)<windowsize)\\n            {\\n                ei++;\\n            }\\n            else if((ei-si+1)==windowsize)\\n            {\\n                //do some work\\n                temp = m;\\n                string t = s.substr(si,ei-si+1);\\n        \\n               \\n                int i =0;\\n\\n                while(i<t.length())\\n                {\\n                    string sub = t.substr(i,wordlen);\\n                    if(temp.find(sub)!=temp.end())\\n                    {\\n                        temp[sub]--;\\n                    }\\n                    if(temp[sub]==0)\\n                    {\\n                        temp.erase(sub);\\n                    }\\n                    i = i + wordlen;\\n                }\\n                if(temp.size()==0)\\n                {\\n                    ans.push_back(si);\\n                }\\n                si = si+1;\\n                ei = ei+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "lucifer870",
                        "content": "Why my sol is giving tle\\n\\n\\nclass Solution {\\nprivate:\\n    map<string,int> mp,mp1;\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words.size()*(words[0].length());\\n        int nn = words[0].length();\\n        for(auto i : words)mp[i]++;\\n        vector<int> ans;\\n        for(int i=0;s.length()-len+1>i;i++){\\n            string x = s.substr(i,len);\\n            for(int j=0;x.length()>j;j = j + nn)\\n            {\\n                mp1[x.substr(j,nn)]++;\\n            }   \\n            if(mp == mp1)ans.push_back(i);\\n            mp1.clear();\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1980032,
                "content": [
                    {
                        "username": "vladgenyuk29",
                        "content": "Is \"ab\" * 5000 and [\\'ab\\', \\'ba\\'] * 100 an edge case, my code works well by wtf is this hell (175/179)?"
                    },
                    {
                        "username": "dpw82",
                        "content": "Memory limit exceeded. s3 the biggest string to test the final length for the answer. \n\n\n` public void helper(String s, String s2, String[] words){\n        if(leg == words.length){\n            s3+=s2;\n            s2 = \"\";\n            leg = 0;\n        }\n\n        for(int i = 0; i < words.length; i++){\n            helper(s, s2 + words[i], words);\n            leg++;\n        }\n    }`\n\n"
                    },
                    {
                        "username": "niclim65",
                        "content": "Got TLE with 179/179 testcases passed., why?"
                    },
                    {
                        "username": "niclim65",
                        "content": "[@Vibhor_1435](/Vibhor_1435) I got it, the way I reset my map was just a little more inefficient. Overall time complexity did not change"
                    },
                    {
                        "username": "Vibhor_1435",
                        "content": "yes same problem\\n"
                    },
                    {
                        "username": "SekharGanesh97",
                        "content": "Can we use this Package over here :  import com.google.common.base.Splitter\\ni could not able to use this above package here."
                    },
                    {
                        "username": "shivanihibare",
                        "content": "last expected input is empty which is causing TLE\\n"
                    },
                    {
                        "username": "anantverma711",
                        "content": "Passed all the testcases, still got a TLE"
                    },
                    {
                        "username": "edcr1790",
                        "content": "You might need to read this: https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "How sliding window gives us the solution ,I am able to generate concatenated string permutations but after that I am using a substring method which is giving TLE. Should I use algorithm like LPS array to find the substring.Thanks in advance."
                    },
                    {
                        "username": "snehel4510",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> counts;\\n        vector<int> indexes;\\n        for(string word : words)\\n            counts[word]++;\\n        int n = s.length(), num = words.size();\\n        if (n == 0 || num == 0) return indexes;\\n        int len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            unordered_map<string, int> seen;\\n            int j = 0;\\n            for (; j < num; j++) {\\n                string word = s.substr(i + j * len, len);\\n                if (counts.find(word) != counts.end()) {\\n                    seen[word]++;\\n                    if (seen[word] > counts[word])\\n                        break;\\n                }\\n                else break;\\n            }\\n            if (j == num) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```\\n\\nThis is my solution which gives TLE on 179/179 test case, and i don\\'t know why. The test case itself is an empty string and an empty words array which should be an invalid testcase."
                    },
                    {
                        "username": "Chirag27",
                        "content": "can someone explain why the s =\"aaaaaaaaaa\"(like 1000 times) and words=[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"](like 10000 time sagain is the only test case that is giving tle wth this approach, not able to find or figure out the ans to this case.\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n      \\n        //DEFINE WINDOW LENGTH;\\n        int n = words.size();\\n        int slen = s.length();\\n        int wordlen = words[0].length();\\n        int windowsize = n*wordlen;\\n\\n   \\n\\n        //put in map\\n        unordered_map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[words[i]]++;\\n        }\\n\\n        if(slen==windowsize && m.size()==1)\\n        {\\n            return {0};\\n        }\\n\\n        int si = 0;\\n        int ei = 0;\\n\\n        unordered_map<string,int> temp;\\n\\n        vector<int> ans;\\n\\n        while(ei<slen)\\n        {\\n            if((ei-si+1)<windowsize)\\n            {\\n                ei++;\\n            }\\n            else if((ei-si+1)==windowsize)\\n            {\\n                //do some work\\n                temp = m;\\n                string t = s.substr(si,ei-si+1);\\n        \\n               \\n                int i =0;\\n\\n                while(i<t.length())\\n                {\\n                    string sub = t.substr(i,wordlen);\\n                    if(temp.find(sub)!=temp.end())\\n                    {\\n                        temp[sub]--;\\n                    }\\n                    if(temp[sub]==0)\\n                    {\\n                        temp.erase(sub);\\n                    }\\n                    i = i + wordlen;\\n                }\\n                if(temp.size()==0)\\n                {\\n                    ans.push_back(si);\\n                }\\n                si = si+1;\\n                ei = ei+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "lucifer870",
                        "content": "Why my sol is giving tle\\n\\n\\nclass Solution {\\nprivate:\\n    map<string,int> mp,mp1;\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words.size()*(words[0].length());\\n        int nn = words[0].length();\\n        for(auto i : words)mp[i]++;\\n        vector<int> ans;\\n        for(int i=0;s.length()-len+1>i;i++){\\n            string x = s.substr(i,len);\\n            for(int j=0;x.length()>j;j = j + nn)\\n            {\\n                mp1[x.substr(j,nn)]++;\\n            }   \\n            if(mp == mp1)ans.push_back(i);\\n            mp1.clear();\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1976913,
                "content": [
                    {
                        "username": "vladgenyuk29",
                        "content": "Is \"ab\" * 5000 and [\\'ab\\', \\'ba\\'] * 100 an edge case, my code works well by wtf is this hell (175/179)?"
                    },
                    {
                        "username": "dpw82",
                        "content": "Memory limit exceeded. s3 the biggest string to test the final length for the answer. \n\n\n` public void helper(String s, String s2, String[] words){\n        if(leg == words.length){\n            s3+=s2;\n            s2 = \"\";\n            leg = 0;\n        }\n\n        for(int i = 0; i < words.length; i++){\n            helper(s, s2 + words[i], words);\n            leg++;\n        }\n    }`\n\n"
                    },
                    {
                        "username": "niclim65",
                        "content": "Got TLE with 179/179 testcases passed., why?"
                    },
                    {
                        "username": "niclim65",
                        "content": "[@Vibhor_1435](/Vibhor_1435) I got it, the way I reset my map was just a little more inefficient. Overall time complexity did not change"
                    },
                    {
                        "username": "Vibhor_1435",
                        "content": "yes same problem\\n"
                    },
                    {
                        "username": "SekharGanesh97",
                        "content": "Can we use this Package over here :  import com.google.common.base.Splitter\\ni could not able to use this above package here."
                    },
                    {
                        "username": "shivanihibare",
                        "content": "last expected input is empty which is causing TLE\\n"
                    },
                    {
                        "username": "anantverma711",
                        "content": "Passed all the testcases, still got a TLE"
                    },
                    {
                        "username": "edcr1790",
                        "content": "You might need to read this: https://leetcode.com/discuss/feedback/3270801/All-testcases-passed-but-verdict-TLE-with-an-empty-Last-Executed-Input/1826434"
                    },
                    {
                        "username": "dasarisairam",
                        "content": "How sliding window gives us the solution ,I am able to generate concatenated string permutations but after that I am using a substring method which is giving TLE. Should I use algorithm like LPS array to find the substring.Thanks in advance."
                    },
                    {
                        "username": "snehel4510",
                        "content": "```cpp\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        unordered_map<string, int> counts;\\n        vector<int> indexes;\\n        for(string word : words)\\n            counts[word]++;\\n        int n = s.length(), num = words.size();\\n        if (n == 0 || num == 0) return indexes;\\n        int len = words[0].length();\\n        for (int i = 0; i < n - num * len + 1; i++) {\\n            unordered_map<string, int> seen;\\n            int j = 0;\\n            for (; j < num; j++) {\\n                string word = s.substr(i + j * len, len);\\n                if (counts.find(word) != counts.end()) {\\n                    seen[word]++;\\n                    if (seen[word] > counts[word])\\n                        break;\\n                }\\n                else break;\\n            }\\n            if (j == num) indexes.push_back(i);\\n        }\\n        return indexes;\\n    }\\n};\\n```\\n\\nThis is my solution which gives TLE on 179/179 test case, and i don\\'t know why. The test case itself is an empty string and an empty words array which should be an invalid testcase."
                    },
                    {
                        "username": "Chirag27",
                        "content": "can someone explain why the s =\"aaaaaaaaaa\"(like 1000 times) and words=[\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\",\"a\"](like 10000 time sagain is the only test case that is giving tle wth this approach, not able to find or figure out the ans to this case.\\n\\n\\nclass Solution {\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) \\n    {\\n      \\n        //DEFINE WINDOW LENGTH;\\n        int n = words.size();\\n        int slen = s.length();\\n        int wordlen = words[0].length();\\n        int windowsize = n*wordlen;\\n\\n   \\n\\n        //put in map\\n        unordered_map<string,int> m;\\n        for(int i=0;i<n;i++)\\n        {\\n            m[words[i]]++;\\n        }\\n\\n        if(slen==windowsize && m.size()==1)\\n        {\\n            return {0};\\n        }\\n\\n        int si = 0;\\n        int ei = 0;\\n\\n        unordered_map<string,int> temp;\\n\\n        vector<int> ans;\\n\\n        while(ei<slen)\\n        {\\n            if((ei-si+1)<windowsize)\\n            {\\n                ei++;\\n            }\\n            else if((ei-si+1)==windowsize)\\n            {\\n                //do some work\\n                temp = m;\\n                string t = s.substr(si,ei-si+1);\\n        \\n               \\n                int i =0;\\n\\n                while(i<t.length())\\n                {\\n                    string sub = t.substr(i,wordlen);\\n                    if(temp.find(sub)!=temp.end())\\n                    {\\n                        temp[sub]--;\\n                    }\\n                    if(temp[sub]==0)\\n                    {\\n                        temp.erase(sub);\\n                    }\\n                    i = i + wordlen;\\n                }\\n                if(temp.size()==0)\\n                {\\n                    ans.push_back(si);\\n                }\\n                si = si+1;\\n                ei = ei+1;\\n            }\\n        }\\n        return ans;\\n    }\\n};"
                    },
                    {
                        "username": "lucifer870",
                        "content": "Why my sol is giving tle\\n\\n\\nclass Solution {\\nprivate:\\n    map<string,int> mp,mp1;\\npublic:\\n    vector<int> findSubstring(string s, vector<string>& words) {\\n        int len = words.size()*(words[0].length());\\n        int nn = words[0].length();\\n        for(auto i : words)mp[i]++;\\n        vector<int> ans;\\n        for(int i=0;s.length()-len+1>i;i++){\\n            string x = s.substr(i,len);\\n            for(int j=0;x.length()>j;j = j + nn)\\n            {\\n                mp1[x.substr(j,nn)]++;\\n            }   \\n            if(mp == mp1)ans.push_back(i);\\n            mp1.clear();\\n        }\\n        return ans;\\n    }\\n};"
                    }
                ]
            },
            {
                "id": 1972336,
                "content": [
                    {
                        "username": "Satvik__",
                        "content": "Just a heads up, consider this case as well\\n```java\\n\"barfoofoxobarfhefoobarman\"\\n[\"arf\",\"rfo\",\"ofo\",\"xob\"]\\n```"
                    },
                    {
                        "username": "jschnall",
                        "content": "It\\'d be nice if they stated whether the list of words were unique, but since they didn\\'t, I guess I need to use a map instead of a set to be safe."
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "// Code 1:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    if(hm.get(x) != h2.get(x)){\n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\n// Code 2:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            \n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    int b = h2.get(x);\n                    int a = hm.get(x);\n                    if(a != b){                       \n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\nBoth of the above codes are exactly same except that  hashmap comparing condiation but still code 2 is returning correct answer but code 1 don't\nCan tell me why?"
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "Tried this but not able to handle situation where words get repeated\\n\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        int n = s.length();\\n        int wordLen = words[0].length();\\n        int total = (words.length*wordLen);\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],-1);\\n        }\\n\\n        int start = 0;\\n        int len = 0;\\n        int index = 0;\\n\\n        while(start<n-wordLen){\\n            if(len==total){\\n                ans.add(index);\\n                start=index+wordLen;\\n                index+=wordLen;\\n                len=0;\\n            }else{\\n\\n                String str = s.substring(start,start+wordLen);\\n                if(map.containsKey(str)){\\n                    \\n                    if(map.get(str)<=index || map.get(str)>=start){\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        len+=wordLen;\\n                    }else{\\n                        len = wordLen;\\n                        index= start;\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        \\n                    }\\n                   \\n                }else{\\n                    start+=1;\\n                    index=start;\\n                    len=0;\\n                }\\n            }\\n        }\\n\\n        if(len==total){\\n            ans.add(start-len);\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "andykim112",
                        "content": "I am not understanding the question even though abcdef is in there why isn\\'t acdbef not part of the permutation? it has all of the component,"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first part of that combined word is \"ac\" but \"ac\" is not in the list of words provided."
                    },
                    {
                        "username": "psionl0",
                        "content": "What a nasty challenge!\\n\\nThe theory was straightforward enough but I got caught by all sorts of edge cases: It turns out that the same permutation can appear at several spots in string s (not evident by the sample cases) and, of course, in the larger test cases, ints simply won\\'t do.\\n\\nI managed to get the code to work for 151 test cases but test case 152 is of the form:\\ns= \"pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefg...\\n(there is not enough space to list the entire s) and\\nwords =[\"dhvf\",\"sind\",\"ffsl\",\"yekr\",\"zwzq\",\"kpeo\",\"cila\",\"tfty\",\"modg\",\"ztjg\",\"ybty\",\"heqg\",\"cpwo\",\"gdcj\",\"lnle\",\"sefg\",\"vimw\",\"bxcb\"]\\n\\nMy answer was [] but the correct answer was supposed to be [935]. How am I supposed to debug this test case? (Even if I successfully did so, I am bound to run into a TLE the way my form has been going today)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@TheMarvelFan](/TheMarvelFan) I am reluctant to post unsuccessful code on this forum but as far as I can tell, my code is correctly generating all of the permutations of concatenated words. The remainder of the algorithm is about using a sliding window with each permutation and locating the starting index of where they matched. Since I didn\\'t know how many starting indexes I would find, I put them all in a linked list then transferred them to an array (and sorted them) once I was done.\\n\\nIf you have a location, I could post the code for your perusal."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "what was your alorithm"
                    },
                    {
                        "username": "codemonksr",
                        "content": "Kept failing the last cases as it was telling me I wasn\\'t outputting an answer at all. Turns out the time limit exceeded exception wasn\\'t being shown properly :/"
                    },
                    {
                        "username": "angu95600",
                        "content": "Classical question of sliding video and hashmaps."
                    },
                    {
                        "username": "PradyumnT",
                        "content": "Hii, from DTU??\\n"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Why even trying if chatGPT can solve it?"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nOutput []\\nExpected [13]\\nHow is this possible, if you can only get to the 12 as index because of the multiplier which is 4.\\n"
                    }
                ]
            },
            {
                "id": 1959113,
                "content": [
                    {
                        "username": "Satvik__",
                        "content": "Just a heads up, consider this case as well\\n```java\\n\"barfoofoxobarfhefoobarman\"\\n[\"arf\",\"rfo\",\"ofo\",\"xob\"]\\n```"
                    },
                    {
                        "username": "jschnall",
                        "content": "It\\'d be nice if they stated whether the list of words were unique, but since they didn\\'t, I guess I need to use a map instead of a set to be safe."
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "// Code 1:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    if(hm.get(x) != h2.get(x)){\n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\n// Code 2:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            \n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    int b = h2.get(x);\n                    int a = hm.get(x);\n                    if(a != b){                       \n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\nBoth of the above codes are exactly same except that  hashmap comparing condiation but still code 2 is returning correct answer but code 1 don't\nCan tell me why?"
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "Tried this but not able to handle situation where words get repeated\\n\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        int n = s.length();\\n        int wordLen = words[0].length();\\n        int total = (words.length*wordLen);\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],-1);\\n        }\\n\\n        int start = 0;\\n        int len = 0;\\n        int index = 0;\\n\\n        while(start<n-wordLen){\\n            if(len==total){\\n                ans.add(index);\\n                start=index+wordLen;\\n                index+=wordLen;\\n                len=0;\\n            }else{\\n\\n                String str = s.substring(start,start+wordLen);\\n                if(map.containsKey(str)){\\n                    \\n                    if(map.get(str)<=index || map.get(str)>=start){\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        len+=wordLen;\\n                    }else{\\n                        len = wordLen;\\n                        index= start;\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        \\n                    }\\n                   \\n                }else{\\n                    start+=1;\\n                    index=start;\\n                    len=0;\\n                }\\n            }\\n        }\\n\\n        if(len==total){\\n            ans.add(start-len);\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "andykim112",
                        "content": "I am not understanding the question even though abcdef is in there why isn\\'t acdbef not part of the permutation? it has all of the component,"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first part of that combined word is \"ac\" but \"ac\" is not in the list of words provided."
                    },
                    {
                        "username": "psionl0",
                        "content": "What a nasty challenge!\\n\\nThe theory was straightforward enough but I got caught by all sorts of edge cases: It turns out that the same permutation can appear at several spots in string s (not evident by the sample cases) and, of course, in the larger test cases, ints simply won\\'t do.\\n\\nI managed to get the code to work for 151 test cases but test case 152 is of the form:\\ns= \"pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefg...\\n(there is not enough space to list the entire s) and\\nwords =[\"dhvf\",\"sind\",\"ffsl\",\"yekr\",\"zwzq\",\"kpeo\",\"cila\",\"tfty\",\"modg\",\"ztjg\",\"ybty\",\"heqg\",\"cpwo\",\"gdcj\",\"lnle\",\"sefg\",\"vimw\",\"bxcb\"]\\n\\nMy answer was [] but the correct answer was supposed to be [935]. How am I supposed to debug this test case? (Even if I successfully did so, I am bound to run into a TLE the way my form has been going today)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@TheMarvelFan](/TheMarvelFan) I am reluctant to post unsuccessful code on this forum but as far as I can tell, my code is correctly generating all of the permutations of concatenated words. The remainder of the algorithm is about using a sliding window with each permutation and locating the starting index of where they matched. Since I didn\\'t know how many starting indexes I would find, I put them all in a linked list then transferred them to an array (and sorted them) once I was done.\\n\\nIf you have a location, I could post the code for your perusal."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "what was your alorithm"
                    },
                    {
                        "username": "codemonksr",
                        "content": "Kept failing the last cases as it was telling me I wasn\\'t outputting an answer at all. Turns out the time limit exceeded exception wasn\\'t being shown properly :/"
                    },
                    {
                        "username": "angu95600",
                        "content": "Classical question of sliding video and hashmaps."
                    },
                    {
                        "username": "PradyumnT",
                        "content": "Hii, from DTU??\\n"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Why even trying if chatGPT can solve it?"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nOutput []\\nExpected [13]\\nHow is this possible, if you can only get to the 12 as index because of the multiplier which is 4.\\n"
                    }
                ]
            },
            {
                "id": 1904416,
                "content": [
                    {
                        "username": "Satvik__",
                        "content": "Just a heads up, consider this case as well\\n```java\\n\"barfoofoxobarfhefoobarman\"\\n[\"arf\",\"rfo\",\"ofo\",\"xob\"]\\n```"
                    },
                    {
                        "username": "jschnall",
                        "content": "It\\'d be nice if they stated whether the list of words were unique, but since they didn\\'t, I guess I need to use a map instead of a set to be safe."
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "// Code 1:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    if(hm.get(x) != h2.get(x)){\n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\n// Code 2:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            \n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    int b = h2.get(x);\n                    int a = hm.get(x);\n                    if(a != b){                       \n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\nBoth of the above codes are exactly same except that  hashmap comparing condiation but still code 2 is returning correct answer but code 1 don't\nCan tell me why?"
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "Tried this but not able to handle situation where words get repeated\\n\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        int n = s.length();\\n        int wordLen = words[0].length();\\n        int total = (words.length*wordLen);\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],-1);\\n        }\\n\\n        int start = 0;\\n        int len = 0;\\n        int index = 0;\\n\\n        while(start<n-wordLen){\\n            if(len==total){\\n                ans.add(index);\\n                start=index+wordLen;\\n                index+=wordLen;\\n                len=0;\\n            }else{\\n\\n                String str = s.substring(start,start+wordLen);\\n                if(map.containsKey(str)){\\n                    \\n                    if(map.get(str)<=index || map.get(str)>=start){\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        len+=wordLen;\\n                    }else{\\n                        len = wordLen;\\n                        index= start;\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        \\n                    }\\n                   \\n                }else{\\n                    start+=1;\\n                    index=start;\\n                    len=0;\\n                }\\n            }\\n        }\\n\\n        if(len==total){\\n            ans.add(start-len);\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "andykim112",
                        "content": "I am not understanding the question even though abcdef is in there why isn\\'t acdbef not part of the permutation? it has all of the component,"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first part of that combined word is \"ac\" but \"ac\" is not in the list of words provided."
                    },
                    {
                        "username": "psionl0",
                        "content": "What a nasty challenge!\\n\\nThe theory was straightforward enough but I got caught by all sorts of edge cases: It turns out that the same permutation can appear at several spots in string s (not evident by the sample cases) and, of course, in the larger test cases, ints simply won\\'t do.\\n\\nI managed to get the code to work for 151 test cases but test case 152 is of the form:\\ns= \"pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefg...\\n(there is not enough space to list the entire s) and\\nwords =[\"dhvf\",\"sind\",\"ffsl\",\"yekr\",\"zwzq\",\"kpeo\",\"cila\",\"tfty\",\"modg\",\"ztjg\",\"ybty\",\"heqg\",\"cpwo\",\"gdcj\",\"lnle\",\"sefg\",\"vimw\",\"bxcb\"]\\n\\nMy answer was [] but the correct answer was supposed to be [935]. How am I supposed to debug this test case? (Even if I successfully did so, I am bound to run into a TLE the way my form has been going today)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@TheMarvelFan](/TheMarvelFan) I am reluctant to post unsuccessful code on this forum but as far as I can tell, my code is correctly generating all of the permutations of concatenated words. The remainder of the algorithm is about using a sliding window with each permutation and locating the starting index of where they matched. Since I didn\\'t know how many starting indexes I would find, I put them all in a linked list then transferred them to an array (and sorted them) once I was done.\\n\\nIf you have a location, I could post the code for your perusal."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "what was your alorithm"
                    },
                    {
                        "username": "codemonksr",
                        "content": "Kept failing the last cases as it was telling me I wasn\\'t outputting an answer at all. Turns out the time limit exceeded exception wasn\\'t being shown properly :/"
                    },
                    {
                        "username": "angu95600",
                        "content": "Classical question of sliding video and hashmaps."
                    },
                    {
                        "username": "PradyumnT",
                        "content": "Hii, from DTU??\\n"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Why even trying if chatGPT can solve it?"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nOutput []\\nExpected [13]\\nHow is this possible, if you can only get to the 12 as index because of the multiplier which is 4.\\n"
                    }
                ]
            },
            {
                "id": 1890285,
                "content": [
                    {
                        "username": "Satvik__",
                        "content": "Just a heads up, consider this case as well\\n```java\\n\"barfoofoxobarfhefoobarman\"\\n[\"arf\",\"rfo\",\"ofo\",\"xob\"]\\n```"
                    },
                    {
                        "username": "jschnall",
                        "content": "It\\'d be nice if they stated whether the list of words were unique, but since they didn\\'t, I guess I need to use a map instead of a set to be safe."
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "// Code 1:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    if(hm.get(x) != h2.get(x)){\n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\n// Code 2:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            \n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    int b = h2.get(x);\n                    int a = hm.get(x);\n                    if(a != b){                       \n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\nBoth of the above codes are exactly same except that  hashmap comparing condiation but still code 2 is returning correct answer but code 1 don't\nCan tell me why?"
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "Tried this but not able to handle situation where words get repeated\\n\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        int n = s.length();\\n        int wordLen = words[0].length();\\n        int total = (words.length*wordLen);\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],-1);\\n        }\\n\\n        int start = 0;\\n        int len = 0;\\n        int index = 0;\\n\\n        while(start<n-wordLen){\\n            if(len==total){\\n                ans.add(index);\\n                start=index+wordLen;\\n                index+=wordLen;\\n                len=0;\\n            }else{\\n\\n                String str = s.substring(start,start+wordLen);\\n                if(map.containsKey(str)){\\n                    \\n                    if(map.get(str)<=index || map.get(str)>=start){\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        len+=wordLen;\\n                    }else{\\n                        len = wordLen;\\n                        index= start;\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        \\n                    }\\n                   \\n                }else{\\n                    start+=1;\\n                    index=start;\\n                    len=0;\\n                }\\n            }\\n        }\\n\\n        if(len==total){\\n            ans.add(start-len);\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "andykim112",
                        "content": "I am not understanding the question even though abcdef is in there why isn\\'t acdbef not part of the permutation? it has all of the component,"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first part of that combined word is \"ac\" but \"ac\" is not in the list of words provided."
                    },
                    {
                        "username": "psionl0",
                        "content": "What a nasty challenge!\\n\\nThe theory was straightforward enough but I got caught by all sorts of edge cases: It turns out that the same permutation can appear at several spots in string s (not evident by the sample cases) and, of course, in the larger test cases, ints simply won\\'t do.\\n\\nI managed to get the code to work for 151 test cases but test case 152 is of the form:\\ns= \"pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefg...\\n(there is not enough space to list the entire s) and\\nwords =[\"dhvf\",\"sind\",\"ffsl\",\"yekr\",\"zwzq\",\"kpeo\",\"cila\",\"tfty\",\"modg\",\"ztjg\",\"ybty\",\"heqg\",\"cpwo\",\"gdcj\",\"lnle\",\"sefg\",\"vimw\",\"bxcb\"]\\n\\nMy answer was [] but the correct answer was supposed to be [935]. How am I supposed to debug this test case? (Even if I successfully did so, I am bound to run into a TLE the way my form has been going today)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@TheMarvelFan](/TheMarvelFan) I am reluctant to post unsuccessful code on this forum but as far as I can tell, my code is correctly generating all of the permutations of concatenated words. The remainder of the algorithm is about using a sliding window with each permutation and locating the starting index of where they matched. Since I didn\\'t know how many starting indexes I would find, I put them all in a linked list then transferred them to an array (and sorted them) once I was done.\\n\\nIf you have a location, I could post the code for your perusal."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "what was your alorithm"
                    },
                    {
                        "username": "codemonksr",
                        "content": "Kept failing the last cases as it was telling me I wasn\\'t outputting an answer at all. Turns out the time limit exceeded exception wasn\\'t being shown properly :/"
                    },
                    {
                        "username": "angu95600",
                        "content": "Classical question of sliding video and hashmaps."
                    },
                    {
                        "username": "PradyumnT",
                        "content": "Hii, from DTU??\\n"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Why even trying if chatGPT can solve it?"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nOutput []\\nExpected [13]\\nHow is this possible, if you can only get to the 12 as index because of the multiplier which is 4.\\n"
                    }
                ]
            },
            {
                "id": 1863723,
                "content": [
                    {
                        "username": "Satvik__",
                        "content": "Just a heads up, consider this case as well\\n```java\\n\"barfoofoxobarfhefoobarman\"\\n[\"arf\",\"rfo\",\"ofo\",\"xob\"]\\n```"
                    },
                    {
                        "username": "jschnall",
                        "content": "It\\'d be nice if they stated whether the list of words were unique, but since they didn\\'t, I guess I need to use a map instead of a set to be safe."
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "// Code 1:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    if(hm.get(x) != h2.get(x)){\n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\n// Code 2:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            \n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    int b = h2.get(x);\n                    int a = hm.get(x);\n                    if(a != b){                       \n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\nBoth of the above codes are exactly same except that  hashmap comparing condiation but still code 2 is returning correct answer but code 1 don't\nCan tell me why?"
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "Tried this but not able to handle situation where words get repeated\\n\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        int n = s.length();\\n        int wordLen = words[0].length();\\n        int total = (words.length*wordLen);\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],-1);\\n        }\\n\\n        int start = 0;\\n        int len = 0;\\n        int index = 0;\\n\\n        while(start<n-wordLen){\\n            if(len==total){\\n                ans.add(index);\\n                start=index+wordLen;\\n                index+=wordLen;\\n                len=0;\\n            }else{\\n\\n                String str = s.substring(start,start+wordLen);\\n                if(map.containsKey(str)){\\n                    \\n                    if(map.get(str)<=index || map.get(str)>=start){\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        len+=wordLen;\\n                    }else{\\n                        len = wordLen;\\n                        index= start;\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        \\n                    }\\n                   \\n                }else{\\n                    start+=1;\\n                    index=start;\\n                    len=0;\\n                }\\n            }\\n        }\\n\\n        if(len==total){\\n            ans.add(start-len);\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "andykim112",
                        "content": "I am not understanding the question even though abcdef is in there why isn\\'t acdbef not part of the permutation? it has all of the component,"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first part of that combined word is \"ac\" but \"ac\" is not in the list of words provided."
                    },
                    {
                        "username": "psionl0",
                        "content": "What a nasty challenge!\\n\\nThe theory was straightforward enough but I got caught by all sorts of edge cases: It turns out that the same permutation can appear at several spots in string s (not evident by the sample cases) and, of course, in the larger test cases, ints simply won\\'t do.\\n\\nI managed to get the code to work for 151 test cases but test case 152 is of the form:\\ns= \"pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefg...\\n(there is not enough space to list the entire s) and\\nwords =[\"dhvf\",\"sind\",\"ffsl\",\"yekr\",\"zwzq\",\"kpeo\",\"cila\",\"tfty\",\"modg\",\"ztjg\",\"ybty\",\"heqg\",\"cpwo\",\"gdcj\",\"lnle\",\"sefg\",\"vimw\",\"bxcb\"]\\n\\nMy answer was [] but the correct answer was supposed to be [935]. How am I supposed to debug this test case? (Even if I successfully did so, I am bound to run into a TLE the way my form has been going today)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@TheMarvelFan](/TheMarvelFan) I am reluctant to post unsuccessful code on this forum but as far as I can tell, my code is correctly generating all of the permutations of concatenated words. The remainder of the algorithm is about using a sliding window with each permutation and locating the starting index of where they matched. Since I didn\\'t know how many starting indexes I would find, I put them all in a linked list then transferred them to an array (and sorted them) once I was done.\\n\\nIf you have a location, I could post the code for your perusal."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "what was your alorithm"
                    },
                    {
                        "username": "codemonksr",
                        "content": "Kept failing the last cases as it was telling me I wasn\\'t outputting an answer at all. Turns out the time limit exceeded exception wasn\\'t being shown properly :/"
                    },
                    {
                        "username": "angu95600",
                        "content": "Classical question of sliding video and hashmaps."
                    },
                    {
                        "username": "PradyumnT",
                        "content": "Hii, from DTU??\\n"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Why even trying if chatGPT can solve it?"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nOutput []\\nExpected [13]\\nHow is this possible, if you can only get to the 12 as index because of the multiplier which is 4.\\n"
                    }
                ]
            },
            {
                "id": 1849983,
                "content": [
                    {
                        "username": "Satvik__",
                        "content": "Just a heads up, consider this case as well\\n```java\\n\"barfoofoxobarfhefoobarman\"\\n[\"arf\",\"rfo\",\"ofo\",\"xob\"]\\n```"
                    },
                    {
                        "username": "jschnall",
                        "content": "It\\'d be nice if they stated whether the list of words were unique, but since they didn\\'t, I guess I need to use a map instead of a set to be safe."
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "// Code 1:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    if(hm.get(x) != h2.get(x)){\n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\n// Code 2:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            \n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    int b = h2.get(x);\n                    int a = hm.get(x);\n                    if(a != b){                       \n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\nBoth of the above codes are exactly same except that  hashmap comparing condiation but still code 2 is returning correct answer but code 1 don't\nCan tell me why?"
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "Tried this but not able to handle situation where words get repeated\\n\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        int n = s.length();\\n        int wordLen = words[0].length();\\n        int total = (words.length*wordLen);\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],-1);\\n        }\\n\\n        int start = 0;\\n        int len = 0;\\n        int index = 0;\\n\\n        while(start<n-wordLen){\\n            if(len==total){\\n                ans.add(index);\\n                start=index+wordLen;\\n                index+=wordLen;\\n                len=0;\\n            }else{\\n\\n                String str = s.substring(start,start+wordLen);\\n                if(map.containsKey(str)){\\n                    \\n                    if(map.get(str)<=index || map.get(str)>=start){\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        len+=wordLen;\\n                    }else{\\n                        len = wordLen;\\n                        index= start;\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        \\n                    }\\n                   \\n                }else{\\n                    start+=1;\\n                    index=start;\\n                    len=0;\\n                }\\n            }\\n        }\\n\\n        if(len==total){\\n            ans.add(start-len);\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "andykim112",
                        "content": "I am not understanding the question even though abcdef is in there why isn\\'t acdbef not part of the permutation? it has all of the component,"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first part of that combined word is \"ac\" but \"ac\" is not in the list of words provided."
                    },
                    {
                        "username": "psionl0",
                        "content": "What a nasty challenge!\\n\\nThe theory was straightforward enough but I got caught by all sorts of edge cases: It turns out that the same permutation can appear at several spots in string s (not evident by the sample cases) and, of course, in the larger test cases, ints simply won\\'t do.\\n\\nI managed to get the code to work for 151 test cases but test case 152 is of the form:\\ns= \"pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefg...\\n(there is not enough space to list the entire s) and\\nwords =[\"dhvf\",\"sind\",\"ffsl\",\"yekr\",\"zwzq\",\"kpeo\",\"cila\",\"tfty\",\"modg\",\"ztjg\",\"ybty\",\"heqg\",\"cpwo\",\"gdcj\",\"lnle\",\"sefg\",\"vimw\",\"bxcb\"]\\n\\nMy answer was [] but the correct answer was supposed to be [935]. How am I supposed to debug this test case? (Even if I successfully did so, I am bound to run into a TLE the way my form has been going today)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@TheMarvelFan](/TheMarvelFan) I am reluctant to post unsuccessful code on this forum but as far as I can tell, my code is correctly generating all of the permutations of concatenated words. The remainder of the algorithm is about using a sliding window with each permutation and locating the starting index of where they matched. Since I didn\\'t know how many starting indexes I would find, I put them all in a linked list then transferred them to an array (and sorted them) once I was done.\\n\\nIf you have a location, I could post the code for your perusal."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "what was your alorithm"
                    },
                    {
                        "username": "codemonksr",
                        "content": "Kept failing the last cases as it was telling me I wasn\\'t outputting an answer at all. Turns out the time limit exceeded exception wasn\\'t being shown properly :/"
                    },
                    {
                        "username": "angu95600",
                        "content": "Classical question of sliding video and hashmaps."
                    },
                    {
                        "username": "PradyumnT",
                        "content": "Hii, from DTU??\\n"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Why even trying if chatGPT can solve it?"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nOutput []\\nExpected [13]\\nHow is this possible, if you can only get to the 12 as index because of the multiplier which is 4.\\n"
                    }
                ]
            },
            {
                "id": 1806068,
                "content": [
                    {
                        "username": "Satvik__",
                        "content": "Just a heads up, consider this case as well\\n```java\\n\"barfoofoxobarfhefoobarman\"\\n[\"arf\",\"rfo\",\"ofo\",\"xob\"]\\n```"
                    },
                    {
                        "username": "jschnall",
                        "content": "It\\'d be nice if they stated whether the list of words were unique, but since they didn\\'t, I guess I need to use a map instead of a set to be safe."
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "// Code 1:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    if(hm.get(x) != h2.get(x)){\n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\n// Code 2:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            \n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    int b = h2.get(x);\n                    int a = hm.get(x);\n                    if(a != b){                       \n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\nBoth of the above codes are exactly same except that  hashmap comparing condiation but still code 2 is returning correct answer but code 1 don't\nCan tell me why?"
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "Tried this but not able to handle situation where words get repeated\\n\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        int n = s.length();\\n        int wordLen = words[0].length();\\n        int total = (words.length*wordLen);\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],-1);\\n        }\\n\\n        int start = 0;\\n        int len = 0;\\n        int index = 0;\\n\\n        while(start<n-wordLen){\\n            if(len==total){\\n                ans.add(index);\\n                start=index+wordLen;\\n                index+=wordLen;\\n                len=0;\\n            }else{\\n\\n                String str = s.substring(start,start+wordLen);\\n                if(map.containsKey(str)){\\n                    \\n                    if(map.get(str)<=index || map.get(str)>=start){\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        len+=wordLen;\\n                    }else{\\n                        len = wordLen;\\n                        index= start;\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        \\n                    }\\n                   \\n                }else{\\n                    start+=1;\\n                    index=start;\\n                    len=0;\\n                }\\n            }\\n        }\\n\\n        if(len==total){\\n            ans.add(start-len);\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "andykim112",
                        "content": "I am not understanding the question even though abcdef is in there why isn\\'t acdbef not part of the permutation? it has all of the component,"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first part of that combined word is \"ac\" but \"ac\" is not in the list of words provided."
                    },
                    {
                        "username": "psionl0",
                        "content": "What a nasty challenge!\\n\\nThe theory was straightforward enough but I got caught by all sorts of edge cases: It turns out that the same permutation can appear at several spots in string s (not evident by the sample cases) and, of course, in the larger test cases, ints simply won\\'t do.\\n\\nI managed to get the code to work for 151 test cases but test case 152 is of the form:\\ns= \"pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefg...\\n(there is not enough space to list the entire s) and\\nwords =[\"dhvf\",\"sind\",\"ffsl\",\"yekr\",\"zwzq\",\"kpeo\",\"cila\",\"tfty\",\"modg\",\"ztjg\",\"ybty\",\"heqg\",\"cpwo\",\"gdcj\",\"lnle\",\"sefg\",\"vimw\",\"bxcb\"]\\n\\nMy answer was [] but the correct answer was supposed to be [935]. How am I supposed to debug this test case? (Even if I successfully did so, I am bound to run into a TLE the way my form has been going today)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@TheMarvelFan](/TheMarvelFan) I am reluctant to post unsuccessful code on this forum but as far as I can tell, my code is correctly generating all of the permutations of concatenated words. The remainder of the algorithm is about using a sliding window with each permutation and locating the starting index of where they matched. Since I didn\\'t know how many starting indexes I would find, I put them all in a linked list then transferred them to an array (and sorted them) once I was done.\\n\\nIf you have a location, I could post the code for your perusal."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "what was your alorithm"
                    },
                    {
                        "username": "codemonksr",
                        "content": "Kept failing the last cases as it was telling me I wasn\\'t outputting an answer at all. Turns out the time limit exceeded exception wasn\\'t being shown properly :/"
                    },
                    {
                        "username": "angu95600",
                        "content": "Classical question of sliding video and hashmaps."
                    },
                    {
                        "username": "PradyumnT",
                        "content": "Hii, from DTU??\\n"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Why even trying if chatGPT can solve it?"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nOutput []\\nExpected [13]\\nHow is this possible, if you can only get to the 12 as index because of the multiplier which is 4.\\n"
                    }
                ]
            },
            {
                "id": 1799104,
                "content": [
                    {
                        "username": "Satvik__",
                        "content": "Just a heads up, consider this case as well\\n```java\\n\"barfoofoxobarfhefoobarman\"\\n[\"arf\",\"rfo\",\"ofo\",\"xob\"]\\n```"
                    },
                    {
                        "username": "jschnall",
                        "content": "It\\'d be nice if they stated whether the list of words were unique, but since they didn\\'t, I guess I need to use a map instead of a set to be safe."
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "// Code 1:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    if(hm.get(x) != h2.get(x)){\n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\n// Code 2:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            \n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    int b = h2.get(x);\n                    int a = hm.get(x);\n                    if(a != b){                       \n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\nBoth of the above codes are exactly same except that  hashmap comparing condiation but still code 2 is returning correct answer but code 1 don't\nCan tell me why?"
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "Tried this but not able to handle situation where words get repeated\\n\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        int n = s.length();\\n        int wordLen = words[0].length();\\n        int total = (words.length*wordLen);\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],-1);\\n        }\\n\\n        int start = 0;\\n        int len = 0;\\n        int index = 0;\\n\\n        while(start<n-wordLen){\\n            if(len==total){\\n                ans.add(index);\\n                start=index+wordLen;\\n                index+=wordLen;\\n                len=0;\\n            }else{\\n\\n                String str = s.substring(start,start+wordLen);\\n                if(map.containsKey(str)){\\n                    \\n                    if(map.get(str)<=index || map.get(str)>=start){\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        len+=wordLen;\\n                    }else{\\n                        len = wordLen;\\n                        index= start;\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        \\n                    }\\n                   \\n                }else{\\n                    start+=1;\\n                    index=start;\\n                    len=0;\\n                }\\n            }\\n        }\\n\\n        if(len==total){\\n            ans.add(start-len);\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "andykim112",
                        "content": "I am not understanding the question even though abcdef is in there why isn\\'t acdbef not part of the permutation? it has all of the component,"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first part of that combined word is \"ac\" but \"ac\" is not in the list of words provided."
                    },
                    {
                        "username": "psionl0",
                        "content": "What a nasty challenge!\\n\\nThe theory was straightforward enough but I got caught by all sorts of edge cases: It turns out that the same permutation can appear at several spots in string s (not evident by the sample cases) and, of course, in the larger test cases, ints simply won\\'t do.\\n\\nI managed to get the code to work for 151 test cases but test case 152 is of the form:\\ns= \"pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefg...\\n(there is not enough space to list the entire s) and\\nwords =[\"dhvf\",\"sind\",\"ffsl\",\"yekr\",\"zwzq\",\"kpeo\",\"cila\",\"tfty\",\"modg\",\"ztjg\",\"ybty\",\"heqg\",\"cpwo\",\"gdcj\",\"lnle\",\"sefg\",\"vimw\",\"bxcb\"]\\n\\nMy answer was [] but the correct answer was supposed to be [935]. How am I supposed to debug this test case? (Even if I successfully did so, I am bound to run into a TLE the way my form has been going today)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@TheMarvelFan](/TheMarvelFan) I am reluctant to post unsuccessful code on this forum but as far as I can tell, my code is correctly generating all of the permutations of concatenated words. The remainder of the algorithm is about using a sliding window with each permutation and locating the starting index of where they matched. Since I didn\\'t know how many starting indexes I would find, I put them all in a linked list then transferred them to an array (and sorted them) once I was done.\\n\\nIf you have a location, I could post the code for your perusal."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "what was your alorithm"
                    },
                    {
                        "username": "codemonksr",
                        "content": "Kept failing the last cases as it was telling me I wasn\\'t outputting an answer at all. Turns out the time limit exceeded exception wasn\\'t being shown properly :/"
                    },
                    {
                        "username": "angu95600",
                        "content": "Classical question of sliding video and hashmaps."
                    },
                    {
                        "username": "PradyumnT",
                        "content": "Hii, from DTU??\\n"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Why even trying if chatGPT can solve it?"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nOutput []\\nExpected [13]\\nHow is this possible, if you can only get to the 12 as index because of the multiplier which is 4.\\n"
                    }
                ]
            },
            {
                "id": 1798495,
                "content": [
                    {
                        "username": "Satvik__",
                        "content": "Just a heads up, consider this case as well\\n```java\\n\"barfoofoxobarfhefoobarman\"\\n[\"arf\",\"rfo\",\"ofo\",\"xob\"]\\n```"
                    },
                    {
                        "username": "jschnall",
                        "content": "It\\'d be nice if they stated whether the list of words were unique, but since they didn\\'t, I guess I need to use a map instead of a set to be safe."
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "// Code 1:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    if(hm.get(x) != h2.get(x)){\n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\n// Code 2:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            \n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    int b = h2.get(x);\n                    int a = hm.get(x);\n                    if(a != b){                       \n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\nBoth of the above codes are exactly same except that  hashmap comparing condiation but still code 2 is returning correct answer but code 1 don't\nCan tell me why?"
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "Tried this but not able to handle situation where words get repeated\\n\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        int n = s.length();\\n        int wordLen = words[0].length();\\n        int total = (words.length*wordLen);\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],-1);\\n        }\\n\\n        int start = 0;\\n        int len = 0;\\n        int index = 0;\\n\\n        while(start<n-wordLen){\\n            if(len==total){\\n                ans.add(index);\\n                start=index+wordLen;\\n                index+=wordLen;\\n                len=0;\\n            }else{\\n\\n                String str = s.substring(start,start+wordLen);\\n                if(map.containsKey(str)){\\n                    \\n                    if(map.get(str)<=index || map.get(str)>=start){\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        len+=wordLen;\\n                    }else{\\n                        len = wordLen;\\n                        index= start;\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        \\n                    }\\n                   \\n                }else{\\n                    start+=1;\\n                    index=start;\\n                    len=0;\\n                }\\n            }\\n        }\\n\\n        if(len==total){\\n            ans.add(start-len);\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "andykim112",
                        "content": "I am not understanding the question even though abcdef is in there why isn\\'t acdbef not part of the permutation? it has all of the component,"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first part of that combined word is \"ac\" but \"ac\" is not in the list of words provided."
                    },
                    {
                        "username": "psionl0",
                        "content": "What a nasty challenge!\\n\\nThe theory was straightforward enough but I got caught by all sorts of edge cases: It turns out that the same permutation can appear at several spots in string s (not evident by the sample cases) and, of course, in the larger test cases, ints simply won\\'t do.\\n\\nI managed to get the code to work for 151 test cases but test case 152 is of the form:\\ns= \"pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefg...\\n(there is not enough space to list the entire s) and\\nwords =[\"dhvf\",\"sind\",\"ffsl\",\"yekr\",\"zwzq\",\"kpeo\",\"cila\",\"tfty\",\"modg\",\"ztjg\",\"ybty\",\"heqg\",\"cpwo\",\"gdcj\",\"lnle\",\"sefg\",\"vimw\",\"bxcb\"]\\n\\nMy answer was [] but the correct answer was supposed to be [935]. How am I supposed to debug this test case? (Even if I successfully did so, I am bound to run into a TLE the way my form has been going today)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@TheMarvelFan](/TheMarvelFan) I am reluctant to post unsuccessful code on this forum but as far as I can tell, my code is correctly generating all of the permutations of concatenated words. The remainder of the algorithm is about using a sliding window with each permutation and locating the starting index of where they matched. Since I didn\\'t know how many starting indexes I would find, I put them all in a linked list then transferred them to an array (and sorted them) once I was done.\\n\\nIf you have a location, I could post the code for your perusal."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "what was your alorithm"
                    },
                    {
                        "username": "codemonksr",
                        "content": "Kept failing the last cases as it was telling me I wasn\\'t outputting an answer at all. Turns out the time limit exceeded exception wasn\\'t being shown properly :/"
                    },
                    {
                        "username": "angu95600",
                        "content": "Classical question of sliding video and hashmaps."
                    },
                    {
                        "username": "PradyumnT",
                        "content": "Hii, from DTU??\\n"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Why even trying if chatGPT can solve it?"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nOutput []\\nExpected [13]\\nHow is this possible, if you can only get to the 12 as index because of the multiplier which is 4.\\n"
                    }
                ]
            },
            {
                "id": 1797523,
                "content": [
                    {
                        "username": "Satvik__",
                        "content": "Just a heads up, consider this case as well\\n```java\\n\"barfoofoxobarfhefoobarman\"\\n[\"arf\",\"rfo\",\"ofo\",\"xob\"]\\n```"
                    },
                    {
                        "username": "jschnall",
                        "content": "It\\'d be nice if they stated whether the list of words were unique, but since they didn\\'t, I guess I need to use a map instead of a set to be safe."
                    },
                    {
                        "username": "arnavkumarpalia",
                        "content": "// Code 1:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    if(hm.get(x) != h2.get(x)){\n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\n// Code 2:\nclass Solution {\n    public List<Integer> findSubstring(String s, String[] words) {\n        List<Integer> ans = new ArrayList();\n        int len = words[0].length()*words.length;\n        int wordlen = words[0].length();\n        HashMap<String,Integer> hm = new HashMap();\n        for(String str : words){\n            hm.put(str,hm.getOrDefault(str,0)+1);\n        }\n        int i = 0;\n        while(i+len <= s.length()){\n            HashMap<String,Integer> h2 = new HashMap();\n            boolean flag = true;\n            \n            for(int j = i; j < i+len;){\n                h2.put(s.substring(j,j+wordlen),h2.getOrDefault(s.substring(j,j+wordlen),0)+1);\n                j += wordlen;\n            }\n            for(String x : hm.keySet()){\n                if(h2.containsKey(x)){\n                    int b = h2.get(x);\n                    int a = hm.get(x);\n                    if(a != b){                       \n                        flag = false;\n                        break;\n                    }\n                }\n                else{\n                    flag = false;\n                    break;\n                }\n            }\n            if(flag){\n                ans.add(i);\n            }\n            i++;\n        }\n        return ans;\n    }\n}\n\nBoth of the above codes are exactly same except that  hashmap comparing condiation but still code 2 is returning correct answer but code 1 don't\nCan tell me why?"
                    },
                    {
                        "username": "manyabajpai26",
                        "content": "Tried this but not able to handle situation where words get repeated\\n\\nclass Solution {\\n    public List<Integer> findSubstring(String s, String[] words) {\\n        \\n        int n = s.length();\\n        int wordLen = words[0].length();\\n        int total = (words.length*wordLen);\\n        \\n        Map<String,Integer> map = new HashMap<>();\\n        List<Integer> ans = new ArrayList<>();\\n\\n        for(int i=0;i<words.length;i++){\\n            map.put(words[i],-1);\\n        }\\n\\n        int start = 0;\\n        int len = 0;\\n        int index = 0;\\n\\n        while(start<n-wordLen){\\n            if(len==total){\\n                ans.add(index);\\n                start=index+wordLen;\\n                index+=wordLen;\\n                len=0;\\n            }else{\\n\\n                String str = s.substring(start,start+wordLen);\\n                if(map.containsKey(str)){\\n                    \\n                    if(map.get(str)<=index || map.get(str)>=start){\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        len+=wordLen;\\n                    }else{\\n                        len = wordLen;\\n                        index= start;\\n                        map.put(str,start);\\n                        start+=wordLen;\\n                        \\n                    }\\n                   \\n                }else{\\n                    start+=1;\\n                    index=start;\\n                    len=0;\\n                }\\n            }\\n        }\\n\\n        if(len==total){\\n            ans.add(start-len);\\n        }\\n\\n        return ans;\\n\\n        \\n    }\\n}"
                    },
                    {
                        "username": "andykim112",
                        "content": "I am not understanding the question even though abcdef is in there why isn\\'t acdbef not part of the permutation? it has all of the component,"
                    },
                    {
                        "username": "psionl0",
                        "content": "The first part of that combined word is \"ac\" but \"ac\" is not in the list of words provided."
                    },
                    {
                        "username": "psionl0",
                        "content": "What a nasty challenge!\\n\\nThe theory was straightforward enough but I got caught by all sorts of edge cases: It turns out that the same permutation can appear at several spots in string s (not evident by the sample cases) and, of course, in the larger test cases, ints simply won\\'t do.\\n\\nI managed to get the code to work for 151 test cases but test case 152 is of the form:\\ns= \"pjzkrkevzztxductzzxmxsvwjkxpvukmfjywwetvfnujhweiybwvvsrfequzkhossmootkmyxgjgfordrpapjuunmqnxxdrqrfgkrsjqbszgiqlcfnrpjlcwdrvbumtotzylshdvccdmsqoadfrpsvnwpizlwszrtyclhgilklydbmfhuywotjmktnwrfvizvnmfvvqfiokkdprznnnjycttprkxpuykhmpchiksyucbmtabiqkisgbhxngmhezrrqvayfsxauampdpxtafniiwfvdufhtwajrbkxtjzqjnfocdhekumttuqwovfjrgulhekcpjszyynadxhnttgmnxkduqmmyhzfnjhducesctufqbumxbamalqudeibljgbspeotkgvddcwgxidaiqcvgwykhbysjzlzfbupkqunuqtraxrlptivshhbihtsigtpipguhbhctcvubnhqipncyxfjebdnjyetnlnvmuxhzsdahkrscewabejifmxombiamxvauuitoltyymsarqcuuoezcbqpdaprxmsrickwpgwpsoplhugbikbkotzrtqkscekkgwjycfnvwfgdzogjzjvpcvixnsqsxacfwndzvrwrycwxrcismdhqapoojegggkocyrdtkzmiekhxoppctytvphjynrhtcvxcobxbcjjivtfjiwmduhzjokkbctweqtigwfhzorjlkpuuliaipbtfldinyetoybvugevwvhhhweejogrghllsouipabfafcxnhukcbtmxzshoyyufjhzadhrelweszbfgwpkzlwxkogyogutscvuhcllphshivnoteztpxsaoaacgxyaztuixhunrowzljqfqrahosheukhahhbiaxqzfmmwcjxountkevsvpbzjnilwpoermxrtlfroqoclexxisrdhvfsindffslyekrzwzqkpeocilatftymodgztjgybtyheqgcpwogdcjlnlesefg...\\n(there is not enough space to list the entire s) and\\nwords =[\"dhvf\",\"sind\",\"ffsl\",\"yekr\",\"zwzq\",\"kpeo\",\"cila\",\"tfty\",\"modg\",\"ztjg\",\"ybty\",\"heqg\",\"cpwo\",\"gdcj\",\"lnle\",\"sefg\",\"vimw\",\"bxcb\"]\\n\\nMy answer was [] but the correct answer was supposed to be [935]. How am I supposed to debug this test case? (Even if I successfully did so, I am bound to run into a TLE the way my form has been going today)."
                    },
                    {
                        "username": "psionl0",
                        "content": "[@TheMarvelFan](/TheMarvelFan) I am reluctant to post unsuccessful code on this forum but as far as I can tell, my code is correctly generating all of the permutations of concatenated words. The remainder of the algorithm is about using a sliding window with each permutation and locating the starting index of where they matched. Since I didn\\'t know how many starting indexes I would find, I put them all in a linked list then transferred them to an array (and sorted them) once I was done.\\n\\nIf you have a location, I could post the code for your perusal."
                    },
                    {
                        "username": "TheMarvelFan",
                        "content": "what was your alorithm"
                    },
                    {
                        "username": "codemonksr",
                        "content": "Kept failing the last cases as it was telling me I wasn\\'t outputting an answer at all. Turns out the time limit exceeded exception wasn\\'t being shown properly :/"
                    },
                    {
                        "username": "angu95600",
                        "content": "Classical question of sliding video and hashmaps."
                    },
                    {
                        "username": "PradyumnT",
                        "content": "Hii, from DTU??\\n"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "Why even trying if chatGPT can solve it?"
                    },
                    {
                        "username": "Dany__Guty",
                        "content": "s = \"lingmindraboofooowingdingbarrwingmonkeypoundcake\" words = [\"fooo\",\"barr\",\"wing\",\"ding\",\"wing\"]\\nOutput []\\nExpected [13]\\nHow is this possible, if you can only get to the 12 as index because of the multiplier which is 4.\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Surrounded Regions",
        "question_content": "<p>Given an <code>m x n</code> matrix <code>board</code> containing <code>&#39;X&#39;</code> and <code>&#39;O&#39;</code>, <em>capture all regions that are 4-directionally&nbsp;surrounded by</em> <code>&#39;X&#39;</code>.</p>\n\n<p>A region is <strong>captured</strong> by flipping all <code>&#39;O&#39;</code>s into <code>&#39;X&#39;</code>s in that surrounded region.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/02/19/xogrid.jpg\" style=\"width: 550px; height: 237px;\" />\n<pre>\n<strong>Input:</strong> board = [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;O&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]\n<strong>Output:</strong> [[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;X&quot;,&quot;X&quot;,&quot;X&quot;],[&quot;X&quot;,&quot;O&quot;,&quot;X&quot;,&quot;X&quot;]]\n<strong>Explanation:</strong> Notice that an &#39;O&#39; should not be flipped if:\n- It is on the border, or\n- It is adjacent to an &#39;O&#39; that should not be flipped.\nThe bottom &#39;O&#39; is on the border, so it is not flipped.\nThe other three &#39;O&#39; form a surrounded region, so they are flipped.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> board = [[&quot;X&quot;]]\n<strong>Output:</strong> [[&quot;X&quot;]]\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>m == board.length</code></li>\n\t<li><code>n == board[i].length</code></li>\n\t<li><code>1 &lt;= m, n &lt;= 200</code></li>\n\t<li><code>board[i][j]</code> is <code>&#39;X&#39;</code> or <code>&#39;O&#39;</code>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 691675,
                "title": "c-beginner-friendly-boundary-dfs-inplace",
                "content": "```\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<char>>& board, int i, int j, int m, int n) {\\n        if(i<0 or j<0 or i>=m or j>=n or board[i][j] != \\'O\\') return;\\n        board[i][j] = \\'#\\';\\n        DFS(board, i-1, j, m, n);\\n        DFS(board, i+1, j, m, n);\\n        DFS(board, i, j-1, m, n);\\n        DFS(board, i, j+1, m, n);\\n    }\\n    \\n    void solve(vector<vector<char>>& board) {\\n      \\n      //We will use boundary DFS to solve this problem\\n        \\n      // Let\\'s analyze when an \\'O\\' cannot be flipped,\\n      // if it has atleast one \\'O\\' in it\\'s adjacent, AND ultimately this chain of adjacent \\'O\\'s is connected to some \\'O\\' which lies on boundary of board\\n        \\n      //consider these two cases for clarity :\\n      /*\\n        O\\'s won\\'t be flipped          O\\'s will be flipped\\n        [X O X X X]                   [X X X X X]     \\n        [X O O O X]                   [X O O O X]\\n        [X O X X X]                   [X O X X X] \\n        [X X X X X]                   [X X X X X]\\n      \\n      So we can conclude if a chain of adjacent O\\'s is connected some O on boundary then they cannot be flipped\\n      \\n      */\\n        \\n      //Steps to Solve :\\n      //1. Move over the boundary of board, and find O\\'s \\n      //2. Every time we find an O, perform DFS from it\\'s position\\n      //3. In DFS convert all \\'O\\' to \\'#\\'      (why?? so that we can differentiate which \\'O\\' can be flipped and which cannot be)   \\n      //4. After all DFSs have been performed, board contains three elements,#,O and X\\n      //5. \\'O\\' are left over elements which are not connected to any boundary O, so flip them to \\'X\\'\\n      //6. \\'#\\' are elements which cannot be flipped to \\'X\\', so flip them back to \\'O\\'\\n      //7. finally, Upvote the solution\\uD83D\\uDE0A   \\n        \\n      \\n     int m = board.size();\\n        \\n      if(m == 0) return;  \\n        \\n     int n = board[0].size();\\n     \\n     //Moving over firts and last column   \\n     for(int i=0; i<m; i++) {\\n         if(board[i][0] == \\'O\\')\\n             DFS(board, i, 0, m, n);\\n         if(board[i][n-1] == \\'O\\')\\n             DFS(board, i, n-1, m, n);\\n     }\\n        \\n        \\n     //Moving over first and last row   \\n     for(int j=0; j<n; j++) {\\n         if(board[0][j] == \\'O\\')\\n             DFS(board, 0, j, m, n);\\n         if(board[m-1][j] == \\'O\\')\\n             DFS(board, m-1, j, m, n);\\n     }\\n        \\n     for(int i=0; i<m; i++)\\n         for(int j=0; j<n; j++)\\n         {\\n             if(board[i][j] == \\'O\\')\\n                 board[i][j] = \\'X\\';\\n             if(board[i][j] == \\'#\\')\\n                 board[i][j] = \\'O\\';\\n         }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<char>>& board, int i, int j, int m, int n) {\\n        if(i<0 or j<0 or i>=m or j>=n or board[i][j] != \\'O\\') return;\\n        board[i][j] = \\'#\\';\\n        DFS(board, i-1, j, m, n);\\n        DFS(board, i+1, j, m, n);\\n        DFS(board, i, j-1, m, n);\\n        DFS(board, i, j+1, m, n);\\n    }\\n    \\n    void solve(vector<vector<char>>& board) {\\n      \\n      //We will use boundary DFS to solve this problem\\n        \\n      // Let\\'s analyze when an \\'O\\' cannot be flipped,\\n      // if it has atleast one \\'O\\' in it\\'s adjacent, AND ultimately this chain of adjacent \\'O\\'s is connected to some \\'O\\' which lies on boundary of board\\n        \\n      //consider these two cases for clarity :\\n      /*\\n        O\\'s won\\'t be flipped          O\\'s will be flipped\\n        [X O X X X]                   [X X X X X]     \\n        [X O O O X]                   [X O O O X]\\n        [X O X X X]                   [X O X X X] \\n        [X X X X X]                   [X X X X X]\\n      \\n      So we can conclude if a chain of adjacent O\\'s is connected some O on boundary then they cannot be flipped\\n      \\n      */\\n        \\n      //Steps to Solve :\\n      //1. Move over the boundary of board, and find O\\'s \\n      //2. Every time we find an O, perform DFS from it\\'s position\\n      //3. In DFS convert all \\'O\\' to \\'#\\'      (why?? so that we can differentiate which \\'O\\' can be flipped and which cannot be)   \\n      //4. After all DFSs have been performed, board contains three elements,#,O and X\\n      //5. \\'O\\' are left over elements which are not connected to any boundary O, so flip them to \\'X\\'\\n      //6. \\'#\\' are elements which cannot be flipped to \\'X\\', so flip them back to \\'O\\'\\n      //7. finally, Upvote the solution\\uD83D\\uDE0A   \\n        \\n      \\n     int m = board.size();\\n        \\n      if(m == 0) return;  \\n        \\n     int n = board[0].size();\\n     \\n     //Moving over firts and last column   \\n     for(int i=0; i<m; i++) {\\n         if(board[i][0] == \\'O\\')\\n             DFS(board, i, 0, m, n);\\n         if(board[i][n-1] == \\'O\\')\\n             DFS(board, i, n-1, m, n);\\n     }\\n        \\n        \\n     //Moving over first and last row   \\n     for(int j=0; j<n; j++) {\\n         if(board[0][j] == \\'O\\')\\n             DFS(board, 0, j, m, n);\\n         if(board[m-1][j] == \\'O\\')\\n             DFS(board, m-1, j, m, n);\\n     }\\n        \\n     for(int i=0; i<m; i++)\\n         for(int j=0; j<n; j++)\\n         {\\n             if(board[i][j] == \\'O\\')\\n                 board[i][j] = \\'X\\';\\n             if(board[i][j] == \\'#\\')\\n                 board[i][j] = \\'O\\';\\n         }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41612,
                "title": "a-really-simple-and-readable-c-solution-uff0conly-cost-12ms",
                "content": " - First, check the four border of the matrix. If there is a element is\\n   'O', alter it and all its neighbor 'O' elements to '1'.\\n   \\n   \\n - Then ,alter all the 'O' to 'X'\\n - At last,alter all the '1' to 'O'\\n\\nFor example:\\n\\n             X X X X           X X X X             X X X X\\n             X X O X  ->       X X O X    ->       X X X X\\n             X O X X           X 1 X X             X O X X\\n             X O X X           X 1 X X             X O X X\\n        \\n\\n    class Solution {\\n    public:\\n    \\tvoid solve(vector<vector<char>>& board) {\\n            int i,j;\\n            int row=board.size();\\n            if(!row)\\n            \\treturn;\\n            int col=board[0].size();\\n\\n    \\t\\tfor(i=0;i<row;i++){\\n    \\t\\t\\tcheck(board,i,0,row,col);\\n    \\t\\t\\tif(col>1)\\n    \\t\\t\\t\\tcheck(board,i,col-1,row,col);\\n    \\t\\t}\\n    \\t\\tfor(j=1;j+1<col;j++){\\n    \\t\\t\\tcheck(board,0,j,row,col);\\n    \\t\\t\\tif(row>1)\\n    \\t\\t\\t\\tcheck(board,row-1,j,row,col);\\n    \\t\\t}\\n    \\t\\tfor(i=0;i<row;i++)\\n    \\t\\t\\tfor(j=0;j<col;j++)\\n    \\t\\t\\t\\tif(board[i][j]=='O')\\n    \\t\\t\\t\\t\\tboard[i][j]='X';\\n    \\t\\tfor(i=0;i<row;i++)\\n    \\t\\t\\tfor(j=0;j<col;j++)\\n    \\t\\t\\t\\tif(board[i][j]=='1')\\n    \\t\\t\\t\\t\\tboard[i][j]='O';\\n        }\\n    \\tvoid check(vector<vector<char> >&vec,int i,int j,int row,int col){\\n    \\t\\tif(vec[i][j]=='O'){\\n    \\t\\t\\tvec[i][j]='1';\\n    \\t\\t\\tif(i>1)\\n    \\t\\t\\t\\tcheck(vec,i-1,j,row,col);\\n    \\t\\t\\tif(j>1)\\n    \\t\\t\\t\\tcheck(vec,i,j-1,row,col);\\n    \\t\\t\\tif(i+1<row)\\n    \\t\\t\\t\\tcheck(vec,i+1,j,row,col);\\n    \\t\\t\\tif(j+1<col)\\n    \\t\\t\\t\\tcheck(vec,i,j+1,row,col);\\n    \\t\\t}\\n    \\t}\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n    \\tvoid solve(vector<vector<char>>& board) {\\n            int i,j;\\n            int row=board.size();\\n            if(!row)\\n            \\treturn;\\n            int col=board[0].size();\\n\\n    \\t\\tfor(i=0;i<row;i++){\\n    \\t\\t\\tcheck(board,i,0,row,col);\\n    \\t\\t\\tif(col>1)\\n    \\t\\t\\t\\tcheck(board,i,col-1,row,col);\\n    \\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 41630,
                "title": "9-lines-python-148-ms",
                "content": "Phase 1: \"Save\" every O-region touching the border, changing its cells to 'S'.  \\nPhase 2: Change every 'S' on the board to 'O' and everything else to 'X'.\\n\\n    def solve(self, board):\\n        if not any(board): return\\n    \\n        m, n = len(board), len(board[0])\\n        save = [ij for k in range(m+n) for ij in ((0, k), (m-1, k), (k, 0), (k, n-1))]\\n        while save:\\n            i, j = save.pop()\\n            if 0 <= i < m and 0 <= j < n and board[i][j] == 'O':\\n                board[i][j] = 'S'\\n                save += (i, j-1), (i, j+1), (i-1, j), (i+1, j)\\n\\n        board[:] = [['XO'[c == 'S'] for c in row] for row in board]\\n\\nIn case you don't like my last line, you could do this instead:\\n\\n        for row in board:\\n            for i, c in enumerate(row):\\n                row[i] = 'XO'[c == 'S']",
                "solutionTags": [
                    "Python"
                ],
                "code": "Phase 1: \"Save\" every O-region touching the border, changing its cells to 'S'.  \\nPhase 2: Change every 'S' on the board to 'O' and everything else to 'X'.\\n\\n    def solve(self, board):\\n        if not any(board): return\\n    \\n        m, n = len(board), len(board[0])\\n        save = [ij for k in range(m+n) for ij in ((0, k), (m-1, k), (k, 0), (k, n-1))]\\n        while save:\\n            i, j = save.pop()\\n            if 0 <= i < m and 0 <= j < n and board[i][j] == 'O':\\n                board[i][j] = 'S'\\n                save += (i, j-1), (i, j+1), (i-1, j), (i+1, j)\\n\\n        board[:] = [['XO'[c == 'S'] for c in row] for row in board]\\n\\nIn case you don't like my last line, you could do this instead:\\n\\n        for row in board:\\n            for i, c in enumerate(row):\\n                row[i] = 'XO'[c == 'S']",
                "codeTag": "Python3"
            },
            {
                "id": 41633,
                "title": "java-dfs-boundary-cell-turning-solution-simple-and-clean-code-commented",
                "content": "   \\tpublic void solve(char[][] board) {\\n\\t\\tif (board.length == 0 || board[0].length == 0)\\n\\t\\t\\treturn;\\n\\t\\tif (board.length < 2 || board[0].length < 2)\\n\\t\\t\\treturn;\\n\\t\\tint m = board.length, n = board[0].length;\\n\\t\\t//Any 'O' connected to a boundary can't be turned to 'X', so ...\\n\\t\\t//Start from first and last column, turn 'O' to '*'.\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tif (board[i][0] == 'O')\\n\\t\\t\\t\\tboundaryDFS(board, i, 0);\\n\\t\\t\\tif (board[i][n-1] == 'O')\\n\\t\\t\\t\\tboundaryDFS(board, i, n-1);\\t\\n\\t\\t}\\n\\t\\t//Start from first and last row, turn '0' to '*'\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (board[0][j] == 'O')\\n\\t\\t\\t\\tboundaryDFS(board, 0, j);\\n\\t\\t\\tif (board[m-1][j] == 'O')\\n\\t\\t\\t\\tboundaryDFS(board, m-1, j);\\t\\n\\t\\t}\\n\\t\\t//post-prcessing, turn 'O' to 'X', '*' back to 'O', keep 'X' intact.\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (board[i][j] == 'O')\\n\\t\\t\\t\\t\\tboard[i][j] = 'X';\\n\\t\\t\\t\\telse if (board[i][j] == '*')\\n\\t\\t\\t\\t\\tboard[i][j] = 'O';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t//Use DFS algo to turn internal however boundary-connected 'O' to '*';\\n\\tprivate void boundaryDFS(char[][] board, int i, int j) {\\n\\t\\tif (i < 0 || i > board.length - 1 || j <0 || j > board[0].length - 1)\\n\\t\\t\\treturn;\\n\\t\\tif (board[i][j] == 'O')\\n\\t\\t\\tboard[i][j] = '*';\\n\\t\\tif (i > 1 && board[i-1][j] == 'O')\\n\\t\\t\\tboundaryDFS(board, i-1, j);\\n\\t\\tif (i < board.length - 2 && board[i+1][j] == 'O')\\n\\t\\t\\tboundaryDFS(board, i+1, j);\\n\\t\\tif (j > 1 && board[i][j-1] == 'O')\\n\\t\\t\\tboundaryDFS(board, i, j-1);\\n\\t\\tif (j < board[i].length - 2 && board[i][j+1] == 'O' )\\n\\t\\t\\tboundaryDFS(board, i, j+1);\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "   \\tpublic void solve(char[][] board) {\\n\\t\\tif (board.length == 0 || board[0].length == 0)\\n\\t\\t\\treturn;\\n\\t\\tif (board.length < 2 || board[0].length < 2)\\n\\t\\t\\treturn;\\n\\t\\tint m = board.length, n = board[0].length;\\n\\t\\t//Any 'O' connected to a boundary can't be turned to 'X', so ...\\n\\t\\t//Start from first and last column, turn 'O' to '*'.\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tif (board[i][0] == 'O')\\n\\t\\t\\t\\tboundaryDFS(board, i, 0);\\n\\t\\t\\tif (board[i][n-1] == 'O')\\n\\t\\t\\t\\tboundaryDFS(board, i, n-1);\\t\\n\\t\\t}\\n\\t\\t//Start from first and last row, turn '0' to '*'\\n\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\tif (board[0][j] == 'O')\\n\\t\\t\\t\\tboundaryDFS(board, 0, j);\\n\\t\\t\\tif (board[m-1][j] == 'O')\\n\\t\\t\\t\\tboundaryDFS(board, m-1, j);\\t\\n\\t\\t}\\n\\t\\t//post-prcessing, turn 'O' to 'X', '*' back to 'O', keep 'X' intact.\\n\\t\\tfor (int i = 0; i < m; i++) {\\n\\t\\t\\tfor (int j = 0; j < n; j++) {\\n\\t\\t\\t\\tif (board[i][j] == 'O')\\n\\t\\t\\t\\t\\tboard[i][j] = 'X';\\n\\t\\t\\t\\telse if (board[i][j] == '*')\\n\\t\\t\\t\\t\\tboard[i][j] = 'O';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\t//Use DFS algo to turn internal however boundary-connected 'O' to '*';\\n\\tprivate void boundaryDFS(char[][] board, int i, int j) {\\n\\t\\tif (i < 0 || i > board.length - 1 || j <0 || j > board[0].length - 1)\\n\\t\\t\\treturn;\\n\\t\\tif (board[i][j] == 'O')\\n\\t\\t\\tboard[i][j] = '*';\\n\\t\\tif (i > 1 && board[i-1][j] == 'O')\\n\\t\\t\\tboundaryDFS(board, i-1, j);\\n\\t\\tif (i < board.length - 2 && board[i+1][j] == 'O')\\n\\t\\t\\tboundaryDFS(board, i+1, j);\\n\\t\\tif (j > 1 && board[i][j-1] == 'O')\\n\\t\\t\\tboundaryDFS(board, i, j-1);\\n\\t\\tif (j < board[i].length - 2 && board[i][j+1] == 'O' )\\n\\t\\t\\tboundaryDFS(board, i, j+1);\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 41617,
                "title": "solve-it-using-union-find",
                "content": " \\n\\n    class UF\\n    {\\n    private:\\n    \\tint* id;     // id[i] = parent of i\\n    \\tint* rank;  // rank[i] = rank of subtree rooted at i (cannot be more than 31)\\n    \\tint count;    // number of components\\n    public:\\n    \\tUF(int N)\\n    \\t{\\n    \\t\\tcount = N;\\n    \\t\\tid = new int[N];\\n    \\t\\trank = new int[N];\\n    \\t\\tfor (int i = 0; i < N; i++) {\\n    \\t\\t\\tid[i] = i;\\n    \\t\\t\\trank[i] = 0;\\n    \\t\\t}\\n    \\t}\\n    \\t~UF()\\n    \\t{\\n    \\t\\tdelete [] id;\\n    \\t\\tdelete [] rank;\\n    \\t}\\n    \\tint find(int p) {\\n    \\t\\twhile (p != id[p]) {\\n    \\t\\t\\tid[p] = id[id[p]];    // path compression by halving\\n    \\t\\t\\tp = id[p];\\n    \\t\\t}\\n    \\t\\treturn p;\\n    \\t}\\n    \\tint getCount() {\\n    \\t\\treturn count;\\n    \\t}\\n    \\tbool connected(int p, int q) {\\n    \\t\\treturn find(p) == find(q);\\n    \\t}\\n    \\tvoid connect(int p, int q) {\\n    \\t\\tint i = find(p);\\n    \\t\\tint j = find(q);\\n    \\t\\tif (i == j) return;\\n    \\t\\tif (rank[i] < rank[j]) id[i] = j;\\n    \\t\\telse if (rank[i] > rank[j]) id[j] = i;\\n    \\t\\telse {\\n    \\t\\t\\tid[j] = i;\\n    \\t\\t\\trank[i]++;\\n    \\t\\t}\\n    \\t\\tcount--;\\n    \\t}\\n    };\\n    \\n    class Solution {\\n    public:\\n        void solve(vector<vector<char>> &board) {\\n            int n = board.size();\\n            if(n==0)    return;\\n            int m = board[0].size();\\n            UF uf = UF(n*m+1);\\n            \\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if((i==0||i==n-1||j==0||j==m-1)&&board[i][j]=='O') // if a 'O' node is on the boundry, connect it to the dummy node\\n                        uf.connect(i*m+j,n*m);\\n                    else if(board[i][j]=='O') // connect a 'O' node to its neighbour 'O' nodes\\n                    {\\n                        if(board[i-1][j]=='O')\\n                            uf.connect(i*m+j,(i-1)*m+j);\\n                        if(board[i+1][j]=='O')\\n                            uf.connect(i*m+j,(i+1)*m+j);\\n                        if(board[i][j-1]=='O')\\n                            uf.connect(i*m+j,i*m+j-1);\\n                        if(board[i][j+1]=='O')\\n                            uf.connect(i*m+j,i*m+j+1);\\n                    }\\n                }\\n            }\\n            \\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if(!uf.connected(i*m+j,n*m)){ // if a 'O' node is not connected to the dummy node, it is captured\\n                        board[i][j]='X';\\n                    }\\n                }\\n            }\\n        }\\n    };\\n\\nHi. So here is my accepted code using **Union Find** data structure. The idea comes from the observation that if a region is NOT captured, it is connected to the boundry. So if we connect all the 'O' nodes on the boundry to a dummy node, and then connect each 'O' node to its neighbour 'O' nodes, then we can tell directly whether a 'O' node is captured by checking whether it is connected to the dummy node.\\nFor more about Union Find, the first assignment in the algo1 may help:\\nhttps://www.coursera.org/course/algs4partI",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void solve(vector<vector<char>> &board) {\\n            int n = board.size();\\n            if(n==0)    return;\\n            int m = board[0].size();\\n            UF uf = UF(n*m+1);\\n            \\n            for(int i=0;i<n;i++){\\n                for(int j=0;j<m;j++){\\n                    if((i==0||i==n-1||j==0||j==m-1)&&board[i][j]=='O') // if a 'O' node is on the boundry, connect it to the dummy node\\n                        uf.connect(i*m+j,n*m);\\n                    else if(board[i][j]=='O') // connect a 'O' node to its neighbour 'O' nodes\\n                    {\\n                        if(board[i-1][j]=='O')\\n                            uf.connect(i*m+j,(i-1)*m+j);\\n                        if(board[i+1][j]=='O')\\n                            uf.connect(i*m+j,(i+1)*m+j);\\n                        if(board[i][j-1]=='O')\\n                            uf.connect(i*m+j,i*m+j-1);\\n                        if(board[i][j+1]=='O')\\n                            uf.connect(i*m+j,i*m+j+1);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 41652,
                "title": "python-easy-to-understand-dfs-and-bfs-solutions",
                "content": "```\\nclass Solution(object):\\n    # DFS\\n    def solve1(self, board):\\n        if not board or not board[0]:\\n            return \\n        for i in [0, len(board)-1]:\\n            for j in range(len(board[0])):\\n                self.dfs(board, i, j)   \\n        for i in range(len(board)):\\n            for j in [0, len(board[0])-1]:\\n                self.dfs(board, i, j)\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \\'O\\':\\n                    board[i][j] = \\'X\\'\\n                elif board[i][j] == \\'.\\':\\n                    board[i][j] = \\'O\\'\\n                \\n    def dfs(self, board, i, j):\\n        if 0 <= i < len(board) and 0 <= j < len(board[0]) and board[i][j] == \\'O\\':\\n            board[i][j] = \\'.\\'\\n            self.dfs(board, i+1, j)\\n            self.dfs(board, i-1, j)\\n            self.dfs(board, i, j+1)\\n            self.dfs(board, i, j-1)\\n                \\n    # BFS\\n    def solve(self, board):\\n        queue = collections.deque([])\\n        for r in range(len(board)):\\n            for c in range(len(board[0])):\\n                if (r in [0, len(board)-1] or c in [0, len(board[0])-1]) and board[r][c] == \"O\":\\n                    queue.append((r, c))\\n        while queue:\\n            r, c = queue.popleft()\\n            if 0<=r<len(board) and 0<=c<len(board[0]) and board[r][c] == \"O\":\\n                board[r][c] = \".\"\\n                queue.extend([(r-1, c),(r+1, c),(r, c-1),(r, c+1)])\\n        \\n        for r in range(len(board)):\\n            for c in range(len(board[0])):\\n                if board[r][c] == \"O\":\\n                    board[r][c] = \"X\"\\n                elif board[r][c] == \".\":\\n                    board[r][c] = \"O\"\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution(object):\\n    # DFS\\n    def solve1(self, board):\\n        if not board or not board[0]:\\n            return \\n        for i in [0, len(board)-1]:\\n            for j in range(len(board[0])):\\n                self.dfs(board, i, j)   \\n        for i in range(len(board)):\\n            for j in [0, len(board[0])-1]:\\n                self.dfs(board, i, j)\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \\'O\\':\\n                    board[i][j] = \\'X\\'\\n                elif board[i][j] == \\'.\\':\\n                    board[i][j] = \\'O\\'\\n                \\n    def dfs(self, board, i, j):\\n        if 0 <= i < len(board) and 0 <= j < len(board[0]) and board[i][j] == \\'O\\':\\n            board[i][j] = \\'.\\'\\n            self.dfs(board, i+1, j)\\n            self.dfs(board, i-1, j)\\n            self.dfs(board, i, j+1)\\n            self.dfs(board, i, j-1)\\n                \\n    # BFS\\n    def solve(self, board):\\n        queue = collections.deque([])\\n        for r in range(len(board)):\\n            for c in range(len(board[0])):\\n                if (r in [0, len(board)-1] or c in [0, len(board[0])-1]) and board[r][c] == \"O\":\\n                    queue.append((r, c))\\n        while queue:\\n            r, c = queue.popleft()\\n            if 0<=r<len(board) and 0<=c<len(board[0]) and board[r][c] == \"O\":\\n                board[r][c] = \".\"\\n                queue.extend([(r-1, c),(r+1, c),(r, c-1),(r, c+1)])\\n        \\n        for r in range(len(board)):\\n            for c in range(len(board[0])):\\n                if board[r][c] == \"O\":\\n                    board[r][c] = \"X\"\\n                elif board[r][c] == \".\":\\n                    board[r][c] = \"O\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691646,
                "title": "python-o-mn-3-colors-dfs-explained",
                "content": "In this problem we need to understand, what exactly surrouned by `\\'X\\'` means. It actually means that if we start from `\\'O\\'` at the border, and we traverse only `\\'O\\'`, only those `\\'O\\'` are **not surrouned** by `\\'X\\'`. So the plan is the following:\\n\\n1. Start dfs or bfs from all `\\'O\\'`, which are on the border.\\n2. When we traverse them, let us color them as `\\'T\\'`, temporary color.\\n3. Now, when we traverse all we wanted, all colors which are not `\\'T\\'` need to renamed to `\\'X\\'` and all colors which are `\\'T\\'` need to be renamed to `\\'O\\'`, and that is all!\\n\\n**Compexity**: time complextiy is `O(mn)`, where `m` and `n` are sizes of our board. Additional space complexity can also go upto `O(mn)` to keep stack of recursion.\\n\\n```\\nclass Solution:\\n    def dfs(self, i, j):\\n      if i<0 or j<0 or i>=self.M or j>=self.N or self.board[i][j] != \"O\":\\n          return\\n      self.board[i][j] = \\'T\\'\\n      neib_list = [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]\\n      for x, y in neib_list:\\n        self.dfs(x, y)\\n    \\n    def solve(self, board):\\n        if not board: return 0\\n        self.board, self.M, self.N = board, len(board), len(board[0])\\n        \\n        for i in range(0, self.M):\\n            self.dfs(i,0)\\n            self.dfs(i,self.N-1)\\n            \\n        for j in range(0, self.N):\\n            self.dfs(0,j)\\n            self.dfs(self.M-1,j)\\n        \\n        for i,j in product(range(self.M), range(self.N)):\\n            board[i][j] = \"X\" if board[i][j] != \"T\" else \"O\"\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def dfs(self, i, j):\\n      if i<0 or j<0 or i>=self.M or j>=self.N or self.board[i][j] != \"O\":\\n          return\\n      self.board[i][j] = \\'T\\'\\n      neib_list = [[i+1,j],[i-1,j],[i,j-1],[i,j+1]]\\n      for x, y in neib_list:\\n        self.dfs(x, y)\\n    \\n    def solve(self, board):\\n        if not board: return 0\\n        self.board, self.M, self.N = board, len(board), len(board[0])\\n        \\n        for i in range(0, self.M):\\n            self.dfs(i,0)\\n            self.dfs(i,self.N-1)\\n            \\n        for j in range(0, self.N):\\n            self.dfs(0,j)\\n            self.dfs(self.M-1,j)\\n        \\n        for i,j in product(range(self.M), range(self.N)):\\n            board[i][j] = \"X\" if board[i][j] != \"T\" else \"O\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552820,
                "title": "java-simple-and-readable-solution-bfs",
                "content": "**Problem statement at a glance**: So, a m x n matrix is given with \\'O\\'s and \\'X\\'s and we to make all \\'O\\'s to \\'X\\'s which are on 4 directions of a \\'X\\' and they should not be connected with an \\'O\\' which is on border.\\n**Approach:**\\n1) Traverse all borders of the grid and if you find an \\'O\\', then mark all the connected \\'O\\'s with any other temporary character(Let\\'s say \\'1\\'). ( We should not convert the \\'O\\'s which are connected with an \\'O\\' which is on border. So, first mark those positions with any other character, so that at later we can convert them to \\'O\\' again). \\n2) Now convert all 1\\'s to O\\'s and O\\'s to X\\'s.\\n\\n**Pictorial Representation:**\\n![image](https://assets.leetcode.com/users/images/92fc26e2-d40c-4baf-b333-ca607a7000f2_1635768074.128428.png)\\n\\n**Time Complexity:**  O(N * M), where N is the number of rows of the board and M is the number of columns of the board. We will be traversing the grid two times. So time complexity is  O(2 * N * M) ~ O(N * M).\\n\\n**Space Complexity:** O(N * M). Due to a queue in BFS.\\n\\n**Code:**\\n```\\nclass Solution {\\n    public void bfs(char [][]board,int i,int j)\\n    {\\n        // These two arrays are used to traverse four directions of a particular cell.\\n         int []dx={-1,0,1,0};\\n         int []dy={0,1,0,-1};\\n         Queue<ArrayList<Integer>>queue=new LinkedList<>();\\n        // Add the current cell to queue\\n         queue.add(new ArrayList<>(Arrays.asList(i,j)));\\n        // Do BFS until queue is empty\\n          while(!queue.isEmpty())\\n           {\\n                  // Retrieve first position in queue\\n                  ArrayList<Integer>temp=queue.poll();\\n                  int curx=(int)temp.get(0);\\n                  int cury=(int)temp.get(1);\\n                  // Mark it as \\'1\\'\\n                  board[curx][cury]=\\'1\\';\\n                  // Mark four cells which are connected to current cell to \\'1\\' if cell has \\'O\\' and push it to queue.\\n                  for(int i1=0;i1<4;i1++)\\n                  {\\n                      if(curx+dx[i1]<board.length && curx+dx[i1]>=0 && cury+dy[i1]<board[0].length && cury+dy[i1]>=0)\\n                      {\\n                          \\n                           if(board[curx+dx[i1]][cury+dy[i1]]==\\'O\\'){\\n                           board[curx+dx[i1]][cury+dy[i1]]=\\'1\\';\\n                           queue.add(new ArrayList<>(Arrays.asList(curx+dx[i1],cury+dy[i1])));\\n                          }\\n                      }\\n                  }\\n                  \\n           }\\n    }\\n    public void solve(char[][] board) {\\n        \\n            // Traversing on 1st row\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                // If we found an \\'O\\' on border, we need to make all its connected \\'O\\'s to \\'1\\'s.\\n                 if(board[0][j]==\\'O\\')\\n                 {\\n                   bfs(board,0,j);   \\n                 }\\n            }\\n           // Traversing on last row\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                // If we found an \\'O\\' on border, we need to make all its connected \\'O\\'s to \\'1\\'s.\\n                if(board[board.length-1][j]==\\'O\\')\\n                    bfs(board,board.length-1,j);\\n            } \\n           // Traversing on first column\\n            for(int i=0;i<board.length;i++)\\n            {\\n                // If we found an \\'O\\' on border, we need to make all its connected \\'O\\'s to \\'1\\'s.\\n                if(board[i][0]==\\'O\\')\\n                      bfs(board,i,0);\\n            }\\n           // Traversing on last column\\n            for(int i=0;i<board.length;i++)\\n            {\\n                // If we found an \\'O\\' on border, we need to make all its connected \\'O\\'s to \\'1\\'s.\\n                    if(board[i][board[0].length-1]==\\'O\\')\\n                          bfs(board,i,board[0].length-1);\\n            }\\n           // Traverse the grid again and perform step 2\\n            for(int i=0;i<board.length;i++)\\n            {\\n                for(int j=0;j<board[0].length;j++)\\n                {\\n                    if(board[i][j]==\\'O\\')\\n                        board[i][j]=\\'X\\';\\n                  else  if(board[i][j]==\\'1\\')\\n                        board[i][j]=\\'O\\';\\n                }\\n            }\\n    }\\n}\\n```\\nThanks for reading! Please upvote and comment if you got a clear idea:) \\n",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public void bfs(char [][]board,int i,int j)\\n    {\\n        // These two arrays are used to traverse four directions of a particular cell.\\n         int []dx={-1,0,1,0};\\n         int []dy={0,1,0,-1};\\n         Queue<ArrayList<Integer>>queue=new LinkedList<>();\\n        // Add the current cell to queue\\n         queue.add(new ArrayList<>(Arrays.asList(i,j)));\\n        // Do BFS until queue is empty\\n          while(!queue.isEmpty())\\n           {\\n                  // Retrieve first position in queue\\n                  ArrayList<Integer>temp=queue.poll();\\n                  int curx=(int)temp.get(0);\\n                  int cury=(int)temp.get(1);\\n                  // Mark it as \\'1\\'\\n                  board[curx][cury]=\\'1\\';\\n                  // Mark four cells which are connected to current cell to \\'1\\' if cell has \\'O\\' and push it to queue.\\n                  for(int i1=0;i1<4;i1++)\\n                  {\\n                      if(curx+dx[i1]<board.length && curx+dx[i1]>=0 && cury+dy[i1]<board[0].length && cury+dy[i1]>=0)\\n                      {\\n                          \\n                           if(board[curx+dx[i1]][cury+dy[i1]]==\\'O\\'){\\n                           board[curx+dx[i1]][cury+dy[i1]]=\\'1\\';\\n                           queue.add(new ArrayList<>(Arrays.asList(curx+dx[i1],cury+dy[i1])));\\n                          }\\n                      }\\n                  }\\n                  \\n           }\\n    }\\n    public void solve(char[][] board) {\\n        \\n            // Traversing on 1st row\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                // If we found an \\'O\\' on border, we need to make all its connected \\'O\\'s to \\'1\\'s.\\n                 if(board[0][j]==\\'O\\')\\n                 {\\n                   bfs(board,0,j);   \\n                 }\\n            }\\n           // Traversing on last row\\n            for(int j=0;j<board[0].length;j++)\\n            {\\n                // If we found an \\'O\\' on border, we need to make all its connected \\'O\\'s to \\'1\\'s.\\n                if(board[board.length-1][j]==\\'O\\')\\n                    bfs(board,board.length-1,j);\\n            } \\n           // Traversing on first column\\n            for(int i=0;i<board.length;i++)\\n            {\\n                // If we found an \\'O\\' on border, we need to make all its connected \\'O\\'s to \\'1\\'s.\\n                if(board[i][0]==\\'O\\')\\n                      bfs(board,i,0);\\n            }\\n           // Traversing on last column\\n            for(int i=0;i<board.length;i++)\\n            {\\n                // If we found an \\'O\\' on border, we need to make all its connected \\'O\\'s to \\'1\\'s.\\n                    if(board[i][board[0].length-1]==\\'O\\')\\n                          bfs(board,i,board[0].length-1);\\n            }\\n           // Traverse the grid again and perform step 2\\n            for(int i=0;i<board.length;i++)\\n            {\\n                for(int j=0;j<board[0].length;j++)\\n                {\\n                    if(board[i][j]==\\'O\\')\\n                        board[i][j]=\\'X\\';\\n                  else  if(board[i][j]==\\'1\\')\\n                        board[i][j]=\\'O\\';\\n                }\\n            }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41649,
                "title": "my-bfs-solution-c-28ms",
                "content": "The algorithm is quite simple: Use BFS starting from 'O's on the boundary and mark them as 'B', then iterate over the whole board and mark  'O' as 'X' and 'B' as 'O'. \\n\\n\\n\\n    void bfsBoundary(vector<vector<char> >& board, int w, int l)\\n    {\\n        int width = board.size();\\n        int length = board[0].size();\\n        deque<pair<int, int> > q;\\n        q.push_back(make_pair(w, l));\\n        board[w][l] = 'B';\\n        while (!q.empty()) {\\n            pair<int, int> cur = q.front();\\n            q.pop_front();\\n            pair<int, int> adjs[4] = {{cur.first-1, cur.second}, \\n                {cur.first+1, cur.second}, \\n                {cur.first, cur.second-1},\\n                {cur.first, cur.second+1}};\\n            for (int i = 0; i < 4; ++i)\\n            {\\n                int adjW = adjs[i].first;\\n                int adjL = adjs[i].second;\\n                if ((adjW >= 0) && (adjW < width) && (adjL >= 0)\\n                        && (adjL < length) \\n                        && (board[adjW][adjL] == 'O')) {\\n                    q.push_back(make_pair(adjW, adjL));\\n                    board[adjW][adjL] = 'B';\\n                }\\n            }\\n        }\\n    }\\n    \\n    void solve(vector<vector<char> > &board) {\\n        int width = board.size();\\n        if (width == 0) //Add this to prevent run-time error!\\n            return;\\n        int length = board[0].size();\\n        if  (length == 0) // Add this to prevent run-time error!\\n            return;\\n    \\n        for (int i = 0; i < length; ++i)\\n        {\\n            if (board[0][i] == 'O')\\n                bfsBoundary(board, 0, i);\\n    \\n            if (board[width-1][i] == 'O')\\n                bfsBoundary(board, width-1, i);\\n        }\\n    \\n        for (int i = 0; i < width; ++i)\\n        {\\n            if (board[i][0] == 'O')\\n                bfsBoundary(board, i, 0);\\n            if (board[i][length-1] == 'O')\\n                bfsBoundary(board, i, length-1);\\n        }\\n    \\n        for (int i = 0; i < width; ++i)\\n        {\\n            for (int j = 0; j < length; ++j)\\n            {\\n                if (board[i][j] == 'O')\\n                    board[i][j] = 'X';\\n                else if (board[i][j] == 'B')\\n                    board[i][j] = 'O';\\n            }\\n        }\\n    }\\n\\nNote that one of the test cases is when the board is empty. So if you don't check it in your code, you will encounter an run-time error.",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "The algorithm is quite simple: Use BFS starting from 'O's on the boundary and mark them as 'B', then iterate over the whole board and mark  'O' as 'X' and 'B' as 'O'. \\n\\n\\n\\n    void bfsBoundary(vector<vector<char> >& board, int w, int l)\\n    {\\n        int width = board.size();\\n        int length = board[0].size();\\n        deque<pair<int, int> > q;\\n        q.push_back(make_pair(w, l));\\n        board[w][l] = 'B';\\n        while (!q.empty()) {\\n            pair<int, int> cur = q.front();\\n            q.pop_front();\\n            pair<int, int> adjs[4] = {{cur.first-1, cur.second}, \\n                {cur.first+1, cur.second}, \\n                {cur.first, cur.second-1},\\n                {cur.first, cur.second+1}};\\n            for (int i = 0; i < 4; ++i)\\n            {\\n                int adjW = adjs[i].first;\\n                int adjL = adjs[i].second;\\n                if ((adjW >= 0) && (adjW < width) && (adjL >= 0)\\n                        && (adjL < length) \\n                        && (board[adjW][adjL] == 'O')) {\\n                    q.push_back(make_pair(adjW, adjL));\\n                    board[adjW][adjL] = 'B';\\n                }\\n            }\\n        }\\n    }\\n    \\n    void solve(vector<vector<char> > &board) {\\n        int width = board.size();\\n        if (width == 0) //Add this to prevent run-time error!\\n            return;\\n        int length = board[0].size();\\n        if  (length == 0) // Add this to prevent run-time error!\\n            return;\\n    \\n        for (int i = 0; i < length; ++i)\\n        {\\n            if (board[0][i] == 'O')\\n                bfsBoundary(board, 0, i);\\n    \\n            if (board[width-1][i] == 'O')\\n                bfsBoundary(board, width-1, i);\\n        }\\n    \\n        for (int i = 0; i < width; ++i)\\n        {\\n            if (board[i][0] == 'O')\\n                bfsBoundary(board, i, 0);\\n            if (board[i][length-1] == 'O')\\n                bfsBoundary(board, i, length-1);\\n        }\\n    \\n        for (int i = 0; i < width; ++i)\\n        {\\n            for (int j = 0; j < length; ++j)\\n            {\\n                if (board[i][j] == 'O')\\n                    board[i][j] = 'X';\\n                else if (board[i][j] == 'B')\\n                    board[i][j] = 'O';\\n            }\\n        }\\n    }\\n\\nNote that one of the test cases is when the board is empty. So if you don't check it in your code, you will encounter an run-time error.",
                "codeTag": "Unknown"
            },
            {
                "id": 1552435,
                "title": "easy-explained-solution-with-images",
                "content": "![image](https://assets.leetcode.com/users/images/b1524128-c920-4b11-a48e-0c0efe511b40_1635752873.1780322.png)\\n![image](https://assets.leetcode.com/users/images/c896e358-49bb-455c-b0a1-880899c1a9b2_1635752881.639585.png)\\n![image](https://assets.leetcode.com/users/images/ee677759-0f1b-4d9b-b57c-ac6da14aae21_1635752903.1827514.png)\\n![image](https://assets.leetcode.com/users/images/3115efea-625c-41e7-b29f-d46a811bb7da_1635752921.3163881.png)\\n![image](https://assets.leetcode.com/users/images/ed9c6e97-df93-421b-a1b1-796f23cb8b1e_1635752967.6120648.png)\\n![image](https://assets.leetcode.com/users/images/8520a773-3dd5-4cb5-ac86-0666125ba410_1635752978.9371126.png)\\n![image](https://assets.leetcode.com/users/images/25298067-2fe5-40cb-a153-75e9a18864db_1635753000.912536.png)\\n![image](https://assets.leetcode.com/users/images/fa3b637b-39a5-4c71-bb58-ac52ccd7b5c2_1635753038.593972.png)\\n![image](https://assets.leetcode.com/users/images/f8928e3c-53f3-4263-b9e0-c1931cb71775_1635753046.2254264.png)\\ncode\\n```python\\nfrom collections import deque\\n\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        \\n        o = \"O\"\\n        \\n        n = len(board) \\n        m = len(board[0])\\n\\n        Q = deque()\\n        \\n        for i in range(n):\\n            if board[i][0] == o:\\n                Q.append((i,0))\\n            if board[i][m-1] == o:\\n                Q.append((i, m-1))\\n                \\n        for j in range(m):\\n            if board[0][j] == o:\\n                Q.append((0,j))\\n            if board[n-1][j] == o:\\n                Q.append((n-1, j))\\n                \\n        def inBounds(i,j):\\n            return (0 <= i < n) and (0 <= j < m)\\n                \\n        while Q:\\n            i,j = Q.popleft()\\n            board[i][j] = \"#\"\\n            \\n            for ii, jj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n                if not inBounds(ii, jj):\\n                    continue\\n                if board[ii][jj] != o:\\n                    continue\\n                Q.append((ii,jj))\\n                board[ii][jj] = \\'#\\'\\n            \\n        for i in range(n):\\n            for j in range(m):\\n                if board[i][j] == o:\\n                    board[i][j] = \\'X\\'\\n                elif board[i][j] == \\'#\\':\\n                    board[i][j] = o\\n\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3",
                    "C"
                ],
                "code": "```python\\nfrom collections import deque\\n\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        \\n        o = \"O\"\\n        \\n        n = len(board) \\n        m = len(board[0])\\n\\n        Q = deque()\\n        \\n        for i in range(n):\\n            if board[i][0] == o:\\n                Q.append((i,0))\\n            if board[i][m-1] == o:\\n                Q.append((i, m-1))\\n                \\n        for j in range(m):\\n            if board[0][j] == o:\\n                Q.append((0,j))\\n            if board[n-1][j] == o:\\n                Q.append((n-1, j))\\n                \\n        def inBounds(i,j):\\n            return (0 <= i < n) and (0 <= j < m)\\n                \\n        while Q:\\n            i,j = Q.popleft()\\n            board[i][j] = \"#\"\\n            \\n            for ii, jj in [(i+1, j), (i-1, j), (i, j+1), (i, j-1)]:\\n                if not inBounds(ii, jj):\\n                    continue\\n                if board[ii][jj] != o:\\n                    continue\\n                Q.append((ii,jj))\\n                board[ii][jj] = \\'#\\'\\n            \\n        for i in range(n):\\n            for j in range(m):\\n                if board[i][j] == o:\\n                    board[i][j] = \\'X\\'\\n                elif board[i][j] == \\'#\\':\\n                    board[i][j] = o\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 167165,
                "title": "java-union-find-with-explanations",
                "content": "[Click to see DFS Solution](https://leetcode.com/problems/surrounded-regions/discuss/163363/Logical-Thinking-with-Code)\\n\\n**Logical Thought**\\nWe aim to find all \\'O\\'s such that it is on the border or it is connected to an \\'O\\' on the border. If we regard \\'O\\' mentioned above as a `node` (or an `element`), the problem becomes to find the `connected components` (or `disjoint sets`) connected to borders. So-called borders should also be represented as an element, so elements connected to it can be merged with it into a set. That\\'s the usage of `dummyBorder`.\\n**Pseudo-code**\\n```\\ninitialize dummyRepresentative\\n\\nfor O in board\\n\\tif O is on border\\n\\t\\tunion(dummyBorder, O)\\n\\telse\\n\\t\\tfor neighbour of O\\n\\t\\t\\tif (neighbour is \\'O\\') \\n\\t\\t\\t\\tunion(neighbour, O)\\n                \\nfor each cell\\n\\tif cell is \\'O\\' && (find(cel) != find(dummyBorder))\\n\\t\\tflip\\n```\\n**Code**\\n```\\n    private static int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};    \\n        \\n    public void solve(char[][] board) {\\n        \\n        if (board == null || board.length == 0) {\\n            return;\\n        }       \\n       \\n        DisjointSets disjointSets = new DisjointSets(board);\\n        int rows = board.length, cols = board[0].length;\\n        int dummyBorder = rows * cols;\\n        \\n        for (int x = 0; x < rows; x++) {\\n            for (int y = 0; y < cols; y++) {\\n                if (board[x][y] == \\'O\\') {\\n                    int borderO = x * cols + y;\\n                    if (x == 0 || x == rows - 1 || y == 0 || y == cols - 1) {\\n                        disjointSets.union(dummyBorder, borderO);\\n                        continue;\\n                    }\\n                    for (int[] dir : directions) {\\n                        int nx = x + dir[0];\\n                        int ny = y + dir[1];\\n                        if (nx >= 0 && ny >= 0 && nx < rows && ny < cols && board[nx][ny] == \\'O\\') {\\n                            int neighbor = nx * cols + ny;\\n                            disjointSets.union(borderO, neighbor);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (int x = 0; x < rows; x++) {\\n            for (int y = 0; y < cols; y++) {\\n                if (board[x][y] == \\'O\\' && disjointSets.find(x * cols + y) != disjointSets.find(dummyBorder)) {\\n                    board[x][y] = \\'X\\';\\n                }\\n            }\\n        }\\n        \\n    }\\n    \\n    class DisjointSets {\\n        \\n        int[] parent;\\n        \\n        public DisjointSets(char[][] board) {\\n            \\n            int rows = board.length, cols = board[0].length;\\n            parent = new int[rows * cols + 1];\\n            \\n            for (int x = 0; x < rows; x++) {\\n                for (int y = 0; y < cols; y++) {       \\n                    if (board[x][y] == \\'O\\') {\\n                        int id = x * cols + y;\\n                        parent[id] = id;\\n                    }\\n                }\\n            }\\n            parent[rows * cols] = rows * cols;\\n        }\\n        \\n        public int find(int x) {\\n            \\n            if (x == parent[x]) {\\n                return x;\\n            }\\n            return parent[x] = find(parent[x]);\\n        }\\n        \\n        public void union(int x, int y) {\\n            \\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX != rootY) {\\n                parent[rootX] = rootY;\\n            }\\n        }\\n    }\\n```\\n**Trick**\\n* We add an element `dummyBorder` to gather all elements connected to borders. \\n\\nI appreciate your **VOTE UP** (\\u02CAo\\u0334\\u0336\\u0337\\u0324\\u2304o\\u0334\\u0336\\u0337\\u0324\\u02CB) ",
                "solutionTags": [],
                "code": "```\\ninitialize dummyRepresentative\\n\\nfor O in board\\n\\tif O is on border\\n\\t\\tunion(dummyBorder, O)\\n\\telse\\n\\t\\tfor neighbour of O\\n\\t\\t\\tif (neighbour is \\'O\\') \\n\\t\\t\\t\\tunion(neighbour, O)\\n                \\nfor each cell\\n\\tif cell is \\'O\\' && (find(cel) != find(dummyBorder))\\n\\t\\tflip\\n```\n```\\n    private static int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};    \\n        \\n    public void solve(char[][] board) {\\n        \\n        if (board == null || board.length == 0) {\\n            return;\\n        }       \\n       \\n        DisjointSets disjointSets = new DisjointSets(board);\\n        int rows = board.length, cols = board[0].length;\\n        int dummyBorder = rows * cols;\\n        \\n        for (int x = 0; x < rows; x++) {\\n            for (int y = 0; y < cols; y++) {\\n                if (board[x][y] == \\'O\\') {\\n                    int borderO = x * cols + y;\\n                    if (x == 0 || x == rows - 1 || y == 0 || y == cols - 1) {\\n                        disjointSets.union(dummyBorder, borderO);\\n                        continue;\\n                    }\\n                    for (int[] dir : directions) {\\n                        int nx = x + dir[0];\\n                        int ny = y + dir[1];\\n                        if (nx >= 0 && ny >= 0 && nx < rows && ny < cols && board[nx][ny] == \\'O\\') {\\n                            int neighbor = nx * cols + ny;\\n                            disjointSets.union(borderO, neighbor);\\n                        }\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (int x = 0; x < rows; x++) {\\n            for (int y = 0; y < cols; y++) {\\n                if (board[x][y] == \\'O\\' && disjointSets.find(x * cols + y) != disjointSets.find(dummyBorder)) {\\n                    board[x][y] = \\'X\\';\\n                }\\n            }\\n        }\\n        \\n    }\\n    \\n    class DisjointSets {\\n        \\n        int[] parent;\\n        \\n        public DisjointSets(char[][] board) {\\n            \\n            int rows = board.length, cols = board[0].length;\\n            parent = new int[rows * cols + 1];\\n            \\n            for (int x = 0; x < rows; x++) {\\n                for (int y = 0; y < cols; y++) {       \\n                    if (board[x][y] == \\'O\\') {\\n                        int id = x * cols + y;\\n                        parent[id] = id;\\n                    }\\n                }\\n            }\\n            parent[rows * cols] = rows * cols;\\n        }\\n        \\n        public int find(int x) {\\n            \\n            if (x == parent[x]) {\\n                return x;\\n            }\\n            return parent[x] = find(parent[x]);\\n        }\\n        \\n        public void union(int x, int y) {\\n            \\n            int rootX = find(x);\\n            int rootY = find(y);\\n            if (rootX != rootY) {\\n                parent[rootX] = rootY;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41825,
                "title": "simple-bfs-solution-easy-to-understand",
                "content": "The idea is to first find all 'O's on the edge, and do BFS from these 'O's. Keep adding 'O's into the queue in the BFS, and mark it as '+'. Since these 'O's are found by doing BFS from the 'O's on the edge, it means they are connected to the edge 'O's. so they are the 'O's that will remain as 'O' in the result. \\n\\nAfter BFS, there are some 'O's can not be reached, they are the 'O's that need to be turned as 'X'.\\n\\n\\n\\n\\n\\n    public class Solution {\\n        public void solve(char[][] board) {\\n            if (board.length == 0) return;\\n            \\n            int rowN = board.length;\\n            int colN = board[0].length;\\n            Queue<Point> queue = new LinkedList<Point>();\\n           \\n           //get all 'O's on the edge first\\n            for (int r = 0; r< rowN; r++){\\n            \\tif (board[r][0] == 'O') {\\n            \\t\\tboard[r][0] = '+';\\n                    queue.add(new Point(r, 0));\\n            \\t}\\n            \\tif (board[r][colN-1] == 'O') {\\n            \\t\\tboard[r][colN-1] = '+';\\n                    queue.add(new Point(r, colN-1));\\n            \\t}\\n            \\t}\\n            \\n            for (int c = 0; c< colN; c++){\\n            \\tif (board[0][c] == 'O') {\\n            \\t\\tboard[0][c] = '+';\\n                    queue.add(new Point(0, c));\\n            \\t}\\n            \\tif (board[rowN-1][c] == 'O') {\\n            \\t\\tboard[rowN-1][c] = '+';\\n                    queue.add(new Point(rowN-1, c));\\n            \\t}\\n            \\t}\\n            \\n    \\n            //BFS for the 'O's, and mark it as '+'\\n            while (!queue.isEmpty()){\\n            \\tPoint p = queue.poll();\\n            \\tint row = p.x;\\n            \\tint col = p.y;\\n            \\tif (row - 1 >= 0 && board[row-1][col] == 'O') {board[row-1][col] = '+'; queue.add(new Point(row-1, col));}\\n            \\tif (row + 1 < rowN && board[row+1][col] == 'O') {board[row+1][col] = '+'; queue.add(new Point(row+1, col));}\\n            \\tif (col - 1 >= 0 && board[row][col - 1] == 'O') {board[row][col-1] = '+'; queue.add(new Point(row, col-1));}\\n                if (col + 1 < colN && board[row][col + 1] == 'O') {board[row][col+1] = '+'; queue.add(new Point(row, col+1));}        \\t      \\n            }\\n            \\n    \\n            //turn all '+' to 'O', and 'O' to 'X'\\n            for (int i = 0; i<rowN; i++){\\n            \\tfor (int j=0; j<colN; j++){\\n            \\t\\tif (board[i][j] == 'O') board[i][j] = 'X';\\n            \\t\\tif (board[i][j] == '+') board[i][j] = 'O';\\n            \\t}\\n            }\\n           \\n            \\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n        public void solve(char[][] board) {\\n            if (board.length == 0) return;\\n            \\n            int rowN = board.length;\\n            int colN = board[0].length;\\n            Queue<Point> queue = new LinkedList<Point>();\\n           \\n           //get all 'O's on the edge first\\n            for (int r = 0; r< rowN; r++){\\n            \\tif (board[r][0] == 'O') {\\n            \\t\\tboard[r][0] = '+';\\n                    queue.add(new Point(r, 0));\\n            \\t}",
                "codeTag": "Java"
            },
            {
                "id": 692017,
                "title": "c-java-clean-and-simple-dfs-explain",
                "content": "The Idea is first to Mark those grid which having value \\' O \\' are deeply adjacent to the First Row , First Column , Last Row and Last Column !!!  \\nso we are going to update those grid by changeing it\\'s value \\' O\\'  - > \\' P \\' [ I am use \\' P \\' here ,but You can chose any Value except \\' X \\' and \\' O \\' ]\\nTo make it happend we run DFS from the Borders[ each by one ] Of The board\\nThat\\'s It ! this is The main Work , and we done it !!!! [ YES ]\\n\\nnow the remaining grid those having \\' O \\' value is the grid which we looking for to change from \\' O \\' - > \\' X \\'  \\ndo that change and the Other grid which we update as value \\' P \\' need to make them \\' O \\' again\\n\\n\\n \\n![image](https://assets.leetcode.com/users/suman_cp/image_1592414043.png)< < : : : : :    This Example would Make It more clear\\n\\n\\nAt last  Submit your Code (^ - ^) \\n\\n\\n[ C++ SOLLUTION ] \\n```\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<char>>& board,int r,int c,int rsize,int csize){\\n        if(r<0||c<0||r==rsize||c==csize||board[r][c]!=\\'O\\')return;\\n        board[r][c] = \\'P\\';\\n        DFS(board,r+1,c,rsize,csize);\\n        DFS(board,r,c+1,rsize,csize);\\n        DFS(board,r-1,c,rsize,csize);\\n        DFS(board,r,c-1,rsize,csize);\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        if(board.empty())return;\\n        int row = board.size(),col = board[0].size();\\n        for(int i=0;i<col;i++)DFS(board,0,i,row,col),DFS(board,row-1,i,row,col);\\n        for(int i=0;i<row;i++)DFS(board,i,0,row,col),DFS(board,i,col-1,row,col);\\n        \\n        for(int i=0;i<row;i++)\\n            for(int j=0;j<col;j++)\\n                if(board[i][j]==\\'O\\')board[i][j]=\\'X\\';\\n                else if(board[i][j]==\\'P\\')board[i][j]=\\'O\\';\\n    }\\n};\\n```\\n\\n[ JAVA ]\\n```\\nclass Solution {\\n private void DFS(char[][] board,int r,int c,int rsize,int csize){\\n        if(r<0||c<0||r==rsize||c==csize||board[r][c]!=\\'O\\')return;\\n        board[r][c] = \\'P\\';\\n        DFS(board,r+1,c,rsize,csize);\\n        DFS(board,r,c+1,rsize,csize);\\n        DFS(board,r-1,c,rsize,csize);\\n        DFS(board,r,c-1,rsize,csize);\\n    } \\n    public void solve(char[][] board) {\\n        if(board.length==0)return;\\n        int row = board.length,col = board[0].length;\\n     \\n        for(int i=0;i<col;i++){\\n            DFS(board,0,i,row,col);//for FIRST ROW\\n            DFS(board,row-1,i,row,col);//for LAST ROW\\n        }\\n        for(int i=0;i<row;i++){\\n            DFS(board,i,0,row,col);//for FIRST COLUMN\\n            DFS(board,i,col-1,row,col);//for LAST COLUMN\\n        }\\n        for(int i=0;i<row;i++)\\n            for(int j=0;j<col;j++)\\n                if(board[i][j]==\\'O\\')board[i][j]=\\'X\\';\\n                else if(board[i][j]==\\'P\\')board[i][j]=\\'O\\';\\n    }\\n}\\n```\\n\\nIf It\\'s Help you please upvote\\nfor any suggestion comments there\\nThank You",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<char>>& board,int r,int c,int rsize,int csize){\\n        if(r<0||c<0||r==rsize||c==csize||board[r][c]!=\\'O\\')return;\\n        board[r][c] = \\'P\\';\\n        DFS(board,r+1,c,rsize,csize);\\n        DFS(board,r,c+1,rsize,csize);\\n        DFS(board,r-1,c,rsize,csize);\\n        DFS(board,r,c-1,rsize,csize);\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        if(board.empty())return;\\n        int row = board.size(),col = board[0].size();\\n        for(int i=0;i<col;i++)DFS(board,0,i,row,col),DFS(board,row-1,i,row,col);\\n        for(int i=0;i<row;i++)DFS(board,i,0,row,col),DFS(board,i,col-1,row,col);\\n        \\n        for(int i=0;i<row;i++)\\n            for(int j=0;j<col;j++)\\n                if(board[i][j]==\\'O\\')board[i][j]=\\'X\\';\\n                else if(board[i][j]==\\'P\\')board[i][j]=\\'O\\';\\n    }\\n};\\n```\n```\\nclass Solution {\\n private void DFS(char[][] board,int r,int c,int rsize,int csize){\\n        if(r<0||c<0||r==rsize||c==csize||board[r][c]!=\\'O\\')return;\\n        board[r][c] = \\'P\\';\\n        DFS(board,r+1,c,rsize,csize);\\n        DFS(board,r,c+1,rsize,csize);\\n        DFS(board,r-1,c,rsize,csize);\\n        DFS(board,r,c-1,rsize,csize);\\n    } \\n    public void solve(char[][] board) {\\n        if(board.length==0)return;\\n        int row = board.length,col = board[0].length;\\n     \\n        for(int i=0;i<col;i++){\\n            DFS(board,0,i,row,col);//for FIRST ROW\\n            DFS(board,row-1,i,row,col);//for LAST ROW\\n        }\\n        for(int i=0;i<row;i++){\\n            DFS(board,i,0,row,col);//for FIRST COLUMN\\n            DFS(board,i,col-1,row,col);//for LAST COLUMN\\n        }\\n        for(int i=0;i<row;i++)\\n            for(int j=0;j<col;j++)\\n                if(board[i][j]==\\'O\\')board[i][j]=\\'X\\';\\n                else if(board[i][j]==\\'P\\')board[i][j]=\\'O\\';\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1551810,
                "title": "fast-and-very-easy-to-understand-dfs-from-borders-o-n-time-o-n-space",
                "content": "This problem could be solved two ways:\\n1. Identify all isolated `\\'O\\'` cells and mark them as `\\'X\\'` then.\\n2. Mark all accessible from boarders `\\'O\\'` and then turn all inaccessible ones into `\\'X\\'`.\\n\\nThis solution is about the **second way**.\\n\\nTo mark cells as \"reachable\", algorithm changing their values to `\\'R\\'` instead of `\\'O\\'`.\\n\\n1. Follow through left and right borders of the board and look for `\\'O\\'` cells. If found recursevly mark all accessible `\\'O\\'` cells as `\\'R\\'`.\\n2. Follow through top and bottom borders of the board and do the same.\\n3. Follow through the whole board and flip `\\'O\\'` -> `\\'X\\'` and `\\'R\\'` -> `\\'O\\'`\\n\\n**Time compexity:** `O(N * M), where N is the height of the board and M is the width of the board. Since in the wrost case algorithm processes all cells twice and O(2 * N * M) == O(N * M)`\\n**Space complexity:** `O(N * M)` \\u2014 only the fixed set of variables of the fixed size is allocated and all \\'marks\\' are done \\'in-place\\' **BUT** recursive function calls are stored on the stack and use N * M memory in the worst case. There are no \"real\" allocations since the stack is allocated when the program starts, but space complexity is about all **used space**. (Thanks for the [@kim_123 comment](https://leetcode.com/problems/surrounded-regions/discuss/1551810/Fast-and-very-easy-to-understand-or-DFS-from-boarders-or-O(N)-time-or-O(1)-Space/1134588) with the clarifications).\\n\\n<iframe src=\"https://leetcode.com/playground/mRtTsxAF/shared\" frameBorder=\"0\" width=\"100%\" height=\"850\"></iframe>\\n\\nThank you for reading this! =)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "C",
                    "Go"
                ],
                "code": "This problem could be solved two ways:\\n1. Identify all isolated `\\'O\\'` cells and mark them as `\\'X\\'` then.\\n2. Mark all accessible from boarders `\\'O\\'` and then turn all inaccessible ones into `\\'X\\'`.\\n\\nThis solution is about the **second way**.\\n\\nTo mark cells as \"reachable\", algorithm changing their values to `\\'R\\'` instead of `\\'O\\'`.\\n\\n1. Follow through left and right borders of the board and look for `\\'O\\'` cells. If found recursevly mark all accessible `\\'O\\'` cells as `\\'R\\'`.\\n2. Follow through top and bottom borders of the board and do the same.\\n3. Follow through the whole board and flip `\\'O\\'` -> `\\'X\\'` and `\\'R\\'` -> `\\'O\\'`\\n\\n**Time compexity:** `O(N * M), where N is the height of the board and M is the width of the board. Since in the wrost case algorithm processes all cells twice and O(2 * N * M) == O(N * M)`\\n**Space complexity:** `O(N * M)` \\u2014 only the fixed set of variables of the fixed size is allocated and all \\'marks\\' are done \\'in-place\\' **BUT** recursive function calls are stored on the stack and use N * M memory in the worst case. There are no \"real\" allocations since the stack is allocated when the program starts, but space complexity is about all **used space**. (Thanks for the [@kim_123 comment](https://leetcode.com/problems/surrounded-regions/discuss/1551810/Fast-and-very-easy-to-understand-or-DFS-from-boarders-or-O(N)-time-or-O(1)-Space/1134588) with the clarifications).\\n\\n<iframe src=\"https://leetcode.com/playground/mRtTsxAF/shared\" frameBorder=\"0\" width=\"100%\" height=\"850\"></iframe>\\n\\nThank you for reading this! =)",
                "codeTag": "Unknown"
            },
            {
                "id": 41708,
                "title": "java-easy-version-to-understand",
                "content": "----------\\n## Use BFS.This problem is similar to Number of Islands. In this problem, only the cells on the boarders can not be surrounded. So we can first merge those O's on the boarders like in Number of Islands and replace O's with 'B', and then scan the board and replace all O's left (if any). ##\\n\\n    class Point {\\n\\tint x;\\n\\tint y;\\n\\tPoint(int x, int y) {\\n\\t\\tthis.x = x;\\n\\t\\tthis.y = y;\\n\\t}\\n}\\n\\n    public static void solve(char[][] board) {\\n\\t\\tif (board == null || board.length == 0)\\n\\t\\t\\treturn;\\n\\t\\tint rows = board.length, columns = board[0].length;\\n\\t\\tint[][] direction = { { -1, 0 }, { 1, 0 }, { 0, 1 }, { 0, -1 } };\\n\\t\\tfor (int i = 0; i < rows; i++)\\n\\t\\t\\tfor (int j = 0; j < columns; j++) {\\n\\t\\t\\t\\tif ((i == 0 || i == rows - 1 || j == 0 || j == columns - 1) && board[i][j] == 'O') {\\n\\t\\t\\t\\t\\tQueue<Point> queue = new LinkedList<>();\\n\\t\\t\\t\\t\\tboard[i][j] = 'B';\\n\\t\\t\\t\\t\\tqueue.offer(new Point(i, j));\\n\\t\\t\\t\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\t\\t\\t\\tPoint point = queue.poll();\\n\\t\\t\\t\\t\\t\\tfor (int k = 0; k < 4; k++) {\\n\\t\\t\\t\\t\\t\\t\\tint x = direction[k][0] + point.x;\\n\\t\\t\\t\\t\\t\\t\\tint y = direction[k][1] + point.y;\\n\\t\\t\\t\\t\\t\\t\\tif (x >= 0 && x < rows && y >= 0 && y < columns && board[x][y] == 'O') {\\n\\t\\t\\t\\t\\t\\t\\t\\tboard[x][y] = 'B';\\n\\t\\t\\t\\t\\t\\t\\t\\tqueue.offer(new Point(x, y));\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\tfor (int i = 0; i < rows; i++)\\n\\t\\t\\tfor (int j = 0; j < columns; j++) {\\n\\t\\t\\t\\tif (board[i][j] == 'B')\\n\\t\\t\\t\\t\\tboard[i][j] = 'O';\\n\\t\\t\\t\\telse if (board[i][j] == 'O')\\n\\t\\t\\t\\t\\tboard[i][j] = 'X';\\n\\t\\t\\t}\\n\\n\\t}",
                "solutionTags": [],
                "code": "----------\\n## Use BFS.This problem is similar to Number of Islands. In this problem, only the cells on the boarders can not be surrounded. So we can first merge those O's on the boarders like in Number of Islands and replace O's with 'B', and then scan the board and replace all O's left (if any). ##\\n\\n    class Point {\\n\\tint x;\\n\\tint y;\\n\\tPoint(int x, int y) {\\n\\t\\tthis.x = x;\\n\\t\\tthis.y = y;\\n\\t}\\n}\\n\\n    public static void solve(char[][] board) {\\n\\t\\tif (board == null || board.length == 0)\\n\\t\\t\\treturn;\\n\\t\\tint rows = board.length, columns = board[0].length;\\n\\t\\tint[][] direction = { { -1, 0 }, { 1, 0 }, { 0, 1 }, { 0, -1 } };\\n\\t\\tfor (int i = 0; i < rows; i++)\\n\\t\\t\\tfor (int j = 0; j < columns; j++) {\\n\\t\\t\\t\\tif ((i == 0 || i == rows - 1 || j == 0 || j == columns - 1) && board[i][j] == 'O') {\\n\\t\\t\\t\\t\\tQueue<Point> queue = new LinkedList<>();\\n\\t\\t\\t\\t\\tboard[i][j] = 'B';\\n\\t\\t\\t\\t\\tqueue.offer(new Point(i, j));\\n\\t\\t\\t\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\t\\t\\t\\tPoint point = queue.poll();\\n\\t\\t\\t\\t\\t\\tfor (int k = 0; k < 4; k++) {\\n\\t\\t\\t\\t\\t\\t\\tint x = direction[k][0] + point.x;\\n\\t\\t\\t\\t\\t\\t\\tint y = direction[k][1] + point.y;\\n\\t\\t\\t\\t\\t\\t\\tif (x >= 0 && x < rows && y >= 0 && y < columns && board[x][y] == 'O') {\\n\\t\\t\\t\\t\\t\\t\\t\\tboard[x][y] = 'B';\\n\\t\\t\\t\\t\\t\\t\\t\\tqueue.offer(new Point(x, y));\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\tfor (int i = 0; i < rows; i++)\\n\\t\\t\\tfor (int j = 0; j < columns; j++) {\\n\\t\\t\\t\\tif (board[i][j] == 'B')\\n\\t\\t\\t\\t\\tboard[i][j] = 'O';\\n\\t\\t\\t\\telse if (board[i][j] == 'O')\\n\\t\\t\\t\\t\\tboard[i][j] = 'X';\\n\\t\\t\\t}\\n\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 691908,
                "title": "c-dfs-easy-and-clean-solution-t-90-m-80",
                "content": "***Please like the post if you found it helpful. And please don\\'t downvote. It really demotivates and cancels the purpose of sharing knowledge in the community***\\n\\nThe idea is to iterate through the edges of the array and check if there is any zero. And if there is, we will check for zeroes in the neighbour. And keep doing this. These zeroes won\\'t get there values changed. For simplicity, I changed their values to \\'1\\'. And now, all the elements having values other than \\'1\\' will get their values changed to \\'X\\'.\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        if(board.size()==0||board[0].size()==0)return;\\n        for(int i=0;i<board[0].size();i++){\\n            if(board[0][i]==\\'O\\'){dfs(board,0,i);}\\n            if(board[board.size()-1][i]==\\'O\\'){dfs(board,board.size()-1,i);}\\n        }\\n        for(int i=1;i<board.size()-1;i++){\\n            if(board[i][0]==\\'O\\')dfs(board,i,0);\\n            if(board[i][board[0].size()-1]==\\'O\\'){dfs(board,i,board[0].size()-1);}\\n        }\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n                if(board[i][j]!=\\'1\\')board[i][j]=\\'X\\';\\n                if(board[i][j]==\\'1\\')board[i][j]=\\'O\\';\\n            }\\n        }\\n    }\\n    void dfs(vector<vector<char>>& board, int i, int j){\\n        if(i<0||i>=board.size()||j<0||j>=board[0].size())return;\\n        if(board[i][j]!=\\'O\\')return;\\n        board[i][j]=\\'1\\';\\n        dfs(board,i+1,j);\\n        dfs(board,i,j+1);\\n        dfs(board,i-1,j);\\n        dfs(board,i,j-1);\\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        if(board.size()==0||board[0].size()==0)return;\\n        for(int i=0;i<board[0].size();i++){\\n            if(board[0][i]==\\'O\\'){dfs(board,0,i);}\\n            if(board[board.size()-1][i]==\\'O\\'){dfs(board,board.size()-1,i);}\\n        }\\n        for(int i=1;i<board.size()-1;i++){\\n            if(board[i][0]==\\'O\\')dfs(board,i,0);\\n            if(board[i][board[0].size()-1]==\\'O\\'){dfs(board,i,board[0].size()-1);}\\n        }\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[0].size();j++){\\n                if(board[i][j]!=\\'1\\')board[i][j]=\\'X\\';\\n                if(board[i][j]==\\'1\\')board[i][j]=\\'O\\';\\n            }\\n        }\\n    }\\n    void dfs(vector<vector<char>>& board, int i, int j){\\n        if(i<0||i>=board.size()||j<0||j>=board[0].size())return;\\n        if(board[i][j]!=\\'O\\')return;\\n        board[i][j]=\\'1\\';\\n        dfs(board,i+1,j);\\n        dfs(board,i,j+1);\\n        dfs(board,i-1,j);\\n        dfs(board,i,j-1);\\n        return;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552219,
                "title": "java-very-easy-solution-hard-to-forgot-this",
                "content": "Hey Programmers, i try to solve this question using DFS approach.\\n![image](https://assets.leetcode.com/users/images/0446a2e2-66a6-473b-a970-8cf29480db21_1635745894.3744.png)\\n* What I did is, firstly we traverse it\\'s top n bottom column\\n* Then it\\'s left n right row\\n* And finally traverse its all then node\\nHere\\'s how what i mean is :\\n![image](https://assets.leetcode.com/users/images/6e26bc85-0977-400e-a161-57b90e1b0747_1635746026.5758421.png)\\n\\n```\\nclass Solution {\\n    public void solve(char[][] board) {\\n        // Base condition\\n        if(board.length == 0) return;\\n        // 1st Loop : Traversing over top column & bottom column, to find any \\'O\\' present by the boundary\\n        for(int i = 0; i < board[0].length; i++){\\n            if(board[0][i] == \\'O\\'){\\n                DFS(board, 0, i);\\n            }\\n            if(board[board.length - 1][i] == \\'O\\'){\\n                DFS(board, board.length - 1, i);\\n            }\\n        }\\n        // 2nd Loop : Traversing over left row & right row, to find any \\'O\\' present by the boundary\\n        for(int i = 0; i < board.length; i++){\\n            if(board[i][0] == \\'O\\'){\\n                DFS(board, i, 0);\\n            }\\n            if(board[i][board[0].length - 1] == \\'O\\'){\\n                DFS(board, i, board[0].length - 1);\\n            }\\n        }\\n        // 3rd Loop : Now in this we will traverse on each n every node & check if they are \\'O\\' convert into \\'X\\', if they are \\'@\\' convert into \\'O\\'\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(board[i][j] == \\'O\\'){\\n                    board[i][j] = \\'X\\';\\n                }\\n                else if(board[i][j] == \\'@\\'){\\n                    board[i][j] = \\'O\\';\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    // This calls helps in convert the \\'O\\' node present near by the boundary convert them into \\'@\\'\\n    public void DFS(char[][] board, int i, int j){\\n        if(i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != \\'O\\'){\\n            return;\\n        }\\n        board[i][j] = \\'@\\';\\n        DFS(board, i + 1, j);\\n        DFS(board, i - 1, j);\\n        DFS(board, i, j + 1);\\n        DFS(board, i, j - 1);\\n    }\\n}\\n```\\n* Time Complexity :- BigO(N * M), where N is height and M is width of the board\\n* Space Complexity :- BigO(1), as we are not using any kind of extra space\\n\\nI hope this will help\\'s you to understand. Thanks (:",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void solve(char[][] board) {\\n        // Base condition\\n        if(board.length == 0) return;\\n        // 1st Loop : Traversing over top column & bottom column, to find any \\'O\\' present by the boundary\\n        for(int i = 0; i < board[0].length; i++){\\n            if(board[0][i] == \\'O\\'){\\n                DFS(board, 0, i);\\n            }\\n            if(board[board.length - 1][i] == \\'O\\'){\\n                DFS(board, board.length - 1, i);\\n            }\\n        }\\n        // 2nd Loop : Traversing over left row & right row, to find any \\'O\\' present by the boundary\\n        for(int i = 0; i < board.length; i++){\\n            if(board[i][0] == \\'O\\'){\\n                DFS(board, i, 0);\\n            }\\n            if(board[i][board[0].length - 1] == \\'O\\'){\\n                DFS(board, i, board[0].length - 1);\\n            }\\n        }\\n        // 3rd Loop : Now in this we will traverse on each n every node & check if they are \\'O\\' convert into \\'X\\', if they are \\'@\\' convert into \\'O\\'\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(board[i][j] == \\'O\\'){\\n                    board[i][j] = \\'X\\';\\n                }\\n                else if(board[i][j] == \\'@\\'){\\n                    board[i][j] = \\'O\\';\\n                }\\n            }\\n        }\\n        return;\\n    }\\n    // This calls helps in convert the \\'O\\' node present near by the boundary convert them into \\'@\\'\\n    public void DFS(char[][] board, int i, int j){\\n        if(i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] != \\'O\\'){\\n            return;\\n        }\\n        board[i][j] = \\'@\\';\\n        DFS(board, i + 1, j);\\n        DFS(board, i - 1, j);\\n        DFS(board, i, j + 1);\\n        DFS(board, i, j - 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41673,
                "title": "my-java-o-n-2-accepted-solution",
                "content": "The idea is pretty simple: a 'O' marked cell cannot be captured whether:\\n\\n1. It is in contact with the border of the board or\\n2. It is adjacent to an unflippable cell.\\n\\nSo the algorithm is straightforward:\\n\\n 1. Go around the border of the board\\n 2. When a 'O' cell is found mark it with 'U' and perform a DFS on its adjacent cells looking for other 'O' marked cells.\\n 3. When the entire border is processed scan again the board\\n- If a cell is marked as 'O' it wasn't connected to unflippable cell. Hence capture it with 'X'\\n- If a cell is marked as 'X' nothing must be done.\\n- If a cell is marked as 'U' mark it as 'O' because it was an original 'O' marked cell which satisfied one of the above conditions.\\n\\nOn a technical side regarding the code:\\n\\n- In the problem statement it's not specified that the board is rectangular. So different checks must performed when scanning the border.\\n- Since a pure recursive search causes stack overflow it's necessary to make the DFS iterative using a stack to simulate recursion.\\n\\n\\npublic class Solution {\\n\\n    static class Pair {\\n        public int first;\\n        public int second;\\n        public Pair(int f, int s) {\\n            first = f;\\n            second = s;\\n        }\\n    }\\n\\n    public void solve(char[][] board) {\\n        if(board == null || board.length == 0) {\\n            return ;\\n        }\\n        for(int i = 0; i < board[0].length; ++i) {\\n            if(board[0][i] == 'O') {\\n                markUnflippable(board,0,i);\\n            }\\n        }\\n        for(int i = 0; i < board[board.length-1].length; ++i) {\\n            if(board[board.length-1][i] == 'O') {\\n                markUnflippable(board,board.length-1,i);\\n            }\\n        }\\n        for(int i = 0 ; i < board.length; ++i) {\\n            if(board[i][0] == 'O') {\\n                markUnflippable(board,i,0);\\n            }\\n        }\\n        for(int i =0; i < board.length; ++i) {\\n            if(board[i][board[i].length-1] == 'O') {\\n                markUnflippable(board,i,board[i].length-1);\\n            }\\n        }\\n        \\n        // modify the board\\n        for(int i = 0; i < board.length; ++i) {\\n            for(int j = 0; j < board[i].length; ++j) {\\n                if(board[i][j] == 'O') {\\n                    board[i][j] = 'X';\\n                } else if(board[i][j] == 'U') {\\n                    board[i][j] = 'O';\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void markUnflippable(char[][] board, int r, int c) {\\n        int[] dirX = {-1,0,1,0};\\n        int[] dirY = {0,1,0,-1};\\n        ArrayDeque<Pair> stack = new ArrayDeque<>();\\n        stack.push(new Pair(r,c));\\n        while(!stack.isEmpty()) {\\n            Pair p = stack.pop();\\n            board[p.first][p.second] = 'U';\\n            for(int i = 0; i < dirX.length; ++i) {\\n                if(p.first + dirX[i] >= 0 && p.first + dirX[i] < board.length && p.second + dirY[i] >= 0 && p.second +dirY[i] < board[p.first + dirX[i]].length && board[p.first+dirX[i]][p.second+dirY[i]] == 'O') {\\n                    stack.push(new Pair(p.first+dirX[i],p.second+dirY[i]));\\n                }\\n            }\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\n    static class Pair {\\n        public int first;\\n        public int second;\\n        public Pair(int f, int s) {\\n            first = f;\\n            second = s;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1551841,
                "title": "python-very-simple-idea-dfs",
                "content": "The idea is simple:\\n- Start from the boundary, and use DFS (or BFS) to flip the \\'O\\'s that are connected to the edge to a third symbol (e.g., \"Z\")\\n- Scan the matrix again to flip the remaining \\'O\\' to \\'X\\', and the third symbol back to \\'O\\'\\n\\n```python\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        rows = len(board)\\n        cols = len(board[0])\\n        \\n        def dfs(row, col):\\n            board[row][col] = \"Z\"\\n            for dr, dc in (-1, 0), (0, 1), (1, 0), (0, -1):\\n                nr, nc = row + dr, col + dc\\n                if nr < 0 or nr >= rows or nc < 0 or nc >= cols or board[nr][nc] != \\'O\\':\\n                    continue\\n                dfs(nr, nc)\\n\\n        def flip():\\n            for row in range(rows):\\n                for col in range(cols):\\n                    if board[row][col] == \"Z\":\\n                        board[row][col] = \"O\"\\n                    elif board[row][col] == \"O\":\\n                        board[row][col] = \"X\"\\n\\n        for row in [0, rows - 1]:\\n            for col in range(cols):\\n                if board[row][col] == \\'O\\':\\n                    dfs(row, col)\\n\\n        for col in [0, cols - 1]:\\n            for row in range(1, rows - 1):\\n                if board[row][col] == \\'O\\':\\n                    dfs(row, col)\\n\\n        flip()\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        rows = len(board)\\n        cols = len(board[0])\\n        \\n        def dfs(row, col):\\n            board[row][col] = \"Z\"\\n            for dr, dc in (-1, 0), (0, 1), (1, 0), (0, -1):\\n                nr, nc = row + dr, col + dc\\n                if nr < 0 or nr >= rows or nc < 0 or nc >= cols or board[nr][nc] != \\'O\\':\\n                    continue\\n                dfs(nr, nc)\\n\\n        def flip():\\n            for row in range(rows):\\n                for col in range(cols):\\n                    if board[row][col] == \"Z\":\\n                        board[row][col] = \"O\"\\n                    elif board[row][col] == \"O\":\\n                        board[row][col] = \"X\"\\n\\n        for row in [0, rows - 1]:\\n            for col in range(cols):\\n                if board[row][col] == \\'O\\':\\n                    dfs(row, col)\\n\\n        for col in [0, cols - 1]:\\n            for row in range(1, rows - 1):\\n                if board[row][col] == \\'O\\':\\n                    dfs(row, col)\\n\\n        flip()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41743,
                "title": "java-dfs-solution",
                "content": "    public void solve(char[][] board) {\\n        if(board == null || board.length == 0) return;\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(i == 0 || i == board.length-1 || j == 0 || j == board[0].length-1){\\n                    if(board[i][j] == 'O') dfs(i,j,board);\\n                }\\n            }\\n        }\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(board[i][j] == '*') board[i][j] ='O';\\n                else board[i][j] = 'X';\\n            }\\n        }\\n        return;\\n    }\\n    private void dfs(int i,int j,char[][] board){\\n        if(i < 0 || i >= board.length || j < 0 || j >= board[0].length) return;\\n        if(board[i][j] == 'X' || board[i][j] == '*') return;\\n        board[i][j] = '*';\\n        if(i+1 < board.length)\\n            dfs(i+1,j,board);\\n        if(i-1 > 0)\\n            dfs(i-1,j,board);\\n        if(j+1 < board[0].length)\\n            dfs(i,j+1,board);\\n        if(j-1 > 0)\\n            dfs(i,j-1,board);\\n    }",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "    public void solve(char[][] board) {\\n        if(board == null || board.length == 0) return;\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(i == 0 || i == board.length-1 || j == 0 || j == board[0].length-1){\\n                    if(board[i][j] == 'O') dfs(i,j,board);\\n                }\\n            }\\n        }\\n        for(int i = 0; i < board.length; i++){\\n            for(int j = 0; j < board[0].length; j++){\\n                if(board[i][j] == '*') board[i][j] ='O';\\n                else board[i][j] = 'X';\\n            }\\n        }\\n        return;\\n    }\\n    private void dfs(int i,int j,char[][] board){\\n        if(i < 0 || i >= board.length || j < 0 || j >= board[0].length) return;\\n        if(board[i][j] == 'X' || board[i][j] == '*') return;\\n        board[i][j] = '*';\\n        if(i+1 < board.length)\\n            dfs(i+1,j,board);\\n        if(i-1 > 0)\\n            dfs(i-1,j,board);\\n        if(j+1 < board[0].length)\\n            dfs(i,j+1,board);\\n        if(j-1 > 0)\\n            dfs(i,j-1,board);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1552540,
                "title": "c-simple-and-easy-to-understand-clean-dfs-solution-explained",
                "content": "**Idea:**\\nFirst, we want to save the `O`s that are not 4-directionally surrounded by `X`s. So we go through all edges, DFS each `O` and change all its connected `O`s to `!`.\\nAll the remaining `O`s are 4-directionally surrounded by `X`s, so we change all of them to `X`.\\nNow, we change back all `!`s to `O`s.\\n\\n```\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<char>>& board, int x, int y, char c) {\\n        if (x < 0 || x >= board.size() || y < 0 || y >= board[0].size() || board[x][y] != \\'O\\') return;\\n            \\n        board[x][y] = c;\\n        \\n        DFS(board, x + 1, y, c);\\n        DFS(board, x - 1, y, c);\\n        DFS(board, x, y + 1, c);\\n        DFS(board, x, y - 1, c);\\n    }\\n    \\n    void solve(vector<vector<char>>& board) {\\n        int n = board.size(), m = board[0].size();\\n        \\n        // Change the \\'O\\'s connected to border to \\'!\\'\\n        for (int i = 0; i < n; i++) {\\n            if (board[i][0] == \\'O\\') DFS(board, i, 0, \\'!\\');\\n            if (board[i][m-1] == \\'O\\') DFS(board, i, m-1, \\'!\\');\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            if (board[0][i] == \\'O\\') DFS(board, 0, i, \\'!\\');\\n            if (board[n-1][i] == \\'O\\') DFS(board, n-1, i, \\'!\\');\\n        }\\n        \\n        // Change all remaining \\'O\\'s to \\'x\\' and \\'!\\' back to \\'O\\'\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (i && j && i < n - 1 && j < m - 1 && board[i][j] == \\'O\\') board[i][j] = \\'X\\';\\n                if (board[i][j] == \\'!\\') board[i][j] = \\'O\\';\\n            }\\n        }\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<char>>& board, int x, int y, char c) {\\n        if (x < 0 || x >= board.size() || y < 0 || y >= board[0].size() || board[x][y] != \\'O\\') return;\\n            \\n        board[x][y] = c;\\n        \\n        DFS(board, x + 1, y, c);\\n        DFS(board, x - 1, y, c);\\n        DFS(board, x, y + 1, c);\\n        DFS(board, x, y - 1, c);\\n    }\\n    \\n    void solve(vector<vector<char>>& board) {\\n        int n = board.size(), m = board[0].size();\\n        \\n        // Change the \\'O\\'s connected to border to \\'!\\'\\n        for (int i = 0; i < n; i++) {\\n            if (board[i][0] == \\'O\\') DFS(board, i, 0, \\'!\\');\\n            if (board[i][m-1] == \\'O\\') DFS(board, i, m-1, \\'!\\');\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            if (board[0][i] == \\'O\\') DFS(board, 0, i, \\'!\\');\\n            if (board[n-1][i] == \\'O\\') DFS(board, n-1, i, \\'!\\');\\n        }\\n        \\n        // Change all remaining \\'O\\'s to \\'x\\' and \\'!\\' back to \\'O\\'\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (i && j && i < n - 1 && j < m - 1 && board[i][j] == \\'O\\') board[i][j] = \\'X\\';\\n                if (board[i][j] == \\'!\\') board[i][j] = \\'O\\';\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 475014,
                "title": "python3-bfs-and-dfs",
                "content": "below is my python3 BFS and DFS solutions\\n\\n\\nBFS:\\n```python\\nclass Solution:\\n    \\'\\'\\'\\n    Time complexity : O(MXN)\\n    Space complexity : O(MXN) in worse case\\n\\n    First, check the four border of the matrix. If there is a element is\\n    \\'O\\', alter it and all its neighbor \\'O\\' elements to \\'N\\'.\\n\\n    Then ,alter all the \\'O\\' to \\'X\\'\\n\\n    At last,alter all the \\'N\\' to \\'O\\'\\n\\n    example: \\n\\n    X X X X           X X X X             X X X X\\n    X X O X  ->       X X O X    ->       X X X X\\n    X O X X           X N X X             X O X X\\n    X O X X           X N X X             X O X X\\n\\n    \\'\\'\\'\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        if not board or not board[0]:\\n            return\\n        R, C = len(board), len(board[0])\\n        if R <= 2 or C <= 2:\\n            return\\n        \\n        # queue for bfs\\n        q = deque()\\n        \\n        # start from the boarder and replace all O to N\\n        # put all the boarder value into queue.\\n        for r in range(R):\\n            q.append((r, 0))\\n            q.append((r, C-1))\\n\\n        for c in range(C):\\n            q.append((0, c))\\n            q.append((R-1, c))\\n        \\n        while q:\\n            r, c = q.popleft()\\n            if 0<=r<R and 0<=c<C and board[r][c] == \"O\":\\n                # modify the value from O to N\\n                board[r][c] = \"N\"\\n                # append the surrouding cells to queue.\\n                q.append((r, c+1))\\n                q.append((r, c-1))\\n                q.append((r-1, c))\\n                q.append((r+1, c))\\n        \\n        # replace all the O to X, then replace all the N to O\\n        for r in range(R):\\n            for c in range(C):\\n                if board[r][c] == \"O\":\\n                    board[r][c] = \"X\"\\n                if board[r][c] == \"N\":\\n                    board[r][c] = \"O\"\\n```\\n\\nDFS:\\n\\n```python\\nclass Solution1:\\n\\n    \\'\\'\\'\\n    recursion, dfs\\n    \\'\\'\\'\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        if not board or not board[0]:\\n            return\\n        R, C = len(board), len(board[0])\\n        if R <= 2 or C <= 2:\\n            return\\n        \\n        # start from the boarder and replace all O to N\\n        # put all the boarder value into queue.\\n        for r in range(R):\\n            self.dfs(board, r, 0, R, C)\\n            self.dfs(board, r, C-1, R, C)\\n\\n        for c in range(C):\\n            self.dfs(board, 0, c, R, C)\\n            self.dfs(board, R-1, c, R, C)\\n\\n        # replace all the O to X, then replace all the N to O\\n        for r in range(R):\\n            for c in range(C):\\n                if board[r][c] == \"O\":\\n                    board[r][c] = \"X\"\\n                if board[r][c] == \"N\":\\n                    board[r][c] = \"O\"\\n        \\n                    \\n    def dfs(self, board, r, c, R, C):\\n        if 0<=r<R and 0<=c<C and board[r][c] == \"O\":\\n            board[r][c] = \"N\"\\n            self.dfs(board, r, c+1, R, C)\\n            self.dfs(board, r, c-1, R, C)            \\n            self.dfs(board, r-1, c, R, C)            \\n            self.dfs(board, r+1, c, R, C)   \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```python\\nclass Solution:\\n    \\'\\'\\'\\n    Time complexity : O(MXN)\\n    Space complexity : O(MXN) in worse case\\n\\n    First, check the four border of the matrix. If there is a element is\\n    \\'O\\', alter it and all its neighbor \\'O\\' elements to \\'N\\'.\\n\\n    Then ,alter all the \\'O\\' to \\'X\\'\\n\\n    At last,alter all the \\'N\\' to \\'O\\'\\n\\n    example: \\n\\n    X X X X           X X X X             X X X X\\n    X X O X  ->       X X O X    ->       X X X X\\n    X O X X           X N X X             X O X X\\n    X O X X           X N X X             X O X X\\n\\n    \\'\\'\\'\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        if not board or not board[0]:\\n            return\\n        R, C = len(board), len(board[0])\\n        if R <= 2 or C <= 2:\\n            return\\n        \\n        # queue for bfs\\n        q = deque()\\n        \\n        # start from the boarder and replace all O to N\\n        # put all the boarder value into queue.\\n        for r in range(R):\\n            q.append((r, 0))\\n            q.append((r, C-1))\\n\\n        for c in range(C):\\n            q.append((0, c))\\n            q.append((R-1, c))\\n        \\n        while q:\\n            r, c = q.popleft()\\n            if 0<=r<R and 0<=c<C and board[r][c] == \"O\":\\n                # modify the value from O to N\\n                board[r][c] = \"N\"\\n                # append the surrouding cells to queue.\\n                q.append((r, c+1))\\n                q.append((r, c-1))\\n                q.append((r-1, c))\\n                q.append((r+1, c))\\n        \\n        # replace all the O to X, then replace all the N to O\\n        for r in range(R):\\n            for c in range(C):\\n                if board[r][c] == \"O\":\\n                    board[r][c] = \"X\"\\n                if board[r][c] == \"N\":\\n                    board[r][c] = \"O\"\\n```\n```python\\nclass Solution1:\\n\\n    \\'\\'\\'\\n    recursion, dfs\\n    \\'\\'\\'\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        if not board or not board[0]:\\n            return\\n        R, C = len(board), len(board[0])\\n        if R <= 2 or C <= 2:\\n            return\\n        \\n        # start from the boarder and replace all O to N\\n        # put all the boarder value into queue.\\n        for r in range(R):\\n            self.dfs(board, r, 0, R, C)\\n            self.dfs(board, r, C-1, R, C)\\n\\n        for c in range(C):\\n            self.dfs(board, 0, c, R, C)\\n            self.dfs(board, R-1, c, R, C)\\n\\n        # replace all the O to X, then replace all the N to O\\n        for r in range(R):\\n            for c in range(C):\\n                if board[r][c] == \"O\":\\n                    board[r][c] = \"X\"\\n                if board[r][c] == \"N\":\\n                    board[r][c] = \"O\"\\n        \\n                    \\n    def dfs(self, board, r, c, R, C):\\n        if 0<=r<R and 0<=c<C and board[r][c] == \"O\":\\n            board[r][c] = \"N\"\\n            self.dfs(board, r, c+1, R, C)\\n            self.dfs(board, r, c-1, R, C)            \\n            self.dfs(board, r-1, c, R, C)            \\n            self.dfs(board, r+1, c, R, C)   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 789539,
                "title": "simplest-c-solution-possible-with-comments-beats-99-5-solution",
                "content": "## **My BFS Solution**\\n```\\nclass Solution {\\npublic:\\n\\t// To check whether the indices are present in the matrix. [Like (-1,0) is not present]\\n    bool isSafe(int i, int j, int m, int n){\\n        return (i>=0 && i<m && j>=0 && j<n);\\n    }\\n\\t// Checks whether the indices are present at the border of the matrix.\\n    bool isBorder(int i, int j, int m, int n){\\n        return (i==0 || i==m-1 || j==0 || j==n-1);\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        if(board.size()==0)\\n            return ;\\n\\t\\t// m is the number of rows.\\n        int m = board.size();\\n\\t\\t// n is the number of columns\\n        int n = board[0].size();\\n\\t\\t// Taking queue for BFS.\\n        queue<pair<int,int>> q;\\n\\t\\t// dir contains the directions in which the checking is to be done.\\n        vector<pair<int, int>> dir = {{1,0}, {-1,0}, {0, 1}, {0, -1}};\\n\\t\\t// Finding the border elements as \\'O\\' and converting it into something else.\\n\\t\\t// This is done due to the reason because, they are not to be flipped in the final matrix.\\n\\t\\t// We could check only the border rows and columns but I have instead traversed the whole matrix. You can surely save up some time here.\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(board[i][j]==\\'O\\' && isBorder(i,j,m,n)){\\n\\t\\t\\t\\t\\t// Converting the \\'O\\' into \\'.\\' so, that they can be later changed to \\'O\\'.\\n                    board[i][j] = \\'.\\';\\n                    q.push(make_pair(i,j));                    \\n                }\\n            }\\n        }\\n\\t\\t// Starting the BFS.\\n        while(!q.empty()){\\n            pair<int, int> temp = q.front();\\n            q.pop();\\n\\t\\t\\t// Checking all the directions.\\n            for(int i=0;i<dir.size();i++){\\n                int x = temp.first + dir[i].first;\\n                int y = temp.second + dir[i].second;\\n\\t\\t\\t\\t// So, the (x,y) must be possible within the matrix and it must not be on the border.\\n                if(isSafe(x,y,m,n) && !isBorder(x,y, m,n) && board[x][y]==\\'O\\'){\\n                    board[x][y]= \\'.\\';\\n                    q.push(make_pair(x,y));\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n\\t\\t\\t    // Just convert the remaining \\'O\\' into \\'X\\' as they are not connected to any border \\'O\\'.\\n                if(board[i][j]==\\'O\\')\\n                    board[i][j] = \\'X\\';\\n                // Now, convert the \\'.\\' into \\'O\\' as they were connected to some border \\'O\\'.\\n\\t\\t\\t\\telse if(board[i][j]==\\'.\\')\\n                    board[i][j] = \\'O\\';\\n    }\\n};\\n```\\nIf you have any doubts, do let me know in the **comment** section below.\\nIf you like this solution, do **UPVOTE**.\\nHappy Coding :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\t// To check whether the indices are present in the matrix. [Like (-1,0) is not present]\\n    bool isSafe(int i, int j, int m, int n){\\n        return (i>=0 && i<m && j>=0 && j<n);\\n    }\\n\\t// Checks whether the indices are present at the border of the matrix.\\n    bool isBorder(int i, int j, int m, int n){\\n        return (i==0 || i==m-1 || j==0 || j==n-1);\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        if(board.size()==0)\\n            return ;\\n\\t\\t// m is the number of rows.\\n        int m = board.size();\\n\\t\\t// n is the number of columns\\n        int n = board[0].size();\\n\\t\\t// Taking queue for BFS.\\n        queue<pair<int,int>> q;\\n\\t\\t// dir contains the directions in which the checking is to be done.\\n        vector<pair<int, int>> dir = {{1,0}, {-1,0}, {0, 1}, {0, -1}};\\n\\t\\t// Finding the border elements as \\'O\\' and converting it into something else.\\n\\t\\t// This is done due to the reason because, they are not to be flipped in the final matrix.\\n\\t\\t// We could check only the border rows and columns but I have instead traversed the whole matrix. You can surely save up some time here.\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(board[i][j]==\\'O\\' && isBorder(i,j,m,n)){\\n\\t\\t\\t\\t\\t// Converting the \\'O\\' into \\'.\\' so, that they can be later changed to \\'O\\'.\\n                    board[i][j] = \\'.\\';\\n                    q.push(make_pair(i,j));                    \\n                }\\n            }\\n        }\\n\\t\\t// Starting the BFS.\\n        while(!q.empty()){\\n            pair<int, int> temp = q.front();\\n            q.pop();\\n\\t\\t\\t// Checking all the directions.\\n            for(int i=0;i<dir.size();i++){\\n                int x = temp.first + dir[i].first;\\n                int y = temp.second + dir[i].second;\\n\\t\\t\\t\\t// So, the (x,y) must be possible within the matrix and it must not be on the border.\\n                if(isSafe(x,y,m,n) && !isBorder(x,y, m,n) && board[x][y]==\\'O\\'){\\n                    board[x][y]= \\'.\\';\\n                    q.push(make_pair(x,y));\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n\\t\\t\\t    // Just convert the remaining \\'O\\' into \\'X\\' as they are not connected to any border \\'O\\'.\\n                if(board[i][j]==\\'O\\')\\n                    board[i][j] = \\'X\\';\\n                // Now, convert the \\'.\\' into \\'O\\' as they were connected to some border \\'O\\'.\\n\\t\\t\\t\\telse if(board[i][j]==\\'.\\')\\n                    board[i][j] = \\'O\\';\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41646,
                "title": "concise-12ms-c-dfs-solution",
                "content": "First check all surrounding rows columns find those 'O' and their neighbors that are also 'O', make them to some other character like '1'. then traverse the whole board, now the 'O' left need to be turned to 'X', and those marked '1' turned back to 'O'\\n\\nlike this:\\n\\n    X X X X        X X X X         X X X X\\n    X O O X  --->  X O O X   --->  X X X X\\n    X X O X        X X O X         X X X X\\n    X O X X        X 1 X X         X O X X\\n\\ncode:\\n\\n    class Solution {\\n    public:\\n        void solve(vector<vector<char>>& board) {\\n            if (board.empty()) return;\\n            int row = board.size(), col = board[0].size();\\n            for (int i = 0; i < row; ++i) {\\n                check(board, i, 0);             // first column\\n                check(board, i, col - 1);       // last column\\n            }\\n            for (int j = 1; j < col - 1; ++j) {\\n                check(board, 0, j);             // first row\\n                check(board, row - 1, j);       // last row\\n            }\\n            for (int i = 0; i < row; ++i)\\n                for (int j = 0; j < col; ++j)\\n                    if (board[i][j] == 'O') board[i][j] = 'X';\\n                    else if (board[i][j] == '1') board[i][j] = 'O';\\n        }\\n        \\n        void check(vector<vector<char>>& board, int i, int j) {\\n            if (board[i][j] == 'O') {\\n                board[i][j] = '1';\\n                if (i > 1) check(board, i - 1, j);\\n                if (j > 1) check(board, i, j - 1);\\n                if (i + 1 < board.size()) check(board, i + 1, j);\\n                if (j + 1 < board[0].size()) check(board, i, j + 1);\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        void solve(vector<vector<char>>& board) {\\n            if (board.empty()) return;\\n            int row = board.size(), col = board[0].size();\\n            for (int i = 0; i < row; ++i) {\\n                check(board, i, 0);             // first column\\n                check(board, i, col - 1);       // last column\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 163363,
                "title": "java-dfs-with-explanations",
                "content": "[Click to see Union-Find Solution](https://leetcode.com/problems/surrounded-regions/discuss/167165/Java-Union-Find-with-Explanations)\\n\\n**Logical Thinking**\\nWe aim to set all O\\'s which doesn\\'t locate at borders or connect to O at borders  to X.\\nWe mark all O\\'s at borders and apply DFS at each O at boarders to mark all O\\'s connected to it. The un-marked O\\'s ought to be set X.\\n\\n**Trick**\\nWe search for invalid candidates (and exclude them) rather than search for valid candidates.\\n\\n**Code**\\n```\\n    private static final int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    public void solve(char[][] board) {\\n        if (board.length == 0)\\n            return;\\n        \\n        int rows = board.length, cols = board[0].length;\\n        \\n        \\n        for (int i = 0; i < rows; i++) {\\n            if (board[i][0] == \\'O\\')\\n                markNotSurrounded(i, 0, board);\\n            if (board[i][cols - 1] == \\'O\\')\\n                markNotSurrounded(i, cols - 1, board);\\n        }\\n        \\n        for (int j = 0; j < cols; j++) {\\n            if (board[0][j] == \\'O\\')\\n                markNotSurrounded(0, j, board);\\n            if (board[rows - 1][j] == \\'O\\')\\n                markNotSurrounded(rows - 1, j, board);\\n        }\\n        \\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                \\n                if (board[i][j] == \\'*\\') // Restores \\'*\\' to \\'O\\'\\n                    board[i][j] = \\'O\\';\\n                else if (board[i][j] == \\'O\\') // Captures \\'O\\' surrounded by \\'X\\'\\n                    board[i][j] = \\'X\\';\\n            }\\n        }\\n    }\\n    \\n    // Mark \\'O\\' not surrounded by \\'X\\' as \\'*\\'\\n    private void markNotSurrounded(int x, int y, char[][] board) { \\n        board[x][y] = \\'*\\';\\n        for (int[] dir : directions) {\\n            int nx = x + dir[0], ny = y + dir[1];\\n            if (nx >= 0 && nx < board.length\\n               && ny >= 0 && ny < board[0].length\\n               && board[nx][ny] == \\'O\\') {\\n                markNotSurrounded(nx, ny, board);\\n            }\\n        }\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    private static final int[][] directions = {{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n\\n    public void solve(char[][] board) {\\n        if (board.length == 0)\\n            return;\\n        \\n        int rows = board.length, cols = board[0].length;\\n        \\n        \\n        for (int i = 0; i < rows; i++) {\\n            if (board[i][0] == \\'O\\')\\n                markNotSurrounded(i, 0, board);\\n            if (board[i][cols - 1] == \\'O\\')\\n                markNotSurrounded(i, cols - 1, board);\\n        }\\n        \\n        for (int j = 0; j < cols; j++) {\\n            if (board[0][j] == \\'O\\')\\n                markNotSurrounded(0, j, board);\\n            if (board[rows - 1][j] == \\'O\\')\\n                markNotSurrounded(rows - 1, j, board);\\n        }\\n        \\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                \\n                if (board[i][j] == \\'*\\') // Restores \\'*\\' to \\'O\\'\\n                    board[i][j] = \\'O\\';\\n                else if (board[i][j] == \\'O\\') // Captures \\'O\\' surrounded by \\'X\\'\\n                    board[i][j] = \\'X\\';\\n            }\\n        }\\n    }\\n    \\n    // Mark \\'O\\' not surrounded by \\'X\\' as \\'*\\'\\n    private void markNotSurrounded(int x, int y, char[][] board) { \\n        board[x][y] = \\'*\\';\\n        for (int[] dir : directions) {\\n            int nx = x + dir[0], ny = y + dir[1];\\n            if (nx >= 0 && nx < board.length\\n               && ny >= 0 && ny < board[0].length\\n               && board[nx][ny] == \\'O\\') {\\n                markNotSurrounded(nx, ny, board);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1497388,
                "title": "c-dfs-approach-explained",
                "content": "Approach- We apply dfs on all Os that are on boundary and mark them as #,then we just need to traverse the matrix and flip remaining Os to X as these are the ones that are completely surrounded by X. Also,we flip back the #s to Os.\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i,int j,vector<vector<char>>& board){\\n    if(i<0 || i>=board.size() || j<0 || j>=board[0].size() || board[i][j]!=\\'O\\') return;\\n    if(board[i][j]==\\'O\\') board[i][j]=\\'#\\';\\n    dfs(i+1,j,board);\\n    dfs(i,j+1,board);\\n    dfs(i-1,j,board);\\n    dfs(i,j-1,board);  \\n}\\n    \\n    \\n    void solve(vector<vector<char>>& board) {\\n        int m=board.size(),n=board[0].size();\\n       for(int i=0;i<m;i++){\\n           for(int j=0;j<n;j++){\\n               if((i==0 || i==m-1 || j==0 || j==n-1) && board[i][j]==\\'O\\'){\\n                   dfs(i,j,board);\\n               }\\n           }\\n       } \\n         for(int i=0;i<m;i++){\\n           for(int j=0;j<n;j++){\\n               if(board[i][j]==\\'O\\') board[i][j]=\\'X\\';\\n               if(board[i][j]==\\'#\\') board[i][j]=\\'O\\';\\n               }\\n           }\\n       }\\n\\n};\\n```\\nHope you found this useful :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i,int j,vector<vector<char>>& board){\\n    if(i<0 || i>=board.size() || j<0 || j>=board[0].size() || board[i][j]!=\\'O\\') return;\\n    if(board[i][j]==\\'O\\') board[i][j]=\\'#\\';\\n    dfs(i+1,j,board);\\n    dfs(i,j+1,board);\\n    dfs(i-1,j,board);\\n    dfs(i,j-1,board);  \\n}\\n    \\n    \\n    void solve(vector<vector<char>>& board) {\\n        int m=board.size(),n=board[0].size();\\n       for(int i=0;i<m;i++){\\n           for(int j=0;j<n;j++){\\n               if((i==0 || i==m-1 || j==0 || j==n-1) && board[i][j]==\\'O\\'){\\n                   dfs(i,j,board);\\n               }\\n           }\\n       } \\n         for(int i=0;i<m;i++){\\n           for(int j=0;j<n;j++){\\n               if(board[i][j]==\\'O\\') board[i][j]=\\'X\\';\\n               if(board[i][j]==\\'#\\') board[i][j]=\\'O\\';\\n               }\\n           }\\n       }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41895,
                "title": "share-my-clean-java-code",
                "content": "    public class Solution {\\n        public void solve(char[][] board) {\\n            int rown = board.length;\\n            if (rown==0) return;\\n            int coln = board[0].length;\\n            for (int row=0; row<rown; ++row) {\\n                for (int col=0; col<coln; ++col) {\\n                    if (row==0 || row==rown-1 || col==0 || col==coln-1) {\\n                        if (board[row][col]=='O') {\\n                            Queue<Integer> q = new LinkedList<>();\\n                            board[row][col]='1';\\n                            q.add(row*coln+col);\\n                            while (!q.isEmpty()) {\\n                                int cur = q.poll();\\n                                int x = cur/coln;\\n                                int y = cur%coln;\\n                                if (y+1<coln && board[x][y+1]=='O') {\\n                                    q.add(cur+1);\\n                                    board[x][y+1] = '1';\\n                                }\\n                                if (x+1<rown && board[x+1][y]=='O') {\\n                                    q.add(cur+coln);\\n                                    board[x+1][y] = '1';\\n                                }\\n                                if (y-1>=0 && board[x][y-1]=='O') {\\n                                    q.add(cur-1);\\n                                    board[x][y-1] = '1';\\n                                }\\n                                if (x-1>=0 && board[x-1][y]=='O') {\\n                                    q.add(cur-coln);\\n                                    board[x-1][y] = '1';\\n                                }\\n                            }\\n                        }\\n                    }\\n                }\\n            }\\n            for (int i=0; i<rown; ++i) {\\n                for (int j=0; j<coln; ++j) {\\n                    if (board[i][j]=='O') {\\n                        board[i][j]='X';\\n                    } else if (board[i][j]=='1') {\\n                        board[i][j]='O';\\n                    }\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "class Solution {\\n        public void solve(char[][] board) {\\n            int rown = board.length;\\n            if (rown==0) return;\\n            int coln = board[0].length;\\n            for (int row=0; row<rown; ++row) {\\n                for (int col=0; col<coln; ++col) {\\n                    if (row==0 || row==rown-1 || col==0 || col==coln-1) {\\n                        if (board[row][col]=='O') {\\n                            Queue<Integer> q = new LinkedList<>();\\n                            board[row][col]='1';\\n                            q.add(row*coln+col);\\n                            while (!q.isEmpty()) {\\n                                int cur = q.poll();\\n                                int x = cur/coln;\\n                                int y = cur%coln;\\n                                if (y+1<coln && board[x][y+1]=='O') {\\n                                    q.add(cur+1);\\n                                    board[x][y+1] = '1';\\n                                }",
                "codeTag": "Java"
            },
            {
                "id": 3318618,
                "title": "dfs-bfs-easy-to-understand-c-clean-code",
                "content": "# Intuition\\nStore all the boundary elements which are \\'O\\' in a data structure like queue or stack mark all the O\\'s which are connected to these O\\'s and convert all other O\\'s to X.\\n\\n# Approach\\nWe can use DFS as well as BFS. I am using BFS int this solution:\\n1. First store position of all the O\\'s that are present at the boundary in the queue data structue.\\n2. Start BFS traversal and mark all the O\\'s that are connected to these boundary element.\\n3. After completing the whole traversal, check which O\\'s are unmarked, that means they are not connected to the boundary element that\\'s why they are unmarked.\\n4. Now, replace all the umarked O\\'s to X.\\n\\n# Complexity\\n- Time complexity: O(m*n) : m: rows, n: columns\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(m*n) : m: rows, n: columns\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& b) {\\n        int m = b.size(), n = b[0].size();\\n        vector<vector<int>> vis(m, vector<int> (n));\\n        queue<pair<int, int>> q;\\n\\n        // First store position of all the O\\'s that are present at the boundary in the queue data structue\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                if(i==0 || j==0 || i==m-1 || j==n-1){\\n                    if(b[i][j]==\\'O\\'){\\n                        q.push({i, j});\\n                        vis[i][j]=1;\\n                    } \\n                }\\n\\n        // Start BFS traversal and mark all the O\\'s that are connected to these boundary element\\n        while(!q.empty()){\\n            auto [r, c] = q.front();\\n            vis[r][c]=1;\\n            q.pop();\\n            for(int x=-1; x<=1; x++){\\n                for(int y=-1; y<=1; y++){\\n                    if(x&&y || (x==0 && y==0)) continue;\\n                    int nrow = r+x, ncol = c+y;\\n                    if(nrow<0 || ncol<0 || nrow>=m || ncol>=n) continue;\\n                    if(vis[nrow][ncol] || b[nrow][ncol]==\\'X\\') continue;\\n                    vis[nrow][ncol] = 1;\\n                    q.push({nrow, ncol});\\n                }\\n            }\\n        }\\n        // check which O\\'s are unmarked, that means they are not connected to the boundary element that\\'s why they are unmarked\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(vis[i][j]==0 && b[i][j]==\\'O\\') b[i][j] = \\'X\\';\\n            }\\n        }\\n\\n    }\\n};\\n\\n// Please upvote if this solution helped you somehow!\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& b) {\\n        int m = b.size(), n = b[0].size();\\n        vector<vector<int>> vis(m, vector<int> (n));\\n        queue<pair<int, int>> q;\\n\\n        // First store position of all the O\\'s that are present at the boundary in the queue data structue\\n        for(int i=0; i<m; i++)\\n            for(int j=0; j<n; j++)\\n                if(i==0 || j==0 || i==m-1 || j==n-1){\\n                    if(b[i][j]==\\'O\\'){\\n                        q.push({i, j});\\n                        vis[i][j]=1;\\n                    } \\n                }\\n\\n        // Start BFS traversal and mark all the O\\'s that are connected to these boundary element\\n        while(!q.empty()){\\n            auto [r, c] = q.front();\\n            vis[r][c]=1;\\n            q.pop();\\n            for(int x=-1; x<=1; x++){\\n                for(int y=-1; y<=1; y++){\\n                    if(x&&y || (x==0 && y==0)) continue;\\n                    int nrow = r+x, ncol = c+y;\\n                    if(nrow<0 || ncol<0 || nrow>=m || ncol>=n) continue;\\n                    if(vis[nrow][ncol] || b[nrow][ncol]==\\'X\\') continue;\\n                    vis[nrow][ncol] = 1;\\n                    q.push({nrow, ncol});\\n                }\\n            }\\n        }\\n        // check which O\\'s are unmarked, that means they are not connected to the boundary element that\\'s why they are unmarked\\n        for(int i=0; i<m; i++){\\n            for(int j=0; j<n; j++){\\n                if(vis[i][j]==0 && b[i][j]==\\'O\\') b[i][j] = \\'X\\';\\n            }\\n        }\\n\\n    }\\n};\\n\\n// Please upvote if this solution helped you somehow!\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 389024,
                "title": "javascript-runtime-faster-than-88-14-memory-usage-less-than-100-00",
                "content": "```\\nvar solve = function(board) {\\n    if(board.length ==0) return null \\n    \\n    for(var i=0;i<board.length;i++){\\n        for(var j=0;j<board[0].length;j++){\\n            if(board[i][j] == \\'O\\' && (i==0 || i==board.length-1 || j==0 || j==board[0].length-1)){\\n                  dfs(board,i,j)\\n               }\\n        }\\n    }\\n    \\n    for(var i=0;i<board.length;i++){\\n        for(var j=0;j<board[0].length;j++){\\n            if(board[i][j]==\\'W\\'){\\n                  board[i][j]=\\'O\\'\\n               }\\n            else {\\n                    board[i][j]=\\'X\\'\\n                    }\\n        }\\n    }\\n    \\n    return board\\n};\\n\\n  function dfs(board,i,j){\\n      if(i<0 || j<0 || i>=board.length || j >=board[0].length || board[i][j]==\\'X\\' || board[i][j]==\\'W\\'){\\n            return \\n         }\\n      board[i][j]=\\'W\\';\\n      dfs(board,i+1,j)\\n      dfs(board,i-1,j)\\n      dfs(board,i,j+1)\\n      dfs(board,i,j-1)\\n      return \\n  }\\n  ```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar solve = function(board) {\\n    if(board.length ==0) return null \\n    \\n    for(var i=0;i<board.length;i++){\\n        for(var j=0;j<board[0].length;j++){\\n            if(board[i][j] == \\'O\\' && (i==0 || i==board.length-1 || j==0 || j==board[0].length-1)){\\n                  dfs(board,i,j)\\n               }\\n        }\\n    }\\n    \\n    for(var i=0;i<board.length;i++){\\n        for(var j=0;j<board[0].length;j++){\\n            if(board[i][j]==\\'W\\'){\\n                  board[i][j]=\\'O\\'\\n               }\\n            else {\\n                    board[i][j]=\\'X\\'\\n                    }\\n        }\\n    }\\n    \\n    return board\\n};\\n\\n  function dfs(board,i,j){\\n      if(i<0 || j<0 || i>=board.length || j >=board[0].length || board[i][j]==\\'X\\' || board[i][j]==\\'W\\'){\\n            return \\n         }\\n      board[i][j]=\\'W\\';\\n      dfs(board,i+1,j)\\n      dfs(board,i-1,j)\\n      dfs(board,i,j+1)\\n      dfs(board,i,j-1)\\n      return \\n  }\\n  ```",
                "codeTag": "Unknown"
            },
            {
                "id": 294646,
                "title": "python-dfs-solution-beats-96-108-ms",
                "content": "```\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n\\t\\n        m , n  = len(board) , len(board[0]) if m>0 else 0 \\n            \\n        def dfs(i,j):                              \\n            if board[i][j] == \"O\":\\n                board[i][j] = \\'D\\'\\n                for x , y in [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]:\\n                    if 0<=x<m and 0<=y<n:\\n                        dfs(x,y) \\n                            \\n        for i in range(m):\\n            dfs(i,0)\\n            dfs(i,n-1)\\n        \\n        for i in range(n):\\n            dfs(0 ,i)\\n            dfs(m-1 ,i)\\n            \\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j]== \\'D\\' :\\n                    board[i][j] = \"O\"\\n                else:\\n                    board[i][j] = \"X\"\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n\\t\\n        m , n  = len(board) , len(board[0]) if m>0 else 0 \\n            \\n        def dfs(i,j):                              \\n            if board[i][j] == \"O\":\\n                board[i][j] = \\'D\\'\\n                for x , y in [(i+1,j), (i-1,j), (i,j+1), (i,j-1)]:\\n                    if 0<=x<m and 0<=y<n:\\n                        dfs(x,y) \\n                            \\n        for i in range(m):\\n            dfs(i,0)\\n            dfs(i,n-1)\\n        \\n        for i in range(n):\\n            dfs(0 ,i)\\n            dfs(m-1 ,i)\\n            \\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j]== \\'D\\' :\\n                    board[i][j] = \"O\"\\n                else:\\n                    board[i][j] = \"X\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 139944,
                "title": "clean-javascript-solution",
                "content": "Idea\\n1) Check four borders. If it is O, change it and all its neighbor to temporary #\\n2) Change all O to X\\n3) Change all # to O\\n\\nExample\\n```\\nX X X X      X X X X      X X X X\\nX X O X  ->  X X O X  ->  X X X X\\nX O X X      X # X X      X O X X\\nX O X X      X # X X      X O X X\\n```\\n\\n```js\\nfunction solve(board) {\\n  if (!board.length) return;\\n\\n  // change every square connected to left and right borders from O to temporary #\\n  for (let i = 0; i < board.length; i++) {\\n    mark(board, i, 0);\\n    mark(board, i, board[0].length - 1);\\n  }\\n\\n  // change every square connected to top and bottom borders from O to temporary #\\n  for (let i = 1; i < board[0].length - 1; i++) {\\n    mark(board, 0, i);\\n    mark(board, board.length - 1, i);\\n  }\\n\\n  for (let i = 0; i < board.length; i++) {\\n    for (let j = 0; j < board[0].length; j++) {\\n      // change the rest of O to X\\n      if (board[i][j] === \\'O\\') board[i][j] = \\'X\\';\\n\\n      // change temporary # back to O\\n      if (board[i][j] === \\'#\\') board[i][j] = \\'O\\';\\n    }\\n  }\\n}\\n\\nfunction mark(board, i ,j) {\\n  if (i < 0 || i > board.length - 1 || j < 0 || j > board[0].length - 1) return;\\n  if (board[i][j] !== \\'O\\') return;\\n\\n  board[i][j] = \\'#\\';\\n  \\n  mark(board, i - 1, j);\\n  mark(board, i + 1, j);\\n  mark(board, i, j - 1);\\n  mark(board, i, j + 1);\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nX X X X      X X X X      X X X X\\nX X O X  ->  X X O X  ->  X X X X\\nX O X X      X # X X      X O X X\\nX O X X      X # X X      X O X X\\n```\n```js\\nfunction solve(board) {\\n  if (!board.length) return;\\n\\n  // change every square connected to left and right borders from O to temporary #\\n  for (let i = 0; i < board.length; i++) {\\n    mark(board, i, 0);\\n    mark(board, i, board[0].length - 1);\\n  }\\n\\n  // change every square connected to top and bottom borders from O to temporary #\\n  for (let i = 1; i < board[0].length - 1; i++) {\\n    mark(board, 0, i);\\n    mark(board, board.length - 1, i);\\n  }\\n\\n  for (let i = 0; i < board.length; i++) {\\n    for (let j = 0; j < board[0].length; j++) {\\n      // change the rest of O to X\\n      if (board[i][j] === \\'O\\') board[i][j] = \\'X\\';\\n\\n      // change temporary # back to O\\n      if (board[i][j] === \\'#\\') board[i][j] = \\'O\\';\\n    }\\n  }\\n}\\n\\nfunction mark(board, i ,j) {\\n  if (i < 0 || i > board.length - 1 || j < 0 || j > board[0].length - 1) return;\\n  if (board[i][j] !== \\'O\\') return;\\n\\n  board[i][j] = \\'#\\';\\n  \\n  mark(board, i - 1, j);\\n  mark(board, i + 1, j);\\n  mark(board, i, j - 1);\\n  mark(board, i, j + 1);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 362896,
                "title": "c-dfs-bfs-and-union-find-solutions",
                "content": "For **DFS** and **BFS**, we have the same idea in solving this problem.\\n1. We first go through boarders to check if there is any `\\'O\\'`. \\n2. If found `\\'O\\'` on boarders, perform DFS or BFS and make all connected `\\'O\\'` becomes `\\'D\\'`.\\n3. After that, we go through whole board and mark remaining `\\'O\\'` as `\\'X\\'`, and `\\'D\\'` as `\\'O\\'`.\\n\\nFor **Union Find**, we have a different idea.\\n1. We go through whole board, if found `\\'O\\'` and if it is on boarder, connect to `dummy` node.\\n2. Otherwise, connect to surrounded `\\'O\\'`.\\n3. Finally, goes through whole board again and check if `\\'O\\'` is connected to `dummy` node. If yes, then it means this `\\'O\\'` is not captured.\\n\\n## **DFS**\\n```cpp\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        if(!board.size()) return;\\n        \\n        int rows = board.size();\\n        int cols = board[0].size();\\n        \\n        // Go through boarder to find \\'O\\'\\n        for(int i=0; i<rows; ++i) {\\n            DFS(board, i, 0, rows, cols);\\n            if(cols>1) DFS(board, i, cols-1, rows, cols);\\n        }\\n        for(int i=1; i<cols-1; ++i) {\\n            DFS(board, 0, i, rows, cols);\\n            if(rows>1) DFS(board, rows-1, i, rows, cols);\\n        }\\n        \\n        // Go through whole board and mark \\'O\\' as \\'X\\', \\'D\\' as \\'O\\'\\n        for(int i=0; i<rows; ++i) {\\n            for(int j=0; j<cols; ++j) {\\n                if(board[i][j]==\\'O\\') board[i][j] = \\'X\\';\\n                else if(board[i][j]==\\'D\\') board[i][j] = \\'O\\';\\n            }\\n        }\\n    }\\n    \\n    void DFS(vector<vector<char>>& board, int i, int j, int rows, int cols) {\\n        if(i<0 || i>=rows || j<0 || j>=cols || board[i][j]==\\'X\\' || board[i][j]==\\'D\\') return;\\n        \\n        // If current is \\'O\\', mark as \\'D\\' and preform DFS\\n        if(board[i][j]==\\'O\\') board[i][j] = \\'D\\';\\n        \\n        DFS(board, i-1, j, rows, cols);\\n        DFS(board, i+1, j, rows, cols);\\n        DFS(board, i, j-1, rows, cols);\\n        DFS(board, i, j+1, rows, cols);\\n    }\\n};\\n```\\n\\n## **BFS**\\n```cpp\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        if(!board.size()) return;\\n        \\n        int rows = board.size();\\n        int cols = board[0].size();\\n        \\n        // Go through boarder to find \\'O\\'\\n        for(int i=0; i<rows; ++i) {\\n            BFS(board, i, 0, rows, cols);\\n            if(cols>1) BFS(board, i, cols-1, rows, cols);\\n        }\\n        for(int i=1; i<cols-1; ++i) {\\n            BFS(board, 0, i, rows, cols);\\n            if(rows>1) BFS(board, rows-1, i, rows, cols);\\n        }\\n        \\n        // Go through whole board and mark \\'O\\' as \\'X\\', \\'D\\' as \\'O\\'\\n        for(int i=0; i<rows; ++i) {\\n            for(int j=0; j<cols; ++j) {\\n                if(board[i][j]==\\'O\\') board[i][j] = \\'X\\';\\n                else if(board[i][j]==\\'D\\') board[i][j] = \\'O\\';\\n            }\\n        }\\n    }\\n    \\n    void BFS(vector<vector<char>>& board, int i, int j, int rows, int cols) {\\n        if(board[i][j]!=\\'O\\') return;\\n        else board[i][j] = \\'D\\';\\n        \\n        queue<pair<int, int>> myQueue;\\n        myQueue.push(make_pair(i, j));\\n        \\n        while(!myQueue.empty()) {\\n            int x = myQueue.front().first;\\n            int y = myQueue.front().second;\\n            myQueue.pop();\\n            \\n            if(x+1<rows && board[x+1][y]==\\'O\\') {\\n                myQueue.push(make_pair(x+1, y));\\n                board[x+1][y] = \\'D\\';\\n            }\\n            if(x-1>0 && board[x-1][y]==\\'O\\') {\\n                myQueue.push(make_pair(x-1, y));\\n                board[x-1][y] = \\'D\\';\\n            }\\n            if(y+1<cols && board[x][y+1]==\\'O\\') {\\n                myQueue.push(make_pair(x, y+1));\\n                board[x][y+1] = \\'D\\';\\n            }\\n            if(y-1>0 && board[x][y-1]==\\'O\\') {\\n                myQueue.push(make_pair(x, y-1));\\n                board[x][y-1] = \\'D\\';\\n            }\\n        }\\n    }\\n};\\n```\\n\\n## **Union Find**\\n```cpp\\nclass UnionFind {\\npublic:\\n    vector<int> parent;\\n    \\n    UnionFind(vector<vector<char>>& board, int m ,int n) {\\n        // Add dummy node to the tail\\n        for(int i=0; i<m*n+1; ++i) {\\n            parent.push_back(i);\\n        }\\n    }\\n    \\n    int find(int i) {\\n        if(i == parent[i]) return i;\\n        return find(parent[i]);\\n    }\\n    \\n    void unite(int i, int j) {\\n        int pi = find(i);\\n        int pj = find(j);\\n        if(pi != pj) parent[pj] = pi;\\n    }\\n    \\n    bool isConnect(int i, int j) {\\n        return find(i) == find(j);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        if(!board.size()) return;\\n        \\n        int rows = board.size();\\n        int cols = board[0].size();\\n        \\n        UnionFind uf = UnionFind(board, rows, cols);\\n        int dummy = rows * cols;\\n        \\n        for(int i=0; i<rows; ++i) {\\n            for(int j=0; j<cols; ++j) {\\n                if(board[i][j]==\\'O\\') {\\n                    // If \\'O\\' is on boarder, connect to dummy node\\n                    if(i==0 || i==rows-1 || j==0 || j==cols-1){\\n                        uf.unite(i*cols+j, dummy);\\n                    }\\n                    // Else, connect surrounded \\'O\\'\\n                    else {\\n                        if(i>0 && board[i-1][j]==\\'O\\') uf.unite(i*cols+j, (i-1)*cols+j);\\n                        if(i<rows-1 && board[i+1][j]==\\'O\\') uf.unite(i*cols+j, (i+1)*cols+j);\\n                        if(j>0 && board[i][j-1]==\\'O\\') uf.unite(i*cols+j, i*cols+j-1);\\n                        if(j<cols-1 && board[i][j+1]==\\'O\\') uf.unite(i*cols+j, i*cols+j+1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // Go through whole board check each \\'O\\' if it is connected to dummy node\\n        // If no, mark as \\'X\\'\\n        for(int i=0; i<rows; ++i) {\\n            for(int j=0; j<cols; ++j) {\\n                if(board[i][j]==\\'O\\'){\\n                    if(uf.isConnect(i*cols+j, dummy) == false) board[i][j] = \\'X\\';\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        if(!board.size()) return;\\n        \\n        int rows = board.size();\\n        int cols = board[0].size();\\n        \\n        // Go through boarder to find \\'O\\'\\n        for(int i=0; i<rows; ++i) {\\n            DFS(board, i, 0, rows, cols);\\n            if(cols>1) DFS(board, i, cols-1, rows, cols);\\n        }\\n        for(int i=1; i<cols-1; ++i) {\\n            DFS(board, 0, i, rows, cols);\\n            if(rows>1) DFS(board, rows-1, i, rows, cols);\\n        }\\n        \\n        // Go through whole board and mark \\'O\\' as \\'X\\', \\'D\\' as \\'O\\'\\n        for(int i=0; i<rows; ++i) {\\n            for(int j=0; j<cols; ++j) {\\n                if(board[i][j]==\\'O\\') board[i][j] = \\'X\\';\\n                else if(board[i][j]==\\'D\\') board[i][j] = \\'O\\';\\n            }\\n        }\\n    }\\n    \\n    void DFS(vector<vector<char>>& board, int i, int j, int rows, int cols) {\\n        if(i<0 || i>=rows || j<0 || j>=cols || board[i][j]==\\'X\\' || board[i][j]==\\'D\\') return;\\n        \\n        // If current is \\'O\\', mark as \\'D\\' and preform DFS\\n        if(board[i][j]==\\'O\\') board[i][j] = \\'D\\';\\n        \\n        DFS(board, i-1, j, rows, cols);\\n        DFS(board, i+1, j, rows, cols);\\n        DFS(board, i, j-1, rows, cols);\\n        DFS(board, i, j+1, rows, cols);\\n    }\\n};\\n```\n```cpp\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        if(!board.size()) return;\\n        \\n        int rows = board.size();\\n        int cols = board[0].size();\\n        \\n        // Go through boarder to find \\'O\\'\\n        for(int i=0; i<rows; ++i) {\\n            BFS(board, i, 0, rows, cols);\\n            if(cols>1) BFS(board, i, cols-1, rows, cols);\\n        }\\n        for(int i=1; i<cols-1; ++i) {\\n            BFS(board, 0, i, rows, cols);\\n            if(rows>1) BFS(board, rows-1, i, rows, cols);\\n        }\\n        \\n        // Go through whole board and mark \\'O\\' as \\'X\\', \\'D\\' as \\'O\\'\\n        for(int i=0; i<rows; ++i) {\\n            for(int j=0; j<cols; ++j) {\\n                if(board[i][j]==\\'O\\') board[i][j] = \\'X\\';\\n                else if(board[i][j]==\\'D\\') board[i][j] = \\'O\\';\\n            }\\n        }\\n    }\\n    \\n    void BFS(vector<vector<char>>& board, int i, int j, int rows, int cols) {\\n        if(board[i][j]!=\\'O\\') return;\\n        else board[i][j] = \\'D\\';\\n        \\n        queue<pair<int, int>> myQueue;\\n        myQueue.push(make_pair(i, j));\\n        \\n        while(!myQueue.empty()) {\\n            int x = myQueue.front().first;\\n            int y = myQueue.front().second;\\n            myQueue.pop();\\n            \\n            if(x+1<rows && board[x+1][y]==\\'O\\') {\\n                myQueue.push(make_pair(x+1, y));\\n                board[x+1][y] = \\'D\\';\\n            }\\n            if(x-1>0 && board[x-1][y]==\\'O\\') {\\n                myQueue.push(make_pair(x-1, y));\\n                board[x-1][y] = \\'D\\';\\n            }\\n            if(y+1<cols && board[x][y+1]==\\'O\\') {\\n                myQueue.push(make_pair(x, y+1));\\n                board[x][y+1] = \\'D\\';\\n            }\\n            if(y-1>0 && board[x][y-1]==\\'O\\') {\\n                myQueue.push(make_pair(x, y-1));\\n                board[x][y-1] = \\'D\\';\\n            }\\n        }\\n    }\\n};\\n```\n```cpp\\nclass UnionFind {\\npublic:\\n    vector<int> parent;\\n    \\n    UnionFind(vector<vector<char>>& board, int m ,int n) {\\n        // Add dummy node to the tail\\n        for(int i=0; i<m*n+1; ++i) {\\n            parent.push_back(i);\\n        }\\n    }\\n    \\n    int find(int i) {\\n        if(i == parent[i]) return i;\\n        return find(parent[i]);\\n    }\\n    \\n    void unite(int i, int j) {\\n        int pi = find(i);\\n        int pj = find(j);\\n        if(pi != pj) parent[pj] = pi;\\n    }\\n    \\n    bool isConnect(int i, int j) {\\n        return find(i) == find(j);\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        if(!board.size()) return;\\n        \\n        int rows = board.size();\\n        int cols = board[0].size();\\n        \\n        UnionFind uf = UnionFind(board, rows, cols);\\n        int dummy = rows * cols;\\n        \\n        for(int i=0; i<rows; ++i) {\\n            for(int j=0; j<cols; ++j) {\\n                if(board[i][j]==\\'O\\') {\\n                    // If \\'O\\' is on boarder, connect to dummy node\\n                    if(i==0 || i==rows-1 || j==0 || j==cols-1){\\n                        uf.unite(i*cols+j, dummy);\\n                    }\\n                    // Else, connect surrounded \\'O\\'\\n                    else {\\n                        if(i>0 && board[i-1][j]==\\'O\\') uf.unite(i*cols+j, (i-1)*cols+j);\\n                        if(i<rows-1 && board[i+1][j]==\\'O\\') uf.unite(i*cols+j, (i+1)*cols+j);\\n                        if(j>0 && board[i][j-1]==\\'O\\') uf.unite(i*cols+j, i*cols+j-1);\\n                        if(j<cols-1 && board[i][j+1]==\\'O\\') uf.unite(i*cols+j, i*cols+j+1);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // Go through whole board check each \\'O\\' if it is connected to dummy node\\n        // If no, mark as \\'X\\'\\n        for(int i=0; i<rows; ++i) {\\n            for(int j=0; j<cols; ++j) {\\n                if(board[i][j]==\\'O\\'){\\n                    if(uf.isConnect(i*cols+j, dummy) == false) board[i][j] = \\'X\\';\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 415699,
                "title": "simply-simple-python-approach-detailed-explanation",
                "content": "\\tclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        \\n        q = []\\n        \\n        r = len(board)\\n        if r == 0: return\\n        c = len(board[0])\\n        if c == 0: return\\n        \\n\\t\\t# First append all the corner Os and then do bfs on these values to get the \\n\\t\\t# neighbor Os. All Os which are connected to any corner O need to be remain \\n\\t\\t# as O. So replace them with T and then revert it back to O.\\n        for i in range(r):\\n            for j in range(c):\\n                if (i == 0 or j == 0 or i == r - 1 or j == c - 1) and board[i][j] == \"O\":\\n                    q.append((i,j))\\n\\n\\n        while q:\\n            i, j = q.pop(0)\\n            board[i][j] = \"T\"\\n            for x,y in [(-1, 0), (0, -1), (1, 0), (0, 1)]:\\n                x_n = i + x\\n                y_n = j + y\\n                \\n                if x_n >= 0 and x_n < r and y_n >= 0 and y_n < c and board[x_n][y_n] == \"O\":\\n                    q.append((x_n, y_n))\\n                    \\n        \\n        for i in range(r):\\n            for j in range(c):   \\n                if board[i][j] == \"O\": # Os are the indexes which are covered by Xs\\n                    board[i][j] = \"X\"\\n                elif board[i][j] == \"T\":\\n                    board[i][j] = \"O\"",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "\\tclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        \\n        q = []\\n        \\n        r = len(board)\\n        if r == 0: return\\n        c = len(board[0])\\n        if c == 0: return\\n        \\n\\t\\t# First append all the corner Os and then do bfs on these values to get the \\n\\t\\t# neighbor Os. All Os which are connected to any corner O need to be remain \\n\\t\\t# as O. So replace them with T and then revert it back to O.\\n        for i in range(r):\\n            for j in range(c):\\n                if (i == 0 or j == 0 or i == r - 1 or j == c - 1) and board[i][j] == \"O\":\\n                    q.append((i,j))\\n\\n\\n        while q:\\n            i, j = q.pop(0)\\n            board[i][j] = \"T\"\\n            for x,y in [(-1, 0), (0, -1), (1, 0), (0, 1)]:\\n                x_n = i + x\\n                y_n = j + y\\n                \\n                if x_n >= 0 and x_n < r and y_n >= 0 and y_n < c and board[x_n][y_n] == \"O\":\\n                    q.append((x_n, y_n))\\n                    \\n        \\n        for i in range(r):\\n            for j in range(c):   \\n                if board[i][j] == \"O\": # Os are the indexes which are covered by Xs\\n                    board[i][j] = \"X\"\\n                elif board[i][j] == \"T\":\\n                    board[i][j] = \"O\"",
                "codeTag": "Java"
            },
            {
                "id": 1552685,
                "title": "java-tc-o-m-n-sc-o-min-m-n-linear-space-bfs-simple-dfs-solutions",
                "content": "**BFS - Iterative Solution (This is a space optimized solution as compared to DFS solution)**\\n\\n```java\\n/**\\n * BFS - Iterative Solution (This is a space optimized solution as compared to DFS solution)\\n *\\n * Start from edges and then mark all \\'O\\' cells that connect to \\'O\\' cells at edge.\\n *\\n * Time Complexity: O(M * N)\\n * Each cell is visited twice. To set \\'#\\' and then to set them back to \\'O\\'.\\n *\\n * Space Complexity: O(min(M, N)). Space taken by the queue.\\n * In worst case, it will be equal to the diagonal of the board which is min(M, N)\\n *\\n * M = Number of rows. N = Number of columns.\\n */\\nclass Solution {\\n    private static final int[][] DIRS = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\\n    private static final char NON_CAPTURED = \\'#\\';\\n\\n    public void solve(char[][] board) {\\n        if (board == null) {\\n            throw new IllegalArgumentException(\"Input board is null\");\\n        }\\n        if (board.length == 0 || board[0].length == 0) {\\n            return;\\n        }\\n        int m = board.length;\\n        int n = board[0].length;\\n\\n        for (int i = 0; i < m; i++) {\\n            if (board[i][0] == \\'O\\') {\\n                bfsHelper(board, i, 0);\\n            }\\n\\n            if (board[i][n - 1] == \\'O\\') {\\n                bfsHelper(board, i, n - 1);\\n            }\\n        }\\n        for (int j = 1; j < n - 1; j++) {\\n            if (board[0][j] == \\'O\\') {\\n                bfsHelper(board, 0, j);\\n            }\\n            if (board[m - 1][j] == \\'O\\') {\\n                bfsHelper(board, m - 1, j);\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                board[i][j] = (board[i][j] == NON_CAPTURED) ? \\'O\\' : \\'X\\';\\n            }\\n        }\\n    }\\n\\n    private void bfsHelper(char[][] board, int i, int j) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] { i, j });\\n        board[i][j] = NON_CAPTURED;\\n\\n        while (!queue.isEmpty()) {\\n            int[] cur = queue.poll();\\n            for (int[] d : DIRS) {\\n                int x = cur[0] + d[0];\\n                int y = cur[1] + d[1];\\n                if (x < 0 || y < 0 || x >= board.length || y >= board[0].length || board[x][y] != \\'O\\') {\\n                    continue;\\n                }\\n                queue.offer(new int[] { x, y });\\n                board[x][y] = NON_CAPTURED;\\n            }\\n\\n        }\\n    }\\n}\\n```\\n\\n---\\n**DFS - Recursive Solution**\\n\\n```java\\n/**\\n * DFS - Recursive Solution\\n *\\n * Start from edges and then mark all \\'O\\' cells that connect to \\'O\\' cells at edge.\\n *\\n * Time Complexity: O(M * N)\\n * Each cell is visited twice. To set \\'#\\' and then to set them back to \\'O\\'.\\n *\\n * Space Complexity: O(M * N). Recursion Depth.\\n * In worst case if all cells are \\'O\\' then it will take O(M*N) space.\\n *\\n * M = Number of rows. N = Number of columns.\\n */\\nclass Solution {\\n    private static final int[][] DIRS = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\\n    private static final char NON_CAPTURED = \\'#\\';\\n\\n    public void solve(char[][] board) {\\n        if (board == null) {\\n            throw new IllegalArgumentException(\"Input board is null\");\\n        }\\n        if (board.length == 0 || board[0].length == 0) {\\n            return;\\n        }\\n        int m = board.length;\\n        int n = board[0].length;\\n\\n        for (int i = 0; i < m; i++) {\\n            if (board[i][0] == \\'O\\') {\\n                dfsHelper(board, i, 0);\\n            }\\n\\n            if (board[i][n - 1] == \\'O\\') {\\n                dfsHelper(board, i, n - 1);\\n            }\\n        }\\n        for (int j = 1; j < n - 1; j++) {\\n            if (board[0][j] == \\'O\\') {\\n                dfsHelper(board, 0, j);\\n            }\\n            if (board[m - 1][j] == \\'O\\') {\\n                dfsHelper(board, m - 1, j);\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                board[i][j] = (board[i][j] == NON_CAPTURED) ? \\'O\\' : \\'X\\';\\n            }\\n        }\\n    }\\n\\n    private void dfsHelper(char[][] board, int x, int y) {\\n        if (x < 0 || y < 0 || x >= board.length || y >= board[0].length || board[x][y] != \\'O\\') {\\n            return;\\n        }\\n        board[x][y] = NON_CAPTURED;\\n        for (int[] d : DIRS) {\\n            dfsHelper(board, x + d[0], y + d[1]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```java\\n/**\\n * BFS - Iterative Solution (This is a space optimized solution as compared to DFS solution)\\n *\\n * Start from edges and then mark all \\'O\\' cells that connect to \\'O\\' cells at edge.\\n *\\n * Time Complexity: O(M * N)\\n * Each cell is visited twice. To set \\'#\\' and then to set them back to \\'O\\'.\\n *\\n * Space Complexity: O(min(M, N)). Space taken by the queue.\\n * In worst case, it will be equal to the diagonal of the board which is min(M, N)\\n *\\n * M = Number of rows. N = Number of columns.\\n */\\nclass Solution {\\n    private static final int[][] DIRS = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\\n    private static final char NON_CAPTURED = \\'#\\';\\n\\n    public void solve(char[][] board) {\\n        if (board == null) {\\n            throw new IllegalArgumentException(\"Input board is null\");\\n        }\\n        if (board.length == 0 || board[0].length == 0) {\\n            return;\\n        }\\n        int m = board.length;\\n        int n = board[0].length;\\n\\n        for (int i = 0; i < m; i++) {\\n            if (board[i][0] == \\'O\\') {\\n                bfsHelper(board, i, 0);\\n            }\\n\\n            if (board[i][n - 1] == \\'O\\') {\\n                bfsHelper(board, i, n - 1);\\n            }\\n        }\\n        for (int j = 1; j < n - 1; j++) {\\n            if (board[0][j] == \\'O\\') {\\n                bfsHelper(board, 0, j);\\n            }\\n            if (board[m - 1][j] == \\'O\\') {\\n                bfsHelper(board, m - 1, j);\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                board[i][j] = (board[i][j] == NON_CAPTURED) ? \\'O\\' : \\'X\\';\\n            }\\n        }\\n    }\\n\\n    private void bfsHelper(char[][] board, int i, int j) {\\n        Queue<int[]> queue = new LinkedList<>();\\n        queue.offer(new int[] { i, j });\\n        board[i][j] = NON_CAPTURED;\\n\\n        while (!queue.isEmpty()) {\\n            int[] cur = queue.poll();\\n            for (int[] d : DIRS) {\\n                int x = cur[0] + d[0];\\n                int y = cur[1] + d[1];\\n                if (x < 0 || y < 0 || x >= board.length || y >= board[0].length || board[x][y] != \\'O\\') {\\n                    continue;\\n                }\\n                queue.offer(new int[] { x, y });\\n                board[x][y] = NON_CAPTURED;\\n            }\\n\\n        }\\n    }\\n}\\n```\n```java\\n/**\\n * DFS - Recursive Solution\\n *\\n * Start from edges and then mark all \\'O\\' cells that connect to \\'O\\' cells at edge.\\n *\\n * Time Complexity: O(M * N)\\n * Each cell is visited twice. To set \\'#\\' and then to set them back to \\'O\\'.\\n *\\n * Space Complexity: O(M * N). Recursion Depth.\\n * In worst case if all cells are \\'O\\' then it will take O(M*N) space.\\n *\\n * M = Number of rows. N = Number of columns.\\n */\\nclass Solution {\\n    private static final int[][] DIRS = { { -1, 0 }, { 0, -1 }, { 0, 1 }, { 1, 0 } };\\n    private static final char NON_CAPTURED = \\'#\\';\\n\\n    public void solve(char[][] board) {\\n        if (board == null) {\\n            throw new IllegalArgumentException(\"Input board is null\");\\n        }\\n        if (board.length == 0 || board[0].length == 0) {\\n            return;\\n        }\\n        int m = board.length;\\n        int n = board[0].length;\\n\\n        for (int i = 0; i < m; i++) {\\n            if (board[i][0] == \\'O\\') {\\n                dfsHelper(board, i, 0);\\n            }\\n\\n            if (board[i][n - 1] == \\'O\\') {\\n                dfsHelper(board, i, n - 1);\\n            }\\n        }\\n        for (int j = 1; j < n - 1; j++) {\\n            if (board[0][j] == \\'O\\') {\\n                dfsHelper(board, 0, j);\\n            }\\n            if (board[m - 1][j] == \\'O\\') {\\n                dfsHelper(board, m - 1, j);\\n            }\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                board[i][j] = (board[i][j] == NON_CAPTURED) ? \\'O\\' : \\'X\\';\\n            }\\n        }\\n    }\\n\\n    private void dfsHelper(char[][] board, int x, int y) {\\n        if (x < 0 || y < 0 || x >= board.length || y >= board[0].length || board[x][y] != \\'O\\') {\\n            return;\\n        }\\n        board[x][y] = NON_CAPTURED;\\n        for (int[] d : DIRS) {\\n            dfsHelper(board, x + d[0], y + d[1]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 367396,
                "title": "python-different-simple-solutions",
                "content": "# DFS or BFS:\\nPhase 1: Changing every O-region cells to \\'D\\' which touching the border  .\\nPhase 2: Change every \\'D\\' on the board to \\'O\\' and everything else to \\'X\\'.\\n```python\\n    def solve(self, board: List[List[str]]) -> None:\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \\'O\\' and (i in [0,len(board)-1] or j in [0,len(board[0])-1]):\\n                    DFS(i,j) # or BFS(i,j)\\n                    \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \\'O\\':\\n                    board[i][j] = \\'X\\'\\n                if board[i][j] == \\'D\\':\\n                    board[i][j] = \\'O\\'\\n```\\nDFS and BFS Implementation\\n```python\\n        def DFS(i,j):\\n            if 0<=i<len(board) and 0<=j<len(board[0]) and board[i][j] == \\'O\\':\\n                board[i][j] = \\'D\\'\\n                DFS(i+1,j)\\n                DFS(i-1,j)\\n                DFS(i,j+1)\\n                DFS(i,j-1)\\n```\\n```python\\n        def BFS(i,j):\\n            level = [(i,j)]\\n            while level:\\n                temp = []\\n                for i,j in level: \\n                    if 0<=i<len(board) and 0<=j<len(board[0]) and board[i][j] == \\'O\\':\\n                        board[i][j] = \\'D\\'\\n                        temp += [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]\\n                level = temp\\n```\\n\\nImplementation with deque\\n```python\\n        def DFS(i,j):\\n            queue = collections.deque([(i,j)])\\n            while queue:\\n                i,j = queue.pop()\\n                if 0<=i<len(board) and 0<=j<len(board[0]) and board[i][j] == \\'O\\':\\n                    board[i][j] = \\'D\\'\\n                    queue += [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]      \\n```\\n\\n```python\\n        def BFS(i,j):\\n            queue = collections.deque([(i,j)])\\n            while queue:\\n                i,j = queue.popleft()\\n                if 0<=i<len(board) and 0<=j<len(board[0]) and board[i][j] == \\'O\\':\\n                    board[i][j] = \\'D\\'\\n                    queue += [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]\\n```\\n\\n# UNION FIND:\\n```python\\n    def solve(self, board: List[List[str]]) -> None:\\n        # iterate cause TLE\\n        # def find(x):\\n        #     while x!=surround[x]:\\n        #         x = surround[x]\\n        #     return x\\n        \\n        def find(x):\\n            if x != surround[x]:\\n                surround[x] = find(surround[x])\\n            return surround[x]\\n        \\n        # when union, choose larger node, that\\'s the reason I choose {n*m:n*m} represent touching border node\\n        def union(a,b):\\n            rootA = find(a)\\n            rootB = find(b)\\n            if rootA > rootB:\\n                surround[rootB] = rootA\\n            elif rootA < rootB:\\n                surround[rootA] = rootB\\n            \\n        if not board:\\n            return []\\n        \\n        n = len(board)\\n        m = len(board[0])\\n        \\n        # {n*m:n*m} means touching border node\\n        surround = {i:i for i in range(n*m+1)}\\n        \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \\'O\\':\\n                    # find touching border node\\n                    if i in [0,n-1] or j in [0,m-1]:\\n                        surround[i*m+j] = n*m \\n                    # union with the previous node: board[i-1][j],board[i][j-1]\\n                    if i-1>=0 and board[i-1][j] == \\'O\\':\\n                        union((i-1)*m+j,i*m+j)\\n                    if j-1>=0 and board[i][j-1] == \\'O\\':\\n                        union(i*m+j-1,i*m+j)\\n                        \\n        for i in range(n):\\n            for j in range(m):\\n                # if root of node is not the touching border node,set to \\'X\\'\\n                if find(i*m+j)!=n*m:\\n                    board[i][j] = \\'X\\'\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Union Find"
                ],
                "code": "```python\\n    def solve(self, board: List[List[str]]) -> None:\\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \\'O\\' and (i in [0,len(board)-1] or j in [0,len(board[0])-1]):\\n                    DFS(i,j) # or BFS(i,j)\\n                    \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \\'O\\':\\n                    board[i][j] = \\'X\\'\\n                if board[i][j] == \\'D\\':\\n                    board[i][j] = \\'O\\'\\n```\n```python\\n        def DFS(i,j):\\n            if 0<=i<len(board) and 0<=j<len(board[0]) and board[i][j] == \\'O\\':\\n                board[i][j] = \\'D\\'\\n                DFS(i+1,j)\\n                DFS(i-1,j)\\n                DFS(i,j+1)\\n                DFS(i,j-1)\\n```\n```python\\n        def BFS(i,j):\\n            level = [(i,j)]\\n            while level:\\n                temp = []\\n                for i,j in level: \\n                    if 0<=i<len(board) and 0<=j<len(board[0]) and board[i][j] == \\'O\\':\\n                        board[i][j] = \\'D\\'\\n                        temp += [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]\\n                level = temp\\n```\n```python\\n        def DFS(i,j):\\n            queue = collections.deque([(i,j)])\\n            while queue:\\n                i,j = queue.pop()\\n                if 0<=i<len(board) and 0<=j<len(board[0]) and board[i][j] == \\'O\\':\\n                    board[i][j] = \\'D\\'\\n                    queue += [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]      \\n```\n```python\\n        def BFS(i,j):\\n            queue = collections.deque([(i,j)])\\n            while queue:\\n                i,j = queue.popleft()\\n                if 0<=i<len(board) and 0<=j<len(board[0]) and board[i][j] == \\'O\\':\\n                    board[i][j] = \\'D\\'\\n                    queue += [(i+1,j),(i-1,j),(i,j+1),(i,j-1)]\\n```\n```python\\n    def solve(self, board: List[List[str]]) -> None:\\n        # iterate cause TLE\\n        # def find(x):\\n        #     while x!=surround[x]:\\n        #         x = surround[x]\\n        #     return x\\n        \\n        def find(x):\\n            if x != surround[x]:\\n                surround[x] = find(surround[x])\\n            return surround[x]\\n        \\n        # when union, choose larger node, that\\'s the reason I choose {n*m:n*m} represent touching border node\\n        def union(a,b):\\n            rootA = find(a)\\n            rootB = find(b)\\n            if rootA > rootB:\\n                surround[rootB] = rootA\\n            elif rootA < rootB:\\n                surround[rootA] = rootB\\n            \\n        if not board:\\n            return []\\n        \\n        n = len(board)\\n        m = len(board[0])\\n        \\n        # {n*m:n*m} means touching border node\\n        surround = {i:i for i in range(n*m+1)}\\n        \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \\'O\\':\\n                    # find touching border node\\n                    if i in [0,n-1] or j in [0,m-1]:\\n                        surround[i*m+j] = n*m \\n                    # union with the previous node: board[i-1][j],board[i][j-1]\\n                    if i-1>=0 and board[i-1][j] == \\'O\\':\\n                        union((i-1)*m+j,i*m+j)\\n                    if j-1>=0 and board[i][j-1] == \\'O\\':\\n                        union(i*m+j-1,i*m+j)\\n                        \\n        for i in range(n):\\n            for j in range(m):\\n                # if root of node is not the touching border node,set to \\'X\\'\\n                if find(i*m+j)!=n*m:\\n                    board[i][j] = \\'X\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 558746,
                "title": "python-dfs-easy-solution-with-comments",
                "content": "```\\nclass Solution:\\n    \\n    def dfs(self,board,i,j):\\n            \\n        if i<0 or j<0 or i>=len(board) or j>=len(board[0]) or board[i][j]!=\\'O\\':\\n            return\\n        board[i][j]=\\'$\\'  # converting to  a dollar sign \\n            \\n        self.dfs(board,i+1,j)\\n        self.dfs(board,i-1,j)\\n        self.dfs(board,i,j+1)\\n        self.dfs(board,i,j-1)\\n        \\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        if len(board)==0:\\n            return None\\n        \\n        m=len(board)\\n        n=len(board[0])\\n        \\n        \\n        for i in range(m):  # call dfs on all border \\'O\\'s and turn them to \\'$\\'\\n            for j in range(n):\\n                if i==0 or i==m-1:\\n                    self.dfs(board,i,j)\\n                        \\n                if j==0 or j==n-1:\\n                    self.dfs(board,i,j)\\n                    \\n        \\n   \\n#all border O and others connected them were already converted to $ sign \\n#so left out zeros are surely surrounded by \\'X\\' . Turn all of them to \\'X\\'\\n        for i in range(m):   \\n            for j in range(n):\\n                if board[i][j]==\\'O\\':\\n                    board[i][j]=\\'X\\'\\n        \\n# turn the border zeros and their adjacents to their initial form. ie $ -> O \\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j]==\\'$\\':\\n                    board[i][j]=\\'O\\'\\n        \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def dfs(self,board,i,j):\\n            \\n        if i<0 or j<0 or i>=len(board) or j>=len(board[0]) or board[i][j]!=\\'O\\':\\n            return\\n        board[i][j]=\\'$\\'  # converting to  a dollar sign \\n            \\n        self.dfs(board,i+1,j)\\n        self.dfs(board,i-1,j)\\n        self.dfs(board,i,j+1)\\n        self.dfs(board,i,j-1)\\n        \\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        if len(board)==0:\\n            return None\\n        \\n        m=len(board)\\n        n=len(board[0])\\n        \\n        \\n        for i in range(m):  # call dfs on all border \\'O\\'s and turn them to \\'$\\'\\n            for j in range(n):\\n                if i==0 or i==m-1:\\n                    self.dfs(board,i,j)\\n                        \\n                if j==0 or j==n-1:\\n                    self.dfs(board,i,j)\\n                    \\n        \\n   \\n#all border O and others connected them were already converted to $ sign \\n#so left out zeros are surely surrounded by \\'X\\' . Turn all of them to \\'X\\'\\n        for i in range(m):   \\n            for j in range(n):\\n                if board[i][j]==\\'O\\':\\n                    board[i][j]=\\'X\\'\\n        \\n# turn the border zeros and their adjacents to their initial form. ie $ -> O \\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j]==\\'$\\':\\n                    board[i][j]=\\'O\\'\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 41886,
                "title": "c-solution-inspired-from-the-game-of-i-go-20ms",
                "content": "I guess this question is inspired from Chinese traditional sport\\u2014I-go. Here the task is to flip all the dead pieces. \\n\\nMy solution is common: perform BFS from live pieces('O') on the edges and mark the live pieces with temporary state '+'. After BFS done, scan the whole board to flip remaining 'O' (dead) cells and recover live pieces('+') to 'O'.\\n    \\n    class Solution {\\n    public:\\n        int row;\\n        int col;\\n        vector<pair<int, int> > move_step; \\n    \\n        void bfs(vector<vector<char> > &board, int r, int c) {\\n            queue<pair<int, int> > qe;\\n            qe.push({r, c});\\n    \\n            while(!qe.empty()) {        \\n                r = qe.front().first;\\n                c = qe.front().second;\\n                qe.pop();\\n                for(int i = 0; i < 4; i++) {\\n                    int rr = r + move_step[i].first;\\n                    int cc = c + move_step[i].second; \\n                    if(rr >= 0 && rr < row\\n                            && cc >= 0 && cc < col\\n                             && board[rr][cc] == 'O') {\\n                        board[rr][cc] = '+';\\n                        qe.push({rr, cc});\\n                    }\\n                }\\n            }\\n    \\n            return;\\n        }\\n    \\n        void solve(vector<vector<char> > &board) {\\n            if (board.empty())\\n                return;\\n                                             \\n            row = board.size();        \\n            col = board[0].size();        \\n    \\n            move_step.resize(4);\\n            move_step[0] = {0,-1};\\n            move_step[1] = {0,1};\\n            move_step[2] = {-1,0};\\n            move_step[3] = {1,0};\\n    \\n            // BFS from four edges and mark  non-surrounded(dead) cells with '+' sign\\n            \\n            // top edge\\n            for(int i = 0; i < col; i++) {\\n                if(board[0][i] == 'O') {\\n                    board[0][i] = '+';\\n                    bfs(board, 0, i);\\n                }\\n            }\\n    \\n            // bottom edge\\n            for(int i = 0; i < col; i++) {\\n                if(board[row-1][i] == 'O') {\\n                    board[row-1][i] = '+';\\n                    bfs(board, row-1, i);\\n                }\\n            }\\n            \\n            // left edge\\n            for(int i = 1; i < row-1; i++) {\\n                if(board[i][0] == 'O') {\\n                    board[i][0] = '+';\\n                    bfs(board, i, 0);\\n                }\\n            }\\n    \\n            // right edge\\n            for(int i = 1; i < row-1; i++) {\\n                if(board[i][col-1] == 'O') {\\n                    board[i][col-1] = '+';\\n                    bfs(board, i, col-1);\\n                }\\n            }\\n            \\n            // then scan all the cells, recover live cells and flip dead cells \\n            for(int i = 0; i < row; i++) \\n                for(int j = 0; j < col; j++) {\\n                    char cur = board[i][j];\\n                    // recover live cell marked with '+' to 'O'\\n                    if(cur == '+') \\n                        board[i][j] = 'O';\\n                    // flip dead cell to '*'\\n                    else if(cur == 'O') \\n                        board[i][j] = 'X';\\n                }\\n    \\n            return;\\n        }\\n    };",
                "solutionTags": [
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "class Solution {\\n    public:\\n        int row;\\n        int col;\\n        vector<pair<int, int> > move_step; \\n    \\n        void bfs(vector<vector<char> > &board, int r, int c) {\\n            queue<pair<int, int> > qe;\\n            qe.push({r, c}",
                "codeTag": "Java"
            },
            {
                "id": 1552379,
                "title": "surrounded-region-99-faster",
                "content": "<h1><b>130. Surrounded Regions</b></h1><hr>\\n\\n\\nHi coders \\uD83D\\uDC4B,<br>\\n\\n\\uD83C\\uDFC6  &nbsp; &nbsp; &nbsp; Runtime: 8 ms, faster than **98.69%**\\n&nbsp; &nbsp; &nbsp; Memory Usage: 10 MB, less than **79.51%** <br>\\n\\uD83E\\uDDE0 APPROACH :\\n\\t\\t\\u25B6  &nbsp; Traverse the given board and replace all \\u2018O\\u2019 with a special character \\u2018-\\u2018 \\n\\t\\t\\u25B6  &nbsp;Traverse four edges of the given board and call **dfs** for every \\u2018-\\u2018 on edges. \\n\\t\\t&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The remaining \\u2018-\\u2018 are the characters that indicate \\u2018O\\u2019s (in the original board) to be replaced by \\u2018X\\u2019.\\n\\t\\t\\u25B6  &nbsp;Traverse the board and replace all \\u2018-\\u2018s with \\u2018X\\u2019s.\\n\\t\\t<br>\\n```\\nclass Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(vector<vector<char>>& board, int i, int j)\\n\\t\\t{   \\n\\t\\t\\tif(board[i][j] == \\'O\\'){\\n\\t\\t\\t\\tboard[i][j] = \\'1\\';\\n\\t\\t\\t\\tif(i+1 < board.size()) dfs(board, i+1, j);\\n\\t\\t\\t\\tif(i > 1) dfs(board, i-1, j);\\n\\t\\t\\t\\tif(j+1 < board[i].size()) dfs(board, i, j+1);\\n\\t\\t\\t\\tif(j > 1) dfs(board, i, j-1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvoid solve(vector<vector<char>>& board) {\\n\\t\\t\\tif(board.size() == 0)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tint row = board.size(), col = board[0].size();\\n\\t\\n\\t\\t\\t// traversing through first row and last row\\n\\t\\t\\tfor(int i=0; i<row; i++){\\n\\t\\t\\t\\tdfs(board, i, 0);\\n\\t\\t\\t\\tdfs(board, i, col-1);\\n\\t\\t\\t}\\n\\t\\t\\t//traversing through first col and last col\\n\\t\\t\\tfor(int j=1; j<col-1; j++){\\n\\t\\t\\t\\tdfs(board, 0, j);\\n\\t\\t\\t\\tdfs(board, row-1, j);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tfor (int i = 0; i < row; ++i)\\n\\t\\t\\t\\tfor (int j = 0; j < col; ++j)\\n\\t\\t\\t\\t\\tif (board[i][j] == \\'O\\') board[i][j] = \\'X\\';\\n\\t\\t\\t\\t\\telse if (board[i][j] == \\'1\\') board[i][j] = \\'O\\';\\n\\t\\t}\\n\\t\\t// came so far \\n\\t\\t// Please Upvote :-)\\n};\\n```\\n<hr><br>\\n\\n  \\u2705  &nbsp; &nbsp; &nbsp;Runtime: 8 ms, faster than *98.69%*\\n\\t\\t  &nbsp; &nbsp; &nbsp; Memory Usage: 15.7 MB, less than *10.51%*\\n\\t\\t<br>\\uD83E\\uDDE0 APPROACH :\\n\\t\\t\\u25B6  &nbsp;Here we will use a global seen variable to check if give region is connected to any boundary O\\u2019s\\n\\t\\t\\u25B6  &nbsp;If Not connected mark all O\\u2019s with X\\u2019s\\n\\t\\t<br>\\t\\t\\n```\\nclass Solution {\\n    bool seen; \\n    void mark(vector<vector<char>>& board,int i,int j,int r,int c)\\n    {\\n        if(i<0 || i>r-1 || j<0 || j>c-1)\\n            return;\\n        if(board[i][j]==\\'X\\')\\n            return;\\n        \\n        board[i][j] = \\'X\\';\\n        mark(board,i-1,j,r,c);\\n        mark(board,i+1,j,r,c);\\n        mark(board,i,j-1,r,c);\\n        mark(board,i,j+1,r,c);       \\n    }\\n    void dfs(vector<vector<char>>& board,int i,int j,int r,int c,vector<vector<bool>>& visited)\\n    {\\n        if(i<0 || i>r-1 || j<0 || j>c-1) // checking for boundary conditions\\n            return;\\n        \\n        if(board[i][j]==\\'X\\' || visited[i][j]) \\n            return;\\n        if(i<=0 || i>=r-1 || j<=0 || j>=c-1) // if it is a boundary element mark seen as true\\n            seen = true;\\n        \\n        visited[i][j] = true;\\n        dfs(board,i-1,j,r,c,visited);\\n        dfs(board,i+1,j,r,c,visited);\\n        dfs(board,i,j-1,r,c,visited);\\n        dfs(board,i,j+1,r,c,visited);\\n    }\\npublic:\\n    void solve(vector<vector<char>>& board) {       \\n        int r=board.size();\\n        if(r<=1)\\n            return;\\n        int c=board[0].size();\\n        if(c<=1)\\n            return;\\n        vector<vector<bool>> visited(r,vector<bool>(c,false));\\n        \\n        for(int i=1;i<r-1;++i) // *r-1* and *c-1*  : as we are not checking the boundary elements\\n        {\\n            for(int j=1;j<c-1;++j)\\n            {\\n                if(board[i][j]==\\'O\\' && !visited[i][j])\\n                {\\n                    seen = false; // on every iteration seen is made False\\n                    dfs(board,i,j,r,c,visited);\\n                    if(seen==false)\\n                        mark(board,i,j,r,c); \\n                    seen = true;\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(vector<vector<char>>& board, int i, int j)\\n\\t\\t{   \\n\\t\\t\\tif(board[i][j] == \\'O\\'){\\n\\t\\t\\t\\tboard[i][j] = \\'1\\';\\n\\t\\t\\t\\tif(i+1 < board.size()) dfs(board, i+1, j);\\n\\t\\t\\t\\tif(i > 1) dfs(board, i-1, j);\\n\\t\\t\\t\\tif(j+1 < board[i].size()) dfs(board, i, j+1);\\n\\t\\t\\t\\tif(j > 1) dfs(board, i, j-1);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tvoid solve(vector<vector<char>>& board) {\\n\\t\\t\\tif(board.size() == 0)\\n\\t\\t\\t\\treturn;\\n\\t\\t\\tint row = board.size(), col = board[0].size();\\n\\t\\n\\t\\t\\t// traversing through first row and last row\\n\\t\\t\\tfor(int i=0; i<row; i++){\\n\\t\\t\\t\\tdfs(board, i, 0);\\n\\t\\t\\t\\tdfs(board, i, col-1);\\n\\t\\t\\t}\\n\\t\\t\\t//traversing through first col and last col\\n\\t\\t\\tfor(int j=1; j<col-1; j++){\\n\\t\\t\\t\\tdfs(board, 0, j);\\n\\t\\t\\t\\tdfs(board, row-1, j);\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tfor (int i = 0; i < row; ++i)\\n\\t\\t\\t\\tfor (int j = 0; j < col; ++j)\\n\\t\\t\\t\\t\\tif (board[i][j] == \\'O\\') board[i][j] = \\'X\\';\\n\\t\\t\\t\\t\\telse if (board[i][j] == \\'1\\') board[i][j] = \\'O\\';\\n\\t\\t}\\n\\t\\t// came so far \\n\\t\\t// Please Upvote :-)\\n};\\n```\n```\\nclass Solution {\\n    bool seen; \\n    void mark(vector<vector<char>>& board,int i,int j,int r,int c)\\n    {\\n        if(i<0 || i>r-1 || j<0 || j>c-1)\\n            return;\\n        if(board[i][j]==\\'X\\')\\n            return;\\n        \\n        board[i][j] = \\'X\\';\\n        mark(board,i-1,j,r,c);\\n        mark(board,i+1,j,r,c);\\n        mark(board,i,j-1,r,c);\\n        mark(board,i,j+1,r,c);       \\n    }\\n    void dfs(vector<vector<char>>& board,int i,int j,int r,int c,vector<vector<bool>>& visited)\\n    {\\n        if(i<0 || i>r-1 || j<0 || j>c-1) // checking for boundary conditions\\n            return;\\n        \\n        if(board[i][j]==\\'X\\' || visited[i][j]) \\n            return;\\n        if(i<=0 || i>=r-1 || j<=0 || j>=c-1) // if it is a boundary element mark seen as true\\n            seen = true;\\n        \\n        visited[i][j] = true;\\n        dfs(board,i-1,j,r,c,visited);\\n        dfs(board,i+1,j,r,c,visited);\\n        dfs(board,i,j-1,r,c,visited);\\n        dfs(board,i,j+1,r,c,visited);\\n    }\\npublic:\\n    void solve(vector<vector<char>>& board) {       \\n        int r=board.size();\\n        if(r<=1)\\n            return;\\n        int c=board[0].size();\\n        if(c<=1)\\n            return;\\n        vector<vector<bool>> visited(r,vector<bool>(c,false));\\n        \\n        for(int i=1;i<r-1;++i) // *r-1* and *c-1*  : as we are not checking the boundary elements\\n        {\\n            for(int j=1;j<c-1;++j)\\n            {\\n                if(board[i][j]==\\'O\\' && !visited[i][j])\\n                {\\n                    seen = false; // on every iteration seen is made False\\n                    dfs(board,i,j,r,c,visited);\\n                    if(seen==false)\\n                        mark(board,i,j,r,c); \\n                    seen = true;\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1935366,
                "title": "100-fastest-swift-solution",
                "content": "```\\nclass Solution {\\n    func solve(_ board: inout [[Character]]) {\\n        let row = board.count\\n        let col = board[0].count\\n        var map = Array(repeating: Array(repeating: 0, count: col) , count: row)\\n        //  1...n\\n        var index = 1\\n        var indexs: [Int] = []\\n        \\n        for i in 0..<row {\\n            for j in 0..<col where board[i][j] == \"O\" && map[i][j] < 1 {\\n                markRegion(i, j, board, &map, index, &indexs)\\n                index += 1\\n            } \\n        }\\n        \\n        for i in 0..<row {\\n            for j in 0..<col where map[i][j] > 0 && indexs.contains(map[i][j]) == false { board[i][j] = \"X\" }\\n        }\\n    }\\n    \\n\\n    func markRegion(_ i: Int, _ j: Int, _ board: [[Character]], _ map: inout [[Int]], _ index: Int, _ indexs: inout [Int]) {\\n        let row = board.count\\n        let col = board[0].count\\n        \\n        if i >= 0 && i < row && j >= 0 && j < col {\\n            if board[i][j] == \"O\" && map[i][j] == 0 {\\n                map[i][j] = index\\n                markRegion(i + 1, j, board, &map, index, &indexs)\\n                markRegion(i - 1, j, board, &map, index, &indexs)\\n                markRegion(i, j - 1, board, &map, index, &indexs)\\n                markRegion(i, j + 1, board, &map, index, &indexs) \\n            }\\n            \\n        } else {\\n            indexs.append(index)\\n        }\\n    }\\n    \\n}\\n```\\n\\nLet me know in comments if you have any doubts. I will be happy to answer.\\n\\nPlease upvote if you found the solution useful.",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func solve(_ board: inout [[Character]]) {\\n        let row = board.count\\n        let col = board[0].count\\n        var map = Array(repeating: Array(repeating: 0, count: col) , count: row)\\n        //  1...n\\n        var index = 1\\n        var indexs: [Int] = []\\n        \\n        for i in 0..<row {\\n            for j in 0..<col where board[i][j] == \"O\" && map[i][j] < 1 {\\n                markRegion(i, j, board, &map, index, &indexs)\\n                index += 1\\n            } \\n        }\\n        \\n        for i in 0..<row {\\n            for j in 0..<col where map[i][j] > 0 && indexs.contains(map[i][j]) == false { board[i][j] = \"X\" }\\n        }\\n    }\\n    \\n\\n    func markRegion(_ i: Int, _ j: Int, _ board: [[Character]], _ map: inout [[Int]], _ index: Int, _ indexs: inout [Int]) {\\n        let row = board.count\\n        let col = board[0].count\\n        \\n        if i >= 0 && i < row && j >= 0 && j < col {\\n            if board[i][j] == \"O\" && map[i][j] == 0 {\\n                map[i][j] = index\\n                markRegion(i + 1, j, board, &map, index, &indexs)\\n                markRegion(i - 1, j, board, &map, index, &indexs)\\n                markRegion(i, j - 1, board, &map, index, &indexs)\\n                markRegion(i, j + 1, board, &map, index, &indexs) \\n            }\\n            \\n        } else {\\n            indexs.append(index)\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1491614,
                "title": "python-dfs-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: BFS**\\n```python\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        m, n = len(board), len(board[0])\\n        DIR = [0, 1, 0, -1, 0]\\n        protected = [[False] * n for _ in range(m)]\\n\\n        def dfs(r, c):\\n            if r < 0 or r == m or c < 0 or c == n or board[r][c] == \"X\" or protected[r][c]:\\n                return\\n\\n            protected[r][c] = True\\n            for i in range(4):\\n                dfs(r + DIR[i], c + DIR[i + 1])\\n\\n        for r in range(m):\\n            dfs(r, 0)\\n            dfs(r, n - 1)\\n\\n        for c in range(n):\\n            dfs(0, c)\\n            dfs(m - 1, c)\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if board[r][c] == \"O\" and not protected[r][c]:\\n                    board[r][c] = \"X\"\\n```\\nComplexity:\\n- Time: `O(M*N)`, where `M <= 200` is number of rows, `N <= 200` is number of columns in the board.\\n- Space: `O(M*N)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        m, n = len(board), len(board[0])\\n        DIR = [0, 1, 0, -1, 0]\\n        protected = [[False] * n for _ in range(m)]\\n\\n        def dfs(r, c):\\n            if r < 0 or r == m or c < 0 or c == n or board[r][c] == \"X\" or protected[r][c]:\\n                return\\n\\n            protected[r][c] = True\\n            for i in range(4):\\n                dfs(r + DIR[i], c + DIR[i + 1])\\n\\n        for r in range(m):\\n            dfs(r, 0)\\n            dfs(r, n - 1)\\n\\n        for c in range(n):\\n            dfs(0, c)\\n            dfs(m - 1, c)\\n\\n        for r in range(m):\\n            for c in range(n):\\n                if board[r][c] == \"O\" and not protected[r][c]:\\n                    board[r][c] = \"X\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 196152,
                "title": "python-beats-98-easy-to-understand-dfs-solution",
                "content": "Use \"N\" to mark all \"O\"s linked to boundary \"O\"s.\\n```\\nclass Solution(object):\\n    def solve(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: void Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        if not board: return\\n        m, n = len(board), len(board[0])\\n        \\n        def fillN(i, j):\\n            if 0<=i<m and 0<=j<n and board[i][j] == \"O\":\\n                board[i][j] = \"N\"\\n                fillN(i+1, j)\\n                fillN(i-1, j)\\n                fillN(i, j+1)\\n                fillN(i, j-1)\\n            \\n        for i in range(m):\\n            if board[i][0] == \"O\": fillN(i,0)\\n            if board[i][n-1] == \"O\": fillN(i,n-1)        \\n        for j in range(n):\\n            if board[0][j] == \"O\": fillN(0,j)\\n            if board[m-1][j] == \"O\": fillN(m-1,j)\\n                \\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] != \"N\": board[i][j] = \"X\"\\n                else: board[i][j] = \"O\"\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def solve(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: void Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        if not board: return\\n        m, n = len(board), len(board[0])\\n        \\n        def fillN(i, j):\\n            if 0<=i<m and 0<=j<n and board[i][j] == \"O\":\\n                board[i][j] = \"N\"\\n                fillN(i+1, j)\\n                fillN(i-1, j)\\n                fillN(i, j+1)\\n                fillN(i, j-1)\\n            \\n        for i in range(m):\\n            if board[i][0] == \"O\": fillN(i,0)\\n            if board[i][n-1] == \"O\": fillN(i,n-1)        \\n        for j in range(n):\\n            if board[0][j] == \"O\": fillN(0,j)\\n            if board[m-1][j] == \"O\": fillN(m-1,j)\\n                \\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] != \"N\": board[i][j] = \"X\"\\n                else: board[i][j] = \"O\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41795,
                "title": "20-ms-c-recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "As far as I am concerned, after knowing about the BFS, it is all about details to use deque to do the BFS.\\n\\nthe idea is simple and the implementation is concise \\n\\n\\n    class Solution {\\n    public:\\n        void solve(vector<vector<char>>& board) {\\n            if(board.size()<=1 || board[0].size()<=1) return;\\n            \\n            int m=board.size(), n=board[0].size();\\n            deque<pair<int, int>> q;\\n            for(int i=0; i<n; i++){\\n                if(board[0][i]=='O')   q.push_back(make_pair(0, i));\\n                if(board[m-1][i]=='O') q.push_back(make_pair(m-1, i));\\n            }\\n            for(int i=1; i<m-1; i++){\\n                if(board[i][0]=='O')   q.push_back(make_pair(i, 0));\\n                if(board[i][n-1]=='O') q.push_back(make_pair(i, n-1));\\n            }\\n            \\n            while(!q.empty()){\\n                pair<int, int> temp=q.front();\\n                q.pop_front();\\n                board[temp.first][temp.second]='N';\\n                \\n                if(temp.first-1>=0 && board[temp.first-1][temp.second]=='O'){\\n                    q.push_back(make_pair(temp.first-1, temp.second));\\n                }\\n                if(temp.first+1<m && board[temp.first+1][temp.second]=='O'){\\n                    q.push_back(make_pair(temp.first+1, temp.second));\\n                }\\n                \\n                if(temp.second-1>=0 && board[temp.first][temp.second-1]=='O'){\\n                    q.push_back(make_pair(temp.first, temp.second-1));\\n                }\\n                if(temp.second+1<n && board[temp.first][temp.second+1]=='O'){\\n                    q.push_back(make_pair(temp.first, temp.second+1));\\n                }\\n            }\\n            \\n            for(int i=0; i<m; i++){\\n                for(int j=0; j<n; j++){\\n                    if(board[i][j]=='N')   board[i][j]='O';\\n                    else if(board[i][j]=='O')   board[i][j]='X';\\n                }\\n            }\\n            \\n            return;\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void solve(vector<vector<char>>& board) {\\n            if(board.size()<=1 || board[0].size()<=1) return;\\n            \\n            int m=board.size(), n=board[0].size();\\n            deque<pair<int, int>> q;\\n            for(int i=0; i<n; i++){\\n                if(board[0][i]=='O')   q.push_back(make_pair(0, i));\\n                if(board[m-1][i]=='O') q.push_back(make_pair(m-1, i));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 812540,
                "title": "simple-easy-java-solution-using-dfs-1ms-99-beats",
                "content": "class Solution {\\n    public void solve(char[][] board) {\\n        \\n        if(board.length==0)\\n            return;\\n        \\n        // this for loop handles all boundary condition in 1st & last row.\\n        for(int i=0; i<board[0].length ;i++){\\n            if(board[0][i]==\\'O\\')\\n                DFS(board, 0, i);\\n            if(board[board.length-1][i]==\\'O\\')\\n                DFS(board, board.length-1, i);\\n            \\n        }\\n        \\n        // this for loop handles all boundary condition in 1st & last col.\\n         for(int i=0; i<board.length ;i++){\\n            if(board[i][0]==\\'O\\')\\n                DFS(board, i, 0);\\n            if(board[i][board[0].length-1]==\\'O\\')\\n                DFS(board, i, board[0].length-1);\\n            \\n        }\\n                \\n        for(int i=0; i<board.length; i++){\\n            for(int j=0; j<board[0].length; j++){\\n                \\n               if(board[i][j]==\\'O\\')\\n                   board[i][j]=\\'X\\';\\n                \\n                if(board[i][j]==\\'#\\')\\n                    board[i][j]=\\'O\\';\\n            }\\n        }\\n    }\\n    \\n    private void DFS(char[][]board, int i, int j){\\n        \\n        if(i<0 || j<0 || i>=board.length || j>=board[0].length || board[i][j]!=\\'O\\')\\n                return;\\n       \\n        board[i][j]= \\'#\\';\\n            \\n        DFS(board, i+1, j);\\n        DFS(board, i-1, j);\\n        DFS(board, i, j-1);\\n        DFS(board, i, j+1);\\n        }\\n    }\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    public void solve(char[][] board) {\\n        \\n        if(board.length==0)\\n            return;\\n        \\n        // this for loop handles all boundary condition in 1st & last row.\\n        for(int i=0; i<board[0].length ;i++){\\n            if(board[0][i]==\\'O\\')\\n                DFS(board, 0, i);\\n            if(board[board.length-1][i]==\\'O\\')\\n                DFS(board, board.length-1, i);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 691619,
                "title": "python-recursion",
                "content": "First mark the `not surrounded` ones as `\\'\\'`. These will be assigned to `O`. The rest become `X`\\n\\n```\\nclass Solution:\\n    def mark_border(self, i, j, board):\\n        if i==-1 or i==len(board):\\n            return\\n        if j==-1 or j==len(board[0]):\\n            return\\n        if board[i][j]==\\'O\\':\\n            board[i][j]=\\'\\'\\n            self.mark_border(i-1, j, board)\\n            self.mark_border(i+1, j, board)\\n            self.mark_border(i, j-1, board)\\n            self.mark_border(i, j+1, board)\\n        \\n    \\n    def solve(self, board):\\n        if not board or not board[0]:\\n            return []\\n        \\n        M, N = len(board), len(board[0])\\n        for i in range(M):\\n            self.mark_border(i, 0, board)\\n            self.mark_border(i, N-1, board)\\n        for j in range(N):\\n            self.mark_border(0, j, board)\\n            self.mark_border(M-1, j, board)\\n        \\n        for i in range(M):\\n            for j in range(N):\\n                if board[i][j]==\\'\\':\\n                    board[i][j]=\\'O\\'\\n                elif board[i][j]==\\'O\\':\\n                    board[i][j]=\\'X\\'\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def mark_border(self, i, j, board):\\n        if i==-1 or i==len(board):\\n            return\\n        if j==-1 or j==len(board[0]):\\n            return\\n        if board[i][j]==\\'O\\':\\n            board[i][j]=\\'\\'\\n            self.mark_border(i-1, j, board)\\n            self.mark_border(i+1, j, board)\\n            self.mark_border(i, j-1, board)\\n            self.mark_border(i, j+1, board)\\n        \\n    \\n    def solve(self, board):\\n        if not board or not board[0]:\\n            return []\\n        \\n        M, N = len(board), len(board[0])\\n        for i in range(M):\\n            self.mark_border(i, 0, board)\\n            self.mark_border(i, N-1, board)\\n        for j in range(N):\\n            self.mark_border(0, j, board)\\n            self.mark_border(M-1, j, board)\\n        \\n        for i in range(M):\\n            for j in range(N):\\n                if board[i][j]==\\'\\':\\n                    board[i][j]=\\'O\\'\\n                elif board[i][j]==\\'O\\':\\n                    board[i][j]=\\'X\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691602,
                "title": "java-1ms-simple",
                "content": "```\\nclass Solution {\\n    \\n    public void solve(char[][] board) {\\n        if(board.length == 0) return;\\n        boolean[][] visited;\\n        visited = new boolean[board.length][board[0].length];\\n        \\n        for(int i=0;i<board.length;i++) {   // Run dfs on left and right borders and change \\'0\\'s to \\'#\\'\\n            dfs(board, i, 0, visited);\\n            dfs(board, i, board[0].length-1, visited);\\n        }\\n        \\n        for(int j=1;j<board[0].length-1;j++) { // Run dfs on top and bottom borders and change \\'0\\'s to \\'#\\'\\n            dfs(board, 0, j, visited);\\n            dfs(board, board.length-1, j, visited);\\n        }\\n        \\n        for(int i=0;i<board.length;i++) \\n            for(int j=0;j<board[0].length;j++) \\n                if(board[i][j] == \\'O\\')      // Change surrounded \\'0\\' to \\'X\\'\\n                    board[i][j] = \\'X\\';\\n                else if(board[i][j] == \\'#\\')    // Change \\'#\\' (not surrounded) back to \\'0\\'\\n                    board[i][j] = \\'O\\';\\n    }\\n    \\n    public void dfs(char[][] board,int i,int j,boolean[][] visited) {\\n        if(i>=0 && i < board.length && j>=0 && j<board[0].length && !visited[i][j] && board[i][j] == \\'O\\') {\\n            visited[i][j] = true;\\n            board[i][j] = \\'#\\';\\n            dfs(board,i+1,j,visited);\\n            dfs(board,i-1,j,visited);\\n            dfs(board,i,j+1,visited);\\n            dfs(board,i,j-1,visited);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public void solve(char[][] board) {\\n        if(board.length == 0) return;\\n        boolean[][] visited;\\n        visited = new boolean[board.length][board[0].length];\\n        \\n        for(int i=0;i<board.length;i++) {   // Run dfs on left and right borders and change \\'0\\'s to \\'#\\'\\n            dfs(board, i, 0, visited);\\n            dfs(board, i, board[0].length-1, visited);\\n        }\\n        \\n        for(int j=1;j<board[0].length-1;j++) { // Run dfs on top and bottom borders and change \\'0\\'s to \\'#\\'\\n            dfs(board, 0, j, visited);\\n            dfs(board, board.length-1, j, visited);\\n        }\\n        \\n        for(int i=0;i<board.length;i++) \\n            for(int j=0;j<board[0].length;j++) \\n                if(board[i][j] == \\'O\\')      // Change surrounded \\'0\\' to \\'X\\'\\n                    board[i][j] = \\'X\\';\\n                else if(board[i][j] == \\'#\\')    // Change \\'#\\' (not surrounded) back to \\'0\\'\\n                    board[i][j] = \\'O\\';\\n    }\\n    \\n    public void dfs(char[][] board,int i,int j,boolean[][] visited) {\\n        if(i>=0 && i < board.length && j>=0 && j<board[0].length && !visited[i][j] && board[i][j] == \\'O\\') {\\n            visited[i][j] = true;\\n            board[i][j] = \\'#\\';\\n            dfs(board,i+1,j,visited);\\n            dfs(board,i-1,j,visited);\\n            dfs(board,i,j+1,visited);\\n            dfs(board,i,j-1,visited);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41686,
                "title": "5ms-simple-dfs-java-solution",
                "content": "This problem can be dealt with in a very simple way. A 'O' will not be surrounded by all sides only if it is linked (directly or through another 'O') to a 'O' that is on the boundary row or column.\\n\\nThis means that if all 4 boundaries have only 'X' then all the characters can be switched to 'X' \\n\\nFor example if your region is defined like this\\n\\nXXXX\\nXOOX\\nXOOX\\nXXXX  then we can convert all the 'O' to'X's .\\n\\nSolution: Run through the boundaries and perform dfs when you come across a 'O' . Switch all adjoining 'O' to another character. (I have chosen to switch them to 'Y'). This way all th e'O's that are not surrounded completely by 'X' are switched to 'Y's .\\n\\nAfter simply run through the matrix again and switch all 'Y' to 'O' and all 'O' to 'X'.\\n\\n\\n```\\npublic class Solution {\\n    \\n    public void solve(char[][] board) {\\n        \\n        if(board==null || board.length==0) return;\\n        \\n        int row = board.length;\\n        int col = board[0].length;\\n        \\n        //check first and last col\\n        for(int i=0;i<row;i++){\\n            \\n            if(board[i][0]=='O') getEmAll(board,i,1);\\n            if(board[i][col-1]=='O') getEmAll(board,i,col-2);\\n        }\\n        \\n        //check first and last  row\\n        for(int i=0;i<col;i++){\\n            \\n            if(board[0][i]=='O') getEmAll(board,1,i);\\n            if(board[row-1][i]=='O') getEmAll(board,row-2,i);\\n        }\\n        \\n\\n       //Switch all 'O's to 'X's and 'Y's to 'O's\\n        for(int i=1;i<row-1;i++)\\n        {\\n            for(int j=1;j<col-1;j++)\\n                 if(board[i][j]=='Y') board[i][j]='O';\\n                 else if(board[i][j]=='O') board[i][j]='X';\\n        }\\n\\t}\\n\\t    \\n\\tpublic void getEmAll(char[][] board, int row, int col){\\n\\t    \\n\\t    if(row>=board.length-1 || row<=0 || col>=board[0].length-1 || col<=0) return;\\n\\t    \\n\\t    if(board[row][col]=='X' || board[row][col]=='Y') return;\\n\\t    if(board[row][col]=='O') board[row][col]='Y';\\n\\t    \\n\\t    getEmAll(board,row+1,col);\\n\\t    getEmAll(board,row,col+1);\\n\\t    getEmAll(board,row-1,col);\\n\\t    getEmAll(board,row,col-1);\\n\\t    \\n\\t}   \\n\\t        \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    public void solve(char[][] board) {\\n        \\n        if(board==null || board.length==0) return;\\n        \\n        int row = board.length;\\n        int col = board[0].length;\\n        \\n        //check first and last col\\n        for(int i=0;i<row;i++){\\n            \\n            if(board[i][0]=='O') getEmAll(board,i,1);\\n            if(board[i][col-1]=='O') getEmAll(board,i,col-2);\\n        }\\n        \\n        //check first and last  row\\n        for(int i=0;i<col;i++){\\n            \\n            if(board[0][i]=='O') getEmAll(board,1,i);\\n            if(board[row-1][i]=='O') getEmAll(board,row-2,i);\\n        }\\n        \\n\\n       //Switch all 'O's to 'X's and 'Y's to 'O's\\n        for(int i=1;i<row-1;i++)\\n        {\\n            for(int j=1;j<col-1;j++)\\n                 if(board[i][j]=='Y') board[i][j]='O';\\n                 else if(board[i][j]=='O') board[i][j]='X';\\n        }\\n\\t}\\n\\t    \\n\\tpublic void getEmAll(char[][] board, int row, int col){\\n\\t    \\n\\t    if(row>=board.length-1 || row<=0 || col>=board[0].length-1 || col<=0) return;\\n\\t    \\n\\t    if(board[row][col]=='X' || board[row][col]=='Y') return;\\n\\t    if(board[row][col]=='O') board[row][col]='Y';\\n\\t    \\n\\t    getEmAll(board,row+1,col);\\n\\t    getEmAll(board,row,col+1);\\n\\t    getEmAll(board,row-1,col);\\n\\t    getEmAll(board,row,col-1);\\n\\t    \\n\\t}   \\n\\t        \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41713,
                "title": "efficient-java-solution-using-recursion",
                "content": "    public class Solution {\\n        public void solve(char[][] board) {\\n            if(board==null || board.length<=1 ||board[0].length<=1)\\n                return;\\n            int rows = board.length;\\n            int cols = board[0].length;\\n            for(int i=0; i<rows; i++){\\n                if(board[i][0]=='O') helper(board,i,0);\\n                if(board[i][cols-1]=='O') helper(board,i, cols-1);\\n            }\\n            for(int i=1; i<cols-1; i++){\\n                if(board[0][i]=='O') helper(board,0,i);\\n                if(board[rows-1][i]=='O') helper(board,rows-1,i);\\n            }\\n           \\n            for(int i=0; i<rows; i++){\\n                for(int j=0; j<cols; j++){\\n                    if(board[i][j]=='I') board[i][j]='O';\\n                    else if(board[i][j]=='O') board[i][j]='X';\\n            }\\n         }\\n        }\\n        public void helper(char[][] board, int r, int c){\\n            board[r][c] = 'I';\\n            if(r-1>0 && board[r-1][c]=='O'){helper(board, r-1,c);}\\n            if(r+1<board.length-1 && board[r+1][c]=='O'){helper(board, r+1,c);}\\n            if(c+1<board[0].length-1 && board[r][c+1]=='O'){helper(board, r,c+1);}\\n            if(c-1>0 && board[r][c-1]=='O'){helper(board, r,c-1);}\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void solve(char[][] board) {\\n            if(board==null || board.length<=1 ||board[0].length<=1)\\n                return;\\n            int rows = board.length;\\n            int cols = board[0].length;\\n            for(int i=0; i<rows; i++){\\n                if(board[i][0]=='O') helper(board,i,0);\\n                if(board[i][cols-1]=='O') helper(board,i, cols-1);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 41635,
                "title": "why-this-code-has-runtime-error",
                "content": "Hi,\\n\\nThe first version of my submission has runtime error, and I debugged it on local machine, it seems to be stack overflow. But if I add the if with comment \"modified version\", then it can pass. I don't understand. Is the case kind of corner? Or the test case is not large enough to make the modified version fail?\\n\\n    class Solution {\\n    public:\\n    void solve(vector<vector<char>>& board) {\\n        int rows=board.size();\\n        if(rows<=2) return;\\n        int columns=board.front().size();\\n        if(columns<=2) return;\\n        int i=0, j=0;\\n        for(; j<columns-1; ++j){\\n            populate(board, i, j, rows, columns);\\n        }\\n        for(; i<rows-1; ++i){\\n            populate(board, i, j, rows, columns);\\n        }\\n        for(; j>0; --j){\\n            populate(board, i, j, rows, columns);\\n        }\\n        for(; i>0; --i){\\n            populate(board, i, j, rows, columns);\\n        }\\n        for(i=0; i<rows; ++i){\\n            for(j=0; j<columns; ++j){\\n                if(board[i][j]=='Z') board[i][j]='O';\\n                else if(board[i][j]=='O') board[i][j]='X';\\n            }\\n        }\\n    }\\n    void populate(vector<vector<char>>& board, int i, int j, int rows, int columns){\\n        if(i<0 || i>=rows || j<0 || j>=columns) return;\\n        if(board[i][j]=='O'){\\n            board[i][j]='Z';\\n            populate(board, i+1, j, rows, columns);\\n            populate(board, i-1, j, rows, columns);\\n            populate(board, i, j+1, rows, columns);\\n            if(j>1) // modified version\\n            populate(board, i, j-1, rows, columns);\\n        }\\n    }};",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    void solve(vector<vector<char>>& board) {\\n        int rows=board.size();\\n        if(rows<=2) return;\\n        int columns=board.front().size();\\n        if(columns<=2) return;\\n        int i=0, j=0;\\n        for(; j<columns-1; ++j){\\n            populate(board, i, j, rows, columns);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2707807,
                "title": "java-1-ms-faster-than-99-93",
                "content": "```\\n    public void solve(char[][] board) {\\n        int m = board.length;\\n        int n = board[0].length;\\n\\n        // traverse 1st and last col\\n        for (int i = 0; i < m; i++){\\n            dfs(board, i, 0);\\n            dfs(board, i, n - 1);\\n        }\\n\\n        // traverse 1st and last row\\n        for (int j = 0; j < n; j++){\\n            dfs(board, 0, j);\\n            dfs(board, m - 1, j);\\n        }\\n\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (board[i][j] == \\'O\\'){\\n                    board[i][j] = \\'X\\';\\n                }\\n                if (board[i][j] == \\'*\\'){\\n                    board[i][j] = \\'O\\';\\n                }\\n            }\\n        }\\n    }\\n\\n    public void dfs(char[][] board, int i, int j){\\n        if (i < 0 || j < 0 || i >= board.length || j >= board[i].length){\\n            return;\\n        }\\n\\n        if (board[i][j] == \\'X\\' || board[i][j] == \\'*\\'){\\n            return;\\n        }\\n\\n        board[i][j] = \\'*\\';\\n        dfs(board, i + 1, j);\\n        dfs(board, i - 1, j);\\n        dfs(board, i, j + 1);\\n        dfs(board, i, j - 1);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n    public void solve(char[][] board) {\\n        int m = board.length;\\n        int n = board[0].length;\\n\\n        // traverse 1st and last col\\n        for (int i = 0; i < m; i++){\\n            dfs(board, i, 0);\\n            dfs(board, i, n - 1);\\n        }\\n\\n        // traverse 1st and last row\\n        for (int j = 0; j < n; j++){\\n            dfs(board, 0, j);\\n            dfs(board, m - 1, j);\\n        }\\n\\n        for (int i = 0; i < m; i++){\\n            for (int j = 0; j < n; j++){\\n                if (board[i][j] == \\'O\\'){\\n                    board[i][j] = \\'X\\';\\n                }\\n                if (board[i][j] == \\'*\\'){\\n                    board[i][j] = \\'O\\';\\n                }\\n            }\\n        }\\n    }\\n\\n    public void dfs(char[][] board, int i, int j){\\n        if (i < 0 || j < 0 || i >= board.length || j >= board[i].length){\\n            return;\\n        }\\n\\n        if (board[i][j] == \\'X\\' || board[i][j] == \\'*\\'){\\n            return;\\n        }\\n\\n        board[i][j] = \\'*\\';\\n        dfs(board, i + 1, j);\\n        dfs(board, i - 1, j);\\n        dfs(board, i, j + 1);\\n        dfs(board, i, j - 1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1552808,
                "title": "not-best-but-intuitive-solution",
                "content": "Okay, so this is my first ever post ever, any feedback is appreciated. Thanks for reading in advance.\\n\\nNow, my intuition is simple as you will also realise from the following steps:\\n\\n**Note:** Observe that, any component of \"O\" that will not be converted to \"X\" wil have atleast one cell that will lie on the boundary.\\n\\n1. I will traverse in the boundary of the board and check for cells with \"O\".\\n\\n2. For every cell with value as \"O\" in the boundary, I will mark the full component (component here is a cluster of \"O\") of that cell as bad component (By making it unreachable as you will see from the code).\\n\\n3. Then, I will do a simple DFS and convert all the \"O\" to \"X\" which are not in a bad component.\\n\\nHere goes the code for my approach:\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    int dx[4] = {0, 0, 1, -1};\\n    int dy[4] = {1, -1, 0, 0};\\n    \\n    bool is_valid(vector<vector<char>>& board, int x, int y, int n, int m, vector<vector<bool>>& vis){\\n        \\n        if(x>=0 and x<n and y >= 0 and y < m and board[x][y] == \\'O\\' and !vis[x][y])\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    void fill_comp(int x, int y, vector<vector<char>>& board, vector<vector<bool>>& vis){\\n        vis[x][y] = true;\\n        board[x][y] = \\'X\\';\\n        \\n        int n = board.size();\\n        int m = board[0].size();\\n        \\n        for(int i{}; i<4; ++i){\\n            int xx = x+dx[i];\\n            int yy = y+dy[i];\\n            \\n            if(is_valid(board, xx, yy, n, m, vis)){\\n                \\n                fill_comp(xx, yy, board, vis);\\n            }\\n        }\\n    }\\n    \\n    void mark_bad(vector<vector<bool>>&vis, vector<vector<char>>& board, int x, int y){\\n        \\n        vis[x][y] = true; //marking bad means already making it visited so that it won\\'t get visited while doing main dfs\\n        int n = board.size();\\n        int m = board[0].size();\\n        \\n        for(int i{}; i<4; ++i){\\n            int xx = x + dx[i];\\n            int yy = y + dy[i];\\n            \\n            if(is_valid(board, xx, yy, n, m, vis)){\\n                \\n                mark_bad(vis, board, xx, yy);\\n            }\\n        }\\n        \\n    }\\n    \\n    void solve(vector<vector<char>>& board) {\\n        \\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<bool>>vis(n, vector<bool>(m, 0));\\n        \\n\\t\\t// Traversing the boundary and marking bad components\\n        for(int i{}; i<n; ++i){\\n            if(board[i][0] == \\'O\\' and !vis[i][0]){\\n                mark_bad(vis, board, i, 0);\\n            }\\n            \\n            if(board[i][m-1] == \\'O\\' and !vis[i][m-1]){\\n                mark_bad(vis, board, i, m-1);\\n            }\\n        }\\n        \\n        for(int j{}; j<m; ++j){\\n            \\n            if(board[0][j]==\\'O\\' and !vis[0][j]){\\n                mark_bad(vis, board, 0, j);\\n            }\\n            if(board[n-1][j] == \\'O\\' and !vis[n-1][j]){\\n                mark_bad(vis, board, n-1, j);\\n            }\\n        }\\n        \\n\\t\\t//main dfs fill_comp that will fill good components of \"O\" with \"X\"\\n        for(int i{}; i<n; ++i){\\n            for(int j{}; j<m; ++j){\\n                \\n                if(board[i][j] == \\'O\\' and !vis[i][j]){\\n                    \\n                    fill_comp(i, j, board, vis);\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int dx[4] = {0, 0, 1, -1};\\n    int dy[4] = {1, -1, 0, 0};\\n    \\n    bool is_valid(vector<vector<char>>& board, int x, int y, int n, int m, vector<vector<bool>>& vis){\\n        \\n        if(x>=0 and x<n and y >= 0 and y < m and board[x][y] == \\'O\\' and !vis[x][y])\\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    void fill_comp(int x, int y, vector<vector<char>>& board, vector<vector<bool>>& vis){\\n        vis[x][y] = true;\\n        board[x][y] = \\'X\\';\\n        \\n        int n = board.size();\\n        int m = board[0].size();\\n        \\n        for(int i{}; i<4; ++i){\\n            int xx = x+dx[i];\\n            int yy = y+dy[i];\\n            \\n            if(is_valid(board, xx, yy, n, m, vis)){\\n                \\n                fill_comp(xx, yy, board, vis);\\n            }\\n        }\\n    }\\n    \\n    void mark_bad(vector<vector<bool>>&vis, vector<vector<char>>& board, int x, int y){\\n        \\n        vis[x][y] = true; //marking bad means already making it visited so that it won\\'t get visited while doing main dfs\\n        int n = board.size();\\n        int m = board[0].size();\\n        \\n        for(int i{}; i<4; ++i){\\n            int xx = x + dx[i];\\n            int yy = y + dy[i];\\n            \\n            if(is_valid(board, xx, yy, n, m, vis)){\\n                \\n                mark_bad(vis, board, xx, yy);\\n            }\\n        }\\n        \\n    }\\n    \\n    void solve(vector<vector<char>>& board) {\\n        \\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<bool>>vis(n, vector<bool>(m, 0));\\n        \\n\\t\\t// Traversing the boundary and marking bad components\\n        for(int i{}; i<n; ++i){\\n            if(board[i][0] == \\'O\\' and !vis[i][0]){\\n                mark_bad(vis, board, i, 0);\\n            }\\n            \\n            if(board[i][m-1] == \\'O\\' and !vis[i][m-1]){\\n                mark_bad(vis, board, i, m-1);\\n            }\\n        }\\n        \\n        for(int j{}; j<m; ++j){\\n            \\n            if(board[0][j]==\\'O\\' and !vis[0][j]){\\n                mark_bad(vis, board, 0, j);\\n            }\\n            if(board[n-1][j] == \\'O\\' and !vis[n-1][j]){\\n                mark_bad(vis, board, n-1, j);\\n            }\\n        }\\n        \\n\\t\\t//main dfs fill_comp that will fill good components of \"O\" with \"X\"\\n        for(int i{}; i<n; ++i){\\n            for(int j{}; j<m; ++j){\\n                \\n                if(board[i][j] == \\'O\\' and !vis[i][j]){\\n                    \\n                    fill_comp(i, j, board, vis);\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1334501,
                "title": "c-simple-and-easy-to-understand-clean-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<char>>& board, int x, int y, char c) {\\n        if (x < 0 || x >= board.size() || y < 0 || y >= board[0].size() || board[x][y] != \\'O\\') return;\\n            \\n        board[x][y] = c;\\n        \\n        DFS(board, x + 1, y, c);\\n        DFS(board, x - 1, y, c);\\n        DFS(board, x, y + 1, c);\\n        DFS(board, x, y - 1, c);\\n    }\\n    \\n    void solve(vector<vector<char>>& board) {\\n        int n = board.size(), m = board[0].size();\\n        \\n        // Change the \\'O\\'s connected to border to \\'!\\'\\n        for (int i = 0; i < n; i++) {\\n            if (board[i][0] == \\'O\\') DFS(board, i, 0, \\'!\\');\\n            if (board[i][m-1] == \\'O\\') DFS(board, i, m-1, \\'!\\');\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            if (board[0][i] == \\'O\\') DFS(board, 0, i, \\'!\\');\\n            if (board[n-1][i] == \\'O\\') DFS(board, n-1, i, \\'!\\');\\n        }\\n        \\n        // Change all remaining \\'O\\'s to \\'x\\'\\n        for (int i = 1; i < n-1; i++) {\\n            for (int j = 1; j < m-1; j++) {\\n                if (board[i][j] == \\'O\\') board[i][j] = \\'X\\';\\n            }\\n        }\\n        \\n        // Change back \\'!\\' to \\'O\\'\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (board[i][j] == \\'!\\') board[i][j] = \\'O\\';\\n            }\\n        }\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void DFS(vector<vector<char>>& board, int x, int y, char c) {\\n        if (x < 0 || x >= board.size() || y < 0 || y >= board[0].size() || board[x][y] != \\'O\\') return;\\n            \\n        board[x][y] = c;\\n        \\n        DFS(board, x + 1, y, c);\\n        DFS(board, x - 1, y, c);\\n        DFS(board, x, y + 1, c);\\n        DFS(board, x, y - 1, c);\\n    }\\n    \\n    void solve(vector<vector<char>>& board) {\\n        int n = board.size(), m = board[0].size();\\n        \\n        // Change the \\'O\\'s connected to border to \\'!\\'\\n        for (int i = 0; i < n; i++) {\\n            if (board[i][0] == \\'O\\') DFS(board, i, 0, \\'!\\');\\n            if (board[i][m-1] == \\'O\\') DFS(board, i, m-1, \\'!\\');\\n        }\\n        \\n        for (int i = 0; i < m; i++) {\\n            if (board[0][i] == \\'O\\') DFS(board, 0, i, \\'!\\');\\n            if (board[n-1][i] == \\'O\\') DFS(board, n-1, i, \\'!\\');\\n        }\\n        \\n        // Change all remaining \\'O\\'s to \\'x\\'\\n        for (int i = 1; i < n-1; i++) {\\n            for (int j = 1; j < m-1; j++) {\\n                if (board[i][j] == \\'O\\') board[i][j] = \\'X\\';\\n            }\\n        }\\n        \\n        // Change back \\'!\\' to \\'O\\'\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (board[i][j] == \\'!\\') board[i][j] = \\'O\\';\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 287279,
                "title": "c-dfs",
                "content": "```\\npublic class Solution {\\n    public void Solve(char[][] board) {\\n        var n = board.Length;\\n\\n        if (n == 0) return;\\n        var m = board[0].Length;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if ((i == 0 || j == 0 || i == n - 1 || j == m - 1) && board[i][j] == \\'O\\') {\\n                    DFS(board, i, j);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (board[i][j] == \\'O\\') {\\n                    board[i][j] = \\'X\\';\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (board[i][j] == \\'C\\') {\\n                    board[i][j] = \\'O\\';\\n                }\\n            }\\n        }\\n    }\\n\\n    private void DFS(char[][] board, int x, int y) {\\n        var n = board.Length;\\n        var m = board[0].Length;\\n\\n        if (x >= n || x < 0 || y >= m || y < 0) {\\n            return;\\n        }\\n\\n        if (board[x][y] == \\'C\\' || board[x][y] == \\'X\\') return;\\n\\n        board[x][y] = \\'C\\';\\n        var directions = new (int, int)[] { (0, 1), (0, -1), (1, 0), (-1, 0) };\\n\\n        foreach (var direction in directions) {\\n            var nextX = x + direction.Item1;\\n            var nextY = y + direction.Item2;\\n\\n            DFS(board, nextX, nextY);\\n        }\\n\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public void Solve(char[][] board) {\\n        var n = board.Length;\\n\\n        if (n == 0) return;\\n        var m = board[0].Length;\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if ((i == 0 || j == 0 || i == n - 1 || j == m - 1) && board[i][j] == \\'O\\') {\\n                    DFS(board, i, j);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (board[i][j] == \\'O\\') {\\n                    board[i][j] = \\'X\\';\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < n; i++) {\\n            for (int j = 0; j < m; j++) {\\n                if (board[i][j] == \\'C\\') {\\n                    board[i][j] = \\'O\\';\\n                }\\n            }\\n        }\\n    }\\n\\n    private void DFS(char[][] board, int x, int y) {\\n        var n = board.Length;\\n        var m = board[0].Length;\\n\\n        if (x >= n || x < 0 || y >= m || y < 0) {\\n            return;\\n        }\\n\\n        if (board[x][y] == \\'C\\' || board[x][y] == \\'X\\') return;\\n\\n        board[x][y] = \\'C\\';\\n        var directions = new (int, int)[] { (0, 1), (0, -1), (1, 0), (-1, 0) };\\n\\n        foreach (var direction in directions) {\\n            var nextX = x + direction.Item1;\\n            var nextY = y + direction.Item2;\\n\\n            DFS(board, nextX, nextY);\\n        }\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3805983,
                "title": "java-100-faster-step-by-step-explained",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->O(n * m)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->O(n * m)\\n![Screenshot_20230205_171246.png](https://assets.leetcode.com/users/images/174e566e-9390-49f8-aee1-acb6c77158cf_1690120856.4299119.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public void solve(char[][] board) {\\n        int rows = board.length;\\n        int cols = board[0].length;\\n        \\n        int[] delRows = {-1, 0, 1, 0}; // Array to represent changes in row index to traverse in all four directions\\n        int[] delCols = {0, 1, 0, -1}; // Array to represent changes in column index to traverse in all four directions\\n\\n        int[][] visited = new int[rows][cols]; // Matrix to keep track of visited cells\\n\\n        // Process first row and last row\\n        for (int i = 0; i < cols; i++) {\\n            // Process first row\\n            if (board[0][i] == \\'O\\' && visited[0][i] == 0) {\\n                dfs(0, i, board, visited, delRows, delCols); // Call the dfs method to explore the connected region of \\'O\\'s\\n            }\\n            // Process last row\\n            if (board[rows - 1][i] == \\'O\\' && visited[rows - 1][i] == 0) {\\n                dfs(rows - 1, i, board, visited, delRows, delCols); // Call the dfs method to explore the connected region of \\'O\\'s\\n            }\\n        }\\n\\n        // Process first and last column\\n        for (int i = 0; i < rows; i++) {\\n            // Process first column\\n            if (board[i][0] == \\'O\\' && visited[i][0] == 0) {\\n                dfs(i, 0, board, visited, delRows, delCols); // Call the dfs method to explore the connected region of \\'O\\'s\\n            }\\n            // Process last column\\n            if (board[i][cols - 1] == \\'O\\' && visited[i][cols - 1] == 0) {\\n                dfs(i, cols - 1, board, visited, delRows, delCols); // Call the dfs method to explore the connected region of \\'O\\'s\\n            }\\n        }\\n\\n        // Convert surrounded \\'O\\'s to \\'X\\'s\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (board[i][j] == \\'O\\' && visited[i][j] == 0) {\\n                    board[i][j] = \\'X\\'; // Mark the surrounded \\'O\\'s as \\'X\\'\\n                }\\n            }\\n        }\\n    }\\n\\n    // Depth First Search (DFS) method to explore the connected region of \\'O\\'s\\n    private static void dfs(int row, int col, char[][] board, int[][] visited, int[] delRows, int[] delCols) {\\n        visited[row][col] = 1; // Mark the current cell as visited\\n\\n        int rows = board.length;\\n        int cols = board[0].length;\\n\\n        // Explore all four directions\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + delRows[i];\\n            int newCol = col + delCols[i];\\n\\n            // Check if the new cell is within bounds and is an unvisited \\'O\\'\\n            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols\\n                && board[newRow][newCol] == \\'O\\' && visited[newRow][newCol] == 0) {\\n                dfs(newRow, newCol, board, visited, delRows, delCols); // Recursively call dfs for the new cell\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\n    public void solve(char[][] board) {\\n        int rows = board.length;\\n        int cols = board[0].length;\\n        \\n        int[] delRows = {-1, 0, 1, 0}; // Array to represent changes in row index to traverse in all four directions\\n        int[] delCols = {0, 1, 0, -1}; // Array to represent changes in column index to traverse in all four directions\\n\\n        int[][] visited = new int[rows][cols]; // Matrix to keep track of visited cells\\n\\n        // Process first row and last row\\n        for (int i = 0; i < cols; i++) {\\n            // Process first row\\n            if (board[0][i] == \\'O\\' && visited[0][i] == 0) {\\n                dfs(0, i, board, visited, delRows, delCols); // Call the dfs method to explore the connected region of \\'O\\'s\\n            }\\n            // Process last row\\n            if (board[rows - 1][i] == \\'O\\' && visited[rows - 1][i] == 0) {\\n                dfs(rows - 1, i, board, visited, delRows, delCols); // Call the dfs method to explore the connected region of \\'O\\'s\\n            }\\n        }\\n\\n        // Process first and last column\\n        for (int i = 0; i < rows; i++) {\\n            // Process first column\\n            if (board[i][0] == \\'O\\' && visited[i][0] == 0) {\\n                dfs(i, 0, board, visited, delRows, delCols); // Call the dfs method to explore the connected region of \\'O\\'s\\n            }\\n            // Process last column\\n            if (board[i][cols - 1] == \\'O\\' && visited[i][cols - 1] == 0) {\\n                dfs(i, cols - 1, board, visited, delRows, delCols); // Call the dfs method to explore the connected region of \\'O\\'s\\n            }\\n        }\\n\\n        // Convert surrounded \\'O\\'s to \\'X\\'s\\n        for (int i = 0; i < rows; i++) {\\n            for (int j = 0; j < cols; j++) {\\n                if (board[i][j] == \\'O\\' && visited[i][j] == 0) {\\n                    board[i][j] = \\'X\\'; // Mark the surrounded \\'O\\'s as \\'X\\'\\n                }\\n            }\\n        }\\n    }\\n\\n    // Depth First Search (DFS) method to explore the connected region of \\'O\\'s\\n    private static void dfs(int row, int col, char[][] board, int[][] visited, int[] delRows, int[] delCols) {\\n        visited[row][col] = 1; // Mark the current cell as visited\\n\\n        int rows = board.length;\\n        int cols = board[0].length;\\n\\n        // Explore all four directions\\n        for (int i = 0; i < 4; i++) {\\n            int newRow = row + delRows[i];\\n            int newCol = col + delCols[i];\\n\\n            // Check if the new cell is within bounds and is an unvisited \\'O\\'\\n            if (newRow >= 0 && newRow < rows && newCol >= 0 && newCol < cols\\n                && board[newRow][newCol] == \\'O\\' && visited[newRow][newCol] == 0) {\\n                dfs(newRow, newCol, board, visited, delRows, delCols); // Recursively call dfs for the new cell\\n            }\\n        }\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1663618,
                "title": "solution-swift-surrounded-regions-test-cases",
                "content": "```swift\\nclass Solution {\\n    func solve(_ board: inout [[Character]]) {\\n        for r in board.indices {\\n            for c in board[r].indices where board[r][c] == \"O\" {\\n                var curr = board\\n                if dfs(&curr, r, c) { board = curr }\\n            }\\n        }\\n    }\\n    \\n    // valid region board\\n    private func dfs(_ board: inout [[Character]], _ r: Int, _ c: Int) -> Bool {\\n        if r < 0 || r >= board.count || c < 0 || c >= board[r].count { return false }\\n        if board[r][c] != \"O\" { return true }\\n        \\n        board[r][c] = \"X\"\\n        \\n        for (dx, dy) in [(1,0), (-1,0), (0,1), (0,-1)] {\\n            let nr = r + dx, nc = c + dy\\n            if !dfs(&board, nr, nc) { return false }\\n        }\\n        return true\\n    }\\n}\\n```\\n\\n---\\n\\n<p>\\n<details>\\n<summary>\\n<img src=\"https://git.io/JDblm\" height=\"24\">\\n<b>TEST CASES</b>\\n</summary>\\n\\n<p><pre>\\n<b>Result:</b> Executed 2 tests, with 0 failures (0 unexpected) in 0.010 (0.012) seconds\\n</pre></p>\\n\\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// Surrounded regions should not be on the border, which means that any \\'O\\' on the\\n    /// border of the board are not flipped to \\'X\\'. Any \\'O\\' that is not on the border and it is not\\n    /// connected to an \\'O\\' on the border will be flipped to \\'X\\'. Two cells are connected if they are\\n    /// adjacent cells connected horizontally or vertically.\\n    func test0() {\\n        var board: [[Character]] = [[\"X\",\"X\",\"X\",\"X\"],\\n                                    [\"X\",\"O\",\"O\",\"X\"],\\n                                    [\"X\",\"X\",\"O\",\"X\"],\\n                                    [\"X\",\"O\",\"X\",\"X\"]]\\n        solution.solve(&board)\\n        XCTAssertEqual(board, [[\"X\",\"X\",\"X\",\"X\"],\\n                               [\"X\",\"X\",\"X\",\"X\"],\\n                               [\"X\",\"X\",\"X\",\"X\"],\\n                               [\"X\",\"O\",\"X\",\"X\"]])\\n    }\\n    \\n    func test1() {\\n        var board: [[Character]] = [[\"X\"]]\\n        solution.solve(&board)\\n        XCTAssertEqual(board, [[\"X\"]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```\\n\\n</details>\\n</p>",
                "solutionTags": [
                    "Swift",
                    "Depth-First Search"
                ],
                "code": "```swift\\nclass Solution {\\n    func solve(_ board: inout [[Character]]) {\\n        for r in board.indices {\\n            for c in board[r].indices where board[r][c] == \"O\" {\\n                var curr = board\\n                if dfs(&curr, r, c) { board = curr }\\n            }\\n        }\\n    }\\n    \\n    // valid region board\\n    private func dfs(_ board: inout [[Character]], _ r: Int, _ c: Int) -> Bool {\\n        if r < 0 || r >= board.count || c < 0 || c >= board[r].count { return false }\\n        if board[r][c] != \"O\" { return true }\\n        \\n        board[r][c] = \"X\"\\n        \\n        for (dx, dy) in [(1,0), (-1,0), (0,1), (0,-1)] {\\n            let nr = r + dx, nc = c + dy\\n            if !dfs(&board, nr, nc) { return false }\\n        }\\n        return true\\n    }\\n}\\n```\n```swift\\nimport XCTest\\n\\nclass Tests: XCTestCase {\\n    \\n    private let solution = Solution()\\n    \\n    /// Surrounded regions should not be on the border, which means that any \\'O\\' on the\\n    /// border of the board are not flipped to \\'X\\'. Any \\'O\\' that is not on the border and it is not\\n    /// connected to an \\'O\\' on the border will be flipped to \\'X\\'. Two cells are connected if they are\\n    /// adjacent cells connected horizontally or vertically.\\n    func test0() {\\n        var board: [[Character]] = [[\"X\",\"X\",\"X\",\"X\"],\\n                                    [\"X\",\"O\",\"O\",\"X\"],\\n                                    [\"X\",\"X\",\"O\",\"X\"],\\n                                    [\"X\",\"O\",\"X\",\"X\"]]\\n        solution.solve(&board)\\n        XCTAssertEqual(board, [[\"X\",\"X\",\"X\",\"X\"],\\n                               [\"X\",\"X\",\"X\",\"X\"],\\n                               [\"X\",\"X\",\"X\",\"X\"],\\n                               [\"X\",\"O\",\"X\",\"X\"]])\\n    }\\n    \\n    func test1() {\\n        var board: [[Character]] = [[\"X\"]]\\n        solution.solve(&board)\\n        XCTAssertEqual(board, [[\"X\"]])\\n    }\\n}\\n\\nTests.defaultTestSuite.run()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 602287,
                "title": "default-code-compile-error",
                "content": "When I submit c++ default code, it gives compile error.\\nIs there anyone in the same situation?\\n\\n- Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n\\n    }\\n};\\n```\\n\\n- Error message\\n```\\nCompile Error:\\n\\nLine 30: Char 17: fatal error: no matching member function for call to \\'resize\\'\\n        param_1.resize();\\n        ~~~~~~~~^~~~~~\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/8/../../../../include/c++/8/bits/stl_vector.h:824:7: note: candidate function not viable: requires single argument \\'__new_size\\', but no arguments were provided\\n      resize(size_type __new_size)\\n      ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/8/../../../../include/c++/8/bits/stl_vector.h:844:7: note: candidate function not viable: requires 2 arguments, but 0 were provided\\n      resize(size_type __new_size, const value_type& __x)\\n      ^\\n1 error generated.\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n\\n    }\\n};\\n```\n```\\nCompile Error:\\n\\nLine 30: Char 17: fatal error: no matching member function for call to \\'resize\\'\\n        param_1.resize();\\n        ~~~~~~~~^~~~~~\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/8/../../../../include/c++/8/bits/stl_vector.h:824:7: note: candidate function not viable: requires single argument \\'__new_size\\', but no arguments were provided\\n      resize(size_type __new_size)\\n      ^\\n/usr/bin/../lib/gcc/x86_64-linux-gnu/8/../../../../include/c++/8/bits/stl_vector.h:844:7: note: candidate function not viable: requires 2 arguments, but 0 were provided\\n      resize(size_type __new_size, const value_type& __x)\\n      ^\\n1 error generated.\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41710,
                "title": "java-6ms-dfs-solution-easy-to-understand-and-relatively-short",
                "content": "Idea is simple: the only 'O's that will NOT change to 'X's are those at the edges and those horizontally or vertically connected to the 'O's at the edges. So, first find out all the 'O's at the edges, mark them as 'M', and keep checking their surrounding 'O's and mark them as 'M'. Then loop the board again, change 'O's to 'X's and change those who was marked as 'M's to 'O's. Done.\\n\\n    public class Solution {\\n        public void solve(char[][] board) {\\n            for (int i = 0; i < board.length; i++) {\\n                for (int j = 0; j < board[i].length; j++) {\\n                    if ((i == 0 || i == board.length-1 || j == 0 || j == board[i].length-1) && (board[i][j] == 'O')) {\\n                        board[i][j] = 'M';\\n                        connected(i, j, board);\\n                    }\\n                }\\n            }\\n            for (int i = 0; i < board.length; i++) {\\n                for (int j = 0; j < board[i].length; j++) {\\n                    if (board[i][j] == 'O') {\\n                        board[i][j] = 'X';\\n                    }\\n                    else if (board[i][j] == 'M') {\\n                        board[i][j] = 'O';\\n                    }       \\n                }\\n            }\\n        }\\n        \\n        public void connected(int i, int j, char[][] board) {\\n            if (i-1 > 0 && board[i-1][j] == 'O') {\\n                board[i-1][j] = 'M';\\n                connected(i-1, j, board);\\n            }\\n            if (i+1 < board.length-1 && board[i+1][j] == 'O') {\\n                board[i+1][j] = 'M';\\n                connected(i+1, j, board);\\n            }\\n            if (j-1 > 0 && board[i][j-1] == 'O') {\\n                board[i][j-1] = 'M';\\n                connected(i, j-1, board);\\n            }\\n            if (j+1 < board[i].length-1 && board[i][j+1] == 'O') {\\n                board[i][j+1] = 'M';\\n                connected(i, j+1, board);\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n        public void solve(char[][] board) {\\n            for (int i = 0; i < board.length; i++) {\\n                for (int j = 0; j < board[i].length; j++) {\\n                    if ((i == 0 || i == board.length-1 || j == 0 || j == board[i].length-1) && (board[i][j] == 'O')) {\\n                        board[i][j] = 'M';\\n                        connected(i, j, board);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 41800,
                "title": "python-straight-forward-solution",
                "content": "Inspired from [caikehe's][1] solution. Start from the edge and mark all the 'O' that are accessible from the 'O' in the edge using BFS. The marked 'O' should stay 'O', and the 'untouchable' 'O' would be converted to 'X'\\n\\n    def solve(board):\\n        queue = []\\n        for r in range(len(board)):\\n            for c in range(len(board[0])):\\n                if (r in [0, len(board)-1] or c in [0, len(board[0])-1]) and board[r][c] == 'O':\\n                    queue.append((r,c))\\n        while queue:\\n            r,c = queue.pop(0)\\n            if 0<=r<len(board) and 0<=c<len(board[0]) and board[r][c] == 'O':\\n                board[r][c] = 'V'\\n                queue.append((r-1,c))\\n                queue.append((r+1,c))\\n                queue.append((r,c-1))\\n                queue.append((r,c+1))\\n        \\n        for r in range(len(board)):\\n            for c in range(len(board[0])):\\n                if board[r][c] == 'V':\\n                    board[r][c] = 'O'\\n                elif board[r][c] == 'O':\\n                    board[r][c] = 'X'\\n                    \\n\\n\\n  [1]: https://leetcode.com/discuss/57174/python-short-bfs-solution",
                "solutionTags": [
                    "Python"
                ],
                "code": "Inspired from [caikehe's][1] solution. Start from the edge and mark all the 'O' that are accessible from the 'O' in the edge using BFS. The marked 'O' should stay 'O', and the 'untouchable' 'O' would be converted to 'X'\\n\\n    def solve(board):\\n        queue = []\\n        for r in range(len(board)):\\n            for c in range(len(board[0])):\\n                if (r in [0, len(board)-1] or c in [0, len(board[0])-1]) and board[r][c] == 'O':\\n                    queue.append((r,c))\\n        while queue:\\n            r,c = queue.pop(0)\\n            if 0<=r<len(board) and 0<=c<len(board[0]) and board[r][c] == 'O':\\n                board[r][c] = 'V'\\n                queue.append((r-1,c))\\n                queue.append((r+1,c))\\n                queue.append((r,c-1))\\n                queue.append((r,c+1))\\n        \\n        for r in range(len(board)):\\n            for c in range(len(board[0])):\\n                if board[r][c] == 'V':\\n                    board[r][c] = 'O'\\n                elif board[r][c] == 'O':\\n                    board[r][c] = 'X'\\n                    \\n\\n\\n  [1]: https://leetcode.com/discuss/57174/python-short-bfs-solution",
                "codeTag": "Python3"
            },
            {
                "id": 3471954,
                "title": "java-solution-for-surrounded-regions-problem",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe problem is to find all the \"surrounded regions\" in a 2D board. A surrounded region is defined as a region of \\'O\\'s (capital letter O) that is surrounded by \\'X\\'s (capital letter X) in all directions (left, right, top, bottom). The goal is to replace all such surrounded regions with \\'X\\'s.\\n\\nThe\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFirst, it checks if the input board is null or empty. If it is, the function returns.\\nNext, it iterates over the left and right borders of the board, looking for \\'O\\'s. If it finds an \\'O\\', it calls the \"merge\" function, passing in the row and column indices of the \\'O\\' as arguments. The \"merge\" function is a recursive function that marks all the connected \\'O\\'s with a special character, \\'#\\' (hash symbol).\\nThen, the solution iterates over the top and bottom borders of the board, looking for \\'O\\'s. If it finds an \\'O\\', it calls the \"merge\" function again, passing in the row and column indices of the \\'O\\' as arguments.\\nAfter all the border \\'O\\'s have been merged, the solution iterates over the entire board, replacing \\'O\\'s with \\'X\\'s and \\'#\\'s with \\'O\\'s.\\nFinally, the modified board is returned.\\n\\nThe \"merge\" function works recursively as follows:\\n\\nFirst, it checks if the given row and column indices are valid (i.e., not out of bounds). If they are not valid, the function returns.\\nNext, it checks if the current cell is an \\'O\\'. If it is not, the function returns.\\nIf the current cell is an \\'O\\', the function marks it with \\'#\\' and then recursively calls itself for all four adjacent cells (up, down, left, right).\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(mn), where m and n are the dimensions of the input board. This is because the code iterates over every cell in the board once, performs a constant amount of work (comparing the cell value to \\'O\\' or \\'#\\'), and recursively calls the merge method on up to four neighboring cells. Since each cell is visited at most once, the time complexity is proportional to the number of cells in the board.\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(mn), because the merge method performs a depth-first search of the board, potentially storing up to m*n recursive calls on the call stack. Additionally, the code modifies the input board in-place by changing \\'O\\' cells to \\'#\\' cells and later changing \\'#\\' cells back to \\'O\\' cells. However, these modifications do not increase the space complexity beyond the original input size.\\n\\n# Code\\n```\\nclass Solution {\\n    public void solve(char[][] board) {\\n        if(board == null || board.length==0)\\n            return;\\n        int m = board.length;\\n        int n = board[0].length;\\n        //merge O\\u2019s on left & right boarder\\n        for(int i=0;i<m;i++)\\n        {\\n            if(board[i][0] == \\'O\\')\\n            {\\n                merge(board, i, 0);\\n            }\\n            if(board[i][n-1] == \\'O\\')\\n            {\\n                merge(board, i,n-1);\\n            }\\n        }\\n        //merge O\\u2019s on top & bottom boarder\\n        for(int j=0; j<n; j++)\\n        {\\n            if(board[0][j] == \\'O\\')\\n            {\\n                merge(board, 0,j);\\n            }\\n            if(board[m-1][j] == \\'O\\')\\n            {\\n                merge(board, m-1,j);\\n            }\\n        }\\n        //process the board\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(board[i][j] == \\'O\\')\\n                {\\n                    board[i][j] = \\'X\\';\\n                }\\n                else if(board[i][j] == \\'#\\')\\n                {\\n                    board[i][j] = \\'O\\';\\n                }\\n            }\\n        }\\n    }\\n    public void merge(char[][] board, int i, int j){\\n        if(i<0 || i>=board.length || j<0 || j>=board[0].length)\\n            return;\\n        if(board[i][j] != \\'O\\')\\n            return;\\n        board[i][j] = \\'#\\';\\n        merge(board, i-1, j);\\n        merge(board, i+1, j);\\n        merge(board, i, j-1);\\n        merge(board, i, j+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void solve(char[][] board) {\\n        if(board == null || board.length==0)\\n            return;\\n        int m = board.length;\\n        int n = board[0].length;\\n        //merge O\\u2019s on left & right boarder\\n        for(int i=0;i<m;i++)\\n        {\\n            if(board[i][0] == \\'O\\')\\n            {\\n                merge(board, i, 0);\\n            }\\n            if(board[i][n-1] == \\'O\\')\\n            {\\n                merge(board, i,n-1);\\n            }\\n        }\\n        //merge O\\u2019s on top & bottom boarder\\n        for(int j=0; j<n; j++)\\n        {\\n            if(board[0][j] == \\'O\\')\\n            {\\n                merge(board, 0,j);\\n            }\\n            if(board[m-1][j] == \\'O\\')\\n            {\\n                merge(board, m-1,j);\\n            }\\n        }\\n        //process the board\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0; j<n; j++)\\n            {\\n                if(board[i][j] == \\'O\\')\\n                {\\n                    board[i][j] = \\'X\\';\\n                }\\n                else if(board[i][j] == \\'#\\')\\n                {\\n                    board[i][j] = \\'O\\';\\n                }\\n            }\\n        }\\n    }\\n    public void merge(char[][] board, int i, int j){\\n        if(i<0 || i>=board.length || j<0 || j>=board[0].length)\\n            return;\\n        if(board[i][j] != \\'O\\')\\n            return;\\n        board[i][j] = \\'#\\';\\n        merge(board, i-1, j);\\n        merge(board, i+1, j);\\n        merge(board, i, j-1);\\n        merge(board, i, j+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3315985,
                "title": "python-97-64-faster-bfs-dfs-two-approaches",
                "content": "**BFS Approach:**\\n```\\ndef solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        m=len(board)\\n        n=len(board[0])\\n        q=deque()\\n        for i in range(m):\\n            for j in range(n):\\n                if i==0 or i==m-1 or j==0 or j==n-1:\\n                    if board[i][j]==\\'O\\':\\n                        board[i][j]=\\'Y\\'\\n                        q.append((i,j))   \\n        while q:\\n            a,b=q.popleft()\\n            for r,c in [(a-1,b),(a+1,b),(a,b-1),(a,b+1)]:\\n                if 0<=r<m and 0<=c<n and board[r][c]==\\'O\\':\\n                    board[r][c]=\"Y\"\\n                    q.append((r,c))\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j]==\\'O\\':\\n                    board[i][j]=\\'X\\'\\n                elif board[i][j]==\\'Y\\':\\n                    board[i][j]=\\'O\\'\\n```\\n**DFS Approach:**\\n```\\ndef solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        def dfs(sv):\\n            a,b=sv[0],sv[1]\\n            board[a][b]=\\'Y\\'\\n            for r,c in [(a-1,b),(a+1,b),(a,b-1),(a,b+1)]:\\n                if 0<=r<m and 0<=c<n and board[r][c]==\\'O\\':\\n                    board[r][c]=\"Y\"\\n                    dfs((r,c))\\n        m=len(board)\\n        n=len(board[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if i==0 or i==m-1 or j==0 or j==n-1:\\n                    if board[i][j]==\\'O\\':\\n                        dfs((i,j))\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j]==\\'O\\':\\n                    board[i][j]=\\'X\\'\\n                elif board[i][j]==\\'Y\\':\\n                    board[i][j]=\\'O\\'\\n```\\n\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\ndef solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        m=len(board)\\n        n=len(board[0])\\n        q=deque()\\n        for i in range(m):\\n            for j in range(n):\\n                if i==0 or i==m-1 or j==0 or j==n-1:\\n                    if board[i][j]==\\'O\\':\\n                        board[i][j]=\\'Y\\'\\n                        q.append((i,j))   \\n        while q:\\n            a,b=q.popleft()\\n            for r,c in [(a-1,b),(a+1,b),(a,b-1),(a,b+1)]:\\n                if 0<=r<m and 0<=c<n and board[r][c]==\\'O\\':\\n                    board[r][c]=\"Y\"\\n                    q.append((r,c))\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j]==\\'O\\':\\n                    board[i][j]=\\'X\\'\\n                elif board[i][j]==\\'Y\\':\\n                    board[i][j]=\\'O\\'\\n```\n```\\ndef solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        def dfs(sv):\\n            a,b=sv[0],sv[1]\\n            board[a][b]=\\'Y\\'\\n            for r,c in [(a-1,b),(a+1,b),(a,b-1),(a,b+1)]:\\n                if 0<=r<m and 0<=c<n and board[r][c]==\\'O\\':\\n                    board[r][c]=\"Y\"\\n                    dfs((r,c))\\n        m=len(board)\\n        n=len(board[0])\\n        for i in range(m):\\n            for j in range(n):\\n                if i==0 or i==m-1 or j==0 or j==n-1:\\n                    if board[i][j]==\\'O\\':\\n                        dfs((i,j))\\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j]==\\'O\\':\\n                    board[i][j]=\\'X\\'\\n                elif board[i][j]==\\'Y\\':\\n                    board[i][j]=\\'O\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3150350,
                "title": "fastest-solution-100-0ms-with-explanation-for-beginners",
                "content": "# Intuition\\nDFS\\n\\n# Approach\\n1. Apply DFS from border of the grid so that all the element which do not have any path leading to broder of the gird will be unaffected. \\n2. Change value of the traversed path to anything for example \\'p\\'.\\n3. After completion of DFS change all the value in grid from \\'O\\' to \\'X\\'\\n4. Change Remaining \\'p\\' from grid to \\'O\\' \\n5. Our answer ready\\n\\n# Complexity\\n- Time complexity:\\nO(grid.length*grid[0].length)\\n\\n- Space complexity:\\nO(grid.length*grid[0].length)\\n\\n# Code\\n```\\nclass Solution {\\n    public void solve(char[][] grid) {\\n        for(int i=0;i<grid.length;i++){\\n            if(grid[i][0]!=\\'X\\')\\n            DFS(i,0,grid);\\n            if(grid[i][grid[0].length-1]!=\\'X\\')\\n            DFS(i,grid[0].length-1,grid);\\n        }\\n        for(int i=0;i<grid[0].length-1;i++){\\n            if(grid[0][i]!=\\'X\\')\\n            DFS(0,i,grid);\\n            if(grid[grid.length-1][i]!=\\'X\\')\\n            DFS(grid.length-1,i,grid);\\n        }\\n        swap(grid,\\'O\\',\\'X\\');\\n        swap(grid,\\'p\\',\\'O\\');  \\n    }\\n\\n    void swap(char[][] grid,char p, char q){\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++)\\n                    if(grid[i][j]==p) grid[i][j]=q;\\n    }\\n\\n    void DFS(int i,int j, char[][] grid){\\n        if(!(i>=0 && j>=0 && i<grid.length && j<grid[0].length && grid[i][j]==\\'O\\')) return ;\\n        grid[i][j]=\\'p\\';\\n        DFS(i+1,j,grid);\\n        DFS(i,j+1,grid);\\n        DFS(i-1,j,grid);\\n        DFS(i,j-1,grid);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public void solve(char[][] grid) {\\n        for(int i=0;i<grid.length;i++){\\n            if(grid[i][0]!=\\'X\\')\\n            DFS(i,0,grid);\\n            if(grid[i][grid[0].length-1]!=\\'X\\')\\n            DFS(i,grid[0].length-1,grid);\\n        }\\n        for(int i=0;i<grid[0].length-1;i++){\\n            if(grid[0][i]!=\\'X\\')\\n            DFS(0,i,grid);\\n            if(grid[grid.length-1][i]!=\\'X\\')\\n            DFS(grid.length-1,i,grid);\\n        }\\n        swap(grid,\\'O\\',\\'X\\');\\n        swap(grid,\\'p\\',\\'O\\');  \\n    }\\n\\n    void swap(char[][] grid,char p, char q){\\n        for(int i=0;i<grid.length;i++)\\n            for(int j=0;j<grid[0].length;j++)\\n                    if(grid[i][j]==p) grid[i][j]=q;\\n    }\\n\\n    void DFS(int i,int j, char[][] grid){\\n        if(!(i>=0 && j>=0 && i<grid.length && j<grid[0].length && grid[i][j]==\\'O\\')) return ;\\n        grid[i][j]=\\'p\\';\\n        DFS(i+1,j,grid);\\n        DFS(i,j+1,grid);\\n        DFS(i-1,j,grid);\\n        DFS(i,j-1,grid);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090365,
                "title": "accepted-easy-solution-short-simple-best-method",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        queue<pair<int, int>> q;\\n        int m=board.size();\\n        int n=board[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            if(i==0 || j==0 || i==m-1 || j==n-1)\\n            if(board[i][j]==\\'O\\')\\n            {\\n                q.push({i, j});\\n                board[i][j]=\\'a\\';\\n            }\\n        }\\n        int v[5]={-1, 0, 1, 0, -1};\\n        while(!q.empty())\\n        {\\n            auto p=q.front();\\n            q.pop();\\n            for(int i=0;i<4;i++)\\n            {\\n                int r=p.first+v[i];\\n                int c=p.second+v[i+1];\\n                if(r>0 && r<m && c>0 && c<n && board[r][c]==\\'O\\')\\n                {\\n                    q.push({r, c});\\n                    board[r][c]=\\'a\\';\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(board[i][j]==\\'a\\')\\n                board[i][j]=\\'O\\';\\n                else if(board[i][j]==\\'O\\')\\n                board[i][j]=\\'X\\';\\n            }\\n        }\\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        queue<pair<int, int>> q;\\n        int m=board.size();\\n        int n=board[0].size();\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            if(i==0 || j==0 || i==m-1 || j==n-1)\\n            if(board[i][j]==\\'O\\')\\n            {\\n                q.push({i, j});\\n                board[i][j]=\\'a\\';\\n            }\\n        }\\n        int v[5]={-1, 0, 1, 0, -1};\\n        while(!q.empty())\\n        {\\n            auto p=q.front();\\n            q.pop();\\n            for(int i=0;i<4;i++)\\n            {\\n                int r=p.first+v[i];\\n                int c=p.second+v[i+1];\\n                if(r>0 && r<m && c>0 && c<n && board[r][c]==\\'O\\')\\n                {\\n                    q.push({r, c});\\n                    board[r][c]=\\'a\\';\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++)\\n        {\\n            for(int j=0;j<n;j++)\\n            {\\n                if(board[i][j]==\\'a\\')\\n                board[i][j]=\\'O\\';\\n                else if(board[i][j]==\\'O\\')\\n                board[i][j]=\\'X\\';\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2979581,
                "title": "dfs-approach-100-runtime-easy-to-understand",
                "content": "Basically, all the boundary \\'O\\'s need not to be changed.\\nUse DFS to visit the boundary \\'O\\', turn it into \\'V\\' and explore the node.\\nIn this way, we change the remaining \\'O\\'s to \\'X\\'s.\\nConvert the \\'V\\'s to \\'O\\'s.\\n\\n# Code\\n```\\nclass Solution {\\n    public void solve(char[][] board) {\\n        int rows = board.length;\\n        int cols = board[0].length;\\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                if(i*j==0 || i==rows-1 || j==cols-1){ \\n            //We check for Boundary \\'O\\'s and turn them into \\'V\\'.\\n            //These are valid \\'O\\'s and need not to be changed to \\'X\\'s.\\n                    if(board[i][j] == \\'O\\'){\\n                        dfs(board,i,j);\\n                    }\\n                }\\n            }\\n        }\\n//Iterate over the whole grid, change remaining \\'O\\'s to \\'X\\'s.\\n//Change \\'V\\'s to \\'O\\'s\\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                if(board[i][j] == \\'O\\'){\\n                    board[i][j] = \\'X\\';\\n                }\\n                else if(board[i][j] == \\'V\\'){\\n                    board[i][j] = \\'O\\';\\n                }\\n            }\\n        }\\n    }\\n\\n//Main DFS Function to convert all the boundary \\'O\\'s to \\'V\\'s\\n\\n    private void dfs(char[][] board, int i, int j){\\n        if(i<0 || j<0 || i>=board.length || j>=board[0].length || board[i][j] != \\'O\\'){\\n            return;\\n        }\\n        board[i][j] = \\'V\\';\\n        dfs(board,i+1,j);\\n        dfs(board,i-1,j);\\n        dfs(board,i,j+1);\\n        dfs(board,i,j-1);\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public void solve(char[][] board) {\\n        int rows = board.length;\\n        int cols = board[0].length;\\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                if(i*j==0 || i==rows-1 || j==cols-1){ \\n            //We check for Boundary \\'O\\'s and turn them into \\'V\\'.\\n            //These are valid \\'O\\'s and need not to be changed to \\'X\\'s.\\n                    if(board[i][j] == \\'O\\'){\\n                        dfs(board,i,j);\\n                    }\\n                }\\n            }\\n        }\\n//Iterate over the whole grid, change remaining \\'O\\'s to \\'X\\'s.\\n//Change \\'V\\'s to \\'O\\'s\\n        for(int i=0; i<rows; i++){\\n            for(int j=0; j<cols; j++){\\n                if(board[i][j] == \\'O\\'){\\n                    board[i][j] = \\'X\\';\\n                }\\n                else if(board[i][j] == \\'V\\'){\\n                    board[i][j] = \\'O\\';\\n                }\\n            }\\n        }\\n    }\\n\\n//Main DFS Function to convert all the boundary \\'O\\'s to \\'V\\'s\\n\\n    private void dfs(char[][] board, int i, int j){\\n        if(i<0 || j<0 || i>=board.length || j>=board[0].length || board[i][j] != \\'O\\'){\\n            return;\\n        }\\n        board[i][j] = \\'V\\';\\n        dfs(board,i+1,j);\\n        dfs(board,i-1,j);\\n        dfs(board,i,j+1);\\n        dfs(board,i,j-1);\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2251301,
                "title": "check-for-the-o-which-lie-on-the-perimeter-cells-of-the-board-c",
                "content": "At first, I thought that was a very hard question as we need to check all cells that surround a particular group of \\'O\\'s. But, it turned out to be a rather simple question.\\nI solved this problem in 2 iterataions of the board. In the first iteration, all you need to do is to traverse the board and look for the O\\'s which lie on the boundary of the board. Then, call DFS for these cells and mark all the O\\'s connected to these O\\'s as visited.\\nThen, in the second iteration of the matrix, just look for those O\\'s which are not marked visited and changeg them to \\'X\\'.\\n\\n**Time Complexity** - O(n * m)\\n**Space Complexity** - O(n * m)\\n\\n```\\n\\tint mvx[4] = {0,0,-1,1};\\n    int mvy[4] = {-1,1,0,0};\\n    \\n    bool isSafe(int i, int j, int n, int m) {\\n        if(i<0 || i>=n || j<0 || j>=m) return false;\\n        return true;\\n    }\\n    \\n    void dfs(vector<vector<char>>& board, vector<vector<int>>& vis, int i, int j, int n, int m) {\\n        vis[i][j] = 1;\\n        \\n        for(int x=0;x<4;x++) {\\n            int ni = i + mvx[x];\\n            int nj = j + mvy[x];\\n            \\n            if(isSafe(ni, nj, n, m) && board[ni][nj]==\\'O\\' && vis[ni][nj]==0)\\n                dfs(board, vis, ni, nj, n, m);\\n        }\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int n = board.size(), m = board[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m, 0));\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                if(i==0 || j==0 || i==n-1 || j==m-1) {\\n                    if(board[i][j]==\\'O\\' && !vis[i][j]) dfs(board, vis, i, j, n, m);\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                if(board[i][j]==\\'O\\' && !vis[i][j]) board[i][j] = \\'X\\';\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "At first, I thought that was a very hard question as we need to check all cells that surround a particular group of \\'O\\'s. But, it turned out to be a rather simple question.\\nI solved this problem in 2 iterataions of the board. In the first iteration, all you need to do is to traverse the board and look for the O\\'s which lie on the boundary of the board. Then, call DFS for these cells and mark all the O\\'s connected to these O\\'s as visited.\\nThen, in the second iteration of the matrix, just look for those O\\'s which are not marked visited and changeg them to \\'X\\'.\\n\\n**Time Complexity** - O(n * m)\\n**Space Complexity** - O(n * m)\\n\\n```\\n\\tint mvx[4] = {0,0,-1,1};\\n    int mvy[4] = {-1,1,0,0};\\n    \\n    bool isSafe(int i, int j, int n, int m) {\\n        if(i<0 || i>=n || j<0 || j>=m) return false;\\n        return true;\\n    }\\n    \\n    void dfs(vector<vector<char>>& board, vector<vector<int>>& vis, int i, int j, int n, int m) {\\n        vis[i][j] = 1;\\n        \\n        for(int x=0;x<4;x++) {\\n            int ni = i + mvx[x];\\n            int nj = j + mvy[x];\\n            \\n            if(isSafe(ni, nj, n, m) && board[ni][nj]==\\'O\\' && vis[ni][nj]==0)\\n                dfs(board, vis, ni, nj, n, m);\\n        }\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int n = board.size(), m = board[0].size();\\n        vector<vector<int>> vis(n, vector<int> (m, 0));\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                if(i==0 || j==0 || i==n-1 || j==m-1) {\\n                    if(board[i][j]==\\'O\\' && !vis[i][j]) dfs(board, vis, i, j, n, m);\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++) {\\n            for(int j=0;j<m;j++) {\\n                if(board[i][j]==\\'O\\' && !vis[i][j]) board[i][j] = \\'X\\';\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1553037,
                "title": "simple-c-dfs-solution-with-explanations-and-comments",
                "content": "Steps to Solve :\\n      1. Move over the boundary of board, and find O\\'s \\n      2. Every time we find an O, perform DFS from it\\'s position\\n      3. In DFS convert all \\'O\\' to \\'#\\'      (why?? so that we can differentiate which \\'O\\' can be flipped and which cannot be)   \\n      4. After all DFSs have been performed, board contains three elements,#,O and X\\n      5. \\'O\\' are left over elements which are not connected to any boundary O, so flip them to \\'X\\'\\n      6. \\'#\\' are elements which cannot be flipped to \\'X\\', so flip them back to \\'O\\'\\n\\n```\\nvoid dfs(vector<vector<char>> &board,int row,int col)\\n    {\\n\\t//to check if the current position is inside the board and is an \\'O\\'\\n        if(row<0 || row>=board.size() || col<0 || col>=board[0].size() || board[row][col] != \\'O\\') return;\\n\\t\\t// if current is an \\'O\\' , we change it to \\'T\\' to mark\\n\\t\\t//it as member of non-surrounded region\\n        board[row][col] = \\'T\\';\\n\\t\\t\\n\\t\\t//recursive call to dfs for up,down,left and right\\n        dfs(board,row+1,col);\\n        dfs(board,row-1,col);\\n        dfs(board,row,col+1);\\n        dfs(board,row,col-1);\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int n = board.size() , m = board[0].size();\\n\\t\\t\\n\\t\\t//checking on left and right\\n        for(int i=0;i<board.size();i++)\\n        {\\n            if(board[i][0] == \\'O\\') dfs(board,i,0);\\n            if(board[i][m-1] == \\'O\\') dfs(board,i,m-1);\\n        }\\n        \\n\\t\\t//checking on up and down\\n        for(int i=0;i<board[0].size();i++)\\n        {\\n            if(board[0][i] == \\'O\\') dfs(board,0,i);\\n            if(board[n-1][i] == \\'O\\') dfs(board,n-1,i);\\n        }\\n        \\n\\t\\t\\n\\t\\t//changing every \\'T\\' to \\'O\\' and every \\'O\\' to \\'X\\'\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(board[i][j] == \\'T\\') board[i][j] = \\'O\\';\\n                else if(board[i][j] == \\'O\\') board[i][j] = \\'X\\';\\n            }\\n        }\\n        \\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Backtracking",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nvoid dfs(vector<vector<char>> &board,int row,int col)\\n    {\\n\\t//to check if the current position is inside the board and is an \\'O\\'\\n        if(row<0 || row>=board.size() || col<0 || col>=board[0].size() || board[row][col] != \\'O\\') return;\\n\\t\\t// if current is an \\'O\\' , we change it to \\'T\\' to mark\\n\\t\\t//it as member of non-surrounded region\\n        board[row][col] = \\'T\\';\\n\\t\\t\\n\\t\\t//recursive call to dfs for up,down,left and right\\n        dfs(board,row+1,col);\\n        dfs(board,row-1,col);\\n        dfs(board,row,col+1);\\n        dfs(board,row,col-1);\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int n = board.size() , m = board[0].size();\\n\\t\\t\\n\\t\\t//checking on left and right\\n        for(int i=0;i<board.size();i++)\\n        {\\n            if(board[i][0] == \\'O\\') dfs(board,i,0);\\n            if(board[i][m-1] == \\'O\\') dfs(board,i,m-1);\\n        }\\n        \\n\\t\\t//checking on up and down\\n        for(int i=0;i<board[0].size();i++)\\n        {\\n            if(board[0][i] == \\'O\\') dfs(board,0,i);\\n            if(board[n-1][i] == \\'O\\') dfs(board,n-1,i);\\n        }\\n        \\n\\t\\t\\n\\t\\t//changing every \\'T\\' to \\'O\\' and every \\'O\\' to \\'X\\'\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(board[i][j] == \\'T\\') board[i][j] = \\'O\\';\\n                else if(board[i][j] == \\'O\\') board[i][j] = \\'X\\';\\n            }\\n        }\\n        \\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1552267,
                "title": "question-explanation-is-very-bad-well-explained-question-and-solution-easy",
                "content": "## Question : \\n**Meaning of Question is to convert all \"O\" in matrix to \"X\" which are not connected to any \"O\" at the border of matrix.** \\n**Approach:**\\n* Pick all O\\'s from boundary (Top/Bottom row, Leftmost/Rightmost column)\\n* Make all connected O\\'s to some intermediate value (* in my case).\\n* Now remaining all O\\'s are surrounded by X (otherwise they should have been converted to * ).\\n* Convert remaining all O to X.\\n* Revert all intermediate values. ( * to O).\\n\\n\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef solve(self, board: List[List[str]]) -> None:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDo not return anything, modify board in-place instead.\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tm,n = len(board),len(board[0])\\n\\t\\t\\tdef dfs(i,j):\\n\\t\\t\\t\\tif i<0 or i>=m or j<0 or j>=n or board[i][j]!=\"O\":\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tboard[i][j] = \"*\"\\n\\t\\t\\t\\tdfs(i+1,j)\\n\\t\\t\\t\\tdfs(i-1,j)\\n\\t\\t\\t\\tdfs(i,j+1)\\n\\t\\t\\t\\tdfs(i,j-1)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tdfs(i,0)\\n\\t\\t\\t\\tdfs(i,n-1)\\n\\n\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\tdfs(0,j)\\n\\t\\t\\t\\tdfs(m-1,j)\\n\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tif board[i][j] == \"*\":\\n\\t\\t\\t\\t\\t\\tboard[i][j] = \"O\"\\n\\t\\t\\t\\t\\telif board[i][j] == \"O\":\\n\\t\\t\\t\\t\\t\\tboard[i][j] = \"X\"\\n\\t\\t\\treturn",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "## Question : \\n**Meaning of Question is to convert all \"O\" in matrix to \"X\" which are not connected to any \"O\" at the border of matrix.** \\n**Approach:**\\n* Pick all O\\'s from boundary (Top/Bottom row, Leftmost/Rightmost column)\\n* Make all connected O\\'s to some intermediate value (* in my case).\\n* Now remaining all O\\'s are surrounded by X (otherwise they should have been converted to * ).\\n* Convert remaining all O to X.\\n* Revert all intermediate values. ( * to O).\\n\\n\\n**Implementation :**\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n\\t\\tdef solve(self, board: List[List[str]]) -> None:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tDo not return anything, modify board in-place instead.\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tm,n = len(board),len(board[0])\\n\\t\\t\\tdef dfs(i,j):\\n\\t\\t\\t\\tif i<0 or i>=m or j<0 or j>=n or board[i][j]!=\"O\":\\n\\t\\t\\t\\t\\treturn\\n\\n\\t\\t\\t\\tboard[i][j] = \"*\"\\n\\t\\t\\t\\tdfs(i+1,j)\\n\\t\\t\\t\\tdfs(i-1,j)\\n\\t\\t\\t\\tdfs(i,j+1)\\n\\t\\t\\t\\tdfs(i,j-1)\\n\\t\\t\\t\\treturn\\n\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tdfs(i,0)\\n\\t\\t\\t\\tdfs(i,n-1)\\n\\n\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\tdfs(0,j)\\n\\t\\t\\t\\tdfs(m-1,j)\\n\\n\\t\\t\\tfor i in range(m):\\n\\t\\t\\t\\tfor j in range(n):\\n\\t\\t\\t\\t\\tif board[i][j] == \"*\":\\n\\t\\t\\t\\t\\t\\tboard[i][j] = \"O\"\\n\\t\\t\\t\\t\\telif board[i][j] == \"O\":\\n\\t\\t\\t\\t\\t\\tboard[i][j] = \"X\"\\n\\t\\t\\treturn",
                "codeTag": "Java"
            },
            {
                "id": 1548349,
                "title": "javascript-runtime-faster-than-95-54-dfs",
                "content": "Runtime - Faster than 95.54%\\nMemory usage - Used less memory than 85.40%\\n\\n```\\nvar solve = function(board) {\\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[0].length; j++) {\\n            if(board[i][j] === \\'O\\' && (i === 0 || j === 0 || i === board.length - 1 || j === board[0].length - 1)) dfs(i, j);\\n        }\\n    }\\n\\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[0].length; j++) {\\n            if(board[i][j] === \\'Visited\\') {\\n                board[i][j] = \\'O\\';\\n            } else  {\\n                board[i][j] = \\'X\\';\\n            }\\n        }    \\n    }\\n    \\n    function dfs(i, j) {\\n        if(i < 0 || i >= board.length || j < 0 || j >= board[i].length || board[i][j] === \\'Visited\\' || board[i][j] === \\'X\\') return\\n        \\n        board[i][j] = \\'Visited\\';\\n        dfs(i + 1, j);\\n        dfs(i - 1, j);\\n        dfs(i, j + 1);\\n        dfs(i, j - 1);\\n        \\n        return;\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search"
                ],
                "code": "```\\nvar solve = function(board) {\\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[0].length; j++) {\\n            if(board[i][j] === \\'O\\' && (i === 0 || j === 0 || i === board.length - 1 || j === board[0].length - 1)) dfs(i, j);\\n        }\\n    }\\n\\n    for(let i = 0; i < board.length; i++) {\\n        for(let j = 0; j < board[0].length; j++) {\\n            if(board[i][j] === \\'Visited\\') {\\n                board[i][j] = \\'O\\';\\n            } else  {\\n                board[i][j] = \\'X\\';\\n            }\\n        }    \\n    }\\n    \\n    function dfs(i, j) {\\n        if(i < 0 || i >= board.length || j < 0 || j >= board[i].length || board[i][j] === \\'Visited\\' || board[i][j] === \\'X\\') return\\n        \\n        board[i][j] = \\'Visited\\';\\n        dfs(i + 1, j);\\n        dfs(i - 1, j);\\n        dfs(i, j + 1);\\n        dfs(i, j - 1);\\n        \\n        return;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1355815,
                "title": "simple-understandable-dfs-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<char>>&board,int i,int j,int m,int n){\\n        if(i<0||i==m||j<0||j==n||board[i][j]==\\'X\\'||board[i][j]==\\'$\\'){\\n            return ;\\n        }\\n        board[i][j]=\\'$\\';\\n        dfs(board,i-1,j,m,n);\\n        dfs(board,i,j-1,m,n);\\n        dfs(board,i+1,j,m,n);\\n        dfs(board,i,j+1,m,n);\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int m=board.size();\\n        int n=board[0].size();\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                if((i==0||i==m-1||j==0||j==n-1) and board[i][j]==\\'O\\'){\\n                    dfs(board,i,j,m,n);\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(board[i][j]==\\'$\\'){\\n                    board[i][j]=\\'O\\';\\n                }\\n                else if(board[i][j]==\\'O\\'){\\n                    board[i][j]=\\'X\\';\\n                }\\n            \\n            }\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<char>>&board,int i,int j,int m,int n){\\n        if(i<0||i==m||j<0||j==n||board[i][j]==\\'X\\'||board[i][j]==\\'$\\'){\\n            return ;\\n        }\\n        board[i][j]=\\'$\\';\\n        dfs(board,i-1,j,m,n);\\n        dfs(board,i,j-1,m,n);\\n        dfs(board,i+1,j,m,n);\\n        dfs(board,i,j+1,m,n);\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int m=board.size();\\n        int n=board[0].size();\\n        for(int i=0;i<board.size();i++){\\n            for(int j=0;j<board[i].size();j++){\\n                if((i==0||i==m-1||j==0||j==n-1) and board[i][j]==\\'O\\'){\\n                    dfs(board,i,j,m,n);\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(board[i][j]==\\'$\\'){\\n                    board[i][j]=\\'O\\';\\n                }\\n                else if(board[i][j]==\\'O\\'){\\n                    board[i][j]=\\'X\\';\\n                }\\n            \\n            }\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1109553,
                "title": "c-simple-bfs-to-understand-faster-than-99-45",
                "content": "Main logic is that to be totally surrounded by X they must be on four sides.\\nSo if there is a O on the outer edge then it can never be surrounded , and all the O\\'s attached to it are also cannot be surrounded!! \\n\\nSo we start storing all the boundary O\\'s and start securing O\\'s in BFS manner.\\n\\nTo Optimise the memory all the unsorrounded O\\'s are labelled as \\'.\\' \\n\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n         queue<pair<int,int>> q;\\n        int m=board.size(),n=board[0].size();\\n\\t\\t\\n\\t\\t//Getting boundary O\\'s\\n        for(int i=0;i<m;i++)\\n        {\\n            if(board[i][0]==\\'O\\') board[i][0]=\\'.\\',q.push({i,0});\\n            if(board[i][n-1]==\\'O\\') board[i][n-1]=\\'.\\',q.push({i,n-1});\\n        }\\n        for(int i=1;i<n-1;i++)\\n        {\\n            if(board[0][i]==\\'O\\') board[0][i]=\\'.\\',q.push({0,i});\\n            if(board[m-1][i]==\\'O\\') board[m-1][i]=\\'.\\',q.push({m-1,i});\\n        }\\n\\t\\t\\n\\t\\t//BFS\\n        while(q.size())\\n        {\\n            int sz=q.size();\\n            while(sz--)\\n            {\\n                auto p=q.front();q.pop();\\n                int r=p.first,c=p.second;\\n                 if(r+1<m) if(board[r+1][c]==\\'O\\') board[r+1][c]=\\'.\\',q.push({r+1,c});\\n                 if(r-1>=0) if(board[r-1][c]==\\'O\\') board[r-1][c]=\\'.\\',q.push({r-1,c});\\n                 if(c+1<n) if(board[r][c+1]==\\'O\\') board[r][c+1]=\\'.\\',q.push({r,c+1});\\n                 if(c-1>=0) if(board[r][c-1]==\\'O\\') board[r][c-1]=\\'.\\',q.push({r,c-1});    \\n            }\\n        }\\n\\t\\t//all the unsorrounded O\\'s are re-entered\\n        for(int i=0;i<m;i++)\\n            for(int j=0;j<n;j++)\\n                board[i][j]=board[i][j]==\\'.\\'?\\'O\\':\\'X\\';\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n         queue<pair<int,int>> q;\\n        int m=board.size(),n=board[0].size();\\n\\t\\t\\n\\t\\t//Getting boundary O\\'s\\n        for(int i=0;i<m;i++)\\n        {\\n            if(board[i][0]==\\'O\\') board[i][0]=\\'.\\',q.push({i,0}",
                "codeTag": "Java"
            },
            {
                "id": 1041472,
                "title": "java-clean-code",
                "content": "```\\nclass Solution {\\n    public void solve(char[][] board) {\\n        if(board.length == 0)\\n            return;\\n          for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[0].length;j++){\\n                if(i==0 || j==0 || i==board.length-1 || j==board[0].length-1){\\n                    dfs(i,j,board);\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[0].length;j++){\\n                if(board[i][j]==\\'-\\'){\\n                   board[i][j]=\\'O\\';\\n                }\\n                else{\\n                    board[i][j]=\\'X\\'; \\n                }\\n            }\\n        }\\n\\n    }\\n\\n    private void dfs(int i, int j, char[][] board) {\\n        if(i<0 || j<0 || i>board.length-1 || j>board[0].length-1 || board[i][j]!=\\'O\\'){\\n            return;\\n        }\\n        board[i][j]=\\'-\\';\\n\\n        dfs(i+1,j,board);\\n        dfs(i-1,j,board);\\n        dfs(i,j+1,board);\\n        dfs(i,j-1,board);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public void solve(char[][] board) {\\n        if(board.length == 0)\\n            return;\\n          for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[0].length;j++){\\n                if(i==0 || j==0 || i==board.length-1 || j==board[0].length-1){\\n                    dfs(i,j,board);\\n                }\\n            }\\n        }\\n\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[0].length;j++){\\n                if(board[i][j]==\\'-\\'){\\n                   board[i][j]=\\'O\\';\\n                }\\n                else{\\n                    board[i][j]=\\'X\\'; \\n                }\\n            }\\n        }\\n\\n    }\\n\\n    private void dfs(int i, int j, char[][] board) {\\n        if(i<0 || j<0 || i>board.length-1 || j>board[0].length-1 || board[i][j]!=\\'O\\'){\\n            return;\\n        }\\n        board[i][j]=\\'-\\';\\n\\n        dfs(i+1,j,board);\\n        dfs(i-1,j,board);\\n        dfs(i,j+1,board);\\n        dfs(i,j-1,board);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 692646,
                "title": "easy-to-understand-python-solution-beats-98-of-runtimes-50-of-memory",
                "content": "```\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        #check for edge cases\\n        if not board:\\n            return\\n        if len(board[0]) == 1 or len(board) == 1:\\n            return\\n        \\n        #dfs helper function\\n        def dfs(x, y):\\n            if board[y][x] == \"O\":\\n                board[y][x] = \"a\"\\n                if x < len(board[0]) - 1:\\n                    dfs(x + 1, y)\\n                if x > 0:\\n                    dfs(x-1, y)\\n                if y < len(board) - 1:\\n                    dfs(x, y + 1)\\n                if y > 0:\\n                    dfs(x, y-1)\\n            \\n        #dfs all border \"O\"s and make them into any random letter (using \"a\" in the dfs function)\\n        for index, value in enumerate(board):\\n            dfs(0, index)\\n            dfs(len(board[0]) - 1, index)\\n        for index, value in enumerate(board[0]):\\n            dfs(index, 0)\\n            dfs(index, len(board) - 1)\\n        \\n        #go through the entire board changing \"a\"s to \"O\" and all remaining \"O\"s to \"X\"\\n        for y in range(len(board)):\\n            for x in range(len(board[0])):\\n                if board[y][x] == \"a\":\\n                    board[y][x] = \"O\"\\n                elif board[y][x] == \"O\":\\n                    board[y][x] = \"X\"\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        #check for edge cases\\n        if not board:\\n            return\\n        if len(board[0]) == 1 or len(board) == 1:\\n            return\\n        \\n        #dfs helper function\\n        def dfs(x, y):\\n            if board[y][x] == \"O\":\\n                board[y][x] = \"a\"\\n                if x < len(board[0]) - 1:\\n                    dfs(x + 1, y)\\n                if x > 0:\\n                    dfs(x-1, y)\\n                if y < len(board) - 1:\\n                    dfs(x, y + 1)\\n                if y > 0:\\n                    dfs(x, y-1)\\n            \\n        #dfs all border \"O\"s and make them into any random letter (using \"a\" in the dfs function)\\n        for index, value in enumerate(board):\\n            dfs(0, index)\\n            dfs(len(board[0]) - 1, index)\\n        for index, value in enumerate(board[0]):\\n            dfs(index, 0)\\n            dfs(index, len(board) - 1)\\n        \\n        #go through the entire board changing \"a\"s to \"O\" and all remaining \"O\"s to \"X\"\\n        for y in range(len(board)):\\n            for x in range(len(board[0])):\\n                if board[y][x] == \"a\":\\n                    board[y][x] = \"O\"\\n                elif board[y][x] == \"O\":\\n                    board[y][x] = \"X\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 574538,
                "title": "java-union-find",
                "content": "```\\nclass Solution {\\n    \\n    // Union Find \\n    // Intuition: \\n    //       - We need to separate \\'O\\' in the borders from the other \\'O\\'\\n    //       - So, if a node \\'O\\' is on the border connect it to the virtual node.\\n    //       - All the others \\'O\\' connect to their \\'O\\' neighbors. (eventually, if they are tied to a border \\'O\\', they will connect)\\n    //       - After that, traverse the board, flipping the \\'O\\' *** NOT *** connected to the virtual.\\n    \\n    public void solve(char[][] board) {\\n        if(board == null || board.length == 0) return;\\n        int row = board.length;\\n        int col = board[0].length;\\n        UnionFind uf = new UnionFind(row, col);\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                \\n                //Is boarder? Is \\'O\\'? ... connect to the virtual.\\n                if((i == 0 || j == 0 || i == row - 1 || j == col - 1) && (board[i][j] == \\'O\\')){\\n                    uf.union(uf.virtualNode, index(col, i, j)); //connect to virtual\\n                    continue;\\n                } \\n                \\n                //not border, but \\'O\\'\\n                if(board[i][j] == \\'O\\') {\\n                    int id = index(col, i, j);\\n                    // connect the neighbors\\n                    if(i + 1 < row && board[i + 1][j] == \\'O\\') uf.union(id, index(col, i + 1, j));\\n                    if(i - 1 >=  0 && board[i - 1][j] == \\'O\\') uf.union(id, index(col, i - 1, j));\\n                    if(j + 1 < col && board[i][j + 1] == \\'O\\') uf.union(id, index(col, i, j + 1));\\n                    if(j - 1 >=  0 && board[i][j - 1] == \\'O\\') uf.union(id, index(col, i, j - 1));\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<row; i++)\\n            for(int j=0; j<col; j++)\\n                if(board[i][j] == \\'O\\' && !uf.connected(index(col, i, j), uf.virtualNode)) \\n                    board[i][j] = \\'X\\';\\n    }\\n    \\n    class UnionFind{\\n        int[] parent;\\n        int[] size;\\n        int virtualNode;\\n        \\n        UnionFind(int N, int M){\\n            virtualNode = N * M;\\n            parent = new int[N * M + 1]; //extra for the virtual Node\\n            size = new int[N * M + 1]; \\n            for(int i=0; i< N * M +1; i++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        \\n        int find(int i){\\n            while(i != parent[i]){\\n                parent[i] = parent[parent[i]]; // compress\\n                i = parent[i];\\n            }\\n            return i;\\n        }\\n        boolean connected(int p, int q){\\n            return find(p) == find(q);\\n        }\\n        void union(int p, int q){\\n            int rootP = find(p);\\n            int rootQ = find(q);\\n            if(rootP == rootQ) return; //the same parent\\n            \\n            if(size[rootP] < size[rootQ]){\\n                parent[rootP] = rootQ;\\n                size[rootQ] += size[rootP];\\n            }else{\\n                parent[rootQ] = rootP;\\n                size[rootP] += size[rootQ];\\n            }\\n        }\\n    }\\n    int index(int col, int i, int j){\\n        return i * col + j;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    // Union Find \\n    // Intuition: \\n    //       - We need to separate \\'O\\' in the borders from the other \\'O\\'\\n    //       - So, if a node \\'O\\' is on the border connect it to the virtual node.\\n    //       - All the others \\'O\\' connect to their \\'O\\' neighbors. (eventually, if they are tied to a border \\'O\\', they will connect)\\n    //       - After that, traverse the board, flipping the \\'O\\' *** NOT *** connected to the virtual.\\n    \\n    public void solve(char[][] board) {\\n        if(board == null || board.length == 0) return;\\n        int row = board.length;\\n        int col = board[0].length;\\n        UnionFind uf = new UnionFind(row, col);\\n        for(int i=0; i<row; i++){\\n            for(int j=0; j<col; j++){\\n                \\n                //Is boarder? Is \\'O\\'? ... connect to the virtual.\\n                if((i == 0 || j == 0 || i == row - 1 || j == col - 1) && (board[i][j] == \\'O\\')){\\n                    uf.union(uf.virtualNode, index(col, i, j)); //connect to virtual\\n                    continue;\\n                } \\n                \\n                //not border, but \\'O\\'\\n                if(board[i][j] == \\'O\\') {\\n                    int id = index(col, i, j);\\n                    // connect the neighbors\\n                    if(i + 1 < row && board[i + 1][j] == \\'O\\') uf.union(id, index(col, i + 1, j));\\n                    if(i - 1 >=  0 && board[i - 1][j] == \\'O\\') uf.union(id, index(col, i - 1, j));\\n                    if(j + 1 < col && board[i][j + 1] == \\'O\\') uf.union(id, index(col, i, j + 1));\\n                    if(j - 1 >=  0 && board[i][j - 1] == \\'O\\') uf.union(id, index(col, i, j - 1));\\n                }\\n            }\\n        }\\n        \\n        for(int i=0; i<row; i++)\\n            for(int j=0; j<col; j++)\\n                if(board[i][j] == \\'O\\' && !uf.connected(index(col, i, j), uf.virtualNode)) \\n                    board[i][j] = \\'X\\';\\n    }\\n    \\n    class UnionFind{\\n        int[] parent;\\n        int[] size;\\n        int virtualNode;\\n        \\n        UnionFind(int N, int M){\\n            virtualNode = N * M;\\n            parent = new int[N * M + 1]; //extra for the virtual Node\\n            size = new int[N * M + 1]; \\n            for(int i=0; i< N * M +1; i++){\\n                parent[i] = i;\\n                size[i] = 1;\\n            }\\n        }\\n        \\n        int find(int i){\\n            while(i != parent[i]){\\n                parent[i] = parent[parent[i]]; // compress\\n                i = parent[i];\\n            }\\n            return i;\\n        }\\n        boolean connected(int p, int q){\\n            return find(p) == find(q);\\n        }\\n        void union(int p, int q){\\n            int rootP = find(p);\\n            int rootQ = find(q);\\n            if(rootP == rootQ) return; //the same parent\\n            \\n            if(size[rootP] < size[rootQ]){\\n                parent[rootP] = rootQ;\\n                size[rootQ] += size[rootP];\\n            }else{\\n                parent[rootQ] = rootP;\\n                size[rootP] += size[rootQ];\\n            }\\n        }\\n    }\\n    int index(int col, int i, int j){\\n        return i * col + j;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 548196,
                "title": "java-dfs-union-find-union-find-rank",
                "content": "```\\n/*\\n * Approach1 Logical Thinking We aim to set all O\\'s which doesn\\'t locate at\\n * borders or connect to O at borders to X. We mark all O\\'s at borders and apply\\n * DFS at each O at boarders to mark all O\\'s connected to it. The un-marked O\\'s\\n * ought to be set X.\\n * \\n * Trick We search for invalid candidates (and exclude them) rather than search\\n * for valid candidates.\\n */\\nboolean[][] visited;\\n\\npublic void solve(char[][] board) {\\n\\n\\tif (board == null || board.length == 0 || board[0].length == 0) {\\n\\t\\treturn;\\n\\t}\\n\\n\\tint rows = board.length, cols = board[0].length;\\n\\tvisited = new boolean[rows][cols];\\n\\n\\t// check first and last column\\n\\tfor (int i = 0; i < rows; i++) {\\n\\n\\t\\tif (board[i][0] == \\'O\\' && !visited[i][0]) {\\n\\t\\t\\tdetectConnected(i, 0, board);\\n\\t\\t}\\n\\n\\t\\tif (board[i][cols - 1] == \\'O\\' && !visited[i][cols - 1]) {\\n\\t\\t\\tdetectConnected(i, cols - 1, board);\\n\\t\\t}\\n\\t}\\n\\n\\t// check first and last row\\n\\tfor (int j = 0; j < cols; j++) {\\n\\n\\t\\tif (board[0][j] == \\'O\\' && !visited[0][j]) {\\n\\t\\t\\tdetectConnected(0, j, board);\\n\\t\\t}\\n\\n\\t\\tif (board[rows - 1][j] == \\'O\\' && !visited[rows - 1][j]) {\\n\\t\\t\\tdetectConnected(rows - 1, j, board);\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int i = 0; i < rows; i++) {\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tif (board[i][j] == \\'O\\' && !visited[i][j]) {\\n\\t\\t\\t\\tboard[i][j] = \\'X\\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\n// function to set all nodes to visited true, if they are connected to \\'O\\' on\\n// the border\\nprivate void detectConnected(int x, int y, char[][] board) {\\n\\n\\tif (x < 0 || x >= board.length || y < 0 || y >= board[0].length || visited[x][y] || board[x][y] != \\'O\\') {\\n\\t\\treturn;\\n\\t}\\n\\n\\tvisited[x][y] = true;\\n\\n\\tdetectConnected(x + 1, y, board);\\n\\tdetectConnected(x, y + 1, board);\\n\\tdetectConnected(x - 1, y, board);\\n\\tdetectConnected(x, y - 1, board);\\n}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t/**********************\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t * Approach2: Union-Find\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t ********************/\\n/*\\n * Approach2: https://leetcode.com/problems/surrounded-regions/discuss/167165/Java-Union-Find-with-Explanations\\n * We aim to find all \\'O\\'s such that it is on the\\n * border or it is connected to an \\'O\\' on the border. If we regard \\'O\\' mentioned\\n * above as a node (or an element), the problem becomes to find the connected\\n * components (or disjoint sets) connected to borders. So-called borders should\\n * also be represented as an element, so elements connected to it can be merged\\n * with it into a set. That\\'s the usage of dummyBorder.\\n * \\n * \\t\\tfor O in board\\n\\t\\t\\tif O is on border\\n\\t\\t\\t\\tunion(dummyBorder, O)\\n\\t\\t\\telse\\n\\t\\t\\t\\tfor neighbour of O\\n\\t\\t\\t\\t\\tif (neighbour is \\'O\\') \\n\\t\\t\\t\\t\\t\\tunion(neighbour, O)\\n\\n\\t\\tfor each cell\\n\\t\\t\\tif cell is \\'O\\' && (find(cel) != find(dummyBorder))\\n\\t\\t\\t\\tflip\\n */\\nprivate static int[][] directions = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };\\n\\npublic void solveApproach2(char[][] board) {\\n\\n\\tif (board == null || board.length == 0) {\\n\\t\\treturn;\\n\\t}\\n\\n\\tUnionFindRank disjointSets = new UnionFindRank(board);\\n\\tint rows = board.length, cols = board[0].length;\\n\\tint dummyBorder = rows * cols;\\n\\n\\tfor (int x = 0; x < rows; x++) {\\n\\t\\tfor (int y = 0; y < cols; y++) {\\n\\t\\t\\tif (board[x][y] == \\'O\\') {\\n\\t\\t\\t\\tint borderO = x * cols + y;\\n\\t\\t\\t\\tif (x == 0 || x == rows - 1 || y == 0 || y == cols - 1) {\\n\\t\\t\\t\\t\\tdisjointSets.union(dummyBorder, borderO);\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (int[] dir : directions) {\\n\\t\\t\\t\\t\\tint nx = x + dir[0];\\n\\t\\t\\t\\t\\tint ny = y + dir[1];\\n\\t\\t\\t\\t\\tif (nx >= 0 && ny >= 0 && nx < rows && ny < cols && board[nx][ny] == \\'O\\') {\\n\\t\\t\\t\\t\\t\\tint neighbor = nx * cols + ny;\\n\\t\\t\\t\\t\\t\\tdisjointSets.union(borderO, neighbor);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int x = 0; x < rows; x++) {\\n\\t\\tfor (int y = 0; y < cols; y++) {\\n\\t\\t\\tif (board[x][y] == \\'O\\' && disjointSets.find(x * cols + y) != disjointSets.find(dummyBorder)) {\\n\\t\\t\\t\\tboard[x][y] = \\'X\\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n}\\n\\n// based on Quick Union\\nclass UnionFind {\\n\\n\\tint[] parents;\\n\\n\\tpublic UnionFind(char[][] board) {\\n\\n\\t\\tint rows = board.length, cols = board[0].length;\\n\\t\\tparents = new int[rows * cols + 1];\\n\\n\\t\\tfor (int x = 0; x < rows; x++) {\\n\\t\\t\\tfor (int y = 0; y < cols; y++) {\\n\\t\\t\\t\\tif (board[x][y] == \\'O\\') {\\n\\t\\t\\t\\t\\tint id = x * cols + y;\\n\\t\\t\\t\\t\\tparents[id] = id;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tparents[rows * cols] = rows * cols;\\n\\t}\\n\\n\\tpublic int find(int x) {\\n\\n\\t\\tif (x != parents[x])\\n\\t\\t\\tx = find(parents[x]);\\n\\t\\treturn parents[x];\\n\\t}\\n\\n\\tpublic void union(int x, int y) {\\n\\n\\t\\tint rootX = find(x);\\n\\t\\tint rootY = find(y);\\n\\t\\tif (rootX != rootY) {\\n\\t\\t\\tparents[rootX] = rootY;\\n\\t\\t}\\n\\t}\\n}\\n\\n// A more optimised approach: based on Quick Union Ranking\\nclass UnionFindRank {\\n\\tint[] parents;\\n\\tint[] ranks;\\n\\n\\tpublic UnionFindRank(char[][] board) {\\n\\t\\tint rows = board.length, cols = board[0].length;\\n\\t\\tint n = rows * cols + 1;\\n\\t\\tparents = new int[n];\\n\\t\\tranks = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tparents[i] = i;\\n\\t}\\n\\n\\tprivate int find(int x) {\\n\\t\\tif (x != parents[x])\\n\\t\\t\\tx = find(parents[x]);\\n\\t\\treturn parents[x];\\n\\t}\\n\\n\\tprivate void union(int x, int y) {\\n\\t\\tint px = find(x);\\n\\t\\tint py = find(y);\\n\\t\\tif (px != py) {\\n\\t\\t\\tif (ranks[px] > ranks[py]) {\\n\\t\\t\\t\\tparents[py] = px;\\n\\t\\t\\t\\tranks[px]++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tparents[px] = py;\\n\\t\\t\\t\\tranks[py]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}",
                "solutionTags": [],
                "code": "```\\n/*\\n * Approach1 Logical Thinking We aim to set all O\\'s which doesn\\'t locate at\\n * borders or connect to O at borders to X. We mark all O\\'s at borders and apply\\n * DFS at each O at boarders to mark all O\\'s connected to it. The un-marked O\\'s\\n * ought to be set X.\\n * \\n * Trick We search for invalid candidates (and exclude them) rather than search\\n * for valid candidates.\\n */\\nboolean[][] visited;\\n\\npublic void solve(char[][] board) {\\n\\n\\tif (board == null || board.length == 0 || board[0].length == 0) {\\n\\t\\treturn;\\n\\t}\\n\\n\\tint rows = board.length, cols = board[0].length;\\n\\tvisited = new boolean[rows][cols];\\n\\n\\t// check first and last column\\n\\tfor (int i = 0; i < rows; i++) {\\n\\n\\t\\tif (board[i][0] == \\'O\\' && !visited[i][0]) {\\n\\t\\t\\tdetectConnected(i, 0, board);\\n\\t\\t}\\n\\n\\t\\tif (board[i][cols - 1] == \\'O\\' && !visited[i][cols - 1]) {\\n\\t\\t\\tdetectConnected(i, cols - 1, board);\\n\\t\\t}\\n\\t}\\n\\n\\t// check first and last row\\n\\tfor (int j = 0; j < cols; j++) {\\n\\n\\t\\tif (board[0][j] == \\'O\\' && !visited[0][j]) {\\n\\t\\t\\tdetectConnected(0, j, board);\\n\\t\\t}\\n\\n\\t\\tif (board[rows - 1][j] == \\'O\\' && !visited[rows - 1][j]) {\\n\\t\\t\\tdetectConnected(rows - 1, j, board);\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int i = 0; i < rows; i++) {\\n\\t\\tfor (int j = 0; j < cols; j++) {\\n\\t\\t\\tif (board[i][j] == \\'O\\' && !visited[i][j]) {\\n\\t\\t\\t\\tboard[i][j] = \\'X\\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}\\n\\n// function to set all nodes to visited true, if they are connected to \\'O\\' on\\n// the border\\nprivate void detectConnected(int x, int y, char[][] board) {\\n\\n\\tif (x < 0 || x >= board.length || y < 0 || y >= board[0].length || visited[x][y] || board[x][y] != \\'O\\') {\\n\\t\\treturn;\\n\\t}\\n\\n\\tvisited[x][y] = true;\\n\\n\\tdetectConnected(x + 1, y, board);\\n\\tdetectConnected(x, y + 1, board);\\n\\tdetectConnected(x - 1, y, board);\\n\\tdetectConnected(x, y - 1, board);\\n}\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t/**********************\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t * Approach2: Union-Find\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t ********************/\\n/*\\n * Approach2: https://leetcode.com/problems/surrounded-regions/discuss/167165/Java-Union-Find-with-Explanations\\n * We aim to find all \\'O\\'s such that it is on the\\n * border or it is connected to an \\'O\\' on the border. If we regard \\'O\\' mentioned\\n * above as a node (or an element), the problem becomes to find the connected\\n * components (or disjoint sets) connected to borders. So-called borders should\\n * also be represented as an element, so elements connected to it can be merged\\n * with it into a set. That\\'s the usage of dummyBorder.\\n * \\n * \\t\\tfor O in board\\n\\t\\t\\tif O is on border\\n\\t\\t\\t\\tunion(dummyBorder, O)\\n\\t\\t\\telse\\n\\t\\t\\t\\tfor neighbour of O\\n\\t\\t\\t\\t\\tif (neighbour is \\'O\\') \\n\\t\\t\\t\\t\\t\\tunion(neighbour, O)\\n\\n\\t\\tfor each cell\\n\\t\\t\\tif cell is \\'O\\' && (find(cel) != find(dummyBorder))\\n\\t\\t\\t\\tflip\\n */\\nprivate static int[][] directions = { { 0, 1 }, { 0, -1 }, { 1, 0 }, { -1, 0 } };\\n\\npublic void solveApproach2(char[][] board) {\\n\\n\\tif (board == null || board.length == 0) {\\n\\t\\treturn;\\n\\t}\\n\\n\\tUnionFindRank disjointSets = new UnionFindRank(board);\\n\\tint rows = board.length, cols = board[0].length;\\n\\tint dummyBorder = rows * cols;\\n\\n\\tfor (int x = 0; x < rows; x++) {\\n\\t\\tfor (int y = 0; y < cols; y++) {\\n\\t\\t\\tif (board[x][y] == \\'O\\') {\\n\\t\\t\\t\\tint borderO = x * cols + y;\\n\\t\\t\\t\\tif (x == 0 || x == rows - 1 || y == 0 || y == cols - 1) {\\n\\t\\t\\t\\t\\tdisjointSets.union(dummyBorder, borderO);\\n\\t\\t\\t\\t\\tcontinue;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tfor (int[] dir : directions) {\\n\\t\\t\\t\\t\\tint nx = x + dir[0];\\n\\t\\t\\t\\t\\tint ny = y + dir[1];\\n\\t\\t\\t\\t\\tif (nx >= 0 && ny >= 0 && nx < rows && ny < cols && board[nx][ny] == \\'O\\') {\\n\\t\\t\\t\\t\\t\\tint neighbor = nx * cols + ny;\\n\\t\\t\\t\\t\\t\\tdisjointSets.union(borderO, neighbor);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\tfor (int x = 0; x < rows; x++) {\\n\\t\\tfor (int y = 0; y < cols; y++) {\\n\\t\\t\\tif (board[x][y] == \\'O\\' && disjointSets.find(x * cols + y) != disjointSets.find(dummyBorder)) {\\n\\t\\t\\t\\tboard[x][y] = \\'X\\';\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n}\\n\\n// based on Quick Union\\nclass UnionFind {\\n\\n\\tint[] parents;\\n\\n\\tpublic UnionFind(char[][] board) {\\n\\n\\t\\tint rows = board.length, cols = board[0].length;\\n\\t\\tparents = new int[rows * cols + 1];\\n\\n\\t\\tfor (int x = 0; x < rows; x++) {\\n\\t\\t\\tfor (int y = 0; y < cols; y++) {\\n\\t\\t\\t\\tif (board[x][y] == \\'O\\') {\\n\\t\\t\\t\\t\\tint id = x * cols + y;\\n\\t\\t\\t\\t\\tparents[id] = id;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tparents[rows * cols] = rows * cols;\\n\\t}\\n\\n\\tpublic int find(int x) {\\n\\n\\t\\tif (x != parents[x])\\n\\t\\t\\tx = find(parents[x]);\\n\\t\\treturn parents[x];\\n\\t}\\n\\n\\tpublic void union(int x, int y) {\\n\\n\\t\\tint rootX = find(x);\\n\\t\\tint rootY = find(y);\\n\\t\\tif (rootX != rootY) {\\n\\t\\t\\tparents[rootX] = rootY;\\n\\t\\t}\\n\\t}\\n}\\n\\n// A more optimised approach: based on Quick Union Ranking\\nclass UnionFindRank {\\n\\tint[] parents;\\n\\tint[] ranks;\\n\\n\\tpublic UnionFindRank(char[][] board) {\\n\\t\\tint rows = board.length, cols = board[0].length;\\n\\t\\tint n = rows * cols + 1;\\n\\t\\tparents = new int[n];\\n\\t\\tranks = new int[n];\\n\\t\\tfor (int i = 0; i < n; i++)\\n\\t\\t\\tparents[i] = i;\\n\\t}\\n\\n\\tprivate int find(int x) {\\n\\t\\tif (x != parents[x])\\n\\t\\t\\tx = find(parents[x]);\\n\\t\\treturn parents[x];\\n\\t}\\n\\n\\tprivate void union(int x, int y) {\\n\\t\\tint px = find(x);\\n\\t\\tint py = find(y);\\n\\t\\tif (px != py) {\\n\\t\\t\\tif (ranks[px] > ranks[py]) {\\n\\t\\t\\t\\tparents[py] = px;\\n\\t\\t\\t\\tranks[px]++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tparents[px] = py;\\n\\t\\t\\t\\tranks[py]++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n}",
                "codeTag": "Java"
            },
            {
                "id": 288053,
                "title": "union-find-algorithm",
                "content": "The problem asks us to flip inner `\"O\"`s, which does not connect to any border `\"O\"`s. If we connect adjacent `\"O\"`s and join them in the same set(i.e. **union** adjacent `\"O\"`s), we can **find** if a `\"O\"` is in the same set with any border `\"O\"`.  This solution can be splited into three steps:\\n```\\nX X X X\\nO O X X\\nX X O X\\nX O X X\\n1. Initialize disjoint set: Each element belongs to a single set\\n0   1  2  3\\n4   5  6  7\\n8   9 10 11\\n12 13 14 15\\n\\n2.  Traver the board, if the element is \\'O\\', union it with its neighbors. \\n\\tHere we change the 5th number to 4, indicates they belongs to the same set.\\n\\tSince there are no elements can connect to its neighbors, we go to the 3rd step directly.\\n0   1  2  3\\n4   4  6  7\\n8   9 10 11\\n12 13 14 15\\n\\n3. Record border \"O\" \\'s set.\\n\\tborder sets in this case: 4,13\\n\\tcheck each inner \\'O\\', if  not connect to any elements in border sets, flip it. \\n\\tIn this case, we checked the 5th and 10th element in board and fliped the 10th element.\\n\\tX X X X\\n\\tO O X X\\n\\tX X \\'X\\' X\\n\\tX O X X\\n\\n```\\nA very naive union find realization.\\n```\\nclass DisjointSet{\\n    private:\\n        int* parent;\\n    public:\\n        DisjointSet(int size){\\n            parent = new int[size];\\n            for(int i = 0; i < size; i++)\\n                    parent[i] = i;\\n        }\\n        ~DisjointSet(){\\n            delete [] parent;\\n        }\\n        void Union(int p, int q){\\n            int pRoot = Find(p);\\n            int qRoot = Find(q);\\n            parent[pRoot] = qRoot;\\n        }\\n        int Find(int p){\\n            while(parent[p] != p)\\n                p = parent[p];\\n            return p;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int rows = board.size();\\n        if(rows == 0) return ;\\n        int cols = board[0].size();\\n        if(rows == 1 || cols == 1)return;\\n        DisjointSet ds(rows * cols);\\n\\t\\t// #1 Union adjacents \\'O\\'s\\n        for(int i = 1 ; i < rows - 1; i++){\\n            for(int j = 1; j < cols -1; j++){\\n                if(board[i][j] == \\'O\\')\\n                {\\n                    int curPos = i * cols + j;\\n                    if(board[i-1][j] == \\'O\\')\\n                        ds.Union(curPos, (i - 1) * cols + j);\\n                    if(board[i+1][j] == \\'O\\')\\n                        ds.Union(curPos, (i + 1) * cols + j);\\n                    if(board[i][j - 1] == \\'O\\')\\n                        ds.Union(curPos, curPos - 1);\\n                    if(board[i][j + 1] == \\'O\\')\\n                        ds.Union(curPos, curPos + 1);\\n                }\\n            }\\n        }\\n\\t\\t// #2 Record border \"O\" \\'s set\\n        set<int> borderSetRoot;\\n        for(int i = 0 ; i < rows; i+=rows-1)\\n            for(int j = 0; j < cols; j++)\\n                if(board[i][j] == \\'O\\')\\n                {\\n                    \\n                    borderSetRoot.insert(ds.Find( i * cols + j));\\n                }\\n        for(int i = 1 ; i < rows - 1; i++)\\n            for(int j = 0; j < cols; j+=cols-1)\\n                if(board[i][j] == \\'O\\')\\n                {\\n                    \\n                    borderSetRoot.insert(ds.Find( i * cols + j));\\n                }\\n                    \\n        // #3 Flip \"O\"s not in border set\\n        for(int i = 1 ; i < rows - 1; i++){\\n            for(int j = 1; j < cols -1; j++){\\n                if(board[i][j] == \\'O\\')\\n                {\\n                    int curPos = i * cols + j;                   \\n                    if(borderSetRoot.find(ds.Find(curPos)) == borderSetRoot.end())\\n                        board[i][j] = \\'X\\';\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nX X X X\\nO O X X\\nX X O X\\nX O X X\\n1. Initialize disjoint set: Each element belongs to a single set\\n0   1  2  3\\n4   5  6  7\\n8   9 10 11\\n12 13 14 15\\n\\n2.  Traver the board, if the element is \\'O\\', union it with its neighbors. \\n\\tHere we change the 5th number to 4, indicates they belongs to the same set.\\n\\tSince there are no elements can connect to its neighbors, we go to the 3rd step directly.\\n0   1  2  3\\n4   4  6  7\\n8   9 10 11\\n12 13 14 15\\n\\n3. Record border \"O\" \\'s set.\\n\\tborder sets in this case: 4,13\\n\\tcheck each inner \\'O\\', if  not connect to any elements in border sets, flip it. \\n\\tIn this case, we checked the 5th and 10th element in board and fliped the 10th element.\\n\\tX X X X\\n\\tO O X X\\n\\tX X \\'X\\' X\\n\\tX O X X\\n\\n```\n```\\nclass DisjointSet{\\n    private:\\n        int* parent;\\n    public:\\n        DisjointSet(int size){\\n            parent = new int[size];\\n            for(int i = 0; i < size; i++)\\n                    parent[i] = i;\\n        }\\n        ~DisjointSet(){\\n            delete [] parent;\\n        }\\n        void Union(int p, int q){\\n            int pRoot = Find(p);\\n            int qRoot = Find(q);\\n            parent[pRoot] = qRoot;\\n        }\\n        int Find(int p){\\n            while(parent[p] != p)\\n                p = parent[p];\\n            return p;\\n        }\\n};\\n\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int rows = board.size();\\n        if(rows == 0) return ;\\n        int cols = board[0].size();\\n        if(rows == 1 || cols == 1)return;\\n        DisjointSet ds(rows * cols);\\n\\t\\t// #1 Union adjacents \\'O\\'s\\n        for(int i = 1 ; i < rows - 1; i++){\\n            for(int j = 1; j < cols -1; j++){\\n                if(board[i][j] == \\'O\\')\\n                {\\n                    int curPos = i * cols + j;\\n                    if(board[i-1][j] == \\'O\\')\\n                        ds.Union(curPos, (i - 1) * cols + j);\\n                    if(board[i+1][j] == \\'O\\')\\n                        ds.Union(curPos, (i + 1) * cols + j);\\n                    if(board[i][j - 1] == \\'O\\')\\n                        ds.Union(curPos, curPos - 1);\\n                    if(board[i][j + 1] == \\'O\\')\\n                        ds.Union(curPos, curPos + 1);\\n                }\\n            }\\n        }\\n\\t\\t// #2 Record border \"O\" \\'s set\\n        set<int> borderSetRoot;\\n        for(int i = 0 ; i < rows; i+=rows-1)\\n            for(int j = 0; j < cols; j++)\\n                if(board[i][j] == \\'O\\')\\n                {\\n                    \\n                    borderSetRoot.insert(ds.Find( i * cols + j));\\n                }\\n        for(int i = 1 ; i < rows - 1; i++)\\n            for(int j = 0; j < cols; j+=cols-1)\\n                if(board[i][j] == \\'O\\')\\n                {\\n                    \\n                    borderSetRoot.insert(ds.Find( i * cols + j));\\n                }\\n                    \\n        // #3 Flip \"O\"s not in border set\\n        for(int i = 1 ; i < rows - 1; i++){\\n            for(int j = 1; j < cols -1; j++){\\n                if(board[i][j] == \\'O\\')\\n                {\\n                    int curPos = i * cols + j;                   \\n                    if(borderSetRoot.find(ds.Find(curPos)) == borderSetRoot.end())\\n                        board[i][j] = \\'X\\';\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 216917,
                "title": "javascript-solution",
                "content": "```\\n/**\\n * @param {character[][]} board\\n * @return {void} Do not return anything, modify board in-place instead.\\n */\\nvar solve = function(board) {\\n  if (board === null || board.length === 0 || board[0].length === 0) return;\\n  for (let i = 0; i< board.length; i++) {\\n    for (let j = 0; j < board[0].length; j++) {\\n      if (i === 0 || j === 0 || i === board.length - 1 || j === board[0].length -1) {\\n        dfs(board, i, j);\\n      }\\n    }\\n  }\\n  \\n  for (let i = 0; i< board.length; i++) {\\n    for (let j = 0; j < board[0].length; j++) {\\n      if (board[i][j] === \\'T\\') {\\n        board[i][j] = \\'O\\';\\n      } else if (board[i][j] === \\'O\\') {\\n        board[i][j] = \\'X\\';\\n      }\\n    }\\n  }\\n};\\n\\nfunction dfs(board, row, col) {\\n  if (row < 0 || col < 0 || row >= board.length || col >= board[0].length) return;\\n  if (board[row][col] === \\'O\\') {\\n    board[row][col] = \\'T\\';\\n    dfs(board, row + 1, col);\\n    dfs(board, row - 1, col);\\n    dfs(board, row, col - 1);\\n    dfs(board, row, col + 1);\\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {character[][]} board\\n * @return {void} Do not return anything, modify board in-place instead.\\n */\\nvar solve = function(board) {\\n  if (board === null || board.length === 0 || board[0].length === 0) return;\\n  for (let i = 0; i< board.length; i++) {\\n    for (let j = 0; j < board[0].length; j++) {\\n      if (i === 0 || j === 0 || i === board.length - 1 || j === board[0].length -1) {\\n        dfs(board, i, j);\\n      }\\n    }\\n  }\\n  \\n  for (let i = 0; i< board.length; i++) {\\n    for (let j = 0; j < board[0].length; j++) {\\n      if (board[i][j] === \\'T\\') {\\n        board[i][j] = \\'O\\';\\n      } else if (board[i][j] === \\'O\\') {\\n        board[i][j] = \\'X\\';\\n      }\\n    }\\n  }\\n};\\n\\nfunction dfs(board, row, col) {\\n  if (row < 0 || col < 0 || row >= board.length || col >= board[0].length) return;\\n  if (board[row][col] === \\'O\\') {\\n    board[row][col] = \\'T\\';\\n    dfs(board, row + 1, col);\\n    dfs(board, row - 1, col);\\n    dfs(board, row, col - 1);\\n    dfs(board, row, col + 1);\\n  }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 171506,
                "title": "it-s-important-to-master-all-3-methods-dfs-bfs-union-find",
                "content": "```\\nclass Solution_DFS:\\n    def solve(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: void Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        alive,v = set(),set()\\n        for r in range(len(board)):\\n            for c in range(len(board[r])):\\n                if r==0 or r==len(board)-1 or c==0 or c==len(board[0])-1:\\n                    self.traverse(board,r,c,alive)   \\n        for r in range(len(board)):\\n            for c in range(len(board[r])):\\n                if board[r][c]==\\'O\\' and (r,c) not in alive:\\n                    board[r][c] = \\'X\\'\\n                \\n    def traverse(self,board,r,c,alive):    \\n        if (r,c) in alive or r<0 or r>len(board)-1 or c<0 or c>len(board[0])-1 or board[r][c] != \\'O\\' :    \\n            return\\n        else:        \\n            alive.add((r,c))            \\n            self.traverse(board,r+1,c,alive)\\n            self.traverse(board,r,c+1,alive)\\n            self.traverse(board,r-1,c,alive)\\n            self.traverse(board,r,c-1,alive)\\n\\nclass Solution_UF:\\n    def solve(self, board):\\n        parents={}\\n        for r in range(len(board)):\\n            for c in range(len(board[r])):\\n                if r==0 or r==len(board)-1 or c==0 or c==len(board[0])-1:\\n                    self.traverse(board,parents,r,c,-1,-1)\\n\\n        for r in range(len(board)):\\n            for c in range(len(board[r])):\\n                if board[r][c]==\\'O\\' and parents.get((r,c)) != (-1,-1):\\n                    board[r][c] = \\'X\\'\\n                    \\n    def traverse(self,board,parents,r,c,pr,pc):    \\n        if (r,c) in parents or r<0 or r>len(board)-1 or c<0 or c>len(board[0])-1 or board[r][c] != \\'O\\' :    \\n            return\\n        else:        \\n            parentCurr=self.find((r,c),parents)\\n            parentPrev=self.find((pr,pc),parents)\\n            if parentCurr != parentPrev:\\n                parents[parentCurr] = parentPrev\\n            self.traverse(board,parents,r+1,c,r,c)\\n            self.traverse(board,parents,r-1,c,r,c)\\n            self.traverse(board,parents,r,c+1,r,c)\\n            self.traverse(board,parents,r,c-1,r,c)\\n\\n    def find(self,node,parents):\\n        if node not in parents:\\n            parents[node] = node\\n            return node\\n        if parents[node]!=node:\\n            parents[node]=self.find(parents[node],parents)\\n        return parents[node]\\n    \\nclass Solution_BFS:\\n    #Iterative BFS\\n    #Temporarily turn \\'reachable O cells form border\\' into \\'#\\', then any \\'#\\' is restored to \\'O\\', and any \\'O\\' is changed to \\'X\\'.\\n    def solve(self,board):\\n        for r in range(len(board)):\\n            for c in range(len(board[r])):\\n                if r==0 or r==len(board)-1 or c==0 or c==len(board[0])-1:\\n                    self.traverse(board,r,c)\\n\\n        for r in range(len(board)):\\n            for c in range(len(board[r])):\\n                if board[r][c]==\\'O\\':\\n                    board[r][c] = \\'X\\'\\n                elif board[r][c]==\\'#\\':\\n                    board[r][c] = \\'O\\'\\n\\n    def traverse(self,board,r,c):\\n        q=collections.deque()\\n        if board[r][c]==\\'O\\':\\n            q.append((r,c))\\n        while q:\\n            c = q.popleft()\\n            r,c=c[0],c[1]\\n            if r>=0 and r<len(board) and c>=0 and c<len(board[0]) and board[r][c]==\\'O\\':\\n                board[r][c]=\\'#\\'\\n                q.append((r+1,c))\\n                q.append((r-1,c))\\n                q.append((r,c+1))\\n                q.append((r,c-1))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution_DFS:\\n    def solve(self, board):\\n        \"\"\"\\n        :type board: List[List[str]]\\n        :rtype: void Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        alive,v = set(),set()\\n        for r in range(len(board)):\\n            for c in range(len(board[r])):\\n                if r==0 or r==len(board)-1 or c==0 or c==len(board[0])-1:\\n                    self.traverse(board,r,c,alive)   \\n        for r in range(len(board)):\\n            for c in range(len(board[r])):\\n                if board[r][c]==\\'O\\' and (r,c) not in alive:\\n                    board[r][c] = \\'X\\'\\n                \\n    def traverse(self,board,r,c,alive):    \\n        if (r,c) in alive or r<0 or r>len(board)-1 or c<0 or c>len(board[0])-1 or board[r][c] != \\'O\\' :    \\n            return\\n        else:        \\n            alive.add((r,c))            \\n            self.traverse(board,r+1,c,alive)\\n            self.traverse(board,r,c+1,alive)\\n            self.traverse(board,r-1,c,alive)\\n            self.traverse(board,r,c-1,alive)\\n\\nclass Solution_UF:\\n    def solve(self, board):\\n        parents={}\\n        for r in range(len(board)):\\n            for c in range(len(board[r])):\\n                if r==0 or r==len(board)-1 or c==0 or c==len(board[0])-1:\\n                    self.traverse(board,parents,r,c,-1,-1)\\n\\n        for r in range(len(board)):\\n            for c in range(len(board[r])):\\n                if board[r][c]==\\'O\\' and parents.get((r,c)) != (-1,-1):\\n                    board[r][c] = \\'X\\'\\n                    \\n    def traverse(self,board,parents,r,c,pr,pc):    \\n        if (r,c) in parents or r<0 or r>len(board)-1 or c<0 or c>len(board[0])-1 or board[r][c] != \\'O\\' :    \\n            return\\n        else:        \\n            parentCurr=self.find((r,c),parents)\\n            parentPrev=self.find((pr,pc),parents)\\n            if parentCurr != parentPrev:\\n                parents[parentCurr] = parentPrev\\n            self.traverse(board,parents,r+1,c,r,c)\\n            self.traverse(board,parents,r-1,c,r,c)\\n            self.traverse(board,parents,r,c+1,r,c)\\n            self.traverse(board,parents,r,c-1,r,c)\\n\\n    def find(self,node,parents):\\n        if node not in parents:\\n            parents[node] = node\\n            return node\\n        if parents[node]!=node:\\n            parents[node]=self.find(parents[node],parents)\\n        return parents[node]\\n    \\nclass Solution_BFS:\\n    #Iterative BFS\\n    #Temporarily turn \\'reachable O cells form border\\' into \\'#\\', then any \\'#\\' is restored to \\'O\\', and any \\'O\\' is changed to \\'X\\'.\\n    def solve(self,board):\\n        for r in range(len(board)):\\n            for c in range(len(board[r])):\\n                if r==0 or r==len(board)-1 or c==0 or c==len(board[0])-1:\\n                    self.traverse(board,r,c)\\n\\n        for r in range(len(board)):\\n            for c in range(len(board[r])):\\n                if board[r][c]==\\'O\\':\\n                    board[r][c] = \\'X\\'\\n                elif board[r][c]==\\'#\\':\\n                    board[r][c] = \\'O\\'\\n\\n    def traverse(self,board,r,c):\\n        q=collections.deque()\\n        if board[r][c]==\\'O\\':\\n            q.append((r,c))\\n        while q:\\n            c = q.popleft()\\n            r,c=c[0],c[1]\\n            if r>=0 and r<len(board) and c>=0 and c<len(board[0]) and board[r][c]==\\'O\\':\\n                board[r][c]=\\'#\\'\\n                q.append((r+1,c))\\n                q.append((r-1,c))\\n                q.append((r,c+1))\\n                q.append((r,c-1))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41789,
                "title": "bfs-based-solution-in-java",
                "content": "    /*\\n        dfs, bfs, union-find\\u90fd\\u53ef\\u4ee5\\u505a, \\u57fa\\u672c\\u601d\\u8def\\u662f\\n        \\u4ece\\u5728\\u56db\\u4e2a\\u8fb9\\u7684\\u5404\\u4e2a'O'\\u5f00\\u59cb\\u641c\\u7d22, \\u8fde\\u5728\\u4e00\\u8d77\\u7684'O'\\u5c31\\u662f\\u4e0d\\u80fd\\u88ab\\u5305\\u56f4\\u7684, \\u5176\\u4f59\\u7684\\u70b9\\u90fd\\u5e94\\u8be5\\u8bbe\\u4e3a'X'.\\n        \\n        \\u5982\\u679c\\u9009\\u62e9bfs, \\u53ef\\u4ee5\\u628a\\u6240\\u6709\\u8fb9\\u4e0a\\u7684\\u6240\\u6709'O'\\u4e00\\u8d77\\u5165\\u961f, \\u540c\\u65f6\\u8fdb\\u884cbfs\\n    */\\n    public class Solution {\\n        public void solve(char[][] board) {\\n            if (board == null || board.length == 0 || board[0].length == 0) return;\\n            int height = board.length, width = board[0].length;\\n            Deque<int[]> queue = new ArrayDeque<>();  // int[2] as [row, col]\\n            for (int i = 0; i < width; ++i) {\\n                if (board[0][i] == 'O') {\\n                    queue.addLast(new int[] {0, i});\\n                    board[0][i] = 'V';  // mark as visited\\n                }\\n                if (board[height - 1][i] == 'O') {\\n                    queue.addLast(new int[] {height - 1, i});\\n                    board[height - 1][i] = 'V';\\n                }\\n            }\\n            for (int i = 1; i < height - 1; ++i) {\\n                if (board[i][0] == 'O') {\\n                    queue.addLast(new int[] {i, 0});\\n                    board[i][0] = 'V';\\n                }\\n                if (board[i][width - 1] == 'O') {\\n                    queue.addLast(new int[] {i, width - 1});\\n                    board[i][width - 1] = 'V';\\n                }\\n            }\\n            while (!queue.isEmpty()) {\\n                int[] cur = queue.removeFirst();\\n                if (cur[0] - 1 >= 0 && board[cur[0] - 1][cur[1]] == 'O') {  // up\\n                    queue.addLast(new int[] {cur[0] - 1, cur[1]});\\n                    board[cur[0] - 1][cur[1]] = 'V';\\n                }\\n                if (cur[0] + 1 < height && board[cur[0] + 1][cur[1]] == 'O') {  // down\\n                    queue.addLast(new int[] {cur[0] + 1, cur[1]});\\n                    board[cur[0] + 1][cur[1]] = 'V';\\n                }\\n                if (cur[1] - 1 >= 0 && board[cur[0]][cur[1] - 1] == 'O') {  // left\\n                    queue.addLast(new int[] {cur[0], cur[1] - 1});\\n                    board[cur[0]][cur[1] - 1] = 'V';\\n                }\\n                if (cur[1] + 1 < width && board[cur[0]][cur[1] + 1] == 'O') {  // right\\n                    queue.addLast(new int[] {cur[0], cur[1] + 1});\\n                    board[cur[0]][cur[1] + 1] = 'V';\\n                }\\n            }\\n            for (int i = 0; i < height; ++i) {\\n                for (int j = 0; j < width; ++j) {\\n                    if (board[i][j] == 'O') board[i][j] = 'X';\\n                    else if (board[i][j] == 'V') board[i][j] = 'O';\\n                }\\n            }\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public void solve(char[][] board) {\\n            if (board == null || board.length == 0 || board[0].length == 0) return;\\n            int height = board.length, width = board[0].length;\\n            Deque<int[]> queue = new ArrayDeque<>();  // int[2] as [row, col]\\n            for (int i = 0; i < width; ++i) {\\n                if (board[0][i] == 'O') {\\n                    queue.addLast(new int[] {0, i}",
                "codeTag": "Java"
            },
            {
                "id": 41751,
                "title": "accepted-14ms-dfs-c-solution-and-16ms-bfs-c-solution",
                "content": "**Please pay special attention to the comment in the solutions\\uff01**\\n\\nDFS, 14ms:\\n\\n    class Solution {\\n    public:\\n        void solve(std::vector<std::vector<char> > &board) {\\n            if (board.empty())\\n                return;\\n            rows = static_cast<int>(board.size());\\n            cols = static_cast<int>(board[0].size());\\n            if (rows < 3 || cols < 3)\\n                return;\\n            for (int col = 0; col < cols; ++col) {\\n                if (board[0][col] == 'O')\\n                    solveDFS(board, 0, col);\\n                if (board[rows - 1][col] == 'O')\\n                    solveDFS(board, rows - 1, col);\\n            }\\n            for (int row = 1; row < rows - 1; ++row) {\\n                if (board[row][0] == 'O')\\n                    solveDFS(board, row, 0);\\n                if (board[row][cols - 1] == 'O')\\n                    solveDFS(board, row, cols - 1);\\n            }\\n            for (int row = 0; row < rows; ++row)\\n                for (int col = 0; col < cols; ++col) {\\n                    if (board[row][col] == 'O')\\n                        board[row][col] = 'X';\\n                    else if (board[row][col] == 'N')\\n                        board[row][col] = 'O';\\n                }\\n        }\\n    private:\\n        int rows;\\n        int cols;\\n        void solveDFS(std::vector<std::vector<char> > &board, int i, int j) {\\n            board[i][j] = 'N';\\n            // no need to consider the peripheral border, so the condition\\n            // is i > 1, i < rows - 2, not i > 0, i < rows - 1.\\n            //\\n            // if use i > 0, i < rows - 1, DFS solution will get a Runtime Error, confusing!\\n            if (i > 1 && board[i - 1][j] == 'O')\\n                solveDFS(board, i - 1, j);\\n            if (i < rows - 2 && board[i + 1][j] == 'O')\\n                solveDFS(board, i + 1, j);\\n            if (j > 1 && board[i][j - 1] == 'O')\\n                solveDFS(board, i, j - 1);\\n            if (j < cols - 2 && board[i][j + 1] == 'O')\\n                solveDFS(board, i, j + 1);\\n        }\\n    };\\n\\nBFS, 16ms:\\n\\n    class Solution {\\n    public:\\n        void solve(std::vector<std::vector<char> > &board) {\\n            if (board.empty())\\n                return;\\n            rows = static_cast<int>(board.size());\\n            cols = static_cast<int>(board[0].size());\\n            if (rows < 3 || cols < 3)\\n                return;\\n            for (int col = 0; col < cols; ++col) {\\n                if (board[0][col] == 'O')\\n                    solveBFS(board, 0, col);\\n                if (board[rows - 1][col] == 'O')\\n                    solveBFS(board, rows - 1, col);\\n            }\\n            for (int row = 1; row < rows - 1; ++row) {\\n                if (board[row][0] == 'O')\\n                    solveBFS(board, row, 0);\\n                if (board[row][cols - 1] == 'O')\\n                    solveBFS(board, row, cols - 1);\\n            }\\n            for (int row = 0; row < rows; ++row)\\n                for (int col = 0; col < cols; ++col) {\\n                    if (board[row][col] == 'O')\\n                        board[row][col] = 'X';\\n                    else if (board[row][col] == 'N')\\n                        board[row][col] = 'O';\\n                }\\n        }\\n    private:\\n        int rows, cols;\\n        void solveBFS(std::vector<std::vector<char> > &board, int i, int j) {\\n            board[i][j] = 'N';\\n    \\t\\tstd::queue<std::pair<int, int> > que;\\n            que.push(std::make_pair(i, j));\\n            while (!que.empty()) {\\n    \\t\\t\\tint row = que.front().first, col = que.front().second;\\n                que.pop();\\n                // no need to consider the peripheral border, so the condition\\n                // is i > 1, i < rows - 2, not i > 0, i < rows - 1.\\n                //\\n                // if use i > 0, i < rows - 1, BFS solution will be accepted too.\\n                if (row > 1 && board[row - 1][col] == 'O') {\\n                    board[row - 1][col] = 'N';\\n                    que.push(std::make_pair(row - 1, col));\\n                }\\n                if (row < rows - 2 && board[row + 1][col] == 'O') {\\n                    board[row + 1][col] = 'N';\\n                    que.push(std::make_pair(row + 1, col));\\n                }\\n                if (col > 1 && board[row][col - 1] == 'O') {\\n                    board[row][col - 1] = 'N';\\n                    que.push(std::make_pair(row, col - 1));\\n                }\\n                if (col < cols - 2 && board[row][col + 1] == 'O') {\\n                    board[row][col + 1] = 'N';\\n                    que.push(std::make_pair(row, col + 1));\\n                }\\n            }\\n        }\\n    };",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    public:\\n        void solve(std::vector<std::vector<char> > &board) {\\n            if (board.empty())\\n                return;\\n            rows = static_cast<int>(board.size());\\n            cols = static_cast<int>(board[0].size());\\n            if (rows < 3 || cols < 3)\\n                return;\\n            for (int col = 0; col < cols; ++col) {\\n                if (board[0][col] == 'O')\\n                    solveDFS(board, 0, col);\\n                if (board[rows - 1][col] == 'O')\\n                    solveDFS(board, rows - 1, col);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3619354,
                "title": "my-solution-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nIdea: first we traverse all the boundaries, if there is a \\'O\\' present we mark that aa \\'P\\'\\nafter that again we traverse through the board, if there is any \\'O\\', present than we replace that with \\'X\\'. else if there is a \\'P\\' is there than we replace that with \\'O\\'.\\n\\n# Complexity\\n- Time complexity:\\n$$O(m.n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public void solve(char[][] board) {\\n        //Approach: Using Backtracking\\n        //Idea: first we traverse all the boundaries, if there is a \\'O\\' present we mark that aa \\'P\\'\\n        /*after that again we traverse through the board, \\n        if there is any \\'O\\', present than we replace that with \\'X\\'.\\n        else if there is a \\'P\\' is there than we replace that with \\'O\\'.*/\\n\\n        int r = board.length;\\n        int c = board[0].length;\\n\\n        // 1a) Capture unsurrounded regions - top and bottom row (replace O with P)\\n        for(int i=0;i<c;i++){\\n            if(board[0][i]==\\'O\\'){\\n                dfs(0, i, board);\\n            }\\n            if(board[r-1][i]==\\'O\\'){\\n                dfs(r-1, i, board);\\n            }\\n        }\\n        // 1b) Capture unsurrounded regions - Left and right columns (replace O with P)\\n        for(int j=0;j<r;j++){\\n            if(board[j][0]==\\'O\\'){\\n                dfs(j, 0, board);\\n            }\\n            if(board[j][c-1]==\\'O\\'){\\n                dfs(j, c-1, board);\\n            }\\n        }\\n\\n        //main loop\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(board[i][j]==\\'O\\'){\\n                    board[i][j]=\\'X\\'; //making the soraunded regions \\'O\\' --> \\'X\\'\\n                }\\n                if(board[i][j]==\\'P\\'){\\n                    board[i][j]=\\'O\\'; //making the soraunded regions \\'P\\' --> \\'O\\'\\n                }\\n            }\\n        }\\n    }\\n    //dfs method\\n    public void dfs(int i, int j, char[][] board){\\n        //base case \\n        if(i<0 || j<0 || i>=board.length || j>=board[0].length || board[i][j]!=\\'O\\'){\\n            return;\\n        }\\n        //make the \\'O\\' position as \\'P\\'\\n        board[i][j] = \\'P\\';\\n        //call dfs for all direction\\n        dfs(i+1, j, board);\\n        dfs(i-1, j, board);\\n        dfs(i, j+1, board);\\n        dfs(i, j-1, board);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public void solve(char[][] board) {\\n        //Approach: Using Backtracking\\n        //Idea: first we traverse all the boundaries, if there is a \\'O\\' present we mark that aa \\'P\\'\\n        /*after that again we traverse through the board, \\n        if there is any \\'O\\', present than we replace that with \\'X\\'.\\n        else if there is a \\'P\\' is there than we replace that with \\'O\\'.*/\\n\\n        int r = board.length;\\n        int c = board[0].length;\\n\\n        // 1a) Capture unsurrounded regions - top and bottom row (replace O with P)\\n        for(int i=0;i<c;i++){\\n            if(board[0][i]==\\'O\\'){\\n                dfs(0, i, board);\\n            }\\n            if(board[r-1][i]==\\'O\\'){\\n                dfs(r-1, i, board);\\n            }\\n        }\\n        // 1b) Capture unsurrounded regions - Left and right columns (replace O with P)\\n        for(int j=0;j<r;j++){\\n            if(board[j][0]==\\'O\\'){\\n                dfs(j, 0, board);\\n            }\\n            if(board[j][c-1]==\\'O\\'){\\n                dfs(j, c-1, board);\\n            }\\n        }\\n\\n        //main loop\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(board[i][j]==\\'O\\'){\\n                    board[i][j]=\\'X\\'; //making the soraunded regions \\'O\\' --> \\'X\\'\\n                }\\n                if(board[i][j]==\\'P\\'){\\n                    board[i][j]=\\'O\\'; //making the soraunded regions \\'P\\' --> \\'O\\'\\n                }\\n            }\\n        }\\n    }\\n    //dfs method\\n    public void dfs(int i, int j, char[][] board){\\n        //base case \\n        if(i<0 || j<0 || i>=board.length || j>=board[0].length || board[i][j]!=\\'O\\'){\\n            return;\\n        }\\n        //make the \\'O\\' position as \\'P\\'\\n        board[i][j] = \\'P\\';\\n        //call dfs for all direction\\n        dfs(i+1, j, board);\\n        dfs(i-1, j, board);\\n        dfs(i, j+1, board);\\n        dfs(i, j-1, board);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3254061,
                "title": "surrounded-regions-explained-dfs-in-python",
                "content": "# Intuition\\nIn order to solve this problem, we first need to distinguish between two types of `\"O\"` cells within the matrix: those that are connected 4-directionally to `\"O\"` cells touching the border, and those that aren\\'t. In other words, all `\"O\"` cells along the bounds of the matrix are **safe**, where \"safe\" means we don\\'t need to overwrite them with `\"X\"`. For all other `\"O\"` cells within the matrix, they can only be considered **safe** if they are reachable 4-directionally from one of the border `\"O\"` cells. Once we\\'ve established a way of discerning between safe and unsafe `\"O\"` cells, all that\\'s left to do is flip all unsafe `\"O\"` cells to `\"X\"`. \\n\\nTo find and mark cells as safe, we can use a hashset and depth-first search, starting from all `\"O\"` cells we find along the border. We use a hashset for its $$O(1)$$ check for existence, and depth-first search to find all properly connected cells and mark them as safe.  \\n\\n# Algorithm\\n1. Initialize a hashset `seen` to contain the `(row, col)` of all safe cells.\\n2. Traverse the border cells of the matrix and depth-first search all cells containing `\"O\"`. For each `(row, col)` we visit through DFS, we add it to `seen`.\\n3. Finally, traverse the inner cells of the matrix and flip all unsafe `\"O\"` cells to `\"X\"`.\\n\\n# Implementation\\n<iframe src=\"https://leetcode.com/playground/ZHzqBsFP/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where $$n$$ is the number of cells in the board. In the worst case, all cells are `\"O\"` and we must traverse and process the entire matrix.\\n- Space complexity: $$O(n)$$, where $$n$$ is the number of cells in the board. In the worst case, we allocate space for $$n$$ elements in our set as well as a maximum depth of $$n$$ recursive calls in the function call stack.\\n\\n---\\n\\n> *Upvote \\uD83D\\uDC4D if this helped at all. Cheers!*",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "# Intuition\\nIn order to solve this problem, we first need to distinguish between two types of `\"O\"` cells within the matrix: those that are connected 4-directionally to `\"O\"` cells touching the border, and those that aren\\'t. In other words, all `\"O\"` cells along the bounds of the matrix are **safe**, where \"safe\" means we don\\'t need to overwrite them with `\"X\"`. For all other `\"O\"` cells within the matrix, they can only be considered **safe** if they are reachable 4-directionally from one of the border `\"O\"` cells. Once we\\'ve established a way of discerning between safe and unsafe `\"O\"` cells, all that\\'s left to do is flip all unsafe `\"O\"` cells to `\"X\"`. \\n\\nTo find and mark cells as safe, we can use a hashset and depth-first search, starting from all `\"O\"` cells we find along the border. We use a hashset for its $$O(1)$$ check for existence, and depth-first search to find all properly connected cells and mark them as safe.  \\n\\n# Algorithm\\n1. Initialize a hashset `seen` to contain the `(row, col)` of all safe cells.\\n2. Traverse the border cells of the matrix and depth-first search all cells containing `\"O\"`. For each `(row, col)` we visit through DFS, we add it to `seen`.\\n3. Finally, traverse the inner cells of the matrix and flip all unsafe `\"O\"` cells to `\"X\"`.\\n\\n# Implementation\\n<iframe src=\"https://leetcode.com/playground/ZHzqBsFP/shared\" frameBorder=\"0\" width=\"800\" height=\"600\"></iframe>\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, where $$n$$ is the number of cells in the board. In the worst case, all cells are `\"O\"` and we must traverse and process the entire matrix.\\n- Space complexity: $$O(n)$$, where $$n$$ is the number of cells in the board. In the worst case, we allocate space for $$n$$ elements in our set as well as a maximum depth of $$n$$ recursive calls in the function call stack.\\n\\n---\\n\\n> *Upvote \\uD83D\\uDC4D if this helped at all. Cheers!*",
                "codeTag": "Unknown"
            },
            {
                "id": 3200188,
                "title": "130-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe algorithm works as follows:\\n\\n1. We first handle the edge cases by checking if the board is empty. If it is, we return without doing anything.\\n\\n2. We define a helper function dfs that performs a depth-first search to mark all O\\'s that are connected to the current O at the coordinates (i, j). We mark each visited cell with the character \\'#\\'. The function takes two arguments i and j that represent the row and column indices of the current cell.\\n\\n3. We then iterate over all the edges of the board and mark all the O\\'s on the edges as visited. We start with the left and right edges by iterating over all the rows and then move on to the top and bottom edges by iterating over all the columns.\\n\\n4. We then iterate over all the cells of the board and flip all unvisited O\\'s to X\\'s and all marked O\\'s back to O\\'s.\\n\\n5. The time complexity of this algorithm is O(mn), where m and n are the number of rows and columns in the board.\\n\\n6. This algorithm is fast and efficient as it only visits each cell once and performs a constant amount of work for each cell.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def solve(self, board: List[List[str]]) -> None:\\n    \"\"\"\\n    Do not return anything, modify board in-place instead.\\n    \"\"\"\\n    if not board:\\n        return # empty board\\n    m, n = len(board), len(board[0])\\n    \\n    def dfs(i: int, j: int) -> None:\\n        \"\"\"\\n        Depth-first search function to mark all O\\'s connected to the current O (i, j).\\n        \"\"\"\\n        if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != \\'O\\':\\n            return\\n        \\n        board[i][j] = \\'#\\'  # mark as visited\\n        \\n        # recursively mark all adjacent O\\'s\\n        dfs(i+1, j)\\n        dfs(i-1, j)\\n        dfs(i, j+1)\\n        dfs(i, j-1)\\n        \\n    # mark all O\\'s on the edges\\n    for i in range(m):\\n        dfs(i, 0)\\n        dfs(i, n-1)\\n        \\n    for j in range(n):\\n        dfs(0, j)\\n        dfs(m-1, j)\\n        \\n    # flip unvisited O\\'s to X\\'s and marked O\\'s back to O\\'s\\n    for i in range(m):\\n        for j in range(n):\\n            if board[i][j] == \\'O\\':\\n                board[i][j] = \\'X\\'\\n            elif board[i][j] == \\'#\\':\\n                board[i][j] = \\'O\\'\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution:\\n  def solve(self, board: List[List[str]]) -> None:\\n    \"\"\"\\n    Do not return anything, modify board in-place instead.\\n    \"\"\"\\n    if not board:\\n        return # empty board\\n    m, n = len(board), len(board[0])\\n    \\n    def dfs(i: int, j: int) -> None:\\n        \"\"\"\\n        Depth-first search function to mark all O\\'s connected to the current O (i, j).\\n        \"\"\"\\n        if i < 0 or i >= m or j < 0 or j >= n or board[i][j] != \\'O\\':\\n            return\\n        \\n        board[i][j] = \\'#\\'  # mark as visited\\n        \\n        # recursively mark all adjacent O\\'s\\n        dfs(i+1, j)\\n        dfs(i-1, j)\\n        dfs(i, j+1)\\n        dfs(i, j-1)\\n        \\n    # mark all O\\'s on the edges\\n    for i in range(m):\\n        dfs(i, 0)\\n        dfs(i, n-1)\\n        \\n    for j in range(n):\\n        dfs(0, j)\\n        dfs(m-1, j)\\n        \\n    # flip unvisited O\\'s to X\\'s and marked O\\'s back to O\\'s\\n    for i in range(m):\\n        for j in range(n):\\n            if board[i][j] == \\'O\\':\\n                board[i][j] = \\'X\\'\\n            elif board[i][j] == \\'#\\':\\n                board[i][j] = \\'O\\'\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2758779,
                "title": "c-boundary-dfs-with-explanation-no-extra-space-easy-understanding",
                "content": "# Approach\\n Steps to Solve :\\n    1. Move over the boundary of board, and find O\\'s \\n    2. Every time we find an O, perform DFS from it\\'s position\\n    3. In DFS convert all \\'O\\' to \\'C\\' (why?? so that we can differentiate which \\'O\\' can be flipped and which cannot be)\\n    4. After all DFSs have been performed, board contains three elements,C,O and X\\n    5. \\'O\\' are left over elements which are not connected to any boundary \\'O\\', so flip them to \\'X\\'\\n    6. \\'C\\' are elements which cannot be flipped to \\'X\\', so flip them back to \\'O\\'\\n    \\n**Note:** \\n1. No visited matrix is not required beacuse after dfs traversal we change O\\'s to \\'C\\'\\n2. \\'C\\' means a chain of adjacent O\\'s is connected some \\'O\\' or boundary or Boundary O\\'s\\n      \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(int i,int j,vector<vector<char>>&grid)\\n    {\\n        int r=grid.size();\\n        int c=grid[0].size();\\n        if(i<0 || j<0 || i>=r || j>=c || grid[i][j]==\\'X\\')\\n        {\\n            return;\\n        }\\n        if(grid[i][j]==\\'C\\')\\n        {\\n            return;\\n        }\\n        grid[i][j]=\\'C\\';\\n        dfs(i-1,j,grid);\\n        dfs(i,j-1,grid);\\n        dfs(i+1,j,grid);\\n        dfs(i,j+1,grid);\\n    }\\n    void solve(vector<vector<char>>& grid) {\\n        int r=grid.size();\\n        int c=grid[0].size();\\n        //Start dfs traversal from only boundary\\'s O\\'s\\n        //Moving over first row\\n        for(int i=1;i<c;i++)\\n        {\\n            if(grid[0][i]==\\'O\\')\\n            {\\n                dfs(0,i,grid);\\n            }\\n        }\\n        //Moving over Last row\\n        for(int i=0;i<r;i++)\\n        {\\n            if(grid[i][0]==\\'O\\')\\n            {\\n                dfs(i,0,grid);\\n            }\\n        }\\n        //Moving over first column \\n        for(int i=0;i<r;i++)\\n        {\\n            if(grid[i][c-1]==\\'O\\')\\n            {\\n                dfs(i,c-1,grid);\\n            }\\n        }\\n        //Moving over first column\\n        for(int i=0;i<c;i++)\\n        {\\n            if(grid[r-1][i]==\\'O\\')\\n            {\\n                dfs(r-1,i,grid);\\n            }\\n        }\\n\\n        //\\'O\\' are left over elements which are not connected to any boundary O, so flip them to \\'X\\'    \\n        for(int i=1;i<r-1;i++)\\n        {\\n            for(int j=1;j<c-1;j++)\\n            {\\n                if(grid[i][j]==\\'O\\')\\n                {\\n                    grid[i][j]=\\'X\\';\\n                }\\n            }\\n        }\\n        //\\'C\\' are elements which cannot be flipped to \\'X\\', so flip them back to \\'O\\'\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(grid[i][j]==\\'C\\')\\n                {\\n                    grid[i][j]=\\'O\\';\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\nIf this was helpful, don\\'t hesitate to upvote! :)\\nHave a nice day\\uD83D\\uDE04\\uD83D\\uDE03!",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(int i,int j,vector<vector<char>>&grid)\\n    {\\n        int r=grid.size();\\n        int c=grid[0].size();\\n        if(i<0 || j<0 || i>=r || j>=c || grid[i][j]==\\'X\\')\\n        {\\n            return;\\n        }\\n        if(grid[i][j]==\\'C\\')\\n        {\\n            return;\\n        }\\n        grid[i][j]=\\'C\\';\\n        dfs(i-1,j,grid);\\n        dfs(i,j-1,grid);\\n        dfs(i+1,j,grid);\\n        dfs(i,j+1,grid);\\n    }\\n    void solve(vector<vector<char>>& grid) {\\n        int r=grid.size();\\n        int c=grid[0].size();\\n        //Start dfs traversal from only boundary\\'s O\\'s\\n        //Moving over first row\\n        for(int i=1;i<c;i++)\\n        {\\n            if(grid[0][i]==\\'O\\')\\n            {\\n                dfs(0,i,grid);\\n            }\\n        }\\n        //Moving over Last row\\n        for(int i=0;i<r;i++)\\n        {\\n            if(grid[i][0]==\\'O\\')\\n            {\\n                dfs(i,0,grid);\\n            }\\n        }\\n        //Moving over first column \\n        for(int i=0;i<r;i++)\\n        {\\n            if(grid[i][c-1]==\\'O\\')\\n            {\\n                dfs(i,c-1,grid);\\n            }\\n        }\\n        //Moving over first column\\n        for(int i=0;i<c;i++)\\n        {\\n            if(grid[r-1][i]==\\'O\\')\\n            {\\n                dfs(r-1,i,grid);\\n            }\\n        }\\n\\n        //\\'O\\' are left over elements which are not connected to any boundary O, so flip them to \\'X\\'    \\n        for(int i=1;i<r-1;i++)\\n        {\\n            for(int j=1;j<c-1;j++)\\n            {\\n                if(grid[i][j]==\\'O\\')\\n                {\\n                    grid[i][j]=\\'X\\';\\n                }\\n            }\\n        }\\n        //\\'C\\' are elements which cannot be flipped to \\'X\\', so flip them back to \\'O\\'\\n        for(int i=0;i<r;i++)\\n        {\\n            for(int j=0;j<c;j++)\\n            {\\n                if(grid[i][j]==\\'C\\')\\n                {\\n                    grid[i][j]=\\'O\\';\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552692,
                "title": "easy-dfs-intuitive-java-solution-beats-99-98",
                "content": "```\\nclass Solution {\\n    public void solve(char[][] a) {\\n        int n = a.length, m = a[0].length;\\n        for(int i = 0; i < n; i++){     // Boundary calls on 0th and a[0].length - 1 th coll\\n            if(a[i][0] == \\'O\\'){\\n                dfs(a, i, 0);\\n            }\\n            if(a[i][m - 1] == \\'O\\'){\\n                dfs(a, i, m - 1);\\n            }\\n        }\\n        for(int i = 0; i < m; i++){     // Boundary calls on 0th and a.length - 1 th row\\n            if(a[0][i] == \\'O\\'){\\n                dfs(a, 0, i);\\n            }\\n            if(a[n - 1][i] == \\'O\\'){\\n                dfs(a, n - 1, i);\\n            }\\n        }\\n        for(int i = 0; i < n; i++){             // Updating Values\\n            for(int j = 0; j < m; j++){\\n                if(a[i][j] == \\'M\\'){\\n                    a[i][j] = \\'O\\';\\n                } else {\\n                    a[i][j] = \\'X\\';\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void dfs(char[][] a, int r, int c){\\n        // if our cell is already marked or out of bound or an \\'X\\' return\\n        if(r<0 || c<0 || r>=a.length || c>=a[0].length || a[r][c]==\\'X\\' || a[r][c]==\\'M\\') return;\\n        a[r][c] = \\'M\\';  // marking curr cell as it is \\'O\\' and connected to the boundary four-Directionally\\n        dfs(a, r - 1, c);  // top call\\n        dfs(a, r, c + 1);  // right call\\n        dfs(a, r + 1, c);  // bottom call\\n        dfs(a, r, c - 1);  // left call\\n    }\\n}\\n```\\n```\\nTime Complexity : O(N*M)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void solve(char[][] a) {\\n        int n = a.length, m = a[0].length;\\n        for(int i = 0; i < n; i++){     // Boundary calls on 0th and a[0].length - 1 th coll\\n            if(a[i][0] == \\'O\\'){\\n                dfs(a, i, 0);\\n            }\\n            if(a[i][m - 1] == \\'O\\'){\\n                dfs(a, i, m - 1);\\n            }\\n        }\\n        for(int i = 0; i < m; i++){     // Boundary calls on 0th and a.length - 1 th row\\n            if(a[0][i] == \\'O\\'){\\n                dfs(a, 0, i);\\n            }\\n            if(a[n - 1][i] == \\'O\\'){\\n                dfs(a, n - 1, i);\\n            }\\n        }\\n        for(int i = 0; i < n; i++){             // Updating Values\\n            for(int j = 0; j < m; j++){\\n                if(a[i][j] == \\'M\\'){\\n                    a[i][j] = \\'O\\';\\n                } else {\\n                    a[i][j] = \\'X\\';\\n                }\\n            }\\n        }\\n    }\\n    \\n    public void dfs(char[][] a, int r, int c){\\n        // if our cell is already marked or out of bound or an \\'X\\' return\\n        if(r<0 || c<0 || r>=a.length || c>=a[0].length || a[r][c]==\\'X\\' || a[r][c]==\\'M\\') return;\\n        a[r][c] = \\'M\\';  // marking curr cell as it is \\'O\\' and connected to the boundary four-Directionally\\n        dfs(a, r - 1, c);  // top call\\n        dfs(a, r, c + 1);  // right call\\n        dfs(a, r + 1, c);  // bottom call\\n        dfs(a, r, c - 1);  // left call\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1420389,
                "title": "simple-python-bfs-solution-beats-90",
                "content": "The key of this problem is to realize that the only way for a \"O\" cell to escape is through the boundaries. Instead of starting from each \"O\" cell we can expand \"O\" cells at the four boundaries using BFS and see which cell is reachable form the boundaries (or in other words which cells can reach/escape the boundary).\\n\\nThe algorithm is as follows:\\n1. Add \"O\" cells at the four boundaries to the queue\\n2. Run BFS, see which cells are reachable\\n3. Scan through the board, flip cells not reachable from the boundaries.\\n```Python\\nfrom collections import deque\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        m, n = len(board), len(board[0])\\n        visited = [[False]*n for _ in range(m)]\\n        queue = deque([])\\n        \\n        # add starting \"O\" coordinates at the boundary to the queue\\n        for i in range(m):\\n            if board[i][0] == \"O\":\\n                queue.append((i, 0))\\n                visited[i][0] = True\\n            if board[i][n-1] == \"O\":\\n                queue.append((i, n-1))\\n                visited[i][n-1] = True\\n        for i in range(n):\\n            if board[0][i] == \"O\":\\n                queue.append((0, i))\\n                visited[0][i] = True\\n            if board[m-1][i] == \"O\":\\n                queue.append((m-1, i))\\n                visited[m-1][i] = True\\n        \\n        # standard BFS, see where we can reach from the boundaries\\n        connections = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        while queue:\\n            cur_i, cur_j = queue.popleft()\\n            for d_i, d_j in connections:\\n                new_i, new_j = cur_i+d_i, cur_j+d_j\\n                if 0 <= new_i < m and 0 <= new_j < n and board[new_i][new_j] == \"O\" and not visited[new_i][new_j]:\\n                    visited[new_i][new_j] = True\\n                    queue.append((new_i, new_j))\\n        \\n        # go through the rest of the board, flip any cell not reachable from the boundary\\n        for i in range(1, m-1):\\n            for j in range(1, n-1):\\n                if board[i][j] == \"O\" and not visited[i][j]:\\n                    board[i][j] = \"X\"\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Breadth-First Search"
                ],
                "code": "```Python\\nfrom collections import deque\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        m, n = len(board), len(board[0])\\n        visited = [[False]*n for _ in range(m)]\\n        queue = deque([])\\n        \\n        # add starting \"O\" coordinates at the boundary to the queue\\n        for i in range(m):\\n            if board[i][0] == \"O\":\\n                queue.append((i, 0))\\n                visited[i][0] = True\\n            if board[i][n-1] == \"O\":\\n                queue.append((i, n-1))\\n                visited[i][n-1] = True\\n        for i in range(n):\\n            if board[0][i] == \"O\":\\n                queue.append((0, i))\\n                visited[0][i] = True\\n            if board[m-1][i] == \"O\":\\n                queue.append((m-1, i))\\n                visited[m-1][i] = True\\n        \\n        # standard BFS, see where we can reach from the boundaries\\n        connections = [(-1, 0), (1, 0), (0, -1), (0, 1)]\\n        while queue:\\n            cur_i, cur_j = queue.popleft()\\n            for d_i, d_j in connections:\\n                new_i, new_j = cur_i+d_i, cur_j+d_j\\n                if 0 <= new_i < m and 0 <= new_j < n and board[new_i][new_j] == \"O\" and not visited[new_i][new_j]:\\n                    visited[new_i][new_j] = True\\n                    queue.append((new_i, new_j))\\n        \\n        # go through the rest of the board, flip any cell not reachable from the boundary\\n        for i in range(1, m-1):\\n            for j in range(1, n-1):\\n                if board[i][j] == \"O\" and not visited[i][j]:\\n                    board[i][j] = \"X\"\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1391905,
                "title": "python-interview-solution-explained-dfs",
                "content": "```\\nclass Solution:\\n    \\n    # Helper function to determine if a postiion is on the border of the matrix\\n    def is_border(self, row, col, m, n):\\n      return row == 0 or row == m - 1 or col == 0 or col == n-1\\n    \\n    # Helper function to get valid neighbours\\n    def get_valid_neighbours(self, row, col, board):\\n      valid_directions = []\\n      for drow, dcol in [(-1,0),(1,0),(0,-1),(0,1)]:\\n        new_row, new_col = row + drow, col + dcol\\n        if 0 <= new_row < len(board) and 0 <= new_col < len(board[0]) and board[new_row][new_col] == \\'O\\':\\n          valid_directions.append((new_row, new_col))\\n      return valid_directions\\n    \\n    # Perform DFS \\n    def dfs(self, row, col, board):\\n      board[row][col] = \\'E\\'\\n      # Get Valid rows before performing DFS to reduce recursive stack (Optimization)\\n      for row,col in self.get_valid_neighbours(row, col, board):\\n        self.dfs(row, col, board)\\n\\n\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        m,n = len(board), len(board[0])\\n        # Perform DFS from all nodes at the border and mark as \"escaped (E)\" as they are not \"surrounded\" by X\\n        for row in range(m):\\n          for col in range(n):\\n            if self.is_border(row, col, m, n) and board[row][col] == \\'O\\':\\n                self.dfs(row, col, board)\\n        \\n        # Iterate through all elements again and change the \"E\" elements back to \"O\" and everything else to \\'X\\'\\n        for row in range(m):\\n          for col in range(n):\\n            if board[row][col] == \\'O\\': \\n              board[row][col] = \\'X\\'\\n            elif board[row][col] == \\'E\\':\\n              board[row][col] = \\'O\\'\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    \\n    # Helper function to determine if a postiion is on the border of the matrix\\n    def is_border(self, row, col, m, n):\\n      return row == 0 or row == m - 1 or col == 0 or col == n-1\\n    \\n    # Helper function to get valid neighbours\\n    def get_valid_neighbours(self, row, col, board):\\n      valid_directions = []\\n      for drow, dcol in [(-1,0),(1,0),(0,-1),(0,1)]:\\n        new_row, new_col = row + drow, col + dcol\\n        if 0 <= new_row < len(board) and 0 <= new_col < len(board[0]) and board[new_row][new_col] == \\'O\\':\\n          valid_directions.append((new_row, new_col))\\n      return valid_directions\\n    \\n    # Perform DFS \\n    def dfs(self, row, col, board):\\n      board[row][col] = \\'E\\'\\n      # Get Valid rows before performing DFS to reduce recursive stack (Optimization)\\n      for row,col in self.get_valid_neighbours(row, col, board):\\n        self.dfs(row, col, board)\\n\\n\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        m,n = len(board), len(board[0])\\n        # Perform DFS from all nodes at the border and mark as \"escaped (E)\" as they are not \"surrounded\" by X\\n        for row in range(m):\\n          for col in range(n):\\n            if self.is_border(row, col, m, n) and board[row][col] == \\'O\\':\\n                self.dfs(row, col, board)\\n        \\n        # Iterate through all elements again and change the \"E\" elements back to \"O\" and everything else to \\'X\\'\\n        for row in range(m):\\n          for col in range(n):\\n            if board[row][col] == \\'O\\': \\n              board[row][col] = \\'X\\'\\n            elif board[row][col] == \\'E\\':\\n              board[row][col] = \\'O\\'\\n",
                "codeTag": "Java"
            },
            {
                "id": 1147632,
                "title": "simple-detailed-c-dfs-approach-faster-than-100",
                "content": "* Travel on the boundary of the given board and call dfs everytime you encounter \\'O\\'.\\n* Now when you call dfs at a cell which is \\'O\\', make it \\'S\\' (or any other recognisable marker) and call dfs to its neighbours \\n* So all \\'O\\' reachable from the boundary \\'O\\' will get marker \\'S\\' along with the one at the boundary.\\n* But still some \\'O\\' reachable from some \\'O\\' at the boundary might get left. For those of them you have to continue iterating over the boundary of the board.\\n* In the end, travel again on all of the cells of your board and convert all \\'S\\' to \\'O\\'. If a cell is found to be \\'O\\' then it has to be converted to \\'X\\' as it was not reachable from the boundary.\\n\\nTime complexity will be O(m*n).\\n\\n\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<char>>& board, int i, int j,int m,int n){\\n        if(i>=m || i<0 || j>=n || j<0 ) return;\\n        else if(board[i][j]==\\'X\\' || board[i][j]==\\'S\\' ) return;\\n        \\n        board[i][j]=\\'S\\';\\n        dfs(board,i+1,j,m,n);\\n        dfs(board,i,j+1,m,n);\\n        dfs(board,i-1,j,m,n);\\n        dfs(board,i,j-1,m,n);        \\n    }\\n    \\n    void solve(vector<vector<char>>& board) {\\n        int m=board.size(),n=board[0].size();\\n        for(int j=0;j<n;j++){\\n            if(board[0][j]==\\'O\\') dfs(board,0,j,m,n);\\n        }\\n        for(int i=1;i<m;i++){\\n            if(board[i][n-1]==\\'O\\') dfs(board,i,n-1,m,n);\\n        }\\n        for(int j=n-2;j>=0;j--){\\n            if(board[m-1][j]==\\'O\\') dfs(board,m-1,j,m,n);\\n        }\\n        for(int i=m-2;i>0;i--){\\n            if(board[i][0]==\\'O\\') dfs(board,i,0,m,n);\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(board[i][j]==\\'S\\') board[i][j]=\\'O\\';\\n                else if(board[i][j]==\\'O\\') board[i][j]=\\'X\\';\\n        }\\n        }\\n        \\n    }\\n};\\n```\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void dfs(vector<vector<char>>& board, int i, int j,int m,int n){\\n        if(i>=m || i<0 || j>=n || j<0 ) return;\\n        else if(board[i][j]==\\'X\\' || board[i][j]==\\'S\\' ) return;\\n        \\n        board[i][j]=\\'S\\';\\n        dfs(board,i+1,j,m,n);\\n        dfs(board,i,j+1,m,n);\\n        dfs(board,i-1,j,m,n);\\n        dfs(board,i,j-1,m,n);        \\n    }\\n    \\n    void solve(vector<vector<char>>& board) {\\n        int m=board.size(),n=board[0].size();\\n        for(int j=0;j<n;j++){\\n            if(board[0][j]==\\'O\\') dfs(board,0,j,m,n);\\n        }\\n        for(int i=1;i<m;i++){\\n            if(board[i][n-1]==\\'O\\') dfs(board,i,n-1,m,n);\\n        }\\n        for(int j=n-2;j>=0;j--){\\n            if(board[m-1][j]==\\'O\\') dfs(board,m-1,j,m,n);\\n        }\\n        for(int i=m-2;i>0;i--){\\n            if(board[i][0]==\\'O\\') dfs(board,i,0,m,n);\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(board[i][j]==\\'S\\') board[i][j]=\\'O\\';\\n                else if(board[i][j]==\\'O\\') board[i][j]=\\'X\\';\\n        }\\n        }\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 997133,
                "title": "python-3-dfs-backtracking-with-explanation-128ms-runtime-o-1-extra-space",
                "content": "Approach:\\nUse dfs from every \"O\" that is on the boarders and convert all those \"O\" that are connected into \"A\" which temporarily\\nmeans they are explored, but will turn back to \"O\" at the end of the dfs. After finishing dfs on all boarder \"O\", \\nwe can then iterate through the entire board and convert all \"O\" into \"X\", and \"A\" into \"O\".\\n\\n```\\nfrom typing import List\\nclass Solution:\\n    # 128ms ~ O((M+N) * 3^(M*N))) (upperbound) runtime. The first M+N is from looking through the boundary, and 3^(M*N) for dfs up to a maximum depth of M*N nodes \\n    # M+N is dependent on 3^(M*N) if we have 3^(M*N) on the first dfs search, then the rest of the M+N-1 iterations won\\'t be searched past the first node\\n    # which means it\\'s just O(3^(M*N) + (M+N-1)), but likewise (M+N) will increase if 3^(M*N) is decreased.\\n\\n    # O(1) extra space used, we only need to modify the given input board, rather than making a new one.\\n\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        \\n        if not board or len(board[0]) == 0:\\n            return\\n        \\n        rows = len(board)\\n        cols = len(board[0])\\n        \\n        # input a boarder \"O\" position, and convert all connected \"O\" into \"A\"\\n        def dfs(x,y):\\n            board[x][y] = \"A\"\\n            # check the neighbors\\n            for dx,dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n                newX, newY = x + dx, y + dy\\n                \\n                # check for bounds\\n                if 0 <= newX < rows and 0 <= newY < cols:\\n                    if board[newX][newY] == \"O\":\\n                        dfs(newX,newY)\\n            return\\n        \\n        # iterate through the boundary of the board and insert any \"O\" into dfs\\n        # top boundary\\n        x = 0\\n        for y in range(cols):\\n            if board[x][y] == \"O\":\\n                dfs(x,y)\\n        # bottom boundary\\n        x = rows - 1\\n        for y in range(cols):\\n            if board[x][y] == \"O\":\\n                dfs(x,y)\\n                \\n        # note that left and right boundaries check top and bottom values (even though it\\'s checked previously)\\n        # but that doesn\\'t matter since the label is no longer \"O\" it will be \"A\"\\n        \\n        # left boundary\\n        y = 0\\n        for x in range(rows):\\n            if board[x][y] == \"O\":\\n                dfs(x,y)\\n        # right boundary\\n        y = cols - 1\\n        for x in range(rows):\\n            if board[x][y] == \"O\":\\n                dfs(x,y)\\n        \\n        # iterate through board and convert all \"O\" into \"X\" and \"A\" into \"O\"\\n        for x in range(rows):\\n            for y in range(cols):\\n                if board[x][y] == \"O\":\\n                    board[x][y] = \"X\"\\n                elif board[x][y] == \"A\":\\n                    board[x][y] = \"O\"\\n        \\n        return\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nfrom typing import List\\nclass Solution:\\n    # 128ms ~ O((M+N) * 3^(M*N))) (upperbound) runtime. The first M+N is from looking through the boundary, and 3^(M*N) for dfs up to a maximum depth of M*N nodes \\n    # M+N is dependent on 3^(M*N) if we have 3^(M*N) on the first dfs search, then the rest of the M+N-1 iterations won\\'t be searched past the first node\\n    # which means it\\'s just O(3^(M*N) + (M+N-1)), but likewise (M+N) will increase if 3^(M*N) is decreased.\\n\\n    # O(1) extra space used, we only need to modify the given input board, rather than making a new one.\\n\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        \\n        if not board or len(board[0]) == 0:\\n            return\\n        \\n        rows = len(board)\\n        cols = len(board[0])\\n        \\n        # input a boarder \"O\" position, and convert all connected \"O\" into \"A\"\\n        def dfs(x,y):\\n            board[x][y] = \"A\"\\n            # check the neighbors\\n            for dx,dy in [(-1,0),(1,0),(0,-1),(0,1)]:\\n                newX, newY = x + dx, y + dy\\n                \\n                # check for bounds\\n                if 0 <= newX < rows and 0 <= newY < cols:\\n                    if board[newX][newY] == \"O\":\\n                        dfs(newX,newY)\\n            return\\n        \\n        # iterate through the boundary of the board and insert any \"O\" into dfs\\n        # top boundary\\n        x = 0\\n        for y in range(cols):\\n            if board[x][y] == \"O\":\\n                dfs(x,y)\\n        # bottom boundary\\n        x = rows - 1\\n        for y in range(cols):\\n            if board[x][y] == \"O\":\\n                dfs(x,y)\\n                \\n        # note that left and right boundaries check top and bottom values (even though it\\'s checked previously)\\n        # but that doesn\\'t matter since the label is no longer \"O\" it will be \"A\"\\n        \\n        # left boundary\\n        y = 0\\n        for x in range(rows):\\n            if board[x][y] == \"O\":\\n                dfs(x,y)\\n        # right boundary\\n        y = cols - 1\\n        for x in range(rows):\\n            if board[x][y] == \"O\":\\n                dfs(x,y)\\n        \\n        # iterate through board and convert all \"O\" into \"X\" and \"A\" into \"O\"\\n        for x in range(rows):\\n            for y in range(cols):\\n                if board[x][y] == \"O\":\\n                    board[x][y] = \"X\"\\n                elif board[x][y] == \"A\":\\n                    board[x][y] = \"O\"\\n        \\n        return\\n```",
                "codeTag": "Java"
            },
            {
                "id": 41875,
                "title": "u3010c-u3011my-bfs-solution-get-ac-but-my-dfs-solution-doesn-t",
                "content": "    class Solution {\\n    public:\\n        int row,col;\\n        void solve(vector<vector<char>> &board) {\\n            row = board.size();\\n            if (row==0) return;\\n            col = board[0].size();\\n            if (col==0) return;\\n            for(int i = 0;i<col;i++){\\n                if(board[0][i]=='O') {\\n                    DFS(board, 0, i);\\n                    //board[0][i] = 'P';\\n                }\\n                if(board[row-1][i]=='O') {\\n                    DFS(board, row-1, i);\\n                    //board[row-1][i] = 'P';\\n                }\\n            }\\n            for(int i = 0;i<row;i++){\\n                if(board[i][0]=='O') {\\n                    DFS(board, i, 0);\\n                    //board[i][0] = 'P';\\n                }\\n                if(board[i][col-1]=='O') {\\n                    DFS(board, i, col-1);\\n                    //board[i][col-1] = 'P';\\n                }\\n            }\\n            for(int i = 0;i<row;i++){\\n                for(int j= 0;j<col;j++){\\n                    if (board[i][j]=='O') board[i][j] = 'X';\\n                    else if (board[i][j]=='P') board[i][j] = 'O';\\n                }\\n            }\\n        }\\n        \\n        void DFS(vector<vector<char> > &board, int i, int j){\\n            while(i<0||j<0||i>=row||j>=col) return;\\n            if(board[i][j]=='O'){\\n                board[i][j] = 'P';\\n                DFS(board,i-1,j);\\n                DFS(board,i,j-1);\\n                DFS(board,i+1,j);\\n                DFS(board,i,j+1);\\n            }\\n        }\\n    \\n        void BFS(vector<vector<char> > &board, int i, int l){\\n            int j,k;\\n            queue<pair<int,int> > q;\\n            q.push({i,l});\\n            while(!q.empty()){\\n                j = q.front().first;\\n                k = q.front().second;\\n                q.pop();\\n               // board[j][k] = 'P';\\n                if (j>0&&board[j-1][k]=='O'){\\n                    board[j-1][k] = 'P';\\n                    q.push({j-1,k});\\n                }\\n                if (k>0&&board[j][k-1]=='O'){\\n                    board[j][k-1] = 'P';\\n                    q.push({j,k-1});\\n                }\\n                if (j+1<row&&board[j+1][k]=='O'){\\n                    board[j+1][k] = 'P';\\n                    q.push({j+1,k});\\n                }\\n                if (k+1<col&&board[j][k+1]=='O'){\\n                    board[j][k+1] = 'P';\\n                    q.push({j,k+1});\\n                }\\n            }\\n            \\n        }\\n                    \\n    };\\n\\nThe DFS solution encounters a Runtime Error for large input, I really have no idea where's wrong. Could any one help me with that? Thanks a lot!",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int row,col;\\n        void solve(vector<vector<char>> &board) {\\n            row = board.size();\\n            if (row==0) return;\\n            col = board[0].size();\\n            if (col==0) return;\\n            for(int i = 0;i<col;i++){\\n                if(board[0][i]=='O') {\\n                    DFS(board, 0, i);\\n                    //board[0][i] = 'P';\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 4011236,
                "title": "96-beats-c-memory-space-optimized-boundary-dfs",
                "content": "# Approach\\nWe can start by identifying \\'O\\' cells at the border of the board because these cells cannot be surrounded by \\'X\\'. All other \\'O\\' cells within the border can potentially be surrounded and should be marked with  \\'N\\'.\\n\\n# Algorithm\\n+ Initialize variables to store the number of rows (row) and columns (col) in the matrix.\\n\\n+ Create a helper function dfs(i, j, mat) that performs Depth-First Search (DFS) to mark \\'O\\' cells and their connected neighbors as \\'N\\'. It should have the following steps:\\n\\n  + Base case: If the cell (i, j) is out of bounds or already marked as \\'N\\', return.\\n  + If the cell (i, j) is \\'O\\', mark it as \\'N\\'.\\n  + Recursively call dfs on its adjacent cells: down (i+1, j), up (i-1, j), right (i, j+1), and left (i, j-1).\\n+  Iterate through the entire matrix using two nested loops:\\n   + For each cell (i, j):\\n       + Check if mat[i][j] is equal to \\'O\\' and if (i, j) is a corner cell (i.e., (i, j) is on the border). You can use the isCorner function for this.\\n       + If both conditions are met, call dfs(i, j, mat) to mark this region as \\'N\\' and all connected \\'O\\' cells.\\n+ After marking all potentially surrounded regions as \\'N\\', iterate through the entire matrix again:\\n\\n   + For each cell (i, j):\\n       + If mat[i][j] is \\'O\\', change it to \\'X\\' because it is not part of a surrounded region.\\n       + If mat[i][j] is \\'N\\', change it back to \\'O\\' to restore the originally marked \\'O\\' cells.\\n+ The matrix is now updated with the correct regions captured. The regions surrounded by \\'X\\' remain \\'X\\', and the regions not surrounded are restored to \\'O\\'.\\n\\n# Complexity\\n- Time complexity: **O(row*col)**\\n\\n- Space complexity:**O(1)**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int row,col; // Variables to store the number of rows and columns in the matrix.\\n\\n    // Function to check if a cell is at the corner of the matrix.\\n    inline bool isCorner(int i,int j){return (i==0 || j==0 || i==row-1 || j==col-1);}\\n\\n    // Depth-First Search (DFS) function to mark \\'O\\' cells connected to the border as \\'N\\'.\\n    void dfs(int i,int j,vector<vector<char>>&mat){\\n\\n        // Base case: If the cell is out of bounds, return.\\n        if(i<0 || j<0 || i>=row || j>=col) {return;}\\n\\n        // If the cell is \\'O\\', mark it as \\'N\\' and explore its neighbors.\\n        if(mat[i][j]==\\'O\\') {mat[i][j]=\\'N\\';}\\n        else {return;}\\n\\n        dfs(i+1,j,mat); // Explore down.\\n        dfs(i-1,j,mat); // Explore up.\\n        dfs(i,j+1,mat); // Explore right.\\n        dfs(i,j-1,mat); // Explore left.\\n    }\\n\\n    // Main function to solve the problem.\\n    void solve(vector<vector<char>>& mat) {\\n        row=mat.size(); // Get the number of rows in the matrix.\\n        col=mat[0].size(); // Get the number of columns in the matrix.\\n        \\n        // Iterate through the matrix to find \\'O\\' cells at the border and start DFS.\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(mat[i][j]==\\'O\\' && isCorner(i,j)){\\n                    dfs(i,j,mat);\\n                }\\n            }\\n        }\\n\\n        // Final pass to update \\'O\\' cells to \\'X\\' and \\'N\\' cells back to \\'O\\'.\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(mat[i][j] ==\\'O\\') mat[i][j]=\\'X\\';\\n                else if(mat[i][j] ==\\'N\\') mat[i][j]=\\'O\\';\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Depth-First Search",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int row,col; // Variables to store the number of rows and columns in the matrix.\\n\\n    // Function to check if a cell is at the corner of the matrix.\\n    inline bool isCorner(int i,int j){return (i==0 || j==0 || i==row-1 || j==col-1);}\\n\\n    // Depth-First Search (DFS) function to mark \\'O\\' cells connected to the border as \\'N\\'.\\n    void dfs(int i,int j,vector<vector<char>>&mat){\\n\\n        // Base case: If the cell is out of bounds, return.\\n        if(i<0 || j<0 || i>=row || j>=col) {return;}\\n\\n        // If the cell is \\'O\\', mark it as \\'N\\' and explore its neighbors.\\n        if(mat[i][j]==\\'O\\') {mat[i][j]=\\'N\\';}\\n        else {return;}\\n\\n        dfs(i+1,j,mat); // Explore down.\\n        dfs(i-1,j,mat); // Explore up.\\n        dfs(i,j+1,mat); // Explore right.\\n        dfs(i,j-1,mat); // Explore left.\\n    }\\n\\n    // Main function to solve the problem.\\n    void solve(vector<vector<char>>& mat) {\\n        row=mat.size(); // Get the number of rows in the matrix.\\n        col=mat[0].size(); // Get the number of columns in the matrix.\\n        \\n        // Iterate through the matrix to find \\'O\\' cells at the border and start DFS.\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(mat[i][j]==\\'O\\' && isCorner(i,j)){\\n                    dfs(i,j,mat);\\n                }\\n            }\\n        }\\n\\n        // Final pass to update \\'O\\' cells to \\'X\\' and \\'N\\' cells back to \\'O\\'.\\n        for(int i=0;i<row;i++){\\n            for(int j=0;j<col;j++){\\n                if(mat[i][j] ==\\'O\\') mat[i][j]=\\'X\\';\\n                else if(mat[i][j] ==\\'N\\') mat[i][j]=\\'O\\';\\n            }\\n        }\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619170,
                "title": "c-bfs-solution-number-of-enclaves-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board)\\n    {\\n        int n = board.size();\\n        int m = board[0].size();\\n        \\n        queue<pair<int,int>> q;\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(i == 0 || i == n-1 || j == 0 || j == m-1 )\\n                {\\n                    if(board[i][j] == \\'O\\')\\n                    {\\n                        q.push({i,j});\\n                        vis[i][j] = 1;\\n                    }\\n                }\\n\\n            }\\n        }\\n        \\n        int delrow[] = {-1,0,1,0};\\n        int delcol[] = {0,1,0,-1};\\n        while(!q.empty())\\n        {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(int i = 0; i<4; i++)\\n            {\\n                int row = r + delrow[i];\\n                int col = c + delcol[i];\\n               \\n                if(row >= 0 && col >= 0 && row < n && col < m && !vis[row][col] && board[row][col] == \\'O\\')\\n                {\\n                    q.push({row,col});\\n                    vis[row][col] = 1;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(board[i][j] == \\'O\\' && !vis[i][j])\\n                {\\n                     board[i][j] = \\'X\\';\\n                }\\n            }\\n            \\n        }\\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board)\\n    {\\n        int n = board.size();\\n        int m = board[0].size();\\n        \\n        queue<pair<int,int>> q;\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(i == 0 || i == n-1 || j == 0 || j == m-1 )\\n                {\\n                    if(board[i][j] == \\'O\\')\\n                    {\\n                        q.push({i,j});\\n                        vis[i][j] = 1;\\n                    }\\n                }\\n\\n            }\\n        }\\n        \\n        int delrow[] = {-1,0,1,0};\\n        int delcol[] = {0,1,0,-1};\\n        while(!q.empty())\\n        {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            q.pop();\\n            for(int i = 0; i<4; i++)\\n            {\\n                int row = r + delrow[i];\\n                int col = c + delcol[i];\\n               \\n                if(row >= 0 && col >= 0 && row < n && col < m && !vis[row][col] && board[row][col] == \\'O\\')\\n                {\\n                    q.push({row,col});\\n                    vis[row][col] = 1;\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i<n; i++)\\n        {\\n            for(int j = 0; j<m; j++)\\n            {\\n                if(board[i][j] == \\'O\\' && !vis[i][j])\\n                {\\n                     board[i][j] = \\'X\\';\\n                }\\n            }\\n            \\n        }\\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400731,
                "title": "easy-c-solution",
                "content": "class Solution {\\npublic:\\n    \\n    void dfs(int i, int j, int n, int m, vector<vector<char>> &board){\\n        if(i<0 || i>n || j<0 || j>m){\\n            return;\\n        }\\n        if(board[i][j] == \\'X\\' || board[i][j] == \\'1\\'){\\n            return;\\n        }\\n        board[i][j] = \\'1\\';\\n        dfs(i, j-1, n, m, board);\\n        dfs(i, j+1, n, m, board);\\n        dfs(i-1, j, n, m, board);\\n        dfs(i+1, j, n, m, board);\\n    }\\n    void solve(vector<vector<char>> &board) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if((i==0 || i==n-1 || j==0 || j==m-1) && board[i][j] == \\'O\\'){\\n                    dfs(i, j, n-1, m-1, board);\\n                }\\n            }\\n        }\\n        for(int i=0; i<n; i++){\\n            for(int j=0; j<m; j++){\\n                if(board[i][j] == \\'O\\'){\\n                    board[i][j] = \\'X\\';\\n                }\\n                else if(board[i][j] == \\'1\\'){\\n                    board[i][j] = \\'O\\';\\n                }\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    void dfs(int i, int j, int n, int m, vector<vector<char>> &board){\\n        if(i<0 || i>n || j<0 || j>m){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3390237,
                "title": "c-solution-explained-and-commented-constant-space-easy-recursion",
                "content": "# Explanation\\n*So, the only O which is not completely surronded by X is safe.*\\n- My approach is to first go to every edge or corner O\\n- Then I marked them as P (protected)\\n- Then I got to every neighbour and if it is O then marked them as P.\\n- After the loop I can see every O which cannot be changed to X is marked as P.\\n- Now I just have to change these P->O  and O->X after this conversion my solution should be completed\\n\\n# Complexity\\n- Time complexity: O(m*n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int r=board.size(),c=board[0].size();\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(i==0 || i==r-1 || j==0 || j==c-1){  // To check every edge and corner of the grid\\n                    dfs(r,c,i,j,board);                    \\n                }\\n            }\\n        }\\n        change(board);        \\n    }\\n    void dfs(int r,int c,int i,int j,vector<vector<char>>& grid){\\n        if(i<0 || i>=r || j<0 || j>=c) return;  // If we get outside of the grid\\n        if(grid[i][j]==\\'O\\'){  // If we find any O at the edge or corner\\n            grid[i][j]=\\'P\\';  // I marked it as protected\\n            dfs(r,c,i+1,j,grid);  // For the lower neighbour\\n            dfs(r,c,i-1,j,grid);  // For the upper neighbour\\n            dfs(r,c,i,j+1,grid);  // For the right neighbour\\n            dfs(r,c,i,j-1,grid);  // For the left neighbour\\n        }\\n    }\\n    void change(vector<vector<char>>& board){\\n        for(auto &i:board){\\n            for(auto &j:i){\\n                if(j==\\'P\\')  // P is changed to O as it remains the same\\n                    j=\\'O\\';\\n                else if(j==\\'O\\')  // O is changed to X as it was surrounded by everyside\\n                    j=\\'X\\';\\n            }\\n        }\\n    }\\n};\\n```\\n![upvote cat.jpeg](https://assets.leetcode.com/users/images/c242d4d3-c4c6-4446-be83-650298f90381_1680869896.6513474.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int r=board.size(),c=board[0].size();\\n        for(int i=0;i<r;i++){\\n            for(int j=0;j<c;j++){\\n                if(i==0 || i==r-1 || j==0 || j==c-1){  // To check every edge and corner of the grid\\n                    dfs(r,c,i,j,board);                    \\n                }\\n            }\\n        }\\n        change(board);        \\n    }\\n    void dfs(int r,int c,int i,int j,vector<vector<char>>& grid){\\n        if(i<0 || i>=r || j<0 || j>=c) return;  // If we get outside of the grid\\n        if(grid[i][j]==\\'O\\'){  // If we find any O at the edge or corner\\n            grid[i][j]=\\'P\\';  // I marked it as protected\\n            dfs(r,c,i+1,j,grid);  // For the lower neighbour\\n            dfs(r,c,i-1,j,grid);  // For the upper neighbour\\n            dfs(r,c,i,j+1,grid);  // For the right neighbour\\n            dfs(r,c,i,j-1,grid);  // For the left neighbour\\n        }\\n    }\\n    void change(vector<vector<char>>& board){\\n        for(auto &i:board){\\n            for(auto &j:i){\\n                if(j==\\'P\\')  // P is changed to O as it remains the same\\n                    j=\\'O\\';\\n                else if(j==\\'O\\')  // O is changed to X as it was surrounded by everyside\\n                    j=\\'X\\';\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3357624,
                "title": "easy-clear-solution-python-3-beat-99-8",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def solve(self, b: List[List[str]]) -> None:\\n        m=len(b)\\n        n=len(b[0])\\n        def dfs(i,j):\\n            if b[i][j]==\"O\":\\n                b[i][j]=\"P\"\\n                if i<m-1:\\n                    dfs(i+1,j)\\n                if i>0:\\n                    dfs(i-1,j)\\n                if j<n-1:\\n                    dfs(i,j+1)\\n                if j>0:\\n                    dfs(i,j-1)\\n        for i in [0,m-1]:\\n            for j in range(n):\\n                dfs(i,j)\\n        for j in [0,n-1]:\\n            for i in range(m):\\n                dfs(i,j)\\n        for i in range(m):\\n            for j in range(n):\\n                if b[i][j]==\"O\":\\n                    b[i][j]=\"X\"\\n        for i in range(m):\\n            for j in range(n):\\n                if b[i][j]==\"P\":\\n                    b[i][j]=\"O\"\\n\\n\\n\\n            \\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def solve(self, b: List[List[str]]) -> None:\\n        m=len(b)\\n        n=len(b[0])\\n        def dfs(i,j):\\n            if b[i][j]==\"O\":\\n                b[i][j]=\"P\"\\n                if i<m-1:\\n                    dfs(i+1,j)\\n                if i>0:\\n                    dfs(i-1,j)\\n                if j<n-1:\\n                    dfs(i,j+1)\\n                if j>0:\\n                    dfs(i,j-1)\\n        for i in [0,m-1]:\\n            for j in range(n):\\n                dfs(i,j)\\n        for j in [0,n-1]:\\n            for i in range(m):\\n                dfs(i,j)\\n        for i in range(m):\\n            for j in range(n):\\n                if b[i][j]==\"O\":\\n                    b[i][j]=\"X\"\\n        for i in range(m):\\n            for j in range(n):\\n                if b[i][j]==\"P\":\\n                    b[i][j]=\"O\"\\n\\n\\n\\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3288737,
                "title": "best-o-m-n-solution",
                "content": "# Approach 1\\nUsing BFS\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$ \\n\\n- Space complexity:\\n$$O(m*n)$$ \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        vector<vector<int>> visited(m , vector<int>(n, 0));\\n        queue <pair<int, int>> q;\\n        for (int i = 0; i < n; i++) {\\n            if (board[0][i] == \\'O\\') {\\n                q.push({0, i});\\n                visited[0][i] = 1;\\n            }\\n            if (board[m-1][i] == \\'O\\') {\\n                q.push({m-1, i});\\n                visited[m-1][i] = 1; \\n            }   \\n        }\\n        for (int i = 0; i < m; i++) {\\n            if (board[i][0] == \\'O\\') {\\n                q.push({i, 0});\\n                visited[i][0] = 1;\\n            }\\n            if (board[i][n-1] == \\'O\\') {\\n                q.push({i, n-1}); \\n                visited[i][n-1] = 1; \\n            } \\n        }\\n        int drow[] = {-1, 0, +1, 0};\\n        int dcol[] = {0, +1, 0, -1};\\n        while (!q.empty()) {\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            for (int i = 0; i < 4; i++) {\\n                    int nrow = row + drow[i];\\n                    int ncol = col + dcol[i];\\n                    if (nrow >= 0 && nrow < m && ncol >= 0 && ncol < n &&\\n                        board[nrow][ncol] == \\'O\\' && visited[nrow][ncol] == 0) {\\n                            q.push({nrow, ncol});\\n                            visited[nrow][ncol] = 1;\\n                        }\\n                }\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == \\'O\\' && visited[i][j] == 0)\\n                    board[i][j] = \\'X\\';\\n            }\\n        }\\n    }\\n};\\n```\\n\\n# Approach 2\\nUsing DFS\\n\\n# Complexity\\n- Time complexity:\\n$$O(m*n)$$ \\n\\n- Space complexity:\\n$$O(m*n)$$ \\n\\n# Code\\n```\\nclass Solution {\\nprivate:\\n    void dfs(int row, int col, vector<vector<char>>& board, \\n            vector<vector<int>>& visited, int drow[], int dcol[]) {\\n                int m = board.size();\\n                int n = board[0].size();\\n                visited[row][col] = 1;\\n                for (int i = 0; i < 4; i++) {\\n                    int nrow = row + drow[i];\\n                    int ncol = col + dcol[i];\\n                    if (nrow >= 0 && nrow < m && ncol >= 0 && ncol < n &&\\n                        board[nrow][ncol] == \\'O\\' && visited[nrow][ncol] == 0) {\\n                            dfs(nrow, ncol, board, visited, drow, dcol);\\n                        }\\n                }\\n    }    \\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        vector<vector<int>> visited(m , vector<int>(n, 0));\\n        int drow[] = {-1, 0, +1, 0};\\n        int dcol[] = {0, +1, 0, -1};\\n        for (int i = 0; i < n; i++) {\\n            if (board[0][i] == \\'O\\' && visited[0][i] == 0)\\n                dfs(0, i, board, visited, drow, dcol);\\n            if (board[m-1][i] == \\'O\\' && visited[m-1][i] == 0)\\n                dfs(m-1, i, board, visited, drow, dcol);    \\n        }\\n        for (int i = 0; i < m; i++) {\\n            if (board[i][0] == \\'O\\' && visited[i][0] == 0)\\n                dfs(i, 0, board, visited, drow, dcol);\\n            if (board[i][n-1] == \\'O\\' && visited[i][n-1] == 0)\\n                dfs(i, n-1, board, visited, drow, dcol);    \\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == \\'O\\' && visited[i][j] == 0)\\n                    board[i][j] = \\'X\\';\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        vector<vector<int>> visited(m , vector<int>(n, 0));\\n        queue <pair<int, int>> q;\\n        for (int i = 0; i < n; i++) {\\n            if (board[0][i] == \\'O\\') {\\n                q.push({0, i});\\n                visited[0][i] = 1;\\n            }\\n            if (board[m-1][i] == \\'O\\') {\\n                q.push({m-1, i});\\n                visited[m-1][i] = 1; \\n            }   \\n        }\\n        for (int i = 0; i < m; i++) {\\n            if (board[i][0] == \\'O\\') {\\n                q.push({i, 0});\\n                visited[i][0] = 1;\\n            }\\n            if (board[i][n-1] == \\'O\\') {\\n                q.push({i, n-1}); \\n                visited[i][n-1] = 1; \\n            } \\n        }\\n        int drow[] = {-1, 0, +1, 0};\\n        int dcol[] = {0, +1, 0, -1};\\n        while (!q.empty()) {\\n            int row = q.front().first;\\n            int col = q.front().second;\\n            q.pop();\\n            for (int i = 0; i < 4; i++) {\\n                    int nrow = row + drow[i];\\n                    int ncol = col + dcol[i];\\n                    if (nrow >= 0 && nrow < m && ncol >= 0 && ncol < n &&\\n                        board[nrow][ncol] == \\'O\\' && visited[nrow][ncol] == 0) {\\n                            q.push({nrow, ncol});\\n                            visited[nrow][ncol] = 1;\\n                        }\\n                }\\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == \\'O\\' && visited[i][j] == 0)\\n                    board[i][j] = \\'X\\';\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\nprivate:\\n    void dfs(int row, int col, vector<vector<char>>& board, \\n            vector<vector<int>>& visited, int drow[], int dcol[]) {\\n                int m = board.size();\\n                int n = board[0].size();\\n                visited[row][col] = 1;\\n                for (int i = 0; i < 4; i++) {\\n                    int nrow = row + drow[i];\\n                    int ncol = col + dcol[i];\\n                    if (nrow >= 0 && nrow < m && ncol >= 0 && ncol < n &&\\n                        board[nrow][ncol] == \\'O\\' && visited[nrow][ncol] == 0) {\\n                            dfs(nrow, ncol, board, visited, drow, dcol);\\n                        }\\n                }\\n    }    \\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        vector<vector<int>> visited(m , vector<int>(n, 0));\\n        int drow[] = {-1, 0, +1, 0};\\n        int dcol[] = {0, +1, 0, -1};\\n        for (int i = 0; i < n; i++) {\\n            if (board[0][i] == \\'O\\' && visited[0][i] == 0)\\n                dfs(0, i, board, visited, drow, dcol);\\n            if (board[m-1][i] == \\'O\\' && visited[m-1][i] == 0)\\n                dfs(m-1, i, board, visited, drow, dcol);    \\n        }\\n        for (int i = 0; i < m; i++) {\\n            if (board[i][0] == \\'O\\' && visited[i][0] == 0)\\n                dfs(i, 0, board, visited, drow, dcol);\\n            if (board[i][n-1] == \\'O\\' && visited[i][n-1] == 0)\\n                dfs(i, n-1, board, visited, drow, dcol);    \\n        }\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == \\'O\\' && visited[i][j] == 0)\\n                    board[i][j] = \\'X\\';\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2968566,
                "title": "easy-dfs-and-bfs-c-solution-simple",
                "content": "## BFS\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int n= board.size();\\n        int m= board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        queue<pair<int,int>> q;\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                if (i==0 || j==0 || i==(n-1) || j==(m-1)){\\n                    if (board[i][j]==\\'O\\'){\\n                        q.push({i,j});\\n                        vis[i][j]=1;\\n                    }\\n                }    \\n            }\\n        }\\n        int dx[]= {0,1,0,-1};\\n        int dy[]= {1,0,-1,0};\\n        while (!q.empty()){\\n            int x= q.front().first;\\n            int y= q.front().second;\\n            q.pop();\\n            for (int i=0; i<4; i++){\\n                int nr= x+dx[i];\\n                int nc= y+dy[i];\\n                if (nr>=0 && nr<n && nc>=0 && nc<m && board[nr][nc]==\\'O\\' && !vis[nr][nc]){\\n                    vis[nr][nc]=1;\\n                    q.push({nr,nc});\\n                }\\n            }\\n        }\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                if (board[i][j]==\\'O\\' && !vis[i][j])board[i][j]=\\'X\\';\\n            }\\n        }\\n        \\n    }\\n}; \\n\\n```\\n### Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\n## DFS\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<char>>& board, int x, int y, vector<vector<int>>& vis, int dx[],int dy[],int n, int m){\\n        for (int i=0; i<4; i++){\\n            int nr= x+ dx[i];\\n            int nc= y+ dy[i];\\n            if (nr>=0 && nr<n && nc>=0 && nc<m && !vis[nr][nc] && board[nr][nc]==\\'O\\'){\\n                vis[nr][nc]=1;\\n                dfs(board,nr,nc,vis,dx,dy,n,m);\\n            }\\n        }\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int n= board.size();\\n        int m= board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int dx[]= {0,1,0,-1};\\n        int dy[]= {1,0,-1,0};\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                if (i==0 || j==0 || i==(n-1) || j==(m-1)){\\n                    if (board[i][j]==\\'O\\' && !vis[i][j]){\\n                        vis[i][j]=1;\\n                        dfs(board,i,j,vis,dx,dy,n,m);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                if (board[i][j]==\\'O\\' && !vis[i][j])board[i][j]=\\'X\\';\\n            }\\n        }\\n        \\n    }\\n};\\n*/\\n```\\n### Complexity\\n- Time complexity: $$O(n*m)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n*m)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int n= board.size();\\n        int m= board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        queue<pair<int,int>> q;\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                if (i==0 || j==0 || i==(n-1) || j==(m-1)){\\n                    if (board[i][j]==\\'O\\'){\\n                        q.push({i,j});\\n                        vis[i][j]=1;\\n                    }\\n                }    \\n            }\\n        }\\n        int dx[]= {0,1,0,-1};\\n        int dy[]= {1,0,-1,0};\\n        while (!q.empty()){\\n            int x= q.front().first;\\n            int y= q.front().second;\\n            q.pop();\\n            for (int i=0; i<4; i++){\\n                int nr= x+dx[i];\\n                int nc= y+dy[i];\\n                if (nr>=0 && nr<n && nc>=0 && nc<m && board[nr][nc]==\\'O\\' && !vis[nr][nc]){\\n                    vis[nr][nc]=1;\\n                    q.push({nr,nc});\\n                }\\n            }\\n        }\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                if (board[i][j]==\\'O\\' && !vis[i][j])board[i][j]=\\'X\\';\\n            }\\n        }\\n        \\n    }\\n}; \\n\\n```\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<char>>& board, int x, int y, vector<vector<int>>& vis, int dx[],int dy[],int n, int m){\\n        for (int i=0; i<4; i++){\\n            int nr= x+ dx[i];\\n            int nc= y+ dy[i];\\n            if (nr>=0 && nr<n && nc>=0 && nc<m && !vis[nr][nc] && board[nr][nc]==\\'O\\'){\\n                vis[nr][nc]=1;\\n                dfs(board,nr,nc,vis,dx,dy,n,m);\\n            }\\n        }\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int n= board.size();\\n        int m= board[0].size();\\n        vector<vector<int>> vis(n,vector<int>(m,0));\\n        int dx[]= {0,1,0,-1};\\n        int dy[]= {1,0,-1,0};\\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                if (i==0 || j==0 || i==(n-1) || j==(m-1)){\\n                    if (board[i][j]==\\'O\\' && !vis[i][j]){\\n                        vis[i][j]=1;\\n                        dfs(board,i,j,vis,dx,dy,n,m);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (int i=0; i<n; i++){\\n            for (int j=0; j<m; j++){\\n                if (board[i][j]==\\'O\\' && !vis[i][j])board[i][j]=\\'X\\';\\n            }\\n        }\\n        \\n    }\\n};\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2743369,
                "title": "graph-traversal",
                "content": "The problem asks to convert all O\\'s into X\\'s provided:\\n i) O does not lie on broder\\n ii) Following path formed by O\\'s doesn\\'t take to border.\\n \\n We will just traverse the boundary and check if the cell contains O, if the cell contains O , we will do traversal on the cell, and mark it visited.\\n Once ,we are done checking for border O\\'s, we will traverse in entire grid and check for unvisited cells that have O ,if a match is found make the cell X.\\n \\n TC: O(N*M) \\n SC: O(N*M) \\n \\n\\n```\\nclass Solution {\\n    public void solve(char[][] board) {\\n        int r = board.length;\\n        int c = board[0].length;\\n        \\n        int[][]vis = new int[r][c];\\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n                if(board[i][j]==\\'O\\' && vis[i][j]==0 && (i ==0 || j==0 || i== r-1 || j==c-1 ))\\n                {\\n                    dfs(i,j,vis,board,r,c);\\n                }\\n            }\\n        }\\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n                if(board[i][j]==\\'O\\' && vis[i][j]!=1)\\n                {\\n                    board[i][j]=\\'X\\';\\n                }\\n            }\\n        }\\n        \\n    }\\n    \\n    public void dfs(int row, int col,int[][]vis,char[][] board, int r, int c)\\n    {\\n        vis[row][col]=1;\\n        for(int i=-1; i<=1; i++)\\n        {\\n            for(int j=-1; j<=1; j++)\\n            {\\n              if(i !=j && i != -j)\\n              {\\n                int nrow = row + i;\\n                int ncol = col + j;\\n                if(nrow >=0 && nrow <= r-1 && ncol >=0 && ncol <= c-1 && vis[nrow][ncol]==0 && board[nrow][ncol]==\\'O\\' )\\n                {\\n\\n                    dfs(nrow,ncol,vis,board,r,c);\\n                }\\n              }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public void solve(char[][] board) {\\n        int r = board.length;\\n        int c = board[0].length;\\n        \\n        int[][]vis = new int[r][c];\\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n                if(board[i][j]==\\'O\\' && vis[i][j]==0 && (i ==0 || j==0 || i== r-1 || j==c-1 ))\\n                {\\n                    dfs(i,j,vis,board,r,c);\\n                }\\n            }\\n        }\\n        for(int i=0; i<r; i++)\\n        {\\n            for(int j=0; j<c; j++)\\n            {\\n                if(board[i][j]==\\'O\\' && vis[i][j]!=1)\\n                {\\n                    board[i][j]=\\'X\\';\\n                }\\n            }\\n        }\\n        \\n    }\\n    \\n    public void dfs(int row, int col,int[][]vis,char[][] board, int r, int c)\\n    {\\n        vis[row][col]=1;\\n        for(int i=-1; i<=1; i++)\\n        {\\n            for(int j=-1; j<=1; j++)\\n            {\\n              if(i !=j && i != -j)\\n              {\\n                int nrow = row + i;\\n                int ncol = col + j;\\n                if(nrow >=0 && nrow <= r-1 && ncol >=0 && ncol <= c-1 && vis[nrow][ncol]==0 && board[nrow][ncol]==\\'O\\' )\\n                {\\n\\n                    dfs(nrow,ncol,vis,board,r,c);\\n                }\\n              }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472655,
                "title": "golang-solve-it-using-union-find",
                "content": "- Firstly, group all connecting \\'O\\' by its root thanks to Union find.\\n\\n```\\n[                                                       \\n           [\"X\",\"X\",\"X\",\"X\"],                           \\n           [\"X\",\"O\",\"O\",\"X\"],\\n           [\"X\",\"X\",\"O\",\"X\"],\\n           [\"X\",\"O\",\"X\",\"X\"] \\n]\\n\\n---> \\n\\nInit with its root:\\n\\n[\\n    [0, 1, 2, 3],\\n    [4, 5, 6, 7],\\n    [8, 9, 10, 11],\\n    [12, 13, 14, 15]\\n]\\n\\n\\n--->\\n\\nAfter the joining roots step:\\n[\\n    [0 1 2 3],\\n    [4 5 5 7],\\n    [8 9 5 11],\\n    [12 13 14 15]\\n]\\n```\\n- During above step, we also want to store positions has value `\\'O\\'` reaches the border to `memo`.\\n- Finally, replacing \\'`O\\'` with `\\'X\\'` for root position of `\\'O\\'` not stored in `memo`.\\n\\n```\\nfunc solve(board [][]byte)  {\\n    \\n    initRoot(len(board) * len(board[0]))\\n    reachBorderPos := make(map[int]bool)\\n    for i := 0; i < len(board); i++{\\n        for j := 0; j < len(board[0]); j++{\\n            if board[i][j] == \\'X\\' {\\n                continue\\n            }\\n            \\n            if i - 1 >= 0 && board[i-1][j] == \\'O\\' {\\n                merge(i * (len(board[0])) + j, (i-1) * (len(board[0])) + j, reachBorderPos)\\n            }\\n            \\n            if j - 1 >= 0 && board[i][j-1] == \\'O\\' {\\n                merge(i * (len(board[0])) + j, i * (len(board[0])) + j - 1, reachBorderPos)\\n            }\\n            \\n            if i <= 0 || j <= 0 || i == len(board) - 1 || j == len(board[0]) - 1 {\\n                reachBorderPos[findRoot(i * (len(board[0])) + j)] = true\\n            }\\n        }\\n    }\\n        \\n    for i := 0; i < len(board); i++{\\n        for j := 0; j < len(board[0]); j++{\\n            if board[i][j] == \\'X\\' {\\n                continue\\n            }\\n                        \\n            if reachBorderPos[findRoot(i * (len(board[0])) + j)] {\\n                continue\\n            }\\n            \\n            board[i][j] = \\'X\\'\\n        }\\n    }\\n}\\n\\nvar root = []int{}\\n\\nfunc initRoot(s int) {\\n    root = make([]int, s)\\n    for i := 0; i < s; i++{\\n        root[i] = i\\n    }\\n}\\n\\nfunc findRoot(i int) int {\\n    if root[i] == i {\\n        return i\\n    }\\n    return findRoot(root[i])\\n}\\n\\nfunc merge(i, j int, memo map[int]bool) {\\n    if rootI, rootJ := findRoot(i), findRoot(j); rootI != rootJ {\\n        for idx, v := range root {\\n            if v == rootI {\\n                root[idx] = rootJ\\n                if _, ok := memo[rootI]; ok {\\n                    delete(memo, rootI)\\n                    memo[rootJ] = true   \\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Union Find"
                ],
                "code": "```\\n[                                                       \\n           [\"X\",\"X\",\"X\",\"X\"],                           \\n           [\"X\",\"O\",\"O\",\"X\"],\\n           [\"X\",\"X\",\"O\",\"X\"],\\n           [\"X\",\"O\",\"X\",\"X\"] \\n]\\n\\n---> \\n\\nInit with its root:\\n\\n[\\n    [0, 1, 2, 3],\\n    [4, 5, 6, 7],\\n    [8, 9, 10, 11],\\n    [12, 13, 14, 15]\\n]\\n\\n\\n--->\\n\\nAfter the joining roots step:\\n[\\n    [0 1 2 3],\\n    [4 5 5 7],\\n    [8 9 5 11],\\n    [12 13 14 15]\\n]\\n```\n```\\nfunc solve(board [][]byte)  {\\n    \\n    initRoot(len(board) * len(board[0]))\\n    reachBorderPos := make(map[int]bool)\\n    for i := 0; i < len(board); i++{\\n        for j := 0; j < len(board[0]); j++{\\n            if board[i][j] == \\'X\\' {\\n                continue\\n            }\\n            \\n            if i - 1 >= 0 && board[i-1][j] == \\'O\\' {\\n                merge(i * (len(board[0])) + j, (i-1) * (len(board[0])) + j, reachBorderPos)\\n            }\\n            \\n            if j - 1 >= 0 && board[i][j-1] == \\'O\\' {\\n                merge(i * (len(board[0])) + j, i * (len(board[0])) + j - 1, reachBorderPos)\\n            }\\n            \\n            if i <= 0 || j <= 0 || i == len(board) - 1 || j == len(board[0]) - 1 {\\n                reachBorderPos[findRoot(i * (len(board[0])) + j)] = true\\n            }\\n        }\\n    }\\n        \\n    for i := 0; i < len(board); i++{\\n        for j := 0; j < len(board[0]); j++{\\n            if board[i][j] == \\'X\\' {\\n                continue\\n            }\\n                        \\n            if reachBorderPos[findRoot(i * (len(board[0])) + j)] {\\n                continue\\n            }\\n            \\n            board[i][j] = \\'X\\'\\n        }\\n    }\\n}\\n\\nvar root = []int{}\\n\\nfunc initRoot(s int) {\\n    root = make([]int, s)\\n    for i := 0; i < s; i++{\\n        root[i] = i\\n    }\\n}\\n\\nfunc findRoot(i int) int {\\n    if root[i] == i {\\n        return i\\n    }\\n    return findRoot(root[i])\\n}\\n\\nfunc merge(i, j int, memo map[int]bool) {\\n    if rootI, rootJ := findRoot(i), findRoot(j); rootI != rootJ {\\n        for idx, v := range root {\\n            if v == rootI {\\n                root[idx] = rootJ\\n                if _, ok := memo[rootI]; ok {\\n                    delete(memo, rootI)\\n                    memo[rootJ] = true   \\n                }\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2286720,
                "title": "java-solution-dfs-solution",
                "content": "The Solution for this problem is slightly tricky.\\n1- we need to see all the boundries  \\'O\\' \\n2- then we just need to make those \\'O\\' to some other Symbol like \\'#\\'\\n3- then will go in dfs order and check the nearby \\'O\\'s and change them also to some specific symbol \\'#\\'.\\n4- we will find the remaining \\'O\\' and make those \\'O\\' to \\'X\\'.\\n5- then will make those special symbol \\'*\\' to \\'O\\' again because those are not modifiable to \\'X\\'\\n6- Done :) please Upvote if its helpful.\\n```\\nclass Solution {\\n    public void solve(char[][] board) {\\n        int m = board.length;\\n        int n = board[0].length;\\n    \\n        for (int i = 0 ; i < n; i++  ){\\n            if(board[0][i] == \\'O\\')\\n                dfs(0, i, board);\\n            if(board[m-1][i] == \\'O\\')\\n                dfs( m-1, i,board);\\n        }\\n        for (int i = 0 ; i < m; i++  ){\\n            if(board[i][0] == \\'O\\')\\n               dfs( i, 0, board); \\n            if(board[i][n-1] == \\'O\\')\\n               dfs( i, n-1, board);\\n        }\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                if(board[i][j] == \\'O\\')\\n                    board[i][j] = \\'X\\';\\n                if(board[i][j] == \\'#\\')\\n                    board[i][j] = \\'O\\';\\n            }\\n        }\\n        \\n    }\\n    void dfs(int row , int col, char[][]board){\\n        if(row < 0 || row > board.length-1 || col < 0 || col > board[0].length-1 || board[row][col] == \\'#\\' || board[row][col] == \\'X\\' )\\n            return;\\n        board[row][col] = \\'#\\';\\n        dfs(row, col+1, board);\\n        dfs(row, col-1, board);\\n        dfs(row+1, col, board);\\n     \\n\\t dfs(row-1, col, board);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public void solve(char[][] board) {\\n        int m = board.length;\\n        int n = board[0].length;\\n    \\n        for (int i = 0 ; i < n; i++  ){\\n            if(board[0][i] == \\'O\\')\\n                dfs(0, i, board);\\n            if(board[m-1][i] == \\'O\\')\\n                dfs( m-1, i,board);\\n        }\\n        for (int i = 0 ; i < m; i++  ){\\n            if(board[i][0] == \\'O\\')\\n               dfs( i, 0, board); \\n            if(board[i][n-1] == \\'O\\')\\n               dfs( i, n-1, board);\\n        }\\n        for(int i = 0 ; i < m ; i++){\\n            for(int j = 0 ; j < n ; j++){\\n                if(board[i][j] == \\'O\\')\\n                    board[i][j] = \\'X\\';\\n                if(board[i][j] == \\'#\\')\\n                    board[i][j] = \\'O\\';\\n            }\\n        }\\n        \\n    }\\n    void dfs(int row , int col, char[][]board){\\n        if(row < 0 || row > board.length-1 || col < 0 || col > board[0].length-1 || board[row][col] == \\'#\\' || board[row][col] == \\'X\\' )\\n            return;\\n        board[row][col] = \\'#\\';\\n        dfs(row, col+1, board);\\n        dfs(row, col-1, board);\\n        dfs(row+1, col, board);\\n     \\n\\t dfs(row-1, col, board);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1553068,
                "title": "clean-c-dfs-solution-o-n",
                "content": "## Idea:\\nPeform depth first search on all the edge elements of the board to mark all the connected elements with a different flag (in my case \\'V\\' for visisted). Then afterward, mark all the element that are not visisted as \\'X\\' and visisted node back to \\'O\\'.\\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int n = board.size(), m = board[0].size();\\n        for(int i = 0 ; i < n ; i++){\\n            dfs(board,i,0);\\n            dfs(board,i,m-1);\\n        }\\n        for(int j = 0 ; j < m ; j++){\\n            dfs(board,0,j);\\n            dfs(board,n-1,j);\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                if(board[i][j]==\\'V\\')board[i][j] = \\'O\\';\\n                else board[i][j] = \\'X\\';\\n            }\\n        }\\n    }\\n    \\n    void dfs(vector<vector<char>>& board, int r, int c){\\n        if(r < 0 || c < 0 || r >= board.size() || c >= board[0].size())return;\\n        if(board[r][c]!=\\'O\\')return;\\n        board[r][c] = \\'V\\';\\n        dfs(board, r+1, c);\\n        dfs(board, r-1, c);\\n        dfs(board, r, c+1);\\n        dfs(board, r, c-1);\\n    }\\n};\\n```\\n\\n## Complexity\\nLet n  be the number of element in the grid.\\nTime: O(n)\\nSpace: O(n)\\n\\n**If you like this solution, feel free to upvote. If you have any question, feel free to comment down below and I will get back to you.**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int n = board.size(), m = board[0].size();\\n        for(int i = 0 ; i < n ; i++){\\n            dfs(board,i,0);\\n            dfs(board,i,m-1);\\n        }\\n        for(int j = 0 ; j < m ; j++){\\n            dfs(board,0,j);\\n            dfs(board,n-1,j);\\n        }\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                if(board[i][j]==\\'V\\')board[i][j] = \\'O\\';\\n                else board[i][j] = \\'X\\';\\n            }\\n        }\\n    }\\n    \\n    void dfs(vector<vector<char>>& board, int r, int c){\\n        if(r < 0 || c < 0 || r >= board.size() || c >= board[0].size())return;\\n        if(board[r][c]!=\\'O\\')return;\\n        board[r][c] = \\'V\\';\\n        dfs(board, r+1, c);\\n        dfs(board, r-1, c);\\n        dfs(board, r, c+1);\\n        dfs(board, r, c-1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552971,
                "title": "python-dfs-solution-broken-down-in-detail",
                "content": "**Idea or Intuition:**\\n* Now the first and foremost idea that you should get in your mind is that, If we can find all **O\\'s** that are connected to each other from the **borders of the grid**, it should be not be turned into **X**\\n* Now that we have the wrong answers in our hand, we can reverse out the answer.\\n\\n**Approach:**\\n * Start a **dfs()** function at every **O** in **borders** of the grid and change all those **O\\'s** which are connected adjacently to eachother to **S**.\\n * Now loop through **all the borders** of the grid and change every **S** back to **O**.\\n * Now loop through the whole grid **excluding the borders** and change every **O** to **X** and every **S** back to **O**.\\n\\nPlease do upvote if you like!\\n\\n```\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        def dfs(x,y):\\n            if not (0<=x<n and 0<=y<m) or board[x][y]!=\\'O\\':\\n                return\\n            board[x][y] = \\'S\\'\\n            dfs(x+1,y) ; dfs(x-1,y) # up and down\\n            dfs(x,y+1) ; dfs(x,y-1) # left and right\\n            \\n        n = len(board) # no of rows\\n        m = len(board[0]) # no of column\\n        \\n        # Looping throw the first and last column to find \\'O\\'\\n        for i in range(n):\\n            dfs(i,0)\\n            dfs(i,m-1)\\n        \\n        # Looping throw the first and last row to find \\'O\\'\\n        for j in range(m):\\n            dfs(0,j)\\n            dfs(n-1,j)\\n        \\n        # Now Change the \\'S\\' that are in borders to \\'O\\'\\n        \\n        # Changin the \\'S\\' in first and last column to \\'O\\'\\n        for i in range(n):\\n            if board[i][0] == \\'S\\': board[i][0] = \\'O\\'\\n            if board[i][m-1] == \\'S\\': board[i][m-1] = \\'O\\'\\n                \\n        # Changin the \\'S\\' in first and last row to \\'O\\'\\n        for j in range(m):\\n            if board[0][j] == \\'S\\': board[0][j] = \\'O\\'\\n            if board[n-1][j] == \\'S\\': board[n-1][j] = \"O\"\\n                \\n        \"\"\"\\n        Now all the \\'S\\' which are inside the border are not surrounded \\n        by X, so change it to \\'O\\' and rest of the \\'O\\' can be \\n        converted to \\'X\\' as it is surrounded by \\'X\\'\\n        \"\"\"\\n        \\n        for i in range(1,n-1):\\n            for j in range(1,m-1):\\n                if board[i][j] == \\'O\\': board[i][j] = \"X\"\\n                if board[i][j] == \"S\": board[i][j] = \"O\"\\n                    \\n        \\n```\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        def dfs(x,y):\\n            if not (0<=x<n and 0<=y<m) or board[x][y]!=\\'O\\':\\n                return\\n            board[x][y] = \\'S\\'\\n            dfs(x+1,y) ; dfs(x-1,y) # up and down\\n            dfs(x,y+1) ; dfs(x,y-1) # left and right\\n            \\n        n = len(board) # no of rows\\n        m = len(board[0]) # no of column\\n        \\n        # Looping throw the first and last column to find \\'O\\'\\n        for i in range(n):\\n            dfs(i,0)\\n            dfs(i,m-1)\\n        \\n        # Looping throw the first and last row to find \\'O\\'\\n        for j in range(m):\\n            dfs(0,j)\\n            dfs(n-1,j)\\n        \\n        # Now Change the \\'S\\' that are in borders to \\'O\\'\\n        \\n        # Changin the \\'S\\' in first and last column to \\'O\\'\\n        for i in range(n):\\n            if board[i][0] == \\'S\\': board[i][0] = \\'O\\'\\n            if board[i][m-1] == \\'S\\': board[i][m-1] = \\'O\\'\\n                \\n        # Changin the \\'S\\' in first and last row to \\'O\\'\\n        for j in range(m):\\n            if board[0][j] == \\'S\\': board[0][j] = \\'O\\'\\n            if board[n-1][j] == \\'S\\': board[n-1][j] = \"O\"\\n                \\n        \"\"\"\\n        Now all the \\'S\\' which are inside the border are not surrounded \\n        by X, so change it to \\'O\\' and rest of the \\'O\\' can be \\n        converted to \\'X\\' as it is surrounded by \\'X\\'\\n        \"\"\"\\n        \\n        for i in range(1,n-1):\\n            for j in range(1,m-1):\\n                if board[i][j] == \\'O\\': board[i][j] = \"X\"\\n                if board[i][j] == \"S\": board[i][j] = \"O\"\\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552160,
                "title": "c-bfs-and-dfs-approach",
                "content": "1. DFS approach: \\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<char>> &board, vector<vector<bool>> &visited, int i, int j) {\\n        int m = board.size();\\n        int n = board[0].size();\\n\\n        if (!visited[i][j] && board[i][j] == \\'O\\') {\\n            visited[i][j] = true;\\n            if (i - 1 >= 0)\\n                dfs(board, visited, i - 1, j);\\n            if (j - 1 >= 0)\\n                dfs(board, visited, i, j - 1);\\n\\n            if (i + 1 < m)\\n                dfs(board, visited, i + 1, j);\\n            if (j + 1 < n)\\n                dfs(board, visited, i, j + 1);\\n        }\\n    }\\n\\n\\n    void solve(vector<vector<char>> &board) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        // cout<<m<<\" \"<<n<<endl;\\n\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n\\n        for (int i = 0; i < m; i++) {\\n            dfs(board, visited, i, 0);\\n            dfs(board, visited, i, n - 1);\\n        }\\n        for (int j = 0; j < n; j++) {\\n            dfs(board, visited, 0, j);\\n            dfs(board, visited, m - 1, j);\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (!visited[i][j])\\n                    board[i][j] = \\'X\\';\\n            }\\n        }\\n    }\\n};\\n```\\n\\n2. BFS approach: \\n\\n```\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<char>> &board, vector<vector<bool>> &visited) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        queue<pair<int, int>> q;\\n\\n        //border \\'O\\'\\n        for (int i = 0; i < m; i++) {\\n            if (board[i][0] == \\'O\\')\\n                q.push({i, 0});\\n            if (board[i][n - 1] == \\'O\\')\\n                q.push({i, n - 1});\\n        }\\n\\n        //border \\'O\\'\\n        for (int j = 1; j < n - 1; j++) {\\n            if (board[0][j] == \\'O\\')\\n                q.push({0, j});\\n            if (board[m - 1][j] == \\'O\\')\\n                q.push({m - 1, j});\\n        }\\n\\n        while (!q.empty()) {\\n            int i = q.front().first;\\n            int j = q.front().second;\\n            visited[i][j] = true;\\n            q.pop();\\n\\n            //up\\n            if (i - 1 >= 0 && board[i - 1][j] == \\'O\\' && !visited[i - 1][j])\\n                q.push({i - 1, j});\\n            //down\\n            if (i + 1 < m && board[i + 1][j] == \\'O\\' && !visited[i + 1][j])\\n                q.push({i + 1, j});\\n            // left\\n            if (j - 1 >= 0 && board[i][j - 1] == \\'O\\' && !visited[i][j - 1])\\n                q.push({i, j - 1});\\n            //right\\n            if (j + 1 < n && board[i][j + 1] == \\'O\\' && !visited[i][j + 1])\\n                q.push({i, j + 1});\\n        }\\n    }\\n\\n\\n    void solve(vector<vector<char>> &board) {\\n        int m = board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n\\n        bfs(board, visited);\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (!visited[i][j])\\n                    board[i][j] = \\'X\\';\\n            }\\n        }\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Recursion",
                    "Matrix"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<char>> &board, vector<vector<bool>> &visited, int i, int j) {\\n        int m = board.size();\\n        int n = board[0].size();\\n\\n        if (!visited[i][j] && board[i][j] == \\'O\\') {\\n            visited[i][j] = true;\\n            if (i - 1 >= 0)\\n                dfs(board, visited, i - 1, j);\\n            if (j - 1 >= 0)\\n                dfs(board, visited, i, j - 1);\\n\\n            if (i + 1 < m)\\n                dfs(board, visited, i + 1, j);\\n            if (j + 1 < n)\\n                dfs(board, visited, i, j + 1);\\n        }\\n    }\\n\\n\\n    void solve(vector<vector<char>> &board) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        // cout<<m<<\" \"<<n<<endl;\\n\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n\\n        for (int i = 0; i < m; i++) {\\n            dfs(board, visited, i, 0);\\n            dfs(board, visited, i, n - 1);\\n        }\\n        for (int j = 0; j < n; j++) {\\n            dfs(board, visited, 0, j);\\n            dfs(board, visited, m - 1, j);\\n        }\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (!visited[i][j])\\n                    board[i][j] = \\'X\\';\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void bfs(vector<vector<char>> &board, vector<vector<bool>> &visited) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        queue<pair<int, int>> q;\\n\\n        //border \\'O\\'\\n        for (int i = 0; i < m; i++) {\\n            if (board[i][0] == \\'O\\')\\n                q.push({i, 0});\\n            if (board[i][n - 1] == \\'O\\')\\n                q.push({i, n - 1});\\n        }\\n\\n        //border \\'O\\'\\n        for (int j = 1; j < n - 1; j++) {\\n            if (board[0][j] == \\'O\\')\\n                q.push({0, j});\\n            if (board[m - 1][j] == \\'O\\')\\n                q.push({m - 1, j});\\n        }\\n\\n        while (!q.empty()) {\\n            int i = q.front().first;\\n            int j = q.front().second;\\n            visited[i][j] = true;\\n            q.pop();\\n\\n            //up\\n            if (i - 1 >= 0 && board[i - 1][j] == \\'O\\' && !visited[i - 1][j])\\n                q.push({i - 1, j});\\n            //down\\n            if (i + 1 < m && board[i + 1][j] == \\'O\\' && !visited[i + 1][j])\\n                q.push({i + 1, j});\\n            // left\\n            if (j - 1 >= 0 && board[i][j - 1] == \\'O\\' && !visited[i][j - 1])\\n                q.push({i, j - 1});\\n            //right\\n            if (j + 1 < n && board[i][j + 1] == \\'O\\' && !visited[i][j + 1])\\n                q.push({i, j + 1});\\n        }\\n    }\\n\\n\\n    void solve(vector<vector<char>> &board) {\\n        int m = board.size();\\n        int n = board[0].size();\\n\\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n\\n        bfs(board, visited);\\n\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (!visited[i][j])\\n                    board[i][j] = \\'X\\';\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1551934,
                "title": "simple-best-solution",
                "content": "class Solution {\\npublic:\\n    \\n    void change(vector<vector<char>>& board , int i , int j){\\n        board[i][j] = \\'*\\';\\n        int dx[] = {0 ,0 ,-1,1};\\n        int dy[] = {1,-1 ,0,0};\\n        for(int k=0;k<4;k++){\\n            int cx = i +dx[k];\\n            int cy = j+ dy[k];\\n            if(cx>=0 && cx<board.size() && cy>=0 && cy<board[0].size() && board[cx][cy]==\\'O\\'){\\n                change(board, cx ,cy);\\n            }\\n        }\\n    }\\n    \\n    void solve(vector<vector<char>>& board) {\\n        int n= board.size();\\n        int m = board[0].size();\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 || i==n-1 || j==0 || j==m-1 ){\\n                    if(board[i][j]==\\'O\\'){\\n                    change(board, i, j);\\n                    }\\n                }\\n            }\\n        }\\n         for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==\\'O\\'){\\n                    board[i][j] = \\'X\\';\\n                }\\n\\t\\t\\t\\telse if(board[i][j]==\\'*\\'){\\n                   board[i][j] = \\'O\\';\\n                }\\n            }\\n        }\\n         \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    void change(vector<vector<char>>& board , int i , int j){\\n        board[i][j] = \\'*\\';\\n        int dx[] = {0 ,0 ,-1,1}",
                "codeTag": "Java"
            },
            {
                "id": 1292067,
                "title": "java-dfs-do-checkout-for-detailed-explanation-o-m-n-complexity",
                "content": "**Do vote up if you like it :)**\\n\\nSince you are expected to flip all the surrounded O\\'s by X\\nSo, we can make a dfs call on all the 4 boundaries of the grid and mark the bounday O\\'s with $ just  to distinguish between the boundary O\\'s and other O\\'s.\\n\\nNow, we wil simply iterate over the whole grid and do the following 2 steps:\\n1) If we find O\\'s make it as X (beacuse now whichever O\\'s you will be finding in the entire grid that will be surrounded by X, since the boundary O\\'s was converted into $)\\n2) If we find $ make it as O\\n\\nNote: The order of these 2 steps is important, otherwise the end result will be all X\\'s in the whole grid, which is not the desired output.\\n\\n-------------------------------------------------------------------------------------------------------------------\\n*//Using direction matrix:*\\n\\n```\\nclass Solution {\\n    \\n    public void solve(char[][] board) {\\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        int row = board.length;\\n        int col = board[0].length;\\n        \\n        for(int i = 0 ; i < col; i++) {\\n            if(board[0][i] == \\'O\\')\\n                dfs(board, 0, i, dir);\\n            if(board[row-1][i] == \\'O\\')\\n                dfs(board, row-1, i, dir);\\n        }\\n        \\n        for(int i = 0 ; i < row; i++) {\\n            if(board[i][0] == \\'O\\')\\n                dfs(board, i, 0, dir);\\n            if(board[i][col-1] == \\'O\\')\\n                dfs(board, i, col-1, dir);\\n        }\\n        \\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(board[i][j] == \\'O\\')\\n                    board[i][j] = \\'X\\';\\n                if(board[i][j] == \\'$\\')\\n                    board[i][j] = \\'O\\';\\n            }\\n        }\\n        return;\\n    }\\n    \\n    public static void dfs(char[][] board, int i, int j, int[][] dir) {\\n        \\n        board[i][j] = \\'$\\';\\n        \\n        for(int d = 0; d < dir.length; d++) {\\n            int x = i + dir[d][0];\\n            int y = j + dir[d][1];\\n            if(x >= 0 && x < board.length && y >= 0 && y < board[0].length && board[x][y] == \\'O\\') {\\n                dfs(board, x, y, dir);\\n            }\\n        }\\n    }\\n}\\n```\\n-------------------------------------------------------------------------------------------\\n\\n*//Without using direction matrix:*\\n\\n```\\nclass Solution {\\n   \\n    public void solve(char[][] board) {\\n     \\n        int row = board.length;\\n        int col = board[0].length;\\n        \\n        for(int i = 0 ; i < col; i++){\\n            if(board[0][i] == \\'O\\')\\n                dfs(board, 0, i);\\n            if(board[row-1][i] == \\'O\\')\\n                dfs(board, row-1, i);\\n        }\\n        \\n        for(int i = 0 ; i < row; i++){\\n            if(board[i][0] == \\'O\\')\\n                dfs(board, i, 0);\\n            if(board[i][col-1] == \\'O\\')\\n                dfs(board, i, col-1);\\n        }\\n        \\n        for(int i = 0; i < row; i++){\\n            for(int j = 0; j < col; j++){\\n                if(board[i][j] == \\'O\\')\\n                    board[i][j] = \\'X\\';\\n                if(board[i][j] == \\'$\\')\\n                    board[i][j] = \\'O\\';\\n            }\\n        }\\n        return;\\n    }\\n    \\n    public static void dfs(char[][] board, int i, int j){\\n        \\n        if(i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] == \\'X\\' || board[i][j] == \\'$\\')\\n            return;\\n        \\n        board[i][j] = \\'$\\';\\n        dfs(board, i-1, j);\\n        dfs(board, i+1, j);\\n        dfs(board, i, j+1);\\n        dfs(board, i, j-1);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    public void solve(char[][] board) {\\n        int[][] dir = {{-1, 0}, {0, 1}, {1, 0}, {0, -1}};\\n        \\n        int row = board.length;\\n        int col = board[0].length;\\n        \\n        for(int i = 0 ; i < col; i++) {\\n            if(board[0][i] == \\'O\\')\\n                dfs(board, 0, i, dir);\\n            if(board[row-1][i] == \\'O\\')\\n                dfs(board, row-1, i, dir);\\n        }\\n        \\n        for(int i = 0 ; i < row; i++) {\\n            if(board[i][0] == \\'O\\')\\n                dfs(board, i, 0, dir);\\n            if(board[i][col-1] == \\'O\\')\\n                dfs(board, i, col-1, dir);\\n        }\\n        \\n        for(int i = 0; i < row; i++) {\\n            for(int j = 0; j < col; j++) {\\n                if(board[i][j] == \\'O\\')\\n                    board[i][j] = \\'X\\';\\n                if(board[i][j] == \\'$\\')\\n                    board[i][j] = \\'O\\';\\n            }\\n        }\\n        return;\\n    }\\n    \\n    public static void dfs(char[][] board, int i, int j, int[][] dir) {\\n        \\n        board[i][j] = \\'$\\';\\n        \\n        for(int d = 0; d < dir.length; d++) {\\n            int x = i + dir[d][0];\\n            int y = j + dir[d][1];\\n            if(x >= 0 && x < board.length && y >= 0 && y < board[0].length && board[x][y] == \\'O\\') {\\n                dfs(board, x, y, dir);\\n            }\\n        }\\n    }\\n}\\n```\n```\\nclass Solution {\\n   \\n    public void solve(char[][] board) {\\n     \\n        int row = board.length;\\n        int col = board[0].length;\\n        \\n        for(int i = 0 ; i < col; i++){\\n            if(board[0][i] == \\'O\\')\\n                dfs(board, 0, i);\\n            if(board[row-1][i] == \\'O\\')\\n                dfs(board, row-1, i);\\n        }\\n        \\n        for(int i = 0 ; i < row; i++){\\n            if(board[i][0] == \\'O\\')\\n                dfs(board, i, 0);\\n            if(board[i][col-1] == \\'O\\')\\n                dfs(board, i, col-1);\\n        }\\n        \\n        for(int i = 0; i < row; i++){\\n            for(int j = 0; j < col; j++){\\n                if(board[i][j] == \\'O\\')\\n                    board[i][j] = \\'X\\';\\n                if(board[i][j] == \\'$\\')\\n                    board[i][j] = \\'O\\';\\n            }\\n        }\\n        return;\\n    }\\n    \\n    public static void dfs(char[][] board, int i, int j){\\n        \\n        if(i < 0 || i >= board.length || j < 0 || j >= board[0].length || board[i][j] == \\'X\\' || board[i][j] == \\'$\\')\\n            return;\\n        \\n        board[i][j] = \\'$\\';\\n        dfs(board, i-1, j);\\n        dfs(board, i+1, j);\\n        dfs(board, i, j+1);\\n        dfs(board, i, j-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1280761,
                "title": "a-better-example-easy-solution-same-dfs-template",
                "content": "The given example is not good enough to understand the crux of the question. I bet it is an easy type question ( similar to other dfs questions )\\n\\nA better example : \\n\\n![image](https://assets.leetcode.com/users/images/64e0e51f-855c-47e3-83fb-e34bf2c8b02d_1624008222.5958953.jpeg)\\n\\nLogic: \\n1. We need to remove all the non potential O\\'s ( i.e the boundary components from the grid with value O ). Let\\'s say we do a DFS on the boundary iff grid[i][j] = \\'O\\' and convert them to another non-overlapping character in input ( except \\'X\\' and \\'O\\' ) .\\n2. now, the grid holds the potential O\\'s that need to be converted into \\'X\\'.\\n\\n\\n```\\nclass Solution {\\n    public void solve(char[][] board) {\\n        int rows = board.length;\\n        int cols = board[0].length;\\n        \\n\\t\\t// boundary O\\'s to \\'*\\'\\n        for(int i=0;i<rows;i++) {\\n            for(int j=0;j<cols;j++) {\\n                if(i==0 || i == rows-1 || j == 0 || j == cols-1)\\n                   {\\n                    if(board[i][j] == \\'O\\') {\\n                        dfs(board, i, j, rows, cols);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // convert back\\n        for(int i=0;i<rows;i++) {\\n            for(int j=0;j<cols;j++) {\\n                if(board[i][j] == \\'O\\') board[i][j] = \\'X\\';\\n                else if(board[i][j] == \\'*\\') board[i][j] = \\'O\\';\\n            }\\n        }\\n\\n    }\\n    // same dfs logic\\n    private void dfs(char[][]board, int i, int j, int rows, int cols) {\\n        \\n        boolean isCurrentCellSafe = isSafe(board, i, j, rows, cols);\\n        if(isCurrentCellSafe) {\\n            board[i][j] = \\'*\\';\\n            dfs(board, i+1, j, rows, cols);\\n            dfs(board, i-1, j, rows, cols);\\n            dfs(board, i, j+1, rows, cols);\\n            dfs(board, i, j-1, rows, cols);\\n        }\\n    }\\n    private boolean isSafe(char[][]board, int i, int j, int rows, int cols) {\\n        if(i>=0 && i<rows && j>=0 && j<cols && board[i][j] == \\'O\\') return true;\\n        return false;\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public void solve(char[][] board) {\\n        int rows = board.length;\\n        int cols = board[0].length;\\n        \\n\\t\\t// boundary O\\'s to \\'*\\'\\n        for(int i=0;i<rows;i++) {\\n            for(int j=0;j<cols;j++) {\\n                if(i==0 || i == rows-1 || j == 0 || j == cols-1)\\n                   {\\n                    if(board[i][j] == \\'O\\') {\\n                        dfs(board, i, j, rows, cols);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // convert back\\n        for(int i=0;i<rows;i++) {\\n            for(int j=0;j<cols;j++) {\\n                if(board[i][j] == \\'O\\') board[i][j] = \\'X\\';\\n                else if(board[i][j] == \\'*\\') board[i][j] = \\'O\\';\\n            }\\n        }\\n\\n    }\\n    // same dfs logic\\n    private void dfs(char[][]board, int i, int j, int rows, int cols) {\\n        \\n        boolean isCurrentCellSafe = isSafe(board, i, j, rows, cols);\\n        if(isCurrentCellSafe) {\\n            board[i][j] = \\'*\\';\\n            dfs(board, i+1, j, rows, cols);\\n            dfs(board, i-1, j, rows, cols);\\n            dfs(board, i, j+1, rows, cols);\\n            dfs(board, i, j-1, rows, cols);\\n        }\\n    }\\n    private boolean isSafe(char[][]board, int i, int j, int rows, int cols) {\\n        if(i>=0 && i<rows && j>=0 && j<cols && board[i][j] == \\'O\\') return true;\\n        return false;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 693007,
                "title": "easy-dfs-in-go",
                "content": "We will first capture all boundary connected elements and make rest as \\'X\\'. \\nAlgo is like :-\\n* For all `\\'O\\'` on boundary, traverse recursively(DFS) and mark any connected `\\'O\\'` as **boarder_connected**, i.e. make it `\\'B\\'`\\n* At last, traverse  on all elements of the board and make all `\\'B\\'` as `\\'O\\'` and anything else as `\\'X\\'`\\n\\n```\\nfunc solve(board [][]byte)  {\\n    if len(board) < 2 || len(board[0]) < 2 {\\n        return\\n    }\\n    \\n    // mark cells connected to boarder as boarder_connected(\\'B\\')\\n    for i := 0; i < len(board); i++ {\\n        colorUsingDFS(board, i, 0)               // traverse on first column\\n        colorUsingDFS(board, i, len(board[i])-1) // traverse on last column\\n    }\\n    for j := 0; j < len(board[0]); j++ {\\n        colorUsingDFS(board, 0, j)               // traverse on first row\\n        colorUsingDFS(board, len(board)-1, j)    // traverse on last row\\n    }\\n    \\n    // iterate over all cells and mark all \\'B\\' as \\'O\\' and rest as \\'X\\'\\n    for i := 0; i < len(board); i++ {\\n        for j := 0; j < len(board[i]); j++ {\\n            if board[i][j] == \\'B\\' {\\n                board[i][j] = \\'O\\'\\n            } else {\\n                board[i][j] = \\'X\\'\\n            }\\n        }\\n    }\\n}\\n\\nfunc colorUsingDFS(board [][]byte, i, j int) {\\n    if i < 0 ||  i >= len(board) || j < 0 || j >= len(board[i]) || \\n        board[i][j] != \\'O\\' { // if current boarder connected element is not \\'O\\', skip it\\n        return \\n    }\\n    // make current boarder connected element as \\'B\\'\\n    board[i][j] = \\'B\\'\\n\\n    // check top cell\\n    if i - 1 >= 0 {\\n        colorUsingDFS(board, i-1, j)\\n    }\\n\\t\\n    // check right cell\\n    if j + 1 < len(board[i]) {\\n        colorUsingDFS(board, i, j + 1)\\n    }\\n\\t\\n\\t// check bottom cell\\n    if i + 1 < len(board) {\\n        colorUsingDFS(board, i + 1, j)\\n    }\\n\\t\\n    // check left cell\\n    if j - 1 >= 0 {\\n        colorUsingDFS(board, i, j - 1)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Depth-First Search"
                ],
                "code": "```\\nfunc solve(board [][]byte)  {\\n    if len(board) < 2 || len(board[0]) < 2 {\\n        return\\n    }\\n    \\n    // mark cells connected to boarder as boarder_connected(\\'B\\')\\n    for i := 0; i < len(board); i++ {\\n        colorUsingDFS(board, i, 0)               // traverse on first column\\n        colorUsingDFS(board, i, len(board[i])-1) // traverse on last column\\n    }\\n    for j := 0; j < len(board[0]); j++ {\\n        colorUsingDFS(board, 0, j)               // traverse on first row\\n        colorUsingDFS(board, len(board)-1, j)    // traverse on last row\\n    }\\n    \\n    // iterate over all cells and mark all \\'B\\' as \\'O\\' and rest as \\'X\\'\\n    for i := 0; i < len(board); i++ {\\n        for j := 0; j < len(board[i]); j++ {\\n            if board[i][j] == \\'B\\' {\\n                board[i][j] = \\'O\\'\\n            } else {\\n                board[i][j] = \\'X\\'\\n            }\\n        }\\n    }\\n}\\n\\nfunc colorUsingDFS(board [][]byte, i, j int) {\\n    if i < 0 ||  i >= len(board) || j < 0 || j >= len(board[i]) || \\n        board[i][j] != \\'O\\' { // if current boarder connected element is not \\'O\\', skip it\\n        return \\n    }\\n    // make current boarder connected element as \\'B\\'\\n    board[i][j] = \\'B\\'\\n\\n    // check top cell\\n    if i - 1 >= 0 {\\n        colorUsingDFS(board, i-1, j)\\n    }\\n\\t\\n    // check right cell\\n    if j + 1 < len(board[i]) {\\n        colorUsingDFS(board, i, j + 1)\\n    }\\n\\t\\n\\t// check bottom cell\\n    if i + 1 < len(board) {\\n        colorUsingDFS(board, i + 1, j)\\n    }\\n\\t\\n    // check left cell\\n    if j - 1 >= 0 {\\n        colorUsingDFS(board, i, j - 1)\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 692339,
                "title": "c-solution-with-explanation",
                "content": "Intuition: first sweep borders, change \\'O\\' that connecting to borders to a symbol other than \\'O\\' and \\'X\\', for example \\'Y\\'; then change remaining \\'O\\'s to \\'X\\'; finally recover \\'Y\\'s to \\'O\\'. The last two steps can be done simutaniously.\\n\\n```\\nclass Solution {\\npublic:\\n   public:\\n    void solve(vector<vector<char>>& board) {\\n        if (board.empty() || board[0].empty()) return;\\n        int m = board.size(), n = board[0].size();\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {\\n                    if (board[i][j] == \\'O\\') dfs(board, i , j);\\n                }\\n            }   \\n        }\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (board[i][j] == \\'O\\') board[i][j] = \\'X\\';\\n                if (board[i][j] == \\'Y\\') board[i][j] = \\'O\\';\\n            }\\n        }\\n    }\\n    void dfs(vector<vector<char>> &board, int x, int y) {\\n        int m = board.size(), n = board[0].size();\\n        vector<vector<int>> dir{{0,-1},{-1,0},{0,1},{1,0}};\\n        board[x][y] = \\'Y\\';\\n        for (int i = 0; i < dir.size(); ++i) {\\n            int dx = x + dir[i][0], dy = y + dir[i][1];\\n            if (dx >= 0 && dx < m && dy > 0 && dy < n && board[dx][dy] == \\'O\\') {\\n                dfs(board, dx, dy);\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   public:\\n    void solve(vector<vector<char>>& board) {\\n        if (board.empty() || board[0].empty()) return;\\n        int m = board.size(), n = board[0].size();\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (i == 0 || i == m - 1 || j == 0 || j == n - 1) {\\n                    if (board[i][j] == \\'O\\') dfs(board, i , j);\\n                }\\n            }   \\n        }\\n        for (int i = 0; i < m; ++i) {\\n            for (int j = 0; j < n; ++j) {\\n                if (board[i][j] == \\'O\\') board[i][j] = \\'X\\';\\n                if (board[i][j] == \\'Y\\') board[i][j] = \\'O\\';\\n            }\\n        }\\n    }\\n    void dfs(vector<vector<char>> &board, int x, int y) {\\n        int m = board.size(), n = board[0].size();\\n        vector<vector<int>> dir{{0,-1},{-1,0},{0,1},{1,0}};\\n        board[x][y] = \\'Y\\';\\n        for (int i = 0; i < dir.size(); ++i) {\\n            int dx = x + dir[i][0], dy = y + dir[i][1];\\n            if (dx >= 0 && dx < m && dy > 0 && dy < n && board[dx][dy] == \\'O\\') {\\n                dfs(board, dx, dy);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 691707,
                "title": "c-easy-dfs-with-comments-and-explanation",
                "content": "In this question we have to flip all O\\'s which are surrounded by X.\\nIn other words all the O\\'s which can be traversed through the border O\\'s should not be flipped.\\nSo we can first perform DFS on all the O\\'s connected to boreder O\\'s and mark them as visited then we can perform bfs on remaing and flip them.\\n\\nI have used a flag flip - if flip is 0 change O to X and if not don\\'t.\\nSo while traversing borders flip will be set  to 0 and for rest  it will be 1\\n\\nSo to traverse all bordering O\\'s  we will use 4 loops:\\n```\\nflip = 0 - mark all O\\'s as visited\\n1.  row - 0          column - 0 to n-1\\n2.  row - 1 to n-1   column - 0\\n3.  row - n-1        column - 1 to n-2\\n4.  row - 1 to n-2   column - n-1\\n```\\nAfterwards just loop through the remiang parts and all the non visited O\\'s will be flipped.\\n```\\nNote : \\nvector<pair<int,int>>dirs = {{-1,0},{0,1},{1,0},{0,-1}};\\nhere the values will be used to calculate adjacent indices - \\n\\nfor dir: dirs\\n\\n(i + dir.first)    (j + dir.second)\\ni-1                 j\\ni                   j+1\\ni+1                 j\\ni                   j-1\\n```\\nC++ code: \\n```\\nclass Solution {\\npublic:\\n\\t//Check function is used to check whether the given indices i,j are in range.\\n    bool check(int i,int j,int r,int c){\\n        return (i>=0 && i<r && j>=0 && j<c);\\n    }\\n\\t// DFS funtion to traverse the adjacent elements\\n    void dfs(vector<vector<char>>& b,vector<vector<int>>&visited,int i,int j,int r,int c,int flip){\\n        if(visited[i][j]) return; // If already visited return\\n        visited[i][j] = 1;  // Set visited to 1\\n        if(flip) b[i][j] = \\'X\\'; // if we are in flip mode then filp the value to X\\n\\t\\n\\t\\t// The dirs array consists of pair that we can use to calculate the adjacent indices.\\n        vector<pair<int,int>>dirs = {{-1,0},{0,-1},{0,1},{1,0}}; \\n        // For all 4 directions :\\n\\t\\tfor(auto dir: dirs){\\n            int ii = i+dir.first, jj = j+dir.second; // obtain the indices\\n\\t\\t\\t// If the indices are valid and the value is O and it is not visited yet then perform dfs on those indices\\n            if(check(ii,jj,r,c) && b[ii][jj] == \\'O\\' && !visited[ii][jj]){\\n                dfs(b,visited,ii,jj,r,c,flip); \\n            }\\n        }\\n    }\\n    void solve(vector<vector<char>>& b) {\\n        int r = b.size();\\n        if(r <3 )return;\\n        int c = b[0].size();\\n        vector<vector<int>>visited(r,vector<int>(c));\\n        for(int i=0;i<c;i++){\\n            if(b[0][i] == \\'O\\' && !visited[0][i]){\\n                dfs(b,visited,0,i,r,c,0);\\n            }\\n        }\\n        for(int i=1;i<r;i++){\\n            if(b[i][0] == \\'O\\' && !visited[i][0]){\\n                bfs(b,visited,i,0,r,c,0);\\n            }\\n        }\\n        for(int i=1;i<c;i++){\\n            if(b[r-1][i] == \\'O\\' && !visited[r-1][i]){\\n                dfs(b,visited,r-1,i,r,c,0);\\n            }\\n        }\\n        for(int i=1;i<r-1;i++){\\n            if(b[i][c-1] == \\'O\\' && !visited[i][c-1]){\\n                dfs(b,visited,i,c-1,r,c,0);\\n            }\\n        }\\n        \\n        for(int i=1;i<r-1;i++){\\n            for(int j=1;j<c-1;j++){\\n                if(b[i][j] == \\'O\\' && !visited[i][j]){\\n                    dfs(b,visited,i,j,r,c,1);\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\nHope it helps!",
                "solutionTags": [],
                "code": "```\\nflip = 0 - mark all O\\'s as visited\\n1.  row - 0          column - 0 to n-1\\n2.  row - 1 to n-1   column - 0\\n3.  row - n-1        column - 1 to n-2\\n4.  row - 1 to n-2   column - n-1\\n```\n```\\nNote : \\nvector<pair<int,int>>dirs = {{-1,0},{0,1},{1,0},{0,-1}};\\nhere the values will be used to calculate adjacent indices - \\n\\nfor dir: dirs\\n\\n(i + dir.first)    (j + dir.second)\\ni-1                 j\\ni                   j+1\\ni+1                 j\\ni                   j-1\\n```\n```\\nclass Solution {\\npublic:\\n\\t//Check function is used to check whether the given indices i,j are in range.\\n    bool check(int i,int j,int r,int c){\\n        return (i>=0 && i<r && j>=0 && j<c);\\n    }\\n\\t// DFS funtion to traverse the adjacent elements\\n    void dfs(vector<vector<char>>& b,vector<vector<int>>&visited,int i,int j,int r,int c,int flip){\\n        if(visited[i][j]) return; // If already visited return\\n        visited[i][j] = 1;  // Set visited to 1\\n        if(flip) b[i][j] = \\'X\\'; // if we are in flip mode then filp the value to X\\n\\t\\n\\t\\t// The dirs array consists of pair that we can use to calculate the adjacent indices.\\n        vector<pair<int,int>>dirs = {{-1,0},{0,-1},{0,1},{1,0}}; \\n        // For all 4 directions :\\n\\t\\tfor(auto dir: dirs){\\n            int ii = i+dir.first, jj = j+dir.second; // obtain the indices\\n\\t\\t\\t// If the indices are valid and the value is O and it is not visited yet then perform dfs on those indices\\n            if(check(ii,jj,r,c) && b[ii][jj] == \\'O\\' && !visited[ii][jj]){\\n                dfs(b,visited,ii,jj,r,c,flip); \\n            }\\n        }\\n    }\\n    void solve(vector<vector<char>>& b) {\\n        int r = b.size();\\n        if(r <3 )return;\\n        int c = b[0].size();\\n        vector<vector<int>>visited(r,vector<int>(c));\\n        for(int i=0;i<c;i++){\\n            if(b[0][i] == \\'O\\' && !visited[0][i]){\\n                dfs(b,visited,0,i,r,c,0);\\n            }\\n        }\\n        for(int i=1;i<r;i++){\\n            if(b[i][0] == \\'O\\' && !visited[i][0]){\\n                bfs(b,visited,i,0,r,c,0);\\n            }\\n        }\\n        for(int i=1;i<c;i++){\\n            if(b[r-1][i] == \\'O\\' && !visited[r-1][i]){\\n                dfs(b,visited,r-1,i,r,c,0);\\n            }\\n        }\\n        for(int i=1;i<r-1;i++){\\n            if(b[i][c-1] == \\'O\\' && !visited[i][c-1]){\\n                dfs(b,visited,i,c-1,r,c,0);\\n            }\\n        }\\n        \\n        for(int i=1;i<r-1;i++){\\n            for(int j=1;j<c-1;j++){\\n                if(b[i][j] == \\'O\\' && !visited[i][j]){\\n                    dfs(b,visited,i,j,r,c,1);\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 524222,
                "title": "go-dfs",
                "content": "```\\nfunc solve(board [][]byte)  {\\n    if board == nil || len(board) == 0 {\\n        return\\n    }\\n    m := len(board)\\n    n := len(board[0])\\n    for i := 0; i < m; i++ {\\n        for j := 0; j < n; j++ {\\n            if i == 0 || j == 0 || i == m - 1 || j == n - 1 {\\n                if board[i][j] == \\'O\\' {\\n                    dfs(board, i, j)\\n                }\\n            }\\n        }\\n    }\\n    \\n    for i := 0; i < m; i++ {\\n        for j := 0; j < n; j++ {\\n            if board[i][j] == \\'#\\' {\\n                board[i][j] = \\'O\\'\\n            } else if board[i][j] == \\'O\\' {\\n                board[i][j] = \\'X\\'\\n            }\\n        }\\n    }\\n    return\\n}\\n\\nfunc dfs(board [][]byte, i int, j int) {\\n    if i < 0 || j < 0 || i >= len(board) || j >= len(board[0]) {\\n        return\\n    }\\n    if board[i][j] == \\'O\\' {\\n        board[i][j] = \\'#\\'\\n        dfs(board, i + 1, j)\\n        dfs(board, i - 1, j)\\n        dfs(board, i, j + 1)\\n        dfs(board, i, j - 1)\\n    }\\n    return\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc solve(board [][]byte)  {\\n    if board == nil || len(board) == 0 {\\n        return\\n    }\\n    m := len(board)\\n    n := len(board[0])\\n    for i := 0; i < m; i++ {\\n        for j := 0; j < n; j++ {\\n            if i == 0 || j == 0 || i == m - 1 || j == n - 1 {\\n                if board[i][j] == \\'O\\' {\\n                    dfs(board, i, j)\\n                }\\n            }\\n        }\\n    }\\n    \\n    for i := 0; i < m; i++ {\\n        for j := 0; j < n; j++ {\\n            if board[i][j] == \\'#\\' {\\n                board[i][j] = \\'O\\'\\n            } else if board[i][j] == \\'O\\' {\\n                board[i][j] = \\'X\\'\\n            }\\n        }\\n    }\\n    return\\n}\\n\\nfunc dfs(board [][]byte, i int, j int) {\\n    if i < 0 || j < 0 || i >= len(board) || j >= len(board[0]) {\\n        return\\n    }\\n    if board[i][j] == \\'O\\' {\\n        board[i][j] = \\'#\\'\\n        dfs(board, i + 1, j)\\n        dfs(board, i - 1, j)\\n        dfs(board, i, j + 1)\\n        dfs(board, i, j - 1)\\n    }\\n    return\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 518265,
                "title": "c-simple-dfs-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    void do_not_turn(vector<vector<char>>& board, int i, int j){\\n        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size()) return;   //out of the board\\n        if(board[i][j] == \\'_\\' || board[i][j] == \\'X\\') return;          //dont check fo visited and X nodes\\n        \\n        //only O nodes remaining\\n        \\n        board[i][j] = \\'_\\';  //node is visited\\n        \\t\\t\\n\\t\\t//go for their neighbours now\\n        do_not_turn(board, i+1, j);\\n        do_not_turn(board, i-1, j);\\n        do_not_turn(board, i, j+1);\\n        do_not_turn(board, i, j-1);\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int height = board.size();\\n        if(height == 0) return;\\n        int width = board[0].size();\\n        \\n        //check for all the boundry \\'O\\'s\\n        for(int i = 0; i < height; i++){                                 \\n            if(board[i][0] == \\'O\\')                //left vertical boundry\\n               do_not_turn(board, i, 0); \\n            if(board[i][width-1] == \\'O\\')              //right vertical boundry\\n               do_not_turn(board, i, width-1); \\n        }\\n        for(int i = 1; i < width; i++){              \\n            if(board[0][i] == \\'O\\')              //top horizontal boundry\\n               do_not_turn(board, 0, i); \\n            if(board[height-1][i] == \\'O\\')              //bottom horizontal boundry\\n               do_not_turn(board, height-1, i); \\n        }\\n        \\n\\t\\t\\n\\t\\t //all the \\'O\\'s connected to the boundry are \\'_\\' now\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n        //print the board just for confirmation\\n\\t\\t\\n        // for(int i = 0; i < height; i++){\\n        //     for(int j = 0; j < width; j++){\\n        //         cout<<board[i][j]<<\" \";\\n        //         }\\n        //     cout<<endl;\\n        // }\\n        \\n       \\n        \\n        for(int i = 0; i < height; i++){\\n            for(int j = 0; j < width; j++){\\n                if(board[i][j] == \\'O\\') board[i][j] = \\'X\\';           //all the 0s which are not connected to the boundry are \\'0\\' and should become \\'X\\'\\n                else if(board[i][j] == \\'_\\') board[i][j] = \\'O\\';         //all the boundry conected 0s are \\'_\\' now, and shoulb be turned back to \\'0\\'\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void do_not_turn(vector<vector<char>>& board, int i, int j){\\n        if(i < 0 || i >= board.size() || j < 0 || j >= board[0].size()) return;   //out of the board\\n        if(board[i][j] == \\'_\\' || board[i][j] == \\'X\\') return;          //dont check fo visited and X nodes\\n        \\n        //only O nodes remaining\\n        \\n        board[i][j] = \\'_\\';  //node is visited\\n        \\t\\t\\n\\t\\t//go for their neighbours now\\n        do_not_turn(board, i+1, j);\\n        do_not_turn(board, i-1, j);\\n        do_not_turn(board, i, j+1);\\n        do_not_turn(board, i, j-1);\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int height = board.size();\\n        if(height == 0) return;\\n        int width = board[0].size();\\n        \\n        //check for all the boundry \\'O\\'s\\n        for(int i = 0; i < height; i++){                                 \\n            if(board[i][0] == \\'O\\')                //left vertical boundry\\n               do_not_turn(board, i, 0); \\n            if(board[i][width-1] == \\'O\\')              //right vertical boundry\\n               do_not_turn(board, i, width-1); \\n        }\\n        for(int i = 1; i < width; i++){              \\n            if(board[0][i] == \\'O\\')              //top horizontal boundry\\n               do_not_turn(board, 0, i); \\n            if(board[height-1][i] == \\'O\\')              //bottom horizontal boundry\\n               do_not_turn(board, height-1, i); \\n        }\\n        \\n\\t\\t\\n\\t\\t //all the \\'O\\'s connected to the boundry are \\'_\\' now\\n\\t\\t\\n\\t\\t\\n\\t\\t\\n        //print the board just for confirmation\\n\\t\\t\\n        // for(int i = 0; i < height; i++){\\n        //     for(int j = 0; j < width; j++){\\n        //         cout<<board[i][j]<<\" \";\\n        //         }\\n        //     cout<<endl;\\n        // }\\n        \\n       \\n        \\n        for(int i = 0; i < height; i++){\\n            for(int j = 0; j < width; j++){\\n                if(board[i][j] == \\'O\\') board[i][j] = \\'X\\';           //all the 0s which are not connected to the boundry are \\'0\\' and should become \\'X\\'\\n                else if(board[i][j] == \\'_\\') board[i][j] = \\'O\\';         //all the boundry conected 0s are \\'_\\' now, and shoulb be turned back to \\'0\\'\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 324289,
                "title": "c-98-beat-oldschool-c-solution-o-n-with-o-n-memory",
                "content": "This is puzzle game logic, very easy.\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int aHeight = board.size();\\n        if (aHeight <= 2) { return; }\\n        \\n        int aWidth = board[0].size();\\n        if (aWidth <= 2) { return; }\\n        \\n        bool aVisited[aHeight][aWidth];\\n        memset(aVisited, false, sizeof(aVisited));\\n        \\n        int aStackX[aWidth * aHeight + 1];\\n        int aStackY[aWidth * aHeight + 1];\\n        \\n        int aHitX[aWidth * aHeight + 1];\\n        int aHitY[aWidth * aHeight + 1];\\n        \\n        int aStackCount = 0;\\n        int aHitCount = 0;\\n        \\n        bool aHitEdge = false;\\n        \\n        int aPopX = 0, aPopY = 0, aCheckX = 0, aCheckY = 0;\\n        \\n        for (int i=0;i<aWidth;i++) {\\n            for (int n=0;n<aHeight;n++) {\\n                if (aVisited[n][i] == false && board[n][i] == \\'O\\') {\\n                    \\n                    aHitCount = 0;\\n                    \\n                    aStackCount = 1;\\n                    aHitEdge = false;\\n                    \\n                    aStackX[0] = i;\\n                    aStackY[0] = n;\\n                    \\n                    aVisited[n][i] = true;\\n                    \\n                    while (aStackCount > 0) {\\n                        \\n                        aStackCount -= 1;\\n                        aPopX = aStackX[aStackCount];\\n                        aPopY = aStackY[aStackCount];\\n                        \\n                        aHitX[aHitCount] = aPopX;\\n                        aHitY[aHitCount] = aPopY;\\n                        aHitCount += 1;\\n                        \\n                        if (aPopX == 0 || aPopX == (aWidth - 1)) { aHitEdge = true; }\\n                        if (aPopY == 0 || aPopY == (aHeight - 1)) { aHitEdge = true; }\\n                        \\n                        if (aPopX > 0 && aVisited[aPopY][aPopX-1] == false && board[aPopY][aPopX-1] == \\'O\\') {\\n                            aVisited[aPopY][aPopX-1] = true;\\n                            aStackX[aStackCount] = aPopX - 1;\\n                            aStackY[aStackCount] = aPopY;\\n                            aStackCount += 1;\\n                        }\\n                        \\n                        if (aPopX < (aWidth - 1) && aVisited[aPopY][aPopX+1] == false && board[aPopY][aPopX+1] == \\'O\\') {\\n                            aVisited[aPopY][aPopX+1] = true;\\n                            aStackX[aStackCount] = aPopX + 1;\\n                            aStackY[aStackCount] = aPopY;\\n                            aStackCount += 1;\\n                        }\\n                        \\n                        if (aPopY > 0 && aVisited[aPopY-1][aPopX] == false && board[aPopY-1][aPopX] == \\'O\\') {\\n                            aVisited[aPopY-1][aPopX] = true;\\n                            aStackX[aStackCount] = aPopX;\\n                            aStackY[aStackCount] = aPopY - 1;\\n                            aStackCount += 1;\\n                        }\\n                        \\n                        if (aPopY < (aHeight - 1) && aVisited[aPopY+1][aPopX] == false && board[aPopY+1][aPopX] == \\'O\\') {\\n                            aVisited[aPopY+1][aPopX] = true;\\n                            aStackX[aStackCount] = aPopX;\\n                            aStackY[aStackCount] = aPopY + 1;\\n                            aStackCount += 1;\\n                        }\\n                    }\\n                    \\n                    if (aHitEdge == false) {\\n                        for (int k=0;k<aHitCount;k++) {\\n                            board[aHitY[k]][aHitX[k]] = \\'X\\';\\n                        }\\n                    }\\n                }\\n            }\\n        }        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int aHeight = board.size();\\n        if (aHeight <= 2) { return; }\\n        \\n        int aWidth = board[0].size();\\n        if (aWidth <= 2) { return; }\\n        \\n        bool aVisited[aHeight][aWidth];\\n        memset(aVisited, false, sizeof(aVisited));\\n        \\n        int aStackX[aWidth * aHeight + 1];\\n        int aStackY[aWidth * aHeight + 1];\\n        \\n        int aHitX[aWidth * aHeight + 1];\\n        int aHitY[aWidth * aHeight + 1];\\n        \\n        int aStackCount = 0;\\n        int aHitCount = 0;\\n        \\n        bool aHitEdge = false;\\n        \\n        int aPopX = 0, aPopY = 0, aCheckX = 0, aCheckY = 0;\\n        \\n        for (int i=0;i<aWidth;i++) {\\n            for (int n=0;n<aHeight;n++) {\\n                if (aVisited[n][i] == false && board[n][i] == \\'O\\') {\\n                    \\n                    aHitCount = 0;\\n                    \\n                    aStackCount = 1;\\n                    aHitEdge = false;\\n                    \\n                    aStackX[0] = i;\\n                    aStackY[0] = n;\\n                    \\n                    aVisited[n][i] = true;\\n                    \\n                    while (aStackCount > 0) {\\n                        \\n                        aStackCount -= 1;\\n                        aPopX = aStackX[aStackCount];\\n                        aPopY = aStackY[aStackCount];\\n                        \\n                        aHitX[aHitCount] = aPopX;\\n                        aHitY[aHitCount] = aPopY;\\n                        aHitCount += 1;\\n                        \\n                        if (aPopX == 0 || aPopX == (aWidth - 1)) { aHitEdge = true; }\\n                        if (aPopY == 0 || aPopY == (aHeight - 1)) { aHitEdge = true; }\\n                        \\n                        if (aPopX > 0 && aVisited[aPopY][aPopX-1] == false && board[aPopY][aPopX-1] == \\'O\\') {\\n                            aVisited[aPopY][aPopX-1] = true;\\n                            aStackX[aStackCount] = aPopX - 1;\\n                            aStackY[aStackCount] = aPopY;\\n                            aStackCount += 1;\\n                        }\\n                        \\n                        if (aPopX < (aWidth - 1) && aVisited[aPopY][aPopX+1] == false && board[aPopY][aPopX+1] == \\'O\\') {\\n                            aVisited[aPopY][aPopX+1] = true;\\n                            aStackX[aStackCount] = aPopX + 1;\\n                            aStackY[aStackCount] = aPopY;\\n                            aStackCount += 1;\\n                        }\\n                        \\n                        if (aPopY > 0 && aVisited[aPopY-1][aPopX] == false && board[aPopY-1][aPopX] == \\'O\\') {\\n                            aVisited[aPopY-1][aPopX] = true;\\n                            aStackX[aStackCount] = aPopX;\\n                            aStackY[aStackCount] = aPopY - 1;\\n                            aStackCount += 1;\\n                        }\\n                        \\n                        if (aPopY < (aHeight - 1) && aVisited[aPopY+1][aPopX] == false && board[aPopY+1][aPopX] == \\'O\\') {\\n                            aVisited[aPopY+1][aPopX] = true;\\n                            aStackX[aStackCount] = aPopX;\\n                            aStackY[aStackCount] = aPopY + 1;\\n                            aStackCount += 1;\\n                        }\\n                    }\\n                    \\n                    if (aHitEdge == false) {\\n                        for (int k=0;k<aHitCount;k++) {\\n                            board[aHitY[k]][aHitX[k]] = \\'X\\';\\n                        }\\n                    }\\n                }\\n            }\\n        }        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 244390,
                "title": "python-dfs",
                "content": "```\\nclass Solution(object):\\n    def solve(self, grid):\\n        def dfs(row, col):\\n            if not 0 <= row < len(grid) or not 0 <= col < len(grid[0]) or grid[row][col] != \\'O\\':\\n                return \\n            grid[row][col] = \\'D\\'\\n            dfs(row+1, col)\\n            dfs(row-1, col)\\n            dfs(row, col+1)\\n            dfs(row, col-1)\\n        \\n        for row, group in enumerate(grid):\\n            for col, val in enumerate(group):\\n                if row in {0, len(grid)-1} or col in {0, len(grid[0])-1} and val == \\'O\\':\\n                    dfs(row, col)\\n        \\n        for row, group in enumerate(grid):\\n            for col, val in enumerate(group):\\n                if val == \\'D\\':\\n                    grid[row][col] = \\'O\\'\\n                elif val == \\'O\\':\\n                    grid[row][col] = \\'X\\'",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "class Solution(object):\\n    def solve(self, grid):\\n        def dfs(row, col):\\n            if not 0 <= row < len(grid) or not 0 <= col < len(grid[0]) or grid[row][col] != \\'O\\':\\n                return \\n            grid[row][col] = \\'D\\'\\n            dfs(row+1, col)\\n            dfs(row-1, col)\\n            dfs(row, col+1)\\n            dfs(row, col-1)\\n        \\n        for row, group in enumerate(grid):\\n            for col, val in enumerate(group):\\n                if row in {0, len(grid)-1}",
                "codeTag": "Java"
            },
            {
                "id": 166135,
                "title": "dfs-python-solution",
                "content": "```class Solution:\\n    def solve(self, board):\\n        if len(board) == 0:\\n            return\\n        height = len(board)\\n        width = len(board[0])\\n        def dfs(board, y, x):\\n            if x < 0 or x >= width or y < 0 or y >= height or board[y][x] != \\'O\\':\\n                return \\n            board[y][x] = \\'S\\'\\n            dfs(board, y + 1, x)\\n            dfs(board, y - 1, x)\\n            dfs(board, y, x + 1)\\n            dfs(board, y, x - 1)\\n        for i in range(width):\\n            if board[0][i] == \\'O\\':\\n                dfs(board, 0, i)\\n            if board[height-1][i] == \\'O\\':\\n                dfs(board, height-1, i)\\n        for j in range(height):\\n            if board[j][0] == \\'O\\':\\n                dfs(board, j, 0)\\n            if board[j][width-1] == \\'O\\':\\n                dfs(board, j, width-1)\\n        for y in range(height):\\n            for x in range(width):\\n                if board[y][x] == \\'S\\':\\n                    board[y][x] = \\'O\\'\\n                else:\\n                    board[y][x] = \\'X\\'\\n```",
                "solutionTags": [],
                "code": "```class Solution:\\n    def solve(self, board):\\n        if len(board) == 0:\\n            return\\n        height = len(board)\\n        width = len(board[0])\\n        def dfs(board, y, x):\\n            if x < 0 or x >= width or y < 0 or y >= height or board[y][x] != \\'O\\':\\n                return \\n            board[y][x] = \\'S\\'\\n            dfs(board, y + 1, x)\\n            dfs(board, y - 1, x)\\n            dfs(board, y, x + 1)\\n            dfs(board, y, x - 1)\\n        for i in range(width):\\n            if board[0][i] == \\'O\\':\\n                dfs(board, 0, i)\\n            if board[height-1][i] == \\'O\\':\\n                dfs(board, height-1, i)\\n        for j in range(height):\\n            if board[j][0] == \\'O\\':\\n                dfs(board, j, 0)\\n            if board[j][width-1] == \\'O\\':\\n                dfs(board, j, width-1)\\n        for y in range(height):\\n            for x in range(width):\\n                if board[y][x] == \\'S\\':\\n                    board[y][x] = \\'O\\'\\n                else:\\n                    board[y][x] = \\'X\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 117829,
                "title": "java-concise-union-find",
                "content": "I have tried my best to make my code clean and readable.\n```\npublic class Solution {\n    private int m, n;\n    \n    private class UnionFind{\n        private int[] parent;\n        private int[] rank;\n        \n        public UnionFind(int n){\n            parent = new int[n];\n            rank = new int[n];\n            \n            for(int i = 0;i < n;i++)    parent[i] = i;\n        }\n        public int find(int n){\n            while(n != parent[n]){\n                parent[n] = parent[parent[n]];\n                n = parent[n];\n            }\n            \n            return n;\n        }      \n        public void union(int i, int j){\n            int rooti = find(i);\n            int rootj = find(j);\n            \n            if(rooti == rootj) return;\n            \n            if(rank[rootj] < rank[rooti]){\n                parent[rootj] = rooti;\n            }else{\n                parent[rooti] = rootj;\n                if(rank[rooti] == rank[rootj]) rank[rootj]++;\n            }\n        }\n    }\n    \n    public void solve(char[][] board) {\n        if(board == null || board.length == 0 || board[0].length == 0) return;\n        \n        m = board.length;\n        n = board[0].length;\n        int dummyNode = m * n;\n        UnionFind unionFind = new UnionFind(dummyNode + 1);\n        \n        for(int i = 0; i < m;i++){\n            for(int j = 0;j < n;j++){\n                if(board[i][j] == 'O'){\n                    if(i == 0 || j == 0 || i == m - 1 || j == n - 1){\n                        unionFind.union(i * n + j, dummyNode);\n                    }else{\n                        if(j - 1 >= 0 && board[i][j - 1] == 'O')  unionFind.union(getNode(i, j), getNode(i, j - 1));\n                        if(i - 1 >= 0 && board[i - 1][j] == 'O')  unionFind.union(getNode(i, j), getNode(i - 1, j));\n                        if(i + 1 < m && board[i + 1][j] == 'O')   unionFind.union(getNode(i, j), getNode(i + 1, j));\n                        if(j + 1 < n && board[i][j + 1] == 'O')   unionFind.union(getNode(i, j), getNode(i, j + 1));\n                    }\n                }\n            }\n        }\n        \n        for(int i = 0;i < m;i++){\n            for(int j = 0;j < n;j++){\n                if(board[i][j] == 'O'){\n                    if(unionFind.find(getNode(i, j)) == unionFind.find(dummyNode)) board[i][j] = 'O';\n                    else    board[i][j] = 'X';\n                }\n            }\n        }\n    }\n    public int getNode(int i, int j){\n        return i * n + j;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\npublic class Solution {\n    private int m, n;\n    \n    private class UnionFind{\n        private int[] parent;\n        private int[] rank;\n        \n        public UnionFind(int n){\n            parent = new int[n];\n            rank = new int[n];\n            \n            for(int i = 0;i < n;i++)    parent[i] = i;\n        }\n        public int find(int n){\n            while(n != parent[n]){\n                parent[n] = parent[parent[n]];\n                n = parent[n];\n            }\n            \n            return n;\n        }      \n        public void union(int i, int j){\n            int rooti = find(i);\n            int rootj = find(j);\n            \n            if(rooti == rootj) return;\n            \n            if(rank[rootj] < rank[rooti]){\n                parent[rootj] = rooti;\n            }else{\n                parent[rooti] = rootj;\n                if(rank[rooti] == rank[rootj]) rank[rootj]++;\n            }\n        }\n    }\n    \n    public void solve(char[][] board) {\n        if(board == null || board.length == 0 || board[0].length == 0) return;\n        \n        m = board.length;\n        n = board[0].length;\n        int dummyNode = m * n;\n        UnionFind unionFind = new UnionFind(dummyNode + 1);\n        \n        for(int i = 0; i < m;i++){\n            for(int j = 0;j < n;j++){\n                if(board[i][j] == 'O'){\n                    if(i == 0 || j == 0 || i == m - 1 || j == n - 1){\n                        unionFind.union(i * n + j, dummyNode);\n                    }else{\n                        if(j - 1 >= 0 && board[i][j - 1] == 'O')  unionFind.union(getNode(i, j), getNode(i, j - 1));\n                        if(i - 1 >= 0 && board[i - 1][j] == 'O')  unionFind.union(getNode(i, j), getNode(i - 1, j));\n                        if(i + 1 < m && board[i + 1][j] == 'O')   unionFind.union(getNode(i, j), getNode(i + 1, j));\n                        if(j + 1 < n && board[i][j + 1] == 'O')   unionFind.union(getNode(i, j), getNode(i, j + 1));\n                    }\n                }\n            }\n        }\n        \n        for(int i = 0;i < m;i++){\n            for(int j = 0;j < n;j++){\n                if(board[i][j] == 'O'){\n                    if(unionFind.find(getNode(i, j)) == unionFind.find(dummyNode)) board[i][j] = 'O';\n                    else    board[i][j] = 'X';\n                }\n            }\n        }\n    }\n    public int getNode(int i, int j){\n        return i * n + j;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 41804,
                "title": "union-find-clean-python-code",
                "content": "    class UnionFind(object):\\n        def __init__(self, board):\\n            self.m = len(board)\\n            self.n = len(board[0])\\n            self.length = self.m * self.n\\n    \\n            self.id = [None] * self.length\\n            self.size = [1] * self.length\\n            self.surrounded = [True] * self.length\\n    \\n            [operator.setitem(self.id, *([self.genIndex(i, j)] * 2))\\n             for i, row in enumerate(board)\\n             for j, val in enumerate(row) if val == 'O']\\n    \\n        def genIndex(self, i, j):\\n            return self.n * i + j\\n    \\n        def find(self, p):\\n            while p != self.id[p]:\\n                self.id[p] = self.id[self.id[p]]\\n                p = self.id[p]\\n            return p\\n    \\n        def union(self, p, q):\\n            idp, idq = map(self.find, (p, q))\\n            if idp == idq:\\n                return\\n    \\n            less, more = (\\n                (idp, idq) if self.size[idp] < self.size[idq] else (idq, idp))\\n    \\n            self.id[less] = self.id[more]\\n            self.size[more] += self.size[less]\\n            self.surrounded[more] = self.surrounded[less] and self.surrounded[more]\\n    \\n    \\n    class Solution(object):\\n        def solve(self, board):\\n            if not board:\\n                return\\n    \\n            uf = UnionFind(board)\\n    \\n            for i, row in enumerate(board):\\n                for j, val in enumerate(row):\\n                    if val != 'O':\\n                        continue\\n    \\n                    index = uf.genIndex(i, j)\\n    \\n                    [uf.union(index, uf.genIndex(y, z))\\n                     for x, y, z in ((i, i - 1, j), (j, i, j - 1))\\n                     if x > 0 and board[y][z] == 'O']\\n    \\n                    if i == 0 or j == 0 or i == uf.m - 1 or j == uf.n - 1:\\n                        uf.surrounded[uf.find(index)] = False\\n    \\n            [operator.setitem(board[i], j, 'X')\\n             for i in xrange(uf.m)\\n             for j in xrange(uf.n)\\n             if board[i][j] == 'O' and uf.surrounded[uf.find(uf.genIndex(i, j))]]",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "    class UnionFind(object):\\n        def __init__(self, board):\\n            self.m = len(board)\\n            self.n = len(board[0])\\n            self.length = self.m * self.n\\n    \\n            self.id = [None] * self.length\\n            self.size = [1] * self.length\\n            self.surrounded = [True] * self.length\\n    \\n            [operator.setitem(self.id, *([self.genIndex(i, j)] * 2))\\n             for i, row in enumerate(board)\\n             for j, val in enumerate(row) if val == 'O']\\n    \\n        def genIndex(self, i, j):\\n            return self.n * i + j\\n    \\n        def find(self, p):\\n            while p != self.id[p]:\\n                self.id[p] = self.id[self.id[p]]\\n                p = self.id[p]\\n            return p\\n    \\n        def union(self, p, q):\\n            idp, idq = map(self.find, (p, q))\\n            if idp == idq:\\n                return\\n    \\n            less, more = (\\n                (idp, idq) if self.size[idp] < self.size[idq] else (idq, idp))\\n    \\n            self.id[less] = self.id[more]\\n            self.size[more] += self.size[less]\\n            self.surrounded[more] = self.surrounded[less] and self.surrounded[more]\\n    \\n    \\n    class Solution(object):\\n        def solve(self, board):\\n            if not board:\\n                return\\n    \\n            uf = UnionFind(board)\\n    \\n            for i, row in enumerate(board):\\n                for j, val in enumerate(row):\\n                    if val != 'O':\\n                        continue\\n    \\n                    index = uf.genIndex(i, j)\\n    \\n                    [uf.union(index, uf.genIndex(y, z))\\n                     for x, y, z in ((i, i - 1, j), (j, i, j - 1))\\n                     if x > 0 and board[y][z] == 'O']\\n    \\n                    if i == 0 or j == 0 or i == uf.m - 1 or j == uf.n - 1:\\n                        uf.surrounded[uf.find(index)] = False\\n    \\n            [operator.setitem(board[i], j, 'X')\\n             for i in xrange(uf.m)\\n             for j in xrange(uf.n)\\n             if board[i][j] == 'O' and uf.surrounded[uf.find(uf.genIndex(i, j))]]",
                "codeTag": "Java"
            },
            {
                "id": 41812,
                "title": "ac-python-140-ms-solution-bfs-starting-from-boundary-o",
                "content": "    displacements = [[1, 0], [-1, 1], [-1, -1], [1, -1]]\\n    # (i,j) -> (i+1,j) -> (i,j+1) -> (i-1,j) -> (i,j-1)\\n\\n    def bfs(self, board, i, j, m, n):\\n        # O: White, X:Black, G:Gray\\n        dq = collections.deque([[i, j]])\\n        board[i][j] = 'G'\\n        while dq:\\n            i, j = dq.popleft()\\n            for di, dj in Solution.displacements:\\n                i += di\\n                j += dj\\n                if 0 <= i < m and 0 <= j < n and board[i][j] == 'O':\\n                    dq.append([i, j])\\n                    board[i][j] = 'G'\\n\\n    def solve(self, board):\\n        if len(board) < 3 or len(board[0]) < 3:\\n            return\\n        m, n = len(board), len(board[0])\\n        for i in xrange(m):\\n            for j in 0, n - 1:\\n                if board[i][j] == 'O':\\n                    self.bfs(board, i, j, m, n)\\n\\n        for i in 0, m - 1:\\n            for j in xrange(1, n - 1):\\n                if board[i][j] == 'O':\\n                    self.bfs(board, i, j, m, n)\\n\\n        for row in board:\\n            for j in xrange(n):\\n                if row[j] != 'X':\\n                    row[j] = 'X' if row[j] == 'O' else 'O'\\n\\n    # 58 / 58 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 140 ms\\n    # 94.63%\\n\\nThe idea is to color all non surrounded region and then flip those uncolored ones. Any non surrounded region must connect to a 'O' at the boundary. Therefore we can perform BFS from boundary 'O's. This way we minimized our search task.",
                "solutionTags": [
                    "Python"
                ],
                "code": "    displacements = [[1, 0], [-1, 1], [-1, -1], [1, -1]]\\n    # (i,j) -> (i+1,j) -> (i,j+1) -> (i-1,j) -> (i,j-1)\\n\\n    def bfs(self, board, i, j, m, n):\\n        # O: White, X:Black, G:Gray\\n        dq = collections.deque([[i, j]])\\n        board[i][j] = 'G'\\n        while dq:\\n            i, j = dq.popleft()\\n            for di, dj in Solution.displacements:\\n                i += di\\n                j += dj\\n                if 0 <= i < m and 0 <= j < n and board[i][j] == 'O':\\n                    dq.append([i, j])\\n                    board[i][j] = 'G'\\n\\n    def solve(self, board):\\n        if len(board) < 3 or len(board[0]) < 3:\\n            return\\n        m, n = len(board), len(board[0])\\n        for i in xrange(m):\\n            for j in 0, n - 1:\\n                if board[i][j] == 'O':\\n                    self.bfs(board, i, j, m, n)\\n\\n        for i in 0, m - 1:\\n            for j in xrange(1, n - 1):\\n                if board[i][j] == 'O':\\n                    self.bfs(board, i, j, m, n)\\n\\n        for row in board:\\n            for j in xrange(n):\\n                if row[j] != 'X':\\n                    row[j] = 'X' if row[j] == 'O' else 'O'\\n\\n    # 58 / 58 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 140 ms\\n    # 94.63%\\n\\nThe idea is to color all non surrounded region and then flip those uncolored ones. Any non surrounded region must connect to a 'O' at the boundary. Therefore we can perform BFS from boundary 'O's. This way we minimized our search task.",
                "codeTag": "Python3"
            },
            {
                "id": 41628,
                "title": "my-java-union-find-solution",
                "content": "    public class Solution {\\n    class union{\\n        int[] weight;\\n        int[] next;\\n        int size;\\n        public union(int capacity){\\n            weight=new int[capacity];\\n            next=new int[capacity];\\n            for(int i=0;i<capacity;i++){\\n                next[i]=i;\\n                weight[i]=1;\\n                this.size=capacity;\\n            }\\n        }\\n        public int find(int p){\\n            int start=p;\\n            int tmp;\\n            while(next[p]!=p){\\n                p=next[p];\\n            }\\n            while(next[start]!=p){\\n                tmp=next[start];\\n                next[start]=p;\\n                start=tmp;\\n            }\\n            return p;\\n            \\n            \\n        }\\n        public void connect(int p,int q){\\n            int pid=find(p);\\n            int qid=find(q);\\n            if(pid==qid) return;\\n            if(weight[pid]>=weight[qid]){\\n                next[qid]=pid;\\n                weight[pid]+=weight[qid];\\n                \\n            }else{\\n                next[pid]=qid;\\n                weight[qid]+=weight[pid];\\n            }\\n            size--;\\n            \\n            \\n        }\\n        \\n        \\n    }\\n    public void solve(char[][] board) {\\n        if(board.length==0) return;\\n        union myunion=new union(board.length*board[0].length+1);\\n        myunion.weight[board.length*board[0].length]=10000;\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[0].length;j++){\\n                     \\n                    if(board[i][j]=='O'){\\n        if(i==0 || j==0 || i==board.length-1 || j==board[0].length-1) myunion.connect(i*board[0].length+j,board.length*board[0].length);\\n                       if(i+1<board.length && board[i+1][j]=='O'){\\n                           myunion.connect(i*board[0].length+j,(i+1)*board[0].length+j);\\n                       }\\n                       if(j+1<board[0].length && board[i][j+1]=='O'){\\n                           myunion.connect(i*board[0].length+j,i*board[0].length+j+1);\\n                       }\\n                        \\n                    }\\n                    \\n                    \\n                \\n                \\n            }\\n        }\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[0].length;j++){\\n                if(myunion.find(i*board[0].length+j)!=board.length*board[0].length) board[i][j]='X';\\n                \\n            }\\n        }\\n        \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    class union{\\n        int[] weight;\\n        int[] next;\\n        int size;\\n        public union(int capacity){\\n            weight=new int[capacity];\\n            next=new int[capacity];\\n            for(int i=0;i<capacity;i++){\\n                next[i]=i;\\n                weight[i]=1;\\n                this.size=capacity;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 41868,
                "title": "concise-bfs-c-solution",
                "content": "The idea is starting from any 'O' on the frame of the board apply BFS and replace any encountered 'O' with '#'\\n\\n    class Solution {\\n    public:\\n        void bfs(int i, int j, vector<vector<char>>& board) {\\n            int n = board.size();\\n            int m = board[0].size();\\n            queue<pair<int, int>> q;\\n            q.push(make_pair(i, j));\\n            while (!q.empty()) {\\n                auto top = q.front();\\n                q.pop();\\n                if (top.first >= 0 && top.first < n && top.second >= 0 && top.second < m && board[top.first][top.second] == 'O') {\\n                    board[top.first][top.second] = '#';\\n                    q.push(make_pair(top.first - 1, top.second));\\n                    q.push(make_pair(top.first + 1, top.second));\\n                    q.push(make_pair(top.first, top.second + 1));\\n                    q.push(make_pair(top.first, top.second - 1));\\n                }\\n            }\\n        }\\n    \\n        void solve(vector<vector<char>>& board) {\\n            if (board.empty() || board[0].empty()) return;\\n            int n = board.size();\\n            int m = board[0].size();\\n    \\n            for (int i = 0; i < n; ++i) {\\n                if (board[i][0] == 'O') bfs(i, 0, board);\\n                if (board[i][m - 1] == 'O') bfs(i, m - 1, board);\\n            }\\n    \\n            for (int i = 0; i < m; ++i) {\\n                if (board[0][i] == 'O') bfs(0, i, board);\\n                if (board[n - 1][i] == 'O') bfs(n - 1, i, board);\\n            }\\n    \\n            for (int i = 0; i < n; ++i)\\n                for (int j = 0; j < m; ++j)\\n                    if (board[i][j] == '#') board[i][j] = 'O';\\n                    else board[i][j] = 'X';\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void bfs(int i, int j, vector<vector<char>>& board) {\\n            int n = board.size();\\n            int m = board[0].size();\\n            queue<pair<int, int>> q;\\n            q.push(make_pair(i, j));\\n            while (!q.empty()) {\\n                auto top = q.front();\\n                q.pop();\\n                if (top.first >= 0 && top.first < n && top.second >= 0 && top.second < m && board[top.first][top.second] == 'O') {\\n                    board[top.first][top.second] = '#';\\n                    q.push(make_pair(top.first - 1, top.second));\\n                    q.push(make_pair(top.first + 1, top.second));\\n                    q.push(make_pair(top.first, top.second + 1));\\n                    q.push(make_pair(top.first, top.second - 1));\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 41918,
                "title": "my-accepted-bfs-solution-java",
                "content": "The following is my Java BFS solution.\\n\\n    class Point\\n    {\\n        int row;\\n        int col;\\n        \\n        public Point(int row, int col)\\n        {\\n            this.row = row;\\n            this.col = col;\\n        }\\n    }\\n    \\n\\tpublic void solve(char[][] board)\\n\\t{\\n\\t\\tif (board.length < 3 || board[0].length < 3)\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t    \\n\\t    boolean[][] visited = new boolean[board.length][board[0].length];\\n\\t    \\t\\n        // check first row\\n        for (int col = 0; col < board[0].length; col++)\\n        {\\n            if (board[0][col] == 'O')\\n            {\\n                exploreBoard(board, visited, 0, col);\\n            }\\n        }\\n        \\n        // check last row\\n        for (int col = 0; col < board[0].length; col++)\\n        {\\n            if (board[board.length-1][col] == 'O')\\n            {\\n                exploreBoard(board, visited, board.length-1, col);\\n            }\\n        }\\n        \\n        // check first col\\n        for (int row = 0; row < board.length; row++)\\n        {\\n            if (board[row][0] == 'O')\\n            {\\n                exploreBoard(board, visited, row, 0);\\n            }\\n        }\\n        \\n        // check last col\\n        for (int row = 0; row < board.length; row++)\\n        {\\n            if (board[row][board[0].length-1] == 'O')\\n            {\\n                exploreBoard(board, visited, row, board[0].length-1);\\n            }\\n        }\\n        \\n        for (int row = 0; row < board.length; row++)\\n        {\\n            for (int col = 0; col < board[0].length; col++)\\n            {\\n                if (visited[row][col] == false && board[row][col] == 'O')\\n                {\\n                    board[row][col] = 'X';\\n                }\\n            }\\n        }\\n\\t}\\n\\n    public void exploreBoard(char[][] board, boolean[][] visited, int row, int col)\\n\\t{\\n\\t\\tLinkedList<Point> queue = new LinkedList<Point>();\\n\\t\\tqueue.addLast(new Point(row, col));\\n\\n\\t\\twhile (!queue.isEmpty())\\n\\t\\t{\\n\\t\\t\\tPoint p = queue.removeFirst();\\n\\t\\t\\t// four directions\\n\\n\\t\\t\\tif (visited[p.row][p.col] == false)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvisited[p.row][p.col] = true;\\n\\n\\t\\t\\t\\t//up\\n\\t\\t\\t\\tif (p.row != 0 && board[p.row-1][p.col] == 'O' && !visited[p.row-1][p.col])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tqueue.addLast(new Point(p.row-1, p.col));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//left\\n\\t\\t\\t\\tif (p.col != 0 && board[p.row][p.col-1] == 'O' && !visited[p.row][p.col-1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tqueue.addLast(new Point(p.row, p.col-1));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// down\\n\\t\\t\\t\\tif (p.row != board.length-1 && board[p.row+1][p.col] == 'O' && !visited[p.row+1][p.col])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tqueue.addLast(new Point(p.row+1, p.col));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// right\\n\\t\\t\\t\\tif (p.col != board[0].length-1 && board[p.row][p.col+1] == 'O' && !visited[p.row][p.col+1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tqueue.addLast(new Point(p.row, p.col+1));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "The following is my Java BFS solution.\\n\\n    class Point\\n    {\\n        int row;\\n        int col;\\n        \\n        public Point(int row, int col)\\n        {\\n            this.row = row;\\n            this.col = col;\\n        }\\n    }\\n    \\n\\tpublic void solve(char[][] board)\\n\\t{\\n\\t\\tif (board.length < 3 || board[0].length < 3)\\n\\t\\t{\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t    \\n\\t    boolean[][] visited = new boolean[board.length][board[0].length];\\n\\t    \\t\\n        // check first row\\n        for (int col = 0; col < board[0].length; col++)\\n        {\\n            if (board[0][col] == 'O')\\n            {\\n                exploreBoard(board, visited, 0, col);\\n            }\\n        }\\n        \\n        // check last row\\n        for (int col = 0; col < board[0].length; col++)\\n        {\\n            if (board[board.length-1][col] == 'O')\\n            {\\n                exploreBoard(board, visited, board.length-1, col);\\n            }\\n        }\\n        \\n        // check first col\\n        for (int row = 0; row < board.length; row++)\\n        {\\n            if (board[row][0] == 'O')\\n            {\\n                exploreBoard(board, visited, row, 0);\\n            }\\n        }\\n        \\n        // check last col\\n        for (int row = 0; row < board.length; row++)\\n        {\\n            if (board[row][board[0].length-1] == 'O')\\n            {\\n                exploreBoard(board, visited, row, board[0].length-1);\\n            }\\n        }\\n        \\n        for (int row = 0; row < board.length; row++)\\n        {\\n            for (int col = 0; col < board[0].length; col++)\\n            {\\n                if (visited[row][col] == false && board[row][col] == 'O')\\n                {\\n                    board[row][col] = 'X';\\n                }\\n            }\\n        }\\n\\t}\\n\\n    public void exploreBoard(char[][] board, boolean[][] visited, int row, int col)\\n\\t{\\n\\t\\tLinkedList<Point> queue = new LinkedList<Point>();\\n\\t\\tqueue.addLast(new Point(row, col));\\n\\n\\t\\twhile (!queue.isEmpty())\\n\\t\\t{\\n\\t\\t\\tPoint p = queue.removeFirst();\\n\\t\\t\\t// four directions\\n\\n\\t\\t\\tif (visited[p.row][p.col] == false)\\n\\t\\t\\t{\\n\\t\\t\\t\\tvisited[p.row][p.col] = true;\\n\\n\\t\\t\\t\\t//up\\n\\t\\t\\t\\tif (p.row != 0 && board[p.row-1][p.col] == 'O' && !visited[p.row-1][p.col])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tqueue.addLast(new Point(p.row-1, p.col));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t//left\\n\\t\\t\\t\\tif (p.col != 0 && board[p.row][p.col-1] == 'O' && !visited[p.row][p.col-1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tqueue.addLast(new Point(p.row, p.col-1));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// down\\n\\t\\t\\t\\tif (p.row != board.length-1 && board[p.row+1][p.col] == 'O' && !visited[p.row+1][p.col])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tqueue.addLast(new Point(p.row+1, p.col));\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t// right\\n\\t\\t\\t\\tif (p.col != board[0].length-1 && board[p.row][p.col+1] == 'O' && !visited[p.row][p.col+1])\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tqueue.addLast(new Point(p.row, p.col+1));\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}",
                "codeTag": "Java"
            },
            {
                "id": 41676,
                "title": "use-stack-to-get-rid-of-stackoverflow-in-dfs",
                "content": "Most people first use a recursion to traverse in board, but this will cause StackOverFlow in large size input. Use a stack to simulate the recursion will solve your problem.\\n\\n    \\n    class Pair {\\n        int x;\\n        int y;\\n        Pair (int a, int b) { x = a; y = b; }\\n    }\\n    \\n    public void solve(char[][] board) {\\n        int m = board.length;\\n        if (m == 0) return;\\n        int n = board[0].length;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if ((i == 0 || j == 0 || i == m-1 || j == n-1)\\n                    && board[i][j] == 'O') {\\n                    // for positions in border which are 'O', exhaust all NON surrounded regions and mark them as 'N'\\n                    Stack<Pair> stk = new Stack<Pair>();\\n                    stk.push(new Pair(i, j));\\n                    while (!stk.isEmpty()) {\\n                        Pair curr = stk.pop();\\n                        int x = curr.x;\\n                        int y = curr.y;\\n                        if (x < 0 || x >= m || y < 0 || y >= n || !(board[x][y] == 'O'))\\n                            continue;\\n                        board[x][y] = 'N';\\n                        stk.push(new Pair(x-1, y));\\n                        stk.push(new Pair(x, y-1));\\n                        stk.push(new Pair(x, y+1));\\n                        stk.push(new Pair(x+1, y));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // mark all NON surrounded regions back to 'O' and render all surrounded regions\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == 'O') board[i][j] = 'X';\\n                else if (board[i][j] == 'N') board[i][j] = 'O';\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "Most people first use a recursion to traverse in board, but this will cause StackOverFlow in large size input. Use a stack to simulate the recursion will solve your problem.\\n\\n    \\n    class Pair {\\n        int x;\\n        int y;\\n        Pair (int a, int b) { x = a; y = b; }\\n    }\\n    \\n    public void solve(char[][] board) {\\n        int m = board.length;\\n        if (m == 0) return;\\n        int n = board[0].length;\\n        \\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if ((i == 0 || j == 0 || i == m-1 || j == n-1)\\n                    && board[i][j] == 'O') {\\n                    // for positions in border which are 'O', exhaust all NON surrounded regions and mark them as 'N'\\n                    Stack<Pair> stk = new Stack<Pair>();\\n                    stk.push(new Pair(i, j));\\n                    while (!stk.isEmpty()) {\\n                        Pair curr = stk.pop();\\n                        int x = curr.x;\\n                        int y = curr.y;\\n                        if (x < 0 || x >= m || y < 0 || y >= n || !(board[x][y] == 'O'))\\n                            continue;\\n                        board[x][y] = 'N';\\n                        stk.push(new Pair(x-1, y));\\n                        stk.push(new Pair(x, y-1));\\n                        stk.push(new Pair(x, y+1));\\n                        stk.push(new Pair(x+1, y));\\n                    }\\n                }\\n            }\\n        }\\n        \\n        // mark all NON surrounded regions back to 'O' and render all surrounded regions\\n        for (int i = 0; i < m; i++) {\\n            for (int j = 0; j < n; j++) {\\n                if (board[i][j] == 'O') board[i][j] = 'X';\\n                else if (board[i][j] == 'N') board[i][j] = 'O';\\n            }\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 41939,
                "title": "dp-bfs-solution-o-n",
                "content": "    public class Solution {\\n        int length =0;\\n        int height = 0;\\n        \\n        public void solve(char[][] board) {\\n            if(board == null || board.length ==0){\\n                return;\\n            }\\n            \\n            length = board[0].length;\\n            height = board.length;\\n            char[][] copy = new char[height][length];\\n            \\n            for(int i=0; i< height;i++){\\n               copyCharToCopy(board, copy, i, 0);\\n               copyCharToCopy(board, copy, i, length-1);\\n            }\\n            \\n            for(int j=0; j<length; j++){\\n                copyCharToCopy(board, copy, 0, j); \\n                copyCharToCopy(board, copy, height-1, j);\\n            }\\n            \\n            for(int i=0; i<height;i++){\\n                for(int j=0;j<length;j++){\\n                    if(board[i][j] =='O' && copy[i][j] != 'O'){\\n                        board[i][j] = 'X';\\n                    }\\n                }\\n            }\\n            \\n            return;\\n        }\\n        \\n        private void copyCharToCopy(char[][] board, char[][] copy, int h, int w){\\n        \\t\\n        \\tStack<Integer> iS = new Stack<Integer>();\\n        \\tStack<Integer> jS =new Stack<Integer>();\\n        \\tiS.push(h);\\n        \\tjS.push(w);\\n        \\t\\n        \\twhile(!iS.isEmpty()){\\n        \\t\\tint i = iS.pop();\\n        \\t\\tint j = jS.pop();\\n        \\t\\tif(!(i<0 || i>= height || j<0 || j>= length || copy[i][j] == 'O' || board[i][j] =='X')){\\n    \\t    \\t\\tcopy[i][j] = board[i][j];\\n    \\t    \\t\\tiS.push(i-1);\\n    \\t    \\t\\tjS.push(j);\\n    \\t    \\t\\t\\n    \\t    \\t\\tiS.push(i+1);\\n    \\t    \\t\\tjS.push(j);\\n    \\t    \\t\\t\\n    \\t    \\t\\tiS.push(i);\\n    \\t    \\t\\tjS.push(j-1);\\n    \\t    \\t\\t\\n    \\t    \\t\\tiS.push(i);\\n    \\t    \\t\\tjS.push(j+1);\\n        \\t\\t}\\n        \\t}\\n        }\\n    }\\n\\nuse copy to store if the point is connected to edge, every point should be visited just once since we do not visit the point if it is visited",
                "solutionTags": [],
                "code": "class Solution {\\n        int length =0;\\n        int height = 0;\\n        \\n        public void solve(char[][] board) {\\n            if(board == null || board.length ==0){\\n                return;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 3730372,
                "title": "unique-and-simple-approach-c-border-check-inplace",
                "content": "* We will first check all the borders for \\'O\\' and set all the connected \\'O\\'s to a temp character \\'N\\' so that we will get all the regions which do not satisfy the condition.\\n* So automatixcally all the remaining \\'O\\' will be surrounded by \\'X\\' and not at the borders. So we will flip them to \\'X\\' inplace.\\n* after that we will flip all the \\'N\\'s back to \\'O\\'s .\\n\\n```\\nvoid solve(vector<vector<char>>& board) {\\n    const int r = board.size();\\n    const int c = board[0].size();\\n    queue<pair<int,int>> q;\\n    vector<vector<int>> dir = {{1,0},{-1,0},{0,1},{0,-1}};\\n\\t\\n\\t//top border\\n    for(int i=0;i<c;++i){\\n        if(board[0][i] == \\'X\\' || board[0][i] == \\'N\\'){continue;}\\n        else{\\n            q.push(make_pair(0,i));\\n            while(q.size()){\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                if(x<0 || x>=r || y<0 || y>=c || board[x][y] == \\'X\\' || board[x][y] == \\'N\\'){continue;}\\n                board[x][y] = \\'N\\';\\n                for(int d=0;d<dir.size();++d){\\n                    q.push(make_pair(x+dir[d][0], y+dir[d][1]));\\n                }\\n            }\\n        }\\n    }\\n    \\n    //right border\\n        for(int i=0;i<r;++i){\\n        if(board[i][c-1] == \\'X\\' || board[i][c-1] == \\'N\\'){continue;}\\n        else{\\n            q.push(make_pair(i,c-1));\\n            while(q.size()){\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                if(x<0 || x>=r || y<0 || y>=c || board[x][y] == \\'X\\' || board[x][y] == \\'N\\'){continue;}\\n                board[x][y] = \\'N\\';\\n                for(int d=0;d<dir.size();++d){\\n                    q.push(make_pair(x+dir[d][0], y+dir[d][1]));\\n                }\\n            }\\n        }\\n    }\\n    //bottom border\\n        for(int i=0;i<c;++i){\\n            if(board[r-1][i] == \\'X\\' || board[r-1][i] == \\'N\\'){continue;}\\n            else{\\n                q.push(make_pair(r-1,i));\\n                while(q.size()){\\n                    int x = q.front().first;\\n                    int y = q.front().second;\\n                    q.pop();\\n                    if(x<0 || x>=r || y<0 || y>=c || board[x][y] == \\'X\\' || board[x][y] == \\'N\\'){continue;}\\n                    board[x][y] = \\'N\\';\\n                    for(int d=0;d<dir.size();++d){\\n                        q.push(make_pair(x+dir[d][0], y+dir[d][1]));\\n                    }\\n                }\\n            }\\n    }\\n    \\n    //left border\\n        for(int i=0;i<r;++i){\\n        if(board[i][0] == \\'X\\' || board[i][0] == \\'N\\'){continue;}\\n        else{\\n            q.push(make_pair(i,0));\\n            while(q.size()){\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                if(x<0 || x>=r || y<0 || y>=c || board[x][y] == \\'X\\' || board[x][y] == \\'N\\'){continue;}\\n                board[x][y] = \\'N\\';\\n                for(int d=0;d<dir.size();++d){\\n                    q.push(make_pair(x+dir[d][0], y+dir[d][1]));\\n                }\\n            }\\n        }\\n    }\\n\\n    for(int i=0;i<r;++i){\\n        for(int j=0;j<c;++j){\\n            if(board[i][j]==\\'O\\'){board[i][j]=\\'X\\';}\\n        }\\n    }\\n    \\n    for(int i=0;i<r;++i){\\n        for(int j=0;j<c;++j){\\n            if(board[i][j]==\\'N\\'){board[i][j]=\\'O\\';}\\n        }\\n    }\\n    \\n    \\n}\\n```\\n\\n### Please upvote if you liked it!",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nvoid solve(vector<vector<char>>& board) {\\n    const int r = board.size();\\n    const int c = board[0].size();\\n    queue<pair<int,int>> q;\\n    vector<vector<int>> dir = {{1,0},{-1,0},{0,1},{0,-1}};\\n\\t\\n\\t//top border\\n    for(int i=0;i<c;++i){\\n        if(board[0][i] == \\'X\\' || board[0][i] == \\'N\\'){continue;}\\n        else{\\n            q.push(make_pair(0,i));\\n            while(q.size()){\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                if(x<0 || x>=r || y<0 || y>=c || board[x][y] == \\'X\\' || board[x][y] == \\'N\\'){continue;}\\n                board[x][y] = \\'N\\';\\n                for(int d=0;d<dir.size();++d){\\n                    q.push(make_pair(x+dir[d][0], y+dir[d][1]));\\n                }\\n            }\\n        }\\n    }\\n    \\n    //right border\\n        for(int i=0;i<r;++i){\\n        if(board[i][c-1] == \\'X\\' || board[i][c-1] == \\'N\\'){continue;}\\n        else{\\n            q.push(make_pair(i,c-1));\\n            while(q.size()){\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                if(x<0 || x>=r || y<0 || y>=c || board[x][y] == \\'X\\' || board[x][y] == \\'N\\'){continue;}\\n                board[x][y] = \\'N\\';\\n                for(int d=0;d<dir.size();++d){\\n                    q.push(make_pair(x+dir[d][0], y+dir[d][1]));\\n                }\\n            }\\n        }\\n    }\\n    //bottom border\\n        for(int i=0;i<c;++i){\\n            if(board[r-1][i] == \\'X\\' || board[r-1][i] == \\'N\\'){continue;}\\n            else{\\n                q.push(make_pair(r-1,i));\\n                while(q.size()){\\n                    int x = q.front().first;\\n                    int y = q.front().second;\\n                    q.pop();\\n                    if(x<0 || x>=r || y<0 || y>=c || board[x][y] == \\'X\\' || board[x][y] == \\'N\\'){continue;}\\n                    board[x][y] = \\'N\\';\\n                    for(int d=0;d<dir.size();++d){\\n                        q.push(make_pair(x+dir[d][0], y+dir[d][1]));\\n                    }\\n                }\\n            }\\n    }\\n    \\n    //left border\\n        for(int i=0;i<r;++i){\\n        if(board[i][0] == \\'X\\' || board[i][0] == \\'N\\'){continue;}\\n        else{\\n            q.push(make_pair(i,0));\\n            while(q.size()){\\n                int x = q.front().first;\\n                int y = q.front().second;\\n                q.pop();\\n                if(x<0 || x>=r || y<0 || y>=c || board[x][y] == \\'X\\' || board[x][y] == \\'N\\'){continue;}\\n                board[x][y] = \\'N\\';\\n                for(int d=0;d<dir.size();++d){\\n                    q.push(make_pair(x+dir[d][0], y+dir[d][1]));\\n                }\\n            }\\n        }\\n    }\\n\\n    for(int i=0;i<r;++i){\\n        for(int j=0;j<c;++j){\\n            if(board[i][j]==\\'O\\'){board[i][j]=\\'X\\';}\\n        }\\n    }\\n    \\n    for(int i=0;i<r;++i){\\n        for(int j=0;j<c;++j){\\n            if(board[i][j]==\\'N\\'){board[i][j]=\\'O\\';}\\n        }\\n    }\\n    \\n    \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3670646,
                "title": "c-straight-forward-approach",
                "content": "**Approch: 1**\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<char>> temp = grid;\\n        \\n        for(int i=0;i<m;i++){\\n            \\n            if(temp[i][0] == \\'O\\')\\n                bfs1(i,0,temp,grid);\\n            \\n            if(temp[i][n-1] == \\'O\\')\\n                bfs1(i,n-1,temp,grid);\\n        }\\n        for(int i=0;i<n;i++){\\n            \\n            if(temp[0][i] == \\'O\\')\\n                bfs1(0,i,temp,grid);\\n            \\n            if(temp[m-1][i] == \\'O\\')\\n                bfs1(m-1,i,temp,grid);\\n            \\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(temp[i][j] == \\'O\\'){\\n                    temp[i][j] = \\'X\\';\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(temp[i][j] == \\'1\\')\\n                    temp[i][j] = \\'O\\';\\n            }\\n        }\\n        grid = temp;\\n    }\\n    \\n    void bfs1(int i, int j, vector<vector<char>>& vis,vector<vector<char>> grid){\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int drows[] = {-1,0,1,0};\\n        int dcols[] = {0,1,0,-1};\\n        queue<pair<int,int>> q;\\n        \\n        q.push({i,j});\\n        vis[i][j] = \\'1\\';\\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            int row = it.first;\\n            int col = it.second;\\n            \\n            for(int k=0;k<4;k++){\\n                int nrow = row + drows[k];\\n                int ncol = col + dcols[k];\\n                if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && vis[nrow][ncol] == \\'O\\'){\\n                    q.push({nrow,ncol});\\n                    vis[nrow][ncol] = \\'1\\';\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n\\n**Approch: 2**\\n\\n```\\nclass Solution {\\npublic:\\n    int drow[4] = {-1,0,1,0};\\n    int dcol[4] = {0,1,0,-1};\\n    \\n    void solve(vector<vector<char>>& board) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        for(int i=0;i<m;i++){\\n            if(!vis[i][0] && board[i][0] == \\'O\\')\\n                dfs(i,0,vis,board);\\n            if(!vis[i][n-1] && board[i][n-1] == \\'O\\')\\n                dfs(i,n-1,vis,board);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(!vis[0][i] && board[0][i] == \\'O\\')\\n                dfs(0,i,vis,board);\\n            if(!vis[m-1][i] && board[m-1][i] == \\'O\\')\\n                dfs(m-1,i,vis,board);\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(board[i][j] == \\'O\\' && !vis[i][j])\\n                    board[i][j] = \\'X\\';\\n            }\\n        }\\n    }\\n    \\n    void dfs(int row,int col, vector<vector<int>> &vis, vector<vector<char>> &board){\\n        vis[row][col] = 1;\\n        for(int i=0;i<4;i++){\\n            int nrow = row + drow[i];\\n            int ncol = col + dcol[i];\\n            if(nrow>=0 && ncol >=0 && nrow<board.size() && ncol<board[0].size() && !vis[nrow][ncol] && board[nrow][ncol] == \\'O\\'){\\n                dfs(nrow,ncol,vis,board);\\n            }\\n        }\\n    }\\n};\\n```\\n\\n![image](https://assets.leetcode.com/users/images/39451a8b-4887-46f6-9b8f-b994e2e40253_1687453528.6643982.jpeg)\\n\\n**please upvote!! if you like.**\\ncomment below\\uD83D\\uDC47",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& grid) {\\n        int m = grid.size();\\n        int n = grid[0].size();\\n        vector<vector<char>> temp = grid;\\n        \\n        for(int i=0;i<m;i++){\\n            \\n            if(temp[i][0] == \\'O\\')\\n                bfs1(i,0,temp,grid);\\n            \\n            if(temp[i][n-1] == \\'O\\')\\n                bfs1(i,n-1,temp,grid);\\n        }\\n        for(int i=0;i<n;i++){\\n            \\n            if(temp[0][i] == \\'O\\')\\n                bfs1(0,i,temp,grid);\\n            \\n            if(temp[m-1][i] == \\'O\\')\\n                bfs1(m-1,i,temp,grid);\\n            \\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(temp[i][j] == \\'O\\'){\\n                    temp[i][j] = \\'X\\';\\n                }\\n            }\\n        }\\n        \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(temp[i][j] == \\'1\\')\\n                    temp[i][j] = \\'O\\';\\n            }\\n        }\\n        grid = temp;\\n    }\\n    \\n    void bfs1(int i, int j, vector<vector<char>>& vis,vector<vector<char>> grid){\\n        \\n        int m = grid.size();\\n        int n = grid[0].size();\\n        int drows[] = {-1,0,1,0};\\n        int dcols[] = {0,1,0,-1};\\n        queue<pair<int,int>> q;\\n        \\n        q.push({i,j});\\n        vis[i][j] = \\'1\\';\\n        while(!q.empty()){\\n            auto it = q.front();\\n            q.pop();\\n            int row = it.first;\\n            int col = it.second;\\n            \\n            for(int k=0;k<4;k++){\\n                int nrow = row + drows[k];\\n                int ncol = col + dcols[k];\\n                if(nrow>=0 && nrow<m && ncol>=0 && ncol<n && vis[nrow][ncol] == \\'O\\'){\\n                    q.push({nrow,ncol});\\n                    vis[nrow][ncol] = \\'1\\';\\n                }\\n            }\\n        }\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int drow[4] = {-1,0,1,0};\\n    int dcol[4] = {0,1,0,-1};\\n    \\n    void solve(vector<vector<char>>& board) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        vector<vector<int>> vis(m,vector<int> (n,0));\\n        for(int i=0;i<m;i++){\\n            if(!vis[i][0] && board[i][0] == \\'O\\')\\n                dfs(i,0,vis,board);\\n            if(!vis[i][n-1] && board[i][n-1] == \\'O\\')\\n                dfs(i,n-1,vis,board);\\n        }\\n        for(int i=0;i<n;i++){\\n            if(!vis[0][i] && board[0][i] == \\'O\\')\\n                dfs(0,i,vis,board);\\n            if(!vis[m-1][i] && board[m-1][i] == \\'O\\')\\n                dfs(m-1,i,vis,board);\\n        }\\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(board[i][j] == \\'O\\' && !vis[i][j])\\n                    board[i][j] = \\'X\\';\\n            }\\n        }\\n    }\\n    \\n    void dfs(int row,int col, vector<vector<int>> &vis, vector<vector<char>> &board){\\n        vis[row][col] = 1;\\n        for(int i=0;i<4;i++){\\n            int nrow = row + drow[i];\\n            int ncol = col + dcol[i];\\n            if(nrow>=0 && ncol >=0 && nrow<board.size() && ncol<board[0].size() && !vis[nrow][ncol] && board[nrow][ncol] == \\'O\\'){\\n                dfs(nrow,ncol,vis,board);\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297851,
                "title": "100-faster-easy-to-understand-bfs-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int> (m,0));\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 || i==n-1 || j==0 || j==m-1){\\n                    if(board[i][j]==\\'O\\'){\\n                        q.push({i,j});\\n                        vis[i][j]=1;\\n                    }\\n                }\\n\\n            }\\n        }\\n\\n            int delrow[4] = {-1,0,1,0};\\n            int delcol[4] ={0,+1,0,-1};\\n\\n        while(!q.empty()){\\n            int r = q.front().first;\\n            int c= q.front().second;\\n            q.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nr =r+delrow[i];\\n                int nc= c+delcol[i];\\n\\n                if(nr>=0 && nc>=0 && nr<n && nc<m && !vis[nr][nc] && board[nr][nc]==\\'O\\'){\\n                    vis[nr][nc]=1;\\n                    q.push({nr,nc});\\n                }\\n            }\\n        }\\n\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                    if(board[i][j]==\\'O\\' && !vis[i][j]){\\n                        board[i][j]=\\'X\\';\\n                    }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int n = board.size();\\n        int m = board[0].size();\\n        vector<vector<int>> vis(n,vector<int> (m,0));\\n        queue<pair<int,int>> q;\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(i==0 || i==n-1 || j==0 || j==m-1){\\n                    if(board[i][j]==\\'O\\'){\\n                        q.push({i,j});\\n                        vis[i][j]=1;\\n                    }\\n                }\\n\\n            }\\n        }\\n\\n            int delrow[4] = {-1,0,1,0};\\n            int delcol[4] ={0,+1,0,-1};\\n\\n        while(!q.empty()){\\n            int r = q.front().first;\\n            int c= q.front().second;\\n            q.pop();\\n\\n            for(int i=0;i<4;i++){\\n                int nr =r+delrow[i];\\n                int nc= c+delcol[i];\\n\\n                if(nr>=0 && nc>=0 && nr<n && nc<m && !vis[nr][nc] && board[nr][nc]==\\'O\\'){\\n                    vis[nr][nc]=1;\\n                    q.push({nr,nc});\\n                }\\n            }\\n        }\\n\\n          for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                    if(board[i][j]==\\'O\\' && !vis[i][j]){\\n                        board[i][j]=\\'X\\';\\n                    }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2884951,
                "title": "kotlin-dfs",
                "content": "```\\nclass Solution {\\n    fun solve(board: Array<CharArray>): Unit {\\n        fun dfs(r: Int, c: Int) {\\n            if (r !in board.indices || c !in board[0].indices || board[r][c] != \\'O\\') return\\n            board[r][c] = \\'T\\'\\n            dfs(r + 1, c); dfs(r - 1, c); dfs(r, c + 1); dfs(r, c - 1)\\n        }\\n        traverse(board) { r, c -> \\n            if (r in listOf(0, board.lastIndex) || c in listOf(0, board[0].lastIndex)) dfs(r,c)\\n        }\\n        traverse(board) { r, c -> \\n            if (board[r][c] == \\'O\\') board[r][c] = \\'X\\'\\n            if (board[r][c] == \\'T\\') board[r][c] = \\'O\\'\\n        }\\n    }\\n\\n    fun traverse(board: Array<CharArray>, code: (Int, Int) -> Unit) {\\n        for (r in 0 until board.size) {\\n            for (c in 0 until board[0].size) {\\n                code(r, c)    \\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    fun solve(board: Array<CharArray>): Unit {\\n        fun dfs(r: Int, c: Int) {\\n            if (r !in board.indices || c !in board[0].indices || board[r][c] != \\'O\\') return\\n            board[r][c] = \\'T\\'\\n            dfs(r + 1, c); dfs(r - 1, c); dfs(r, c + 1); dfs(r, c - 1)\\n        }\\n        traverse(board) { r, c -> \\n            if (r in listOf(0, board.lastIndex) || c in listOf(0, board[0].lastIndex)) dfs(r,c)\\n        }\\n        traverse(board) { r, c -> \\n            if (board[r][c] == \\'O\\') board[r][c] = \\'X\\'\\n            if (board[r][c] == \\'T\\') board[r][c] = \\'O\\'\\n        }\\n    }\\n\\n    fun traverse(board: Array<CharArray>, code: (Int, Int) -> Unit) {\\n        for (r in 0 until board.size) {\\n            for (c in 0 until board[0].size) {\\n                code(r, c)    \\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2873919,
                "title": "python3-easy-to-understand-recursion",
                "content": "The idea: what if we iterate through all the boarder O\\'s and preserve all the connected O\\'s.\\n\\n1. In the first for loops we iterate through top and bottom boarders and preserving all the connected O\\'s.\\n2. Iterate through left and right boarders and preserve the O\\'s.\\n3. How the O\\'s are preserved:\\n\\t3.1. Define visited cells to not run into infinite recursion.\\n\\t3.2. `sur` describes possible surrounding cells.\\n\\t3.3 . `ci, cj` are the current cell\\'s indexes.\\n\\t3.4. `0 < ci < m-1 and 0 < cj < n-1` cuts off all the invalid and boarder cells.\\n\\t3.5 `(ci, cj) not in visited` we check if we had visited the cell (prevents the infinite recursion)\\n\\t3.6. `if (ci, cj) in should_preserve: continue` - there is no need to double-process the cell if it\\'s preserved\\n\\t3.7. if the cell is preserved - it can preserve the neighbor cell - call `preserve_connected`\\n4. Go through all the cells excluding borders and set them to \\'X\\' if they are not preserved.\\n\\n\\n```\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        should_preserve = set()\\n        m = len(board)\\n        n = len(board[0])\\n\\n        def preserve_connected(i, j, visited=None):\\n            if visited is None:\\n                visited = set([(i, j)])\\n            sur = ((0, 1), (0, -1), (1, 0), (-1, 0))\\n            for di, dj in sur:\\n                ci, cj = di + i, dj + j\\n                if 0 < ci < m-1 and 0 < cj < n-1 and (ci, cj) not in visited and board[ci][cj] == \\'O\\':\\n                    if (ci, cj) in should_preserve:\\n                        continue\\n                    should_preserve.add((ci, cj))\\n                    preserve_connected(ci, cj, visited.union([(ci, cj)]))\\n\\n        for i in [0, m-1]:\\n            for j in range(n):\\n                if board[i][j] == \\'O\\':\\n                    should_preserve.add((i, j))\\n                    preserve_connected(i, j)\\n\\n        for j in [0, n-1]:\\n            for i in range(1, m-1):\\n                if board[i][j] == \\'O\\':\\n                    should_preserve.add((i, j))\\n                    preserve_connected(i, j)\\n\\n        for i in range(1, m-1):\\n            for j in range(1, n-1):\\n                if board[i][j] == \\'O\\' and (i, j) not in should_preserve:\\n                    board[i][j] = \\'X\\'\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "The idea: what if we iterate through all the boarder O\\'s and preserve all the connected O\\'s.\\n\\n1. In the first for loops we iterate through top and bottom boarders and preserving all the connected O\\'s.\\n2. Iterate through left and right boarders and preserve the O\\'s.\\n3. How the O\\'s are preserved:\\n\\t3.1. Define visited cells to not run into infinite recursion.\\n\\t3.2. `sur` describes possible surrounding cells.\\n\\t3.3 . `ci, cj` are the current cell\\'s indexes.\\n\\t3.4. `0 < ci < m-1 and 0 < cj < n-1` cuts off all the invalid and boarder cells.\\n\\t3.5 `(ci, cj) not in visited` we check if we had visited the cell (prevents the infinite recursion)\\n\\t3.6. `if (ci, cj) in should_preserve: continue` - there is no need to double-process the cell if it\\'s preserved\\n\\t3.7. if the cell is preserved - it can preserve the neighbor cell - call `preserve_connected`\\n4. Go through all the cells excluding borders and set them to \\'X\\' if they are not preserved.\\n\\n\\n```\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        should_preserve = set()\\n        m = len(board)\\n        n = len(board[0])\\n\\n        def preserve_connected(i, j, visited=None):\\n            if visited is None:\\n                visited = set([(i, j)])\\n            sur = ((0, 1), (0, -1), (1, 0), (-1, 0))\\n            for di, dj in sur:\\n                ci, cj = di + i, dj + j\\n                if 0 < ci < m-1 and 0 < cj < n-1 and (ci, cj) not in visited and board[ci][cj] == \\'O\\':\\n                    if (ci, cj) in should_preserve:\\n                        continue\\n                    should_preserve.add((ci, cj))\\n                    preserve_connected(ci, cj, visited.union([(ci, cj)]))\\n\\n        for i in [0, m-1]:\\n            for j in range(n):\\n                if board[i][j] == \\'O\\':\\n                    should_preserve.add((i, j))\\n                    preserve_connected(i, j)\\n\\n        for j in [0, n-1]:\\n            for i in range(1, m-1):\\n                if board[i][j] == \\'O\\':\\n                    should_preserve.add((i, j))\\n                    preserve_connected(i, j)\\n\\n        for i in range(1, m-1):\\n            for j in range(1, n-1):\\n                if board[i][j] == \\'O\\' and (i, j) not in should_preserve:\\n                    board[i][j] = \\'X\\'\\n\\n",
                "codeTag": "Java"
            },
            {
                "id": 2676931,
                "title": "java-easy-to-understand-beats-99-95",
                "content": "```\\n/*\\n\\nGiven that O cells along the boarder, and any cell connected to O cell that cannot be captured also cannot be captured,\\nwe can think of it inversely by determining all the cells that CANNOT BE captured and use it to determine whether an O cell can be captured\\n\\n1. init a set to track cells that cannot be caputured\\n2. for each cell in the starting from the 4 boarders, run a dfs check if the cell is O\\n    2.1 add all cells adjacent to it to the set\\n3. iterate the board again, and if the cell is O and not along the 4 boarder and is also not present in the set\\n    3.1 mark the cell to X\\n    \\nHowever, note that instead of using additional space, we can use back the board itself to track which cells cannot be captured by marking it \\nwith custom character\\n\\nif an O cell cannot be captured, we mark it as T.\\nWhen we iterate the board again, we change T cells back to O, and all other cells will be X\\n*/\\n\\nclass Solution {\\n    int row;\\n    int col;\\n    \\n    public void solve(char[][] board) {\\n        row = board.length;\\n        col = board[0].length;\\n\\n        // top and bottom boarder\\n        // dfs from each col\\n        for(int i = 0; i < col; i++) {\\n            dfs(board, 0, i);\\n            dfs(board, row-1, i);\\n        }\\n        \\n        // check left and right border\\n        // dfs from each row\\n        for(int i = 0; i < row; i++) {\\n            dfs(board, i, 0);\\n            dfs(board, i, col-1);\\n        }\\n        \\n        for(int i = 0; i < row; i++)\\n            for(int j = 0; j < col; j++) {\\n                if (board[i][j] == \\'T\\') board[i][j] = \\'O\\';\\n                else board[i][j] = \\'X\\';\\n            }\\n    }\\n    \\n    int[][] directions = new int[][]{{0,1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public void dfs(char[][] board, int i , int j) {\\n        if ((i < 0 || j < 0 || i >= row || j >= col) // out of bounds\\n            || board[i][j] == \\'T\\' // already visited\\n            || board[i][j] != \\'O\\') { // not connected to an O\\n            return;\\n        }\\n        \\n        board[i][j] = \\'T\\';\\n        \\n        // dfs neighbours\\n        for(int[] dir : directions) {\\n            dfs(board, dir[0] + i, dir[1] + j);\\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\n/*\\n\\nGiven that O cells along the boarder, and any cell connected to O cell that cannot be captured also cannot be captured,\\nwe can think of it inversely by determining all the cells that CANNOT BE captured and use it to determine whether an O cell can be captured\\n\\n1. init a set to track cells that cannot be caputured\\n2. for each cell in the starting from the 4 boarders, run a dfs check if the cell is O\\n    2.1 add all cells adjacent to it to the set\\n3. iterate the board again, and if the cell is O and not along the 4 boarder and is also not present in the set\\n    3.1 mark the cell to X\\n    \\nHowever, note that instead of using additional space, we can use back the board itself to track which cells cannot be captured by marking it \\nwith custom character\\n\\nif an O cell cannot be captured, we mark it as T.\\nWhen we iterate the board again, we change T cells back to O, and all other cells will be X\\n*/\\n\\nclass Solution {\\n    int row;\\n    int col;\\n    \\n    public void solve(char[][] board) {\\n        row = board.length;\\n        col = board[0].length;\\n\\n        // top and bottom boarder\\n        // dfs from each col\\n        for(int i = 0; i < col; i++) {\\n            dfs(board, 0, i);\\n            dfs(board, row-1, i);\\n        }\\n        \\n        // check left and right border\\n        // dfs from each row\\n        for(int i = 0; i < row; i++) {\\n            dfs(board, i, 0);\\n            dfs(board, i, col-1);\\n        }\\n        \\n        for(int i = 0; i < row; i++)\\n            for(int j = 0; j < col; j++) {\\n                if (board[i][j] == \\'T\\') board[i][j] = \\'O\\';\\n                else board[i][j] = \\'X\\';\\n            }\\n    }\\n    \\n    int[][] directions = new int[][]{{0,1}, {0, -1}, {1, 0}, {-1, 0}};\\n    public void dfs(char[][] board, int i , int j) {\\n        if ((i < 0 || j < 0 || i >= row || j >= col) // out of bounds\\n            || board[i][j] == \\'T\\' // already visited\\n            || board[i][j] != \\'O\\') { // not connected to an O\\n            return;\\n        }\\n        \\n        board[i][j] = \\'T\\';\\n        \\n        // dfs neighbours\\n        for(int[] dir : directions) {\\n            dfs(board, dir[0] + i, dir[1] + j);\\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2642467,
                "title": "using-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q;\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(i == 0 || i == m-1 || j == 0 || j == n-1)\\n                {\\n                    if(board[i][j] == \\'O\\')\\n                    {\\n                        visited[i][j] = true;\\n                        q.push({i, j});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            \\n            q.pop();\\n            int drow[4] = {-1, 0, 1, 0};\\n            int dcol[4] = {0, 1, 0, -1};\\n            \\n            for(int i = 0; i < 4; i++)\\n            {\\n                int row = r + drow[i];\\n                int col = c + dcol[i];\\n                \\n                if(row >= 0 && row < m && col >= 0 && col < n && !visited[row][col] && board[row][col] == \\'O\\')\\n                {\\n                    visited[row][col] = true;\\n                    q.push({row, col});\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(!visited[i][j] && board[i][j] == \\'O\\')\\n                {\\n                    board[i][j] = \\'X\\';\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        vector<vector<bool>> visited(m, vector<bool>(n, false));\\n        queue<pair<int, int>> q;\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(i == 0 || i == m-1 || j == 0 || j == n-1)\\n                {\\n                    if(board[i][j] == \\'O\\')\\n                    {\\n                        visited[i][j] = true;\\n                        q.push({i, j});\\n                    }\\n                }\\n            }\\n        }\\n        \\n        while(!q.empty())\\n        {\\n            int r = q.front().first;\\n            int c = q.front().second;\\n            \\n            q.pop();\\n            int drow[4] = {-1, 0, 1, 0};\\n            int dcol[4] = {0, 1, 0, -1};\\n            \\n            for(int i = 0; i < 4; i++)\\n            {\\n                int row = r + drow[i];\\n                int col = c + dcol[i];\\n                \\n                if(row >= 0 && row < m && col >= 0 && col < n && !visited[row][col] && board[row][col] == \\'O\\')\\n                {\\n                    visited[row][col] = true;\\n                    q.push({row, col});\\n                }\\n            }\\n        }\\n        \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++)\\n            {\\n                if(!visited[i][j] && board[i][j] == \\'O\\')\\n                {\\n                    board[i][j] = \\'X\\';\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2506056,
                "title": "c-dfs-boundary-dfs",
                "content": "class Solution {\\n    public:\\n    int DR[4]={1,0,-1,0};\\n    int DC[4]={0,-1,0,1};\\n    \\n    void dfs(int i,int j,vector<vector<int>> &vis,vector<vector<char>> &board){\\n      vis[i][j] = 1;\\n      int n = board.size();\\n      int m = board[0].size();\\n      \\n      //Check for top,right,bottom,left\\n      for(int k=0;k<4;k++){\\n          int ci = i + DR[k];\\n          int cj = j + DC[k];\\n          \\n          if(ci >= 0 && ci < n && cj >= 0 && cj < m && !vis[ci][cj] && board[ci][cj] == \\'O\\' ){\\n              dfs(ci,cj,vis,board);\\n          }\\n      }\\n      \\n    }\\n\\n    void solve(vector<vector<char>>& board) {\\n        int n = board.size();\\n        int m = board[0].size();\\n     \\n        vector<vector<int>> vis(n,vector<int> (m,0));\\n        \\n        //traverse first row and last row\\n        for(int j=0;j<m;j++){\\n            \\n            //First Row\\n            if(!vis[0][j] && board[0][j] == \\'O\\'){\\n                dfs(0,j,vis,board);\\n            }\\n            \\n            //Last Row\\n            if(!vis[n-1][j] && board[n-1][j] == \\'O\\'){\\n                dfs(n-1,j,vis,board);\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            //First Column\\n            if(!vis[i][0] && board[i][0] == \\'O\\'){\\n                dfs(i,0,vis,board);\\n            }\\n            \\n            if(!vis[i][m-1] && board[i][m-1] == \\'O\\'){\\n                dfs(i,m-1,vis,board);\\n            }\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j = 0;j<m;j++){\\n                if(!vis[i][j] && board[i][j] == \\'O\\'){\\n                    board[i][j] = \\'X\\';\\n                }\\n            }\\n        }\\n    }\\n   \\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int DR[4]={1,0,-1,0}",
                "codeTag": "Java"
            },
            {
                "id": 2498259,
                "title": "easy-c-solution-dfs",
                "content": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int n = (int)board.size();\\n        int m = (int)board[0].size();\\n        \\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (i == 0 || i == n - 1 || j == 0 || j == m - 1) {\\n                    if (board[i][j] == \\'O\\') {\\n                        dfs(i, j, board, n, m);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (board[i][j] == \\'O\\') {\\n                    board[i][j] = \\'X\\';\\n                } else if (board[i][j] == \\'-\\') {\\n                    board[i][j] = \\'O\\';\\n                }\\n            }\\n        }\\n    }\\n    void dfs(int r, int c, vector<vector<char>>& board, int n, int m) {\\n        if (r < 0 || r >= n || c < 0 || c >= m || board[r][c] != \\'O\\') return;\\n        \\n        board[r][c] = \\'-\\';\\n        \\n        dfs(r - 1, c, board, n, m);\\n        dfs(r, c + 1, board, n, m);\\n        dfs(r + 1, c, board, n, m);\\n        dfs(r, c - 1, board, n, m);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int n = (int)board.size();\\n        int m = (int)board[0].size();\\n        \\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (i == 0 || i == n - 1 || j == 0 || j == m - 1) {\\n                    if (board[i][j] == \\'O\\') {\\n                        dfs(i, j, board, n, m);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        for (int i = 0; i < n; ++i) {\\n            for (int j = 0; j < m; ++j) {\\n                if (board[i][j] == \\'O\\') {\\n                    board[i][j] = \\'X\\';\\n                } else if (board[i][j] == \\'-\\') {\\n                    board[i][j] = \\'O\\';\\n                }\\n            }\\n        }\\n    }\\n    void dfs(int r, int c, vector<vector<char>>& board, int n, int m) {\\n        if (r < 0 || r >= n || c < 0 || c >= m || board[r][c] != \\'O\\') return;\\n        \\n        board[r][c] = \\'-\\';\\n        \\n        dfs(r - 1, c, board, n, m);\\n        dfs(r, c + 1, board, n, m);\\n        dfs(r + 1, c, board, n, m);\\n        dfs(r, c - 1, board, n, m);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459971,
                "title": "c-dfs",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(int i,int j,vector<vector<char>>& board){\\n\\n\\t\\t\\tif(i>=board.size() || j>=board[0].size() || i<0 || j<0)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tif(board[i][j]!=\\'O\\')\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tboard[i][j]=\\'#\\';\\n\\n\\t\\t\\tdfs(i-1,j,board);\\n\\t\\t\\tdfs(i,j-1,board);\\n\\t\\t\\tdfs(i,j+1,board);\\n\\t\\t\\tdfs(i+1,j,board);\\n\\t\\t}\\n\\t\\tvoid solve(vector<vector<char>>& board) {\\n\\n\\t\\t\\tfor(int i=0;i<board.size();i++){\\n\\t\\t\\t\\tfor(int j=0;j<board[i].size();j++){\\n\\t\\t\\t\\t\\tif(i==0 || j==0 || i==board.size()-1 || j==board[i].size()-1){\\n\\t\\t\\t\\t\\t\\tif(board[i][j]==\\'O\\')\\n\\t\\t\\t\\t\\t\\t\\tdfs(i,j,board);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tfor(int i=0;i<board.size();i++){\\n\\t\\t\\t\\tfor(int j=0;j<board[i].size();j++){\\n\\t\\t\\t\\t\\tif(board[i][j]==\\'O\\')\\n\\t\\t\\t\\t\\t\\tboard[i][j]=\\'X\\';\\n\\t\\t\\t\\t\\tif(board[i][j]==\\'#\\')\\n\\t\\t\\t\\t\\t\\tboard[i][j]=\\'O\\';\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvoid dfs(int i,int j,vector<vector<char>>& board){\\n\\n\\t\\t\\tif(i>=board.size() || j>=board[0].size() || i<0 || j<0)\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tif(board[i][j]!=\\'O\\')\\n\\t\\t\\t\\treturn;\\n\\n\\t\\t\\tboard[i][j]=\\'#\\';\\n\\n\\t\\t\\tdfs(i-1,j,board);\\n\\t\\t\\tdfs(i,j-1,board);\\n\\t\\t\\tdfs(i,j+1,board);\\n\\t\\t\\tdfs(i+1,j,board);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2449639,
                "title": "java-bfs-simple-and-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public class pair{\\n        int row;\\n        int col;\\n        \\n        pair(int row,int col){\\n            this.row = row;\\n            this.col = col;\\n        }\\n    }\\n    \\n    public void solve(char[][] board) {\\n        int n = board.length,m = board[0].length;\\n        int [][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n        \\n        // Adding all the O\\'s at the Edges in the Queue and marking it as \\'+\\'\\n        LinkedList<pair> que = new LinkedList<>();\\n        for(int r = 0;r < n;r++){\\n            if(board[r][0] == \\'O\\'){\\n                board[r][0] = \\'+\\';\\n                que.addLast(new pair(r,0));\\n            }\\n            \\n            if(board[r][m - 1] == \\'O\\'){\\n                board[r][m - 1] = \\'+\\';\\n                que.addLast(new pair(r,m - 1));\\n            }\\n        }\\n        \\n        for(int c = 0; c < m;c++){\\n            if(board[0][c] == \\'O\\'){\\n                board[0][c] = \\'+\\';\\n                que.addLast(new pair(0,c));\\n            }\\n            \\n            if(board[n - 1][c] == \\'O\\'){\\n                board[n - 1][c] = \\'+\\';\\n                que.addLast(new pair(n - 1,c));\\n            }\\n        }\\n        \\n        // marking all the O\\'s connected with edges in the Queue as \\'+\\'\\n        while(que.size() != 0){\\n            pair rp = que.removeFirst();\\n            int row = rp.row;\\n            int col = rp.col;\\n            \\n            for(int[] d : dir){\\n                int r = row + d[0];\\n                int c = col + d[1];\\n                \\n                if(r >= 0 && c >= 0 && r < n && c < m && board[r][c] == \\'O\\'){\\n                    board[r][c] = \\'+\\';\\n                    que.addLast(new pair(r,c));\\n                }\\n            }\\n        }\\n\\n        // replacing all the remaining O\\'s as \\'X\\' and all the \\'+\\' as O\\'s\\n        for(int i = 0;i < n;i++){\\n            for(int j = 0;j < m;j++){\\n                if(board[i][j] == \\'O\\')  board[i][j] = \\'X\\';\\n                else if(board[i][j] == \\'+\\')  board[i][j] = \\'O\\'; \\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public class pair{\\n        int row;\\n        int col;\\n        \\n        pair(int row,int col){\\n            this.row = row;\\n            this.col = col;\\n        }\\n    }\\n    \\n    public void solve(char[][] board) {\\n        int n = board.length,m = board[0].length;\\n        int [][] dir = {{0,1},{1,0},{0,-1},{-1,0}};\\n        \\n        // Adding all the O\\'s at the Edges in the Queue and marking it as \\'+\\'\\n        LinkedList<pair> que = new LinkedList<>();\\n        for(int r = 0;r < n;r++){\\n            if(board[r][0] == \\'O\\'){\\n                board[r][0] = \\'+\\';\\n                que.addLast(new pair(r,0));\\n            }\\n            \\n            if(board[r][m - 1] == \\'O\\'){\\n                board[r][m - 1] = \\'+\\';\\n                que.addLast(new pair(r,m - 1));\\n            }\\n        }\\n        \\n        for(int c = 0; c < m;c++){\\n            if(board[0][c] == \\'O\\'){\\n                board[0][c] = \\'+\\';\\n                que.addLast(new pair(0,c));\\n            }\\n            \\n            if(board[n - 1][c] == \\'O\\'){\\n                board[n - 1][c] = \\'+\\';\\n                que.addLast(new pair(n - 1,c));\\n            }\\n        }\\n        \\n        // marking all the O\\'s connected with edges in the Queue as \\'+\\'\\n        while(que.size() != 0){\\n            pair rp = que.removeFirst();\\n            int row = rp.row;\\n            int col = rp.col;\\n            \\n            for(int[] d : dir){\\n                int r = row + d[0];\\n                int c = col + d[1];\\n                \\n                if(r >= 0 && c >= 0 && r < n && c < m && board[r][c] == \\'O\\'){\\n                    board[r][c] = \\'+\\';\\n                    que.addLast(new pair(r,c));\\n                }\\n            }\\n        }\\n\\n        // replacing all the remaining O\\'s as \\'X\\' and all the \\'+\\' as O\\'s\\n        for(int i = 0;i < n;i++){\\n            for(int j = 0;j < m;j++){\\n                if(board[i][j] == \\'O\\')  board[i][j] = \\'X\\';\\n                else if(board[i][j] == \\'+\\')  board[i][j] = \\'O\\'; \\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2347794,
                "title": "simple-dfs-solution",
                "content": "Solution is in 3 steps :-\\n1) Traverse all boundary 0s and make them and all their connected 0s 1\\n2) Now traverse in matrix if you find a 1 that means it was previously a 0 which was not connected by X on all 4 directions or it was not connected to a valid 0 . Therefore make them 0 again. \\n3) If you found a 0 that means it was a valid 0(i,.e connected by X on all 4 directions) therefore make it X.\\n\\n```\\nclass Solution {\\npublic:\\n    void helper(int i,int j,vector<vector<char>>& board,int n,int m,vector<vector<bool>>& vis){\\n        if(i<0 || i>=n || j<0 || j>=m || vis[i][j] || board[i][j] != \\'O\\')\\n            return;\\n        \\n        vis[i][j] = true;\\n        board[i][j] = \\'1\\';\\n        helper(i+1,j,board,n,m,vis);\\n        helper(i-1,j,board,n,m,vis);\\n        helper(i,j+1,board,n,m,vis);\\n        helper(i,j-1,board,n,m,vis);\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n        vector<vector<bool>> vis(n,vector<bool>(m,false));\\n        \\n        for(int j=0;j<m;j++){\\n            if(board[0][j] == \\'O\\')\\n                helper(0,j,board,n,m,vis);\\n            if(board[n-1][j] == \\'O\\')\\n                helper(n-1,j,board,n,m,vis);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            if(board[i][0] == \\'O\\')\\n                helper(i,0,board,n,m,vis);\\n            if(board[i][m-1] == \\'O\\')\\n                helper(i,m-1,board,n,m,vis);\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j] == \\'1\\')\\n                    board[i][j] = \\'O\\';\\n                else if(board[i][j] == \\'O\\')\\n                    board[i][j] = \\'X\\';\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    void helper(int i,int j,vector<vector<char>>& board,int n,int m,vector<vector<bool>>& vis){\\n        if(i<0 || i>=n || j<0 || j>=m || vis[i][j] || board[i][j] != \\'O\\')\\n            return;\\n        \\n        vis[i][j] = true;\\n        board[i][j] = \\'1\\';\\n        helper(i+1,j,board,n,m,vis);\\n        helper(i-1,j,board,n,m,vis);\\n        helper(i,j+1,board,n,m,vis);\\n        helper(i,j-1,board,n,m,vis);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2294084,
                "title": "c-dfs-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<char>>&board,int row,int col,int m,int n){\\n        if(row<0 || row>=m || col<0 || col>=n){\\n            return;\\n        }\\n        board[row][col] = \\'B\\';\\n        if(row-1>=0 && board[row-1][col]==\\'O\\'){\\n            dfs(board,row-1,col,m,n);\\n        }\\n        if(col+1<n && board[row][col+1] == \\'O\\'){\\n            dfs(board,row,col+1,m,n);\\n        }\\n        if(row+1<m && board[row+1][col] == \\'O\\'){\\n            dfs(board,row+1,col,m,n);\\n        }\\n        if(col-1>=0 && board[row][col-1] == \\'O\\'){\\n            dfs(board,row,col-1,m,n);\\n        }\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        \\n    //Iterate over boundaries to find any \\'O\\' connected to boundary and mark them \\'B\\' using DFS.\\n        for(int i=0;i<m;i++){\\n            if(board[i][0] == \\'O\\'){\\n                dfs(board,i,0,m,n);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(board[0][i] == \\'O\\'){\\n                dfs(board,0,i,m,n);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(board[m-1][i] == \\'O\\'){\\n                dfs(board,m-1,i,m,n);\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            if(board[i][n-1] == \\'O\\'){\\n                dfs(board,i,n-1,m,n);\\n            }\\n        }\\n        \\n    //The Cell which is still \\'O\\' doesn\\'t connected to boundary therefore it is surrounded by \"X\".\\n    //Convert all \"B\" to \"O\" because they are on boundary hence can\\'t be surrounded and mark rest of the cells \"X\". \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(board[i][j] == \\'O\\'){\\n                    board[i][j] = \\'X\\';\\n                }\\n                if(board[i][j] == \\'B\\'){\\n                    board[i][j] = \\'O\\';\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<char>>&board,int row,int col,int m,int n){\\n        if(row<0 || row>=m || col<0 || col>=n){\\n            return;\\n        }\\n        board[row][col] = \\'B\\';\\n        if(row-1>=0 && board[row-1][col]==\\'O\\'){\\n            dfs(board,row-1,col,m,n);\\n        }\\n        if(col+1<n && board[row][col+1] == \\'O\\'){\\n            dfs(board,row,col+1,m,n);\\n        }\\n        if(row+1<m && board[row+1][col] == \\'O\\'){\\n            dfs(board,row+1,col,m,n);\\n        }\\n        if(col-1>=0 && board[row][col-1] == \\'O\\'){\\n            dfs(board,row,col-1,m,n);\\n        }\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        \\n        \\n    //Iterate over boundaries to find any \\'O\\' connected to boundary and mark them \\'B\\' using DFS.\\n        for(int i=0;i<m;i++){\\n            if(board[i][0] == \\'O\\'){\\n                dfs(board,i,0,m,n);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(board[0][i] == \\'O\\'){\\n                dfs(board,0,i,m,n);\\n            }\\n        }\\n        for(int i=0;i<n;i++){\\n            if(board[m-1][i] == \\'O\\'){\\n                dfs(board,m-1,i,m,n);\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            if(board[i][n-1] == \\'O\\'){\\n                dfs(board,i,n-1,m,n);\\n            }\\n        }\\n        \\n    //The Cell which is still \\'O\\' doesn\\'t connected to boundary therefore it is surrounded by \"X\".\\n    //Convert all \"B\" to \"O\" because they are on boundary hence can\\'t be surrounded and mark rest of the cells \"X\". \\n        for(int i=0;i<m;i++){\\n            for(int j=0;j<n;j++){\\n                if(board[i][j] == \\'O\\'){\\n                    board[i][j] = \\'X\\';\\n                }\\n                if(board[i][j] == \\'B\\'){\\n                    board[i][j] = \\'O\\';\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2284131,
                "title": "c-boundary-traversal-dfs-solution",
                "content": "```\\nclass Solution {\\n    int dx[4]={-1,1,0,0};\\n    int dy[4]={0,0,-1,1};\\n    void DFS(std::vector<vector<char>>& board,int x,int y,int n,int m){\\n        if(x>=0 and y>=0 and x<n and y<m and board[x][y]==\\'O\\'){\\n                board[x][y]=\\'#\\';\\n                for(int k=0;k<4;++k)\\n                    DFS(board,x+dx[k],y+dy[k],n,m);\\n        }  \\n    }\\npublic:\\n    void solve(std::vector<vector<char>>& board) {\\n        int n=board.size(), m=board[0].size();\\n        \\n        if((n==1 and m==1) or !n or !m) \\n            return;\\n        \\n        for(int i=0;i<n;i++){\\n            if(board[i][0]==\\'O\\')\\n                DFS(board,i,0,n,m);\\n            if(board[i][m-1]==\\'O\\')\\n                DFS(board,i,m-1,n,m);\\n        }\\n        \\n        for(int j=0;j<m;++j){\\n            if(board[0][j]==\\'O\\')\\n                DFS(board,0,j,n,m);\\n            if(board[n-1][j]==\\'O\\')\\n                DFS(board,n-1,j,n,m);\\n        }\\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(board[i][j]==\\'#\\')\\n                    board[i][j]=\\'O\\';\\n                else if(board[i][j]==\\'O\\')\\n                    board[i][j]=\\'X\\';\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    int dx[4]={-1,1,0,0};\\n    int dy[4]={0,0,-1,1};\\n    void DFS(std::vector<vector<char>>& board,int x,int y,int n,int m){\\n        if(x>=0 and y>=0 and x<n and y<m and board[x][y]==\\'O\\'){\\n                board[x][y]=\\'#\\';\\n                for(int k=0;k<4;++k)\\n                    DFS(board,x+dx[k],y+dy[k],n,m);\\n        }  \\n    }\\npublic:\\n    void solve(std::vector<vector<char>>& board) {\\n        int n=board.size(), m=board[0].size();\\n        \\n        if((n==1 and m==1) or !n or !m) \\n            return;\\n        \\n        for(int i=0;i<n;i++){\\n            if(board[i][0]==\\'O\\')\\n                DFS(board,i,0,n,m);\\n            if(board[i][m-1]==\\'O\\')\\n                DFS(board,i,m-1,n,m);\\n        }\\n        \\n        for(int j=0;j<m;++j){\\n            if(board[0][j]==\\'O\\')\\n                DFS(board,0,j,n,m);\\n            if(board[n-1][j]==\\'O\\')\\n                DFS(board,n-1,j,n,m);\\n        }\\n        \\n        for(int i=0;i<n;++i){\\n            for(int j=0;j<m;++j){\\n                if(board[i][j]==\\'#\\')\\n                    board[i][j]=\\'O\\';\\n                else if(board[i][j]==\\'O\\')\\n                    board[i][j]=\\'X\\';\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2162688,
                "title": "c-bfs-easy-solution",
                "content": "*Please upvote if you find it helpful :)*\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        queue<pair<int,int> >q;\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 || j==0 || i==m-1 || j==n-1) {\\n                    if(board[i][j]==\\'O\\')\\n                        q.push({i,j});\\n                }\\n            }\\n        }\\n        int x1[4] = {1,-1,0,0};\\n        int y1[4] = {0,0,-1,1};\\n        while(!q.empty()) {\\n            pair<int,int> h = q.front();\\n            q.pop();\\n            int x = h.first;\\n            int y = h.second;\\n            board[x][y] = \\'V\\';\\n            for(int k=0;k<4;k++) {\\n                int x2 = x + x1[k];\\n                int y2 = y + y1[k];\\n                if(x2>=0 && y2>=0 && x2<m && y2<n && board[x2][y2]==\\'O\\') {\\n                    q.push({x2,y2});\\n                    board[x2][y2] = \\'V\\';              // visited\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(board[i][j]==\\'V\\') {       \\n                    board[i][j]=\\'O\\';\\n                }\\n                else if(board[i][j]==\\'O\\') {\\n                    board[i][j]=\\'X\\';\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        int m = board.size();\\n        int n = board[0].size();\\n        queue<pair<int,int> >q;\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(i==0 || j==0 || i==m-1 || j==n-1) {\\n                    if(board[i][j]==\\'O\\')\\n                        q.push({i,j});\\n                }\\n            }\\n        }\\n        int x1[4] = {1,-1,0,0};\\n        int y1[4] = {0,0,-1,1};\\n        while(!q.empty()) {\\n            pair<int,int> h = q.front();\\n            q.pop();\\n            int x = h.first;\\n            int y = h.second;\\n            board[x][y] = \\'V\\';\\n            for(int k=0;k<4;k++) {\\n                int x2 = x + x1[k];\\n                int y2 = y + y1[k];\\n                if(x2>=0 && y2>=0 && x2<m && y2<n && board[x2][y2]==\\'O\\') {\\n                    q.push({x2,y2});\\n                    board[x2][y2] = \\'V\\';              // visited\\n                }\\n            }\\n        }\\n        for(int i=0;i<m;i++) {\\n            for(int j=0;j<n;j++) {\\n                if(board[i][j]==\\'V\\') {       \\n                    board[i][j]=\\'O\\';\\n                }\\n                else if(board[i][j]==\\'O\\') {\\n                    board[i][j]=\\'X\\';\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2077910,
                "title": "python-dfs-reverse-thinking-with-illustration-and-explanations",
                "content": "![image](https://assets.leetcode.com/users/images/ed87474b-eee6-432c-9b8f-364cd56d27c3_1653620407.2524738.png)\\n*This example graph is draw by myself using google slide.*\\nI use the reverse thinking method. My solution has 3 steps:\\n1. DFS the border the board, change non-surrounded regions from ```\\'O\\'``` to ```\\'T\\'```. After doing this step, the remaining ```\\'O\\'``` are all surrounded by ```\\'X\\'```. Noticed that we only need to DFS the border not the entire board. However, to make the code simple, I DFS entire board in my solution.\\n2. DFS the board, change all ```\\'O\\'``` to ```\\'X\\'``` as explained in step 1.\\n3. Now we have finished flipping all surrounded regions to ```\\'X\\'```. But we want to keep non-surrounded regions to ```\\'O\\'``` instead of ```\\'T\\'```. Last step is to change all ```\\'T\\'``` back to ```\\'O\\'```.\\n\\n```\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        m, n = len(board), len(board[0])\\n        \\n        # DFS the board to change all non-surrounded regions \\'O\\' -> \\'T\\'\\n        def dfs(r, c):\\n            if r < 0 or r == m or c < 0 or c == n or board[r][c] != \\'O\\':\\n                return\\n            board[r][c] = \\'T\\'\\n            dfs(r - 1, c)\\n            dfs(r + 1, c)\\n            dfs(r, c - 1)\\n            dfs(r, c + 1)\\n            \\n        # step 1    \\n        for r in range(m):\\n            for c in range(n):\\n                if board[r][c] == \\'O\\' and (r in [0, m-1] or c in [0, n-1]):\\n                    dfs(r, c)\\n        \\n        # step 2                 \\n        for r in range(m):\\n            for c in range(n):\\n                if board[r][c] == \\'O\\':\\n                    board[r][c] = \\'X\\'\\n        \\n        # step 3 \\n        for r in range(m):\\n            for c in range(n):\\n                if board[r][c] == \\'T\\':\\n                    board[r][c] = \\'O\\'\\n```\\nFeel free to ask if you have any questions!",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\'O\\'```\n```\\'T\\'```\n```\\'O\\'```\n```\\'X\\'```\n```\\'O\\'```\n```\\'X\\'```\n```\\'X\\'```\n```\\'O\\'```\n```\\'T\\'```\n```\\'T\\'```\n```\\'O\\'```\n```\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        m, n = len(board), len(board[0])\\n        \\n        # DFS the board to change all non-surrounded regions \\'O\\' -> \\'T\\'\\n        def dfs(r, c):\\n            if r < 0 or r == m or c < 0 or c == n or board[r][c] != \\'O\\':\\n                return\\n            board[r][c] = \\'T\\'\\n            dfs(r - 1, c)\\n            dfs(r + 1, c)\\n            dfs(r, c - 1)\\n            dfs(r, c + 1)\\n            \\n        # step 1    \\n        for r in range(m):\\n            for c in range(n):\\n                if board[r][c] == \\'O\\' and (r in [0, m-1] or c in [0, n-1]):\\n                    dfs(r, c)\\n        \\n        # step 2                 \\n        for r in range(m):\\n            for c in range(n):\\n                if board[r][c] == \\'O\\':\\n                    board[r][c] = \\'X\\'\\n        \\n        # step 3 \\n        for r in range(m):\\n            for c in range(n):\\n                if board[r][c] == \\'T\\':\\n                    board[r][c] = \\'O\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1833338,
                "title": "java-dfs-simple-and-clean-code",
                "content": "```\\nclass Solution {\\n    public void solve(char[][] board) {\\n        int n = board.length;\\n        int m = board[0].length;\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                //any \\'O\\' connected to the boundary can\\'t be turned into \\'X\\'\\n                //so we run dfs only for those cells and change \\'O\\' to \\'a\\' (just for marking visited you can use any char)\\n                if((i == 0 || j == 0 || i == n-1 || j == m - 1) && board[i][j] == \\'O\\'){\\n                    dfs(board, i, j);\\n                }\\n            }\\n        }\\n        //turning \\'O\\' to \\'X\\', \\'a\\' back to \\'O\\', keep \\'X\\' intact.\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                if(board[i][j] == \\'O\\'){\\n                    board[i][j] = \\'X\\';\\n                }else if(board[i][j] == \\'a\\'){\\n                    board[i][j] = \\'O\\';\\n                }\\n            }\\n        }\\n    }\\n    public void dfs(char[][] board, int i, int j){\\n        if(i < 0 || j < 0 || i >= board.length || j >= board[0].length || board[i][j] == \\'X\\' || board[i][j] == \\'a\\'){\\n            return;\\n        }\\n        if(board[i][j] == \\'O\\') {\\n            //marking this cell as visited\\n            board[i][j] = \\'a\\';\\n        }\\n        dfs(board, i + 1 , j);        \\n        dfs(board, i - 1 , j);\\n        dfs(board, i  , j + 1);\\n        dfs(board, i , j - 1);\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public void solve(char[][] board) {\\n        int n = board.length;\\n        int m = board[0].length;\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                //any \\'O\\' connected to the boundary can\\'t be turned into \\'X\\'\\n                //so we run dfs only for those cells and change \\'O\\' to \\'a\\' (just for marking visited you can use any char)\\n                if((i == 0 || j == 0 || i == n-1 || j == m - 1) && board[i][j] == \\'O\\'){\\n                    dfs(board, i, j);\\n                }\\n            }\\n        }\\n        //turning \\'O\\' to \\'X\\', \\'a\\' back to \\'O\\', keep \\'X\\' intact.\\n        for(int i = 0 ; i < n ; i++){\\n            for(int j = 0 ; j < m ; j++){\\n                if(board[i][j] == \\'O\\'){\\n                    board[i][j] = \\'X\\';\\n                }else if(board[i][j] == \\'a\\'){\\n                    board[i][j] = \\'O\\';\\n                }\\n            }\\n        }\\n    }\\n    public void dfs(char[][] board, int i, int j){\\n        if(i < 0 || j < 0 || i >= board.length || j >= board[0].length || board[i][j] == \\'X\\' || board[i][j] == \\'a\\'){\\n            return;\\n        }\\n        if(board[i][j] == \\'O\\') {\\n            //marking this cell as visited\\n            board[i][j] = \\'a\\';\\n        }\\n        dfs(board, i + 1 , j);        \\n        dfs(board, i - 1 , j);\\n        dfs(board, i  , j + 1);\\n        dfs(board, i , j - 1);\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1769534,
                "title": "java-clean-code-dfs-traversal",
                "content": "I found the explanation given by Leetcode staff quite intuitive, but the code was a little tricky to follow. \\n\\nThe algorithm remains the same. \\n* Traverse all the \\'Os\\' on the border. For every \\'O\\' that is either on the border, or can reach the border, mark it as temp \\'T\\'.\\n* Thus, any \\'O\\' that can be reached from the border is now \\'T\\'. Any remaining \\'O\\' is unreachable from the border so turn it into \\'X\\'. Turn back \\'T\\' into \\'O\\'.\\n\\n```\\nclass Solution {\\n    char[][] board;\\n\\tint row, col;\\n\\t    \\n    public void solve(char[][] board) {\\n        if (board == null || board.length == 0) return;\\n        \\n        row = board.length;\\n        col = board[0].length;\\n        this.board = board;\\n       \\n        // traverse top to bottom\\n        for (int i = 0; i < row; i++) {\\n\\t\\t\\t// top to bottom traversal first column\\n            if (board[i][0] == \\'O\\') dfs(i, 0);\\n\\t\\t\\t\\n\\t\\t\\t// top to bottom traversal last column\\n            if (board[i][col - 1] == \\'O\\') dfs(i, col - 1);\\n        }\\n        \\n\\t\\t// traverse left to right\\n        for (int j = 0; j < col; j++) {\\n\\t\\t\\t// left to right traversal top row\\n            if (board[0][j] == \\'O\\') dfs(0, j);\\n\\t\\t\\t\\n\\t\\t\\t// left to right traversal bottom row\\n            if (board[row - 1][j] == \\'O\\') dfs(row - 1, j);\\n        }\\n        \\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n\\t\\t\\t\\t// turn every unreachable \\'O\\' from border into \\'X\\'\\n                if (board[i][j] == \\'O\\') board[i][j] = \\'X\\';\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// turn every reachable \\'O\\' marked as \\'T\\' back to \\'O\\' \\n                if (board[i][j] == \\'T\\') board[i][j] = \\'O\\';\\n            }\\n        }\\n    }\\n    \\n    \\n    private void dfs(int currRow, int currCol) {\\n        if (currRow < 0 || currRow >= row || currCol < 0 || currCol >= col) return;\\n\\t\\t\\n\\t\\t// if an element is \\'X\\' or already marked as \\'T\\' skip ahead\\n        if (board[currRow][currCol] == \\'X\\' || board[currRow][currCol] == \\'T\\') return;\\n        \\n        // if an element \\'O\\' can be traversed from border, mark it as temp \\'T\\'\\n        board[currRow][currCol] = \\'T\\';\\n        \\n        // move in all four directions\\n        dfs(currRow + 1, currCol);\\n        dfs(currRow - 1, currCol);\\n        dfs(currRow, currCol + 1);\\n        dfs(currRow, currCol - 1);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    char[][] board;\\n\\tint row, col;\\n\\t    \\n    public void solve(char[][] board) {\\n        if (board == null || board.length == 0) return;\\n        \\n        row = board.length;\\n        col = board[0].length;\\n        this.board = board;\\n       \\n        // traverse top to bottom\\n        for (int i = 0; i < row; i++) {\\n\\t\\t\\t// top to bottom traversal first column\\n            if (board[i][0] == \\'O\\') dfs(i, 0);\\n\\t\\t\\t\\n\\t\\t\\t// top to bottom traversal last column\\n            if (board[i][col - 1] == \\'O\\') dfs(i, col - 1);\\n        }\\n        \\n\\t\\t// traverse left to right\\n        for (int j = 0; j < col; j++) {\\n\\t\\t\\t// left to right traversal top row\\n            if (board[0][j] == \\'O\\') dfs(0, j);\\n\\t\\t\\t\\n\\t\\t\\t// left to right traversal bottom row\\n            if (board[row - 1][j] == \\'O\\') dfs(row - 1, j);\\n        }\\n        \\n        for (int i = 0; i < row; i++) {\\n            for (int j = 0; j < col; j++) {\\n\\t\\t\\t\\t// turn every unreachable \\'O\\' from border into \\'X\\'\\n                if (board[i][j] == \\'O\\') board[i][j] = \\'X\\';\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// turn every reachable \\'O\\' marked as \\'T\\' back to \\'O\\' \\n                if (board[i][j] == \\'T\\') board[i][j] = \\'O\\';\\n            }\\n        }\\n    }\\n    \\n    \\n    private void dfs(int currRow, int currCol) {\\n        if (currRow < 0 || currRow >= row || currCol < 0 || currCol >= col) return;\\n\\t\\t\\n\\t\\t// if an element is \\'X\\' or already marked as \\'T\\' skip ahead\\n        if (board[currRow][currCol] == \\'X\\' || board[currRow][currCol] == \\'T\\') return;\\n        \\n        // if an element \\'O\\' can be traversed from border, mark it as temp \\'T\\'\\n        board[currRow][currCol] = \\'T\\';\\n        \\n        // move in all four directions\\n        dfs(currRow + 1, currCol);\\n        dfs(currRow - 1, currCol);\\n        dfs(currRow, currCol + 1);\\n        dfs(currRow, currCol - 1);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1764075,
                "title": "python-union-find",
                "content": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.root = list(range(n))\\n        self.rank = [0]*n\\n    \\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x, y):\\n        rx, ry = self.find(x), self.find(y)\\n        \\n        if rx == ry:\\n            return False\\n        \\n        if self.rank[rx] == self.rank[ry]:\\n            self.rank[ry] += 1\\n        \\n        if self.rank[rx]  < self.rank[ry]:\\n            self.root[rx] = ry\\n        else:\\n            self.root[ry] = rx\\n        \\n        return True\\n\\n        \\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        \\n        #use union find to group the Os\\n        #the Os on the edge has higher rank\\n        #in the end, check each O cell, if the root of the cell is not in the edge, flip to x\\n        \\n        m, n = len(board), len(board[0])\\n        dsu = DSU(m*n)\\n        edges = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if i == 0 or i == m - 1 or j == 0 or j == n - 1:\\n                    dsu.rank[n*i + j] = float(\"inf\")\\n                    edges.add(n*i + j)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == \"X\": continue\\n                for ni, nj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\\n                    if 0 <= ni < m and 0 <= nj < n and board[ni][nj] == \"O\":\\n                        dsu.union(n*i + j, n*ni + nj)\\n        \\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if dsu.find(n*i + j) not in edges:\\n                    board[i][j] = \"X\"\\n        \\n        return board\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass DSU:\\n    def __init__(self, n):\\n        self.root = list(range(n))\\n        self.rank = [0]*n\\n    \\n    def find(self, x):\\n        if self.root[x] != x:\\n            self.root[x] = self.find(self.root[x])\\n        return self.root[x]\\n    \\n    def union(self, x, y):\\n        rx, ry = self.find(x), self.find(y)\\n        \\n        if rx == ry:\\n            return False\\n        \\n        if self.rank[rx] == self.rank[ry]:\\n            self.rank[ry] += 1\\n        \\n        if self.rank[rx]  < self.rank[ry]:\\n            self.root[rx] = ry\\n        else:\\n            self.root[ry] = rx\\n        \\n        return True\\n\\n        \\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        \\n        #use union find to group the Os\\n        #the Os on the edge has higher rank\\n        #in the end, check each O cell, if the root of the cell is not in the edge, flip to x\\n        \\n        m, n = len(board), len(board[0])\\n        dsu = DSU(m*n)\\n        edges = set()\\n        for i in range(m):\\n            for j in range(n):\\n                if i == 0 or i == m - 1 or j == 0 or j == n - 1:\\n                    dsu.rank[n*i + j] = float(\"inf\")\\n                    edges.add(n*i + j)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j] == \"X\": continue\\n                for ni, nj in [(i + 1, j), (i - 1, j), (i, j + 1), (i, j - 1)]:\\n                    if 0 <= ni < m and 0 <= nj < n and board[ni][nj] == \"O\":\\n                        dsu.union(n*i + j, n*ni + nj)\\n        \\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if dsu.find(n*i + j) not in edges:\\n                    board[i][j] = \"X\"\\n        \\n        return board\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1665034,
                "title": "c-dfs-simple-approach",
                "content": "```\\n//Main idea is that Convert non-flipable \\'O\\' into another character by using DFS.So, We can easily convert flipable \\'O\\' into \\'X\\' by simple iteration.\\nclass Solution {\\npublic:\\n    void dfs(vector<vector<char>>& board,int i,int j,int m,int n)\\n    {\\n        if(i<0 || i>= m || j<0 || j>=n || board[i][j] != \\'O\\') return;\\n        board[i][j] = \\'$\\';\\n        dfs(board,i-1,j,m,n);\\n        dfs(board,i+1,j,m,n);\\n        dfs(board,i,j-1,m,n);\\n        dfs(board,i,j+1,m,n);\\n    }\\n    \\n    void solve(vector<vector<char>>& board) \\n    {\\n        int m = board.size(),n = board[0].size();\\n        //First row and last row\\n        for(int i =0;i<n;i++)\\n        {\\n            if(board[0][i]==\\'O\\') dfs(board,0,i,m,n);\\n            if(board[m-1][i]==\\'O\\')  dfs(board,m-1,i,m,n); \\n        }\\n        \\n        //First column and last column\\n        for(int i =0;i<m;i++)\\n        {\\n            if(board[i][0]==\\'O\\') dfs(board,i,0,m,n);\\n            if(board[i][n-1]==\\'O\\') dfs(board,i,n-1,m,n);\\n        }\\n        \\n        for(int i =0;i<m;i++)\\n        {\\n            for(int j =0;j<n;j++)\\n            {\\n                if(board[i][j] == \\'O\\') board[i][j] = \\'X\\';\\n                else if(board[i][j]==\\'$\\') board[i][j] = \\'O\\';\\n            }\\n        }\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    void dfs(vector<vector<char>>& board,int i,int j,int m,int n)\\n    {\\n        if(i<0 || i>= m || j<0 || j>=n || board[i][j] != \\'O\\') return;\\n        board[i][j] = \\'$\\';\\n        dfs(board,i-1,j,m,n);\\n        dfs(board,i+1,j,m,n);\\n        dfs(board,i,j-1,m,n);\\n        dfs(board,i,j+1,m,n);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1559634,
                "title": "java-concise-dfs-pictures",
                "content": "**Approach**\\n1. Iterate through the borders of the matrix that are marked as O\\n2. Take vertices from previous step and DFS across all neighbors marking O\\'s with A\\'s\\n3. Iterate through the entire matrix converting A\\'s to O\\'s and O\\'s to X\\'s.\\n\\n**Initial State**\\n* The red background is a signal for O\\'s connected to the border. The blue background is for O\\'s not connected to the border.\\n\\n![image](https://assets.leetcode.com/users/images/aefc6c1c-50d9-4e02-99dc-d2422facf8ac_1636053458.1714075.png)\\n\\n\\n**Intermediate State**\\n* Mark all O\\'s connected to the border as A\\'s\\n![image](https://assets.leetcode.com/users/images/fd02d5ee-2a41-4d5e-8968-fbcdf27f5aec_1636051961.0175774.png)\\n\\n**Final State**\\n* Convert O\\'s to X\\'s and A\\'s to O\\'s\\n![image](https://assets.leetcode.com/users/images/fcd6b201-859d-4f7c-b075-b52e8b7e3d26_1636051821.9669514.png)\\n\\n\\n**Code**\\n```\\npublic void solve(char[][] board) {\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                // is a border coordinate\\n                if ((i == 0 || i == board.length - 1 || j == 0 || j == board[0].length - 1) && board[i][j] == \\'O\\') {\\n                    dfs(i, j, board);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (board[i][j] == \\'O\\') {\\n                    board[i][j] = \\'X\\';\\n                } else if (board[i][j] == \\'A\\') {\\n                    board[i][j] = \\'O\\';\\n                }\\n            }\\n        }\\n    }\\n\\n    void dfs(int i, int j, char[][] board) {\\n        board[i][j] = \\'A\\';\\n        int[][] moves = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        for (int[] move : moves) {\\n            int newI = i + move[0];\\n            int newJ = j + move[1];\\n            // is within bounds + equal to O\\n            if (newI >= 0 && newI < board.length && newJ >= 0 && newJ < board[0].length && board[newI][newJ] == \\'O\\') {\\n                dfs(newI, newJ, board);\\n            }\\n        }\\n    }\\n```\\n\\n**Time + Space**\\nN - # of rows\\nM - # of columns\\n\\nTime Complexity: O(2(N * M)) ~ O (N * M), we are traversing the grid two times.\\nSpace Complexity: O(N * M). The recursive stack in our DFS can grow to this size if the board is all O\\'s.\\n\\n**Please upvote if you found this useful! Happy to answer any questions, thanks!**",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\npublic void solve(char[][] board) {\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                // is a border coordinate\\n                if ((i == 0 || i == board.length - 1 || j == 0 || j == board[0].length - 1) && board[i][j] == \\'O\\') {\\n                    dfs(i, j, board);\\n                }\\n            }\\n        }\\n\\n        for (int i = 0; i < board.length; i++) {\\n            for (int j = 0; j < board[0].length; j++) {\\n                if (board[i][j] == \\'O\\') {\\n                    board[i][j] = \\'X\\';\\n                } else if (board[i][j] == \\'A\\') {\\n                    board[i][j] = \\'O\\';\\n                }\\n            }\\n        }\\n    }\\n\\n    void dfs(int i, int j, char[][] board) {\\n        board[i][j] = \\'A\\';\\n        int[][] moves = new int[][]{{0, 1}, {0, -1}, {1, 0}, {-1, 0}};\\n        for (int[] move : moves) {\\n            int newI = i + move[0];\\n            int newJ = j + move[1];\\n            // is within bounds + equal to O\\n            if (newI >= 0 && newI < board.length && newJ >= 0 && newJ < board[0].length && board[newI][newJ] == \\'O\\') {\\n                dfs(newI, newJ, board);\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1553272,
                "title": "explanation-using-pictures-dfs-python",
                "content": "# **Problem Description**\\nIn this problem: \\n- You have to change all the clusters of `\\'O\\' to \\'X\\'` if they are not connected to the border of the board. \\n- Else they will remain as it is.\\n![image](https://assets.leetcode.com/users/images/8bb05489-263d-48b6-87af-5a25ef2d162e_1635783990.2290413.jpeg)\\n\\n---\\n\\n# **Approach**\\n**Step - 1:** Mark all the clusters on the board with `\\'O\\'` connected to the border by traversing using `Depth First Search (or Breadth First Search)`. Let\\'s mark them using `\\'V\\'`. \\n**Step - 2:** Change all the cells marked with `\\'V\\' to \\'O\\'` and everything else to `\\'X\\'`.\\n\\n---\\n\\n# **Implementation**\\n**Step - 1:** Perform the traversal of the board along the border on the first and the last row. If any cell is found with value `\\'O\\'` perform the Depth First Traversal and mark all the cells connected to it to `\\'V\\'`.\\n![image](https://assets.leetcode.com/users/images/456edc26-a925-4ca2-ae5a-60aa7a2bcf18_1635785021.3837135.gif)\\n\\n\\n**Step - 2:** Similarly to the Step 1, Perform the traversal of the board along the border on the first and the last column. If any cell is found with value `\\'O\\' `perform the Depth First Traversal and mark all the cells connected to it to `\\'V\\'`.\\n![image](https://assets.leetcode.com/users/images/2af0c7af-90b6-4850-ad3b-601d96c121e0_1635785031.2194002.gif)\\n\\n\\n**Step - 3:** Now, change all the cells marked with `\\'V\\' to \\'O\\'` and everything else to `\\'X\\'`.\\n![image](https://assets.leetcode.com/users/images/1555d00c-9c43-400e-9b46-0cc8164248ce_1635785040.2284353.gif)\\n\\n\\n---\\n\\n# **Code**\\n```\\nclass Solution:\\n    \\n    def depth_first_search(self, board, row, col):\\n        \\n        if row < 0 or row >= len(board) or col < 0 or col >= len(board[0]) or board[row][col] in \\'XV\\':\\n            return \\n        \\n        board[row][col] = \\'V\\'\\n        moves = [(1,0),(-1,0),(0,1),(0,-1)]\\n        for dr,dc in moves:\\n            self.depth_first_search(board, row + dr, col + dc)\\n    \\n    \\n    def solve(self, board: List[List[str]]) -> None:\\n\\n        rows_num,cols_num = len(board), len(board[0])\\n        \\n        # Traversing Grid along the 0th and (n-1)th row\\n        for col in range(cols_num):\\n            # 0th row\\n            if board[0][col] == \\'O\\':\\n                self.depth_first_search(board, 0, col)\\n            # (rows_num-1)th row\\n            if board[rows_num-1][col] == \\'O\\':\\n                self.depth_first_search(board, rows_num-1, col)\\n        \\n        # Traversing Grid along the 0th and (m-1)th column\\n        for row in range(rows_num):\\n            # 0th column\\n            if board[row][0] == \\'O\\':\\n                self.depth_first_search(board, row, 0)\\n            # (m-1)th column\\n            if board[row][cols_num-1] == \\'O\\':\\n                self.depth_first_search(board, row, cols_num-1)\\n                \\n        # post-processing board        \\n        for row in range(rows_num):\\n            for col in range(cols_num):\\n                if board[row][col] == \\'V\\':\\n                    board[row][col] = \\'O\\'\\n                elif board[row][col] == \\'O\\':\\n                    board[row][col] = \\'X\\'\\n                    \\n        \\n```\\n\\n---\\n\\n# **Complexity Analysis**\\n**Time Complexity:** `O(N*M)` where `N` is the number of rows and `M` is the number of columns.\\n**Space Complexity:** `O(N*M)` : This space is used by the board. Exactly this much space is used by the stack that will be used in the `recursion of the Depth First Search`.\\n\\n---",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    \\n    def depth_first_search(self, board, row, col):\\n        \\n        if row < 0 or row >= len(board) or col < 0 or col >= len(board[0]) or board[row][col] in \\'XV\\':\\n            return \\n        \\n        board[row][col] = \\'V\\'\\n        moves = [(1,0),(-1,0),(0,1),(0,-1)]\\n        for dr,dc in moves:\\n            self.depth_first_search(board, row + dr, col + dc)\\n    \\n    \\n    def solve(self, board: List[List[str]]) -> None:\\n\\n        rows_num,cols_num = len(board), len(board[0])\\n        \\n        # Traversing Grid along the 0th and (n-1)th row\\n        for col in range(cols_num):\\n            # 0th row\\n            if board[0][col] == \\'O\\':\\n                self.depth_first_search(board, 0, col)\\n            # (rows_num-1)th row\\n            if board[rows_num-1][col] == \\'O\\':\\n                self.depth_first_search(board, rows_num-1, col)\\n        \\n        # Traversing Grid along the 0th and (m-1)th column\\n        for row in range(rows_num):\\n            # 0th column\\n            if board[row][0] == \\'O\\':\\n                self.depth_first_search(board, row, 0)\\n            # (m-1)th column\\n            if board[row][cols_num-1] == \\'O\\':\\n                self.depth_first_search(board, row, cols_num-1)\\n                \\n        # post-processing board        \\n        for row in range(rows_num):\\n            for col in range(cols_num):\\n                if board[row][col] == \\'V\\':\\n                    board[row][col] = \\'O\\'\\n                elif board[row][col] == \\'O\\':\\n                    board[row][col] = \\'X\\'\\n                    \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1552246,
                "title": "dfs-simple-easy-to-understand-with-comments-c-best-explanation",
                "content": "Public:\\n//DFS call for check next \\'0\\' cell in all the 4-directions.\\n   void dfs(vector<vector<char>>& grid, int i, int j)\\n{\\n// If grid[i][j]==\\'0\\' ,  mark this cell as \\'1\\' which is mean REACHED & make DFS call for upper.lower ,to the left and to the right of current cordinate (i,j). \\n    if(grid[i][j] == \\'O\\'){\\n        \\n        grid[i][j] = \\'1\\';\\n\\n        if(i+1 < grid.size()) dfs(grid, i+1, j);\\n        if(i > 1) dfs(grid, i-1, j);\\n        if(j+1 < grid[i].size()) dfs(grid, i, j+1);\\n        if(j > 1) dfs(grid, i, j-1);\\n    }\\n}\\n\\n    void solve(vector<vector<char>>& grid) {\\n       if(grid.empty())//edgecase->if grid is empty so just simply return\\n            return;\\n     \\n          //number of row in matrix\\n        int row = grid.size();\\n        //number of column in matrix\\n        int col = grid[0].size();\\n        \\n//If grid have less than 3 size in any direction: nothing to do, because all cells located on borders this is also a edge case.\\n     if(row<3 || col<3) return ;\\n        \\n        //check for first row and last row\\n        for(int i=0; i<row; i++){\\n            dfs(grid, i, 0);\\n            dfs(grid, i, col-1);\\n        }\\n        //Same as above check for first col and last col\\n    // Since first & last row already checked in previous cycle, skip them here\\n        for(int j=1; j<col-1; j++){\\n            dfs(grid, 0, j);\\n            dfs(grid, row-1, j);\\n        }\\n//Go through the whole grid and flip all \\'1\\' back into \\'O\\' and all \\'O\\'cell to\\'X\\'\\n// since they\\'re unreacheable from the board located \\'O\\' cell if any\\n        for (int i = 0; i < row; ++i)\\n            for (int j = 0; j < col; ++j)\\n                if (grid[i][j] == \\'O\\') grid[i][j] = \\'X\\';\\n                else if (grid[i][j] == \\'1\\') grid[i][j] = \\'O\\';\\n    }\\n\\t\\n****Please Like and Upvote this solution .\\n",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "Public:\\n//DFS call for check next \\'0\\' cell in all the 4-directions.\\n   void dfs(vector<vector<char>>& grid, int i, int j)\\n{\\n// If grid[i][j]==\\'0\\' ,  mark this cell as \\'1\\' which is mean REACHED & make DFS call for upper.lower ,to the left and to the right of current cordinate (i,j). \\n    if(grid[i][j] == \\'O\\'){\\n        \\n        grid[i][j] = \\'1\\';\\n\\n        if(i+1 < grid.size()) dfs(grid, i+1, j);\\n        if(i > 1) dfs(grid, i-1, j);\\n        if(j+1 < grid[i].size()) dfs(grid, i, j+1);\\n        if(j > 1) dfs(grid, i, j-1);\\n    }\\n}\\n\\n    void solve(vector<vector<char>>& grid) {\\n       if(grid.empty())//edgecase->if grid is empty so just simply return\\n            return;\\n     \\n          //number of row in matrix\\n        int row = grid.size();\\n        //number of column in matrix\\n        int col = grid[0].size();\\n        \\n//If grid have less than 3 size in any direction: nothing to do, because all cells located on borders this is also a edge case.\\n     if(row<3 || col<3) return ;\\n        \\n        //check for first row and last row\\n        for(int i=0; i<row; i++){\\n            dfs(grid, i, 0);\\n            dfs(grid, i, col-1);\\n        }\\n        //Same as above check for first col and last col\\n    // Since first & last row already checked in previous cycle, skip them here\\n        for(int j=1; j<col-1; j++){\\n            dfs(grid, 0, j);\\n            dfs(grid, row-1, j);\\n        }\\n//Go through the whole grid and flip all \\'1\\' back into \\'O\\' and all \\'O\\'cell to\\'X\\'\\n// since they\\'re unreacheable from the board located \\'O\\' cell if any\\n        for (int i = 0; i < row; ++i)\\n            for (int j = 0; j < col; ++j)\\n                if (grid[i][j] == \\'O\\') grid[i][j] = \\'X\\';\\n                else if (grid[i][j] == \\'1\\') grid[i][j] = \\'O\\';\\n    }\\n\\t\\n****Please Like and Upvote this solution .\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 1551995,
                "title": "python-dfs-bfs-produce-different-results-explained",
                "content": "### Introduction\\n\\nWe want to find all regions of \\'O\\'s that are surrounded completely by \\'X\\'s, and \\'capture\\' these regions (i.e. modify \\'O\\' to \\'X\\'), performing all of these operations in-place.\\n\\nThe key observations we need to make are as follows:\\n\\n- Every \\'O\\' on the border of the `board` will never be captured. This is because the \\'O\\'s cannot be completely surrounded by \\'X\\'s at the `board`\\'s edge.\\n- Every \\'O\\' connected to another \\'O\\' that is on the border of the board is considered to be of the same region as the border \\'O\\', and thus cannot be captured either.\\n\\nThus, we need to find **all \\'O\\'s that are neither on the border nor connected to an \\'O\\' on the border, and modify all of them to \\'X\\'s**.\\n\\n---\\n\\n### Approach 1: DFS\\n\\nThe idea is that, given an \\'O\\' coordinate, we can DFS the adjacent cells to find more \\'O\\'s that are connected and hence part of the same region. If we pass the function a coordinate that is on the border, we can be sure that every \\'O\\' coordinate that the function finds is not captured as well.\\n\\n```python\\ndef dfs(i: int, j: int) -> None:\\n\\t\"\"\"\\n\\tDFS to find all \\'O\\'s connected to the border. These \\'O\\'s will not be captured.\\n\\t:param i: index of row (where top = 0) of \\'O\\' coordinate.\\n\\t:param j: index of column (where left = 0) of \\'O\\' coordinate.\\n\\t\"\"\"\\n\\tfor x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):  # search the 4 adjacent coordinates\\n\\t\\tif 0 <= x < len(board) and 0 <= y < len(board[0]) and board[x][y] == \\'O\\':\\n\\t\\t\\t# found non-captured \\'O\\', do something\\n\\t\\t\\tdfs(x, y)\\n```\\n\\nThis approach seems highly favourable since we can just modify the coordinates found to be some other character temporarily, to denote that the coordinate is non-capturable. In this manner, we can theoretically utilise O(1) auxiliary space, since we don\\'t require any data structures to store our found coordinates.\\n\\n```python\\n# Solution 1: Pure DFS Implementation\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        m, n = len(board), len(board[0])\\n        \\n        def dfs(i: int, j: int) -> None:\\n            \"\"\"\\n            DFS to find all \\'O\\'s connected to the border. These \\'O\\'s will not be captured.\\n            :param i: index of row (where top = 0) of \\'O\\' coordinate.\\n            :param j: index of column (where left = 0) of \\'O\\' coordinate.\\n            :returns: nothing; modifies \\'O\\' coordinates found to \\'S\\' (seen).\\n            \"\"\"\\n            board[i][j] = \\'S\\'\\n            for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\\n                if 0 <= x < m and 0 <= y < n and board[x][y] == \\'O\\':\\n                    dfs(x, y)\\n        \\n        # get all \\'O\\'s from the border, and find \\'O\\'s connected to them\\n        for i in range(n):\\n            if board[0][i] == \\'O\\':  # top row\\n                dfs(0, i)\\n            if m > 1 and board[m-1][i] == \\'O\\':  # bottom row\\n                dfs(m-1, i)\\n        for i in range(1, m-1):\\n            if board[i][0] == \\'O\\':  # left column\\n                dfs(i, 0)\\n            if n > 1 and board[i][n-1] == \\'O\\':  # right column\\n                dfs(i, n-1)\\n        \\n        # one-pass to capture \\'O\\'s to \\'X\\'s and \\'S\\'s to \\'O\\'s\\n        for i in range(m):\\n            for j in range(n):\\n                board[i][j] = \\'X\\' if board[i][j] == \\'O\\' else \\'O\\' if board[i][j] == \\'S\\' else board[i][j]\\n```\\n\\n![image](https://assets.leetcode.com/users/images/fb994ade-131c-4b90-ac55-efc2e379b289_1635736059.9038856.png)\\n\\nHowever, the memory usage is still quite high. This is because the recursive function calls will also generate spatial overhead, hence the memory usage of the function calls will scale as the number of connected \\'O\\'s increase.\\n\\n```\\nVisualisation:\\n\\nO X X\\nO O X  --> dfs(0, 0) --|--> dfs(-1, 0) --> resolved\\nX X X                  |--> dfs(0, -1) --> resolved\\n                       |--> dfs(0, 1) ---> resolved\\n\\t\\t\\t\\t\\t   ---> dfs(1, 0) ---------------|--> dfs(0, 0)\\n\\nassume dfs() spatial overhead: x B\\ntotal spatial overhead incurred by DFS: 4x B (recursion is 3+1=4 layers deep)\\n\\nO O O O O\\nO O O O O\\nO O O O O  --> dfs(0, 0) --> dfs(0, 1) --> dfs(0, 2) -->dfs(0, 3) --> ...\\nO O O O O\\nO O O O O\\n\\ntotal spatial overhead incurred by DFS: 26x B (recursion is 25+1=26 layers deep)\\n```\\n\\n---\\n\\n### Approach 2: BFS\\n\\nThe idea is the same, except for BFS, we need to store the coordinates that require checking at the current iteration. While this theoretically does use O(n) auxiliary space, we can discard coordinates that have already been checked before (by marking them with \\'S\\') and maintain a data structure that only contains the most relevant information, instead of incurring spatial overhead for coordinates we might not even need as per DFS approach.\\n\\n```python\\n# Solution 2: Pure BFS Implementation\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        m, n, curr = len(board), len(board[0]), deque()\\n       \\n        # get all \\'O\\'s from the border\\n        for i in range(n):\\n            if board[0][i] == \\'O\\':  # top row\\n                curr.append((0, i))\\n            if m > 1 and board[m-1][i] == \\'O\\':  # bottom row\\n                curr.append((m-1, i))\\n        for i in range(1, m-1):\\n            if board[i][0] == \\'O\\':  # left column\\n                curr.append((i, 0))\\n            if n > 1 and board[i][n-1] == \\'O\\':  # right column\\n                curr.append((i, n-1))\\n        \\n        # loop through BFS-style to find adjacent \\'O\\'s\\n        while curr:\\n            i, j = curr.popleft()\\n            board[i][j] = \\'S\\'  # mark as seen, or non-capturable\\n            for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\\n                if 0 <= x < m and 0 <= y < n and board[x][y] == \\'O\\':\\n                    curr.append((x, y))\\n        \\n        # one-pass to capture \\'O\\'s to \\'X\\'s and \\'S\\'s to \\'O\\'s\\n        for i in range(m):\\n            for j in range(n):\\n                board[i][j] = \\'X\\' if board[i][j] == \\'O\\' else \\'O\\' if board[i][j] == \\'S\\' else board[i][j]\\n```\\n\\n![image](https://assets.leetcode.com/users/images/a32aa34c-3a29-4f44-bc19-687d6088c9a4_1635737707.4848204.png)\\n\\nAs expected, minimising unnecessary spatial overhead gave us a significant memory usage boost, even if we were using O(n) auxiliary space in theory.\\n\\n---\\n\\n### Conclusion\\n\\nFor this problem, it seems like DFS and BFS give significantly different results. Feel free to try these solutions out and compare the difference for yourself!\\n\\nPlease upvote if this has helped you! Appreciate any comments as well :)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```python\\ndef dfs(i: int, j: int) -> None:\\n\\t\"\"\"\\n\\tDFS to find all \\'O\\'s connected to the border. These \\'O\\'s will not be captured.\\n\\t:param i: index of row (where top = 0) of \\'O\\' coordinate.\\n\\t:param j: index of column (where left = 0) of \\'O\\' coordinate.\\n\\t\"\"\"\\n\\tfor x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):  # search the 4 adjacent coordinates\\n\\t\\tif 0 <= x < len(board) and 0 <= y < len(board[0]) and board[x][y] == \\'O\\':\\n\\t\\t\\t# found non-captured \\'O\\', do something\\n\\t\\t\\tdfs(x, y)\\n```\n```python\\n# Solution 1: Pure DFS Implementation\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        m, n = len(board), len(board[0])\\n        \\n        def dfs(i: int, j: int) -> None:\\n            \"\"\"\\n            DFS to find all \\'O\\'s connected to the border. These \\'O\\'s will not be captured.\\n            :param i: index of row (where top = 0) of \\'O\\' coordinate.\\n            :param j: index of column (where left = 0) of \\'O\\' coordinate.\\n            :returns: nothing; modifies \\'O\\' coordinates found to \\'S\\' (seen).\\n            \"\"\"\\n            board[i][j] = \\'S\\'\\n            for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\\n                if 0 <= x < m and 0 <= y < n and board[x][y] == \\'O\\':\\n                    dfs(x, y)\\n        \\n        # get all \\'O\\'s from the border, and find \\'O\\'s connected to them\\n        for i in range(n):\\n            if board[0][i] == \\'O\\':  # top row\\n                dfs(0, i)\\n            if m > 1 and board[m-1][i] == \\'O\\':  # bottom row\\n                dfs(m-1, i)\\n        for i in range(1, m-1):\\n            if board[i][0] == \\'O\\':  # left column\\n                dfs(i, 0)\\n            if n > 1 and board[i][n-1] == \\'O\\':  # right column\\n                dfs(i, n-1)\\n        \\n        # one-pass to capture \\'O\\'s to \\'X\\'s and \\'S\\'s to \\'O\\'s\\n        for i in range(m):\\n            for j in range(n):\\n                board[i][j] = \\'X\\' if board[i][j] == \\'O\\' else \\'O\\' if board[i][j] == \\'S\\' else board[i][j]\\n```\n```\\nVisualisation:\\n\\nO X X\\nO O X  --> dfs(0, 0) --|--> dfs(-1, 0) --> resolved\\nX X X                  |--> dfs(0, -1) --> resolved\\n                       |--> dfs(0, 1) ---> resolved\\n\\t\\t\\t\\t\\t   ---> dfs(1, 0) ---------------|--> dfs(0, 0)\\n\\nassume dfs() spatial overhead: x B\\ntotal spatial overhead incurred by DFS: 4x B (recursion is 3+1=4 layers deep)\\n\\nO O O O O\\nO O O O O\\nO O O O O  --> dfs(0, 0) --> dfs(0, 1) --> dfs(0, 2) -->dfs(0, 3) --> ...\\nO O O O O\\nO O O O O\\n\\ntotal spatial overhead incurred by DFS: 26x B (recursion is 25+1=26 layers deep)\\n```\n```python\\n# Solution 2: Pure BFS Implementation\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        m, n, curr = len(board), len(board[0]), deque()\\n       \\n        # get all \\'O\\'s from the border\\n        for i in range(n):\\n            if board[0][i] == \\'O\\':  # top row\\n                curr.append((0, i))\\n            if m > 1 and board[m-1][i] == \\'O\\':  # bottom row\\n                curr.append((m-1, i))\\n        for i in range(1, m-1):\\n            if board[i][0] == \\'O\\':  # left column\\n                curr.append((i, 0))\\n            if n > 1 and board[i][n-1] == \\'O\\':  # right column\\n                curr.append((i, n-1))\\n        \\n        # loop through BFS-style to find adjacent \\'O\\'s\\n        while curr:\\n            i, j = curr.popleft()\\n            board[i][j] = \\'S\\'  # mark as seen, or non-capturable\\n            for x, y in ((i-1, j), (i+1, j), (i, j-1), (i, j+1)):\\n                if 0 <= x < m and 0 <= y < n and board[x][y] == \\'O\\':\\n                    curr.append((x, y))\\n        \\n        # one-pass to capture \\'O\\'s to \\'X\\'s and \\'S\\'s to \\'O\\'s\\n        for i in range(m):\\n            for j in range(n):\\n                board[i][j] = \\'X\\' if board[i][j] == \\'O\\' else \\'O\\' if board[i][j] == \\'S\\' else board[i][j]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1458638,
                "title": "clear-java-dfs-solution-using-1ms-and-36-lines",
                "content": "Please upvote if you find my solution helpful!\\n\\n```\\nclass Solution {\\n    void dfs(char[][] board, int r, int c) {\\n        int nr = board.length;\\n        int nc = board[0].length;\\n        \\n        //ensure the cell iswithin the boundary and its value is \\'O\\'\\n        if (r<0 || r > nr-1 || c<0 || c > nc-1 || board[r][c] != \\'O\\') return; \\n        \\n        board[r][c] = \\'*\\'; //to mark the connected \\'O\\'s with a origin from the board boundary\\n        dfs(board, r-1, c);\\n        dfs(board, r, c-1);\\n        dfs(board, r+1, c);\\n        dfs(board, r, c+1);\\n    }\\n    \\n    public void solve(char[][] board) {\\n        int nr = board.length;\\n        int nc = board[0].length;\\n        \\n        //if \\'O\\' is on the border\\n        for (int i=0; i<nr; i++) {\\n            if (board[i][0] == \\'O\\') dfs(board, i,0);\\n            if (board[i][nc-1] == \\'O\\') dfs(board, i,nc-1);\\n        }\\n        \\n        for (int i=0; i<nc; i++) {\\n            if (board[0][i] == \\'O\\') dfs(board, 0, i);\\n            if (board[nr-1][i] == \\'O\\') dfs(board, nr-1,i);\\n        }\\n        \\n        for(int r=0; r<nr; r++){\\n            for(int c=0; c<nc; c++) {\\n               if (board[r][c] == \\'O\\') board[r][c] = \\'X\\';\\n               if (board[r][c] == \\'*\\') board[r][c] = \\'O\\';\\n            }\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    void dfs(char[][] board, int r, int c) {\\n        int nr = board.length;\\n        int nc = board[0].length;\\n        \\n        //ensure the cell iswithin the boundary and its value is \\'O\\'\\n        if (r<0 || r > nr-1 || c<0 || c > nc-1 || board[r][c] != \\'O\\') return; \\n        \\n        board[r][c] = \\'*\\'; //to mark the connected \\'O\\'s with a origin from the board boundary\\n        dfs(board, r-1, c);\\n        dfs(board, r, c-1);\\n        dfs(board, r+1, c);\\n        dfs(board, r, c+1);\\n    }\\n    \\n    public void solve(char[][] board) {\\n        int nr = board.length;\\n        int nc = board[0].length;\\n        \\n        //if \\'O\\' is on the border\\n        for (int i=0; i<nr; i++) {\\n            if (board[i][0] == \\'O\\') dfs(board, i,0);\\n            if (board[i][nc-1] == \\'O\\') dfs(board, i,nc-1);\\n        }\\n        \\n        for (int i=0; i<nc; i++) {\\n            if (board[0][i] == \\'O\\') dfs(board, 0, i);\\n            if (board[nr-1][i] == \\'O\\') dfs(board, nr-1,i);\\n        }\\n        \\n        for(int r=0; r<nr; r++){\\n            for(int c=0; c<nc; c++) {\\n               if (board[r][c] == \\'O\\') board[r][c] = \\'X\\';\\n               if (board[r][c] == \\'*\\') board[r][c] = \\'O\\';\\n            }\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1402968,
                "title": "java-easy-approach-with-explanation-preorder-dfs",
                "content": "```\\nclass Solution \\n{//T -> O(N^2)  S-> O(1)\\n    public void solve(char[][] board)\\n    {//We are treating each node as \\n        int m= board.length;//number of row \\n        int n= board[0].length;//number of column \\n      \\n        //Axcept edge component or boundary component, all componennt are captured by X\\n\\n        for(int i= 0; i < m; i++) \\n        {\\n            for(int j= 0; j < n; j++) \\n            {\\n                if(board[i][j] == \\'O\\' && (i == 0 || j == 0 || i == m - 1 || j == n - 1)) //Finding the edge component nodes,//and filling that componenet nodes with -(dash), //indicating that the components are not covered by X on 4 sides//1 or two side is blocked  \\n                    Fill(board, i, j, m, n);\\n            }\\n        }\\n      \\n        //iterating over the matrix again to check that the edge related component must be replaced with O and rest of all the component must be replaced by X//since the component other than the edge must be surrounded by X on all 4 direction  \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++) \\n            {\\n                if(board[i][j] == \\'-\\') //Edge component remains same, according to  the question, //not able capture(support of wall)\\n                    board[i][j]= \\'O\\';\\n                else //other than edge component are filled with X, //captured by X\\n                    board[i][j]= \\'X\\';\\n            }\\n        }\\n        return;\\n    }\\n    public void Fill(char[][] board, int i, int j, int m, int n)//Filling the Edge Component nodes with Dash\\n    {//Preorder DFS\\n        if(i < 0 || j < 0 || i >= m  || j >= n || board[i][j] == \\'-\\' || board[i][j] == \\'X\\') \\n            return;//base case for returning back to the calling function when -> 1) when our index is out of bound 2) Already X condition 3) Already marked -(dash) condition(Visisted)\\n      \\n        //ROOT\\n        board[i][j]= \\'-\\';//filling the node of component of edge boundary with -(dash)\\n      \\n        //LEFT- RIGHT-TOP-BOTTOM// 4 direction coverage \\n        Fill(board, i - 1, j, m, n);//Top\\n        Fill(board, i, j + 1, m, n);//Right\\n        Fill(board, i, j - 1, m, n);//Left \\n        Fill(board, i + 1, j, m, n);//Bottom \\n      \\n        return;\\n    }\\n}//Please do Upvote, it Helps a lot \\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{//T -> O(N^2)  S-> O(1)\\n    public void solve(char[][] board)\\n    {//We are treating each node as \\n        int m= board.length;//number of row \\n        int n= board[0].length;//number of column \\n      \\n        //Axcept edge component or boundary component, all componennt are captured by X\\n\\n        for(int i= 0; i < m; i++) \\n        {\\n            for(int j= 0; j < n; j++) \\n            {\\n                if(board[i][j] == \\'O\\' && (i == 0 || j == 0 || i == m - 1 || j == n - 1)) //Finding the edge component nodes,//and filling that componenet nodes with -(dash), //indicating that the components are not covered by X on 4 sides//1 or two side is blocked  \\n                    Fill(board, i, j, m, n);\\n            }\\n        }\\n      \\n        //iterating over the matrix again to check that the edge related component must be replaced with O and rest of all the component must be replaced by X//since the component other than the edge must be surrounded by X on all 4 direction  \\n        for(int i = 0; i < m; i++)\\n        {\\n            for(int j = 0; j < n; j++) \\n            {\\n                if(board[i][j] == \\'-\\') //Edge component remains same, according to  the question, //not able capture(support of wall)\\n                    board[i][j]= \\'O\\';\\n                else //other than edge component are filled with X, //captured by X\\n                    board[i][j]= \\'X\\';\\n            }\\n        }\\n        return;\\n    }\\n    public void Fill(char[][] board, int i, int j, int m, int n)//Filling the Edge Component nodes with Dash\\n    {//Preorder DFS\\n        if(i < 0 || j < 0 || i >= m  || j >= n || board[i][j] == \\'-\\' || board[i][j] == \\'X\\') \\n            return;//base case for returning back to the calling function when -> 1) when our index is out of bound 2) Already X condition 3) Already marked -(dash) condition(Visisted)\\n      \\n        //ROOT\\n        board[i][j]= \\'-\\';//filling the node of component of edge boundary with -(dash)\\n      \\n        //LEFT- RIGHT-TOP-BOTTOM// 4 direction coverage \\n        Fill(board, i - 1, j, m, n);//Top\\n        Fill(board, i, j + 1, m, n);//Right\\n        Fill(board, i, j - 1, m, n);//Left \\n        Fill(board, i + 1, j, m, n);//Bottom \\n      \\n        return;\\n    }\\n}//Please do Upvote, it Helps a lot \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1384978,
                "title": "easy-c-solution-using-dfs",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    void dfs(vector<vector<char>>& board,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=board.size() || j>=board[0].size() || board[i][j]!=\\'O\\')\\n        {\\n            return;\\n        }\\n        board[i][j]=\\'#\\';\\n        dfs(board,i-1,j);\\n        dfs(board,i+1,j);\\n        dfs(board,i,j-1);\\n        dfs(board,i,j+1);\\n    }\\n    void solve(vector<vector<char>>& board) \\n    {\\n        // traverse through all the boundaries\\n        for(int i=0;i<board.size();i++)\\n        {\\n            if(board[i][0]==\\'O\\')\\n            {\\n                dfs(board,i,0);\\n            }\\n        }\\n        for(int i=0;i<board[0].size();i++)\\n        {\\n            if(board[board.size()-1][i]==\\'O\\')\\n            {\\n                dfs(board,board.size()-1,i);\\n            }\\n        }\\n        for(int i=0;i<board.size();i++)\\n        {\\n            if(board[i][board[0].size()-1]==\\'O\\')\\n            {\\n                dfs(board,i,board[0].size()-1);\\n            }\\n        }\\n        for(int i=0;i<board[0].size();i++)\\n        {\\n            if(board[0][i]==\\'O\\')\\n            {\\n                dfs(board,0,i);\\n            }\\n        }\\n        \\n        // now traverse through all the cells of the matrix and convert \\'O\\' to \\'X\\' and \\'#\\' to \\'O\\'\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[0].size();j++)\\n            {\\n                if(board[i][j]==\\'O\\')\\n                {\\n                    board[i][j]=\\'X\\';\\n                }\\n                else if(board[i][j]==\\'#\\')\\n                {\\n                    board[i][j]=\\'O\\';\\n                }\\n            }\\n        }\\n    }\\n};\\n```\\n***Please upvote if you\\'ve got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    void dfs(vector<vector<char>>& board,int i,int j)\\n    {\\n        if(i<0 || j<0 || i>=board.size() || j>=board[0].size() || board[i][j]!=\\'O\\')\\n        {\\n            return;\\n        }\\n        board[i][j]=\\'#\\';\\n        dfs(board,i-1,j);\\n        dfs(board,i+1,j);\\n        dfs(board,i,j-1);\\n        dfs(board,i,j+1);\\n    }\\n    void solve(vector<vector<char>>& board) \\n    {\\n        // traverse through all the boundaries\\n        for(int i=0;i<board.size();i++)\\n        {\\n            if(board[i][0]==\\'O\\')\\n            {\\n                dfs(board,i,0);\\n            }\\n        }\\n        for(int i=0;i<board[0].size();i++)\\n        {\\n            if(board[board.size()-1][i]==\\'O\\')\\n            {\\n                dfs(board,board.size()-1,i);\\n            }\\n        }\\n        for(int i=0;i<board.size();i++)\\n        {\\n            if(board[i][board[0].size()-1]==\\'O\\')\\n            {\\n                dfs(board,i,board[0].size()-1);\\n            }\\n        }\\n        for(int i=0;i<board[0].size();i++)\\n        {\\n            if(board[0][i]==\\'O\\')\\n            {\\n                dfs(board,0,i);\\n            }\\n        }\\n        \\n        // now traverse through all the cells of the matrix and convert \\'O\\' to \\'X\\' and \\'#\\' to \\'O\\'\\n        for(int i=0;i<board.size();i++)\\n        {\\n            for(int j=0;j<board[0].size();j++)\\n            {\\n                if(board[i][j]==\\'O\\')\\n                {\\n                    board[i][j]=\\'X\\';\\n                }\\n                else if(board[i][j]==\\'#\\')\\n                {\\n                    board[i][j]=\\'O\\';\\n                }\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1329872,
                "title": "clean-dfs-java-code-faster-than-100-easy-to-understand",
                "content": "```\\npublic void dfs(char[][] board, int i, int j, int[][] dir){\\n        board[i][j] = \\'$\\';\\n        int n = board.length, m = board[0].length;\\n        for(int d=0; d < 4; d++){\\n            int r = i + dir[d][0];\\n            int c = j + dir[d][1];\\n            if(r >= 0 && c >= 0 && r < n && c < m && board[r][c] == \\'O\\')\\n                dfs(board,r,c,dir);\\n        }\\n    }\\n    public void solve(char[][] board) {\\n        int n = board.length, m = board[0].length;\\n        int dir[][] = {{1,0}, {-1,0}, {0,-1}, {0,1}};\\n        for(int i=0; i < n; i++){\\n            for(int j=0; j < m; j++){\\n                if((i==0 || j == 0 || i == n-1 || j == m-1) && board[i][j] == \\'O\\'){\\n                    dfs(board,i,j,dir);\\n                }\\n            }\\n        }\\n        for(int i=0; i < n; i++){\\n            for(int j=0; j < m; j++){\\n                if(board[i][j] == \\'$\\')\\n                    board[i][j] = \\'O\\';\\n                else\\n                    board[i][j] = \\'X\\';\\n            }\\n        }\\n    }",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\npublic void dfs(char[][] board, int i, int j, int[][] dir){\\n        board[i][j] = \\'$\\';\\n        int n = board.length, m = board[0].length;\\n        for(int d=0; d < 4; d++){\\n            int r = i + dir[d][0];\\n            int c = j + dir[d][1];\\n            if(r >= 0 && c >= 0 && r < n && c < m && board[r][c] == \\'O\\')\\n                dfs(board,r,c,dir);\\n        }\\n    }\\n    public void solve(char[][] board) {\\n        int n = board.length, m = board[0].length;\\n        int dir[][] = {{1,0}, {-1,0}, {0,-1}, {0,1}};\\n        for(int i=0; i < n; i++){\\n            for(int j=0; j < m; j++){\\n                if((i==0 || j == 0 || i == n-1 || j == m-1) && board[i][j] == \\'O\\'){\\n                    dfs(board,i,j,dir);\\n                }\\n            }\\n        }\\n        for(int i=0; i < n; i++){\\n            for(int j=0; j < m; j++){\\n                if(board[i][j] == \\'$\\')\\n                    board[i][j] = \\'O\\';\\n                else\\n                    board[i][j] = \\'X\\';\\n            }\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1214693,
                "title": "c-bfs-and-dfs-time-less-than-100-4ms-space-less-than-90",
                "content": "The below solution is **bfs** based , for **dfs** just create another dfs function and check the condition inside it and recursively run it along with visited.\\n\\nThe Problem required us to change only those \"O\" which are not at outermost part or adjacent to outermost part. Any \"O\" character which did not fit the over condition was supposed to be changed to \"X\" . That\\'s what is written in the below code.\\n\\n```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        queue<pair<int,int>> q; //Queue initialised for storing indexes\\n        int n = board.size();   //taking row size\\n        if(n==0)    //for edge case \\n            return;\\n        int m = board[0].size();    //taking column size\\n        vector<vector<bool>> vis(n,vector<bool>(m,0));  //intialising visited 2D vector\\n        for(int i=0;i<n;i++)    //for Row only\\n        {\\n            if(board[i][0]==\\'O\\')     \\n                q.push({i,0});      //Storing the index of outmost \"O\" characters\\n            if(board[i][m-1]==\\'O\\')\\n                q.push({i,m-1});    //Same as above \\n        }\\n        for(int i=0;i<m;i++)    //for Column only\\n        {\\n            if(board[0][i]==\\'O\\')\\n                q.push({0,i});      //Storing the index of outmost \"O\" character in the 0th column\\n            if(board[n-1][i]==\\'O\\')\\n                q.push({n-1,i});    //same as above for n-1th column\\n        }\\n        int dr[4] = {-1,0,1,0}; //initialising row array for cheacking adjacent \"O\"\\n        int dc[4] = {0,-1,0,1}; //initialising column array for checking adjacent \"O\"\\n        \\n        while(!q.empty())\\n        {\\n            int x = q.front().first;    \\n            int y = q.front().second;\\n            q.pop();\\n            board[x][y] = \\'S\\';  //Putting a character of our choice in the place of \"O\"\\n            vis[x][y] = 1;  //and also updating visited to 1\\n            for(int i=0;i<4;i++)\\n            {\\n                int x_p = x + dr[i];    //x_p is x point for adjacent elements\\n                int y_p = y + dc[i];    // y_p is y point for adjacent elements\\n                if(x_p>=0 && x_p<=n-1 && y_p>=0 && y_p<=m-1 && board[x_p][y_p]==\\'O\\' && vis[x_p][y_p]==0)    //we will change the char of those elements only which are unvisited and adjacent to outmost \"O\"\\n                {\\n                    q.push({x_p,y_p});  //Storing the index of the adjacent \"O\"\\n                    vis[x_p][y_p]=1;    //Updating visited of adjacent to 1\\n                }\\n            }\\n        }\\n        //Now iterating over whole array\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(board[i][j]==\\'S\\')    //Checking if the character is \"O\" or adjacent to \"O\" , if yes then we will change the temporary char \"S\" to \"O\" for output purpose\\n                    board[i][j]=\\'O\\';\\n                else\\n                    board[i][j]=\\'X\\';    //if O appears on any other side except outmost part or adjacent to it then we will update it to \"X\"\\n            }\\n        }\\n    }\\n};\\n```\\n**If you like it , Do UPVOTE**\\n**HAPPY CODING**",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void solve(vector<vector<char>>& board) {\\n        queue<pair<int,int>> q; //Queue initialised for storing indexes\\n        int n = board.size();   //taking row size\\n        if(n==0)    //for edge case \\n            return;\\n        int m = board[0].size();    //taking column size\\n        vector<vector<bool>> vis(n,vector<bool>(m,0));  //intialising visited 2D vector\\n        for(int i=0;i<n;i++)    //for Row only\\n        {\\n            if(board[i][0]==\\'O\\')     \\n                q.push({i,0});      //Storing the index of outmost \"O\" characters\\n            if(board[i][m-1]==\\'O\\')\\n                q.push({i,m-1});    //Same as above \\n        }\\n        for(int i=0;i<m;i++)    //for Column only\\n        {\\n            if(board[0][i]==\\'O\\')\\n                q.push({0,i});      //Storing the index of outmost \"O\" character in the 0th column\\n            if(board[n-1][i]==\\'O\\')\\n                q.push({n-1,i});    //same as above for n-1th column\\n        }\\n        int dr[4] = {-1,0,1,0}; //initialising row array for cheacking adjacent \"O\"\\n        int dc[4] = {0,-1,0,1}; //initialising column array for checking adjacent \"O\"\\n        \\n        while(!q.empty())\\n        {\\n            int x = q.front().first;    \\n            int y = q.front().second;\\n            q.pop();\\n            board[x][y] = \\'S\\';  //Putting a character of our choice in the place of \"O\"\\n            vis[x][y] = 1;  //and also updating visited to 1\\n            for(int i=0;i<4;i++)\\n            {\\n                int x_p = x + dr[i];    //x_p is x point for adjacent elements\\n                int y_p = y + dc[i];    // y_p is y point for adjacent elements\\n                if(x_p>=0 && x_p<=n-1 && y_p>=0 && y_p<=m-1 && board[x_p][y_p]==\\'O\\' && vis[x_p][y_p]==0)    //we will change the char of those elements only which are unvisited and adjacent to outmost \"O\"\\n                {\\n                    q.push({x_p,y_p});  //Storing the index of the adjacent \"O\"\\n                    vis[x_p][y_p]=1;    //Updating visited of adjacent to 1\\n                }\\n            }\\n        }\\n        //Now iterating over whole array\\n        for(int i=0;i<n;i++)\\n        {\\n            for(int j=0;j<m;j++)\\n            {\\n                if(board[i][j]==\\'S\\')    //Checking if the character is \"O\" or adjacent to \"O\" , if yes then we will change the temporary char \"S\" to \"O\" for output purpose\\n                    board[i][j]=\\'O\\';\\n                else\\n                    board[i][j]=\\'X\\';    //if O appears on any other side except outmost part or adjacent to it then we will update it to \"X\"\\n            }\\n        }\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1191379,
                "title": "python-dfs-coloring",
                "content": "**Intuition:**\\n* DFS through borders and color them \"*\". (To marks \"0\"s that can\\'t be flipped\").\\n* Loop through board and mark \"0\" as \"X\", and \"*\" and \"0\".\\n\\n```\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        def DFS(board, i, j):\\n            board[i][j] = \"*\"\\n            neighbours = ((0, 1), (0, -1), (1, 0), (-1, 0))\\n            for dx, dy in neighbours:\\n                if 0 <= i + dx <= len(board) - 1 and 0 <= j + dy <= len(board[0]) - 1 and board[i + dx][j + dy] == \"O\":\\n                    DFS(board, i + dx, j + dy)\\n        \\n        \\n        # first row\\n        i = 0\\n        for j in range(len(board[0])):\\n            if board[i][j] == \"O\":\\n                DFS(board, i, j)\\n            \\n        # last row\\n        i = len(board) - 1\\n        for j in range(len(board[0])):\\n            if board[i][j] == \"O\":\\n                DFS(board, i, j)\\n                \\n        # left column\\n        j = 0\\n        for i in range(len(board)):\\n            if board[i][j] == \"O\":\\n                DFS(board, i, j)\\n                \\n        # right column\\n        j = len(board[0]) - 1\\n        for i in range(len(board)):\\n            if board[i][j] == \"O\":\\n                DFS(board, i, j)\\n                \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \"O\":\\n                    board[i][j] = \"X\"\\n                if board[i][j] == \"*\":\\n                    board[i][j] = \"O\"\\n                    \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        def DFS(board, i, j):\\n            board[i][j] = \"*\"\\n            neighbours = ((0, 1), (0, -1), (1, 0), (-1, 0))\\n            for dx, dy in neighbours:\\n                if 0 <= i + dx <= len(board) - 1 and 0 <= j + dy <= len(board[0]) - 1 and board[i + dx][j + dy] == \"O\":\\n                    DFS(board, i + dx, j + dy)\\n        \\n        \\n        # first row\\n        i = 0\\n        for j in range(len(board[0])):\\n            if board[i][j] == \"O\":\\n                DFS(board, i, j)\\n            \\n        # last row\\n        i = len(board) - 1\\n        for j in range(len(board[0])):\\n            if board[i][j] == \"O\":\\n                DFS(board, i, j)\\n                \\n        # left column\\n        j = 0\\n        for i in range(len(board)):\\n            if board[i][j] == \"O\":\\n                DFS(board, i, j)\\n                \\n        # right column\\n        j = len(board[0]) - 1\\n        for i in range(len(board)):\\n            if board[i][j] == \"O\":\\n                DFS(board, i, j)\\n                \\n        for i in range(len(board)):\\n            for j in range(len(board[0])):\\n                if board[i][j] == \"O\":\\n                    board[i][j] = \"X\"\\n                if board[i][j] == \"*\":\\n                    board[i][j] = \"O\"\\n                    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1189857,
                "title": "dfs-python-98-faster-easy-to-understand",
                "content": "**Algorithms** follows below :\\n* Loop through the first and last row then again loop throgh the first and last column.\\n* In DFS function when we will get \"O\" replace it with any unique character.\\n* After that, all the \"O\" character got replace with \"*\"  which we again convert it into \"O\"/\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        def dfs(i,j):\\n            if i<0 or i>=m or j<0 or j>=n or board[i][j]!=\\'O\\':\\n                return\\n            \\n            board[i][j]=\"*\"\\n            dfs(i+1,j)\\n            dfs(i-1,j)\\n            dfs(i,j+1)\\n            dfs(i,j-1)\\n              \\n        m=len(board)\\n        n=len(board[0])\\n        if m<3 or n<3:\\n            return\\n        \\n        for i in range(m):\\n            dfs(i,0)\\n            dfs(i,n-1)\\n        \\n        for j in range(n):\\n            dfs(0,j)\\n            dfs(m-1,j)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j]==\"*\":\\n                    board[i][j]=\"O\"\\n                elif board[i][j]==\"O\":\\n                    board[i][j]=\"X\"      \\n        return",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "**Algorithms** follows below :\\n* Loop through the first and last row then again loop throgh the first and last column.\\n* In DFS function when we will get \"O\" replace it with any unique character.\\n* After that, all the \"O\" character got replace with \"*\"  which we again convert it into \"O\"/\\n\\n\\'\\'\\'\\n\\n\\tclass Solution:\\n    def solve(self, board: List[List[str]]) -> None:\\n        \"\"\"\\n        Do not return anything, modify board in-place instead.\\n        \"\"\"\\n        def dfs(i,j):\\n            if i<0 or i>=m or j<0 or j>=n or board[i][j]!=\\'O\\':\\n                return\\n            \\n            board[i][j]=\"*\"\\n            dfs(i+1,j)\\n            dfs(i-1,j)\\n            dfs(i,j+1)\\n            dfs(i,j-1)\\n              \\n        m=len(board)\\n        n=len(board[0])\\n        if m<3 or n<3:\\n            return\\n        \\n        for i in range(m):\\n            dfs(i,0)\\n            dfs(i,n-1)\\n        \\n        for j in range(n):\\n            dfs(0,j)\\n            dfs(m-1,j)\\n        \\n        for i in range(m):\\n            for j in range(n):\\n                if board[i][j]==\"*\":\\n                    board[i][j]=\"O\"\\n                elif board[i][j]==\"O\":\\n                    board[i][j]=\"X\"      \\n        return",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564696,
                "content": [
                    {
                        "username": "butterman1986",
                        "content": "I felt that the problem statement was difficult to understand as it and the associated example don't clearly indicate what surrounded means. An 'O' is surrounded if there is **NO** path from it to the boundary of the matrix (ie. row index 0, column index 0, row index matrix.length-1, column index matrix[0].length-1) when moving in a North, South, East, or West direction :). Hope this helps anyone else who was unclear."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thanks this hint helped me solve it easily "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/surrounded-regions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS (Depth-First Search)\n\n  \n**Approach 2:** BFS (Breadth-First Search)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mrigankshekhar27",
                        "content": "Leetcode should give more examples. I had to wast so much time running and testing different test cases. \\n And, after all of this, I learned nothing."
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "1) All the \"O\" that are not directly/indirectly connected to the \"O\" on the boundary line, will be captured and converted into \"X\"\\n2) Just traverse the matrix once, and as soon as your enounter a boundary line that has a \"O\" in it, run DFS on this \"O\" and \"Save\" all the nehgbours of this \"O\" from being captured by calling them \"S\"\\n3) Now traverse the matrix again and capture all the \"O\" that you can inside the matrix except the boundary line\\n4) Rename the \"Save\" O back to \"O\"\\n5) Done!"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "interesting, no need to bfs from the islands inside then. Just save any islands on the border."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you this was very helpful!"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Thanks man"
                    },
                    {
                        "username": "shx",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three 'o' are surrounded regions? I mean, the 'o' in the third row has another 'o' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "surrounded in means of 4 directions only top,left,bottom,right..!"
                    },
                    {
                        "username": "Yumi_C",
                        "content": "input=\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],   \\n [\"X\",\"O\",\"O\",\"X\",\"O\"],\\n [\"X\",\"O\",\"X\",\"O\",\"X\"],\\n [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nexpect =\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"X\",\"X\",\"X\",\"X\",\"O\"],\\n  [\"X\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n  [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n  \\n   since  board[2][3] does not on the boarder and does not connect to anything on the boder, it suppose to flip to \"X\" ,right? why it stay the same?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "For anyone still wondering:\\nboard[2][3] stays an O because it is connected to O\\'s that are not surrounded by X\\'s. "
                    },
                    {
                        "username": "irazer19",
                        "content": "That board[2][3] is at the border because its connect to the other O\\'s (board[3][4] and board[4][2]), if you do BFS you will see the connection"
                    },
                    {
                        "username": "sr259",
                        "content": "I am having the same problem, I feel like this one should be \\'X\\' but i am not sure. Can anyone explain?"
                    },
                    {
                        "username": "tonytata",
                        "content": "What does it mean to be surrounded? Whatever I think it means, it is contradicted by the fact that the '0' on the bottom row is not changed."
                    },
                    {
                        "username": "00paradise",
                        "content": "The border cells do not have 4 adjacent cells. Therefore, we can not flip those cell in the border that contains \\'O\\' and also all adjacent cell connected to that border cell.\\n\\nSteps to perform--\\nVisit the border character. \\nIf character is \\'O\\', then mark that character as \\'P\\' or with any random character. And make a dfs call from that position to other adjacent cell where character is \\'O\\' and mark it \\'P\\'.\\n\\nAt last, assign all \\'P\\' as \\'O\\' and other cell value as \\'X\\'."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you, this made the whole problem a lot easier."
                    },
                    {
                        "username": "mczscta",
                        "content": "First things first. Clear what it means that each cell has \\'X\\' on all sides. \\'X\\' should be adjacent or can be any cells away.\\n\\nSolution 1:\\n\\tDo as the question says. For each cell, go in all directions and see if it is surrounded by \\'X\\' on all sides.\\n\\tThe complexity is O(n*n*n)\\n\\t\\nSolution 2: \\n\\tIn the above approach, we are going in all directions just to find the first occurence of \\'X\\' in that direction. Instead we can do some precomputation.\\n\\tDefine left[i][j] as the first index to left of cell(i, j) which has a \\'X\\'. Keep value as -1 if doesn\\'t exist. Similarly, define right[i][j], top[i][j] and down[i][j]. \\n\\tThe time complexity for this solution is O(n*n + n*n) = O(2*n*n) = O(n * n) and space complexity is also same.\\n\\t\\nSolution 3:\\n Notice that if a cell has \\'X\\' on all sides then it can not be reached by a series of 0\\'s that start at the border. Use this observation to do dfs from all 0\\'s at the border and mark them with \\'I\\' so as to mark invalid. After this mark all 0\\'s with X and all the \\'I\\'s back to 0. \\n The time complexity is O(n*n) and space is O(n*n) for dfs."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my mind really tripped reading O(nn) \\uD83D\\uDE16"
                    },
                    {
                        "username": "__anu__",
                        "content": "Just to save you some time, it\\'s alphabet \\'O\\' and not number \\'0\\'"
                    }
                ]
            },
            {
                "id": 1564736,
                "content": [
                    {
                        "username": "butterman1986",
                        "content": "I felt that the problem statement was difficult to understand as it and the associated example don't clearly indicate what surrounded means. An 'O' is surrounded if there is **NO** path from it to the boundary of the matrix (ie. row index 0, column index 0, row index matrix.length-1, column index matrix[0].length-1) when moving in a North, South, East, or West direction :). Hope this helps anyone else who was unclear."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thanks this hint helped me solve it easily "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/surrounded-regions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS (Depth-First Search)\n\n  \n**Approach 2:** BFS (Breadth-First Search)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mrigankshekhar27",
                        "content": "Leetcode should give more examples. I had to wast so much time running and testing different test cases. \\n And, after all of this, I learned nothing."
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "1) All the \"O\" that are not directly/indirectly connected to the \"O\" on the boundary line, will be captured and converted into \"X\"\\n2) Just traverse the matrix once, and as soon as your enounter a boundary line that has a \"O\" in it, run DFS on this \"O\" and \"Save\" all the nehgbours of this \"O\" from being captured by calling them \"S\"\\n3) Now traverse the matrix again and capture all the \"O\" that you can inside the matrix except the boundary line\\n4) Rename the \"Save\" O back to \"O\"\\n5) Done!"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "interesting, no need to bfs from the islands inside then. Just save any islands on the border."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you this was very helpful!"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Thanks man"
                    },
                    {
                        "username": "shx",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three 'o' are surrounded regions? I mean, the 'o' in the third row has another 'o' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "surrounded in means of 4 directions only top,left,bottom,right..!"
                    },
                    {
                        "username": "Yumi_C",
                        "content": "input=\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],   \\n [\"X\",\"O\",\"O\",\"X\",\"O\"],\\n [\"X\",\"O\",\"X\",\"O\",\"X\"],\\n [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nexpect =\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"X\",\"X\",\"X\",\"X\",\"O\"],\\n  [\"X\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n  [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n  \\n   since  board[2][3] does not on the boarder and does not connect to anything on the boder, it suppose to flip to \"X\" ,right? why it stay the same?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "For anyone still wondering:\\nboard[2][3] stays an O because it is connected to O\\'s that are not surrounded by X\\'s. "
                    },
                    {
                        "username": "irazer19",
                        "content": "That board[2][3] is at the border because its connect to the other O\\'s (board[3][4] and board[4][2]), if you do BFS you will see the connection"
                    },
                    {
                        "username": "sr259",
                        "content": "I am having the same problem, I feel like this one should be \\'X\\' but i am not sure. Can anyone explain?"
                    },
                    {
                        "username": "tonytata",
                        "content": "What does it mean to be surrounded? Whatever I think it means, it is contradicted by the fact that the '0' on the bottom row is not changed."
                    },
                    {
                        "username": "00paradise",
                        "content": "The border cells do not have 4 adjacent cells. Therefore, we can not flip those cell in the border that contains \\'O\\' and also all adjacent cell connected to that border cell.\\n\\nSteps to perform--\\nVisit the border character. \\nIf character is \\'O\\', then mark that character as \\'P\\' or with any random character. And make a dfs call from that position to other adjacent cell where character is \\'O\\' and mark it \\'P\\'.\\n\\nAt last, assign all \\'P\\' as \\'O\\' and other cell value as \\'X\\'."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you, this made the whole problem a lot easier."
                    },
                    {
                        "username": "mczscta",
                        "content": "First things first. Clear what it means that each cell has \\'X\\' on all sides. \\'X\\' should be adjacent or can be any cells away.\\n\\nSolution 1:\\n\\tDo as the question says. For each cell, go in all directions and see if it is surrounded by \\'X\\' on all sides.\\n\\tThe complexity is O(n*n*n)\\n\\t\\nSolution 2: \\n\\tIn the above approach, we are going in all directions just to find the first occurence of \\'X\\' in that direction. Instead we can do some precomputation.\\n\\tDefine left[i][j] as the first index to left of cell(i, j) which has a \\'X\\'. Keep value as -1 if doesn\\'t exist. Similarly, define right[i][j], top[i][j] and down[i][j]. \\n\\tThe time complexity for this solution is O(n*n + n*n) = O(2*n*n) = O(n * n) and space complexity is also same.\\n\\t\\nSolution 3:\\n Notice that if a cell has \\'X\\' on all sides then it can not be reached by a series of 0\\'s that start at the border. Use this observation to do dfs from all 0\\'s at the border and mark them with \\'I\\' so as to mark invalid. After this mark all 0\\'s with X and all the \\'I\\'s back to 0. \\n The time complexity is O(n*n) and space is O(n*n) for dfs."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my mind really tripped reading O(nn) \\uD83D\\uDE16"
                    },
                    {
                        "username": "__anu__",
                        "content": "Just to save you some time, it\\'s alphabet \\'O\\' and not number \\'0\\'"
                    }
                ]
            },
            {
                "id": 1566583,
                "content": [
                    {
                        "username": "butterman1986",
                        "content": "I felt that the problem statement was difficult to understand as it and the associated example don't clearly indicate what surrounded means. An 'O' is surrounded if there is **NO** path from it to the boundary of the matrix (ie. row index 0, column index 0, row index matrix.length-1, column index matrix[0].length-1) when moving in a North, South, East, or West direction :). Hope this helps anyone else who was unclear."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thanks this hint helped me solve it easily "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/surrounded-regions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS (Depth-First Search)\n\n  \n**Approach 2:** BFS (Breadth-First Search)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mrigankshekhar27",
                        "content": "Leetcode should give more examples. I had to wast so much time running and testing different test cases. \\n And, after all of this, I learned nothing."
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "1) All the \"O\" that are not directly/indirectly connected to the \"O\" on the boundary line, will be captured and converted into \"X\"\\n2) Just traverse the matrix once, and as soon as your enounter a boundary line that has a \"O\" in it, run DFS on this \"O\" and \"Save\" all the nehgbours of this \"O\" from being captured by calling them \"S\"\\n3) Now traverse the matrix again and capture all the \"O\" that you can inside the matrix except the boundary line\\n4) Rename the \"Save\" O back to \"O\"\\n5) Done!"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "interesting, no need to bfs from the islands inside then. Just save any islands on the border."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you this was very helpful!"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Thanks man"
                    },
                    {
                        "username": "shx",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three 'o' are surrounded regions? I mean, the 'o' in the third row has another 'o' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "surrounded in means of 4 directions only top,left,bottom,right..!"
                    },
                    {
                        "username": "Yumi_C",
                        "content": "input=\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],   \\n [\"X\",\"O\",\"O\",\"X\",\"O\"],\\n [\"X\",\"O\",\"X\",\"O\",\"X\"],\\n [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nexpect =\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"X\",\"X\",\"X\",\"X\",\"O\"],\\n  [\"X\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n  [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n  \\n   since  board[2][3] does not on the boarder and does not connect to anything on the boder, it suppose to flip to \"X\" ,right? why it stay the same?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "For anyone still wondering:\\nboard[2][3] stays an O because it is connected to O\\'s that are not surrounded by X\\'s. "
                    },
                    {
                        "username": "irazer19",
                        "content": "That board[2][3] is at the border because its connect to the other O\\'s (board[3][4] and board[4][2]), if you do BFS you will see the connection"
                    },
                    {
                        "username": "sr259",
                        "content": "I am having the same problem, I feel like this one should be \\'X\\' but i am not sure. Can anyone explain?"
                    },
                    {
                        "username": "tonytata",
                        "content": "What does it mean to be surrounded? Whatever I think it means, it is contradicted by the fact that the '0' on the bottom row is not changed."
                    },
                    {
                        "username": "00paradise",
                        "content": "The border cells do not have 4 adjacent cells. Therefore, we can not flip those cell in the border that contains \\'O\\' and also all adjacent cell connected to that border cell.\\n\\nSteps to perform--\\nVisit the border character. \\nIf character is \\'O\\', then mark that character as \\'P\\' or with any random character. And make a dfs call from that position to other adjacent cell where character is \\'O\\' and mark it \\'P\\'.\\n\\nAt last, assign all \\'P\\' as \\'O\\' and other cell value as \\'X\\'."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you, this made the whole problem a lot easier."
                    },
                    {
                        "username": "mczscta",
                        "content": "First things first. Clear what it means that each cell has \\'X\\' on all sides. \\'X\\' should be adjacent or can be any cells away.\\n\\nSolution 1:\\n\\tDo as the question says. For each cell, go in all directions and see if it is surrounded by \\'X\\' on all sides.\\n\\tThe complexity is O(n*n*n)\\n\\t\\nSolution 2: \\n\\tIn the above approach, we are going in all directions just to find the first occurence of \\'X\\' in that direction. Instead we can do some precomputation.\\n\\tDefine left[i][j] as the first index to left of cell(i, j) which has a \\'X\\'. Keep value as -1 if doesn\\'t exist. Similarly, define right[i][j], top[i][j] and down[i][j]. \\n\\tThe time complexity for this solution is O(n*n + n*n) = O(2*n*n) = O(n * n) and space complexity is also same.\\n\\t\\nSolution 3:\\n Notice that if a cell has \\'X\\' on all sides then it can not be reached by a series of 0\\'s that start at the border. Use this observation to do dfs from all 0\\'s at the border and mark them with \\'I\\' so as to mark invalid. After this mark all 0\\'s with X and all the \\'I\\'s back to 0. \\n The time complexity is O(n*n) and space is O(n*n) for dfs."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my mind really tripped reading O(nn) \\uD83D\\uDE16"
                    },
                    {
                        "username": "__anu__",
                        "content": "Just to save you some time, it\\'s alphabet \\'O\\' and not number \\'0\\'"
                    }
                ]
            },
            {
                "id": 1570621,
                "content": [
                    {
                        "username": "butterman1986",
                        "content": "I felt that the problem statement was difficult to understand as it and the associated example don't clearly indicate what surrounded means. An 'O' is surrounded if there is **NO** path from it to the boundary of the matrix (ie. row index 0, column index 0, row index matrix.length-1, column index matrix[0].length-1) when moving in a North, South, East, or West direction :). Hope this helps anyone else who was unclear."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thanks this hint helped me solve it easily "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/surrounded-regions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS (Depth-First Search)\n\n  \n**Approach 2:** BFS (Breadth-First Search)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mrigankshekhar27",
                        "content": "Leetcode should give more examples. I had to wast so much time running and testing different test cases. \\n And, after all of this, I learned nothing."
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "1) All the \"O\" that are not directly/indirectly connected to the \"O\" on the boundary line, will be captured and converted into \"X\"\\n2) Just traverse the matrix once, and as soon as your enounter a boundary line that has a \"O\" in it, run DFS on this \"O\" and \"Save\" all the nehgbours of this \"O\" from being captured by calling them \"S\"\\n3) Now traverse the matrix again and capture all the \"O\" that you can inside the matrix except the boundary line\\n4) Rename the \"Save\" O back to \"O\"\\n5) Done!"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "interesting, no need to bfs from the islands inside then. Just save any islands on the border."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you this was very helpful!"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Thanks man"
                    },
                    {
                        "username": "shx",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three 'o' are surrounded regions? I mean, the 'o' in the third row has another 'o' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "surrounded in means of 4 directions only top,left,bottom,right..!"
                    },
                    {
                        "username": "Yumi_C",
                        "content": "input=\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],   \\n [\"X\",\"O\",\"O\",\"X\",\"O\"],\\n [\"X\",\"O\",\"X\",\"O\",\"X\"],\\n [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nexpect =\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"X\",\"X\",\"X\",\"X\",\"O\"],\\n  [\"X\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n  [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n  \\n   since  board[2][3] does not on the boarder and does not connect to anything on the boder, it suppose to flip to \"X\" ,right? why it stay the same?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "For anyone still wondering:\\nboard[2][3] stays an O because it is connected to O\\'s that are not surrounded by X\\'s. "
                    },
                    {
                        "username": "irazer19",
                        "content": "That board[2][3] is at the border because its connect to the other O\\'s (board[3][4] and board[4][2]), if you do BFS you will see the connection"
                    },
                    {
                        "username": "sr259",
                        "content": "I am having the same problem, I feel like this one should be \\'X\\' but i am not sure. Can anyone explain?"
                    },
                    {
                        "username": "tonytata",
                        "content": "What does it mean to be surrounded? Whatever I think it means, it is contradicted by the fact that the '0' on the bottom row is not changed."
                    },
                    {
                        "username": "00paradise",
                        "content": "The border cells do not have 4 adjacent cells. Therefore, we can not flip those cell in the border that contains \\'O\\' and also all adjacent cell connected to that border cell.\\n\\nSteps to perform--\\nVisit the border character. \\nIf character is \\'O\\', then mark that character as \\'P\\' or with any random character. And make a dfs call from that position to other adjacent cell where character is \\'O\\' and mark it \\'P\\'.\\n\\nAt last, assign all \\'P\\' as \\'O\\' and other cell value as \\'X\\'."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you, this made the whole problem a lot easier."
                    },
                    {
                        "username": "mczscta",
                        "content": "First things first. Clear what it means that each cell has \\'X\\' on all sides. \\'X\\' should be adjacent or can be any cells away.\\n\\nSolution 1:\\n\\tDo as the question says. For each cell, go in all directions and see if it is surrounded by \\'X\\' on all sides.\\n\\tThe complexity is O(n*n*n)\\n\\t\\nSolution 2: \\n\\tIn the above approach, we are going in all directions just to find the first occurence of \\'X\\' in that direction. Instead we can do some precomputation.\\n\\tDefine left[i][j] as the first index to left of cell(i, j) which has a \\'X\\'. Keep value as -1 if doesn\\'t exist. Similarly, define right[i][j], top[i][j] and down[i][j]. \\n\\tThe time complexity for this solution is O(n*n + n*n) = O(2*n*n) = O(n * n) and space complexity is also same.\\n\\t\\nSolution 3:\\n Notice that if a cell has \\'X\\' on all sides then it can not be reached by a series of 0\\'s that start at the border. Use this observation to do dfs from all 0\\'s at the border and mark them with \\'I\\' so as to mark invalid. After this mark all 0\\'s with X and all the \\'I\\'s back to 0. \\n The time complexity is O(n*n) and space is O(n*n) for dfs."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my mind really tripped reading O(nn) \\uD83D\\uDE16"
                    },
                    {
                        "username": "__anu__",
                        "content": "Just to save you some time, it\\'s alphabet \\'O\\' and not number \\'0\\'"
                    }
                ]
            },
            {
                "id": 1565427,
                "content": [
                    {
                        "username": "butterman1986",
                        "content": "I felt that the problem statement was difficult to understand as it and the associated example don't clearly indicate what surrounded means. An 'O' is surrounded if there is **NO** path from it to the boundary of the matrix (ie. row index 0, column index 0, row index matrix.length-1, column index matrix[0].length-1) when moving in a North, South, East, or West direction :). Hope this helps anyone else who was unclear."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thanks this hint helped me solve it easily "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/surrounded-regions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS (Depth-First Search)\n\n  \n**Approach 2:** BFS (Breadth-First Search)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mrigankshekhar27",
                        "content": "Leetcode should give more examples. I had to wast so much time running and testing different test cases. \\n And, after all of this, I learned nothing."
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "1) All the \"O\" that are not directly/indirectly connected to the \"O\" on the boundary line, will be captured and converted into \"X\"\\n2) Just traverse the matrix once, and as soon as your enounter a boundary line that has a \"O\" in it, run DFS on this \"O\" and \"Save\" all the nehgbours of this \"O\" from being captured by calling them \"S\"\\n3) Now traverse the matrix again and capture all the \"O\" that you can inside the matrix except the boundary line\\n4) Rename the \"Save\" O back to \"O\"\\n5) Done!"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "interesting, no need to bfs from the islands inside then. Just save any islands on the border."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you this was very helpful!"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Thanks man"
                    },
                    {
                        "username": "shx",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three 'o' are surrounded regions? I mean, the 'o' in the third row has another 'o' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "surrounded in means of 4 directions only top,left,bottom,right..!"
                    },
                    {
                        "username": "Yumi_C",
                        "content": "input=\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],   \\n [\"X\",\"O\",\"O\",\"X\",\"O\"],\\n [\"X\",\"O\",\"X\",\"O\",\"X\"],\\n [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nexpect =\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"X\",\"X\",\"X\",\"X\",\"O\"],\\n  [\"X\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n  [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n  \\n   since  board[2][3] does not on the boarder and does not connect to anything on the boder, it suppose to flip to \"X\" ,right? why it stay the same?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "For anyone still wondering:\\nboard[2][3] stays an O because it is connected to O\\'s that are not surrounded by X\\'s. "
                    },
                    {
                        "username": "irazer19",
                        "content": "That board[2][3] is at the border because its connect to the other O\\'s (board[3][4] and board[4][2]), if you do BFS you will see the connection"
                    },
                    {
                        "username": "sr259",
                        "content": "I am having the same problem, I feel like this one should be \\'X\\' but i am not sure. Can anyone explain?"
                    },
                    {
                        "username": "tonytata",
                        "content": "What does it mean to be surrounded? Whatever I think it means, it is contradicted by the fact that the '0' on the bottom row is not changed."
                    },
                    {
                        "username": "00paradise",
                        "content": "The border cells do not have 4 adjacent cells. Therefore, we can not flip those cell in the border that contains \\'O\\' and also all adjacent cell connected to that border cell.\\n\\nSteps to perform--\\nVisit the border character. \\nIf character is \\'O\\', then mark that character as \\'P\\' or with any random character. And make a dfs call from that position to other adjacent cell where character is \\'O\\' and mark it \\'P\\'.\\n\\nAt last, assign all \\'P\\' as \\'O\\' and other cell value as \\'X\\'."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you, this made the whole problem a lot easier."
                    },
                    {
                        "username": "mczscta",
                        "content": "First things first. Clear what it means that each cell has \\'X\\' on all sides. \\'X\\' should be adjacent or can be any cells away.\\n\\nSolution 1:\\n\\tDo as the question says. For each cell, go in all directions and see if it is surrounded by \\'X\\' on all sides.\\n\\tThe complexity is O(n*n*n)\\n\\t\\nSolution 2: \\n\\tIn the above approach, we are going in all directions just to find the first occurence of \\'X\\' in that direction. Instead we can do some precomputation.\\n\\tDefine left[i][j] as the first index to left of cell(i, j) which has a \\'X\\'. Keep value as -1 if doesn\\'t exist. Similarly, define right[i][j], top[i][j] and down[i][j]. \\n\\tThe time complexity for this solution is O(n*n + n*n) = O(2*n*n) = O(n * n) and space complexity is also same.\\n\\t\\nSolution 3:\\n Notice that if a cell has \\'X\\' on all sides then it can not be reached by a series of 0\\'s that start at the border. Use this observation to do dfs from all 0\\'s at the border and mark them with \\'I\\' so as to mark invalid. After this mark all 0\\'s with X and all the \\'I\\'s back to 0. \\n The time complexity is O(n*n) and space is O(n*n) for dfs."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my mind really tripped reading O(nn) \\uD83D\\uDE16"
                    },
                    {
                        "username": "__anu__",
                        "content": "Just to save you some time, it\\'s alphabet \\'O\\' and not number \\'0\\'"
                    }
                ]
            },
            {
                "id": 1569410,
                "content": [
                    {
                        "username": "butterman1986",
                        "content": "I felt that the problem statement was difficult to understand as it and the associated example don't clearly indicate what surrounded means. An 'O' is surrounded if there is **NO** path from it to the boundary of the matrix (ie. row index 0, column index 0, row index matrix.length-1, column index matrix[0].length-1) when moving in a North, South, East, or West direction :). Hope this helps anyone else who was unclear."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thanks this hint helped me solve it easily "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/surrounded-regions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS (Depth-First Search)\n\n  \n**Approach 2:** BFS (Breadth-First Search)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mrigankshekhar27",
                        "content": "Leetcode should give more examples. I had to wast so much time running and testing different test cases. \\n And, after all of this, I learned nothing."
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "1) All the \"O\" that are not directly/indirectly connected to the \"O\" on the boundary line, will be captured and converted into \"X\"\\n2) Just traverse the matrix once, and as soon as your enounter a boundary line that has a \"O\" in it, run DFS on this \"O\" and \"Save\" all the nehgbours of this \"O\" from being captured by calling them \"S\"\\n3) Now traverse the matrix again and capture all the \"O\" that you can inside the matrix except the boundary line\\n4) Rename the \"Save\" O back to \"O\"\\n5) Done!"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "interesting, no need to bfs from the islands inside then. Just save any islands on the border."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you this was very helpful!"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Thanks man"
                    },
                    {
                        "username": "shx",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three 'o' are surrounded regions? I mean, the 'o' in the third row has another 'o' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "surrounded in means of 4 directions only top,left,bottom,right..!"
                    },
                    {
                        "username": "Yumi_C",
                        "content": "input=\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],   \\n [\"X\",\"O\",\"O\",\"X\",\"O\"],\\n [\"X\",\"O\",\"X\",\"O\",\"X\"],\\n [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nexpect =\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"X\",\"X\",\"X\",\"X\",\"O\"],\\n  [\"X\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n  [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n  \\n   since  board[2][3] does not on the boarder and does not connect to anything on the boder, it suppose to flip to \"X\" ,right? why it stay the same?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "For anyone still wondering:\\nboard[2][3] stays an O because it is connected to O\\'s that are not surrounded by X\\'s. "
                    },
                    {
                        "username": "irazer19",
                        "content": "That board[2][3] is at the border because its connect to the other O\\'s (board[3][4] and board[4][2]), if you do BFS you will see the connection"
                    },
                    {
                        "username": "sr259",
                        "content": "I am having the same problem, I feel like this one should be \\'X\\' but i am not sure. Can anyone explain?"
                    },
                    {
                        "username": "tonytata",
                        "content": "What does it mean to be surrounded? Whatever I think it means, it is contradicted by the fact that the '0' on the bottom row is not changed."
                    },
                    {
                        "username": "00paradise",
                        "content": "The border cells do not have 4 adjacent cells. Therefore, we can not flip those cell in the border that contains \\'O\\' and also all adjacent cell connected to that border cell.\\n\\nSteps to perform--\\nVisit the border character. \\nIf character is \\'O\\', then mark that character as \\'P\\' or with any random character. And make a dfs call from that position to other adjacent cell where character is \\'O\\' and mark it \\'P\\'.\\n\\nAt last, assign all \\'P\\' as \\'O\\' and other cell value as \\'X\\'."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you, this made the whole problem a lot easier."
                    },
                    {
                        "username": "mczscta",
                        "content": "First things first. Clear what it means that each cell has \\'X\\' on all sides. \\'X\\' should be adjacent or can be any cells away.\\n\\nSolution 1:\\n\\tDo as the question says. For each cell, go in all directions and see if it is surrounded by \\'X\\' on all sides.\\n\\tThe complexity is O(n*n*n)\\n\\t\\nSolution 2: \\n\\tIn the above approach, we are going in all directions just to find the first occurence of \\'X\\' in that direction. Instead we can do some precomputation.\\n\\tDefine left[i][j] as the first index to left of cell(i, j) which has a \\'X\\'. Keep value as -1 if doesn\\'t exist. Similarly, define right[i][j], top[i][j] and down[i][j]. \\n\\tThe time complexity for this solution is O(n*n + n*n) = O(2*n*n) = O(n * n) and space complexity is also same.\\n\\t\\nSolution 3:\\n Notice that if a cell has \\'X\\' on all sides then it can not be reached by a series of 0\\'s that start at the border. Use this observation to do dfs from all 0\\'s at the border and mark them with \\'I\\' so as to mark invalid. After this mark all 0\\'s with X and all the \\'I\\'s back to 0. \\n The time complexity is O(n*n) and space is O(n*n) for dfs."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my mind really tripped reading O(nn) \\uD83D\\uDE16"
                    },
                    {
                        "username": "__anu__",
                        "content": "Just to save you some time, it\\'s alphabet \\'O\\' and not number \\'0\\'"
                    }
                ]
            },
            {
                "id": 1567878,
                "content": [
                    {
                        "username": "butterman1986",
                        "content": "I felt that the problem statement was difficult to understand as it and the associated example don't clearly indicate what surrounded means. An 'O' is surrounded if there is **NO** path from it to the boundary of the matrix (ie. row index 0, column index 0, row index matrix.length-1, column index matrix[0].length-1) when moving in a North, South, East, or West direction :). Hope this helps anyone else who was unclear."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thanks this hint helped me solve it easily "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/surrounded-regions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS (Depth-First Search)\n\n  \n**Approach 2:** BFS (Breadth-First Search)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mrigankshekhar27",
                        "content": "Leetcode should give more examples. I had to wast so much time running and testing different test cases. \\n And, after all of this, I learned nothing."
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "1) All the \"O\" that are not directly/indirectly connected to the \"O\" on the boundary line, will be captured and converted into \"X\"\\n2) Just traverse the matrix once, and as soon as your enounter a boundary line that has a \"O\" in it, run DFS on this \"O\" and \"Save\" all the nehgbours of this \"O\" from being captured by calling them \"S\"\\n3) Now traverse the matrix again and capture all the \"O\" that you can inside the matrix except the boundary line\\n4) Rename the \"Save\" O back to \"O\"\\n5) Done!"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "interesting, no need to bfs from the islands inside then. Just save any islands on the border."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you this was very helpful!"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Thanks man"
                    },
                    {
                        "username": "shx",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three 'o' are surrounded regions? I mean, the 'o' in the third row has another 'o' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "surrounded in means of 4 directions only top,left,bottom,right..!"
                    },
                    {
                        "username": "Yumi_C",
                        "content": "input=\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],   \\n [\"X\",\"O\",\"O\",\"X\",\"O\"],\\n [\"X\",\"O\",\"X\",\"O\",\"X\"],\\n [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nexpect =\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"X\",\"X\",\"X\",\"X\",\"O\"],\\n  [\"X\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n  [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n  \\n   since  board[2][3] does not on the boarder and does not connect to anything on the boder, it suppose to flip to \"X\" ,right? why it stay the same?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "For anyone still wondering:\\nboard[2][3] stays an O because it is connected to O\\'s that are not surrounded by X\\'s. "
                    },
                    {
                        "username": "irazer19",
                        "content": "That board[2][3] is at the border because its connect to the other O\\'s (board[3][4] and board[4][2]), if you do BFS you will see the connection"
                    },
                    {
                        "username": "sr259",
                        "content": "I am having the same problem, I feel like this one should be \\'X\\' but i am not sure. Can anyone explain?"
                    },
                    {
                        "username": "tonytata",
                        "content": "What does it mean to be surrounded? Whatever I think it means, it is contradicted by the fact that the '0' on the bottom row is not changed."
                    },
                    {
                        "username": "00paradise",
                        "content": "The border cells do not have 4 adjacent cells. Therefore, we can not flip those cell in the border that contains \\'O\\' and also all adjacent cell connected to that border cell.\\n\\nSteps to perform--\\nVisit the border character. \\nIf character is \\'O\\', then mark that character as \\'P\\' or with any random character. And make a dfs call from that position to other adjacent cell where character is \\'O\\' and mark it \\'P\\'.\\n\\nAt last, assign all \\'P\\' as \\'O\\' and other cell value as \\'X\\'."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you, this made the whole problem a lot easier."
                    },
                    {
                        "username": "mczscta",
                        "content": "First things first. Clear what it means that each cell has \\'X\\' on all sides. \\'X\\' should be adjacent or can be any cells away.\\n\\nSolution 1:\\n\\tDo as the question says. For each cell, go in all directions and see if it is surrounded by \\'X\\' on all sides.\\n\\tThe complexity is O(n*n*n)\\n\\t\\nSolution 2: \\n\\tIn the above approach, we are going in all directions just to find the first occurence of \\'X\\' in that direction. Instead we can do some precomputation.\\n\\tDefine left[i][j] as the first index to left of cell(i, j) which has a \\'X\\'. Keep value as -1 if doesn\\'t exist. Similarly, define right[i][j], top[i][j] and down[i][j]. \\n\\tThe time complexity for this solution is O(n*n + n*n) = O(2*n*n) = O(n * n) and space complexity is also same.\\n\\t\\nSolution 3:\\n Notice that if a cell has \\'X\\' on all sides then it can not be reached by a series of 0\\'s that start at the border. Use this observation to do dfs from all 0\\'s at the border and mark them with \\'I\\' so as to mark invalid. After this mark all 0\\'s with X and all the \\'I\\'s back to 0. \\n The time complexity is O(n*n) and space is O(n*n) for dfs."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my mind really tripped reading O(nn) \\uD83D\\uDE16"
                    },
                    {
                        "username": "__anu__",
                        "content": "Just to save you some time, it\\'s alphabet \\'O\\' and not number \\'0\\'"
                    }
                ]
            },
            {
                "id": 1568600,
                "content": [
                    {
                        "username": "butterman1986",
                        "content": "I felt that the problem statement was difficult to understand as it and the associated example don't clearly indicate what surrounded means. An 'O' is surrounded if there is **NO** path from it to the boundary of the matrix (ie. row index 0, column index 0, row index matrix.length-1, column index matrix[0].length-1) when moving in a North, South, East, or West direction :). Hope this helps anyone else who was unclear."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thanks this hint helped me solve it easily "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/surrounded-regions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS (Depth-First Search)\n\n  \n**Approach 2:** BFS (Breadth-First Search)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mrigankshekhar27",
                        "content": "Leetcode should give more examples. I had to wast so much time running and testing different test cases. \\n And, after all of this, I learned nothing."
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "1) All the \"O\" that are not directly/indirectly connected to the \"O\" on the boundary line, will be captured and converted into \"X\"\\n2) Just traverse the matrix once, and as soon as your enounter a boundary line that has a \"O\" in it, run DFS on this \"O\" and \"Save\" all the nehgbours of this \"O\" from being captured by calling them \"S\"\\n3) Now traverse the matrix again and capture all the \"O\" that you can inside the matrix except the boundary line\\n4) Rename the \"Save\" O back to \"O\"\\n5) Done!"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "interesting, no need to bfs from the islands inside then. Just save any islands on the border."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you this was very helpful!"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Thanks man"
                    },
                    {
                        "username": "shx",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three 'o' are surrounded regions? I mean, the 'o' in the third row has another 'o' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "surrounded in means of 4 directions only top,left,bottom,right..!"
                    },
                    {
                        "username": "Yumi_C",
                        "content": "input=\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],   \\n [\"X\",\"O\",\"O\",\"X\",\"O\"],\\n [\"X\",\"O\",\"X\",\"O\",\"X\"],\\n [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nexpect =\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"X\",\"X\",\"X\",\"X\",\"O\"],\\n  [\"X\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n  [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n  \\n   since  board[2][3] does not on the boarder and does not connect to anything on the boder, it suppose to flip to \"X\" ,right? why it stay the same?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "For anyone still wondering:\\nboard[2][3] stays an O because it is connected to O\\'s that are not surrounded by X\\'s. "
                    },
                    {
                        "username": "irazer19",
                        "content": "That board[2][3] is at the border because its connect to the other O\\'s (board[3][4] and board[4][2]), if you do BFS you will see the connection"
                    },
                    {
                        "username": "sr259",
                        "content": "I am having the same problem, I feel like this one should be \\'X\\' but i am not sure. Can anyone explain?"
                    },
                    {
                        "username": "tonytata",
                        "content": "What does it mean to be surrounded? Whatever I think it means, it is contradicted by the fact that the '0' on the bottom row is not changed."
                    },
                    {
                        "username": "00paradise",
                        "content": "The border cells do not have 4 adjacent cells. Therefore, we can not flip those cell in the border that contains \\'O\\' and also all adjacent cell connected to that border cell.\\n\\nSteps to perform--\\nVisit the border character. \\nIf character is \\'O\\', then mark that character as \\'P\\' or with any random character. And make a dfs call from that position to other adjacent cell where character is \\'O\\' and mark it \\'P\\'.\\n\\nAt last, assign all \\'P\\' as \\'O\\' and other cell value as \\'X\\'."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you, this made the whole problem a lot easier."
                    },
                    {
                        "username": "mczscta",
                        "content": "First things first. Clear what it means that each cell has \\'X\\' on all sides. \\'X\\' should be adjacent or can be any cells away.\\n\\nSolution 1:\\n\\tDo as the question says. For each cell, go in all directions and see if it is surrounded by \\'X\\' on all sides.\\n\\tThe complexity is O(n*n*n)\\n\\t\\nSolution 2: \\n\\tIn the above approach, we are going in all directions just to find the first occurence of \\'X\\' in that direction. Instead we can do some precomputation.\\n\\tDefine left[i][j] as the first index to left of cell(i, j) which has a \\'X\\'. Keep value as -1 if doesn\\'t exist. Similarly, define right[i][j], top[i][j] and down[i][j]. \\n\\tThe time complexity for this solution is O(n*n + n*n) = O(2*n*n) = O(n * n) and space complexity is also same.\\n\\t\\nSolution 3:\\n Notice that if a cell has \\'X\\' on all sides then it can not be reached by a series of 0\\'s that start at the border. Use this observation to do dfs from all 0\\'s at the border and mark them with \\'I\\' so as to mark invalid. After this mark all 0\\'s with X and all the \\'I\\'s back to 0. \\n The time complexity is O(n*n) and space is O(n*n) for dfs."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my mind really tripped reading O(nn) \\uD83D\\uDE16"
                    },
                    {
                        "username": "__anu__",
                        "content": "Just to save you some time, it\\'s alphabet \\'O\\' and not number \\'0\\'"
                    }
                ]
            },
            {
                "id": 1568678,
                "content": [
                    {
                        "username": "butterman1986",
                        "content": "I felt that the problem statement was difficult to understand as it and the associated example don't clearly indicate what surrounded means. An 'O' is surrounded if there is **NO** path from it to the boundary of the matrix (ie. row index 0, column index 0, row index matrix.length-1, column index matrix[0].length-1) when moving in a North, South, East, or West direction :). Hope this helps anyone else who was unclear."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thanks this hint helped me solve it easily "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/surrounded-regions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS (Depth-First Search)\n\n  \n**Approach 2:** BFS (Breadth-First Search)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mrigankshekhar27",
                        "content": "Leetcode should give more examples. I had to wast so much time running and testing different test cases. \\n And, after all of this, I learned nothing."
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "1) All the \"O\" that are not directly/indirectly connected to the \"O\" on the boundary line, will be captured and converted into \"X\"\\n2) Just traverse the matrix once, and as soon as your enounter a boundary line that has a \"O\" in it, run DFS on this \"O\" and \"Save\" all the nehgbours of this \"O\" from being captured by calling them \"S\"\\n3) Now traverse the matrix again and capture all the \"O\" that you can inside the matrix except the boundary line\\n4) Rename the \"Save\" O back to \"O\"\\n5) Done!"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "interesting, no need to bfs from the islands inside then. Just save any islands on the border."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you this was very helpful!"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Thanks man"
                    },
                    {
                        "username": "shx",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three 'o' are surrounded regions? I mean, the 'o' in the third row has another 'o' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "surrounded in means of 4 directions only top,left,bottom,right..!"
                    },
                    {
                        "username": "Yumi_C",
                        "content": "input=\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],   \\n [\"X\",\"O\",\"O\",\"X\",\"O\"],\\n [\"X\",\"O\",\"X\",\"O\",\"X\"],\\n [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nexpect =\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"X\",\"X\",\"X\",\"X\",\"O\"],\\n  [\"X\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n  [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n  \\n   since  board[2][3] does not on the boarder and does not connect to anything on the boder, it suppose to flip to \"X\" ,right? why it stay the same?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "For anyone still wondering:\\nboard[2][3] stays an O because it is connected to O\\'s that are not surrounded by X\\'s. "
                    },
                    {
                        "username": "irazer19",
                        "content": "That board[2][3] is at the border because its connect to the other O\\'s (board[3][4] and board[4][2]), if you do BFS you will see the connection"
                    },
                    {
                        "username": "sr259",
                        "content": "I am having the same problem, I feel like this one should be \\'X\\' but i am not sure. Can anyone explain?"
                    },
                    {
                        "username": "tonytata",
                        "content": "What does it mean to be surrounded? Whatever I think it means, it is contradicted by the fact that the '0' on the bottom row is not changed."
                    },
                    {
                        "username": "00paradise",
                        "content": "The border cells do not have 4 adjacent cells. Therefore, we can not flip those cell in the border that contains \\'O\\' and also all adjacent cell connected to that border cell.\\n\\nSteps to perform--\\nVisit the border character. \\nIf character is \\'O\\', then mark that character as \\'P\\' or with any random character. And make a dfs call from that position to other adjacent cell where character is \\'O\\' and mark it \\'P\\'.\\n\\nAt last, assign all \\'P\\' as \\'O\\' and other cell value as \\'X\\'."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you, this made the whole problem a lot easier."
                    },
                    {
                        "username": "mczscta",
                        "content": "First things first. Clear what it means that each cell has \\'X\\' on all sides. \\'X\\' should be adjacent or can be any cells away.\\n\\nSolution 1:\\n\\tDo as the question says. For each cell, go in all directions and see if it is surrounded by \\'X\\' on all sides.\\n\\tThe complexity is O(n*n*n)\\n\\t\\nSolution 2: \\n\\tIn the above approach, we are going in all directions just to find the first occurence of \\'X\\' in that direction. Instead we can do some precomputation.\\n\\tDefine left[i][j] as the first index to left of cell(i, j) which has a \\'X\\'. Keep value as -1 if doesn\\'t exist. Similarly, define right[i][j], top[i][j] and down[i][j]. \\n\\tThe time complexity for this solution is O(n*n + n*n) = O(2*n*n) = O(n * n) and space complexity is also same.\\n\\t\\nSolution 3:\\n Notice that if a cell has \\'X\\' on all sides then it can not be reached by a series of 0\\'s that start at the border. Use this observation to do dfs from all 0\\'s at the border and mark them with \\'I\\' so as to mark invalid. After this mark all 0\\'s with X and all the \\'I\\'s back to 0. \\n The time complexity is O(n*n) and space is O(n*n) for dfs."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my mind really tripped reading O(nn) \\uD83D\\uDE16"
                    },
                    {
                        "username": "__anu__",
                        "content": "Just to save you some time, it\\'s alphabet \\'O\\' and not number \\'0\\'"
                    }
                ]
            },
            {
                "id": 1762007,
                "content": [
                    {
                        "username": "butterman1986",
                        "content": "I felt that the problem statement was difficult to understand as it and the associated example don't clearly indicate what surrounded means. An 'O' is surrounded if there is **NO** path from it to the boundary of the matrix (ie. row index 0, column index 0, row index matrix.length-1, column index matrix[0].length-1) when moving in a North, South, East, or West direction :). Hope this helps anyone else who was unclear."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thanks this hint helped me solve it easily "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/surrounded-regions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS (Depth-First Search)\n\n  \n**Approach 2:** BFS (Breadth-First Search)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mrigankshekhar27",
                        "content": "Leetcode should give more examples. I had to wast so much time running and testing different test cases. \\n And, after all of this, I learned nothing."
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "1) All the \"O\" that are not directly/indirectly connected to the \"O\" on the boundary line, will be captured and converted into \"X\"\\n2) Just traverse the matrix once, and as soon as your enounter a boundary line that has a \"O\" in it, run DFS on this \"O\" and \"Save\" all the nehgbours of this \"O\" from being captured by calling them \"S\"\\n3) Now traverse the matrix again and capture all the \"O\" that you can inside the matrix except the boundary line\\n4) Rename the \"Save\" O back to \"O\"\\n5) Done!"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "interesting, no need to bfs from the islands inside then. Just save any islands on the border."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you this was very helpful!"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Thanks man"
                    },
                    {
                        "username": "shx",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three 'o' are surrounded regions? I mean, the 'o' in the third row has another 'o' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "surrounded in means of 4 directions only top,left,bottom,right..!"
                    },
                    {
                        "username": "Yumi_C",
                        "content": "input=\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],   \\n [\"X\",\"O\",\"O\",\"X\",\"O\"],\\n [\"X\",\"O\",\"X\",\"O\",\"X\"],\\n [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nexpect =\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"X\",\"X\",\"X\",\"X\",\"O\"],\\n  [\"X\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n  [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n  \\n   since  board[2][3] does not on the boarder and does not connect to anything on the boder, it suppose to flip to \"X\" ,right? why it stay the same?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "For anyone still wondering:\\nboard[2][3] stays an O because it is connected to O\\'s that are not surrounded by X\\'s. "
                    },
                    {
                        "username": "irazer19",
                        "content": "That board[2][3] is at the border because its connect to the other O\\'s (board[3][4] and board[4][2]), if you do BFS you will see the connection"
                    },
                    {
                        "username": "sr259",
                        "content": "I am having the same problem, I feel like this one should be \\'X\\' but i am not sure. Can anyone explain?"
                    },
                    {
                        "username": "tonytata",
                        "content": "What does it mean to be surrounded? Whatever I think it means, it is contradicted by the fact that the '0' on the bottom row is not changed."
                    },
                    {
                        "username": "00paradise",
                        "content": "The border cells do not have 4 adjacent cells. Therefore, we can not flip those cell in the border that contains \\'O\\' and also all adjacent cell connected to that border cell.\\n\\nSteps to perform--\\nVisit the border character. \\nIf character is \\'O\\', then mark that character as \\'P\\' or with any random character. And make a dfs call from that position to other adjacent cell where character is \\'O\\' and mark it \\'P\\'.\\n\\nAt last, assign all \\'P\\' as \\'O\\' and other cell value as \\'X\\'."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you, this made the whole problem a lot easier."
                    },
                    {
                        "username": "mczscta",
                        "content": "First things first. Clear what it means that each cell has \\'X\\' on all sides. \\'X\\' should be adjacent or can be any cells away.\\n\\nSolution 1:\\n\\tDo as the question says. For each cell, go in all directions and see if it is surrounded by \\'X\\' on all sides.\\n\\tThe complexity is O(n*n*n)\\n\\t\\nSolution 2: \\n\\tIn the above approach, we are going in all directions just to find the first occurence of \\'X\\' in that direction. Instead we can do some precomputation.\\n\\tDefine left[i][j] as the first index to left of cell(i, j) which has a \\'X\\'. Keep value as -1 if doesn\\'t exist. Similarly, define right[i][j], top[i][j] and down[i][j]. \\n\\tThe time complexity for this solution is O(n*n + n*n) = O(2*n*n) = O(n * n) and space complexity is also same.\\n\\t\\nSolution 3:\\n Notice that if a cell has \\'X\\' on all sides then it can not be reached by a series of 0\\'s that start at the border. Use this observation to do dfs from all 0\\'s at the border and mark them with \\'I\\' so as to mark invalid. After this mark all 0\\'s with X and all the \\'I\\'s back to 0. \\n The time complexity is O(n*n) and space is O(n*n) for dfs."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my mind really tripped reading O(nn) \\uD83D\\uDE16"
                    },
                    {
                        "username": "__anu__",
                        "content": "Just to save you some time, it\\'s alphabet \\'O\\' and not number \\'0\\'"
                    }
                ]
            },
            {
                "id": 1564696,
                "content": [
                    {
                        "username": "butterman1986",
                        "content": "I felt that the problem statement was difficult to understand as it and the associated example don't clearly indicate what surrounded means. An 'O' is surrounded if there is **NO** path from it to the boundary of the matrix (ie. row index 0, column index 0, row index matrix.length-1, column index matrix[0].length-1) when moving in a North, South, East, or West direction :). Hope this helps anyone else who was unclear."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thanks this hint helped me solve it easily "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/surrounded-regions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS (Depth-First Search)\n\n  \n**Approach 2:** BFS (Breadth-First Search)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mrigankshekhar27",
                        "content": "Leetcode should give more examples. I had to wast so much time running and testing different test cases. \\n And, after all of this, I learned nothing."
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "1) All the \"O\" that are not directly/indirectly connected to the \"O\" on the boundary line, will be captured and converted into \"X\"\\n2) Just traverse the matrix once, and as soon as your enounter a boundary line that has a \"O\" in it, run DFS on this \"O\" and \"Save\" all the nehgbours of this \"O\" from being captured by calling them \"S\"\\n3) Now traverse the matrix again and capture all the \"O\" that you can inside the matrix except the boundary line\\n4) Rename the \"Save\" O back to \"O\"\\n5) Done!"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "interesting, no need to bfs from the islands inside then. Just save any islands on the border."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you this was very helpful!"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Thanks man"
                    },
                    {
                        "username": "shx",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three 'o' are surrounded regions? I mean, the 'o' in the third row has another 'o' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "surrounded in means of 4 directions only top,left,bottom,right..!"
                    },
                    {
                        "username": "Yumi_C",
                        "content": "input=\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],   \\n [\"X\",\"O\",\"O\",\"X\",\"O\"],\\n [\"X\",\"O\",\"X\",\"O\",\"X\"],\\n [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nexpect =\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"X\",\"X\",\"X\",\"X\",\"O\"],\\n  [\"X\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n  [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n  \\n   since  board[2][3] does not on the boarder and does not connect to anything on the boder, it suppose to flip to \"X\" ,right? why it stay the same?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "For anyone still wondering:\\nboard[2][3] stays an O because it is connected to O\\'s that are not surrounded by X\\'s. "
                    },
                    {
                        "username": "irazer19",
                        "content": "That board[2][3] is at the border because its connect to the other O\\'s (board[3][4] and board[4][2]), if you do BFS you will see the connection"
                    },
                    {
                        "username": "sr259",
                        "content": "I am having the same problem, I feel like this one should be \\'X\\' but i am not sure. Can anyone explain?"
                    },
                    {
                        "username": "tonytata",
                        "content": "What does it mean to be surrounded? Whatever I think it means, it is contradicted by the fact that the '0' on the bottom row is not changed."
                    },
                    {
                        "username": "00paradise",
                        "content": "The border cells do not have 4 adjacent cells. Therefore, we can not flip those cell in the border that contains \\'O\\' and also all adjacent cell connected to that border cell.\\n\\nSteps to perform--\\nVisit the border character. \\nIf character is \\'O\\', then mark that character as \\'P\\' or with any random character. And make a dfs call from that position to other adjacent cell where character is \\'O\\' and mark it \\'P\\'.\\n\\nAt last, assign all \\'P\\' as \\'O\\' and other cell value as \\'X\\'."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you, this made the whole problem a lot easier."
                    },
                    {
                        "username": "mczscta",
                        "content": "First things first. Clear what it means that each cell has \\'X\\' on all sides. \\'X\\' should be adjacent or can be any cells away.\\n\\nSolution 1:\\n\\tDo as the question says. For each cell, go in all directions and see if it is surrounded by \\'X\\' on all sides.\\n\\tThe complexity is O(n*n*n)\\n\\t\\nSolution 2: \\n\\tIn the above approach, we are going in all directions just to find the first occurence of \\'X\\' in that direction. Instead we can do some precomputation.\\n\\tDefine left[i][j] as the first index to left of cell(i, j) which has a \\'X\\'. Keep value as -1 if doesn\\'t exist. Similarly, define right[i][j], top[i][j] and down[i][j]. \\n\\tThe time complexity for this solution is O(n*n + n*n) = O(2*n*n) = O(n * n) and space complexity is also same.\\n\\t\\nSolution 3:\\n Notice that if a cell has \\'X\\' on all sides then it can not be reached by a series of 0\\'s that start at the border. Use this observation to do dfs from all 0\\'s at the border and mark them with \\'I\\' so as to mark invalid. After this mark all 0\\'s with X and all the \\'I\\'s back to 0. \\n The time complexity is O(n*n) and space is O(n*n) for dfs."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my mind really tripped reading O(nn) \\uD83D\\uDE16"
                    },
                    {
                        "username": "__anu__",
                        "content": "Just to save you some time, it\\'s alphabet \\'O\\' and not number \\'0\\'"
                    }
                ]
            },
            {
                "id": 1564736,
                "content": [
                    {
                        "username": "butterman1986",
                        "content": "I felt that the problem statement was difficult to understand as it and the associated example don't clearly indicate what surrounded means. An 'O' is surrounded if there is **NO** path from it to the boundary of the matrix (ie. row index 0, column index 0, row index matrix.length-1, column index matrix[0].length-1) when moving in a North, South, East, or West direction :). Hope this helps anyone else who was unclear."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thanks this hint helped me solve it easily "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/surrounded-regions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS (Depth-First Search)\n\n  \n**Approach 2:** BFS (Breadth-First Search)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mrigankshekhar27",
                        "content": "Leetcode should give more examples. I had to wast so much time running and testing different test cases. \\n And, after all of this, I learned nothing."
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "1) All the \"O\" that are not directly/indirectly connected to the \"O\" on the boundary line, will be captured and converted into \"X\"\\n2) Just traverse the matrix once, and as soon as your enounter a boundary line that has a \"O\" in it, run DFS on this \"O\" and \"Save\" all the nehgbours of this \"O\" from being captured by calling them \"S\"\\n3) Now traverse the matrix again and capture all the \"O\" that you can inside the matrix except the boundary line\\n4) Rename the \"Save\" O back to \"O\"\\n5) Done!"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "interesting, no need to bfs from the islands inside then. Just save any islands on the border."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you this was very helpful!"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Thanks man"
                    },
                    {
                        "username": "shx",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three 'o' are surrounded regions? I mean, the 'o' in the third row has another 'o' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "surrounded in means of 4 directions only top,left,bottom,right..!"
                    },
                    {
                        "username": "Yumi_C",
                        "content": "input=\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],   \\n [\"X\",\"O\",\"O\",\"X\",\"O\"],\\n [\"X\",\"O\",\"X\",\"O\",\"X\"],\\n [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nexpect =\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"X\",\"X\",\"X\",\"X\",\"O\"],\\n  [\"X\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n  [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n  \\n   since  board[2][3] does not on the boarder and does not connect to anything on the boder, it suppose to flip to \"X\" ,right? why it stay the same?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "For anyone still wondering:\\nboard[2][3] stays an O because it is connected to O\\'s that are not surrounded by X\\'s. "
                    },
                    {
                        "username": "irazer19",
                        "content": "That board[2][3] is at the border because its connect to the other O\\'s (board[3][4] and board[4][2]), if you do BFS you will see the connection"
                    },
                    {
                        "username": "sr259",
                        "content": "I am having the same problem, I feel like this one should be \\'X\\' but i am not sure. Can anyone explain?"
                    },
                    {
                        "username": "tonytata",
                        "content": "What does it mean to be surrounded? Whatever I think it means, it is contradicted by the fact that the '0' on the bottom row is not changed."
                    },
                    {
                        "username": "00paradise",
                        "content": "The border cells do not have 4 adjacent cells. Therefore, we can not flip those cell in the border that contains \\'O\\' and also all adjacent cell connected to that border cell.\\n\\nSteps to perform--\\nVisit the border character. \\nIf character is \\'O\\', then mark that character as \\'P\\' or with any random character. And make a dfs call from that position to other adjacent cell where character is \\'O\\' and mark it \\'P\\'.\\n\\nAt last, assign all \\'P\\' as \\'O\\' and other cell value as \\'X\\'."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you, this made the whole problem a lot easier."
                    },
                    {
                        "username": "mczscta",
                        "content": "First things first. Clear what it means that each cell has \\'X\\' on all sides. \\'X\\' should be adjacent or can be any cells away.\\n\\nSolution 1:\\n\\tDo as the question says. For each cell, go in all directions and see if it is surrounded by \\'X\\' on all sides.\\n\\tThe complexity is O(n*n*n)\\n\\t\\nSolution 2: \\n\\tIn the above approach, we are going in all directions just to find the first occurence of \\'X\\' in that direction. Instead we can do some precomputation.\\n\\tDefine left[i][j] as the first index to left of cell(i, j) which has a \\'X\\'. Keep value as -1 if doesn\\'t exist. Similarly, define right[i][j], top[i][j] and down[i][j]. \\n\\tThe time complexity for this solution is O(n*n + n*n) = O(2*n*n) = O(n * n) and space complexity is also same.\\n\\t\\nSolution 3:\\n Notice that if a cell has \\'X\\' on all sides then it can not be reached by a series of 0\\'s that start at the border. Use this observation to do dfs from all 0\\'s at the border and mark them with \\'I\\' so as to mark invalid. After this mark all 0\\'s with X and all the \\'I\\'s back to 0. \\n The time complexity is O(n*n) and space is O(n*n) for dfs."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my mind really tripped reading O(nn) \\uD83D\\uDE16"
                    },
                    {
                        "username": "__anu__",
                        "content": "Just to save you some time, it\\'s alphabet \\'O\\' and not number \\'0\\'"
                    }
                ]
            },
            {
                "id": 1566583,
                "content": [
                    {
                        "username": "butterman1986",
                        "content": "I felt that the problem statement was difficult to understand as it and the associated example don't clearly indicate what surrounded means. An 'O' is surrounded if there is **NO** path from it to the boundary of the matrix (ie. row index 0, column index 0, row index matrix.length-1, column index matrix[0].length-1) when moving in a North, South, East, or West direction :). Hope this helps anyone else who was unclear."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thanks this hint helped me solve it easily "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/surrounded-regions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS (Depth-First Search)\n\n  \n**Approach 2:** BFS (Breadth-First Search)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mrigankshekhar27",
                        "content": "Leetcode should give more examples. I had to wast so much time running and testing different test cases. \\n And, after all of this, I learned nothing."
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "1) All the \"O\" that are not directly/indirectly connected to the \"O\" on the boundary line, will be captured and converted into \"X\"\\n2) Just traverse the matrix once, and as soon as your enounter a boundary line that has a \"O\" in it, run DFS on this \"O\" and \"Save\" all the nehgbours of this \"O\" from being captured by calling them \"S\"\\n3) Now traverse the matrix again and capture all the \"O\" that you can inside the matrix except the boundary line\\n4) Rename the \"Save\" O back to \"O\"\\n5) Done!"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "interesting, no need to bfs from the islands inside then. Just save any islands on the border."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you this was very helpful!"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Thanks man"
                    },
                    {
                        "username": "shx",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three 'o' are surrounded regions? I mean, the 'o' in the third row has another 'o' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "surrounded in means of 4 directions only top,left,bottom,right..!"
                    },
                    {
                        "username": "Yumi_C",
                        "content": "input=\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],   \\n [\"X\",\"O\",\"O\",\"X\",\"O\"],\\n [\"X\",\"O\",\"X\",\"O\",\"X\"],\\n [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nexpect =\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"X\",\"X\",\"X\",\"X\",\"O\"],\\n  [\"X\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n  [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n  \\n   since  board[2][3] does not on the boarder and does not connect to anything on the boder, it suppose to flip to \"X\" ,right? why it stay the same?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "For anyone still wondering:\\nboard[2][3] stays an O because it is connected to O\\'s that are not surrounded by X\\'s. "
                    },
                    {
                        "username": "irazer19",
                        "content": "That board[2][3] is at the border because its connect to the other O\\'s (board[3][4] and board[4][2]), if you do BFS you will see the connection"
                    },
                    {
                        "username": "sr259",
                        "content": "I am having the same problem, I feel like this one should be \\'X\\' but i am not sure. Can anyone explain?"
                    },
                    {
                        "username": "tonytata",
                        "content": "What does it mean to be surrounded? Whatever I think it means, it is contradicted by the fact that the '0' on the bottom row is not changed."
                    },
                    {
                        "username": "00paradise",
                        "content": "The border cells do not have 4 adjacent cells. Therefore, we can not flip those cell in the border that contains \\'O\\' and also all adjacent cell connected to that border cell.\\n\\nSteps to perform--\\nVisit the border character. \\nIf character is \\'O\\', then mark that character as \\'P\\' or with any random character. And make a dfs call from that position to other adjacent cell where character is \\'O\\' and mark it \\'P\\'.\\n\\nAt last, assign all \\'P\\' as \\'O\\' and other cell value as \\'X\\'."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you, this made the whole problem a lot easier."
                    },
                    {
                        "username": "mczscta",
                        "content": "First things first. Clear what it means that each cell has \\'X\\' on all sides. \\'X\\' should be adjacent or can be any cells away.\\n\\nSolution 1:\\n\\tDo as the question says. For each cell, go in all directions and see if it is surrounded by \\'X\\' on all sides.\\n\\tThe complexity is O(n*n*n)\\n\\t\\nSolution 2: \\n\\tIn the above approach, we are going in all directions just to find the first occurence of \\'X\\' in that direction. Instead we can do some precomputation.\\n\\tDefine left[i][j] as the first index to left of cell(i, j) which has a \\'X\\'. Keep value as -1 if doesn\\'t exist. Similarly, define right[i][j], top[i][j] and down[i][j]. \\n\\tThe time complexity for this solution is O(n*n + n*n) = O(2*n*n) = O(n * n) and space complexity is also same.\\n\\t\\nSolution 3:\\n Notice that if a cell has \\'X\\' on all sides then it can not be reached by a series of 0\\'s that start at the border. Use this observation to do dfs from all 0\\'s at the border and mark them with \\'I\\' so as to mark invalid. After this mark all 0\\'s with X and all the \\'I\\'s back to 0. \\n The time complexity is O(n*n) and space is O(n*n) for dfs."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my mind really tripped reading O(nn) \\uD83D\\uDE16"
                    },
                    {
                        "username": "__anu__",
                        "content": "Just to save you some time, it\\'s alphabet \\'O\\' and not number \\'0\\'"
                    }
                ]
            },
            {
                "id": 1570621,
                "content": [
                    {
                        "username": "butterman1986",
                        "content": "I felt that the problem statement was difficult to understand as it and the associated example don't clearly indicate what surrounded means. An 'O' is surrounded if there is **NO** path from it to the boundary of the matrix (ie. row index 0, column index 0, row index matrix.length-1, column index matrix[0].length-1) when moving in a North, South, East, or West direction :). Hope this helps anyone else who was unclear."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thanks this hint helped me solve it easily "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/surrounded-regions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS (Depth-First Search)\n\n  \n**Approach 2:** BFS (Breadth-First Search)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mrigankshekhar27",
                        "content": "Leetcode should give more examples. I had to wast so much time running and testing different test cases. \\n And, after all of this, I learned nothing."
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "1) All the \"O\" that are not directly/indirectly connected to the \"O\" on the boundary line, will be captured and converted into \"X\"\\n2) Just traverse the matrix once, and as soon as your enounter a boundary line that has a \"O\" in it, run DFS on this \"O\" and \"Save\" all the nehgbours of this \"O\" from being captured by calling them \"S\"\\n3) Now traverse the matrix again and capture all the \"O\" that you can inside the matrix except the boundary line\\n4) Rename the \"Save\" O back to \"O\"\\n5) Done!"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "interesting, no need to bfs from the islands inside then. Just save any islands on the border."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you this was very helpful!"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Thanks man"
                    },
                    {
                        "username": "shx",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three 'o' are surrounded regions? I mean, the 'o' in the third row has another 'o' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "surrounded in means of 4 directions only top,left,bottom,right..!"
                    },
                    {
                        "username": "Yumi_C",
                        "content": "input=\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],   \\n [\"X\",\"O\",\"O\",\"X\",\"O\"],\\n [\"X\",\"O\",\"X\",\"O\",\"X\"],\\n [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nexpect =\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"X\",\"X\",\"X\",\"X\",\"O\"],\\n  [\"X\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n  [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n  \\n   since  board[2][3] does not on the boarder and does not connect to anything on the boder, it suppose to flip to \"X\" ,right? why it stay the same?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "For anyone still wondering:\\nboard[2][3] stays an O because it is connected to O\\'s that are not surrounded by X\\'s. "
                    },
                    {
                        "username": "irazer19",
                        "content": "That board[2][3] is at the border because its connect to the other O\\'s (board[3][4] and board[4][2]), if you do BFS you will see the connection"
                    },
                    {
                        "username": "sr259",
                        "content": "I am having the same problem, I feel like this one should be \\'X\\' but i am not sure. Can anyone explain?"
                    },
                    {
                        "username": "tonytata",
                        "content": "What does it mean to be surrounded? Whatever I think it means, it is contradicted by the fact that the '0' on the bottom row is not changed."
                    },
                    {
                        "username": "00paradise",
                        "content": "The border cells do not have 4 adjacent cells. Therefore, we can not flip those cell in the border that contains \\'O\\' and also all adjacent cell connected to that border cell.\\n\\nSteps to perform--\\nVisit the border character. \\nIf character is \\'O\\', then mark that character as \\'P\\' or with any random character. And make a dfs call from that position to other adjacent cell where character is \\'O\\' and mark it \\'P\\'.\\n\\nAt last, assign all \\'P\\' as \\'O\\' and other cell value as \\'X\\'."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you, this made the whole problem a lot easier."
                    },
                    {
                        "username": "mczscta",
                        "content": "First things first. Clear what it means that each cell has \\'X\\' on all sides. \\'X\\' should be adjacent or can be any cells away.\\n\\nSolution 1:\\n\\tDo as the question says. For each cell, go in all directions and see if it is surrounded by \\'X\\' on all sides.\\n\\tThe complexity is O(n*n*n)\\n\\t\\nSolution 2: \\n\\tIn the above approach, we are going in all directions just to find the first occurence of \\'X\\' in that direction. Instead we can do some precomputation.\\n\\tDefine left[i][j] as the first index to left of cell(i, j) which has a \\'X\\'. Keep value as -1 if doesn\\'t exist. Similarly, define right[i][j], top[i][j] and down[i][j]. \\n\\tThe time complexity for this solution is O(n*n + n*n) = O(2*n*n) = O(n * n) and space complexity is also same.\\n\\t\\nSolution 3:\\n Notice that if a cell has \\'X\\' on all sides then it can not be reached by a series of 0\\'s that start at the border. Use this observation to do dfs from all 0\\'s at the border and mark them with \\'I\\' so as to mark invalid. After this mark all 0\\'s with X and all the \\'I\\'s back to 0. \\n The time complexity is O(n*n) and space is O(n*n) for dfs."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my mind really tripped reading O(nn) \\uD83D\\uDE16"
                    },
                    {
                        "username": "__anu__",
                        "content": "Just to save you some time, it\\'s alphabet \\'O\\' and not number \\'0\\'"
                    }
                ]
            },
            {
                "id": 1565427,
                "content": [
                    {
                        "username": "butterman1986",
                        "content": "I felt that the problem statement was difficult to understand as it and the associated example don't clearly indicate what surrounded means. An 'O' is surrounded if there is **NO** path from it to the boundary of the matrix (ie. row index 0, column index 0, row index matrix.length-1, column index matrix[0].length-1) when moving in a North, South, East, or West direction :). Hope this helps anyone else who was unclear."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thanks this hint helped me solve it easily "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/surrounded-regions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS (Depth-First Search)\n\n  \n**Approach 2:** BFS (Breadth-First Search)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mrigankshekhar27",
                        "content": "Leetcode should give more examples. I had to wast so much time running and testing different test cases. \\n And, after all of this, I learned nothing."
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "1) All the \"O\" that are not directly/indirectly connected to the \"O\" on the boundary line, will be captured and converted into \"X\"\\n2) Just traverse the matrix once, and as soon as your enounter a boundary line that has a \"O\" in it, run DFS on this \"O\" and \"Save\" all the nehgbours of this \"O\" from being captured by calling them \"S\"\\n3) Now traverse the matrix again and capture all the \"O\" that you can inside the matrix except the boundary line\\n4) Rename the \"Save\" O back to \"O\"\\n5) Done!"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "interesting, no need to bfs from the islands inside then. Just save any islands on the border."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you this was very helpful!"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Thanks man"
                    },
                    {
                        "username": "shx",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three 'o' are surrounded regions? I mean, the 'o' in the third row has another 'o' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "surrounded in means of 4 directions only top,left,bottom,right..!"
                    },
                    {
                        "username": "Yumi_C",
                        "content": "input=\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],   \\n [\"X\",\"O\",\"O\",\"X\",\"O\"],\\n [\"X\",\"O\",\"X\",\"O\",\"X\"],\\n [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nexpect =\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"X\",\"X\",\"X\",\"X\",\"O\"],\\n  [\"X\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n  [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n  \\n   since  board[2][3] does not on the boarder and does not connect to anything on the boder, it suppose to flip to \"X\" ,right? why it stay the same?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "For anyone still wondering:\\nboard[2][3] stays an O because it is connected to O\\'s that are not surrounded by X\\'s. "
                    },
                    {
                        "username": "irazer19",
                        "content": "That board[2][3] is at the border because its connect to the other O\\'s (board[3][4] and board[4][2]), if you do BFS you will see the connection"
                    },
                    {
                        "username": "sr259",
                        "content": "I am having the same problem, I feel like this one should be \\'X\\' but i am not sure. Can anyone explain?"
                    },
                    {
                        "username": "tonytata",
                        "content": "What does it mean to be surrounded? Whatever I think it means, it is contradicted by the fact that the '0' on the bottom row is not changed."
                    },
                    {
                        "username": "00paradise",
                        "content": "The border cells do not have 4 adjacent cells. Therefore, we can not flip those cell in the border that contains \\'O\\' and also all adjacent cell connected to that border cell.\\n\\nSteps to perform--\\nVisit the border character. \\nIf character is \\'O\\', then mark that character as \\'P\\' or with any random character. And make a dfs call from that position to other adjacent cell where character is \\'O\\' and mark it \\'P\\'.\\n\\nAt last, assign all \\'P\\' as \\'O\\' and other cell value as \\'X\\'."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you, this made the whole problem a lot easier."
                    },
                    {
                        "username": "mczscta",
                        "content": "First things first. Clear what it means that each cell has \\'X\\' on all sides. \\'X\\' should be adjacent or can be any cells away.\\n\\nSolution 1:\\n\\tDo as the question says. For each cell, go in all directions and see if it is surrounded by \\'X\\' on all sides.\\n\\tThe complexity is O(n*n*n)\\n\\t\\nSolution 2: \\n\\tIn the above approach, we are going in all directions just to find the first occurence of \\'X\\' in that direction. Instead we can do some precomputation.\\n\\tDefine left[i][j] as the first index to left of cell(i, j) which has a \\'X\\'. Keep value as -1 if doesn\\'t exist. Similarly, define right[i][j], top[i][j] and down[i][j]. \\n\\tThe time complexity for this solution is O(n*n + n*n) = O(2*n*n) = O(n * n) and space complexity is also same.\\n\\t\\nSolution 3:\\n Notice that if a cell has \\'X\\' on all sides then it can not be reached by a series of 0\\'s that start at the border. Use this observation to do dfs from all 0\\'s at the border and mark them with \\'I\\' so as to mark invalid. After this mark all 0\\'s with X and all the \\'I\\'s back to 0. \\n The time complexity is O(n*n) and space is O(n*n) for dfs."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my mind really tripped reading O(nn) \\uD83D\\uDE16"
                    },
                    {
                        "username": "__anu__",
                        "content": "Just to save you some time, it\\'s alphabet \\'O\\' and not number \\'0\\'"
                    }
                ]
            },
            {
                "id": 1569410,
                "content": [
                    {
                        "username": "butterman1986",
                        "content": "I felt that the problem statement was difficult to understand as it and the associated example don't clearly indicate what surrounded means. An 'O' is surrounded if there is **NO** path from it to the boundary of the matrix (ie. row index 0, column index 0, row index matrix.length-1, column index matrix[0].length-1) when moving in a North, South, East, or West direction :). Hope this helps anyone else who was unclear."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thanks this hint helped me solve it easily "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/surrounded-regions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS (Depth-First Search)\n\n  \n**Approach 2:** BFS (Breadth-First Search)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mrigankshekhar27",
                        "content": "Leetcode should give more examples. I had to wast so much time running and testing different test cases. \\n And, after all of this, I learned nothing."
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "1) All the \"O\" that are not directly/indirectly connected to the \"O\" on the boundary line, will be captured and converted into \"X\"\\n2) Just traverse the matrix once, and as soon as your enounter a boundary line that has a \"O\" in it, run DFS on this \"O\" and \"Save\" all the nehgbours of this \"O\" from being captured by calling them \"S\"\\n3) Now traverse the matrix again and capture all the \"O\" that you can inside the matrix except the boundary line\\n4) Rename the \"Save\" O back to \"O\"\\n5) Done!"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "interesting, no need to bfs from the islands inside then. Just save any islands on the border."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you this was very helpful!"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Thanks man"
                    },
                    {
                        "username": "shx",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three 'o' are surrounded regions? I mean, the 'o' in the third row has another 'o' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "surrounded in means of 4 directions only top,left,bottom,right..!"
                    },
                    {
                        "username": "Yumi_C",
                        "content": "input=\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],   \\n [\"X\",\"O\",\"O\",\"X\",\"O\"],\\n [\"X\",\"O\",\"X\",\"O\",\"X\"],\\n [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nexpect =\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"X\",\"X\",\"X\",\"X\",\"O\"],\\n  [\"X\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n  [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n  \\n   since  board[2][3] does not on the boarder and does not connect to anything on the boder, it suppose to flip to \"X\" ,right? why it stay the same?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "For anyone still wondering:\\nboard[2][3] stays an O because it is connected to O\\'s that are not surrounded by X\\'s. "
                    },
                    {
                        "username": "irazer19",
                        "content": "That board[2][3] is at the border because its connect to the other O\\'s (board[3][4] and board[4][2]), if you do BFS you will see the connection"
                    },
                    {
                        "username": "sr259",
                        "content": "I am having the same problem, I feel like this one should be \\'X\\' but i am not sure. Can anyone explain?"
                    },
                    {
                        "username": "tonytata",
                        "content": "What does it mean to be surrounded? Whatever I think it means, it is contradicted by the fact that the '0' on the bottom row is not changed."
                    },
                    {
                        "username": "00paradise",
                        "content": "The border cells do not have 4 adjacent cells. Therefore, we can not flip those cell in the border that contains \\'O\\' and also all adjacent cell connected to that border cell.\\n\\nSteps to perform--\\nVisit the border character. \\nIf character is \\'O\\', then mark that character as \\'P\\' or with any random character. And make a dfs call from that position to other adjacent cell where character is \\'O\\' and mark it \\'P\\'.\\n\\nAt last, assign all \\'P\\' as \\'O\\' and other cell value as \\'X\\'."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you, this made the whole problem a lot easier."
                    },
                    {
                        "username": "mczscta",
                        "content": "First things first. Clear what it means that each cell has \\'X\\' on all sides. \\'X\\' should be adjacent or can be any cells away.\\n\\nSolution 1:\\n\\tDo as the question says. For each cell, go in all directions and see if it is surrounded by \\'X\\' on all sides.\\n\\tThe complexity is O(n*n*n)\\n\\t\\nSolution 2: \\n\\tIn the above approach, we are going in all directions just to find the first occurence of \\'X\\' in that direction. Instead we can do some precomputation.\\n\\tDefine left[i][j] as the first index to left of cell(i, j) which has a \\'X\\'. Keep value as -1 if doesn\\'t exist. Similarly, define right[i][j], top[i][j] and down[i][j]. \\n\\tThe time complexity for this solution is O(n*n + n*n) = O(2*n*n) = O(n * n) and space complexity is also same.\\n\\t\\nSolution 3:\\n Notice that if a cell has \\'X\\' on all sides then it can not be reached by a series of 0\\'s that start at the border. Use this observation to do dfs from all 0\\'s at the border and mark them with \\'I\\' so as to mark invalid. After this mark all 0\\'s with X and all the \\'I\\'s back to 0. \\n The time complexity is O(n*n) and space is O(n*n) for dfs."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my mind really tripped reading O(nn) \\uD83D\\uDE16"
                    },
                    {
                        "username": "__anu__",
                        "content": "Just to save you some time, it\\'s alphabet \\'O\\' and not number \\'0\\'"
                    }
                ]
            },
            {
                "id": 1567878,
                "content": [
                    {
                        "username": "butterman1986",
                        "content": "I felt that the problem statement was difficult to understand as it and the associated example don't clearly indicate what surrounded means. An 'O' is surrounded if there is **NO** path from it to the boundary of the matrix (ie. row index 0, column index 0, row index matrix.length-1, column index matrix[0].length-1) when moving in a North, South, East, or West direction :). Hope this helps anyone else who was unclear."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thanks this hint helped me solve it easily "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/surrounded-regions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS (Depth-First Search)\n\n  \n**Approach 2:** BFS (Breadth-First Search)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mrigankshekhar27",
                        "content": "Leetcode should give more examples. I had to wast so much time running and testing different test cases. \\n And, after all of this, I learned nothing."
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "1) All the \"O\" that are not directly/indirectly connected to the \"O\" on the boundary line, will be captured and converted into \"X\"\\n2) Just traverse the matrix once, and as soon as your enounter a boundary line that has a \"O\" in it, run DFS on this \"O\" and \"Save\" all the nehgbours of this \"O\" from being captured by calling them \"S\"\\n3) Now traverse the matrix again and capture all the \"O\" that you can inside the matrix except the boundary line\\n4) Rename the \"Save\" O back to \"O\"\\n5) Done!"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "interesting, no need to bfs from the islands inside then. Just save any islands on the border."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you this was very helpful!"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Thanks man"
                    },
                    {
                        "username": "shx",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three 'o' are surrounded regions? I mean, the 'o' in the third row has another 'o' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "surrounded in means of 4 directions only top,left,bottom,right..!"
                    },
                    {
                        "username": "Yumi_C",
                        "content": "input=\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],   \\n [\"X\",\"O\",\"O\",\"X\",\"O\"],\\n [\"X\",\"O\",\"X\",\"O\",\"X\"],\\n [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nexpect =\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"X\",\"X\",\"X\",\"X\",\"O\"],\\n  [\"X\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n  [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n  \\n   since  board[2][3] does not on the boarder and does not connect to anything on the boder, it suppose to flip to \"X\" ,right? why it stay the same?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "For anyone still wondering:\\nboard[2][3] stays an O because it is connected to O\\'s that are not surrounded by X\\'s. "
                    },
                    {
                        "username": "irazer19",
                        "content": "That board[2][3] is at the border because its connect to the other O\\'s (board[3][4] and board[4][2]), if you do BFS you will see the connection"
                    },
                    {
                        "username": "sr259",
                        "content": "I am having the same problem, I feel like this one should be \\'X\\' but i am not sure. Can anyone explain?"
                    },
                    {
                        "username": "tonytata",
                        "content": "What does it mean to be surrounded? Whatever I think it means, it is contradicted by the fact that the '0' on the bottom row is not changed."
                    },
                    {
                        "username": "00paradise",
                        "content": "The border cells do not have 4 adjacent cells. Therefore, we can not flip those cell in the border that contains \\'O\\' and also all adjacent cell connected to that border cell.\\n\\nSteps to perform--\\nVisit the border character. \\nIf character is \\'O\\', then mark that character as \\'P\\' or with any random character. And make a dfs call from that position to other adjacent cell where character is \\'O\\' and mark it \\'P\\'.\\n\\nAt last, assign all \\'P\\' as \\'O\\' and other cell value as \\'X\\'."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you, this made the whole problem a lot easier."
                    },
                    {
                        "username": "mczscta",
                        "content": "First things first. Clear what it means that each cell has \\'X\\' on all sides. \\'X\\' should be adjacent or can be any cells away.\\n\\nSolution 1:\\n\\tDo as the question says. For each cell, go in all directions and see if it is surrounded by \\'X\\' on all sides.\\n\\tThe complexity is O(n*n*n)\\n\\t\\nSolution 2: \\n\\tIn the above approach, we are going in all directions just to find the first occurence of \\'X\\' in that direction. Instead we can do some precomputation.\\n\\tDefine left[i][j] as the first index to left of cell(i, j) which has a \\'X\\'. Keep value as -1 if doesn\\'t exist. Similarly, define right[i][j], top[i][j] and down[i][j]. \\n\\tThe time complexity for this solution is O(n*n + n*n) = O(2*n*n) = O(n * n) and space complexity is also same.\\n\\t\\nSolution 3:\\n Notice that if a cell has \\'X\\' on all sides then it can not be reached by a series of 0\\'s that start at the border. Use this observation to do dfs from all 0\\'s at the border and mark them with \\'I\\' so as to mark invalid. After this mark all 0\\'s with X and all the \\'I\\'s back to 0. \\n The time complexity is O(n*n) and space is O(n*n) for dfs."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my mind really tripped reading O(nn) \\uD83D\\uDE16"
                    },
                    {
                        "username": "__anu__",
                        "content": "Just to save you some time, it\\'s alphabet \\'O\\' and not number \\'0\\'"
                    }
                ]
            },
            {
                "id": 1568600,
                "content": [
                    {
                        "username": "butterman1986",
                        "content": "I felt that the problem statement was difficult to understand as it and the associated example don't clearly indicate what surrounded means. An 'O' is surrounded if there is **NO** path from it to the boundary of the matrix (ie. row index 0, column index 0, row index matrix.length-1, column index matrix[0].length-1) when moving in a North, South, East, or West direction :). Hope this helps anyone else who was unclear."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thanks this hint helped me solve it easily "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/surrounded-regions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS (Depth-First Search)\n\n  \n**Approach 2:** BFS (Breadth-First Search)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mrigankshekhar27",
                        "content": "Leetcode should give more examples. I had to wast so much time running and testing different test cases. \\n And, after all of this, I learned nothing."
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "1) All the \"O\" that are not directly/indirectly connected to the \"O\" on the boundary line, will be captured and converted into \"X\"\\n2) Just traverse the matrix once, and as soon as your enounter a boundary line that has a \"O\" in it, run DFS on this \"O\" and \"Save\" all the nehgbours of this \"O\" from being captured by calling them \"S\"\\n3) Now traverse the matrix again and capture all the \"O\" that you can inside the matrix except the boundary line\\n4) Rename the \"Save\" O back to \"O\"\\n5) Done!"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "interesting, no need to bfs from the islands inside then. Just save any islands on the border."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you this was very helpful!"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Thanks man"
                    },
                    {
                        "username": "shx",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three 'o' are surrounded regions? I mean, the 'o' in the third row has another 'o' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "surrounded in means of 4 directions only top,left,bottom,right..!"
                    },
                    {
                        "username": "Yumi_C",
                        "content": "input=\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],   \\n [\"X\",\"O\",\"O\",\"X\",\"O\"],\\n [\"X\",\"O\",\"X\",\"O\",\"X\"],\\n [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nexpect =\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"X\",\"X\",\"X\",\"X\",\"O\"],\\n  [\"X\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n  [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n  \\n   since  board[2][3] does not on the boarder and does not connect to anything on the boder, it suppose to flip to \"X\" ,right? why it stay the same?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "For anyone still wondering:\\nboard[2][3] stays an O because it is connected to O\\'s that are not surrounded by X\\'s. "
                    },
                    {
                        "username": "irazer19",
                        "content": "That board[2][3] is at the border because its connect to the other O\\'s (board[3][4] and board[4][2]), if you do BFS you will see the connection"
                    },
                    {
                        "username": "sr259",
                        "content": "I am having the same problem, I feel like this one should be \\'X\\' but i am not sure. Can anyone explain?"
                    },
                    {
                        "username": "tonytata",
                        "content": "What does it mean to be surrounded? Whatever I think it means, it is contradicted by the fact that the '0' on the bottom row is not changed."
                    },
                    {
                        "username": "00paradise",
                        "content": "The border cells do not have 4 adjacent cells. Therefore, we can not flip those cell in the border that contains \\'O\\' and also all adjacent cell connected to that border cell.\\n\\nSteps to perform--\\nVisit the border character. \\nIf character is \\'O\\', then mark that character as \\'P\\' or with any random character. And make a dfs call from that position to other adjacent cell where character is \\'O\\' and mark it \\'P\\'.\\n\\nAt last, assign all \\'P\\' as \\'O\\' and other cell value as \\'X\\'."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you, this made the whole problem a lot easier."
                    },
                    {
                        "username": "mczscta",
                        "content": "First things first. Clear what it means that each cell has \\'X\\' on all sides. \\'X\\' should be adjacent or can be any cells away.\\n\\nSolution 1:\\n\\tDo as the question says. For each cell, go in all directions and see if it is surrounded by \\'X\\' on all sides.\\n\\tThe complexity is O(n*n*n)\\n\\t\\nSolution 2: \\n\\tIn the above approach, we are going in all directions just to find the first occurence of \\'X\\' in that direction. Instead we can do some precomputation.\\n\\tDefine left[i][j] as the first index to left of cell(i, j) which has a \\'X\\'. Keep value as -1 if doesn\\'t exist. Similarly, define right[i][j], top[i][j] and down[i][j]. \\n\\tThe time complexity for this solution is O(n*n + n*n) = O(2*n*n) = O(n * n) and space complexity is also same.\\n\\t\\nSolution 3:\\n Notice that if a cell has \\'X\\' on all sides then it can not be reached by a series of 0\\'s that start at the border. Use this observation to do dfs from all 0\\'s at the border and mark them with \\'I\\' so as to mark invalid. After this mark all 0\\'s with X and all the \\'I\\'s back to 0. \\n The time complexity is O(n*n) and space is O(n*n) for dfs."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my mind really tripped reading O(nn) \\uD83D\\uDE16"
                    },
                    {
                        "username": "__anu__",
                        "content": "Just to save you some time, it\\'s alphabet \\'O\\' and not number \\'0\\'"
                    }
                ]
            },
            {
                "id": 1568678,
                "content": [
                    {
                        "username": "butterman1986",
                        "content": "I felt that the problem statement was difficult to understand as it and the associated example don't clearly indicate what surrounded means. An 'O' is surrounded if there is **NO** path from it to the boundary of the matrix (ie. row index 0, column index 0, row index matrix.length-1, column index matrix[0].length-1) when moving in a North, South, East, or West direction :). Hope this helps anyone else who was unclear."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thanks this hint helped me solve it easily "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/surrounded-regions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS (Depth-First Search)\n\n  \n**Approach 2:** BFS (Breadth-First Search)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mrigankshekhar27",
                        "content": "Leetcode should give more examples. I had to wast so much time running and testing different test cases. \\n And, after all of this, I learned nothing."
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "1) All the \"O\" that are not directly/indirectly connected to the \"O\" on the boundary line, will be captured and converted into \"X\"\\n2) Just traverse the matrix once, and as soon as your enounter a boundary line that has a \"O\" in it, run DFS on this \"O\" and \"Save\" all the nehgbours of this \"O\" from being captured by calling them \"S\"\\n3) Now traverse the matrix again and capture all the \"O\" that you can inside the matrix except the boundary line\\n4) Rename the \"Save\" O back to \"O\"\\n5) Done!"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "interesting, no need to bfs from the islands inside then. Just save any islands on the border."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you this was very helpful!"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Thanks man"
                    },
                    {
                        "username": "shx",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three 'o' are surrounded regions? I mean, the 'o' in the third row has another 'o' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "surrounded in means of 4 directions only top,left,bottom,right..!"
                    },
                    {
                        "username": "Yumi_C",
                        "content": "input=\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],   \\n [\"X\",\"O\",\"O\",\"X\",\"O\"],\\n [\"X\",\"O\",\"X\",\"O\",\"X\"],\\n [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nexpect =\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"X\",\"X\",\"X\",\"X\",\"O\"],\\n  [\"X\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n  [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n  \\n   since  board[2][3] does not on the boarder and does not connect to anything on the boder, it suppose to flip to \"X\" ,right? why it stay the same?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "For anyone still wondering:\\nboard[2][3] stays an O because it is connected to O\\'s that are not surrounded by X\\'s. "
                    },
                    {
                        "username": "irazer19",
                        "content": "That board[2][3] is at the border because its connect to the other O\\'s (board[3][4] and board[4][2]), if you do BFS you will see the connection"
                    },
                    {
                        "username": "sr259",
                        "content": "I am having the same problem, I feel like this one should be \\'X\\' but i am not sure. Can anyone explain?"
                    },
                    {
                        "username": "tonytata",
                        "content": "What does it mean to be surrounded? Whatever I think it means, it is contradicted by the fact that the '0' on the bottom row is not changed."
                    },
                    {
                        "username": "00paradise",
                        "content": "The border cells do not have 4 adjacent cells. Therefore, we can not flip those cell in the border that contains \\'O\\' and also all adjacent cell connected to that border cell.\\n\\nSteps to perform--\\nVisit the border character. \\nIf character is \\'O\\', then mark that character as \\'P\\' or with any random character. And make a dfs call from that position to other adjacent cell where character is \\'O\\' and mark it \\'P\\'.\\n\\nAt last, assign all \\'P\\' as \\'O\\' and other cell value as \\'X\\'."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you, this made the whole problem a lot easier."
                    },
                    {
                        "username": "mczscta",
                        "content": "First things first. Clear what it means that each cell has \\'X\\' on all sides. \\'X\\' should be adjacent or can be any cells away.\\n\\nSolution 1:\\n\\tDo as the question says. For each cell, go in all directions and see if it is surrounded by \\'X\\' on all sides.\\n\\tThe complexity is O(n*n*n)\\n\\t\\nSolution 2: \\n\\tIn the above approach, we are going in all directions just to find the first occurence of \\'X\\' in that direction. Instead we can do some precomputation.\\n\\tDefine left[i][j] as the first index to left of cell(i, j) which has a \\'X\\'. Keep value as -1 if doesn\\'t exist. Similarly, define right[i][j], top[i][j] and down[i][j]. \\n\\tThe time complexity for this solution is O(n*n + n*n) = O(2*n*n) = O(n * n) and space complexity is also same.\\n\\t\\nSolution 3:\\n Notice that if a cell has \\'X\\' on all sides then it can not be reached by a series of 0\\'s that start at the border. Use this observation to do dfs from all 0\\'s at the border and mark them with \\'I\\' so as to mark invalid. After this mark all 0\\'s with X and all the \\'I\\'s back to 0. \\n The time complexity is O(n*n) and space is O(n*n) for dfs."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my mind really tripped reading O(nn) \\uD83D\\uDE16"
                    },
                    {
                        "username": "__anu__",
                        "content": "Just to save you some time, it\\'s alphabet \\'O\\' and not number \\'0\\'"
                    }
                ]
            },
            {
                "id": 1762007,
                "content": [
                    {
                        "username": "butterman1986",
                        "content": "I felt that the problem statement was difficult to understand as it and the associated example don't clearly indicate what surrounded means. An 'O' is surrounded if there is **NO** path from it to the boundary of the matrix (ie. row index 0, column index 0, row index matrix.length-1, column index matrix[0].length-1) when moving in a North, South, East, or West direction :). Hope this helps anyone else who was unclear."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thanks this hint helped me solve it easily "
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for November, Day 1.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/surrounded-regions/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** DFS (Depth-First Search)\n\n  \n**Approach 2:** BFS (Breadth-First Search)\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "mrigankshekhar27",
                        "content": "Leetcode should give more examples. I had to wast so much time running and testing different test cases. \\n And, after all of this, I learned nothing."
                    },
                    {
                        "username": "turbotorquetiger",
                        "content": "1) All the \"O\" that are not directly/indirectly connected to the \"O\" on the boundary line, will be captured and converted into \"X\"\\n2) Just traverse the matrix once, and as soon as your enounter a boundary line that has a \"O\" in it, run DFS on this \"O\" and \"Save\" all the nehgbours of this \"O\" from being captured by calling them \"S\"\\n3) Now traverse the matrix again and capture all the \"O\" that you can inside the matrix except the boundary line\\n4) Rename the \"Save\" O back to \"O\"\\n5) Done!"
                    },
                    {
                        "username": "TGBBSZWHWDLANZP",
                        "content": "interesting, no need to bfs from the islands inside then. Just save any islands on the border."
                    },
                    {
                        "username": "mochiball",
                        "content": "Thank you this was very helpful!"
                    },
                    {
                        "username": "Adnan_Saif",
                        "content": "Thanks man"
                    },
                    {
                        "username": "shx",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three 'o' are surrounded regions? I mean, the 'o' in the third row has another 'o' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "surrounded in means of 4 directions only top,left,bottom,right..!"
                    },
                    {
                        "username": "Yumi_C",
                        "content": "input=\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],   \\n [\"X\",\"O\",\"O\",\"X\",\"O\"],\\n [\"X\",\"O\",\"X\",\"O\",\"X\"],\\n [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nexpect =\\n[[\"O\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"X\",\"X\",\"X\",\"X\",\"O\"],\\n  [\"X\",\"X\",\"X\",\"O\",\"X\"],\\n  [\"O\",\"X\",\"O\",\"O\",\"O\"],\\n  [\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n  \\n   since  board[2][3] does not on the boarder and does not connect to anything on the boder, it suppose to flip to \"X\" ,right? why it stay the same?"
                    },
                    {
                        "username": "mhandels2023",
                        "content": "For anyone still wondering:\\nboard[2][3] stays an O because it is connected to O\\'s that are not surrounded by X\\'s. "
                    },
                    {
                        "username": "irazer19",
                        "content": "That board[2][3] is at the border because its connect to the other O\\'s (board[3][4] and board[4][2]), if you do BFS you will see the connection"
                    },
                    {
                        "username": "sr259",
                        "content": "I am having the same problem, I feel like this one should be \\'X\\' but i am not sure. Can anyone explain?"
                    },
                    {
                        "username": "tonytata",
                        "content": "What does it mean to be surrounded? Whatever I think it means, it is contradicted by the fact that the '0' on the bottom row is not changed."
                    },
                    {
                        "username": "00paradise",
                        "content": "The border cells do not have 4 adjacent cells. Therefore, we can not flip those cell in the border that contains \\'O\\' and also all adjacent cell connected to that border cell.\\n\\nSteps to perform--\\nVisit the border character. \\nIf character is \\'O\\', then mark that character as \\'P\\' or with any random character. And make a dfs call from that position to other adjacent cell where character is \\'O\\' and mark it \\'P\\'.\\n\\nAt last, assign all \\'P\\' as \\'O\\' and other cell value as \\'X\\'."
                    },
                    {
                        "username": "Cocamo1337",
                        "content": "Thank you, this made the whole problem a lot easier."
                    },
                    {
                        "username": "mczscta",
                        "content": "First things first. Clear what it means that each cell has \\'X\\' on all sides. \\'X\\' should be adjacent or can be any cells away.\\n\\nSolution 1:\\n\\tDo as the question says. For each cell, go in all directions and see if it is surrounded by \\'X\\' on all sides.\\n\\tThe complexity is O(n*n*n)\\n\\t\\nSolution 2: \\n\\tIn the above approach, we are going in all directions just to find the first occurence of \\'X\\' in that direction. Instead we can do some precomputation.\\n\\tDefine left[i][j] as the first index to left of cell(i, j) which has a \\'X\\'. Keep value as -1 if doesn\\'t exist. Similarly, define right[i][j], top[i][j] and down[i][j]. \\n\\tThe time complexity for this solution is O(n*n + n*n) = O(2*n*n) = O(n * n) and space complexity is also same.\\n\\t\\nSolution 3:\\n Notice that if a cell has \\'X\\' on all sides then it can not be reached by a series of 0\\'s that start at the border. Use this observation to do dfs from all 0\\'s at the border and mark them with \\'I\\' so as to mark invalid. After this mark all 0\\'s with X and all the \\'I\\'s back to 0. \\n The time complexity is O(n*n) and space is O(n*n) for dfs."
                    },
                    {
                        "username": "kushalnagwanshicloud",
                        "content": "my mind really tripped reading O(nn) \\uD83D\\uDE16"
                    },
                    {
                        "username": "__anu__",
                        "content": "Just to save you some time, it\\'s alphabet \\'O\\' and not number \\'0\\'"
                    }
                ]
            },
            {
                "id": 1572556,
                "content": [
                    {
                        "username": "user6994",
                        "content": "Input \\nO X X O X \\nX O O X O \\nX O X O X \\nO X O O O \\nX X O X O\\n\\nExpected\\nO X X O X \\nX X X X O \\nX X X O X \\nO X O O O \\nX X O X O \\n\\nCan\\'t understand  why 3rd row 4th column  remains \\'O\\'. It can be flipped as it\\'s not connected to \\'O\\' that is a border cell."
                    },
                    {
                        "username": "heyidk",
                        "content": "- Just turn the connected \\'O\\'s from 4 bound lines into \\'.\\'s (any character besides \\'O\\' and \\'X\\'), then turn all the remaining \\'O\\'s into \\'X\\', and recover the \\'.\\'s at the same time. Actually some easy problems got more complicacted than this one.\\n- I was just wondering how it could be tagged with \\'medium\\'... anyone agrees?"
                    },
                    {
                        "username": "himaniac",
                        "content": "[@aeroabrar_31](/aeroabrar_31) it would not change it \\'X\\' run the example on the code and see for yourself. this heyidk guy  is right "
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[[\"O\",\"O\",\"O\"],\\n[\"O\",\"O\",\"O\"],\\n[\"O\",\"O\",\"O\"]]\\n\\nfor this example, answer should be unchanged.\\nBut by your discussion, it would change the middle \\'O\\' to \\'X\\' which is not on the boundary.\\n\\n[[\"O\",\"O\",\"O\"],\\n[\"O\",\"X\",\"O\"],\\n[\"O\",\"O\",\"O\"]]"
                    },
                    {
                        "username": "anandA3B",
                        "content": "OMG. It is an capital O. and not a zero. i went through my code soooo many times. then i realised that it is not a zero. smh."
                    },
                    {
                        "username": "vamsi369",
                        "content": "Input = [[\"O\",\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"O\",\"X\",\"O\"],[\"X\",\"O\",\"X\",\"O\",\"X\"],[\"O\",\"X\",\"O\",\"O\",\"O\"],[\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\n\\nExpected Output = [[\"O\",\"X\",\"X\",\"O\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"O\"],[\"X\",\"X\",\"X\",\"O\",\"X\"],[\"O\",\"X\",\"O\",\"O\",\"O\"],[\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nwhy is the \"O in 3rd row 4th column will not get flipped to \"X\", i could see it is surrounded with \"X\" in all directions"
                    },
                    {
                        "username": "user196",
                        "content": "130. Surrounded Regions needs either 1-2 more example or clear definition of \"Surrounded\""
                    },
                    {
                        "username": "nikhpand",
                        "content": "I can see that BFS based solutions are able to pass the tests but the DFS based solutions are failing (I am getting stack overflow). Any particular reason as to why BFS should be preferred here ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "One of the worst-formulated porblems I have ever seen on leetcode. No explanation of rules, one poor example, but a pretty strict runtime limit. The author is a horrible person."
                    },
                    {
                        "username": "j3ffhu",
                        "content": "BFS should work, add all border O to queue and BFS visit its neighbors O\\nAt the end, flip  unvisited O\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Gave me TLE but my DFS solved it 99%"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video. \\n\\nhttps://vimeo.com/641013608"
                    },
                    {
                        "username": "triples13",
                        "content": "This post is for people looking to compare with island problem, it took me a while to correlate with island problem so thought it would help someone who is looking to correlate \\n\\n* island problem ->to find all 1\\'s which form an island with no condition , so we do dfs to find all 1\\'s which form island and mark them as visited and we count as 1 island\\n\\n* surrounded regions ->we have to find all o\\'s which can be replaced with x\\'s , but with a catch o\\'s which lies with boundary o\\'s either horizaontaly or verticaly can\\'t be replaced with x\\'s , so similar to island problem we find o\\'s which can\\'t be replaced starting with boundary and marking them as visited  and at the end we replaced unmarked o\\'s with x\\'s"
                    }
                ]
            },
            {
                "id": 1569443,
                "content": [
                    {
                        "username": "user6994",
                        "content": "Input \\nO X X O X \\nX O O X O \\nX O X O X \\nO X O O O \\nX X O X O\\n\\nExpected\\nO X X O X \\nX X X X O \\nX X X O X \\nO X O O O \\nX X O X O \\n\\nCan\\'t understand  why 3rd row 4th column  remains \\'O\\'. It can be flipped as it\\'s not connected to \\'O\\' that is a border cell."
                    },
                    {
                        "username": "heyidk",
                        "content": "- Just turn the connected \\'O\\'s from 4 bound lines into \\'.\\'s (any character besides \\'O\\' and \\'X\\'), then turn all the remaining \\'O\\'s into \\'X\\', and recover the \\'.\\'s at the same time. Actually some easy problems got more complicacted than this one.\\n- I was just wondering how it could be tagged with \\'medium\\'... anyone agrees?"
                    },
                    {
                        "username": "himaniac",
                        "content": "[@aeroabrar_31](/aeroabrar_31) it would not change it \\'X\\' run the example on the code and see for yourself. this heyidk guy  is right "
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[[\"O\",\"O\",\"O\"],\\n[\"O\",\"O\",\"O\"],\\n[\"O\",\"O\",\"O\"]]\\n\\nfor this example, answer should be unchanged.\\nBut by your discussion, it would change the middle \\'O\\' to \\'X\\' which is not on the boundary.\\n\\n[[\"O\",\"O\",\"O\"],\\n[\"O\",\"X\",\"O\"],\\n[\"O\",\"O\",\"O\"]]"
                    },
                    {
                        "username": "anandA3B",
                        "content": "OMG. It is an capital O. and not a zero. i went through my code soooo many times. then i realised that it is not a zero. smh."
                    },
                    {
                        "username": "vamsi369",
                        "content": "Input = [[\"O\",\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"O\",\"X\",\"O\"],[\"X\",\"O\",\"X\",\"O\",\"X\"],[\"O\",\"X\",\"O\",\"O\",\"O\"],[\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\n\\nExpected Output = [[\"O\",\"X\",\"X\",\"O\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"O\"],[\"X\",\"X\",\"X\",\"O\",\"X\"],[\"O\",\"X\",\"O\",\"O\",\"O\"],[\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nwhy is the \"O in 3rd row 4th column will not get flipped to \"X\", i could see it is surrounded with \"X\" in all directions"
                    },
                    {
                        "username": "user196",
                        "content": "130. Surrounded Regions needs either 1-2 more example or clear definition of \"Surrounded\""
                    },
                    {
                        "username": "nikhpand",
                        "content": "I can see that BFS based solutions are able to pass the tests but the DFS based solutions are failing (I am getting stack overflow). Any particular reason as to why BFS should be preferred here ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "One of the worst-formulated porblems I have ever seen on leetcode. No explanation of rules, one poor example, but a pretty strict runtime limit. The author is a horrible person."
                    },
                    {
                        "username": "j3ffhu",
                        "content": "BFS should work, add all border O to queue and BFS visit its neighbors O\\nAt the end, flip  unvisited O\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Gave me TLE but my DFS solved it 99%"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video. \\n\\nhttps://vimeo.com/641013608"
                    },
                    {
                        "username": "triples13",
                        "content": "This post is for people looking to compare with island problem, it took me a while to correlate with island problem so thought it would help someone who is looking to correlate \\n\\n* island problem ->to find all 1\\'s which form an island with no condition , so we do dfs to find all 1\\'s which form island and mark them as visited and we count as 1 island\\n\\n* surrounded regions ->we have to find all o\\'s which can be replaced with x\\'s , but with a catch o\\'s which lies with boundary o\\'s either horizaontaly or verticaly can\\'t be replaced with x\\'s , so similar to island problem we find o\\'s which can\\'t be replaced starting with boundary and marking them as visited  and at the end we replaced unmarked o\\'s with x\\'s"
                    }
                ]
            },
            {
                "id": 1964811,
                "content": [
                    {
                        "username": "user6994",
                        "content": "Input \\nO X X O X \\nX O O X O \\nX O X O X \\nO X O O O \\nX X O X O\\n\\nExpected\\nO X X O X \\nX X X X O \\nX X X O X \\nO X O O O \\nX X O X O \\n\\nCan\\'t understand  why 3rd row 4th column  remains \\'O\\'. It can be flipped as it\\'s not connected to \\'O\\' that is a border cell."
                    },
                    {
                        "username": "heyidk",
                        "content": "- Just turn the connected \\'O\\'s from 4 bound lines into \\'.\\'s (any character besides \\'O\\' and \\'X\\'), then turn all the remaining \\'O\\'s into \\'X\\', and recover the \\'.\\'s at the same time. Actually some easy problems got more complicacted than this one.\\n- I was just wondering how it could be tagged with \\'medium\\'... anyone agrees?"
                    },
                    {
                        "username": "himaniac",
                        "content": "[@aeroabrar_31](/aeroabrar_31) it would not change it \\'X\\' run the example on the code and see for yourself. this heyidk guy  is right "
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[[\"O\",\"O\",\"O\"],\\n[\"O\",\"O\",\"O\"],\\n[\"O\",\"O\",\"O\"]]\\n\\nfor this example, answer should be unchanged.\\nBut by your discussion, it would change the middle \\'O\\' to \\'X\\' which is not on the boundary.\\n\\n[[\"O\",\"O\",\"O\"],\\n[\"O\",\"X\",\"O\"],\\n[\"O\",\"O\",\"O\"]]"
                    },
                    {
                        "username": "anandA3B",
                        "content": "OMG. It is an capital O. and not a zero. i went through my code soooo many times. then i realised that it is not a zero. smh."
                    },
                    {
                        "username": "vamsi369",
                        "content": "Input = [[\"O\",\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"O\",\"X\",\"O\"],[\"X\",\"O\",\"X\",\"O\",\"X\"],[\"O\",\"X\",\"O\",\"O\",\"O\"],[\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\n\\nExpected Output = [[\"O\",\"X\",\"X\",\"O\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"O\"],[\"X\",\"X\",\"X\",\"O\",\"X\"],[\"O\",\"X\",\"O\",\"O\",\"O\"],[\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nwhy is the \"O in 3rd row 4th column will not get flipped to \"X\", i could see it is surrounded with \"X\" in all directions"
                    },
                    {
                        "username": "user196",
                        "content": "130. Surrounded Regions needs either 1-2 more example or clear definition of \"Surrounded\""
                    },
                    {
                        "username": "nikhpand",
                        "content": "I can see that BFS based solutions are able to pass the tests but the DFS based solutions are failing (I am getting stack overflow). Any particular reason as to why BFS should be preferred here ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "One of the worst-formulated porblems I have ever seen on leetcode. No explanation of rules, one poor example, but a pretty strict runtime limit. The author is a horrible person."
                    },
                    {
                        "username": "j3ffhu",
                        "content": "BFS should work, add all border O to queue and BFS visit its neighbors O\\nAt the end, flip  unvisited O\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Gave me TLE but my DFS solved it 99%"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video. \\n\\nhttps://vimeo.com/641013608"
                    },
                    {
                        "username": "triples13",
                        "content": "This post is for people looking to compare with island problem, it took me a while to correlate with island problem so thought it would help someone who is looking to correlate \\n\\n* island problem ->to find all 1\\'s which form an island with no condition , so we do dfs to find all 1\\'s which form island and mark them as visited and we count as 1 island\\n\\n* surrounded regions ->we have to find all o\\'s which can be replaced with x\\'s , but with a catch o\\'s which lies with boundary o\\'s either horizaontaly or verticaly can\\'t be replaced with x\\'s , so similar to island problem we find o\\'s which can\\'t be replaced starting with boundary and marking them as visited  and at the end we replaced unmarked o\\'s with x\\'s"
                    }
                ]
            },
            {
                "id": 1572404,
                "content": [
                    {
                        "username": "user6994",
                        "content": "Input \\nO X X O X \\nX O O X O \\nX O X O X \\nO X O O O \\nX X O X O\\n\\nExpected\\nO X X O X \\nX X X X O \\nX X X O X \\nO X O O O \\nX X O X O \\n\\nCan\\'t understand  why 3rd row 4th column  remains \\'O\\'. It can be flipped as it\\'s not connected to \\'O\\' that is a border cell."
                    },
                    {
                        "username": "heyidk",
                        "content": "- Just turn the connected \\'O\\'s from 4 bound lines into \\'.\\'s (any character besides \\'O\\' and \\'X\\'), then turn all the remaining \\'O\\'s into \\'X\\', and recover the \\'.\\'s at the same time. Actually some easy problems got more complicacted than this one.\\n- I was just wondering how it could be tagged with \\'medium\\'... anyone agrees?"
                    },
                    {
                        "username": "himaniac",
                        "content": "[@aeroabrar_31](/aeroabrar_31) it would not change it \\'X\\' run the example on the code and see for yourself. this heyidk guy  is right "
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[[\"O\",\"O\",\"O\"],\\n[\"O\",\"O\",\"O\"],\\n[\"O\",\"O\",\"O\"]]\\n\\nfor this example, answer should be unchanged.\\nBut by your discussion, it would change the middle \\'O\\' to \\'X\\' which is not on the boundary.\\n\\n[[\"O\",\"O\",\"O\"],\\n[\"O\",\"X\",\"O\"],\\n[\"O\",\"O\",\"O\"]]"
                    },
                    {
                        "username": "anandA3B",
                        "content": "OMG. It is an capital O. and not a zero. i went through my code soooo many times. then i realised that it is not a zero. smh."
                    },
                    {
                        "username": "vamsi369",
                        "content": "Input = [[\"O\",\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"O\",\"X\",\"O\"],[\"X\",\"O\",\"X\",\"O\",\"X\"],[\"O\",\"X\",\"O\",\"O\",\"O\"],[\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\n\\nExpected Output = [[\"O\",\"X\",\"X\",\"O\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"O\"],[\"X\",\"X\",\"X\",\"O\",\"X\"],[\"O\",\"X\",\"O\",\"O\",\"O\"],[\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nwhy is the \"O in 3rd row 4th column will not get flipped to \"X\", i could see it is surrounded with \"X\" in all directions"
                    },
                    {
                        "username": "user196",
                        "content": "130. Surrounded Regions needs either 1-2 more example or clear definition of \"Surrounded\""
                    },
                    {
                        "username": "nikhpand",
                        "content": "I can see that BFS based solutions are able to pass the tests but the DFS based solutions are failing (I am getting stack overflow). Any particular reason as to why BFS should be preferred here ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "One of the worst-formulated porblems I have ever seen on leetcode. No explanation of rules, one poor example, but a pretty strict runtime limit. The author is a horrible person."
                    },
                    {
                        "username": "j3ffhu",
                        "content": "BFS should work, add all border O to queue and BFS visit its neighbors O\\nAt the end, flip  unvisited O\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Gave me TLE but my DFS solved it 99%"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video. \\n\\nhttps://vimeo.com/641013608"
                    },
                    {
                        "username": "triples13",
                        "content": "This post is for people looking to compare with island problem, it took me a while to correlate with island problem so thought it would help someone who is looking to correlate \\n\\n* island problem ->to find all 1\\'s which form an island with no condition , so we do dfs to find all 1\\'s which form island and mark them as visited and we count as 1 island\\n\\n* surrounded regions ->we have to find all o\\'s which can be replaced with x\\'s , but with a catch o\\'s which lies with boundary o\\'s either horizaontaly or verticaly can\\'t be replaced with x\\'s , so similar to island problem we find o\\'s which can\\'t be replaced starting with boundary and marking them as visited  and at the end we replaced unmarked o\\'s with x\\'s"
                    }
                ]
            },
            {
                "id": 1571280,
                "content": [
                    {
                        "username": "user6994",
                        "content": "Input \\nO X X O X \\nX O O X O \\nX O X O X \\nO X O O O \\nX X O X O\\n\\nExpected\\nO X X O X \\nX X X X O \\nX X X O X \\nO X O O O \\nX X O X O \\n\\nCan\\'t understand  why 3rd row 4th column  remains \\'O\\'. It can be flipped as it\\'s not connected to \\'O\\' that is a border cell."
                    },
                    {
                        "username": "heyidk",
                        "content": "- Just turn the connected \\'O\\'s from 4 bound lines into \\'.\\'s (any character besides \\'O\\' and \\'X\\'), then turn all the remaining \\'O\\'s into \\'X\\', and recover the \\'.\\'s at the same time. Actually some easy problems got more complicacted than this one.\\n- I was just wondering how it could be tagged with \\'medium\\'... anyone agrees?"
                    },
                    {
                        "username": "himaniac",
                        "content": "[@aeroabrar_31](/aeroabrar_31) it would not change it \\'X\\' run the example on the code and see for yourself. this heyidk guy  is right "
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[[\"O\",\"O\",\"O\"],\\n[\"O\",\"O\",\"O\"],\\n[\"O\",\"O\",\"O\"]]\\n\\nfor this example, answer should be unchanged.\\nBut by your discussion, it would change the middle \\'O\\' to \\'X\\' which is not on the boundary.\\n\\n[[\"O\",\"O\",\"O\"],\\n[\"O\",\"X\",\"O\"],\\n[\"O\",\"O\",\"O\"]]"
                    },
                    {
                        "username": "anandA3B",
                        "content": "OMG. It is an capital O. and not a zero. i went through my code soooo many times. then i realised that it is not a zero. smh."
                    },
                    {
                        "username": "vamsi369",
                        "content": "Input = [[\"O\",\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"O\",\"X\",\"O\"],[\"X\",\"O\",\"X\",\"O\",\"X\"],[\"O\",\"X\",\"O\",\"O\",\"O\"],[\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\n\\nExpected Output = [[\"O\",\"X\",\"X\",\"O\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"O\"],[\"X\",\"X\",\"X\",\"O\",\"X\"],[\"O\",\"X\",\"O\",\"O\",\"O\"],[\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nwhy is the \"O in 3rd row 4th column will not get flipped to \"X\", i could see it is surrounded with \"X\" in all directions"
                    },
                    {
                        "username": "user196",
                        "content": "130. Surrounded Regions needs either 1-2 more example or clear definition of \"Surrounded\""
                    },
                    {
                        "username": "nikhpand",
                        "content": "I can see that BFS based solutions are able to pass the tests but the DFS based solutions are failing (I am getting stack overflow). Any particular reason as to why BFS should be preferred here ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "One of the worst-formulated porblems I have ever seen on leetcode. No explanation of rules, one poor example, but a pretty strict runtime limit. The author is a horrible person."
                    },
                    {
                        "username": "j3ffhu",
                        "content": "BFS should work, add all border O to queue and BFS visit its neighbors O\\nAt the end, flip  unvisited O\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Gave me TLE but my DFS solved it 99%"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video. \\n\\nhttps://vimeo.com/641013608"
                    },
                    {
                        "username": "triples13",
                        "content": "This post is for people looking to compare with island problem, it took me a while to correlate with island problem so thought it would help someone who is looking to correlate \\n\\n* island problem ->to find all 1\\'s which form an island with no condition , so we do dfs to find all 1\\'s which form island and mark them as visited and we count as 1 island\\n\\n* surrounded regions ->we have to find all o\\'s which can be replaced with x\\'s , but with a catch o\\'s which lies with boundary o\\'s either horizaontaly or verticaly can\\'t be replaced with x\\'s , so similar to island problem we find o\\'s which can\\'t be replaced starting with boundary and marking them as visited  and at the end we replaced unmarked o\\'s with x\\'s"
                    }
                ]
            },
            {
                "id": 1568949,
                "content": [
                    {
                        "username": "user6994",
                        "content": "Input \\nO X X O X \\nX O O X O \\nX O X O X \\nO X O O O \\nX X O X O\\n\\nExpected\\nO X X O X \\nX X X X O \\nX X X O X \\nO X O O O \\nX X O X O \\n\\nCan\\'t understand  why 3rd row 4th column  remains \\'O\\'. It can be flipped as it\\'s not connected to \\'O\\' that is a border cell."
                    },
                    {
                        "username": "heyidk",
                        "content": "- Just turn the connected \\'O\\'s from 4 bound lines into \\'.\\'s (any character besides \\'O\\' and \\'X\\'), then turn all the remaining \\'O\\'s into \\'X\\', and recover the \\'.\\'s at the same time. Actually some easy problems got more complicacted than this one.\\n- I was just wondering how it could be tagged with \\'medium\\'... anyone agrees?"
                    },
                    {
                        "username": "himaniac",
                        "content": "[@aeroabrar_31](/aeroabrar_31) it would not change it \\'X\\' run the example on the code and see for yourself. this heyidk guy  is right "
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[[\"O\",\"O\",\"O\"],\\n[\"O\",\"O\",\"O\"],\\n[\"O\",\"O\",\"O\"]]\\n\\nfor this example, answer should be unchanged.\\nBut by your discussion, it would change the middle \\'O\\' to \\'X\\' which is not on the boundary.\\n\\n[[\"O\",\"O\",\"O\"],\\n[\"O\",\"X\",\"O\"],\\n[\"O\",\"O\",\"O\"]]"
                    },
                    {
                        "username": "anandA3B",
                        "content": "OMG. It is an capital O. and not a zero. i went through my code soooo many times. then i realised that it is not a zero. smh."
                    },
                    {
                        "username": "vamsi369",
                        "content": "Input = [[\"O\",\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"O\",\"X\",\"O\"],[\"X\",\"O\",\"X\",\"O\",\"X\"],[\"O\",\"X\",\"O\",\"O\",\"O\"],[\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\n\\nExpected Output = [[\"O\",\"X\",\"X\",\"O\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"O\"],[\"X\",\"X\",\"X\",\"O\",\"X\"],[\"O\",\"X\",\"O\",\"O\",\"O\"],[\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nwhy is the \"O in 3rd row 4th column will not get flipped to \"X\", i could see it is surrounded with \"X\" in all directions"
                    },
                    {
                        "username": "user196",
                        "content": "130. Surrounded Regions needs either 1-2 more example or clear definition of \"Surrounded\""
                    },
                    {
                        "username": "nikhpand",
                        "content": "I can see that BFS based solutions are able to pass the tests but the DFS based solutions are failing (I am getting stack overflow). Any particular reason as to why BFS should be preferred here ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "One of the worst-formulated porblems I have ever seen on leetcode. No explanation of rules, one poor example, but a pretty strict runtime limit. The author is a horrible person."
                    },
                    {
                        "username": "j3ffhu",
                        "content": "BFS should work, add all border O to queue and BFS visit its neighbors O\\nAt the end, flip  unvisited O\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Gave me TLE but my DFS solved it 99%"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video. \\n\\nhttps://vimeo.com/641013608"
                    },
                    {
                        "username": "triples13",
                        "content": "This post is for people looking to compare with island problem, it took me a while to correlate with island problem so thought it would help someone who is looking to correlate \\n\\n* island problem ->to find all 1\\'s which form an island with no condition , so we do dfs to find all 1\\'s which form island and mark them as visited and we count as 1 island\\n\\n* surrounded regions ->we have to find all o\\'s which can be replaced with x\\'s , but with a catch o\\'s which lies with boundary o\\'s either horizaontaly or verticaly can\\'t be replaced with x\\'s , so similar to island problem we find o\\'s which can\\'t be replaced starting with boundary and marking them as visited  and at the end we replaced unmarked o\\'s with x\\'s"
                    }
                ]
            },
            {
                "id": 2028955,
                "content": [
                    {
                        "username": "user6994",
                        "content": "Input \\nO X X O X \\nX O O X O \\nX O X O X \\nO X O O O \\nX X O X O\\n\\nExpected\\nO X X O X \\nX X X X O \\nX X X O X \\nO X O O O \\nX X O X O \\n\\nCan\\'t understand  why 3rd row 4th column  remains \\'O\\'. It can be flipped as it\\'s not connected to \\'O\\' that is a border cell."
                    },
                    {
                        "username": "heyidk",
                        "content": "- Just turn the connected \\'O\\'s from 4 bound lines into \\'.\\'s (any character besides \\'O\\' and \\'X\\'), then turn all the remaining \\'O\\'s into \\'X\\', and recover the \\'.\\'s at the same time. Actually some easy problems got more complicacted than this one.\\n- I was just wondering how it could be tagged with \\'medium\\'... anyone agrees?"
                    },
                    {
                        "username": "himaniac",
                        "content": "[@aeroabrar_31](/aeroabrar_31) it would not change it \\'X\\' run the example on the code and see for yourself. this heyidk guy  is right "
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[[\"O\",\"O\",\"O\"],\\n[\"O\",\"O\",\"O\"],\\n[\"O\",\"O\",\"O\"]]\\n\\nfor this example, answer should be unchanged.\\nBut by your discussion, it would change the middle \\'O\\' to \\'X\\' which is not on the boundary.\\n\\n[[\"O\",\"O\",\"O\"],\\n[\"O\",\"X\",\"O\"],\\n[\"O\",\"O\",\"O\"]]"
                    },
                    {
                        "username": "anandA3B",
                        "content": "OMG. It is an capital O. and not a zero. i went through my code soooo many times. then i realised that it is not a zero. smh."
                    },
                    {
                        "username": "vamsi369",
                        "content": "Input = [[\"O\",\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"O\",\"X\",\"O\"],[\"X\",\"O\",\"X\",\"O\",\"X\"],[\"O\",\"X\",\"O\",\"O\",\"O\"],[\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\n\\nExpected Output = [[\"O\",\"X\",\"X\",\"O\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"O\"],[\"X\",\"X\",\"X\",\"O\",\"X\"],[\"O\",\"X\",\"O\",\"O\",\"O\"],[\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nwhy is the \"O in 3rd row 4th column will not get flipped to \"X\", i could see it is surrounded with \"X\" in all directions"
                    },
                    {
                        "username": "user196",
                        "content": "130. Surrounded Regions needs either 1-2 more example or clear definition of \"Surrounded\""
                    },
                    {
                        "username": "nikhpand",
                        "content": "I can see that BFS based solutions are able to pass the tests but the DFS based solutions are failing (I am getting stack overflow). Any particular reason as to why BFS should be preferred here ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "One of the worst-formulated porblems I have ever seen on leetcode. No explanation of rules, one poor example, but a pretty strict runtime limit. The author is a horrible person."
                    },
                    {
                        "username": "j3ffhu",
                        "content": "BFS should work, add all border O to queue and BFS visit its neighbors O\\nAt the end, flip  unvisited O\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Gave me TLE but my DFS solved it 99%"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video. \\n\\nhttps://vimeo.com/641013608"
                    },
                    {
                        "username": "triples13",
                        "content": "This post is for people looking to compare with island problem, it took me a while to correlate with island problem so thought it would help someone who is looking to correlate \\n\\n* island problem ->to find all 1\\'s which form an island with no condition , so we do dfs to find all 1\\'s which form island and mark them as visited and we count as 1 island\\n\\n* surrounded regions ->we have to find all o\\'s which can be replaced with x\\'s , but with a catch o\\'s which lies with boundary o\\'s either horizaontaly or verticaly can\\'t be replaced with x\\'s , so similar to island problem we find o\\'s which can\\'t be replaced starting with boundary and marking them as visited  and at the end we replaced unmarked o\\'s with x\\'s"
                    }
                ]
            },
            {
                "id": 1873124,
                "content": [
                    {
                        "username": "user6994",
                        "content": "Input \\nO X X O X \\nX O O X O \\nX O X O X \\nO X O O O \\nX X O X O\\n\\nExpected\\nO X X O X \\nX X X X O \\nX X X O X \\nO X O O O \\nX X O X O \\n\\nCan\\'t understand  why 3rd row 4th column  remains \\'O\\'. It can be flipped as it\\'s not connected to \\'O\\' that is a border cell."
                    },
                    {
                        "username": "heyidk",
                        "content": "- Just turn the connected \\'O\\'s from 4 bound lines into \\'.\\'s (any character besides \\'O\\' and \\'X\\'), then turn all the remaining \\'O\\'s into \\'X\\', and recover the \\'.\\'s at the same time. Actually some easy problems got more complicacted than this one.\\n- I was just wondering how it could be tagged with \\'medium\\'... anyone agrees?"
                    },
                    {
                        "username": "himaniac",
                        "content": "[@aeroabrar_31](/aeroabrar_31) it would not change it \\'X\\' run the example on the code and see for yourself. this heyidk guy  is right "
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[[\"O\",\"O\",\"O\"],\\n[\"O\",\"O\",\"O\"],\\n[\"O\",\"O\",\"O\"]]\\n\\nfor this example, answer should be unchanged.\\nBut by your discussion, it would change the middle \\'O\\' to \\'X\\' which is not on the boundary.\\n\\n[[\"O\",\"O\",\"O\"],\\n[\"O\",\"X\",\"O\"],\\n[\"O\",\"O\",\"O\"]]"
                    },
                    {
                        "username": "anandA3B",
                        "content": "OMG. It is an capital O. and not a zero. i went through my code soooo many times. then i realised that it is not a zero. smh."
                    },
                    {
                        "username": "vamsi369",
                        "content": "Input = [[\"O\",\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"O\",\"X\",\"O\"],[\"X\",\"O\",\"X\",\"O\",\"X\"],[\"O\",\"X\",\"O\",\"O\",\"O\"],[\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\n\\nExpected Output = [[\"O\",\"X\",\"X\",\"O\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"O\"],[\"X\",\"X\",\"X\",\"O\",\"X\"],[\"O\",\"X\",\"O\",\"O\",\"O\"],[\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nwhy is the \"O in 3rd row 4th column will not get flipped to \"X\", i could see it is surrounded with \"X\" in all directions"
                    },
                    {
                        "username": "user196",
                        "content": "130. Surrounded Regions needs either 1-2 more example or clear definition of \"Surrounded\""
                    },
                    {
                        "username": "nikhpand",
                        "content": "I can see that BFS based solutions are able to pass the tests but the DFS based solutions are failing (I am getting stack overflow). Any particular reason as to why BFS should be preferred here ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "One of the worst-formulated porblems I have ever seen on leetcode. No explanation of rules, one poor example, but a pretty strict runtime limit. The author is a horrible person."
                    },
                    {
                        "username": "j3ffhu",
                        "content": "BFS should work, add all border O to queue and BFS visit its neighbors O\\nAt the end, flip  unvisited O\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Gave me TLE but my DFS solved it 99%"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video. \\n\\nhttps://vimeo.com/641013608"
                    },
                    {
                        "username": "triples13",
                        "content": "This post is for people looking to compare with island problem, it took me a while to correlate with island problem so thought it would help someone who is looking to correlate \\n\\n* island problem ->to find all 1\\'s which form an island with no condition , so we do dfs to find all 1\\'s which form island and mark them as visited and we count as 1 island\\n\\n* surrounded regions ->we have to find all o\\'s which can be replaced with x\\'s , but with a catch o\\'s which lies with boundary o\\'s either horizaontaly or verticaly can\\'t be replaced with x\\'s , so similar to island problem we find o\\'s which can\\'t be replaced starting with boundary and marking them as visited  and at the end we replaced unmarked o\\'s with x\\'s"
                    }
                ]
            },
            {
                "id": 1575920,
                "content": [
                    {
                        "username": "user6994",
                        "content": "Input \\nO X X O X \\nX O O X O \\nX O X O X \\nO X O O O \\nX X O X O\\n\\nExpected\\nO X X O X \\nX X X X O \\nX X X O X \\nO X O O O \\nX X O X O \\n\\nCan\\'t understand  why 3rd row 4th column  remains \\'O\\'. It can be flipped as it\\'s not connected to \\'O\\' that is a border cell."
                    },
                    {
                        "username": "heyidk",
                        "content": "- Just turn the connected \\'O\\'s from 4 bound lines into \\'.\\'s (any character besides \\'O\\' and \\'X\\'), then turn all the remaining \\'O\\'s into \\'X\\', and recover the \\'.\\'s at the same time. Actually some easy problems got more complicacted than this one.\\n- I was just wondering how it could be tagged with \\'medium\\'... anyone agrees?"
                    },
                    {
                        "username": "himaniac",
                        "content": "[@aeroabrar_31](/aeroabrar_31) it would not change it \\'X\\' run the example on the code and see for yourself. this heyidk guy  is right "
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[[\"O\",\"O\",\"O\"],\\n[\"O\",\"O\",\"O\"],\\n[\"O\",\"O\",\"O\"]]\\n\\nfor this example, answer should be unchanged.\\nBut by your discussion, it would change the middle \\'O\\' to \\'X\\' which is not on the boundary.\\n\\n[[\"O\",\"O\",\"O\"],\\n[\"O\",\"X\",\"O\"],\\n[\"O\",\"O\",\"O\"]]"
                    },
                    {
                        "username": "anandA3B",
                        "content": "OMG. It is an capital O. and not a zero. i went through my code soooo many times. then i realised that it is not a zero. smh."
                    },
                    {
                        "username": "vamsi369",
                        "content": "Input = [[\"O\",\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"O\",\"X\",\"O\"],[\"X\",\"O\",\"X\",\"O\",\"X\"],[\"O\",\"X\",\"O\",\"O\",\"O\"],[\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\n\\nExpected Output = [[\"O\",\"X\",\"X\",\"O\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"O\"],[\"X\",\"X\",\"X\",\"O\",\"X\"],[\"O\",\"X\",\"O\",\"O\",\"O\"],[\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nwhy is the \"O in 3rd row 4th column will not get flipped to \"X\", i could see it is surrounded with \"X\" in all directions"
                    },
                    {
                        "username": "user196",
                        "content": "130. Surrounded Regions needs either 1-2 more example or clear definition of \"Surrounded\""
                    },
                    {
                        "username": "nikhpand",
                        "content": "I can see that BFS based solutions are able to pass the tests but the DFS based solutions are failing (I am getting stack overflow). Any particular reason as to why BFS should be preferred here ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "One of the worst-formulated porblems I have ever seen on leetcode. No explanation of rules, one poor example, but a pretty strict runtime limit. The author is a horrible person."
                    },
                    {
                        "username": "j3ffhu",
                        "content": "BFS should work, add all border O to queue and BFS visit its neighbors O\\nAt the end, flip  unvisited O\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Gave me TLE but my DFS solved it 99%"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video. \\n\\nhttps://vimeo.com/641013608"
                    },
                    {
                        "username": "triples13",
                        "content": "This post is for people looking to compare with island problem, it took me a while to correlate with island problem so thought it would help someone who is looking to correlate \\n\\n* island problem ->to find all 1\\'s which form an island with no condition , so we do dfs to find all 1\\'s which form island and mark them as visited and we count as 1 island\\n\\n* surrounded regions ->we have to find all o\\'s which can be replaced with x\\'s , but with a catch o\\'s which lies with boundary o\\'s either horizaontaly or verticaly can\\'t be replaced with x\\'s , so similar to island problem we find o\\'s which can\\'t be replaced starting with boundary and marking them as visited  and at the end we replaced unmarked o\\'s with x\\'s"
                    }
                ]
            },
            {
                "id": 1574975,
                "content": [
                    {
                        "username": "user6994",
                        "content": "Input \\nO X X O X \\nX O O X O \\nX O X O X \\nO X O O O \\nX X O X O\\n\\nExpected\\nO X X O X \\nX X X X O \\nX X X O X \\nO X O O O \\nX X O X O \\n\\nCan\\'t understand  why 3rd row 4th column  remains \\'O\\'. It can be flipped as it\\'s not connected to \\'O\\' that is a border cell."
                    },
                    {
                        "username": "heyidk",
                        "content": "- Just turn the connected \\'O\\'s from 4 bound lines into \\'.\\'s (any character besides \\'O\\' and \\'X\\'), then turn all the remaining \\'O\\'s into \\'X\\', and recover the \\'.\\'s at the same time. Actually some easy problems got more complicacted than this one.\\n- I was just wondering how it could be tagged with \\'medium\\'... anyone agrees?"
                    },
                    {
                        "username": "himaniac",
                        "content": "[@aeroabrar_31](/aeroabrar_31) it would not change it \\'X\\' run the example on the code and see for yourself. this heyidk guy  is right "
                    },
                    {
                        "username": "aeroabrar_31",
                        "content": "[[\"O\",\"O\",\"O\"],\\n[\"O\",\"O\",\"O\"],\\n[\"O\",\"O\",\"O\"]]\\n\\nfor this example, answer should be unchanged.\\nBut by your discussion, it would change the middle \\'O\\' to \\'X\\' which is not on the boundary.\\n\\n[[\"O\",\"O\",\"O\"],\\n[\"O\",\"X\",\"O\"],\\n[\"O\",\"O\",\"O\"]]"
                    },
                    {
                        "username": "anandA3B",
                        "content": "OMG. It is an capital O. and not a zero. i went through my code soooo many times. then i realised that it is not a zero. smh."
                    },
                    {
                        "username": "vamsi369",
                        "content": "Input = [[\"O\",\"X\",\"X\",\"O\",\"X\"],[\"X\",\"O\",\"O\",\"X\",\"O\"],[\"X\",\"O\",\"X\",\"O\",\"X\"],[\"O\",\"X\",\"O\",\"O\",\"O\"],[\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\n\\nExpected Output = [[\"O\",\"X\",\"X\",\"O\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"O\"],[\"X\",\"X\",\"X\",\"O\",\"X\"],[\"O\",\"X\",\"O\",\"O\",\"O\"],[\"X\",\"X\",\"O\",\"X\",\"O\"]]\\n\\nwhy is the \"O in 3rd row 4th column will not get flipped to \"X\", i could see it is surrounded with \"X\" in all directions"
                    },
                    {
                        "username": "user196",
                        "content": "130. Surrounded Regions needs either 1-2 more example or clear definition of \"Surrounded\""
                    },
                    {
                        "username": "nikhpand",
                        "content": "I can see that BFS based solutions are able to pass the tests but the DFS based solutions are failing (I am getting stack overflow). Any particular reason as to why BFS should be preferred here ?"
                    },
                    {
                        "username": "dsapelnikov",
                        "content": "One of the worst-formulated porblems I have ever seen on leetcode. No explanation of rules, one poor example, but a pretty strict runtime limit. The author is a horrible person."
                    },
                    {
                        "username": "j3ffhu",
                        "content": "BFS should work, add all border O to queue and BFS visit its neighbors O\\nAt the end, flip  unvisited O\\n"
                    },
                    {
                        "username": "mochiball",
                        "content": "Gave me TLE but my DFS solved it 99%"
                    },
                    {
                        "username": "bayarkhuu",
                        "content": "Hi everyone. While i was solving the problem, i just recorded. Please contact me, I like my video. \\n\\nhttps://vimeo.com/641013608"
                    },
                    {
                        "username": "triples13",
                        "content": "This post is for people looking to compare with island problem, it took me a while to correlate with island problem so thought it would help someone who is looking to correlate \\n\\n* island problem ->to find all 1\\'s which form an island with no condition , so we do dfs to find all 1\\'s which form island and mark them as visited and we count as 1 island\\n\\n* surrounded regions ->we have to find all o\\'s which can be replaced with x\\'s , but with a catch o\\'s which lies with boundary o\\'s either horizaontaly or verticaly can\\'t be replaced with x\\'s , so similar to island problem we find o\\'s which can\\'t be replaced starting with boundary and marking them as visited  and at the end we replaced unmarked o\\'s with x\\'s"
                    }
                ]
            },
            {
                "id": 1573185,
                "content": [
                    {
                        "username": "ajaxpal",
                        "content": "feels like this question needs a lot more explanation to do, which in turn makes this a bad question.  Super surprised to see all the discussions with solutions. Enough venting! have fun, i\\'m skipping it."
                    },
                    {
                        "username": "110abidi",
                        "content": "How is this a graph problem? "
                    },
                    {
                        "username": "yuren1978",
                        "content": "Is there a way to see how many test cases my code passed?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "By running the code you are able to check this"
                    },
                    {
                        "username": "zaalimmanu",
                        "content": "Did not understand this testcase here \\n[[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"]]\\n\\nexpected output is [[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"]]\\n\\nwhy is the X at [1,1] flipped here, are we not flipping \\'O\\'s only ?\\nAm i missing something"
                    },
                    {
                        "username": "naveen17797",
                        "content": "The cells at the border with \"O\" are never surrounded by \"X\", assume the entire grid is surrounded by \"O\", if the cell at border \"O\" is not surrounded by \"X\", then any adjacent cells connected to the border cell share the same property"
                    },
                    {
                        "username": "leetcancode",
                        "content": "This \"captured by\" was really difficult to understand."
                    },
                    {
                        "username": "gowtham6309",
                        "content": "Damn. I was able to solve this problem on my own! \"Reverse Thinking helps\" :')"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "why my bfs solution gives TLE? "
                    },
                    {
                        "username": "ABHISHEKVALSAN",
                        "content": "It is  letter \"X\"  and letter \"O\" as strings, and not letter \"X\" and number \"0\" as string.\\n\\n:/"
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "First of all its alphabet \\'O\\' and not numerical \\'0\\'"
                    }
                ]
            },
            {
                "id": 1571937,
                "content": [
                    {
                        "username": "ajaxpal",
                        "content": "feels like this question needs a lot more explanation to do, which in turn makes this a bad question.  Super surprised to see all the discussions with solutions. Enough venting! have fun, i\\'m skipping it."
                    },
                    {
                        "username": "110abidi",
                        "content": "How is this a graph problem? "
                    },
                    {
                        "username": "yuren1978",
                        "content": "Is there a way to see how many test cases my code passed?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "By running the code you are able to check this"
                    },
                    {
                        "username": "zaalimmanu",
                        "content": "Did not understand this testcase here \\n[[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"]]\\n\\nexpected output is [[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"]]\\n\\nwhy is the X at [1,1] flipped here, are we not flipping \\'O\\'s only ?\\nAm i missing something"
                    },
                    {
                        "username": "naveen17797",
                        "content": "The cells at the border with \"O\" are never surrounded by \"X\", assume the entire grid is surrounded by \"O\", if the cell at border \"O\" is not surrounded by \"X\", then any adjacent cells connected to the border cell share the same property"
                    },
                    {
                        "username": "leetcancode",
                        "content": "This \"captured by\" was really difficult to understand."
                    },
                    {
                        "username": "gowtham6309",
                        "content": "Damn. I was able to solve this problem on my own! \"Reverse Thinking helps\" :')"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "why my bfs solution gives TLE? "
                    },
                    {
                        "username": "ABHISHEKVALSAN",
                        "content": "It is  letter \"X\"  and letter \"O\" as strings, and not letter \"X\" and number \"0\" as string.\\n\\n:/"
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "First of all its alphabet \\'O\\' and not numerical \\'0\\'"
                    }
                ]
            },
            {
                "id": 1571281,
                "content": [
                    {
                        "username": "ajaxpal",
                        "content": "feels like this question needs a lot more explanation to do, which in turn makes this a bad question.  Super surprised to see all the discussions with solutions. Enough venting! have fun, i\\'m skipping it."
                    },
                    {
                        "username": "110abidi",
                        "content": "How is this a graph problem? "
                    },
                    {
                        "username": "yuren1978",
                        "content": "Is there a way to see how many test cases my code passed?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "By running the code you are able to check this"
                    },
                    {
                        "username": "zaalimmanu",
                        "content": "Did not understand this testcase here \\n[[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"]]\\n\\nexpected output is [[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"]]\\n\\nwhy is the X at [1,1] flipped here, are we not flipping \\'O\\'s only ?\\nAm i missing something"
                    },
                    {
                        "username": "naveen17797",
                        "content": "The cells at the border with \"O\" are never surrounded by \"X\", assume the entire grid is surrounded by \"O\", if the cell at border \"O\" is not surrounded by \"X\", then any adjacent cells connected to the border cell share the same property"
                    },
                    {
                        "username": "leetcancode",
                        "content": "This \"captured by\" was really difficult to understand."
                    },
                    {
                        "username": "gowtham6309",
                        "content": "Damn. I was able to solve this problem on my own! \"Reverse Thinking helps\" :')"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "why my bfs solution gives TLE? "
                    },
                    {
                        "username": "ABHISHEKVALSAN",
                        "content": "It is  letter \"X\"  and letter \"O\" as strings, and not letter \"X\" and number \"0\" as string.\\n\\n:/"
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "First of all its alphabet \\'O\\' and not numerical \\'0\\'"
                    }
                ]
            },
            {
                "id": 2058670,
                "content": [
                    {
                        "username": "ajaxpal",
                        "content": "feels like this question needs a lot more explanation to do, which in turn makes this a bad question.  Super surprised to see all the discussions with solutions. Enough venting! have fun, i\\'m skipping it."
                    },
                    {
                        "username": "110abidi",
                        "content": "How is this a graph problem? "
                    },
                    {
                        "username": "yuren1978",
                        "content": "Is there a way to see how many test cases my code passed?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "By running the code you are able to check this"
                    },
                    {
                        "username": "zaalimmanu",
                        "content": "Did not understand this testcase here \\n[[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"]]\\n\\nexpected output is [[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"]]\\n\\nwhy is the X at [1,1] flipped here, are we not flipping \\'O\\'s only ?\\nAm i missing something"
                    },
                    {
                        "username": "naveen17797",
                        "content": "The cells at the border with \"O\" are never surrounded by \"X\", assume the entire grid is surrounded by \"O\", if the cell at border \"O\" is not surrounded by \"X\", then any adjacent cells connected to the border cell share the same property"
                    },
                    {
                        "username": "leetcancode",
                        "content": "This \"captured by\" was really difficult to understand."
                    },
                    {
                        "username": "gowtham6309",
                        "content": "Damn. I was able to solve this problem on my own! \"Reverse Thinking helps\" :')"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "why my bfs solution gives TLE? "
                    },
                    {
                        "username": "ABHISHEKVALSAN",
                        "content": "It is  letter \"X\"  and letter \"O\" as strings, and not letter \"X\" and number \"0\" as string.\\n\\n:/"
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "First of all its alphabet \\'O\\' and not numerical \\'0\\'"
                    }
                ]
            },
            {
                "id": 2057381,
                "content": [
                    {
                        "username": "ajaxpal",
                        "content": "feels like this question needs a lot more explanation to do, which in turn makes this a bad question.  Super surprised to see all the discussions with solutions. Enough venting! have fun, i\\'m skipping it."
                    },
                    {
                        "username": "110abidi",
                        "content": "How is this a graph problem? "
                    },
                    {
                        "username": "yuren1978",
                        "content": "Is there a way to see how many test cases my code passed?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "By running the code you are able to check this"
                    },
                    {
                        "username": "zaalimmanu",
                        "content": "Did not understand this testcase here \\n[[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"]]\\n\\nexpected output is [[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"]]\\n\\nwhy is the X at [1,1] flipped here, are we not flipping \\'O\\'s only ?\\nAm i missing something"
                    },
                    {
                        "username": "naveen17797",
                        "content": "The cells at the border with \"O\" are never surrounded by \"X\", assume the entire grid is surrounded by \"O\", if the cell at border \"O\" is not surrounded by \"X\", then any adjacent cells connected to the border cell share the same property"
                    },
                    {
                        "username": "leetcancode",
                        "content": "This \"captured by\" was really difficult to understand."
                    },
                    {
                        "username": "gowtham6309",
                        "content": "Damn. I was able to solve this problem on my own! \"Reverse Thinking helps\" :')"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "why my bfs solution gives TLE? "
                    },
                    {
                        "username": "ABHISHEKVALSAN",
                        "content": "It is  letter \"X\"  and letter \"O\" as strings, and not letter \"X\" and number \"0\" as string.\\n\\n:/"
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "First of all its alphabet \\'O\\' and not numerical \\'0\\'"
                    }
                ]
            },
            {
                "id": 2045340,
                "content": [
                    {
                        "username": "ajaxpal",
                        "content": "feels like this question needs a lot more explanation to do, which in turn makes this a bad question.  Super surprised to see all the discussions with solutions. Enough venting! have fun, i\\'m skipping it."
                    },
                    {
                        "username": "110abidi",
                        "content": "How is this a graph problem? "
                    },
                    {
                        "username": "yuren1978",
                        "content": "Is there a way to see how many test cases my code passed?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "By running the code you are able to check this"
                    },
                    {
                        "username": "zaalimmanu",
                        "content": "Did not understand this testcase here \\n[[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"]]\\n\\nexpected output is [[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"]]\\n\\nwhy is the X at [1,1] flipped here, are we not flipping \\'O\\'s only ?\\nAm i missing something"
                    },
                    {
                        "username": "naveen17797",
                        "content": "The cells at the border with \"O\" are never surrounded by \"X\", assume the entire grid is surrounded by \"O\", if the cell at border \"O\" is not surrounded by \"X\", then any adjacent cells connected to the border cell share the same property"
                    },
                    {
                        "username": "leetcancode",
                        "content": "This \"captured by\" was really difficult to understand."
                    },
                    {
                        "username": "gowtham6309",
                        "content": "Damn. I was able to solve this problem on my own! \"Reverse Thinking helps\" :')"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "why my bfs solution gives TLE? "
                    },
                    {
                        "username": "ABHISHEKVALSAN",
                        "content": "It is  letter \"X\"  and letter \"O\" as strings, and not letter \"X\" and number \"0\" as string.\\n\\n:/"
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "First of all its alphabet \\'O\\' and not numerical \\'0\\'"
                    }
                ]
            },
            {
                "id": 2031759,
                "content": [
                    {
                        "username": "ajaxpal",
                        "content": "feels like this question needs a lot more explanation to do, which in turn makes this a bad question.  Super surprised to see all the discussions with solutions. Enough venting! have fun, i\\'m skipping it."
                    },
                    {
                        "username": "110abidi",
                        "content": "How is this a graph problem? "
                    },
                    {
                        "username": "yuren1978",
                        "content": "Is there a way to see how many test cases my code passed?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "By running the code you are able to check this"
                    },
                    {
                        "username": "zaalimmanu",
                        "content": "Did not understand this testcase here \\n[[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"]]\\n\\nexpected output is [[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"]]\\n\\nwhy is the X at [1,1] flipped here, are we not flipping \\'O\\'s only ?\\nAm i missing something"
                    },
                    {
                        "username": "naveen17797",
                        "content": "The cells at the border with \"O\" are never surrounded by \"X\", assume the entire grid is surrounded by \"O\", if the cell at border \"O\" is not surrounded by \"X\", then any adjacent cells connected to the border cell share the same property"
                    },
                    {
                        "username": "leetcancode",
                        "content": "This \"captured by\" was really difficult to understand."
                    },
                    {
                        "username": "gowtham6309",
                        "content": "Damn. I was able to solve this problem on my own! \"Reverse Thinking helps\" :')"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "why my bfs solution gives TLE? "
                    },
                    {
                        "username": "ABHISHEKVALSAN",
                        "content": "It is  letter \"X\"  and letter \"O\" as strings, and not letter \"X\" and number \"0\" as string.\\n\\n:/"
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "First of all its alphabet \\'O\\' and not numerical \\'0\\'"
                    }
                ]
            },
            {
                "id": 2025010,
                "content": [
                    {
                        "username": "ajaxpal",
                        "content": "feels like this question needs a lot more explanation to do, which in turn makes this a bad question.  Super surprised to see all the discussions with solutions. Enough venting! have fun, i\\'m skipping it."
                    },
                    {
                        "username": "110abidi",
                        "content": "How is this a graph problem? "
                    },
                    {
                        "username": "yuren1978",
                        "content": "Is there a way to see how many test cases my code passed?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "By running the code you are able to check this"
                    },
                    {
                        "username": "zaalimmanu",
                        "content": "Did not understand this testcase here \\n[[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"]]\\n\\nexpected output is [[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"]]\\n\\nwhy is the X at [1,1] flipped here, are we not flipping \\'O\\'s only ?\\nAm i missing something"
                    },
                    {
                        "username": "naveen17797",
                        "content": "The cells at the border with \"O\" are never surrounded by \"X\", assume the entire grid is surrounded by \"O\", if the cell at border \"O\" is not surrounded by \"X\", then any adjacent cells connected to the border cell share the same property"
                    },
                    {
                        "username": "leetcancode",
                        "content": "This \"captured by\" was really difficult to understand."
                    },
                    {
                        "username": "gowtham6309",
                        "content": "Damn. I was able to solve this problem on my own! \"Reverse Thinking helps\" :')"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "why my bfs solution gives TLE? "
                    },
                    {
                        "username": "ABHISHEKVALSAN",
                        "content": "It is  letter \"X\"  and letter \"O\" as strings, and not letter \"X\" and number \"0\" as string.\\n\\n:/"
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "First of all its alphabet \\'O\\' and not numerical \\'0\\'"
                    }
                ]
            },
            {
                "id": 2010907,
                "content": [
                    {
                        "username": "ajaxpal",
                        "content": "feels like this question needs a lot more explanation to do, which in turn makes this a bad question.  Super surprised to see all the discussions with solutions. Enough venting! have fun, i\\'m skipping it."
                    },
                    {
                        "username": "110abidi",
                        "content": "How is this a graph problem? "
                    },
                    {
                        "username": "yuren1978",
                        "content": "Is there a way to see how many test cases my code passed?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "By running the code you are able to check this"
                    },
                    {
                        "username": "zaalimmanu",
                        "content": "Did not understand this testcase here \\n[[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"]]\\n\\nexpected output is [[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"]]\\n\\nwhy is the X at [1,1] flipped here, are we not flipping \\'O\\'s only ?\\nAm i missing something"
                    },
                    {
                        "username": "naveen17797",
                        "content": "The cells at the border with \"O\" are never surrounded by \"X\", assume the entire grid is surrounded by \"O\", if the cell at border \"O\" is not surrounded by \"X\", then any adjacent cells connected to the border cell share the same property"
                    },
                    {
                        "username": "leetcancode",
                        "content": "This \"captured by\" was really difficult to understand."
                    },
                    {
                        "username": "gowtham6309",
                        "content": "Damn. I was able to solve this problem on my own! \"Reverse Thinking helps\" :')"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "why my bfs solution gives TLE? "
                    },
                    {
                        "username": "ABHISHEKVALSAN",
                        "content": "It is  letter \"X\"  and letter \"O\" as strings, and not letter \"X\" and number \"0\" as string.\\n\\n:/"
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "First of all its alphabet \\'O\\' and not numerical \\'0\\'"
                    }
                ]
            },
            {
                "id": 2003656,
                "content": [
                    {
                        "username": "ajaxpal",
                        "content": "feels like this question needs a lot more explanation to do, which in turn makes this a bad question.  Super surprised to see all the discussions with solutions. Enough venting! have fun, i\\'m skipping it."
                    },
                    {
                        "username": "110abidi",
                        "content": "How is this a graph problem? "
                    },
                    {
                        "username": "yuren1978",
                        "content": "Is there a way to see how many test cases my code passed?"
                    },
                    {
                        "username": "Crispy_coffee",
                        "content": "By running the code you are able to check this"
                    },
                    {
                        "username": "zaalimmanu",
                        "content": "Did not understand this testcase here \\n[[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"]]\\n\\nexpected output is [[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"],[\"X\",\"O\",\"X\"]]\\n\\nwhy is the X at [1,1] flipped here, are we not flipping \\'O\\'s only ?\\nAm i missing something"
                    },
                    {
                        "username": "naveen17797",
                        "content": "The cells at the border with \"O\" are never surrounded by \"X\", assume the entire grid is surrounded by \"O\", if the cell at border \"O\" is not surrounded by \"X\", then any adjacent cells connected to the border cell share the same property"
                    },
                    {
                        "username": "leetcancode",
                        "content": "This \"captured by\" was really difficult to understand."
                    },
                    {
                        "username": "gowtham6309",
                        "content": "Damn. I was able to solve this problem on my own! \"Reverse Thinking helps\" :')"
                    },
                    {
                        "username": "Tamilselvan_B",
                        "content": "why my bfs solution gives TLE? "
                    },
                    {
                        "username": "ABHISHEKVALSAN",
                        "content": "It is  letter \"X\"  and letter \"O\" as strings, and not letter \"X\" and number \"0\" as string.\\n\\n:/"
                    },
                    {
                        "username": "mayankgagneja2002",
                        "content": "First of all its alphabet \\'O\\' and not numerical \\'0\\'"
                    }
                ]
            },
            {
                "id": 2001191,
                "content": [
                    {
                        "username": "mochiball",
                        "content": "My DFS code is 99% but BFS gives me TLE. Weird \n\nI actually really like this question. Its tricky and forces you to think out of the box after doing the other Island problems "
                    },
                    {
                        "username": "SG-C",
                        "content": "please leetcode give more clear context or description of problems otherwise it is difficult to understand"
                    },
                    {
                        "username": "harshdevs",
                        "content": "Y\\'all lowkey need someone who knows how to convey their thoughts through a question!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "The symbol is not zero it is capital O"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "a simple solution using DFS:-\\n\\n\\n `your inline code...your inline code...`\\n\\n\\n\\n\\n\\nclass Solution {\\n    public void solve(char[][] board) {\\n        boolean[][]visited=new boolean[board.length][board[0].length];\\n\\n        //Find boundaries from row=0 and row=board.length-1.\\n        for(int i=0;i<board[0].length;i++){\\n           //top row=0\\n           if(board[0][i]==\\'O\\' && visited[0][i]==false){\\n               dfs(board,0,i,visited);\\n           }\\n           //bottom row row=board.length-1\\n           if(board[board.length-1][i]==\\'O\\' && visited[board.length-1][i]==false){\\n               dfs(board,board.length-1,i,visited);\\n           }\\n        }\\n\\n        //find boundaries in colums colum=0 and coloums=board[0].length-1\\n        for(int i=0;i<board.length;i++){\\n           //col=0  \\n            if(board[i][0]==\\'O\\' && visited[i][0]==false){\\n                dfs(board,i,0,visited);\\n            }\\n           //col= board[0].length-1\\n           if(board[i][board[0].length-1]==\\'O\\' && visited[i][board[0].length-1]==false){\\n               dfs(board,i,board[0].length-1,visited);\\n           }\\n        }\\n        // here we loop again through the matrix and any unvisited O visited[r][c]==fasle where board[r][c]==\\'O\\' we converted to X.\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[i].length;j++){\\n                if(board[i][j]==\\'O\\' && visited[i][j]==false)\\n                   board[i][j]=\\'X\\';\\n            }\\n        }\\n    }\\n    \\n    void dfs(char[][] board,int r,int c,boolean[][]visited){\\n       if(r<0 || r>=board.length || c<0 || c>=board[0].length || board[r][c]==\\'X\\' || visited[r][c]==true)\\n         return;\\n\\n         visited[r][c]=true;\\n\\n         dfs(board,r,c+1,visited);\\n         dfs(board,r,c-1,visited);\\n         dfs(board,r+1,c,visited);\\n         dfs(board,r-1,c,visited);\\n    }\\n\\n    \\n    }\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "this question is what gfg has, replace Os with X"
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three \\'o\\' are surrounded regions? I mean, the \\'o\\' in the third row has another \\'o\\' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "chillychestnuts",
                        "content": "I don't understand why\ninput: [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"O\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]\nx x x x x\nx x o x x\nx o o o x\nx x o x x\nx x x x x\n\nCorrect output is below:\n [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]\nx x x x x\nx x x x x\nx x x x x\nx x x x x\nx x x x x\n\n??? Shouldn't the grid[2][2] stay as \"O\" since it's not surrounded by \"X\" nor is it a part of the path that leads to the borders?"
                    },
                    {
                        "username": "13114199adarsh",
                        "content": "The problem involves working with a 2D matrix (board) of size m x n, where each cell can have either of two possible values: \\'X\\' or \\'O\\'. The goal is to capture all regions that are completely surrounded by \\'X\\'. A region is considered surrounded by \\'X\\' if all the cells in that region are surrounded by \\'X\\' in all four directions (up, down, left, and right).\\n\\nTo capture a region, all the \\'O\\'s in that region need to be flipped to \\'X\\'s. However, an \\'O\\' should not be flipped if it is on the border of the board or adjacent to an \\'O\\' that should not be flipped.\\n\\nThe output should be the board with all the captured regions having all their \\'O\\'s flipped to \\'X\\'s."
                    },
                    {
                        "username": "tpandey495",
                        "content": "Problem statement is very difficult to understand.It does\\'nt clearly specify that what does sorrounded means.\\n"
                    }
                ]
            },
            {
                "id": 1955076,
                "content": [
                    {
                        "username": "mochiball",
                        "content": "My DFS code is 99% but BFS gives me TLE. Weird \n\nI actually really like this question. Its tricky and forces you to think out of the box after doing the other Island problems "
                    },
                    {
                        "username": "SG-C",
                        "content": "please leetcode give more clear context or description of problems otherwise it is difficult to understand"
                    },
                    {
                        "username": "harshdevs",
                        "content": "Y\\'all lowkey need someone who knows how to convey their thoughts through a question!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "The symbol is not zero it is capital O"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "a simple solution using DFS:-\\n\\n\\n `your inline code...your inline code...`\\n\\n\\n\\n\\n\\nclass Solution {\\n    public void solve(char[][] board) {\\n        boolean[][]visited=new boolean[board.length][board[0].length];\\n\\n        //Find boundaries from row=0 and row=board.length-1.\\n        for(int i=0;i<board[0].length;i++){\\n           //top row=0\\n           if(board[0][i]==\\'O\\' && visited[0][i]==false){\\n               dfs(board,0,i,visited);\\n           }\\n           //bottom row row=board.length-1\\n           if(board[board.length-1][i]==\\'O\\' && visited[board.length-1][i]==false){\\n               dfs(board,board.length-1,i,visited);\\n           }\\n        }\\n\\n        //find boundaries in colums colum=0 and coloums=board[0].length-1\\n        for(int i=0;i<board.length;i++){\\n           //col=0  \\n            if(board[i][0]==\\'O\\' && visited[i][0]==false){\\n                dfs(board,i,0,visited);\\n            }\\n           //col= board[0].length-1\\n           if(board[i][board[0].length-1]==\\'O\\' && visited[i][board[0].length-1]==false){\\n               dfs(board,i,board[0].length-1,visited);\\n           }\\n        }\\n        // here we loop again through the matrix and any unvisited O visited[r][c]==fasle where board[r][c]==\\'O\\' we converted to X.\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[i].length;j++){\\n                if(board[i][j]==\\'O\\' && visited[i][j]==false)\\n                   board[i][j]=\\'X\\';\\n            }\\n        }\\n    }\\n    \\n    void dfs(char[][] board,int r,int c,boolean[][]visited){\\n       if(r<0 || r>=board.length || c<0 || c>=board[0].length || board[r][c]==\\'X\\' || visited[r][c]==true)\\n         return;\\n\\n         visited[r][c]=true;\\n\\n         dfs(board,r,c+1,visited);\\n         dfs(board,r,c-1,visited);\\n         dfs(board,r+1,c,visited);\\n         dfs(board,r-1,c,visited);\\n    }\\n\\n    \\n    }\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "this question is what gfg has, replace Os with X"
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three \\'o\\' are surrounded regions? I mean, the \\'o\\' in the third row has another \\'o\\' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "chillychestnuts",
                        "content": "I don't understand why\ninput: [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"O\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]\nx x x x x\nx x o x x\nx o o o x\nx x o x x\nx x x x x\n\nCorrect output is below:\n [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]\nx x x x x\nx x x x x\nx x x x x\nx x x x x\nx x x x x\n\n??? Shouldn't the grid[2][2] stay as \"O\" since it's not surrounded by \"X\" nor is it a part of the path that leads to the borders?"
                    },
                    {
                        "username": "13114199adarsh",
                        "content": "The problem involves working with a 2D matrix (board) of size m x n, where each cell can have either of two possible values: \\'X\\' or \\'O\\'. The goal is to capture all regions that are completely surrounded by \\'X\\'. A region is considered surrounded by \\'X\\' if all the cells in that region are surrounded by \\'X\\' in all four directions (up, down, left, and right).\\n\\nTo capture a region, all the \\'O\\'s in that region need to be flipped to \\'X\\'s. However, an \\'O\\' should not be flipped if it is on the border of the board or adjacent to an \\'O\\' that should not be flipped.\\n\\nThe output should be the board with all the captured regions having all their \\'O\\'s flipped to \\'X\\'s."
                    },
                    {
                        "username": "tpandey495",
                        "content": "Problem statement is very difficult to understand.It does\\'nt clearly specify that what does sorrounded means.\\n"
                    }
                ]
            },
            {
                "id": 1949700,
                "content": [
                    {
                        "username": "mochiball",
                        "content": "My DFS code is 99% but BFS gives me TLE. Weird \n\nI actually really like this question. Its tricky and forces you to think out of the box after doing the other Island problems "
                    },
                    {
                        "username": "SG-C",
                        "content": "please leetcode give more clear context or description of problems otherwise it is difficult to understand"
                    },
                    {
                        "username": "harshdevs",
                        "content": "Y\\'all lowkey need someone who knows how to convey their thoughts through a question!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "The symbol is not zero it is capital O"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "a simple solution using DFS:-\\n\\n\\n `your inline code...your inline code...`\\n\\n\\n\\n\\n\\nclass Solution {\\n    public void solve(char[][] board) {\\n        boolean[][]visited=new boolean[board.length][board[0].length];\\n\\n        //Find boundaries from row=0 and row=board.length-1.\\n        for(int i=0;i<board[0].length;i++){\\n           //top row=0\\n           if(board[0][i]==\\'O\\' && visited[0][i]==false){\\n               dfs(board,0,i,visited);\\n           }\\n           //bottom row row=board.length-1\\n           if(board[board.length-1][i]==\\'O\\' && visited[board.length-1][i]==false){\\n               dfs(board,board.length-1,i,visited);\\n           }\\n        }\\n\\n        //find boundaries in colums colum=0 and coloums=board[0].length-1\\n        for(int i=0;i<board.length;i++){\\n           //col=0  \\n            if(board[i][0]==\\'O\\' && visited[i][0]==false){\\n                dfs(board,i,0,visited);\\n            }\\n           //col= board[0].length-1\\n           if(board[i][board[0].length-1]==\\'O\\' && visited[i][board[0].length-1]==false){\\n               dfs(board,i,board[0].length-1,visited);\\n           }\\n        }\\n        // here we loop again through the matrix and any unvisited O visited[r][c]==fasle where board[r][c]==\\'O\\' we converted to X.\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[i].length;j++){\\n                if(board[i][j]==\\'O\\' && visited[i][j]==false)\\n                   board[i][j]=\\'X\\';\\n            }\\n        }\\n    }\\n    \\n    void dfs(char[][] board,int r,int c,boolean[][]visited){\\n       if(r<0 || r>=board.length || c<0 || c>=board[0].length || board[r][c]==\\'X\\' || visited[r][c]==true)\\n         return;\\n\\n         visited[r][c]=true;\\n\\n         dfs(board,r,c+1,visited);\\n         dfs(board,r,c-1,visited);\\n         dfs(board,r+1,c,visited);\\n         dfs(board,r-1,c,visited);\\n    }\\n\\n    \\n    }\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "this question is what gfg has, replace Os with X"
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three \\'o\\' are surrounded regions? I mean, the \\'o\\' in the third row has another \\'o\\' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "chillychestnuts",
                        "content": "I don't understand why\ninput: [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"O\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]\nx x x x x\nx x o x x\nx o o o x\nx x o x x\nx x x x x\n\nCorrect output is below:\n [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]\nx x x x x\nx x x x x\nx x x x x\nx x x x x\nx x x x x\n\n??? Shouldn't the grid[2][2] stay as \"O\" since it's not surrounded by \"X\" nor is it a part of the path that leads to the borders?"
                    },
                    {
                        "username": "13114199adarsh",
                        "content": "The problem involves working with a 2D matrix (board) of size m x n, where each cell can have either of two possible values: \\'X\\' or \\'O\\'. The goal is to capture all regions that are completely surrounded by \\'X\\'. A region is considered surrounded by \\'X\\' if all the cells in that region are surrounded by \\'X\\' in all four directions (up, down, left, and right).\\n\\nTo capture a region, all the \\'O\\'s in that region need to be flipped to \\'X\\'s. However, an \\'O\\' should not be flipped if it is on the border of the board or adjacent to an \\'O\\' that should not be flipped.\\n\\nThe output should be the board with all the captured regions having all their \\'O\\'s flipped to \\'X\\'s."
                    },
                    {
                        "username": "tpandey495",
                        "content": "Problem statement is very difficult to understand.It does\\'nt clearly specify that what does sorrounded means.\\n"
                    }
                ]
            },
            {
                "id": 1926199,
                "content": [
                    {
                        "username": "mochiball",
                        "content": "My DFS code is 99% but BFS gives me TLE. Weird \n\nI actually really like this question. Its tricky and forces you to think out of the box after doing the other Island problems "
                    },
                    {
                        "username": "SG-C",
                        "content": "please leetcode give more clear context or description of problems otherwise it is difficult to understand"
                    },
                    {
                        "username": "harshdevs",
                        "content": "Y\\'all lowkey need someone who knows how to convey their thoughts through a question!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "The symbol is not zero it is capital O"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "a simple solution using DFS:-\\n\\n\\n `your inline code...your inline code...`\\n\\n\\n\\n\\n\\nclass Solution {\\n    public void solve(char[][] board) {\\n        boolean[][]visited=new boolean[board.length][board[0].length];\\n\\n        //Find boundaries from row=0 and row=board.length-1.\\n        for(int i=0;i<board[0].length;i++){\\n           //top row=0\\n           if(board[0][i]==\\'O\\' && visited[0][i]==false){\\n               dfs(board,0,i,visited);\\n           }\\n           //bottom row row=board.length-1\\n           if(board[board.length-1][i]==\\'O\\' && visited[board.length-1][i]==false){\\n               dfs(board,board.length-1,i,visited);\\n           }\\n        }\\n\\n        //find boundaries in colums colum=0 and coloums=board[0].length-1\\n        for(int i=0;i<board.length;i++){\\n           //col=0  \\n            if(board[i][0]==\\'O\\' && visited[i][0]==false){\\n                dfs(board,i,0,visited);\\n            }\\n           //col= board[0].length-1\\n           if(board[i][board[0].length-1]==\\'O\\' && visited[i][board[0].length-1]==false){\\n               dfs(board,i,board[0].length-1,visited);\\n           }\\n        }\\n        // here we loop again through the matrix and any unvisited O visited[r][c]==fasle where board[r][c]==\\'O\\' we converted to X.\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[i].length;j++){\\n                if(board[i][j]==\\'O\\' && visited[i][j]==false)\\n                   board[i][j]=\\'X\\';\\n            }\\n        }\\n    }\\n    \\n    void dfs(char[][] board,int r,int c,boolean[][]visited){\\n       if(r<0 || r>=board.length || c<0 || c>=board[0].length || board[r][c]==\\'X\\' || visited[r][c]==true)\\n         return;\\n\\n         visited[r][c]=true;\\n\\n         dfs(board,r,c+1,visited);\\n         dfs(board,r,c-1,visited);\\n         dfs(board,r+1,c,visited);\\n         dfs(board,r-1,c,visited);\\n    }\\n\\n    \\n    }\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "this question is what gfg has, replace Os with X"
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three \\'o\\' are surrounded regions? I mean, the \\'o\\' in the third row has another \\'o\\' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "chillychestnuts",
                        "content": "I don't understand why\ninput: [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"O\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]\nx x x x x\nx x o x x\nx o o o x\nx x o x x\nx x x x x\n\nCorrect output is below:\n [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]\nx x x x x\nx x x x x\nx x x x x\nx x x x x\nx x x x x\n\n??? Shouldn't the grid[2][2] stay as \"O\" since it's not surrounded by \"X\" nor is it a part of the path that leads to the borders?"
                    },
                    {
                        "username": "13114199adarsh",
                        "content": "The problem involves working with a 2D matrix (board) of size m x n, where each cell can have either of two possible values: \\'X\\' or \\'O\\'. The goal is to capture all regions that are completely surrounded by \\'X\\'. A region is considered surrounded by \\'X\\' if all the cells in that region are surrounded by \\'X\\' in all four directions (up, down, left, and right).\\n\\nTo capture a region, all the \\'O\\'s in that region need to be flipped to \\'X\\'s. However, an \\'O\\' should not be flipped if it is on the border of the board or adjacent to an \\'O\\' that should not be flipped.\\n\\nThe output should be the board with all the captured regions having all their \\'O\\'s flipped to \\'X\\'s."
                    },
                    {
                        "username": "tpandey495",
                        "content": "Problem statement is very difficult to understand.It does\\'nt clearly specify that what does sorrounded means.\\n"
                    }
                ]
            },
            {
                "id": 1900817,
                "content": [
                    {
                        "username": "mochiball",
                        "content": "My DFS code is 99% but BFS gives me TLE. Weird \n\nI actually really like this question. Its tricky and forces you to think out of the box after doing the other Island problems "
                    },
                    {
                        "username": "SG-C",
                        "content": "please leetcode give more clear context or description of problems otherwise it is difficult to understand"
                    },
                    {
                        "username": "harshdevs",
                        "content": "Y\\'all lowkey need someone who knows how to convey their thoughts through a question!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "The symbol is not zero it is capital O"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "a simple solution using DFS:-\\n\\n\\n `your inline code...your inline code...`\\n\\n\\n\\n\\n\\nclass Solution {\\n    public void solve(char[][] board) {\\n        boolean[][]visited=new boolean[board.length][board[0].length];\\n\\n        //Find boundaries from row=0 and row=board.length-1.\\n        for(int i=0;i<board[0].length;i++){\\n           //top row=0\\n           if(board[0][i]==\\'O\\' && visited[0][i]==false){\\n               dfs(board,0,i,visited);\\n           }\\n           //bottom row row=board.length-1\\n           if(board[board.length-1][i]==\\'O\\' && visited[board.length-1][i]==false){\\n               dfs(board,board.length-1,i,visited);\\n           }\\n        }\\n\\n        //find boundaries in colums colum=0 and coloums=board[0].length-1\\n        for(int i=0;i<board.length;i++){\\n           //col=0  \\n            if(board[i][0]==\\'O\\' && visited[i][0]==false){\\n                dfs(board,i,0,visited);\\n            }\\n           //col= board[0].length-1\\n           if(board[i][board[0].length-1]==\\'O\\' && visited[i][board[0].length-1]==false){\\n               dfs(board,i,board[0].length-1,visited);\\n           }\\n        }\\n        // here we loop again through the matrix and any unvisited O visited[r][c]==fasle where board[r][c]==\\'O\\' we converted to X.\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[i].length;j++){\\n                if(board[i][j]==\\'O\\' && visited[i][j]==false)\\n                   board[i][j]=\\'X\\';\\n            }\\n        }\\n    }\\n    \\n    void dfs(char[][] board,int r,int c,boolean[][]visited){\\n       if(r<0 || r>=board.length || c<0 || c>=board[0].length || board[r][c]==\\'X\\' || visited[r][c]==true)\\n         return;\\n\\n         visited[r][c]=true;\\n\\n         dfs(board,r,c+1,visited);\\n         dfs(board,r,c-1,visited);\\n         dfs(board,r+1,c,visited);\\n         dfs(board,r-1,c,visited);\\n    }\\n\\n    \\n    }\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "this question is what gfg has, replace Os with X"
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three \\'o\\' are surrounded regions? I mean, the \\'o\\' in the third row has another \\'o\\' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "chillychestnuts",
                        "content": "I don't understand why\ninput: [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"O\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]\nx x x x x\nx x o x x\nx o o o x\nx x o x x\nx x x x x\n\nCorrect output is below:\n [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]\nx x x x x\nx x x x x\nx x x x x\nx x x x x\nx x x x x\n\n??? Shouldn't the grid[2][2] stay as \"O\" since it's not surrounded by \"X\" nor is it a part of the path that leads to the borders?"
                    },
                    {
                        "username": "13114199adarsh",
                        "content": "The problem involves working with a 2D matrix (board) of size m x n, where each cell can have either of two possible values: \\'X\\' or \\'O\\'. The goal is to capture all regions that are completely surrounded by \\'X\\'. A region is considered surrounded by \\'X\\' if all the cells in that region are surrounded by \\'X\\' in all four directions (up, down, left, and right).\\n\\nTo capture a region, all the \\'O\\'s in that region need to be flipped to \\'X\\'s. However, an \\'O\\' should not be flipped if it is on the border of the board or adjacent to an \\'O\\' that should not be flipped.\\n\\nThe output should be the board with all the captured regions having all their \\'O\\'s flipped to \\'X\\'s."
                    },
                    {
                        "username": "tpandey495",
                        "content": "Problem statement is very difficult to understand.It does\\'nt clearly specify that what does sorrounded means.\\n"
                    }
                ]
            },
            {
                "id": 1898096,
                "content": [
                    {
                        "username": "mochiball",
                        "content": "My DFS code is 99% but BFS gives me TLE. Weird \n\nI actually really like this question. Its tricky and forces you to think out of the box after doing the other Island problems "
                    },
                    {
                        "username": "SG-C",
                        "content": "please leetcode give more clear context or description of problems otherwise it is difficult to understand"
                    },
                    {
                        "username": "harshdevs",
                        "content": "Y\\'all lowkey need someone who knows how to convey their thoughts through a question!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "The symbol is not zero it is capital O"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "a simple solution using DFS:-\\n\\n\\n `your inline code...your inline code...`\\n\\n\\n\\n\\n\\nclass Solution {\\n    public void solve(char[][] board) {\\n        boolean[][]visited=new boolean[board.length][board[0].length];\\n\\n        //Find boundaries from row=0 and row=board.length-1.\\n        for(int i=0;i<board[0].length;i++){\\n           //top row=0\\n           if(board[0][i]==\\'O\\' && visited[0][i]==false){\\n               dfs(board,0,i,visited);\\n           }\\n           //bottom row row=board.length-1\\n           if(board[board.length-1][i]==\\'O\\' && visited[board.length-1][i]==false){\\n               dfs(board,board.length-1,i,visited);\\n           }\\n        }\\n\\n        //find boundaries in colums colum=0 and coloums=board[0].length-1\\n        for(int i=0;i<board.length;i++){\\n           //col=0  \\n            if(board[i][0]==\\'O\\' && visited[i][0]==false){\\n                dfs(board,i,0,visited);\\n            }\\n           //col= board[0].length-1\\n           if(board[i][board[0].length-1]==\\'O\\' && visited[i][board[0].length-1]==false){\\n               dfs(board,i,board[0].length-1,visited);\\n           }\\n        }\\n        // here we loop again through the matrix and any unvisited O visited[r][c]==fasle where board[r][c]==\\'O\\' we converted to X.\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[i].length;j++){\\n                if(board[i][j]==\\'O\\' && visited[i][j]==false)\\n                   board[i][j]=\\'X\\';\\n            }\\n        }\\n    }\\n    \\n    void dfs(char[][] board,int r,int c,boolean[][]visited){\\n       if(r<0 || r>=board.length || c<0 || c>=board[0].length || board[r][c]==\\'X\\' || visited[r][c]==true)\\n         return;\\n\\n         visited[r][c]=true;\\n\\n         dfs(board,r,c+1,visited);\\n         dfs(board,r,c-1,visited);\\n         dfs(board,r+1,c,visited);\\n         dfs(board,r-1,c,visited);\\n    }\\n\\n    \\n    }\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "this question is what gfg has, replace Os with X"
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three \\'o\\' are surrounded regions? I mean, the \\'o\\' in the third row has another \\'o\\' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "chillychestnuts",
                        "content": "I don't understand why\ninput: [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"O\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]\nx x x x x\nx x o x x\nx o o o x\nx x o x x\nx x x x x\n\nCorrect output is below:\n [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]\nx x x x x\nx x x x x\nx x x x x\nx x x x x\nx x x x x\n\n??? Shouldn't the grid[2][2] stay as \"O\" since it's not surrounded by \"X\" nor is it a part of the path that leads to the borders?"
                    },
                    {
                        "username": "13114199adarsh",
                        "content": "The problem involves working with a 2D matrix (board) of size m x n, where each cell can have either of two possible values: \\'X\\' or \\'O\\'. The goal is to capture all regions that are completely surrounded by \\'X\\'. A region is considered surrounded by \\'X\\' if all the cells in that region are surrounded by \\'X\\' in all four directions (up, down, left, and right).\\n\\nTo capture a region, all the \\'O\\'s in that region need to be flipped to \\'X\\'s. However, an \\'O\\' should not be flipped if it is on the border of the board or adjacent to an \\'O\\' that should not be flipped.\\n\\nThe output should be the board with all the captured regions having all their \\'O\\'s flipped to \\'X\\'s."
                    },
                    {
                        "username": "tpandey495",
                        "content": "Problem statement is very difficult to understand.It does\\'nt clearly specify that what does sorrounded means.\\n"
                    }
                ]
            },
            {
                "id": 1865536,
                "content": [
                    {
                        "username": "mochiball",
                        "content": "My DFS code is 99% but BFS gives me TLE. Weird \n\nI actually really like this question. Its tricky and forces you to think out of the box after doing the other Island problems "
                    },
                    {
                        "username": "SG-C",
                        "content": "please leetcode give more clear context or description of problems otherwise it is difficult to understand"
                    },
                    {
                        "username": "harshdevs",
                        "content": "Y\\'all lowkey need someone who knows how to convey their thoughts through a question!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "The symbol is not zero it is capital O"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "a simple solution using DFS:-\\n\\n\\n `your inline code...your inline code...`\\n\\n\\n\\n\\n\\nclass Solution {\\n    public void solve(char[][] board) {\\n        boolean[][]visited=new boolean[board.length][board[0].length];\\n\\n        //Find boundaries from row=0 and row=board.length-1.\\n        for(int i=0;i<board[0].length;i++){\\n           //top row=0\\n           if(board[0][i]==\\'O\\' && visited[0][i]==false){\\n               dfs(board,0,i,visited);\\n           }\\n           //bottom row row=board.length-1\\n           if(board[board.length-1][i]==\\'O\\' && visited[board.length-1][i]==false){\\n               dfs(board,board.length-1,i,visited);\\n           }\\n        }\\n\\n        //find boundaries in colums colum=0 and coloums=board[0].length-1\\n        for(int i=0;i<board.length;i++){\\n           //col=0  \\n            if(board[i][0]==\\'O\\' && visited[i][0]==false){\\n                dfs(board,i,0,visited);\\n            }\\n           //col= board[0].length-1\\n           if(board[i][board[0].length-1]==\\'O\\' && visited[i][board[0].length-1]==false){\\n               dfs(board,i,board[0].length-1,visited);\\n           }\\n        }\\n        // here we loop again through the matrix and any unvisited O visited[r][c]==fasle where board[r][c]==\\'O\\' we converted to X.\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[i].length;j++){\\n                if(board[i][j]==\\'O\\' && visited[i][j]==false)\\n                   board[i][j]=\\'X\\';\\n            }\\n        }\\n    }\\n    \\n    void dfs(char[][] board,int r,int c,boolean[][]visited){\\n       if(r<0 || r>=board.length || c<0 || c>=board[0].length || board[r][c]==\\'X\\' || visited[r][c]==true)\\n         return;\\n\\n         visited[r][c]=true;\\n\\n         dfs(board,r,c+1,visited);\\n         dfs(board,r,c-1,visited);\\n         dfs(board,r+1,c,visited);\\n         dfs(board,r-1,c,visited);\\n    }\\n\\n    \\n    }\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "this question is what gfg has, replace Os with X"
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three \\'o\\' are surrounded regions? I mean, the \\'o\\' in the third row has another \\'o\\' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "chillychestnuts",
                        "content": "I don't understand why\ninput: [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"O\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]\nx x x x x\nx x o x x\nx o o o x\nx x o x x\nx x x x x\n\nCorrect output is below:\n [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]\nx x x x x\nx x x x x\nx x x x x\nx x x x x\nx x x x x\n\n??? Shouldn't the grid[2][2] stay as \"O\" since it's not surrounded by \"X\" nor is it a part of the path that leads to the borders?"
                    },
                    {
                        "username": "13114199adarsh",
                        "content": "The problem involves working with a 2D matrix (board) of size m x n, where each cell can have either of two possible values: \\'X\\' or \\'O\\'. The goal is to capture all regions that are completely surrounded by \\'X\\'. A region is considered surrounded by \\'X\\' if all the cells in that region are surrounded by \\'X\\' in all four directions (up, down, left, and right).\\n\\nTo capture a region, all the \\'O\\'s in that region need to be flipped to \\'X\\'s. However, an \\'O\\' should not be flipped if it is on the border of the board or adjacent to an \\'O\\' that should not be flipped.\\n\\nThe output should be the board with all the captured regions having all their \\'O\\'s flipped to \\'X\\'s."
                    },
                    {
                        "username": "tpandey495",
                        "content": "Problem statement is very difficult to understand.It does\\'nt clearly specify that what does sorrounded means.\\n"
                    }
                ]
            },
            {
                "id": 1860706,
                "content": [
                    {
                        "username": "mochiball",
                        "content": "My DFS code is 99% but BFS gives me TLE. Weird \n\nI actually really like this question. Its tricky and forces you to think out of the box after doing the other Island problems "
                    },
                    {
                        "username": "SG-C",
                        "content": "please leetcode give more clear context or description of problems otherwise it is difficult to understand"
                    },
                    {
                        "username": "harshdevs",
                        "content": "Y\\'all lowkey need someone who knows how to convey their thoughts through a question!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "The symbol is not zero it is capital O"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "a simple solution using DFS:-\\n\\n\\n `your inline code...your inline code...`\\n\\n\\n\\n\\n\\nclass Solution {\\n    public void solve(char[][] board) {\\n        boolean[][]visited=new boolean[board.length][board[0].length];\\n\\n        //Find boundaries from row=0 and row=board.length-1.\\n        for(int i=0;i<board[0].length;i++){\\n           //top row=0\\n           if(board[0][i]==\\'O\\' && visited[0][i]==false){\\n               dfs(board,0,i,visited);\\n           }\\n           //bottom row row=board.length-1\\n           if(board[board.length-1][i]==\\'O\\' && visited[board.length-1][i]==false){\\n               dfs(board,board.length-1,i,visited);\\n           }\\n        }\\n\\n        //find boundaries in colums colum=0 and coloums=board[0].length-1\\n        for(int i=0;i<board.length;i++){\\n           //col=0  \\n            if(board[i][0]==\\'O\\' && visited[i][0]==false){\\n                dfs(board,i,0,visited);\\n            }\\n           //col= board[0].length-1\\n           if(board[i][board[0].length-1]==\\'O\\' && visited[i][board[0].length-1]==false){\\n               dfs(board,i,board[0].length-1,visited);\\n           }\\n        }\\n        // here we loop again through the matrix and any unvisited O visited[r][c]==fasle where board[r][c]==\\'O\\' we converted to X.\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[i].length;j++){\\n                if(board[i][j]==\\'O\\' && visited[i][j]==false)\\n                   board[i][j]=\\'X\\';\\n            }\\n        }\\n    }\\n    \\n    void dfs(char[][] board,int r,int c,boolean[][]visited){\\n       if(r<0 || r>=board.length || c<0 || c>=board[0].length || board[r][c]==\\'X\\' || visited[r][c]==true)\\n         return;\\n\\n         visited[r][c]=true;\\n\\n         dfs(board,r,c+1,visited);\\n         dfs(board,r,c-1,visited);\\n         dfs(board,r+1,c,visited);\\n         dfs(board,r-1,c,visited);\\n    }\\n\\n    \\n    }\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "this question is what gfg has, replace Os with X"
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three \\'o\\' are surrounded regions? I mean, the \\'o\\' in the third row has another \\'o\\' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "chillychestnuts",
                        "content": "I don't understand why\ninput: [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"O\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]\nx x x x x\nx x o x x\nx o o o x\nx x o x x\nx x x x x\n\nCorrect output is below:\n [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]\nx x x x x\nx x x x x\nx x x x x\nx x x x x\nx x x x x\n\n??? Shouldn't the grid[2][2] stay as \"O\" since it's not surrounded by \"X\" nor is it a part of the path that leads to the borders?"
                    },
                    {
                        "username": "13114199adarsh",
                        "content": "The problem involves working with a 2D matrix (board) of size m x n, where each cell can have either of two possible values: \\'X\\' or \\'O\\'. The goal is to capture all regions that are completely surrounded by \\'X\\'. A region is considered surrounded by \\'X\\' if all the cells in that region are surrounded by \\'X\\' in all four directions (up, down, left, and right).\\n\\nTo capture a region, all the \\'O\\'s in that region need to be flipped to \\'X\\'s. However, an \\'O\\' should not be flipped if it is on the border of the board or adjacent to an \\'O\\' that should not be flipped.\\n\\nThe output should be the board with all the captured regions having all their \\'O\\'s flipped to \\'X\\'s."
                    },
                    {
                        "username": "tpandey495",
                        "content": "Problem statement is very difficult to understand.It does\\'nt clearly specify that what does sorrounded means.\\n"
                    }
                ]
            },
            {
                "id": 1810221,
                "content": [
                    {
                        "username": "mochiball",
                        "content": "My DFS code is 99% but BFS gives me TLE. Weird \n\nI actually really like this question. Its tricky and forces you to think out of the box after doing the other Island problems "
                    },
                    {
                        "username": "SG-C",
                        "content": "please leetcode give more clear context or description of problems otherwise it is difficult to understand"
                    },
                    {
                        "username": "harshdevs",
                        "content": "Y\\'all lowkey need someone who knows how to convey their thoughts through a question!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "The symbol is not zero it is capital O"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "a simple solution using DFS:-\\n\\n\\n `your inline code...your inline code...`\\n\\n\\n\\n\\n\\nclass Solution {\\n    public void solve(char[][] board) {\\n        boolean[][]visited=new boolean[board.length][board[0].length];\\n\\n        //Find boundaries from row=0 and row=board.length-1.\\n        for(int i=0;i<board[0].length;i++){\\n           //top row=0\\n           if(board[0][i]==\\'O\\' && visited[0][i]==false){\\n               dfs(board,0,i,visited);\\n           }\\n           //bottom row row=board.length-1\\n           if(board[board.length-1][i]==\\'O\\' && visited[board.length-1][i]==false){\\n               dfs(board,board.length-1,i,visited);\\n           }\\n        }\\n\\n        //find boundaries in colums colum=0 and coloums=board[0].length-1\\n        for(int i=0;i<board.length;i++){\\n           //col=0  \\n            if(board[i][0]==\\'O\\' && visited[i][0]==false){\\n                dfs(board,i,0,visited);\\n            }\\n           //col= board[0].length-1\\n           if(board[i][board[0].length-1]==\\'O\\' && visited[i][board[0].length-1]==false){\\n               dfs(board,i,board[0].length-1,visited);\\n           }\\n        }\\n        // here we loop again through the matrix and any unvisited O visited[r][c]==fasle where board[r][c]==\\'O\\' we converted to X.\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[i].length;j++){\\n                if(board[i][j]==\\'O\\' && visited[i][j]==false)\\n                   board[i][j]=\\'X\\';\\n            }\\n        }\\n    }\\n    \\n    void dfs(char[][] board,int r,int c,boolean[][]visited){\\n       if(r<0 || r>=board.length || c<0 || c>=board[0].length || board[r][c]==\\'X\\' || visited[r][c]==true)\\n         return;\\n\\n         visited[r][c]=true;\\n\\n         dfs(board,r,c+1,visited);\\n         dfs(board,r,c-1,visited);\\n         dfs(board,r+1,c,visited);\\n         dfs(board,r-1,c,visited);\\n    }\\n\\n    \\n    }\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "this question is what gfg has, replace Os with X"
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three \\'o\\' are surrounded regions? I mean, the \\'o\\' in the third row has another \\'o\\' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "chillychestnuts",
                        "content": "I don't understand why\ninput: [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"O\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]\nx x x x x\nx x o x x\nx o o o x\nx x o x x\nx x x x x\n\nCorrect output is below:\n [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]\nx x x x x\nx x x x x\nx x x x x\nx x x x x\nx x x x x\n\n??? Shouldn't the grid[2][2] stay as \"O\" since it's not surrounded by \"X\" nor is it a part of the path that leads to the borders?"
                    },
                    {
                        "username": "13114199adarsh",
                        "content": "The problem involves working with a 2D matrix (board) of size m x n, where each cell can have either of two possible values: \\'X\\' or \\'O\\'. The goal is to capture all regions that are completely surrounded by \\'X\\'. A region is considered surrounded by \\'X\\' if all the cells in that region are surrounded by \\'X\\' in all four directions (up, down, left, and right).\\n\\nTo capture a region, all the \\'O\\'s in that region need to be flipped to \\'X\\'s. However, an \\'O\\' should not be flipped if it is on the border of the board or adjacent to an \\'O\\' that should not be flipped.\\n\\nThe output should be the board with all the captured regions having all their \\'O\\'s flipped to \\'X\\'s."
                    },
                    {
                        "username": "tpandey495",
                        "content": "Problem statement is very difficult to understand.It does\\'nt clearly specify that what does sorrounded means.\\n"
                    }
                ]
            },
            {
                "id": 1795075,
                "content": [
                    {
                        "username": "mochiball",
                        "content": "My DFS code is 99% but BFS gives me TLE. Weird \n\nI actually really like this question. Its tricky and forces you to think out of the box after doing the other Island problems "
                    },
                    {
                        "username": "SG-C",
                        "content": "please leetcode give more clear context or description of problems otherwise it is difficult to understand"
                    },
                    {
                        "username": "harshdevs",
                        "content": "Y\\'all lowkey need someone who knows how to convey their thoughts through a question!"
                    },
                    {
                        "username": "jain_06_07",
                        "content": "The symbol is not zero it is capital O"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "a simple solution using DFS:-\\n\\n\\n `your inline code...your inline code...`\\n\\n\\n\\n\\n\\nclass Solution {\\n    public void solve(char[][] board) {\\n        boolean[][]visited=new boolean[board.length][board[0].length];\\n\\n        //Find boundaries from row=0 and row=board.length-1.\\n        for(int i=0;i<board[0].length;i++){\\n           //top row=0\\n           if(board[0][i]==\\'O\\' && visited[0][i]==false){\\n               dfs(board,0,i,visited);\\n           }\\n           //bottom row row=board.length-1\\n           if(board[board.length-1][i]==\\'O\\' && visited[board.length-1][i]==false){\\n               dfs(board,board.length-1,i,visited);\\n           }\\n        }\\n\\n        //find boundaries in colums colum=0 and coloums=board[0].length-1\\n        for(int i=0;i<board.length;i++){\\n           //col=0  \\n            if(board[i][0]==\\'O\\' && visited[i][0]==false){\\n                dfs(board,i,0,visited);\\n            }\\n           //col= board[0].length-1\\n           if(board[i][board[0].length-1]==\\'O\\' && visited[i][board[0].length-1]==false){\\n               dfs(board,i,board[0].length-1,visited);\\n           }\\n        }\\n        // here we loop again through the matrix and any unvisited O visited[r][c]==fasle where board[r][c]==\\'O\\' we converted to X.\\n        for(int i=0;i<board.length;i++){\\n            for(int j=0;j<board[i].length;j++){\\n                if(board[i][j]==\\'O\\' && visited[i][j]==false)\\n                   board[i][j]=\\'X\\';\\n            }\\n        }\\n    }\\n    \\n    void dfs(char[][] board,int r,int c,boolean[][]visited){\\n       if(r<0 || r>=board.length || c<0 || c>=board[0].length || board[r][c]==\\'X\\' || visited[r][c]==true)\\n         return;\\n\\n         visited[r][c]=true;\\n\\n         dfs(board,r,c+1,visited);\\n         dfs(board,r,c-1,visited);\\n         dfs(board,r+1,c,visited);\\n         dfs(board,r-1,c,visited);\\n    }\\n\\n    \\n    }\\n\\n\\n"
                    },
                    {
                        "username": "codeMonarch",
                        "content": "this question is what gfg has, replace Os with X"
                    },
                    {
                        "username": "Amarjeet2909",
                        "content": "for example:\\n\\nx x x x\\n\\nx o o x\\n\\nx x o x\\n\\nx o x x\\n\\nwhy the above three \\'o\\' are surrounded regions? I mean, the \\'o\\' in the third row has another \\'o\\' neighbored to it,so why it is still surrounded region?"
                    },
                    {
                        "username": "chillychestnuts",
                        "content": "I don't understand why\ninput: [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"O\",\"X\",\"X\"],[\"X\",\"O\",\"O\",\"O\",\"X\"],[\"X\",\"X\",\"O\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]\nx x x x x\nx x o x x\nx o o o x\nx x o x x\nx x x x x\n\nCorrect output is below:\n [[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"],[\"X\",\"X\",\"X\",\"X\",\"X\"]]\nx x x x x\nx x x x x\nx x x x x\nx x x x x\nx x x x x\n\n??? Shouldn't the grid[2][2] stay as \"O\" since it's not surrounded by \"X\" nor is it a part of the path that leads to the borders?"
                    },
                    {
                        "username": "13114199adarsh",
                        "content": "The problem involves working with a 2D matrix (board) of size m x n, where each cell can have either of two possible values: \\'X\\' or \\'O\\'. The goal is to capture all regions that are completely surrounded by \\'X\\'. A region is considered surrounded by \\'X\\' if all the cells in that region are surrounded by \\'X\\' in all four directions (up, down, left, and right).\\n\\nTo capture a region, all the \\'O\\'s in that region need to be flipped to \\'X\\'s. However, an \\'O\\' should not be flipped if it is on the border of the board or adjacent to an \\'O\\' that should not be flipped.\\n\\nThe output should be the board with all the captured regions having all their \\'O\\'s flipped to \\'X\\'s."
                    },
                    {
                        "username": "tpandey495",
                        "content": "Problem statement is very difficult to understand.It does\\'nt clearly specify that what does sorrounded means.\\n"
                    }
                ]
            },
            {
                "id": 1790272,
                "content": [
                    {
                        "username": "girishbhargava9202",
                        "content": "This problem is really easy to solve, if we apply DFS or BFS, but my union find approach is giving me wrong answer. \nPlease tell me where the code is wrong. \nclass DisjointSet{\n    public:\n    vector<int> rank , parent , size ; \n        DisjointSet(int n){\n            rank.resize(n + 1 , 0) ; \n            parent.resize(n + 1 ) ; \n            size.resize(n + 1 , 1) ; \n            for(int i = 0 ; i <= n ; ++i)\n                parent[i] = i ; \n        }\n        int findUP(int node){\n            if(node == parent[node]) return node ; \n            return parent[node] = findUP(parent[node]) ;  \n        }\n        void unionBySize(int u , int v){\n            int ulp_u = findUP(u) , ulp_v = findUP(v) ; \n            if(ulp_v == ulp_u ) return ; \n            if(size[ulp_v] > size[ulp_u]){\n                parent[ulp_u] = ulp_v ; \n                size[ulp_v] += size[ulp_u] ;\n            }\n            else{\n                parent[ulp_v] = ulp_u ; \n                size[ulp_u] += size[ulp_v] ; \n            }\n        }\n        void unionByRank(int u , int v){\n            int ulp_u = findUP(u) , ulp_v = findUP(v) ;   \n            if(rank[ulp_u] > rank[ulp_v]){\n                parent[ulp_v] = ulp_u ;\n            }else if(rank[ulp_v] > rank[ulp_u]){\n                parent[ulp_u] = ulp_v ; \n            }else{\n                parent[ulp_u] = ulp_v ; \n                ++rank[ulp_v] ; \n            }\n        }\n};\nclass Solution{\n    public:\n    int number(int i , int j , int n , int m){\n        return (i * m) + j ; \n    }\n    vector<int> xcor = {-1 , +1 , 0 , 0} , ycor = {0 , 0 , -1 , +1} ; \n    void runDFS(int i , int j , int n , int m , vector<vector<char>> & board , vector<vector<bool>> & visited , int parent , int num , DisjointSet  & ds1){    \n        visited[i][j] = true ; \n        int val = number(i , j , n , m ) ; \n        ds1.unionBySize(val , num) ; \n        for(int ind = 0 ; ind < 4 ; ++ind){\n            int xc = i + xcor[ind] , yc = j + ycor[ind] ; \n            if(xc >= 0 && xc < n && yc >= 0 && yc < m && board[xc][yc] == 'O' &&  visited[xc][yc] == false){\n                runDFS(xc , yc , n , m , board , visited , parent , val , ds1) ; \n            }\n        }\n    }\n    void solve(vector<vector<char >> & board){\n        int n = board.size() , m = board[0].size() ;  \n        DisjointSet ds1(n * m) ;\n        vector<vector<bool >> visited(n , vector<bool>(m , false)) ; \n        for(int i = 0 ; i < n ; ++i){\n            if(board[i][0] == 'O' && visited[i][0] == false){\n                int num = (i * m) + 0 ; \n                runDFS(i , 0 , n , m , board , visited , -1 , num , ds1 ) ; \n            }if(board[i][m - 1] == 'O' && visited[i][m - 1] == false ){\n                int num = (i * (m - 1)) + m - 1 ; \n                runDFS(i , m - 1 , n , m , board , visited , -1 , num , ds1 ) ; \n            }\n        }\n        for(int i = 0 ; i < m ; ++i){\n            if(board[0][i] == 'O' && visited[0][i] == false){\n                runDFS(0 , i , n , m , board , visited , -1 , i , ds1 ) ; \n            }if(board[n - 1][i] == 'O' && visited[n - 1][i] == false){\n                int num = (n - 1) * m + (i) ; \n                runDFS(n - 1 , i , n , m , board , visited , -1 , num , ds1 ) ; \n            }\n        }\n        for(int i = 0 ; i < n ; ++i){\n            for(int j = 0 ; j < m ; ++j){\n                if(i == 0 || i == n - 1 || j == 0 || j == m - 1 || board[i][j] == 'X') continue ;\n                int value = (i * m) + j ; \n                if(board[i][j] == 'O'){\n                    int par = ds1.parent[value] ; \n                    if(par == value) board[i][j] = 'X' ;\n                }\n            }\n        }\n        return ; \n    }\n};"
                    },
                    {
                        "username": "tylau",
                        "content": "I'm a little confused by what is being checked as the output for Python. It says to modify the board in-place, which is what I am doing but for some reason the output does not match what board looks like at the end of my code for test case 28. Running the code in my own local environment I can see that the board variable is getting changed appropriately...it just doesn't show up as an output here for some reason.\n\nEdit: Never mind I figured it out. If you override board with a copy, it won't recognize the new board anymore so you have to edit the original in place."
                    },
                    {
                        "username": "iamap_",
                        "content": "what\\'s wrong in this code?\\nclass Solution {\\npublic:\\nvoid dfs(int row,int col,vector<vector<int>>&vis,vector<vector<char>>&board){\\n\\n    vis[row][col]=1;\\n\\n    int n=board.size();\\n    int m=board[0].size();\\n\\n    int delrow[]={-1,1,0,0};\\n    int delcol[]={0,0,-1,1};\\n\\n    for(int i=0;i<4;i++){\\n        int nrow=row+delrow[i];\\n        int  ncol=col+delcol[i];\\n        if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && board[nrow][ncol]==\\'O\\' && vis[nrow][ncol]==0){\\n            dfs(nrow,ncol,vis,board);\\n        }\\n    }\\n}\\n    void solve(vector<vector<char>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++){\\n            if(board[i][0]==\\'O\\' && vis[i][0]==0){\\n                dfs(i,0,vis,board);\\n            }\\n            if(board[i][m-1]==\\'O\\' && vis[i][m-1]==0){\\n                dfs(i,m-1,vis,board);\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            if(board[0][i]==\\'O\\' && vis[0][i]==0){\\n                dfs(0,i,vis,board);\\n            }\\n            if(board[n-1][i]==\\'O\\' && vis[n-1][i]==0){\\n                dfs(n-1,i,vis,board);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 && board[i][j]==\\'O\\'){\\n                    board[i][j]==\\'X\\';\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was a nice problem. Enjoyed this. Wondering why so many down votes?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Chandan_393",
                        "content": "How many of you guys thought that this is a kind flood fill like problem.......???\\n\\nI was clear about the problem that this is a simple DFS problem and I got stuck with so many corner cases then I realise that instead of applying DFS on  \\'X\\' why not go with the \\'O\\'.And then I got my solution accepted !!!\\n\\nSome times thinking in opposite direction will lead you in to the  right direction .\\n\\nPOV:THINK OPPOSITE:)"
                    },
                    {
                        "username": "Chandan_393",
                        "content": "how many of you guys thought that this is a kind of flood fill like problem.........???\\n\\nI was clear about problem that this is a simple DFS \\nproblem but I was cramped with so many corner cases then I realise applying dfs on the whole matrix why not to apply it on the \\'O\\' only and I got the solution accepted!!!\\n\\nSometimes thinking in opposite direction will lead you in to the right result:)\\n\\n\\nPOV:Think opposite!! "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Can SomeOne Tell Me The Problem\\n\\ngetting error in test case \\n\\n`[[\"O\",\"O\",\"O\",\"O\",\"X\",\"X\"],[\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"O\",\"X\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"O\",\"O\",\"O\"]]`\\n\\n `/**\\n * @param {character[][]} board\\n * @return {void} Do not return anything, modify board in-place instead.\\n */\\nvar solve = function(board) {\\n    const rows = board.length,\\n        cols = board[0].length\\n    let visited = {}\\n    \\n    const dfs = (i, j) => {\\n        // if outbound return false\\n        if(i < 0 || j < 0 || i >= rows || j >= cols){\\n            return false\\n        }\\n\\n        // not outbound && is \\'X\\'\\n        if(board[i][j] === \"X\"){\\n            return true\\n        }\\n\\n        // if Previously visited\\n        if(visited[`r_${i}_c_${j}`] === true){\\n            return true\\n        }\\n\\n        visited[`r_${i}_c_${j}`] = true\\n\\n        if(dfs(i - 1, j) && dfs(i + 1, j) && dfs(i, j - 1) && dfs(i, j + 1)){\\n            board[i][j] = \\'X\\'\\n            return true\\n        }\\n\\n        return false\\n    }\\n\\n    for(let i = 0; i < rows; i++){\\n        for(let j = 0; j < cols; j++){\\n            if(board[i][j] === \\'O\\' && visited[`r_${i}_c_${j}`] !== true){\\n                dfs(i, j)\\n            }\\n        }\\n    }\\n\\n    return board\\n};`"
                    },
                    {
                        "username": "aditi30ag",
                        "content": "Whats this error?\\n\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x608000000080 at pc 0x000000346812 bp 0x7ffda58aeab0 sp 0x7ffda58aeaa8\\nREAD of size 8 at 0x608000000080 thread T0\\n    #2 0x7f1d4ade10b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x608000000080 is located 0 bytes to the right of 96-byte region [0x608000000020,0x608000000080)\\nallocated by thread T0 here:\\n    #6 0x7f1d4ade10b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff8000: fa fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8010:[fa]fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n `class Solution {\\npublic:\\n    void dfs(int r, int c, vector<vector<int>> &vis, vector<vector<char>>&grid){\\n        vis[r][c]=1;\\n        int n= grid.size();\\n        int m= grid[0].size();\\n\\n        int delrow[]= {-1,0,1,0};\\n        int delcol[]= {0,1,0,-1};\\n\\n        for(int i=0;i<4;i++){\\n            int nr= r+delrow[i];\\n            int nc= c+delcol[i];\\n\\n            if(nr>=0 and nr<n and nc>=0 and nc<m and vis[nr][nc]==0 and grid[nr][nc]==\\'O\\'){\\n                dfs(nr,nc,vis,grid);\\n            }\\n        }\\n        return;\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int n= board.size();\\n        int m= board[0].size();\\n        if(n==0) return;\\n\\n        vector<vector<int>> vis(n, vector<int> (m,0));\\n\\n        //traversing the first and last row\\n        for(int i=0;i<n;i++){\\n            if(board[0][i]==\\'O\\' and vis[0][i]==0){\\n                dfs(0,i,vis,board);\\n            }\\n            if(board[n-1][i]==\\'O\\' and vis[n-1][i]==0){\\n                dfs(n-1,i,vis,board);\\n            }\\n        }\\n        \\n        //traversing the first and last column\\n        for(int i=0;i<m;i++){\\n            if(board[i][0]==\\'O\\' and vis[i][0]==0){\\n                dfs(i,0,vis,board);\\n            }\\n            if(board[i][m-1]==\\'O\\' and vis[i][m-1]==0){\\n                dfs(i, m-1,vis,board);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==\\'O\\' and vis[i][j]==0){\\n                    board[i][j]=\\'X\\';\\n                }\\n            }\\n        }\\n        return;\\n    }\\n};`"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "who r all tricked to identify  small case and lower case  problem \\uD83D\\uDE12 like me as i assumed \\'X\\' as \\'x\\'.........."
                    },
                    {
                        "username": "mochiball",
                        "content": "I think more people were tripped up by the 0 being a big O and not the number zero "
                    }
                ]
            },
            {
                "id": 1766985,
                "content": [
                    {
                        "username": "girishbhargava9202",
                        "content": "This problem is really easy to solve, if we apply DFS or BFS, but my union find approach is giving me wrong answer. \nPlease tell me where the code is wrong. \nclass DisjointSet{\n    public:\n    vector<int> rank , parent , size ; \n        DisjointSet(int n){\n            rank.resize(n + 1 , 0) ; \n            parent.resize(n + 1 ) ; \n            size.resize(n + 1 , 1) ; \n            for(int i = 0 ; i <= n ; ++i)\n                parent[i] = i ; \n        }\n        int findUP(int node){\n            if(node == parent[node]) return node ; \n            return parent[node] = findUP(parent[node]) ;  \n        }\n        void unionBySize(int u , int v){\n            int ulp_u = findUP(u) , ulp_v = findUP(v) ; \n            if(ulp_v == ulp_u ) return ; \n            if(size[ulp_v] > size[ulp_u]){\n                parent[ulp_u] = ulp_v ; \n                size[ulp_v] += size[ulp_u] ;\n            }\n            else{\n                parent[ulp_v] = ulp_u ; \n                size[ulp_u] += size[ulp_v] ; \n            }\n        }\n        void unionByRank(int u , int v){\n            int ulp_u = findUP(u) , ulp_v = findUP(v) ;   \n            if(rank[ulp_u] > rank[ulp_v]){\n                parent[ulp_v] = ulp_u ;\n            }else if(rank[ulp_v] > rank[ulp_u]){\n                parent[ulp_u] = ulp_v ; \n            }else{\n                parent[ulp_u] = ulp_v ; \n                ++rank[ulp_v] ; \n            }\n        }\n};\nclass Solution{\n    public:\n    int number(int i , int j , int n , int m){\n        return (i * m) + j ; \n    }\n    vector<int> xcor = {-1 , +1 , 0 , 0} , ycor = {0 , 0 , -1 , +1} ; \n    void runDFS(int i , int j , int n , int m , vector<vector<char>> & board , vector<vector<bool>> & visited , int parent , int num , DisjointSet  & ds1){    \n        visited[i][j] = true ; \n        int val = number(i , j , n , m ) ; \n        ds1.unionBySize(val , num) ; \n        for(int ind = 0 ; ind < 4 ; ++ind){\n            int xc = i + xcor[ind] , yc = j + ycor[ind] ; \n            if(xc >= 0 && xc < n && yc >= 0 && yc < m && board[xc][yc] == 'O' &&  visited[xc][yc] == false){\n                runDFS(xc , yc , n , m , board , visited , parent , val , ds1) ; \n            }\n        }\n    }\n    void solve(vector<vector<char >> & board){\n        int n = board.size() , m = board[0].size() ;  \n        DisjointSet ds1(n * m) ;\n        vector<vector<bool >> visited(n , vector<bool>(m , false)) ; \n        for(int i = 0 ; i < n ; ++i){\n            if(board[i][0] == 'O' && visited[i][0] == false){\n                int num = (i * m) + 0 ; \n                runDFS(i , 0 , n , m , board , visited , -1 , num , ds1 ) ; \n            }if(board[i][m - 1] == 'O' && visited[i][m - 1] == false ){\n                int num = (i * (m - 1)) + m - 1 ; \n                runDFS(i , m - 1 , n , m , board , visited , -1 , num , ds1 ) ; \n            }\n        }\n        for(int i = 0 ; i < m ; ++i){\n            if(board[0][i] == 'O' && visited[0][i] == false){\n                runDFS(0 , i , n , m , board , visited , -1 , i , ds1 ) ; \n            }if(board[n - 1][i] == 'O' && visited[n - 1][i] == false){\n                int num = (n - 1) * m + (i) ; \n                runDFS(n - 1 , i , n , m , board , visited , -1 , num , ds1 ) ; \n            }\n        }\n        for(int i = 0 ; i < n ; ++i){\n            for(int j = 0 ; j < m ; ++j){\n                if(i == 0 || i == n - 1 || j == 0 || j == m - 1 || board[i][j] == 'X') continue ;\n                int value = (i * m) + j ; \n                if(board[i][j] == 'O'){\n                    int par = ds1.parent[value] ; \n                    if(par == value) board[i][j] = 'X' ;\n                }\n            }\n        }\n        return ; \n    }\n};"
                    },
                    {
                        "username": "tylau",
                        "content": "I'm a little confused by what is being checked as the output for Python. It says to modify the board in-place, which is what I am doing but for some reason the output does not match what board looks like at the end of my code for test case 28. Running the code in my own local environment I can see that the board variable is getting changed appropriately...it just doesn't show up as an output here for some reason.\n\nEdit: Never mind I figured it out. If you override board with a copy, it won't recognize the new board anymore so you have to edit the original in place."
                    },
                    {
                        "username": "iamap_",
                        "content": "what\\'s wrong in this code?\\nclass Solution {\\npublic:\\nvoid dfs(int row,int col,vector<vector<int>>&vis,vector<vector<char>>&board){\\n\\n    vis[row][col]=1;\\n\\n    int n=board.size();\\n    int m=board[0].size();\\n\\n    int delrow[]={-1,1,0,0};\\n    int delcol[]={0,0,-1,1};\\n\\n    for(int i=0;i<4;i++){\\n        int nrow=row+delrow[i];\\n        int  ncol=col+delcol[i];\\n        if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && board[nrow][ncol]==\\'O\\' && vis[nrow][ncol]==0){\\n            dfs(nrow,ncol,vis,board);\\n        }\\n    }\\n}\\n    void solve(vector<vector<char>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++){\\n            if(board[i][0]==\\'O\\' && vis[i][0]==0){\\n                dfs(i,0,vis,board);\\n            }\\n            if(board[i][m-1]==\\'O\\' && vis[i][m-1]==0){\\n                dfs(i,m-1,vis,board);\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            if(board[0][i]==\\'O\\' && vis[0][i]==0){\\n                dfs(0,i,vis,board);\\n            }\\n            if(board[n-1][i]==\\'O\\' && vis[n-1][i]==0){\\n                dfs(n-1,i,vis,board);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 && board[i][j]==\\'O\\'){\\n                    board[i][j]==\\'X\\';\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was a nice problem. Enjoyed this. Wondering why so many down votes?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Chandan_393",
                        "content": "How many of you guys thought that this is a kind flood fill like problem.......???\\n\\nI was clear about the problem that this is a simple DFS problem and I got stuck with so many corner cases then I realise that instead of applying DFS on  \\'X\\' why not go with the \\'O\\'.And then I got my solution accepted !!!\\n\\nSome times thinking in opposite direction will lead you in to the  right direction .\\n\\nPOV:THINK OPPOSITE:)"
                    },
                    {
                        "username": "Chandan_393",
                        "content": "how many of you guys thought that this is a kind of flood fill like problem.........???\\n\\nI was clear about problem that this is a simple DFS \\nproblem but I was cramped with so many corner cases then I realise applying dfs on the whole matrix why not to apply it on the \\'O\\' only and I got the solution accepted!!!\\n\\nSometimes thinking in opposite direction will lead you in to the right result:)\\n\\n\\nPOV:Think opposite!! "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Can SomeOne Tell Me The Problem\\n\\ngetting error in test case \\n\\n`[[\"O\",\"O\",\"O\",\"O\",\"X\",\"X\"],[\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"O\",\"X\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"O\",\"O\",\"O\"]]`\\n\\n `/**\\n * @param {character[][]} board\\n * @return {void} Do not return anything, modify board in-place instead.\\n */\\nvar solve = function(board) {\\n    const rows = board.length,\\n        cols = board[0].length\\n    let visited = {}\\n    \\n    const dfs = (i, j) => {\\n        // if outbound return false\\n        if(i < 0 || j < 0 || i >= rows || j >= cols){\\n            return false\\n        }\\n\\n        // not outbound && is \\'X\\'\\n        if(board[i][j] === \"X\"){\\n            return true\\n        }\\n\\n        // if Previously visited\\n        if(visited[`r_${i}_c_${j}`] === true){\\n            return true\\n        }\\n\\n        visited[`r_${i}_c_${j}`] = true\\n\\n        if(dfs(i - 1, j) && dfs(i + 1, j) && dfs(i, j - 1) && dfs(i, j + 1)){\\n            board[i][j] = \\'X\\'\\n            return true\\n        }\\n\\n        return false\\n    }\\n\\n    for(let i = 0; i < rows; i++){\\n        for(let j = 0; j < cols; j++){\\n            if(board[i][j] === \\'O\\' && visited[`r_${i}_c_${j}`] !== true){\\n                dfs(i, j)\\n            }\\n        }\\n    }\\n\\n    return board\\n};`"
                    },
                    {
                        "username": "aditi30ag",
                        "content": "Whats this error?\\n\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x608000000080 at pc 0x000000346812 bp 0x7ffda58aeab0 sp 0x7ffda58aeaa8\\nREAD of size 8 at 0x608000000080 thread T0\\n    #2 0x7f1d4ade10b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x608000000080 is located 0 bytes to the right of 96-byte region [0x608000000020,0x608000000080)\\nallocated by thread T0 here:\\n    #6 0x7f1d4ade10b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff8000: fa fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8010:[fa]fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n `class Solution {\\npublic:\\n    void dfs(int r, int c, vector<vector<int>> &vis, vector<vector<char>>&grid){\\n        vis[r][c]=1;\\n        int n= grid.size();\\n        int m= grid[0].size();\\n\\n        int delrow[]= {-1,0,1,0};\\n        int delcol[]= {0,1,0,-1};\\n\\n        for(int i=0;i<4;i++){\\n            int nr= r+delrow[i];\\n            int nc= c+delcol[i];\\n\\n            if(nr>=0 and nr<n and nc>=0 and nc<m and vis[nr][nc]==0 and grid[nr][nc]==\\'O\\'){\\n                dfs(nr,nc,vis,grid);\\n            }\\n        }\\n        return;\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int n= board.size();\\n        int m= board[0].size();\\n        if(n==0) return;\\n\\n        vector<vector<int>> vis(n, vector<int> (m,0));\\n\\n        //traversing the first and last row\\n        for(int i=0;i<n;i++){\\n            if(board[0][i]==\\'O\\' and vis[0][i]==0){\\n                dfs(0,i,vis,board);\\n            }\\n            if(board[n-1][i]==\\'O\\' and vis[n-1][i]==0){\\n                dfs(n-1,i,vis,board);\\n            }\\n        }\\n        \\n        //traversing the first and last column\\n        for(int i=0;i<m;i++){\\n            if(board[i][0]==\\'O\\' and vis[i][0]==0){\\n                dfs(i,0,vis,board);\\n            }\\n            if(board[i][m-1]==\\'O\\' and vis[i][m-1]==0){\\n                dfs(i, m-1,vis,board);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==\\'O\\' and vis[i][j]==0){\\n                    board[i][j]=\\'X\\';\\n                }\\n            }\\n        }\\n        return;\\n    }\\n};`"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "who r all tricked to identify  small case and lower case  problem \\uD83D\\uDE12 like me as i assumed \\'X\\' as \\'x\\'.........."
                    },
                    {
                        "username": "mochiball",
                        "content": "I think more people were tripped up by the 0 being a big O and not the number zero "
                    }
                ]
            },
            {
                "id": 1765434,
                "content": [
                    {
                        "username": "girishbhargava9202",
                        "content": "This problem is really easy to solve, if we apply DFS or BFS, but my union find approach is giving me wrong answer. \nPlease tell me where the code is wrong. \nclass DisjointSet{\n    public:\n    vector<int> rank , parent , size ; \n        DisjointSet(int n){\n            rank.resize(n + 1 , 0) ; \n            parent.resize(n + 1 ) ; \n            size.resize(n + 1 , 1) ; \n            for(int i = 0 ; i <= n ; ++i)\n                parent[i] = i ; \n        }\n        int findUP(int node){\n            if(node == parent[node]) return node ; \n            return parent[node] = findUP(parent[node]) ;  \n        }\n        void unionBySize(int u , int v){\n            int ulp_u = findUP(u) , ulp_v = findUP(v) ; \n            if(ulp_v == ulp_u ) return ; \n            if(size[ulp_v] > size[ulp_u]){\n                parent[ulp_u] = ulp_v ; \n                size[ulp_v] += size[ulp_u] ;\n            }\n            else{\n                parent[ulp_v] = ulp_u ; \n                size[ulp_u] += size[ulp_v] ; \n            }\n        }\n        void unionByRank(int u , int v){\n            int ulp_u = findUP(u) , ulp_v = findUP(v) ;   \n            if(rank[ulp_u] > rank[ulp_v]){\n                parent[ulp_v] = ulp_u ;\n            }else if(rank[ulp_v] > rank[ulp_u]){\n                parent[ulp_u] = ulp_v ; \n            }else{\n                parent[ulp_u] = ulp_v ; \n                ++rank[ulp_v] ; \n            }\n        }\n};\nclass Solution{\n    public:\n    int number(int i , int j , int n , int m){\n        return (i * m) + j ; \n    }\n    vector<int> xcor = {-1 , +1 , 0 , 0} , ycor = {0 , 0 , -1 , +1} ; \n    void runDFS(int i , int j , int n , int m , vector<vector<char>> & board , vector<vector<bool>> & visited , int parent , int num , DisjointSet  & ds1){    \n        visited[i][j] = true ; \n        int val = number(i , j , n , m ) ; \n        ds1.unionBySize(val , num) ; \n        for(int ind = 0 ; ind < 4 ; ++ind){\n            int xc = i + xcor[ind] , yc = j + ycor[ind] ; \n            if(xc >= 0 && xc < n && yc >= 0 && yc < m && board[xc][yc] == 'O' &&  visited[xc][yc] == false){\n                runDFS(xc , yc , n , m , board , visited , parent , val , ds1) ; \n            }\n        }\n    }\n    void solve(vector<vector<char >> & board){\n        int n = board.size() , m = board[0].size() ;  \n        DisjointSet ds1(n * m) ;\n        vector<vector<bool >> visited(n , vector<bool>(m , false)) ; \n        for(int i = 0 ; i < n ; ++i){\n            if(board[i][0] == 'O' && visited[i][0] == false){\n                int num = (i * m) + 0 ; \n                runDFS(i , 0 , n , m , board , visited , -1 , num , ds1 ) ; \n            }if(board[i][m - 1] == 'O' && visited[i][m - 1] == false ){\n                int num = (i * (m - 1)) + m - 1 ; \n                runDFS(i , m - 1 , n , m , board , visited , -1 , num , ds1 ) ; \n            }\n        }\n        for(int i = 0 ; i < m ; ++i){\n            if(board[0][i] == 'O' && visited[0][i] == false){\n                runDFS(0 , i , n , m , board , visited , -1 , i , ds1 ) ; \n            }if(board[n - 1][i] == 'O' && visited[n - 1][i] == false){\n                int num = (n - 1) * m + (i) ; \n                runDFS(n - 1 , i , n , m , board , visited , -1 , num , ds1 ) ; \n            }\n        }\n        for(int i = 0 ; i < n ; ++i){\n            for(int j = 0 ; j < m ; ++j){\n                if(i == 0 || i == n - 1 || j == 0 || j == m - 1 || board[i][j] == 'X') continue ;\n                int value = (i * m) + j ; \n                if(board[i][j] == 'O'){\n                    int par = ds1.parent[value] ; \n                    if(par == value) board[i][j] = 'X' ;\n                }\n            }\n        }\n        return ; \n    }\n};"
                    },
                    {
                        "username": "tylau",
                        "content": "I'm a little confused by what is being checked as the output for Python. It says to modify the board in-place, which is what I am doing but for some reason the output does not match what board looks like at the end of my code for test case 28. Running the code in my own local environment I can see that the board variable is getting changed appropriately...it just doesn't show up as an output here for some reason.\n\nEdit: Never mind I figured it out. If you override board with a copy, it won't recognize the new board anymore so you have to edit the original in place."
                    },
                    {
                        "username": "iamap_",
                        "content": "what\\'s wrong in this code?\\nclass Solution {\\npublic:\\nvoid dfs(int row,int col,vector<vector<int>>&vis,vector<vector<char>>&board){\\n\\n    vis[row][col]=1;\\n\\n    int n=board.size();\\n    int m=board[0].size();\\n\\n    int delrow[]={-1,1,0,0};\\n    int delcol[]={0,0,-1,1};\\n\\n    for(int i=0;i<4;i++){\\n        int nrow=row+delrow[i];\\n        int  ncol=col+delcol[i];\\n        if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && board[nrow][ncol]==\\'O\\' && vis[nrow][ncol]==0){\\n            dfs(nrow,ncol,vis,board);\\n        }\\n    }\\n}\\n    void solve(vector<vector<char>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++){\\n            if(board[i][0]==\\'O\\' && vis[i][0]==0){\\n                dfs(i,0,vis,board);\\n            }\\n            if(board[i][m-1]==\\'O\\' && vis[i][m-1]==0){\\n                dfs(i,m-1,vis,board);\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            if(board[0][i]==\\'O\\' && vis[0][i]==0){\\n                dfs(0,i,vis,board);\\n            }\\n            if(board[n-1][i]==\\'O\\' && vis[n-1][i]==0){\\n                dfs(n-1,i,vis,board);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 && board[i][j]==\\'O\\'){\\n                    board[i][j]==\\'X\\';\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was a nice problem. Enjoyed this. Wondering why so many down votes?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Chandan_393",
                        "content": "How many of you guys thought that this is a kind flood fill like problem.......???\\n\\nI was clear about the problem that this is a simple DFS problem and I got stuck with so many corner cases then I realise that instead of applying DFS on  \\'X\\' why not go with the \\'O\\'.And then I got my solution accepted !!!\\n\\nSome times thinking in opposite direction will lead you in to the  right direction .\\n\\nPOV:THINK OPPOSITE:)"
                    },
                    {
                        "username": "Chandan_393",
                        "content": "how many of you guys thought that this is a kind of flood fill like problem.........???\\n\\nI was clear about problem that this is a simple DFS \\nproblem but I was cramped with so many corner cases then I realise applying dfs on the whole matrix why not to apply it on the \\'O\\' only and I got the solution accepted!!!\\n\\nSometimes thinking in opposite direction will lead you in to the right result:)\\n\\n\\nPOV:Think opposite!! "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Can SomeOne Tell Me The Problem\\n\\ngetting error in test case \\n\\n`[[\"O\",\"O\",\"O\",\"O\",\"X\",\"X\"],[\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"O\",\"X\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"O\",\"O\",\"O\"]]`\\n\\n `/**\\n * @param {character[][]} board\\n * @return {void} Do not return anything, modify board in-place instead.\\n */\\nvar solve = function(board) {\\n    const rows = board.length,\\n        cols = board[0].length\\n    let visited = {}\\n    \\n    const dfs = (i, j) => {\\n        // if outbound return false\\n        if(i < 0 || j < 0 || i >= rows || j >= cols){\\n            return false\\n        }\\n\\n        // not outbound && is \\'X\\'\\n        if(board[i][j] === \"X\"){\\n            return true\\n        }\\n\\n        // if Previously visited\\n        if(visited[`r_${i}_c_${j}`] === true){\\n            return true\\n        }\\n\\n        visited[`r_${i}_c_${j}`] = true\\n\\n        if(dfs(i - 1, j) && dfs(i + 1, j) && dfs(i, j - 1) && dfs(i, j + 1)){\\n            board[i][j] = \\'X\\'\\n            return true\\n        }\\n\\n        return false\\n    }\\n\\n    for(let i = 0; i < rows; i++){\\n        for(let j = 0; j < cols; j++){\\n            if(board[i][j] === \\'O\\' && visited[`r_${i}_c_${j}`] !== true){\\n                dfs(i, j)\\n            }\\n        }\\n    }\\n\\n    return board\\n};`"
                    },
                    {
                        "username": "aditi30ag",
                        "content": "Whats this error?\\n\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x608000000080 at pc 0x000000346812 bp 0x7ffda58aeab0 sp 0x7ffda58aeaa8\\nREAD of size 8 at 0x608000000080 thread T0\\n    #2 0x7f1d4ade10b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x608000000080 is located 0 bytes to the right of 96-byte region [0x608000000020,0x608000000080)\\nallocated by thread T0 here:\\n    #6 0x7f1d4ade10b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff8000: fa fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8010:[fa]fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n `class Solution {\\npublic:\\n    void dfs(int r, int c, vector<vector<int>> &vis, vector<vector<char>>&grid){\\n        vis[r][c]=1;\\n        int n= grid.size();\\n        int m= grid[0].size();\\n\\n        int delrow[]= {-1,0,1,0};\\n        int delcol[]= {0,1,0,-1};\\n\\n        for(int i=0;i<4;i++){\\n            int nr= r+delrow[i];\\n            int nc= c+delcol[i];\\n\\n            if(nr>=0 and nr<n and nc>=0 and nc<m and vis[nr][nc]==0 and grid[nr][nc]==\\'O\\'){\\n                dfs(nr,nc,vis,grid);\\n            }\\n        }\\n        return;\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int n= board.size();\\n        int m= board[0].size();\\n        if(n==0) return;\\n\\n        vector<vector<int>> vis(n, vector<int> (m,0));\\n\\n        //traversing the first and last row\\n        for(int i=0;i<n;i++){\\n            if(board[0][i]==\\'O\\' and vis[0][i]==0){\\n                dfs(0,i,vis,board);\\n            }\\n            if(board[n-1][i]==\\'O\\' and vis[n-1][i]==0){\\n                dfs(n-1,i,vis,board);\\n            }\\n        }\\n        \\n        //traversing the first and last column\\n        for(int i=0;i<m;i++){\\n            if(board[i][0]==\\'O\\' and vis[i][0]==0){\\n                dfs(i,0,vis,board);\\n            }\\n            if(board[i][m-1]==\\'O\\' and vis[i][m-1]==0){\\n                dfs(i, m-1,vis,board);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==\\'O\\' and vis[i][j]==0){\\n                    board[i][j]=\\'X\\';\\n                }\\n            }\\n        }\\n        return;\\n    }\\n};`"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "who r all tricked to identify  small case and lower case  problem \\uD83D\\uDE12 like me as i assumed \\'X\\' as \\'x\\'.........."
                    },
                    {
                        "username": "mochiball",
                        "content": "I think more people were tripped up by the 0 being a big O and not the number zero "
                    }
                ]
            },
            {
                "id": 1757849,
                "content": [
                    {
                        "username": "girishbhargava9202",
                        "content": "This problem is really easy to solve, if we apply DFS or BFS, but my union find approach is giving me wrong answer. \nPlease tell me where the code is wrong. \nclass DisjointSet{\n    public:\n    vector<int> rank , parent , size ; \n        DisjointSet(int n){\n            rank.resize(n + 1 , 0) ; \n            parent.resize(n + 1 ) ; \n            size.resize(n + 1 , 1) ; \n            for(int i = 0 ; i <= n ; ++i)\n                parent[i] = i ; \n        }\n        int findUP(int node){\n            if(node == parent[node]) return node ; \n            return parent[node] = findUP(parent[node]) ;  \n        }\n        void unionBySize(int u , int v){\n            int ulp_u = findUP(u) , ulp_v = findUP(v) ; \n            if(ulp_v == ulp_u ) return ; \n            if(size[ulp_v] > size[ulp_u]){\n                parent[ulp_u] = ulp_v ; \n                size[ulp_v] += size[ulp_u] ;\n            }\n            else{\n                parent[ulp_v] = ulp_u ; \n                size[ulp_u] += size[ulp_v] ; \n            }\n        }\n        void unionByRank(int u , int v){\n            int ulp_u = findUP(u) , ulp_v = findUP(v) ;   \n            if(rank[ulp_u] > rank[ulp_v]){\n                parent[ulp_v] = ulp_u ;\n            }else if(rank[ulp_v] > rank[ulp_u]){\n                parent[ulp_u] = ulp_v ; \n            }else{\n                parent[ulp_u] = ulp_v ; \n                ++rank[ulp_v] ; \n            }\n        }\n};\nclass Solution{\n    public:\n    int number(int i , int j , int n , int m){\n        return (i * m) + j ; \n    }\n    vector<int> xcor = {-1 , +1 , 0 , 0} , ycor = {0 , 0 , -1 , +1} ; \n    void runDFS(int i , int j , int n , int m , vector<vector<char>> & board , vector<vector<bool>> & visited , int parent , int num , DisjointSet  & ds1){    \n        visited[i][j] = true ; \n        int val = number(i , j , n , m ) ; \n        ds1.unionBySize(val , num) ; \n        for(int ind = 0 ; ind < 4 ; ++ind){\n            int xc = i + xcor[ind] , yc = j + ycor[ind] ; \n            if(xc >= 0 && xc < n && yc >= 0 && yc < m && board[xc][yc] == 'O' &&  visited[xc][yc] == false){\n                runDFS(xc , yc , n , m , board , visited , parent , val , ds1) ; \n            }\n        }\n    }\n    void solve(vector<vector<char >> & board){\n        int n = board.size() , m = board[0].size() ;  \n        DisjointSet ds1(n * m) ;\n        vector<vector<bool >> visited(n , vector<bool>(m , false)) ; \n        for(int i = 0 ; i < n ; ++i){\n            if(board[i][0] == 'O' && visited[i][0] == false){\n                int num = (i * m) + 0 ; \n                runDFS(i , 0 , n , m , board , visited , -1 , num , ds1 ) ; \n            }if(board[i][m - 1] == 'O' && visited[i][m - 1] == false ){\n                int num = (i * (m - 1)) + m - 1 ; \n                runDFS(i , m - 1 , n , m , board , visited , -1 , num , ds1 ) ; \n            }\n        }\n        for(int i = 0 ; i < m ; ++i){\n            if(board[0][i] == 'O' && visited[0][i] == false){\n                runDFS(0 , i , n , m , board , visited , -1 , i , ds1 ) ; \n            }if(board[n - 1][i] == 'O' && visited[n - 1][i] == false){\n                int num = (n - 1) * m + (i) ; \n                runDFS(n - 1 , i , n , m , board , visited , -1 , num , ds1 ) ; \n            }\n        }\n        for(int i = 0 ; i < n ; ++i){\n            for(int j = 0 ; j < m ; ++j){\n                if(i == 0 || i == n - 1 || j == 0 || j == m - 1 || board[i][j] == 'X') continue ;\n                int value = (i * m) + j ; \n                if(board[i][j] == 'O'){\n                    int par = ds1.parent[value] ; \n                    if(par == value) board[i][j] = 'X' ;\n                }\n            }\n        }\n        return ; \n    }\n};"
                    },
                    {
                        "username": "tylau",
                        "content": "I'm a little confused by what is being checked as the output for Python. It says to modify the board in-place, which is what I am doing but for some reason the output does not match what board looks like at the end of my code for test case 28. Running the code in my own local environment I can see that the board variable is getting changed appropriately...it just doesn't show up as an output here for some reason.\n\nEdit: Never mind I figured it out. If you override board with a copy, it won't recognize the new board anymore so you have to edit the original in place."
                    },
                    {
                        "username": "iamap_",
                        "content": "what\\'s wrong in this code?\\nclass Solution {\\npublic:\\nvoid dfs(int row,int col,vector<vector<int>>&vis,vector<vector<char>>&board){\\n\\n    vis[row][col]=1;\\n\\n    int n=board.size();\\n    int m=board[0].size();\\n\\n    int delrow[]={-1,1,0,0};\\n    int delcol[]={0,0,-1,1};\\n\\n    for(int i=0;i<4;i++){\\n        int nrow=row+delrow[i];\\n        int  ncol=col+delcol[i];\\n        if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && board[nrow][ncol]==\\'O\\' && vis[nrow][ncol]==0){\\n            dfs(nrow,ncol,vis,board);\\n        }\\n    }\\n}\\n    void solve(vector<vector<char>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++){\\n            if(board[i][0]==\\'O\\' && vis[i][0]==0){\\n                dfs(i,0,vis,board);\\n            }\\n            if(board[i][m-1]==\\'O\\' && vis[i][m-1]==0){\\n                dfs(i,m-1,vis,board);\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            if(board[0][i]==\\'O\\' && vis[0][i]==0){\\n                dfs(0,i,vis,board);\\n            }\\n            if(board[n-1][i]==\\'O\\' && vis[n-1][i]==0){\\n                dfs(n-1,i,vis,board);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 && board[i][j]==\\'O\\'){\\n                    board[i][j]==\\'X\\';\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was a nice problem. Enjoyed this. Wondering why so many down votes?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Chandan_393",
                        "content": "How many of you guys thought that this is a kind flood fill like problem.......???\\n\\nI was clear about the problem that this is a simple DFS problem and I got stuck with so many corner cases then I realise that instead of applying DFS on  \\'X\\' why not go with the \\'O\\'.And then I got my solution accepted !!!\\n\\nSome times thinking in opposite direction will lead you in to the  right direction .\\n\\nPOV:THINK OPPOSITE:)"
                    },
                    {
                        "username": "Chandan_393",
                        "content": "how many of you guys thought that this is a kind of flood fill like problem.........???\\n\\nI was clear about problem that this is a simple DFS \\nproblem but I was cramped with so many corner cases then I realise applying dfs on the whole matrix why not to apply it on the \\'O\\' only and I got the solution accepted!!!\\n\\nSometimes thinking in opposite direction will lead you in to the right result:)\\n\\n\\nPOV:Think opposite!! "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Can SomeOne Tell Me The Problem\\n\\ngetting error in test case \\n\\n`[[\"O\",\"O\",\"O\",\"O\",\"X\",\"X\"],[\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"O\",\"X\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"O\",\"O\",\"O\"]]`\\n\\n `/**\\n * @param {character[][]} board\\n * @return {void} Do not return anything, modify board in-place instead.\\n */\\nvar solve = function(board) {\\n    const rows = board.length,\\n        cols = board[0].length\\n    let visited = {}\\n    \\n    const dfs = (i, j) => {\\n        // if outbound return false\\n        if(i < 0 || j < 0 || i >= rows || j >= cols){\\n            return false\\n        }\\n\\n        // not outbound && is \\'X\\'\\n        if(board[i][j] === \"X\"){\\n            return true\\n        }\\n\\n        // if Previously visited\\n        if(visited[`r_${i}_c_${j}`] === true){\\n            return true\\n        }\\n\\n        visited[`r_${i}_c_${j}`] = true\\n\\n        if(dfs(i - 1, j) && dfs(i + 1, j) && dfs(i, j - 1) && dfs(i, j + 1)){\\n            board[i][j] = \\'X\\'\\n            return true\\n        }\\n\\n        return false\\n    }\\n\\n    for(let i = 0; i < rows; i++){\\n        for(let j = 0; j < cols; j++){\\n            if(board[i][j] === \\'O\\' && visited[`r_${i}_c_${j}`] !== true){\\n                dfs(i, j)\\n            }\\n        }\\n    }\\n\\n    return board\\n};`"
                    },
                    {
                        "username": "aditi30ag",
                        "content": "Whats this error?\\n\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x608000000080 at pc 0x000000346812 bp 0x7ffda58aeab0 sp 0x7ffda58aeaa8\\nREAD of size 8 at 0x608000000080 thread T0\\n    #2 0x7f1d4ade10b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x608000000080 is located 0 bytes to the right of 96-byte region [0x608000000020,0x608000000080)\\nallocated by thread T0 here:\\n    #6 0x7f1d4ade10b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff8000: fa fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8010:[fa]fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n `class Solution {\\npublic:\\n    void dfs(int r, int c, vector<vector<int>> &vis, vector<vector<char>>&grid){\\n        vis[r][c]=1;\\n        int n= grid.size();\\n        int m= grid[0].size();\\n\\n        int delrow[]= {-1,0,1,0};\\n        int delcol[]= {0,1,0,-1};\\n\\n        for(int i=0;i<4;i++){\\n            int nr= r+delrow[i];\\n            int nc= c+delcol[i];\\n\\n            if(nr>=0 and nr<n and nc>=0 and nc<m and vis[nr][nc]==0 and grid[nr][nc]==\\'O\\'){\\n                dfs(nr,nc,vis,grid);\\n            }\\n        }\\n        return;\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int n= board.size();\\n        int m= board[0].size();\\n        if(n==0) return;\\n\\n        vector<vector<int>> vis(n, vector<int> (m,0));\\n\\n        //traversing the first and last row\\n        for(int i=0;i<n;i++){\\n            if(board[0][i]==\\'O\\' and vis[0][i]==0){\\n                dfs(0,i,vis,board);\\n            }\\n            if(board[n-1][i]==\\'O\\' and vis[n-1][i]==0){\\n                dfs(n-1,i,vis,board);\\n            }\\n        }\\n        \\n        //traversing the first and last column\\n        for(int i=0;i<m;i++){\\n            if(board[i][0]==\\'O\\' and vis[i][0]==0){\\n                dfs(i,0,vis,board);\\n            }\\n            if(board[i][m-1]==\\'O\\' and vis[i][m-1]==0){\\n                dfs(i, m-1,vis,board);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==\\'O\\' and vis[i][j]==0){\\n                    board[i][j]=\\'X\\';\\n                }\\n            }\\n        }\\n        return;\\n    }\\n};`"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "who r all tricked to identify  small case and lower case  problem \\uD83D\\uDE12 like me as i assumed \\'X\\' as \\'x\\'.........."
                    },
                    {
                        "username": "mochiball",
                        "content": "I think more people were tripped up by the 0 being a big O and not the number zero "
                    }
                ]
            },
            {
                "id": 1756350,
                "content": [
                    {
                        "username": "girishbhargava9202",
                        "content": "This problem is really easy to solve, if we apply DFS or BFS, but my union find approach is giving me wrong answer. \nPlease tell me where the code is wrong. \nclass DisjointSet{\n    public:\n    vector<int> rank , parent , size ; \n        DisjointSet(int n){\n            rank.resize(n + 1 , 0) ; \n            parent.resize(n + 1 ) ; \n            size.resize(n + 1 , 1) ; \n            for(int i = 0 ; i <= n ; ++i)\n                parent[i] = i ; \n        }\n        int findUP(int node){\n            if(node == parent[node]) return node ; \n            return parent[node] = findUP(parent[node]) ;  \n        }\n        void unionBySize(int u , int v){\n            int ulp_u = findUP(u) , ulp_v = findUP(v) ; \n            if(ulp_v == ulp_u ) return ; \n            if(size[ulp_v] > size[ulp_u]){\n                parent[ulp_u] = ulp_v ; \n                size[ulp_v] += size[ulp_u] ;\n            }\n            else{\n                parent[ulp_v] = ulp_u ; \n                size[ulp_u] += size[ulp_v] ; \n            }\n        }\n        void unionByRank(int u , int v){\n            int ulp_u = findUP(u) , ulp_v = findUP(v) ;   \n            if(rank[ulp_u] > rank[ulp_v]){\n                parent[ulp_v] = ulp_u ;\n            }else if(rank[ulp_v] > rank[ulp_u]){\n                parent[ulp_u] = ulp_v ; \n            }else{\n                parent[ulp_u] = ulp_v ; \n                ++rank[ulp_v] ; \n            }\n        }\n};\nclass Solution{\n    public:\n    int number(int i , int j , int n , int m){\n        return (i * m) + j ; \n    }\n    vector<int> xcor = {-1 , +1 , 0 , 0} , ycor = {0 , 0 , -1 , +1} ; \n    void runDFS(int i , int j , int n , int m , vector<vector<char>> & board , vector<vector<bool>> & visited , int parent , int num , DisjointSet  & ds1){    \n        visited[i][j] = true ; \n        int val = number(i , j , n , m ) ; \n        ds1.unionBySize(val , num) ; \n        for(int ind = 0 ; ind < 4 ; ++ind){\n            int xc = i + xcor[ind] , yc = j + ycor[ind] ; \n            if(xc >= 0 && xc < n && yc >= 0 && yc < m && board[xc][yc] == 'O' &&  visited[xc][yc] == false){\n                runDFS(xc , yc , n , m , board , visited , parent , val , ds1) ; \n            }\n        }\n    }\n    void solve(vector<vector<char >> & board){\n        int n = board.size() , m = board[0].size() ;  \n        DisjointSet ds1(n * m) ;\n        vector<vector<bool >> visited(n , vector<bool>(m , false)) ; \n        for(int i = 0 ; i < n ; ++i){\n            if(board[i][0] == 'O' && visited[i][0] == false){\n                int num = (i * m) + 0 ; \n                runDFS(i , 0 , n , m , board , visited , -1 , num , ds1 ) ; \n            }if(board[i][m - 1] == 'O' && visited[i][m - 1] == false ){\n                int num = (i * (m - 1)) + m - 1 ; \n                runDFS(i , m - 1 , n , m , board , visited , -1 , num , ds1 ) ; \n            }\n        }\n        for(int i = 0 ; i < m ; ++i){\n            if(board[0][i] == 'O' && visited[0][i] == false){\n                runDFS(0 , i , n , m , board , visited , -1 , i , ds1 ) ; \n            }if(board[n - 1][i] == 'O' && visited[n - 1][i] == false){\n                int num = (n - 1) * m + (i) ; \n                runDFS(n - 1 , i , n , m , board , visited , -1 , num , ds1 ) ; \n            }\n        }\n        for(int i = 0 ; i < n ; ++i){\n            for(int j = 0 ; j < m ; ++j){\n                if(i == 0 || i == n - 1 || j == 0 || j == m - 1 || board[i][j] == 'X') continue ;\n                int value = (i * m) + j ; \n                if(board[i][j] == 'O'){\n                    int par = ds1.parent[value] ; \n                    if(par == value) board[i][j] = 'X' ;\n                }\n            }\n        }\n        return ; \n    }\n};"
                    },
                    {
                        "username": "tylau",
                        "content": "I'm a little confused by what is being checked as the output for Python. It says to modify the board in-place, which is what I am doing but for some reason the output does not match what board looks like at the end of my code for test case 28. Running the code in my own local environment I can see that the board variable is getting changed appropriately...it just doesn't show up as an output here for some reason.\n\nEdit: Never mind I figured it out. If you override board with a copy, it won't recognize the new board anymore so you have to edit the original in place."
                    },
                    {
                        "username": "iamap_",
                        "content": "what\\'s wrong in this code?\\nclass Solution {\\npublic:\\nvoid dfs(int row,int col,vector<vector<int>>&vis,vector<vector<char>>&board){\\n\\n    vis[row][col]=1;\\n\\n    int n=board.size();\\n    int m=board[0].size();\\n\\n    int delrow[]={-1,1,0,0};\\n    int delcol[]={0,0,-1,1};\\n\\n    for(int i=0;i<4;i++){\\n        int nrow=row+delrow[i];\\n        int  ncol=col+delcol[i];\\n        if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && board[nrow][ncol]==\\'O\\' && vis[nrow][ncol]==0){\\n            dfs(nrow,ncol,vis,board);\\n        }\\n    }\\n}\\n    void solve(vector<vector<char>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++){\\n            if(board[i][0]==\\'O\\' && vis[i][0]==0){\\n                dfs(i,0,vis,board);\\n            }\\n            if(board[i][m-1]==\\'O\\' && vis[i][m-1]==0){\\n                dfs(i,m-1,vis,board);\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            if(board[0][i]==\\'O\\' && vis[0][i]==0){\\n                dfs(0,i,vis,board);\\n            }\\n            if(board[n-1][i]==\\'O\\' && vis[n-1][i]==0){\\n                dfs(n-1,i,vis,board);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 && board[i][j]==\\'O\\'){\\n                    board[i][j]==\\'X\\';\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was a nice problem. Enjoyed this. Wondering why so many down votes?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Chandan_393",
                        "content": "How many of you guys thought that this is a kind flood fill like problem.......???\\n\\nI was clear about the problem that this is a simple DFS problem and I got stuck with so many corner cases then I realise that instead of applying DFS on  \\'X\\' why not go with the \\'O\\'.And then I got my solution accepted !!!\\n\\nSome times thinking in opposite direction will lead you in to the  right direction .\\n\\nPOV:THINK OPPOSITE:)"
                    },
                    {
                        "username": "Chandan_393",
                        "content": "how many of you guys thought that this is a kind of flood fill like problem.........???\\n\\nI was clear about problem that this is a simple DFS \\nproblem but I was cramped with so many corner cases then I realise applying dfs on the whole matrix why not to apply it on the \\'O\\' only and I got the solution accepted!!!\\n\\nSometimes thinking in opposite direction will lead you in to the right result:)\\n\\n\\nPOV:Think opposite!! "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Can SomeOne Tell Me The Problem\\n\\ngetting error in test case \\n\\n`[[\"O\",\"O\",\"O\",\"O\",\"X\",\"X\"],[\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"O\",\"X\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"O\",\"O\",\"O\"]]`\\n\\n `/**\\n * @param {character[][]} board\\n * @return {void} Do not return anything, modify board in-place instead.\\n */\\nvar solve = function(board) {\\n    const rows = board.length,\\n        cols = board[0].length\\n    let visited = {}\\n    \\n    const dfs = (i, j) => {\\n        // if outbound return false\\n        if(i < 0 || j < 0 || i >= rows || j >= cols){\\n            return false\\n        }\\n\\n        // not outbound && is \\'X\\'\\n        if(board[i][j] === \"X\"){\\n            return true\\n        }\\n\\n        // if Previously visited\\n        if(visited[`r_${i}_c_${j}`] === true){\\n            return true\\n        }\\n\\n        visited[`r_${i}_c_${j}`] = true\\n\\n        if(dfs(i - 1, j) && dfs(i + 1, j) && dfs(i, j - 1) && dfs(i, j + 1)){\\n            board[i][j] = \\'X\\'\\n            return true\\n        }\\n\\n        return false\\n    }\\n\\n    for(let i = 0; i < rows; i++){\\n        for(let j = 0; j < cols; j++){\\n            if(board[i][j] === \\'O\\' && visited[`r_${i}_c_${j}`] !== true){\\n                dfs(i, j)\\n            }\\n        }\\n    }\\n\\n    return board\\n};`"
                    },
                    {
                        "username": "aditi30ag",
                        "content": "Whats this error?\\n\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x608000000080 at pc 0x000000346812 bp 0x7ffda58aeab0 sp 0x7ffda58aeaa8\\nREAD of size 8 at 0x608000000080 thread T0\\n    #2 0x7f1d4ade10b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x608000000080 is located 0 bytes to the right of 96-byte region [0x608000000020,0x608000000080)\\nallocated by thread T0 here:\\n    #6 0x7f1d4ade10b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff8000: fa fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8010:[fa]fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n `class Solution {\\npublic:\\n    void dfs(int r, int c, vector<vector<int>> &vis, vector<vector<char>>&grid){\\n        vis[r][c]=1;\\n        int n= grid.size();\\n        int m= grid[0].size();\\n\\n        int delrow[]= {-1,0,1,0};\\n        int delcol[]= {0,1,0,-1};\\n\\n        for(int i=0;i<4;i++){\\n            int nr= r+delrow[i];\\n            int nc= c+delcol[i];\\n\\n            if(nr>=0 and nr<n and nc>=0 and nc<m and vis[nr][nc]==0 and grid[nr][nc]==\\'O\\'){\\n                dfs(nr,nc,vis,grid);\\n            }\\n        }\\n        return;\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int n= board.size();\\n        int m= board[0].size();\\n        if(n==0) return;\\n\\n        vector<vector<int>> vis(n, vector<int> (m,0));\\n\\n        //traversing the first and last row\\n        for(int i=0;i<n;i++){\\n            if(board[0][i]==\\'O\\' and vis[0][i]==0){\\n                dfs(0,i,vis,board);\\n            }\\n            if(board[n-1][i]==\\'O\\' and vis[n-1][i]==0){\\n                dfs(n-1,i,vis,board);\\n            }\\n        }\\n        \\n        //traversing the first and last column\\n        for(int i=0;i<m;i++){\\n            if(board[i][0]==\\'O\\' and vis[i][0]==0){\\n                dfs(i,0,vis,board);\\n            }\\n            if(board[i][m-1]==\\'O\\' and vis[i][m-1]==0){\\n                dfs(i, m-1,vis,board);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==\\'O\\' and vis[i][j]==0){\\n                    board[i][j]=\\'X\\';\\n                }\\n            }\\n        }\\n        return;\\n    }\\n};`"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "who r all tricked to identify  small case and lower case  problem \\uD83D\\uDE12 like me as i assumed \\'X\\' as \\'x\\'.........."
                    },
                    {
                        "username": "mochiball",
                        "content": "I think more people were tripped up by the 0 being a big O and not the number zero "
                    }
                ]
            },
            {
                "id": 1753780,
                "content": [
                    {
                        "username": "girishbhargava9202",
                        "content": "This problem is really easy to solve, if we apply DFS or BFS, but my union find approach is giving me wrong answer. \nPlease tell me where the code is wrong. \nclass DisjointSet{\n    public:\n    vector<int> rank , parent , size ; \n        DisjointSet(int n){\n            rank.resize(n + 1 , 0) ; \n            parent.resize(n + 1 ) ; \n            size.resize(n + 1 , 1) ; \n            for(int i = 0 ; i <= n ; ++i)\n                parent[i] = i ; \n        }\n        int findUP(int node){\n            if(node == parent[node]) return node ; \n            return parent[node] = findUP(parent[node]) ;  \n        }\n        void unionBySize(int u , int v){\n            int ulp_u = findUP(u) , ulp_v = findUP(v) ; \n            if(ulp_v == ulp_u ) return ; \n            if(size[ulp_v] > size[ulp_u]){\n                parent[ulp_u] = ulp_v ; \n                size[ulp_v] += size[ulp_u] ;\n            }\n            else{\n                parent[ulp_v] = ulp_u ; \n                size[ulp_u] += size[ulp_v] ; \n            }\n        }\n        void unionByRank(int u , int v){\n            int ulp_u = findUP(u) , ulp_v = findUP(v) ;   \n            if(rank[ulp_u] > rank[ulp_v]){\n                parent[ulp_v] = ulp_u ;\n            }else if(rank[ulp_v] > rank[ulp_u]){\n                parent[ulp_u] = ulp_v ; \n            }else{\n                parent[ulp_u] = ulp_v ; \n                ++rank[ulp_v] ; \n            }\n        }\n};\nclass Solution{\n    public:\n    int number(int i , int j , int n , int m){\n        return (i * m) + j ; \n    }\n    vector<int> xcor = {-1 , +1 , 0 , 0} , ycor = {0 , 0 , -1 , +1} ; \n    void runDFS(int i , int j , int n , int m , vector<vector<char>> & board , vector<vector<bool>> & visited , int parent , int num , DisjointSet  & ds1){    \n        visited[i][j] = true ; \n        int val = number(i , j , n , m ) ; \n        ds1.unionBySize(val , num) ; \n        for(int ind = 0 ; ind < 4 ; ++ind){\n            int xc = i + xcor[ind] , yc = j + ycor[ind] ; \n            if(xc >= 0 && xc < n && yc >= 0 && yc < m && board[xc][yc] == 'O' &&  visited[xc][yc] == false){\n                runDFS(xc , yc , n , m , board , visited , parent , val , ds1) ; \n            }\n        }\n    }\n    void solve(vector<vector<char >> & board){\n        int n = board.size() , m = board[0].size() ;  \n        DisjointSet ds1(n * m) ;\n        vector<vector<bool >> visited(n , vector<bool>(m , false)) ; \n        for(int i = 0 ; i < n ; ++i){\n            if(board[i][0] == 'O' && visited[i][0] == false){\n                int num = (i * m) + 0 ; \n                runDFS(i , 0 , n , m , board , visited , -1 , num , ds1 ) ; \n            }if(board[i][m - 1] == 'O' && visited[i][m - 1] == false ){\n                int num = (i * (m - 1)) + m - 1 ; \n                runDFS(i , m - 1 , n , m , board , visited , -1 , num , ds1 ) ; \n            }\n        }\n        for(int i = 0 ; i < m ; ++i){\n            if(board[0][i] == 'O' && visited[0][i] == false){\n                runDFS(0 , i , n , m , board , visited , -1 , i , ds1 ) ; \n            }if(board[n - 1][i] == 'O' && visited[n - 1][i] == false){\n                int num = (n - 1) * m + (i) ; \n                runDFS(n - 1 , i , n , m , board , visited , -1 , num , ds1 ) ; \n            }\n        }\n        for(int i = 0 ; i < n ; ++i){\n            for(int j = 0 ; j < m ; ++j){\n                if(i == 0 || i == n - 1 || j == 0 || j == m - 1 || board[i][j] == 'X') continue ;\n                int value = (i * m) + j ; \n                if(board[i][j] == 'O'){\n                    int par = ds1.parent[value] ; \n                    if(par == value) board[i][j] = 'X' ;\n                }\n            }\n        }\n        return ; \n    }\n};"
                    },
                    {
                        "username": "tylau",
                        "content": "I'm a little confused by what is being checked as the output for Python. It says to modify the board in-place, which is what I am doing but for some reason the output does not match what board looks like at the end of my code for test case 28. Running the code in my own local environment I can see that the board variable is getting changed appropriately...it just doesn't show up as an output here for some reason.\n\nEdit: Never mind I figured it out. If you override board with a copy, it won't recognize the new board anymore so you have to edit the original in place."
                    },
                    {
                        "username": "iamap_",
                        "content": "what\\'s wrong in this code?\\nclass Solution {\\npublic:\\nvoid dfs(int row,int col,vector<vector<int>>&vis,vector<vector<char>>&board){\\n\\n    vis[row][col]=1;\\n\\n    int n=board.size();\\n    int m=board[0].size();\\n\\n    int delrow[]={-1,1,0,0};\\n    int delcol[]={0,0,-1,1};\\n\\n    for(int i=0;i<4;i++){\\n        int nrow=row+delrow[i];\\n        int  ncol=col+delcol[i];\\n        if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && board[nrow][ncol]==\\'O\\' && vis[nrow][ncol]==0){\\n            dfs(nrow,ncol,vis,board);\\n        }\\n    }\\n}\\n    void solve(vector<vector<char>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++){\\n            if(board[i][0]==\\'O\\' && vis[i][0]==0){\\n                dfs(i,0,vis,board);\\n            }\\n            if(board[i][m-1]==\\'O\\' && vis[i][m-1]==0){\\n                dfs(i,m-1,vis,board);\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            if(board[0][i]==\\'O\\' && vis[0][i]==0){\\n                dfs(0,i,vis,board);\\n            }\\n            if(board[n-1][i]==\\'O\\' && vis[n-1][i]==0){\\n                dfs(n-1,i,vis,board);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 && board[i][j]==\\'O\\'){\\n                    board[i][j]==\\'X\\';\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was a nice problem. Enjoyed this. Wondering why so many down votes?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Chandan_393",
                        "content": "How many of you guys thought that this is a kind flood fill like problem.......???\\n\\nI was clear about the problem that this is a simple DFS problem and I got stuck with so many corner cases then I realise that instead of applying DFS on  \\'X\\' why not go with the \\'O\\'.And then I got my solution accepted !!!\\n\\nSome times thinking in opposite direction will lead you in to the  right direction .\\n\\nPOV:THINK OPPOSITE:)"
                    },
                    {
                        "username": "Chandan_393",
                        "content": "how many of you guys thought that this is a kind of flood fill like problem.........???\\n\\nI was clear about problem that this is a simple DFS \\nproblem but I was cramped with so many corner cases then I realise applying dfs on the whole matrix why not to apply it on the \\'O\\' only and I got the solution accepted!!!\\n\\nSometimes thinking in opposite direction will lead you in to the right result:)\\n\\n\\nPOV:Think opposite!! "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Can SomeOne Tell Me The Problem\\n\\ngetting error in test case \\n\\n`[[\"O\",\"O\",\"O\",\"O\",\"X\",\"X\"],[\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"O\",\"X\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"O\",\"O\",\"O\"]]`\\n\\n `/**\\n * @param {character[][]} board\\n * @return {void} Do not return anything, modify board in-place instead.\\n */\\nvar solve = function(board) {\\n    const rows = board.length,\\n        cols = board[0].length\\n    let visited = {}\\n    \\n    const dfs = (i, j) => {\\n        // if outbound return false\\n        if(i < 0 || j < 0 || i >= rows || j >= cols){\\n            return false\\n        }\\n\\n        // not outbound && is \\'X\\'\\n        if(board[i][j] === \"X\"){\\n            return true\\n        }\\n\\n        // if Previously visited\\n        if(visited[`r_${i}_c_${j}`] === true){\\n            return true\\n        }\\n\\n        visited[`r_${i}_c_${j}`] = true\\n\\n        if(dfs(i - 1, j) && dfs(i + 1, j) && dfs(i, j - 1) && dfs(i, j + 1)){\\n            board[i][j] = \\'X\\'\\n            return true\\n        }\\n\\n        return false\\n    }\\n\\n    for(let i = 0; i < rows; i++){\\n        for(let j = 0; j < cols; j++){\\n            if(board[i][j] === \\'O\\' && visited[`r_${i}_c_${j}`] !== true){\\n                dfs(i, j)\\n            }\\n        }\\n    }\\n\\n    return board\\n};`"
                    },
                    {
                        "username": "aditi30ag",
                        "content": "Whats this error?\\n\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x608000000080 at pc 0x000000346812 bp 0x7ffda58aeab0 sp 0x7ffda58aeaa8\\nREAD of size 8 at 0x608000000080 thread T0\\n    #2 0x7f1d4ade10b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x608000000080 is located 0 bytes to the right of 96-byte region [0x608000000020,0x608000000080)\\nallocated by thread T0 here:\\n    #6 0x7f1d4ade10b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff8000: fa fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8010:[fa]fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n `class Solution {\\npublic:\\n    void dfs(int r, int c, vector<vector<int>> &vis, vector<vector<char>>&grid){\\n        vis[r][c]=1;\\n        int n= grid.size();\\n        int m= grid[0].size();\\n\\n        int delrow[]= {-1,0,1,0};\\n        int delcol[]= {0,1,0,-1};\\n\\n        for(int i=0;i<4;i++){\\n            int nr= r+delrow[i];\\n            int nc= c+delcol[i];\\n\\n            if(nr>=0 and nr<n and nc>=0 and nc<m and vis[nr][nc]==0 and grid[nr][nc]==\\'O\\'){\\n                dfs(nr,nc,vis,grid);\\n            }\\n        }\\n        return;\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int n= board.size();\\n        int m= board[0].size();\\n        if(n==0) return;\\n\\n        vector<vector<int>> vis(n, vector<int> (m,0));\\n\\n        //traversing the first and last row\\n        for(int i=0;i<n;i++){\\n            if(board[0][i]==\\'O\\' and vis[0][i]==0){\\n                dfs(0,i,vis,board);\\n            }\\n            if(board[n-1][i]==\\'O\\' and vis[n-1][i]==0){\\n                dfs(n-1,i,vis,board);\\n            }\\n        }\\n        \\n        //traversing the first and last column\\n        for(int i=0;i<m;i++){\\n            if(board[i][0]==\\'O\\' and vis[i][0]==0){\\n                dfs(i,0,vis,board);\\n            }\\n            if(board[i][m-1]==\\'O\\' and vis[i][m-1]==0){\\n                dfs(i, m-1,vis,board);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==\\'O\\' and vis[i][j]==0){\\n                    board[i][j]=\\'X\\';\\n                }\\n            }\\n        }\\n        return;\\n    }\\n};`"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "who r all tricked to identify  small case and lower case  problem \\uD83D\\uDE12 like me as i assumed \\'X\\' as \\'x\\'.........."
                    },
                    {
                        "username": "mochiball",
                        "content": "I think more people were tripped up by the 0 being a big O and not the number zero "
                    }
                ]
            },
            {
                "id": 1753774,
                "content": [
                    {
                        "username": "girishbhargava9202",
                        "content": "This problem is really easy to solve, if we apply DFS or BFS, but my union find approach is giving me wrong answer. \nPlease tell me where the code is wrong. \nclass DisjointSet{\n    public:\n    vector<int> rank , parent , size ; \n        DisjointSet(int n){\n            rank.resize(n + 1 , 0) ; \n            parent.resize(n + 1 ) ; \n            size.resize(n + 1 , 1) ; \n            for(int i = 0 ; i <= n ; ++i)\n                parent[i] = i ; \n        }\n        int findUP(int node){\n            if(node == parent[node]) return node ; \n            return parent[node] = findUP(parent[node]) ;  \n        }\n        void unionBySize(int u , int v){\n            int ulp_u = findUP(u) , ulp_v = findUP(v) ; \n            if(ulp_v == ulp_u ) return ; \n            if(size[ulp_v] > size[ulp_u]){\n                parent[ulp_u] = ulp_v ; \n                size[ulp_v] += size[ulp_u] ;\n            }\n            else{\n                parent[ulp_v] = ulp_u ; \n                size[ulp_u] += size[ulp_v] ; \n            }\n        }\n        void unionByRank(int u , int v){\n            int ulp_u = findUP(u) , ulp_v = findUP(v) ;   \n            if(rank[ulp_u] > rank[ulp_v]){\n                parent[ulp_v] = ulp_u ;\n            }else if(rank[ulp_v] > rank[ulp_u]){\n                parent[ulp_u] = ulp_v ; \n            }else{\n                parent[ulp_u] = ulp_v ; \n                ++rank[ulp_v] ; \n            }\n        }\n};\nclass Solution{\n    public:\n    int number(int i , int j , int n , int m){\n        return (i * m) + j ; \n    }\n    vector<int> xcor = {-1 , +1 , 0 , 0} , ycor = {0 , 0 , -1 , +1} ; \n    void runDFS(int i , int j , int n , int m , vector<vector<char>> & board , vector<vector<bool>> & visited , int parent , int num , DisjointSet  & ds1){    \n        visited[i][j] = true ; \n        int val = number(i , j , n , m ) ; \n        ds1.unionBySize(val , num) ; \n        for(int ind = 0 ; ind < 4 ; ++ind){\n            int xc = i + xcor[ind] , yc = j + ycor[ind] ; \n            if(xc >= 0 && xc < n && yc >= 0 && yc < m && board[xc][yc] == 'O' &&  visited[xc][yc] == false){\n                runDFS(xc , yc , n , m , board , visited , parent , val , ds1) ; \n            }\n        }\n    }\n    void solve(vector<vector<char >> & board){\n        int n = board.size() , m = board[0].size() ;  \n        DisjointSet ds1(n * m) ;\n        vector<vector<bool >> visited(n , vector<bool>(m , false)) ; \n        for(int i = 0 ; i < n ; ++i){\n            if(board[i][0] == 'O' && visited[i][0] == false){\n                int num = (i * m) + 0 ; \n                runDFS(i , 0 , n , m , board , visited , -1 , num , ds1 ) ; \n            }if(board[i][m - 1] == 'O' && visited[i][m - 1] == false ){\n                int num = (i * (m - 1)) + m - 1 ; \n                runDFS(i , m - 1 , n , m , board , visited , -1 , num , ds1 ) ; \n            }\n        }\n        for(int i = 0 ; i < m ; ++i){\n            if(board[0][i] == 'O' && visited[0][i] == false){\n                runDFS(0 , i , n , m , board , visited , -1 , i , ds1 ) ; \n            }if(board[n - 1][i] == 'O' && visited[n - 1][i] == false){\n                int num = (n - 1) * m + (i) ; \n                runDFS(n - 1 , i , n , m , board , visited , -1 , num , ds1 ) ; \n            }\n        }\n        for(int i = 0 ; i < n ; ++i){\n            for(int j = 0 ; j < m ; ++j){\n                if(i == 0 || i == n - 1 || j == 0 || j == m - 1 || board[i][j] == 'X') continue ;\n                int value = (i * m) + j ; \n                if(board[i][j] == 'O'){\n                    int par = ds1.parent[value] ; \n                    if(par == value) board[i][j] = 'X' ;\n                }\n            }\n        }\n        return ; \n    }\n};"
                    },
                    {
                        "username": "tylau",
                        "content": "I'm a little confused by what is being checked as the output for Python. It says to modify the board in-place, which is what I am doing but for some reason the output does not match what board looks like at the end of my code for test case 28. Running the code in my own local environment I can see that the board variable is getting changed appropriately...it just doesn't show up as an output here for some reason.\n\nEdit: Never mind I figured it out. If you override board with a copy, it won't recognize the new board anymore so you have to edit the original in place."
                    },
                    {
                        "username": "iamap_",
                        "content": "what\\'s wrong in this code?\\nclass Solution {\\npublic:\\nvoid dfs(int row,int col,vector<vector<int>>&vis,vector<vector<char>>&board){\\n\\n    vis[row][col]=1;\\n\\n    int n=board.size();\\n    int m=board[0].size();\\n\\n    int delrow[]={-1,1,0,0};\\n    int delcol[]={0,0,-1,1};\\n\\n    for(int i=0;i<4;i++){\\n        int nrow=row+delrow[i];\\n        int  ncol=col+delcol[i];\\n        if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && board[nrow][ncol]==\\'O\\' && vis[nrow][ncol]==0){\\n            dfs(nrow,ncol,vis,board);\\n        }\\n    }\\n}\\n    void solve(vector<vector<char>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++){\\n            if(board[i][0]==\\'O\\' && vis[i][0]==0){\\n                dfs(i,0,vis,board);\\n            }\\n            if(board[i][m-1]==\\'O\\' && vis[i][m-1]==0){\\n                dfs(i,m-1,vis,board);\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            if(board[0][i]==\\'O\\' && vis[0][i]==0){\\n                dfs(0,i,vis,board);\\n            }\\n            if(board[n-1][i]==\\'O\\' && vis[n-1][i]==0){\\n                dfs(n-1,i,vis,board);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 && board[i][j]==\\'O\\'){\\n                    board[i][j]==\\'X\\';\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was a nice problem. Enjoyed this. Wondering why so many down votes?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Chandan_393",
                        "content": "How many of you guys thought that this is a kind flood fill like problem.......???\\n\\nI was clear about the problem that this is a simple DFS problem and I got stuck with so many corner cases then I realise that instead of applying DFS on  \\'X\\' why not go with the \\'O\\'.And then I got my solution accepted !!!\\n\\nSome times thinking in opposite direction will lead you in to the  right direction .\\n\\nPOV:THINK OPPOSITE:)"
                    },
                    {
                        "username": "Chandan_393",
                        "content": "how many of you guys thought that this is a kind of flood fill like problem.........???\\n\\nI was clear about problem that this is a simple DFS \\nproblem but I was cramped with so many corner cases then I realise applying dfs on the whole matrix why not to apply it on the \\'O\\' only and I got the solution accepted!!!\\n\\nSometimes thinking in opposite direction will lead you in to the right result:)\\n\\n\\nPOV:Think opposite!! "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Can SomeOne Tell Me The Problem\\n\\ngetting error in test case \\n\\n`[[\"O\",\"O\",\"O\",\"O\",\"X\",\"X\"],[\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"O\",\"X\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"O\",\"O\",\"O\"]]`\\n\\n `/**\\n * @param {character[][]} board\\n * @return {void} Do not return anything, modify board in-place instead.\\n */\\nvar solve = function(board) {\\n    const rows = board.length,\\n        cols = board[0].length\\n    let visited = {}\\n    \\n    const dfs = (i, j) => {\\n        // if outbound return false\\n        if(i < 0 || j < 0 || i >= rows || j >= cols){\\n            return false\\n        }\\n\\n        // not outbound && is \\'X\\'\\n        if(board[i][j] === \"X\"){\\n            return true\\n        }\\n\\n        // if Previously visited\\n        if(visited[`r_${i}_c_${j}`] === true){\\n            return true\\n        }\\n\\n        visited[`r_${i}_c_${j}`] = true\\n\\n        if(dfs(i - 1, j) && dfs(i + 1, j) && dfs(i, j - 1) && dfs(i, j + 1)){\\n            board[i][j] = \\'X\\'\\n            return true\\n        }\\n\\n        return false\\n    }\\n\\n    for(let i = 0; i < rows; i++){\\n        for(let j = 0; j < cols; j++){\\n            if(board[i][j] === \\'O\\' && visited[`r_${i}_c_${j}`] !== true){\\n                dfs(i, j)\\n            }\\n        }\\n    }\\n\\n    return board\\n};`"
                    },
                    {
                        "username": "aditi30ag",
                        "content": "Whats this error?\\n\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x608000000080 at pc 0x000000346812 bp 0x7ffda58aeab0 sp 0x7ffda58aeaa8\\nREAD of size 8 at 0x608000000080 thread T0\\n    #2 0x7f1d4ade10b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x608000000080 is located 0 bytes to the right of 96-byte region [0x608000000020,0x608000000080)\\nallocated by thread T0 here:\\n    #6 0x7f1d4ade10b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff8000: fa fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8010:[fa]fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n `class Solution {\\npublic:\\n    void dfs(int r, int c, vector<vector<int>> &vis, vector<vector<char>>&grid){\\n        vis[r][c]=1;\\n        int n= grid.size();\\n        int m= grid[0].size();\\n\\n        int delrow[]= {-1,0,1,0};\\n        int delcol[]= {0,1,0,-1};\\n\\n        for(int i=0;i<4;i++){\\n            int nr= r+delrow[i];\\n            int nc= c+delcol[i];\\n\\n            if(nr>=0 and nr<n and nc>=0 and nc<m and vis[nr][nc]==0 and grid[nr][nc]==\\'O\\'){\\n                dfs(nr,nc,vis,grid);\\n            }\\n        }\\n        return;\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int n= board.size();\\n        int m= board[0].size();\\n        if(n==0) return;\\n\\n        vector<vector<int>> vis(n, vector<int> (m,0));\\n\\n        //traversing the first and last row\\n        for(int i=0;i<n;i++){\\n            if(board[0][i]==\\'O\\' and vis[0][i]==0){\\n                dfs(0,i,vis,board);\\n            }\\n            if(board[n-1][i]==\\'O\\' and vis[n-1][i]==0){\\n                dfs(n-1,i,vis,board);\\n            }\\n        }\\n        \\n        //traversing the first and last column\\n        for(int i=0;i<m;i++){\\n            if(board[i][0]==\\'O\\' and vis[i][0]==0){\\n                dfs(i,0,vis,board);\\n            }\\n            if(board[i][m-1]==\\'O\\' and vis[i][m-1]==0){\\n                dfs(i, m-1,vis,board);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==\\'O\\' and vis[i][j]==0){\\n                    board[i][j]=\\'X\\';\\n                }\\n            }\\n        }\\n        return;\\n    }\\n};`"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "who r all tricked to identify  small case and lower case  problem \\uD83D\\uDE12 like me as i assumed \\'X\\' as \\'x\\'.........."
                    },
                    {
                        "username": "mochiball",
                        "content": "I think more people were tripped up by the 0 being a big O and not the number zero "
                    }
                ]
            },
            {
                "id": 1737957,
                "content": [
                    {
                        "username": "girishbhargava9202",
                        "content": "This problem is really easy to solve, if we apply DFS or BFS, but my union find approach is giving me wrong answer. \nPlease tell me where the code is wrong. \nclass DisjointSet{\n    public:\n    vector<int> rank , parent , size ; \n        DisjointSet(int n){\n            rank.resize(n + 1 , 0) ; \n            parent.resize(n + 1 ) ; \n            size.resize(n + 1 , 1) ; \n            for(int i = 0 ; i <= n ; ++i)\n                parent[i] = i ; \n        }\n        int findUP(int node){\n            if(node == parent[node]) return node ; \n            return parent[node] = findUP(parent[node]) ;  \n        }\n        void unionBySize(int u , int v){\n            int ulp_u = findUP(u) , ulp_v = findUP(v) ; \n            if(ulp_v == ulp_u ) return ; \n            if(size[ulp_v] > size[ulp_u]){\n                parent[ulp_u] = ulp_v ; \n                size[ulp_v] += size[ulp_u] ;\n            }\n            else{\n                parent[ulp_v] = ulp_u ; \n                size[ulp_u] += size[ulp_v] ; \n            }\n        }\n        void unionByRank(int u , int v){\n            int ulp_u = findUP(u) , ulp_v = findUP(v) ;   \n            if(rank[ulp_u] > rank[ulp_v]){\n                parent[ulp_v] = ulp_u ;\n            }else if(rank[ulp_v] > rank[ulp_u]){\n                parent[ulp_u] = ulp_v ; \n            }else{\n                parent[ulp_u] = ulp_v ; \n                ++rank[ulp_v] ; \n            }\n        }\n};\nclass Solution{\n    public:\n    int number(int i , int j , int n , int m){\n        return (i * m) + j ; \n    }\n    vector<int> xcor = {-1 , +1 , 0 , 0} , ycor = {0 , 0 , -1 , +1} ; \n    void runDFS(int i , int j , int n , int m , vector<vector<char>> & board , vector<vector<bool>> & visited , int parent , int num , DisjointSet  & ds1){    \n        visited[i][j] = true ; \n        int val = number(i , j , n , m ) ; \n        ds1.unionBySize(val , num) ; \n        for(int ind = 0 ; ind < 4 ; ++ind){\n            int xc = i + xcor[ind] , yc = j + ycor[ind] ; \n            if(xc >= 0 && xc < n && yc >= 0 && yc < m && board[xc][yc] == 'O' &&  visited[xc][yc] == false){\n                runDFS(xc , yc , n , m , board , visited , parent , val , ds1) ; \n            }\n        }\n    }\n    void solve(vector<vector<char >> & board){\n        int n = board.size() , m = board[0].size() ;  \n        DisjointSet ds1(n * m) ;\n        vector<vector<bool >> visited(n , vector<bool>(m , false)) ; \n        for(int i = 0 ; i < n ; ++i){\n            if(board[i][0] == 'O' && visited[i][0] == false){\n                int num = (i * m) + 0 ; \n                runDFS(i , 0 , n , m , board , visited , -1 , num , ds1 ) ; \n            }if(board[i][m - 1] == 'O' && visited[i][m - 1] == false ){\n                int num = (i * (m - 1)) + m - 1 ; \n                runDFS(i , m - 1 , n , m , board , visited , -1 , num , ds1 ) ; \n            }\n        }\n        for(int i = 0 ; i < m ; ++i){\n            if(board[0][i] == 'O' && visited[0][i] == false){\n                runDFS(0 , i , n , m , board , visited , -1 , i , ds1 ) ; \n            }if(board[n - 1][i] == 'O' && visited[n - 1][i] == false){\n                int num = (n - 1) * m + (i) ; \n                runDFS(n - 1 , i , n , m , board , visited , -1 , num , ds1 ) ; \n            }\n        }\n        for(int i = 0 ; i < n ; ++i){\n            for(int j = 0 ; j < m ; ++j){\n                if(i == 0 || i == n - 1 || j == 0 || j == m - 1 || board[i][j] == 'X') continue ;\n                int value = (i * m) + j ; \n                if(board[i][j] == 'O'){\n                    int par = ds1.parent[value] ; \n                    if(par == value) board[i][j] = 'X' ;\n                }\n            }\n        }\n        return ; \n    }\n};"
                    },
                    {
                        "username": "tylau",
                        "content": "I'm a little confused by what is being checked as the output for Python. It says to modify the board in-place, which is what I am doing but for some reason the output does not match what board looks like at the end of my code for test case 28. Running the code in my own local environment I can see that the board variable is getting changed appropriately...it just doesn't show up as an output here for some reason.\n\nEdit: Never mind I figured it out. If you override board with a copy, it won't recognize the new board anymore so you have to edit the original in place."
                    },
                    {
                        "username": "iamap_",
                        "content": "what\\'s wrong in this code?\\nclass Solution {\\npublic:\\nvoid dfs(int row,int col,vector<vector<int>>&vis,vector<vector<char>>&board){\\n\\n    vis[row][col]=1;\\n\\n    int n=board.size();\\n    int m=board[0].size();\\n\\n    int delrow[]={-1,1,0,0};\\n    int delcol[]={0,0,-1,1};\\n\\n    for(int i=0;i<4;i++){\\n        int nrow=row+delrow[i];\\n        int  ncol=col+delcol[i];\\n        if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && board[nrow][ncol]==\\'O\\' && vis[nrow][ncol]==0){\\n            dfs(nrow,ncol,vis,board);\\n        }\\n    }\\n}\\n    void solve(vector<vector<char>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++){\\n            if(board[i][0]==\\'O\\' && vis[i][0]==0){\\n                dfs(i,0,vis,board);\\n            }\\n            if(board[i][m-1]==\\'O\\' && vis[i][m-1]==0){\\n                dfs(i,m-1,vis,board);\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            if(board[0][i]==\\'O\\' && vis[0][i]==0){\\n                dfs(0,i,vis,board);\\n            }\\n            if(board[n-1][i]==\\'O\\' && vis[n-1][i]==0){\\n                dfs(n-1,i,vis,board);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 && board[i][j]==\\'O\\'){\\n                    board[i][j]==\\'X\\';\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was a nice problem. Enjoyed this. Wondering why so many down votes?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Chandan_393",
                        "content": "How many of you guys thought that this is a kind flood fill like problem.......???\\n\\nI was clear about the problem that this is a simple DFS problem and I got stuck with so many corner cases then I realise that instead of applying DFS on  \\'X\\' why not go with the \\'O\\'.And then I got my solution accepted !!!\\n\\nSome times thinking in opposite direction will lead you in to the  right direction .\\n\\nPOV:THINK OPPOSITE:)"
                    },
                    {
                        "username": "Chandan_393",
                        "content": "how many of you guys thought that this is a kind of flood fill like problem.........???\\n\\nI was clear about problem that this is a simple DFS \\nproblem but I was cramped with so many corner cases then I realise applying dfs on the whole matrix why not to apply it on the \\'O\\' only and I got the solution accepted!!!\\n\\nSometimes thinking in opposite direction will lead you in to the right result:)\\n\\n\\nPOV:Think opposite!! "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Can SomeOne Tell Me The Problem\\n\\ngetting error in test case \\n\\n`[[\"O\",\"O\",\"O\",\"O\",\"X\",\"X\"],[\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"O\",\"X\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"O\",\"O\",\"O\"]]`\\n\\n `/**\\n * @param {character[][]} board\\n * @return {void} Do not return anything, modify board in-place instead.\\n */\\nvar solve = function(board) {\\n    const rows = board.length,\\n        cols = board[0].length\\n    let visited = {}\\n    \\n    const dfs = (i, j) => {\\n        // if outbound return false\\n        if(i < 0 || j < 0 || i >= rows || j >= cols){\\n            return false\\n        }\\n\\n        // not outbound && is \\'X\\'\\n        if(board[i][j] === \"X\"){\\n            return true\\n        }\\n\\n        // if Previously visited\\n        if(visited[`r_${i}_c_${j}`] === true){\\n            return true\\n        }\\n\\n        visited[`r_${i}_c_${j}`] = true\\n\\n        if(dfs(i - 1, j) && dfs(i + 1, j) && dfs(i, j - 1) && dfs(i, j + 1)){\\n            board[i][j] = \\'X\\'\\n            return true\\n        }\\n\\n        return false\\n    }\\n\\n    for(let i = 0; i < rows; i++){\\n        for(let j = 0; j < cols; j++){\\n            if(board[i][j] === \\'O\\' && visited[`r_${i}_c_${j}`] !== true){\\n                dfs(i, j)\\n            }\\n        }\\n    }\\n\\n    return board\\n};`"
                    },
                    {
                        "username": "aditi30ag",
                        "content": "Whats this error?\\n\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x608000000080 at pc 0x000000346812 bp 0x7ffda58aeab0 sp 0x7ffda58aeaa8\\nREAD of size 8 at 0x608000000080 thread T0\\n    #2 0x7f1d4ade10b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x608000000080 is located 0 bytes to the right of 96-byte region [0x608000000020,0x608000000080)\\nallocated by thread T0 here:\\n    #6 0x7f1d4ade10b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff8000: fa fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8010:[fa]fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n `class Solution {\\npublic:\\n    void dfs(int r, int c, vector<vector<int>> &vis, vector<vector<char>>&grid){\\n        vis[r][c]=1;\\n        int n= grid.size();\\n        int m= grid[0].size();\\n\\n        int delrow[]= {-1,0,1,0};\\n        int delcol[]= {0,1,0,-1};\\n\\n        for(int i=0;i<4;i++){\\n            int nr= r+delrow[i];\\n            int nc= c+delcol[i];\\n\\n            if(nr>=0 and nr<n and nc>=0 and nc<m and vis[nr][nc]==0 and grid[nr][nc]==\\'O\\'){\\n                dfs(nr,nc,vis,grid);\\n            }\\n        }\\n        return;\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int n= board.size();\\n        int m= board[0].size();\\n        if(n==0) return;\\n\\n        vector<vector<int>> vis(n, vector<int> (m,0));\\n\\n        //traversing the first and last row\\n        for(int i=0;i<n;i++){\\n            if(board[0][i]==\\'O\\' and vis[0][i]==0){\\n                dfs(0,i,vis,board);\\n            }\\n            if(board[n-1][i]==\\'O\\' and vis[n-1][i]==0){\\n                dfs(n-1,i,vis,board);\\n            }\\n        }\\n        \\n        //traversing the first and last column\\n        for(int i=0;i<m;i++){\\n            if(board[i][0]==\\'O\\' and vis[i][0]==0){\\n                dfs(i,0,vis,board);\\n            }\\n            if(board[i][m-1]==\\'O\\' and vis[i][m-1]==0){\\n                dfs(i, m-1,vis,board);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==\\'O\\' and vis[i][j]==0){\\n                    board[i][j]=\\'X\\';\\n                }\\n            }\\n        }\\n        return;\\n    }\\n};`"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "who r all tricked to identify  small case and lower case  problem \\uD83D\\uDE12 like me as i assumed \\'X\\' as \\'x\\'.........."
                    },
                    {
                        "username": "mochiball",
                        "content": "I think more people were tripped up by the 0 being a big O and not the number zero "
                    }
                ]
            },
            {
                "id": 1679215,
                "content": [
                    {
                        "username": "girishbhargava9202",
                        "content": "This problem is really easy to solve, if we apply DFS or BFS, but my union find approach is giving me wrong answer. \nPlease tell me where the code is wrong. \nclass DisjointSet{\n    public:\n    vector<int> rank , parent , size ; \n        DisjointSet(int n){\n            rank.resize(n + 1 , 0) ; \n            parent.resize(n + 1 ) ; \n            size.resize(n + 1 , 1) ; \n            for(int i = 0 ; i <= n ; ++i)\n                parent[i] = i ; \n        }\n        int findUP(int node){\n            if(node == parent[node]) return node ; \n            return parent[node] = findUP(parent[node]) ;  \n        }\n        void unionBySize(int u , int v){\n            int ulp_u = findUP(u) , ulp_v = findUP(v) ; \n            if(ulp_v == ulp_u ) return ; \n            if(size[ulp_v] > size[ulp_u]){\n                parent[ulp_u] = ulp_v ; \n                size[ulp_v] += size[ulp_u] ;\n            }\n            else{\n                parent[ulp_v] = ulp_u ; \n                size[ulp_u] += size[ulp_v] ; \n            }\n        }\n        void unionByRank(int u , int v){\n            int ulp_u = findUP(u) , ulp_v = findUP(v) ;   \n            if(rank[ulp_u] > rank[ulp_v]){\n                parent[ulp_v] = ulp_u ;\n            }else if(rank[ulp_v] > rank[ulp_u]){\n                parent[ulp_u] = ulp_v ; \n            }else{\n                parent[ulp_u] = ulp_v ; \n                ++rank[ulp_v] ; \n            }\n        }\n};\nclass Solution{\n    public:\n    int number(int i , int j , int n , int m){\n        return (i * m) + j ; \n    }\n    vector<int> xcor = {-1 , +1 , 0 , 0} , ycor = {0 , 0 , -1 , +1} ; \n    void runDFS(int i , int j , int n , int m , vector<vector<char>> & board , vector<vector<bool>> & visited , int parent , int num , DisjointSet  & ds1){    \n        visited[i][j] = true ; \n        int val = number(i , j , n , m ) ; \n        ds1.unionBySize(val , num) ; \n        for(int ind = 0 ; ind < 4 ; ++ind){\n            int xc = i + xcor[ind] , yc = j + ycor[ind] ; \n            if(xc >= 0 && xc < n && yc >= 0 && yc < m && board[xc][yc] == 'O' &&  visited[xc][yc] == false){\n                runDFS(xc , yc , n , m , board , visited , parent , val , ds1) ; \n            }\n        }\n    }\n    void solve(vector<vector<char >> & board){\n        int n = board.size() , m = board[0].size() ;  \n        DisjointSet ds1(n * m) ;\n        vector<vector<bool >> visited(n , vector<bool>(m , false)) ; \n        for(int i = 0 ; i < n ; ++i){\n            if(board[i][0] == 'O' && visited[i][0] == false){\n                int num = (i * m) + 0 ; \n                runDFS(i , 0 , n , m , board , visited , -1 , num , ds1 ) ; \n            }if(board[i][m - 1] == 'O' && visited[i][m - 1] == false ){\n                int num = (i * (m - 1)) + m - 1 ; \n                runDFS(i , m - 1 , n , m , board , visited , -1 , num , ds1 ) ; \n            }\n        }\n        for(int i = 0 ; i < m ; ++i){\n            if(board[0][i] == 'O' && visited[0][i] == false){\n                runDFS(0 , i , n , m , board , visited , -1 , i , ds1 ) ; \n            }if(board[n - 1][i] == 'O' && visited[n - 1][i] == false){\n                int num = (n - 1) * m + (i) ; \n                runDFS(n - 1 , i , n , m , board , visited , -1 , num , ds1 ) ; \n            }\n        }\n        for(int i = 0 ; i < n ; ++i){\n            for(int j = 0 ; j < m ; ++j){\n                if(i == 0 || i == n - 1 || j == 0 || j == m - 1 || board[i][j] == 'X') continue ;\n                int value = (i * m) + j ; \n                if(board[i][j] == 'O'){\n                    int par = ds1.parent[value] ; \n                    if(par == value) board[i][j] = 'X' ;\n                }\n            }\n        }\n        return ; \n    }\n};"
                    },
                    {
                        "username": "tylau",
                        "content": "I'm a little confused by what is being checked as the output for Python. It says to modify the board in-place, which is what I am doing but for some reason the output does not match what board looks like at the end of my code for test case 28. Running the code in my own local environment I can see that the board variable is getting changed appropriately...it just doesn't show up as an output here for some reason.\n\nEdit: Never mind I figured it out. If you override board with a copy, it won't recognize the new board anymore so you have to edit the original in place."
                    },
                    {
                        "username": "iamap_",
                        "content": "what\\'s wrong in this code?\\nclass Solution {\\npublic:\\nvoid dfs(int row,int col,vector<vector<int>>&vis,vector<vector<char>>&board){\\n\\n    vis[row][col]=1;\\n\\n    int n=board.size();\\n    int m=board[0].size();\\n\\n    int delrow[]={-1,1,0,0};\\n    int delcol[]={0,0,-1,1};\\n\\n    for(int i=0;i<4;i++){\\n        int nrow=row+delrow[i];\\n        int  ncol=col+delcol[i];\\n        if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && board[nrow][ncol]==\\'O\\' && vis[nrow][ncol]==0){\\n            dfs(nrow,ncol,vis,board);\\n        }\\n    }\\n}\\n    void solve(vector<vector<char>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++){\\n            if(board[i][0]==\\'O\\' && vis[i][0]==0){\\n                dfs(i,0,vis,board);\\n            }\\n            if(board[i][m-1]==\\'O\\' && vis[i][m-1]==0){\\n                dfs(i,m-1,vis,board);\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            if(board[0][i]==\\'O\\' && vis[0][i]==0){\\n                dfs(0,i,vis,board);\\n            }\\n            if(board[n-1][i]==\\'O\\' && vis[n-1][i]==0){\\n                dfs(n-1,i,vis,board);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 && board[i][j]==\\'O\\'){\\n                    board[i][j]==\\'X\\';\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was a nice problem. Enjoyed this. Wondering why so many down votes?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Chandan_393",
                        "content": "How many of you guys thought that this is a kind flood fill like problem.......???\\n\\nI was clear about the problem that this is a simple DFS problem and I got stuck with so many corner cases then I realise that instead of applying DFS on  \\'X\\' why not go with the \\'O\\'.And then I got my solution accepted !!!\\n\\nSome times thinking in opposite direction will lead you in to the  right direction .\\n\\nPOV:THINK OPPOSITE:)"
                    },
                    {
                        "username": "Chandan_393",
                        "content": "how many of you guys thought that this is a kind of flood fill like problem.........???\\n\\nI was clear about problem that this is a simple DFS \\nproblem but I was cramped with so many corner cases then I realise applying dfs on the whole matrix why not to apply it on the \\'O\\' only and I got the solution accepted!!!\\n\\nSometimes thinking in opposite direction will lead you in to the right result:)\\n\\n\\nPOV:Think opposite!! "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Can SomeOne Tell Me The Problem\\n\\ngetting error in test case \\n\\n`[[\"O\",\"O\",\"O\",\"O\",\"X\",\"X\"],[\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"O\",\"X\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"O\",\"O\",\"O\"]]`\\n\\n `/**\\n * @param {character[][]} board\\n * @return {void} Do not return anything, modify board in-place instead.\\n */\\nvar solve = function(board) {\\n    const rows = board.length,\\n        cols = board[0].length\\n    let visited = {}\\n    \\n    const dfs = (i, j) => {\\n        // if outbound return false\\n        if(i < 0 || j < 0 || i >= rows || j >= cols){\\n            return false\\n        }\\n\\n        // not outbound && is \\'X\\'\\n        if(board[i][j] === \"X\"){\\n            return true\\n        }\\n\\n        // if Previously visited\\n        if(visited[`r_${i}_c_${j}`] === true){\\n            return true\\n        }\\n\\n        visited[`r_${i}_c_${j}`] = true\\n\\n        if(dfs(i - 1, j) && dfs(i + 1, j) && dfs(i, j - 1) && dfs(i, j + 1)){\\n            board[i][j] = \\'X\\'\\n            return true\\n        }\\n\\n        return false\\n    }\\n\\n    for(let i = 0; i < rows; i++){\\n        for(let j = 0; j < cols; j++){\\n            if(board[i][j] === \\'O\\' && visited[`r_${i}_c_${j}`] !== true){\\n                dfs(i, j)\\n            }\\n        }\\n    }\\n\\n    return board\\n};`"
                    },
                    {
                        "username": "aditi30ag",
                        "content": "Whats this error?\\n\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x608000000080 at pc 0x000000346812 bp 0x7ffda58aeab0 sp 0x7ffda58aeaa8\\nREAD of size 8 at 0x608000000080 thread T0\\n    #2 0x7f1d4ade10b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x608000000080 is located 0 bytes to the right of 96-byte region [0x608000000020,0x608000000080)\\nallocated by thread T0 here:\\n    #6 0x7f1d4ade10b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff8000: fa fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8010:[fa]fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n `class Solution {\\npublic:\\n    void dfs(int r, int c, vector<vector<int>> &vis, vector<vector<char>>&grid){\\n        vis[r][c]=1;\\n        int n= grid.size();\\n        int m= grid[0].size();\\n\\n        int delrow[]= {-1,0,1,0};\\n        int delcol[]= {0,1,0,-1};\\n\\n        for(int i=0;i<4;i++){\\n            int nr= r+delrow[i];\\n            int nc= c+delcol[i];\\n\\n            if(nr>=0 and nr<n and nc>=0 and nc<m and vis[nr][nc]==0 and grid[nr][nc]==\\'O\\'){\\n                dfs(nr,nc,vis,grid);\\n            }\\n        }\\n        return;\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int n= board.size();\\n        int m= board[0].size();\\n        if(n==0) return;\\n\\n        vector<vector<int>> vis(n, vector<int> (m,0));\\n\\n        //traversing the first and last row\\n        for(int i=0;i<n;i++){\\n            if(board[0][i]==\\'O\\' and vis[0][i]==0){\\n                dfs(0,i,vis,board);\\n            }\\n            if(board[n-1][i]==\\'O\\' and vis[n-1][i]==0){\\n                dfs(n-1,i,vis,board);\\n            }\\n        }\\n        \\n        //traversing the first and last column\\n        for(int i=0;i<m;i++){\\n            if(board[i][0]==\\'O\\' and vis[i][0]==0){\\n                dfs(i,0,vis,board);\\n            }\\n            if(board[i][m-1]==\\'O\\' and vis[i][m-1]==0){\\n                dfs(i, m-1,vis,board);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==\\'O\\' and vis[i][j]==0){\\n                    board[i][j]=\\'X\\';\\n                }\\n            }\\n        }\\n        return;\\n    }\\n};`"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "who r all tricked to identify  small case and lower case  problem \\uD83D\\uDE12 like me as i assumed \\'X\\' as \\'x\\'.........."
                    },
                    {
                        "username": "mochiball",
                        "content": "I think more people were tripped up by the 0 being a big O and not the number zero "
                    }
                ]
            },
            {
                "id": 1919022,
                "content": [
                    {
                        "username": "girishbhargava9202",
                        "content": "This problem is really easy to solve, if we apply DFS or BFS, but my union find approach is giving me wrong answer. \nPlease tell me where the code is wrong. \nclass DisjointSet{\n    public:\n    vector<int> rank , parent , size ; \n        DisjointSet(int n){\n            rank.resize(n + 1 , 0) ; \n            parent.resize(n + 1 ) ; \n            size.resize(n + 1 , 1) ; \n            for(int i = 0 ; i <= n ; ++i)\n                parent[i] = i ; \n        }\n        int findUP(int node){\n            if(node == parent[node]) return node ; \n            return parent[node] = findUP(parent[node]) ;  \n        }\n        void unionBySize(int u , int v){\n            int ulp_u = findUP(u) , ulp_v = findUP(v) ; \n            if(ulp_v == ulp_u ) return ; \n            if(size[ulp_v] > size[ulp_u]){\n                parent[ulp_u] = ulp_v ; \n                size[ulp_v] += size[ulp_u] ;\n            }\n            else{\n                parent[ulp_v] = ulp_u ; \n                size[ulp_u] += size[ulp_v] ; \n            }\n        }\n        void unionByRank(int u , int v){\n            int ulp_u = findUP(u) , ulp_v = findUP(v) ;   \n            if(rank[ulp_u] > rank[ulp_v]){\n                parent[ulp_v] = ulp_u ;\n            }else if(rank[ulp_v] > rank[ulp_u]){\n                parent[ulp_u] = ulp_v ; \n            }else{\n                parent[ulp_u] = ulp_v ; \n                ++rank[ulp_v] ; \n            }\n        }\n};\nclass Solution{\n    public:\n    int number(int i , int j , int n , int m){\n        return (i * m) + j ; \n    }\n    vector<int> xcor = {-1 , +1 , 0 , 0} , ycor = {0 , 0 , -1 , +1} ; \n    void runDFS(int i , int j , int n , int m , vector<vector<char>> & board , vector<vector<bool>> & visited , int parent , int num , DisjointSet  & ds1){    \n        visited[i][j] = true ; \n        int val = number(i , j , n , m ) ; \n        ds1.unionBySize(val , num) ; \n        for(int ind = 0 ; ind < 4 ; ++ind){\n            int xc = i + xcor[ind] , yc = j + ycor[ind] ; \n            if(xc >= 0 && xc < n && yc >= 0 && yc < m && board[xc][yc] == 'O' &&  visited[xc][yc] == false){\n                runDFS(xc , yc , n , m , board , visited , parent , val , ds1) ; \n            }\n        }\n    }\n    void solve(vector<vector<char >> & board){\n        int n = board.size() , m = board[0].size() ;  \n        DisjointSet ds1(n * m) ;\n        vector<vector<bool >> visited(n , vector<bool>(m , false)) ; \n        for(int i = 0 ; i < n ; ++i){\n            if(board[i][0] == 'O' && visited[i][0] == false){\n                int num = (i * m) + 0 ; \n                runDFS(i , 0 , n , m , board , visited , -1 , num , ds1 ) ; \n            }if(board[i][m - 1] == 'O' && visited[i][m - 1] == false ){\n                int num = (i * (m - 1)) + m - 1 ; \n                runDFS(i , m - 1 , n , m , board , visited , -1 , num , ds1 ) ; \n            }\n        }\n        for(int i = 0 ; i < m ; ++i){\n            if(board[0][i] == 'O' && visited[0][i] == false){\n                runDFS(0 , i , n , m , board , visited , -1 , i , ds1 ) ; \n            }if(board[n - 1][i] == 'O' && visited[n - 1][i] == false){\n                int num = (n - 1) * m + (i) ; \n                runDFS(n - 1 , i , n , m , board , visited , -1 , num , ds1 ) ; \n            }\n        }\n        for(int i = 0 ; i < n ; ++i){\n            for(int j = 0 ; j < m ; ++j){\n                if(i == 0 || i == n - 1 || j == 0 || j == m - 1 || board[i][j] == 'X') continue ;\n                int value = (i * m) + j ; \n                if(board[i][j] == 'O'){\n                    int par = ds1.parent[value] ; \n                    if(par == value) board[i][j] = 'X' ;\n                }\n            }\n        }\n        return ; \n    }\n};"
                    },
                    {
                        "username": "tylau",
                        "content": "I'm a little confused by what is being checked as the output for Python. It says to modify the board in-place, which is what I am doing but for some reason the output does not match what board looks like at the end of my code for test case 28. Running the code in my own local environment I can see that the board variable is getting changed appropriately...it just doesn't show up as an output here for some reason.\n\nEdit: Never mind I figured it out. If you override board with a copy, it won't recognize the new board anymore so you have to edit the original in place."
                    },
                    {
                        "username": "iamap_",
                        "content": "what\\'s wrong in this code?\\nclass Solution {\\npublic:\\nvoid dfs(int row,int col,vector<vector<int>>&vis,vector<vector<char>>&board){\\n\\n    vis[row][col]=1;\\n\\n    int n=board.size();\\n    int m=board[0].size();\\n\\n    int delrow[]={-1,1,0,0};\\n    int delcol[]={0,0,-1,1};\\n\\n    for(int i=0;i<4;i++){\\n        int nrow=row+delrow[i];\\n        int  ncol=col+delcol[i];\\n        if(nrow>=0 && nrow<n && ncol>=0 && ncol<m && board[nrow][ncol]==\\'O\\' && vis[nrow][ncol]==0){\\n            dfs(nrow,ncol,vis,board);\\n        }\\n    }\\n}\\n    void solve(vector<vector<char>>& board) {\\n        int n=board.size();\\n        int m=board[0].size();\\n\\n        vector<vector<int>>vis(n,vector<int>(m,0));\\n\\n        for(int i=0;i<n;i++){\\n            if(board[i][0]==\\'O\\' && vis[i][0]==0){\\n                dfs(i,0,vis,board);\\n            }\\n            if(board[i][m-1]==\\'O\\' && vis[i][m-1]==0){\\n                dfs(i,m-1,vis,board);\\n            }\\n        }\\n        for(int i=0;i<m;i++){\\n            if(board[0][i]==\\'O\\' && vis[0][i]==0){\\n                dfs(0,i,vis,board);\\n            }\\n            if(board[n-1][i]==\\'O\\' && vis[n-1][i]==0){\\n                dfs(n-1,i,vis,board);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(vis[i][j]==0 && board[i][j]==\\'O\\'){\\n                    board[i][j]==\\'X\\';\\n                }\\n            }\\n        }\\n        \\n    }\\n};\\n"
                    },
                    {
                        "username": "leeten__1500",
                        "content": "It was a nice problem. Enjoyed this. Wondering why so many down votes?"
                    },
                    {
                        "username": "mohamed_waseela",
                        "content": "https://youtu.be/-Qpk2XJ5XJQ"
                    },
                    {
                        "username": "Chandan_393",
                        "content": "How many of you guys thought that this is a kind flood fill like problem.......???\\n\\nI was clear about the problem that this is a simple DFS problem and I got stuck with so many corner cases then I realise that instead of applying DFS on  \\'X\\' why not go with the \\'O\\'.And then I got my solution accepted !!!\\n\\nSome times thinking in opposite direction will lead you in to the  right direction .\\n\\nPOV:THINK OPPOSITE:)"
                    },
                    {
                        "username": "Chandan_393",
                        "content": "how many of you guys thought that this is a kind of flood fill like problem.........???\\n\\nI was clear about problem that this is a simple DFS \\nproblem but I was cramped with so many corner cases then I realise applying dfs on the whole matrix why not to apply it on the \\'O\\' only and I got the solution accepted!!!\\n\\nSometimes thinking in opposite direction will lead you in to the right result:)\\n\\n\\nPOV:Think opposite!! "
                    },
                    {
                        "username": "riyadzaigir280",
                        "content": "Can SomeOne Tell Me The Problem\\n\\ngetting error in test case \\n\\n`[[\"O\",\"O\",\"O\",\"O\",\"X\",\"X\"],[\"O\",\"O\",\"O\",\"O\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"O\",\"X\",\"O\"],[\"O\",\"X\",\"O\",\"X\",\"O\",\"O\"],[\"O\",\"X\",\"O\",\"O\",\"O\",\"O\"]]`\\n\\n `/**\\n * @param {character[][]} board\\n * @return {void} Do not return anything, modify board in-place instead.\\n */\\nvar solve = function(board) {\\n    const rows = board.length,\\n        cols = board[0].length\\n    let visited = {}\\n    \\n    const dfs = (i, j) => {\\n        // if outbound return false\\n        if(i < 0 || j < 0 || i >= rows || j >= cols){\\n            return false\\n        }\\n\\n        // not outbound && is \\'X\\'\\n        if(board[i][j] === \"X\"){\\n            return true\\n        }\\n\\n        // if Previously visited\\n        if(visited[`r_${i}_c_${j}`] === true){\\n            return true\\n        }\\n\\n        visited[`r_${i}_c_${j}`] = true\\n\\n        if(dfs(i - 1, j) && dfs(i + 1, j) && dfs(i, j - 1) && dfs(i, j + 1)){\\n            board[i][j] = \\'X\\'\\n            return true\\n        }\\n\\n        return false\\n    }\\n\\n    for(let i = 0; i < rows; i++){\\n        for(let j = 0; j < cols; j++){\\n            if(board[i][j] === \\'O\\' && visited[`r_${i}_c_${j}`] !== true){\\n                dfs(i, j)\\n            }\\n        }\\n    }\\n\\n    return board\\n};`"
                    },
                    {
                        "username": "aditi30ag",
                        "content": "Whats this error?\\n\\n=================================================================\\n==31==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x608000000080 at pc 0x000000346812 bp 0x7ffda58aeab0 sp 0x7ffda58aeaa8\\nREAD of size 8 at 0x608000000080 thread T0\\n    #2 0x7f1d4ade10b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\n0x608000000080 is located 0 bytes to the right of 96-byte region [0x608000000020,0x608000000080)\\nallocated by thread T0 here:\\n    #6 0x7f1d4ade10b2  (/lib/x86_64-linux-gnu/libc.so.6+0x270b2)\\nShadow bytes around the buggy address:\\n  0x0c107fff7fc0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fd0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7fe0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff7ff0: 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff8000: fa fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00\\n=>0x0c107fff8010:[fa]fa fa fa 00 00 00 00 00 00 00 00 00 00 00 00\\n  0x0c107fff8020: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8030: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8040: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8050: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\n  0x0c107fff8060: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\\nShadow byte legend (one shadow byte represents 8 application bytes):\\n  Addressable:           00\\n  Partially addressable: 01 02 03 04 05 06 07 \\n  Heap left redzone:       fa\\n  Freed heap region:       fd\\n  Stack left redzone:      f1\\n  Stack mid redzone:       f2\\n  Stack right redzone:     f3\\n  Stack after return:      f5\\n  Stack use after scope:   f8\\n  Global redzone:          f9\\n  Global init order:       f6\\n  Poisoned by user:        f7\\n  Container overflow:      fc\\n  Array cookie:            ac\\n  Intra object redzone:    bb\\n  ASan internal:           fe\\n  Left alloca redzone:     ca\\n  Right alloca redzone:    cb\\n  Shadow gap:              cc\\n==31==ABORTING\\n\\n `class Solution {\\npublic:\\n    void dfs(int r, int c, vector<vector<int>> &vis, vector<vector<char>>&grid){\\n        vis[r][c]=1;\\n        int n= grid.size();\\n        int m= grid[0].size();\\n\\n        int delrow[]= {-1,0,1,0};\\n        int delcol[]= {0,1,0,-1};\\n\\n        for(int i=0;i<4;i++){\\n            int nr= r+delrow[i];\\n            int nc= c+delcol[i];\\n\\n            if(nr>=0 and nr<n and nc>=0 and nc<m and vis[nr][nc]==0 and grid[nr][nc]==\\'O\\'){\\n                dfs(nr,nc,vis,grid);\\n            }\\n        }\\n        return;\\n    }\\n    void solve(vector<vector<char>>& board) {\\n        int n= board.size();\\n        int m= board[0].size();\\n        if(n==0) return;\\n\\n        vector<vector<int>> vis(n, vector<int> (m,0));\\n\\n        //traversing the first and last row\\n        for(int i=0;i<n;i++){\\n            if(board[0][i]==\\'O\\' and vis[0][i]==0){\\n                dfs(0,i,vis,board);\\n            }\\n            if(board[n-1][i]==\\'O\\' and vis[n-1][i]==0){\\n                dfs(n-1,i,vis,board);\\n            }\\n        }\\n        \\n        //traversing the first and last column\\n        for(int i=0;i<m;i++){\\n            if(board[i][0]==\\'O\\' and vis[i][0]==0){\\n                dfs(i,0,vis,board);\\n            }\\n            if(board[i][m-1]==\\'O\\' and vis[i][m-1]==0){\\n                dfs(i, m-1,vis,board);\\n            }\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            for(int j=0;j<m;j++){\\n                if(board[i][j]==\\'O\\' and vis[i][j]==0){\\n                    board[i][j]=\\'X\\';\\n                }\\n            }\\n        }\\n        return;\\n    }\\n};`"
                    },
                    {
                        "username": "pokerboy_leet",
                        "content": "who r all tricked to identify  small case and lower case  problem \\uD83D\\uDE12 like me as i assumed \\'X\\' as \\'x\\'.........."
                    },
                    {
                        "username": "mochiball",
                        "content": "I think more people were tripped up by the 0 being a big O and not the number zero "
                    }
                ]
            }
        ]
    },
    {
        "title": "Kth Smallest Element in a BST",
        "question_content": "<p>Given the <code>root</code> of a binary search tree, and an integer <code>k</code>, return <em>the</em> <code>k<sup>th</sup></code> <em>smallest value (<strong>1-indexed</strong>) of all the values of the nodes in the tree</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/28/kthtree1.jpg\" style=\"width: 212px; height: 301px;\" />\n<pre>\n<strong>Input:</strong> root = [3,1,4,null,2], k = 1\n<strong>Output:</strong> 1\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2021/01/28/kthtree2.jpg\" style=\"width: 382px; height: 302px;\" />\n<pre>\n<strong>Input:</strong> root = [5,3,6,2,4,null,null,1], k = 3\n<strong>Output:</strong> 3\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is <code>n</code>.</li>\n\t<li><code>1 &lt;= k &lt;= n &lt;= 10<sup>4</sup></code></li>\n\t<li><code>0 &lt;= Node.val &lt;= 10<sup>4</sup></code></li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong>Follow up:</strong> If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?</p>\n",
        "solutions": [
            {
                "id": 63660,
                "title": "3-ways-implemented-in-java-python-binary-search-in-order-iterative-recursive",
                "content": "Binary Search (dfs): (edited 1/2019) this is NOT preferrable as in performance but since the quesiton is categorized with Binary Search tag, I was trying to solve it in that way.\\n- time complexity: O(N) best, O(N^2) worst\\n\\n      public int kthSmallest(TreeNode root, int k) {\\n            int count = countNodes(root.left);\\n            if (k <= count) {\\n                return kthSmallest(root.left, k);\\n            } else if (k > count + 1) {\\n                return kthSmallest(root.right, k-1-count); // 1 is counted as current node\\n            }\\n            \\n            return root.val;\\n        }\\n        \\n        public int countNodes(TreeNode n) {\\n            if (n == null) return 0;\\n            \\n            return 1 + countNodes(n.left) + countNodes(n.right);\\n        }\\n\\n\\nDFS in-order recursive:\\n- time complexity: O(N)\\n\\n        // better keep these two variables in a wrapper class\\n        private static int number = 0;\\n        private static int count = 0;\\n\\n        public int kthSmallest(TreeNode root, int k) {\\n            count = k;\\n            helper(root);\\n            return number;\\n        }\\n        \\n        public void helper(TreeNode n) {\\n            if (n.left != null) helper(n.left);\\n            count--;\\n            if (count == 0) {\\n                number = n.val;\\n                return;\\n            }\\n            if (n.right != null) helper(n.right);\\n        }\\n\\nDFS in-order iterative:\\n- time complexity: O(N) best\\n\\n      public int kthSmallest(TreeNode root, int k) {\\n            Stack<TreeNode> st = new Stack<>();\\n            \\n            while (root != null) {\\n                st.push(root);\\n                root = root.left;\\n            }\\n                \\n            while (k != 0) {\\n                TreeNode n = st.pop();\\n                k--;\\n                if (k == 0) return n.val;\\n                TreeNode right = n.right;\\n                while (right != null) {\\n                    st.push(right);\\n                    right = right.left;\\n                }\\n            }\\n            \\n            return -1; // never hit if k is valid\\n      }\\n\\n(edited: 7/2017)\\n**note: requirement has been changed a bit since last time I visited that the counting could be looked up frequently and BST itself could be altered (inserted/deleted) by multiple times, so that\\'s the main reason that I stored them in an array.** \\n```\\nclass Solution(object):\\n    def kthSmallest(self, root, k):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        count = []\\n        self.helper(root, count)\\n        return count[k-1]\\n        \\n    def helper(self, node, count):\\n        if not node:\\n            return\\n        \\n        self.helper(node.left, count)\\n        count.append(node.val)\\n        self.helper(node.right, count)\\n```\\n\\nDFS recursive, stop early when meet kth\\n\\n```\\ndef findNode(node, res):\\n            if len(res) > 1:\\n                return\\n\\n            if node.left:\\n                findNode(node.left, res)\\n\\n            res[0] -= 1\\n            if res[0] == 0:\\n                res.append(node.val)\\n                return\\n            \\n            if node.right:\\n                findNode(node.right, res)\\n                \\n        res = [k]\\n        findNode(root, res)\\n        return res[1]\\n```\\n\\n\\nThanks again!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution(object):\\n    def kthSmallest(self, root, k):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        count = []\\n        self.helper(root, count)\\n        return count[k-1]\\n        \\n    def helper(self, node, count):\\n        if not node:\\n            return\\n        \\n        self.helper(node.left, count)\\n        count.append(node.val)\\n        self.helper(node.right, count)\\n```\n```\\ndef findNode(node, res):\\n            if len(res) > 1:\\n                return\\n\\n            if node.left:\\n                findNode(node.left, res)\\n\\n            res[0] -= 1\\n            if res[0] == 0:\\n                res.append(node.val)\\n                return\\n            \\n            if node.right:\\n                findNode(node.right, res)\\n                \\n        res = [k]\\n        findNode(root, res)\\n        return res[1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63659,
                "title": "what-if-you-could-modify-the-bst-node-s-structure",
                "content": "If we could add a count field in the BST node class, it will take O(n) time when we calculate the count value for the whole tree, but after that, it will take O(logn) time when insert/delete a node or calculate the kth smallest element.\\n\\n       public class Solution {\\n            public int kthSmallest(TreeNode root, int k) {\\n                TreeNodeWithCount rootWithCount = buildTreeWithCount(root);\\n                return kthSmallest(rootWithCount, k);\\n            }\\n            \\n            private TreeNodeWithCount buildTreeWithCount(TreeNode root) {\\n                if (root == null) return null;\\n                TreeNodeWithCount rootWithCount = new TreeNodeWithCount(root.val);\\n                rootWithCount.left = buildTreeWithCount(root.left);\\n                rootWithCount.right = buildTreeWithCount(root.right);\\n                if (rootWithCount.left != null) rootWithCount.count += rootWithCount.left.count;\\n                if (rootWithCount.right != null) rootWithCount.count += rootWithCount.right.count;\\n                return rootWithCount;\\n            }\\n            \\n            private int kthSmallest(TreeNodeWithCount rootWithCount, int k) {\\n                if (k <= 0 || k > rootWithCount.count) return -1;\\n                if (rootWithCount.left != null) {\\n                    if (rootWithCount.left.count >= k) return kthSmallest(rootWithCount.left, k);\\n                    if (rootWithCount.left.count == k-1) return rootWithCount.val;\\n                    return kthSmallest(rootWithCount.right, k-1-rootWithCount.left.count);\\n                } else {\\n                    if (k == 1) return rootWithCount.val;\\n                    return kthSmallest(rootWithCount.right, k-1);\\n                }\\n            }\\n            \\n            class TreeNodeWithCount {\\n                int val;\\n                int count;\\n                TreeNodeWithCount left;\\n                TreeNodeWithCount right;\\n                TreeNodeWithCount(int x) {val = x; count = 1;};\\n            }\\n        }",
                "solutionTags": [],
                "code": "class Solution {\\n            public int kthSmallest(TreeNode root, int k) {\\n                TreeNodeWithCount rootWithCount = buildTreeWithCount(root);\\n                return kthSmallest(rootWithCount, k);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 63829,
                "title": "python-easy-iterative-and-recursive-solution",
                "content": "Recursive:\\n\\n    def kthSmallest(self, root, k):\\n        self.k = k\\n        self.res = None\\n        self.helper(root)\\n        return self.res\\n    \\n    def helper(self, node):\\n        if not node:\\n            return\\n        self.helper(node.left)\\n        self.k -= 1\\n        if self.k == 0:\\n            self.res = node.val\\n            return\\n        self.helper(node.right)\\n\\n\\nIterative:\\n\\n    def kthSmallest(root, k):\\n        stack = []\\n        while root or stack:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            k -= 1\\n            if k == 0:\\n                return root.val\\n            root = root.right",
                "solutionTags": [
                    "Python"
                ],
                "code": "Recursive:\\n\\n    def kthSmallest(self, root, k):\\n        self.k = k\\n        self.res = None\\n        self.helper(root)\\n        return self.res\\n    \\n    def helper(self, node):\\n        if not node:\\n            return\\n        self.helper(node.left)\\n        self.k -= 1\\n        if self.k == 0:\\n            self.res = node.val\\n            return\\n        self.helper(node.right)\\n\\n\\nIterative:\\n\\n    def kthSmallest(root, k):\\n        stack = []\\n        while root or stack:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            k -= 1\\n            if k == 0:\\n                return root.val\\n            root = root.right",
                "codeTag": "Python3"
            },
            {
                "id": 63783,
                "title": "two-easiest-in-order-traverse-java",
                "content": "In order traverse for BST gives the natural order of numbers. No need to use array.\\n\\nRecursive:\\n\\n    int count = 0;\\n    int result = Integer.MIN_VALUE;\\n    \\n    public int kthSmallest(TreeNode root, int k) {\\n        traverse(root, k);\\n        return result;\\n    }\\n    \\n    public void traverse(TreeNode root, int k) {\\n        if(root == null) {\\n            return;\\n        }\\n        traverse(root.left, k);\\n        //---------- real code starts here ----------\\n        count++;\\n        if(count == k) {\\n            result = root.val;\\n            return;\\n        }       \\n        //-------------------------------------------\\n        traverse(root.right, k);       \\n    }\\n\\nIterative:\\n\\n     public int kthSmallest(TreeNode root, int k) {\\n         Stack<TreeNode> stack = new Stack<TreeNode>();\\n         TreeNode p = root;\\n         int count = 0;\\n         \\n         while (p != null || !stack.isEmpty()) {\\n             if(p != null) {\\n                 stack.push(p);  // similar to calling dfs(root.left)\\n                 p = p.left;   \\n             } else {\\n                p = stack.pop();\\n                //---------- real code starts here ----------\\n                count++;\\n                if(count == k) {\\n                    return node.val; \\n                }\\n                //-------------------------------------------\\n                p = node.right;  // similar to calling dfs(root.right)\\n             }\\n         }\\n         \\n         return Integer.MIN_VALUE;\\n     }",
                "solutionTags": [
                    "Java"
                ],
                "code": "In order traverse for BST gives the natural order of numbers. No need to use array.\\n\\nRecursive:\\n\\n    int count = 0;\\n    int result = Integer.MIN_VALUE;\\n    \\n    public int kthSmallest(TreeNode root, int k) {\\n        traverse(root, k);\\n        return result;\\n    }\\n    \\n    public void traverse(TreeNode root, int k) {\\n        if(root == null) {\\n            return;\\n        }\\n        traverse(root.left, k);\\n        //---------- real code starts here ----------\\n        count++;\\n        if(count == k) {\\n            result = root.val;\\n            return;\\n        }       \\n        //-------------------------------------------\\n        traverse(root.right, k);       \\n    }\\n\\nIterative:\\n\\n     public int kthSmallest(TreeNode root, int k) {\\n         Stack<TreeNode> stack = new Stack<TreeNode>();\\n         TreeNode p = root;\\n         int count = 0;\\n         \\n         while (p != null || !stack.isEmpty()) {\\n             if(p != null) {\\n                 stack.push(p);  // similar to calling dfs(root.left)\\n                 p = p.left;   \\n             } else {\\n                p = stack.pop();\\n                //---------- real code starts here ----------\\n                count++;\\n                if(count == k) {\\n                    return node.val; \\n                }\\n                //-------------------------------------------\\n                p = node.right;  // similar to calling dfs(root.right)\\n             }\\n         }\\n         \\n         return Integer.MIN_VALUE;\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 63673,
                "title": "4-lines-in-c",
                "content": "Go inorder and decrease `k` at each node. Stop the whole search as soon as `k` is zero, and then the k-th element is immediately returned all the way to the recursion top and to the original caller.\\n\\nTry the left subtree first. If that made `k` zero, then its answer is the overall answer and we return it right away. Otherwise, decrease `k` for the current node, and if that made `k` zero, then we return the current node's value right away. Otherwise try the right subtree and return whatever comes back from there.\\n\\n    int kthSmallest(TreeNode* root, int& k) {\\n        if (root) {\\n            int x = kthSmallest(root->left, k);\\n            return !k ? x : !--k ? root->val : kthSmallest(root->right, k);\\n        }\\n    }\\n\\n---\\n\\nYou might notice that I changed `k` from `int` to `int&` because I didn't feel like adding a helper just for that and the OJ doesn't mind. Oh well, here is that now:\\n\\n    int kthSmallest(TreeNode* root, int k) {\\n        return find(root, k);\\n    }\\n    int find(TreeNode* root, int& k) {\\n        if (root) {\\n            int x = find(root->left, k);\\n            return !k ? x : !--k ? root->val : find(root->right, k);\\n        }\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Go inorder and decrease `k` at each node. Stop the whole search as soon as `k` is zero, and then the k-th element is immediately returned all the way to the recursion top and to the original caller.\\n\\nTry the left subtree first. If that made `k` zero, then its answer is the overall answer and we return it right away. Otherwise, decrease `k` for the current node, and if that made `k` zero, then we return the current node's value right away. Otherwise try the right subtree and return whatever comes back from there.\\n\\n    int kthSmallest(TreeNode* root, int& k) {\\n        if (root) {\\n            int x = kthSmallest(root->left, k);\\n            return !k ? x : !--k ? root->val : kthSmallest(root->right, k);\\n        }\\n    }\\n\\n---\\n\\nYou might notice that I changed `k` from `int` to `int&` because I didn't feel like adding a helper just for that and the OJ doesn't mind. Oh well, here is that now:\\n\\n    int kthSmallest(TreeNode* root, int k) {\\n        return find(root, k);\\n    }\\n    int find(TreeNode* root, int& k) {\\n        if (root) {\\n            int x = find(root->left, k);\\n            return !k ? x : !--k ? root->val : find(root->right, k);\\n        }\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 63703,
                "title": "pythonic-approach-with-generator",
                "content": "With generator in python, one very straightforward solution might be:\\n\\n    class Solution:\\n        # @param {TreeNode} root\\n        # @param {integer} k\\n        # @return {integer}\\n        def kthSmallest(self, root, k):\\n            for val in self.inorder(root):\\n                if k == 1:\\n                    return val\\n                else:\\n                    k -= 1\\n            \\n        def inorder(self, root):\\n            if root is not None:\\n                for val in self.inorder(root.left):\\n                    yield val\\n                yield root.val\\n                for val in self.inorder(root.right):\\n                    yield val",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n        # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 1960046,
                "title": "multiple-c-solutions-with-explanations-time-complexity",
                "content": "---\\n\\n## Explanation:\\n\\n### Solution 01\\n\\n- Using ***Vector.***\\n- Here we\\u2019ll do inorder traversal, which is (left subtree \\u2192 root \\u2192 right subtree).\\n- We\\u2019ll store the values from the left side in our vector, which will be in increasing order.\\n- Finally, we\\u2019ll return (k-1) element from our vector, as it\\u2019s in increasing order so it will be kth smallest element.\\n- **Time complexity:** O(n), as we\\u2019re traversing the whole tree once.\\n\\n### Solution 02\\n\\n- Using ***Recursion.***\\n- if we do inorder traversal then in kth iteration we\\u2019ll get our ans.\\n- return the ans.\\n- **Time complexity:** O(n).\\n\\n---\\n\\n## Code:\\n\\n```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> a;\\n    int kthSmallest(TreeNode* root, int k) {\\n        inorder(root);\\n        int ans = a[k-1];\\n        return ans;\\n    }\\n    void inorder(TreeNode* root){\\n        if(!root) return;\\n        inorder(root->left);\\n        a.push_back(root->val);\\n        inorder(root->right);\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int ans;\\n    \\n    int kthSmallest(TreeNode* root, int k) {\\n        inorder(root, k);\\n        return ans;\\n    }\\n    \\n    void inorder(TreeNode* root, int& k) {\\n        if (!root) return;\\n        inorder(root->left, k);\\n        if (--k == 0){\\n            ans = root->val;\\n            return;\\n        } \\n        inorder(root->right, k);\\n    }  \\n};\\n```\\n\\n---\\n\\n> **Please upvote this solution**\\n>",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```cpp\\n//Solution 01:\\nclass Solution {\\npublic:\\n    vector<int> a;\\n    int kthSmallest(TreeNode* root, int k) {\\n        inorder(root);\\n        int ans = a[k-1];\\n        return ans;\\n    }\\n    void inorder(TreeNode* root){\\n        if(!root) return;\\n        inorder(root->left);\\n        a.push_back(root->val);\\n        inorder(root->right);\\n    }\\n};\\n\\n//Solution 02:\\nclass Solution {\\npublic:\\n    int ans;\\n    \\n    int kthSmallest(TreeNode* root, int k) {\\n        inorder(root, k);\\n        return ans;\\n    }\\n    \\n    void inorder(TreeNode* root, int& k) {\\n        if (!root) return;\\n        inorder(root->left, k);\\n        if (--k == 0){\\n            ans = root->val;\\n            return;\\n        } \\n        inorder(root->right, k);\\n    }  \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642294,
                "title": "java-python-using-stack-as-iterator-picture-explain-clean-code-o-h-k",
                "content": "**\\u2714\\uFE0F Solution 1: Inorder Traversal**\\n- We traverse inorder in BST (Left - Root - Right) then we have `sortedArr` as non-decreasing sorted array af elements in BST. \\n- The result is the `kth` element in our `sortedArr`.\\n```java\\nclass Solution {\\n    List<Integer> sortedArr = new ArrayList<>();\\n    public int kthSmallest(TreeNode root, int k) {\\n        inorderTraverse(root);\\n        return sortedArr.get(k-1);\\n    }\\n    void inorderTraverse(TreeNode root) {\\n        if (root == null) return;\\n        inorderTraverse(root.left);\\n        sortedArr.add(root.val);\\n        inorderTraverse(root.right);\\n    }\\n}\\n```\\n**Complexity**\\n- Time: `O(N)`\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Using Stack as Iterator**\\n- We use idea from [173. Binary Search Tree Iterator](https://leetcode.com/problems/binary-search-tree-iterator/discuss/965584) to iterate elements in order in O(H) in Space Comlpexity.\\n- The idea is that we iterate through the BST, we pop from smallest elements and we just need to pop `k` times to get the `k_th` smallest element.\\n![image](https://assets.leetcode.com/users/hiepit/image_1589996326.png)\\n\\n<iframe src=\"https://leetcode.com/playground/PoiZ2FKw/shared\" frameBorder=\"0\" width=\"100%\" height=\"400\"></iframe>\\n\\n**Complexity**\\n- Time: `O(H + k)`, where `H` is the height of the BST.\\n- Space: `O(H)`\\n\\n\\nPlease help to **UPVOTE** if this post is useful for you. \\nIf you have any questions, feel free to comment below.\\nHappy coding!\\n\\n",
                "solutionTags": [
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```java\\nclass Solution {\\n    List<Integer> sortedArr = new ArrayList<>();\\n    public int kthSmallest(TreeNode root, int k) {\\n        inorderTraverse(root);\\n        return sortedArr.get(k-1);\\n    }\\n    void inorderTraverse(TreeNode root) {\\n        if (root == null) return;\\n        inorderTraverse(root.left);\\n        sortedArr.add(root.val);\\n        inorderTraverse(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469071,
                "title": "i-bet-you-will-understand-brute-better-optimal-beginner-friendly-c",
                "content": "# (1) Naive Approach: \\n## Intuition:\\nWe can do traversal of the given tree using any traversal technique and store the node values in an array/vector. Then we can sort the array in ascending order such that the 1st smallest element comes at 0th index, 2nd smallest element at 1st index ... kth samllest element at k-1th index.\\n\\n## Algorithm:\\n1. Initialize an empty vector \\'v\\'.\\n2. Do any traversal (lets say preorder) and store the node values in v.\\n3. Sort vector v in ascending order.\\n4. Return v[k-1].\\n\\n## Complexity:\\n- Time complexity: $$O(n)$$ + $$O(nlogn)$$ -> $$O(nlogn)$$\\n  O(n) for traversing the Tree and O(nlogn) for sorting the vector of size n.\\n\\n- Space complexity:$$O(n)$$ + recursive stack space \\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    void preOrderTraversal(TreeNode* root, vector<int> &v){\\n        if(root == NULL)    return;\\n        \\n        //root, left, right \\n        v.push_back(root->val);\\n        preOrderTraversal(root->left, v);\\n        preOrderTraversal(root->right, v);      \\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        vector<int> v; \\n        preOrderTraversal(root, v);\\n        sort(v.begin(), v.end());\\n        return v[k-1];\\n    }\\n};\\n```\\n\\n# (2) Better Approach: \\n## Why Better? \\nIn the above approach we are using an extra O(nlogn) for sorting the vector. We need to remove it somehow so that our time complexity boils down to O(n).\\n\\nThe naive approach of O(nlogn) can also be converted to O(nlogk) using priority queue as we do in the following array question.\\nhttps://leetcode.com/problems/kth-largest-element-in-an-array/\\n\\nBut, here I will be discussing only the O(n) one. \\n\\n## Intuition:\\nWe know that the tree given to us is a Binary Search Tree, therefore, all the nodes at the left subtree of a given node will be less than the current node value and it will be less then all the nodes at the right subtree of that node.\\ni.e.\\n\\n               N\\n              / \\\\\\n             L   R\\n        \\n             L<N<R in case of BST\\n\\nSo, we can take advantage of this and do an INORDER TRAVERSAL. The inorder traversal will always result in a sorted array and the extra NlogN that we were using for sorting will be omitted. \\n\\n## Algorithm\\n1. Initialize an empty vector \\'v\\'.\\n2. Do an Inorder traversal and store the node values in v.\\n3. Return v[k-1].\\n\\n## Complexity\\n- Time complexity: $$O(n)$$\\n  O(n) for traversing the Tree consisting of n nodes.\\n- Space complexity:$$O(n)$$ + recursive stack space \\n\\n## Code\\n```\\nclass Solution {\\npublic:\\n    void inOrderTraversal(TreeNode* root, vector<int> &v){\\n        if(root == NULL)    return;\\n        \\n        //left, root, right \\n        inOrderTraversal(root->left, v);\\n        v.push_back(root->val);\\n        inOrderTraversal(root->right, v);      \\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        vector<int> v; \\n        inOrderTraversal(root, v);\\n        return v[k-1];\\n    }\\n};\\n```\\n\\n# (3) Optimal Approach: O(N) time and O(1) space:\\n\\nApproach 2 is fine, but there we are still creating an extra vector to store the node values. We can avoid it so that our space complexity further boils down to O(1).\\n\\n## Intuition:\\nWe need the kth smallest element. And, we know that our inorder traversal will first give the 1st smallest element, then 2nd smallest element ... and so on. \\nSo, instead of storing the node values inside a vector, we can maintain a \\'cnt\\' variable to keep track if we have reached kth smallest value or not in the inorder traversal. And then, we can return the value once cnt reaches k value.\\n\\n## Algorithm:\\n1. Initialize a variable, cnt = 0;\\n2. Do an Inorder traversal and instead of saving node->val in vector do a cnt++, denoting that we have encountered cnt th smallest element.\\n3. Return node->val once cnt == k.\\n\\n## Complexity:\\n- Time complexity: $$O(n)$$\\n  O(n) for traversing the Tree consisting of n nodes.\\n- Space complexity:$$O(1)$$ + recursive stack space \\n\\n## Code:\\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int &cnt, int &ans, int k){\\n        if(root == NULL)    return;\\n        //left, root, right \\n        solve(root->left, cnt, ans, k);\\n        cnt++;\\n        if(cnt == k){\\n            ans = root->val;\\n            return;\\n        }\\n        solve(root->right, cnt, ans, k);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        \\n        int cnt = 0;        \\n        int ans;\\n        solve(root, cnt, ans, k);\\n        return ans;\\n    }\\n};\\n```\\n\\n# Please upvote the solution if you understood it.\\n\\n![NRRa.gif](https://assets.leetcode.com/users/images/ac16397a-5dda-46bb-8508-a6caf66f016b_1679243081.1794233.gif)",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void preOrderTraversal(TreeNode* root, vector<int> &v){\\n        if(root == NULL)    return;\\n        \\n        //root, left, right \\n        v.push_back(root->val);\\n        preOrderTraversal(root->left, v);\\n        preOrderTraversal(root->right, v);      \\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        vector<int> v; \\n        preOrderTraversal(root, v);\\n        sort(v.begin(), v.end());\\n        return v[k-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void inOrderTraversal(TreeNode* root, vector<int> &v){\\n        if(root == NULL)    return;\\n        \\n        //left, root, right \\n        inOrderTraversal(root->left, v);\\n        v.push_back(root->val);\\n        inOrderTraversal(root->right, v);      \\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        vector<int> v; \\n        inOrderTraversal(root, v);\\n        return v[k-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    void solve(TreeNode* root, int &cnt, int &ans, int k){\\n        if(root == NULL)    return;\\n        //left, root, right \\n        solve(root->left, cnt, ans, k);\\n        cnt++;\\n        if(cnt == k){\\n            ans = root->val;\\n            return;\\n        }\\n        solve(root->right, cnt, ans, k);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        \\n        int cnt = 0;        \\n        int ans;\\n        solve(root, cnt, ans, k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63696,
                "title": "share-my-c-iterative-alg",
                "content": "    class Solution {\\n    public:\\n        int kthSmallest(TreeNode* root, int k) {\\n            stack<TreeNode *> st;\\n            TreeNode *p = root;\\n            while(p || !st.empty())\\n            {\\n                while(p)\\n                {\\n                    st.push(p);\\n                    p = p->left;\\n                }\\n                p = st.top();\\n                if(--k == 0)\\n                    return p->val;\\n                st.pop();\\n                p = p->right;\\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int kthSmallest(TreeNode* root, int k) {\\n            stack<TreeNode *> st;\\n            TreeNode *p = root;\\n            while(p || !st.empty())\\n            {\\n                while(p)\\n                {\\n                    st.push(p);\\n                    p = p->left;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 63734,
                "title": "o-k-space-o-n-time-10-short-lines-3-solutions",
                "content": "The solutions I've seen so far use O(n) space, either for the recursion stack or for the self-managed stack. Here's an iterative inorder traversal version that only uses O(k) space by using a \"stack\" cut off at k elements. I called it `stac` because of that and had to laugh when I then wrote `stac(k)` :-)\\n\\n---\\n\\n**Solution 1, Python with deque(maxlen=k)**\\n\\nUsing a deque, setting its maximum length to k.\\n\\n    def kthSmallest(self, root, k):\\n        stac = collections.deque(maxlen=k)\\n        while True:\\n            while root:\\n                stac.append(root)\\n                root = root.left\\n            root = stac.pop()\\n            if k == 1:\\n                return root.val\\n            k -= 1\\n            root = root.right\\n\\n---\\n\\n**Solution 2, C++ with circular vector**\\n\\nUsing a vector of fixed size k and a stack pointer `i` into it which will be used modulo k.\\n\\n    int kthSmallest(TreeNode* root, int k) {\\n        vector<TreeNode*> stac(k);\\n        int i = 0, j = k;\\n        while (true) {\\n            while (root) {\\n                stac[i++%k] = root;\\n                root = root->left;\\n            }\\n            root = stac[--i%k];\\n            if (! --j)\\n                return root->val;\\n            root = root->right;\\n        }\\n    }\\n\\n---\\n\\n**Solution 3, C++ with deque**\\n\\nI really like the previous version, but the fixed size `k` isn't always necessary, so here's a version using a deque:\\n\\n    int kthSmallest(TreeNode* root, int k) {\\n        deque<TreeNode*> stac;\\n        while (true) {\\n            while (root) {\\n                stac.push_front(root);\\n                while (stac.size() > k)\\n                    stac.pop_back();\\n                root = root->left;\\n            }\\n            root = stac.front();\\n            stac.pop_front();\\n            if (! --k)\\n                return root->val;\\n            root = root->right;\\n        }\\n    }\\n\\n---\\n\\nAnd now I'm waiting for the Morris traversalists to show up...",
                "solutionTags": [
                    "C++",
                    "Python"
                ],
                "code": "The solutions I've seen so far use O(n) space, either for the recursion stack or for the self-managed stack. Here's an iterative inorder traversal version that only uses O(k) space by using a \"stack\" cut off at k elements. I called it `stac` because of that and had to laugh when I then wrote `stac(k)` :-)\\n\\n---\\n\\n**Solution 1, Python with deque(maxlen=k)**\\n\\nUsing a deque, setting its maximum length to k.\\n\\n    def kthSmallest(self, root, k):\\n        stac = collections.deque(maxlen=k)\\n        while True:\\n            while root:\\n                stac.append(root)\\n                root = root.left\\n            root = stac.pop()\\n            if k == 1:\\n                return root.val\\n            k -= 1\\n            root = root.right\\n\\n---\\n\\n**Solution 2, C++ with circular vector**\\n\\nUsing a vector of fixed size k and a stack pointer `i` into it which will be used modulo k.\\n\\n    int kthSmallest(TreeNode* root, int k) {\\n        vector<TreeNode*> stac(k);\\n        int i = 0, j = k;\\n        while (true) {\\n            while (root) {\\n                stac[i++%k] = root;\\n                root = root->left;\\n            }\\n            root = stac[--i%k];\\n            if (! --j)\\n                return root->val;\\n            root = root->right;\\n        }\\n    }\\n\\n---\\n\\n**Solution 3, C++ with deque**\\n\\nI really like the previous version, but the fixed size `k` isn't always necessary, so here's a version using a deque:\\n\\n    int kthSmallest(TreeNode* root, int k) {\\n        deque<TreeNode*> stac;\\n        while (true) {\\n            while (root) {\\n                stac.push_front(root);\\n                while (stac.size() > k)\\n                    stac.pop_back();\\n                root = root->left;\\n            }\\n            root = stac.front();\\n            stac.pop_front();\\n            if (! --k)\\n                return root->val;\\n            root = root->right;\\n        }\\n    }\\n\\n---\\n\\nAnd now I'm waiting for the Morris traversalists to show up...",
                "codeTag": "Python3"
            },
            {
                "id": 1958789,
                "title": "c-recursive-iterative-tc-o-h-k",
                "content": "***Approach :***\\n***Inorder traversal of BST***  **print the element in increasing order so that kth smallest element in BST is the kth item in inorder traversal**\\n\\n**Recursive**\\n**Time complexcity O(H+K)** H is height of bst\\n**Space complexcity O(1)**\\nhence we are not using any extra space but for the recursion calls space is allocated and that would be in order of O(H+K) **(Recursion stack space)**\\n```\\nint kthSmallest(TreeNode* root, int &k) \\n    {\\n        if(root==NULL) return -1;\\n        \\n        int left=kthSmallest(root->left,k);          // left recursive call\\n        \\n        if(left!=-1) return left;                      // if we get answer from left call than return it\\n        k--;\\n        if(k==0) return root->val;                 // this is kth smallest element\\n         \\n        int right=kthSmallest(root->right,k);     // right recursive call\\n        \\n        if(right!=-1) return right;                   // if we get answert from right call than return it\\n        \\n        return -1;                                 // return -1 if we not get answer from this call\\n    }\\n```\\n\\n**Iterative**\\n**Time complexcity O(H+K)** H is height of bst\\n**Space complexcity O(H+K)**\\n```\\nint kthSmallest(TreeNode* root, int k) \\n    {\\n        stack<TreeNode *> stk;\\n        while(1)\\n        {\\n            while(root!=NULL)\\n            {\\n                stk.push(root);\\n                root=root->left;\\n            }\\n            root=stk.top();\\n            stk.pop();\\n            k--;\\n            if(k==0) return root->val;\\n            root=root->right;\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint kthSmallest(TreeNode* root, int &k) \\n    {\\n        if(root==NULL) return -1;\\n        \\n        int left=kthSmallest(root->left,k);          // left recursive call\\n        \\n        if(left!=-1) return left;                      // if we get answer from left call than return it\\n        k--;\\n        if(k==0) return root->val;                 // this is kth smallest element\\n         \\n        int right=kthSmallest(root->right,k);     // right recursive call\\n        \\n        if(right!=-1) return right;                   // if we get answert from right call than return it\\n        \\n        return -1;                                 // return -1 if we not get answer from this call\\n    }\\n```\n```\\nint kthSmallest(TreeNode* root, int k) \\n    {\\n        stack<TreeNode *> stk;\\n        while(1)\\n        {\\n            while(root!=NULL)\\n            {\\n                stk.push(root);\\n                root=root->left;\\n            }\\n            root=stk.top();\\n            stk.pop();\\n            k--;\\n            if(k==0) return root->val;\\n            root=root->right;\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 63743,
                "title": "java-divide-and-conquer-solution-considering-augmenting-tree-structure-for-the-follow-up",
                "content": "The idea behind the follow up question is what extra information is required for divide-and-conquer.  Basically is we can know the number of nodes on the left subtree, we get to know what is the position of the root node in the in-order traversal, which is basically the the kth number.  the left value can be saved in each node of the tree, and when we are finding the kth number, the complexity is O(lgn).\\n\\n       public class Solution {\\n            public int kthSmallest(TreeNode root, int k) {\\n                int left = nodeCount(root.left);  // this value can be saved in the root node\\n                if(left + 1 == k) {\\n                    return root.val;\\n                } else if (left + 1 < k) {\\n                    return kthSmallest(root.right, k - left - 1);\\n                } else {\\n                    return kthSmallest(root.left, k);\\n                }\\n            }\\n            \\n            private int nodeCount(TreeNode root) {\\n                if(root == null) {\\n                    return 0;\\n                }\\n                return 1 + nodeCount(root.left) + nodeCount(root.right);\\n            }\\n        }\\n\\t\\t\\nFollow up on the original post, I\\'ve wrote a version that has populated the count in a customized Node.\\n\\n```\\nclass Solution {\\n    public int kthSmallest(TreeNode root, int k) {\\n        Node node = buildTree(root);\\n        return findKth(node, k);\\n    }\\n    \\n    private int findKth(Node node, int k) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.count < k - 1) {\\n            return findKth(node.right, k - node.count - 1);\\n        } else if (node.count > k - 1) {\\n            return findKth(node.left, k);\\n        }\\n        return node.val;\\n    }\\n    \\n    private Node buildTree(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        Node node = new Node(root.val);\\n        \\n        int count = dfs(root.left);\\n        node.count = count;\\n        \\n        node.left = buildTree(root.left);\\n        node.right = buildTree(root.right);\\n        return node;\\n    }\\n    \\n    private int dfs(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        return dfs(root.left) + dfs(root.right) + 1;\\n    }\\n    \\n    class Node {\\n        Node left;\\n        Node right;\\n        int val;\\n        int count;\\n        Node (int val) {\\n            this.val = val;\\n        }\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Divide and Conquer"
                ],
                "code": "class Solution {\\n            public int kthSmallest(TreeNode root, int k) {\\n                int left = nodeCount(root.left);  // this value can be saved in the root node\\n                if(left + 1 == k) {\\n                    return root.val;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 1334632,
                "title": "c-simple-and-clean-recursive-and-iterative-solutions",
                "content": "**Recursive:**\\n```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, int& k) {\\n        if (!root) return;\\n        inorder(root->left, k);\\n        if (--k == 0) res = root->val;\\n        inorder(root->right, k);\\n    }\\n    \\n    int kthSmallest(TreeNode* root, int k) {\\n        inorder(root, k);\\n        return res;\\n    }\\n    \\nprivate:\\n    int res;\\n};\\n```\\n****\\n**Iterative:**\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        stack<TreeNode*> s;\\n        while (root || !s.empty()) {\\n            while (root) {\\n                s.push(root);\\n                root = root->left;\\n            }\\n            \\n            root = s.top();\\n            s.pop();\\n            \\n            if (--k == 0) return root->val;\\n            root = root->right;\\n        }\\n        return -1;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, int& k) {\\n        if (!root) return;\\n        inorder(root->left, k);\\n        if (--k == 0) res = root->val;\\n        inorder(root->right, k);\\n    }\\n    \\n    int kthSmallest(TreeNode* root, int k) {\\n        inorder(root, k);\\n        return res;\\n    }\\n    \\nprivate:\\n    int res;\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        stack<TreeNode*> s;\\n        while (root || !s.empty()) {\\n            while (root) {\\n                s.push(root);\\n                root = root->left;\\n            }\\n            \\n            root = s.top();\\n            s.pop();\\n            \\n            if (--k == 0) return root->val;\\n            root = root->right;\\n        }\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63956,
                "title": "python-solution-using-iteration",
                "content": "     class Solution:\\n            # @param {TreeNode} root\\n            # @param {integer} k\\n            # @return {integer}\\n            def kthSmallest(self, root, k):\\n                i=0\\n                stack=[]\\n                node=root\\n                while node or stack:\\n                    while node:\\n                        stack.append(node)\\n                        node=node.left\\n                    node=stack.pop()\\n                    i+=1\\n                    if i==k:\\n                        return node.val\\n                    node=node.right\\n\\nFor the follow up question, I think we could add a variable to the TreeNode to record the size of the left subtree. When insert or delete a node in the left subtree, we increase or decrease it by 1. So we could know whether the kth smallest element is in the left subtree or in the right subtree by compare the size with k.",
                "solutionTags": [
                    "Python"
                ],
                "code": "class Solution:\\n            # @param {TreeNode}",
                "codeTag": "Java"
            },
            {
                "id": 63896,
                "title": "simple-and-clean-java-solution-with-explanation",
                "content": "    public static int ans = 0;\\n    public int kthSmallest(TreeNode root, int k) {\\n        helper(root, k);\\n        return ans;\\n    }\\n    \\n    public int helper(TreeNode root, int k) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int leftCount = helper(root.left, k);\\n        int rightCount = helper(root.right, k - leftCount - 1);\\n        if (k == leftCount + 1) {\\n            ans = root.val;\\n        }\\n        return leftCount + rightCount + 1;\\n    }\\n\\nWe count the number of nodes of left sub tree and right sub tree recursively. Suppose the Kth smallest element is in the right sub tree, then we need to update k as k - leftCount - 1 (leftCount + 1 is the number of nodes of left sub tree plus the root node). Only when k equals leftCount + 1, we find the target.",
                "solutionTags": [
                    "Java"
                ],
                "code": "    public static int ans = 0;\\n    public int kthSmallest(TreeNode root, int k) {\\n        helper(root, k);\\n        return ans;\\n    }\\n    \\n    public int helper(TreeNode root, int k) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int leftCount = helper(root.left, k);\\n        int rightCount = helper(root.right, k - leftCount - 1);\\n        if (k == leftCount + 1) {\\n            ans = root.val;\\n        }\\n        return leftCount + rightCount + 1;\\n    }\\n\\nWe count the number of nodes of left sub tree and right sub tree recursively. Suppose the Kth smallest element is in the right sub tree, then we need to update k as k - leftCount - 1 (leftCount + 1 is the number of nodes of left sub tree plus the root node). Only when k equals leftCount + 1, we find the target.",
                "codeTag": "Unknown"
            },
            {
                "id": 642045,
                "title": "javascript-with-explanation-recursive-calls-short-circuit-when-reach-k-th-node",
                "content": "Short and simple, good code documents itself.  Have a look.  \\n\\nBasically you know that it\\'s a binary search tree, so go left for smallest values, after begin adding to array values.  Now that I think about it, I guess we just need a counter, rather then an array of values.  Once we get to the kth value, just return that and done.  No need for the array.  \\n\\nAnyway, here is what i\\'ve got.  This was a normal tree traversal, just added the short circuit factor.\\n\\nIf this helped you, please upvote so others can read.  Cheers.\\n\\n```\\nvar kthSmallest = function(root, k) {\\n  let vals = [];\\n  (function dfs(node) {\\n    if (vals.length !=k) { //no need to keep going after reach k-th number\\n      if(node.left) dfs(node.left); //go left first\\n      vals.push(node.val); //finished going left, now start adding values\\n      if (node.right) dfs(node.right); //if have right, go there and repeat process\\n    }  \\n  })(root) // IFFE Immediately Invoking Function Expression, starting from root.\\n  return vals[k-1]; //return element, but as i mentioned in the descript, don\\'t need this full array, just the k-th elm\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Tree",
                    "Binary Tree"
                ],
                "code": "```\\nvar kthSmallest = function(root, k) {\\n  let vals = [];\\n  (function dfs(node) {\\n    if (vals.length !=k) { //no need to keep going after reach k-th number\\n      if(node.left) dfs(node.left); //go left first\\n      vals.push(node.val); //finished going left, now start adding values\\n      if (node.right) dfs(node.right); //if have right, go there and repeat process\\n    }  \\n  })(root) // IFFE Immediately Invoking Function Expression, starting from root.\\n  return vals[k-1]; //return element, but as i mentioned in the descript, don\\'t need this full array, just the k-th elm\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 579698,
                "title": "c-recursive-soln-10-lines-code",
                "content": "```\\nclass Solution {\\npublic:\\n    int val;\\n    int ans;\\n    void fun(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return ;\\n        fun(root->left);\\n        val--;\\n        if(val==0)\\n            ans=root->val;\\n        fun(root->right);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        val=k;\\n        fun(root);\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int val;\\n    int ans;\\n    void fun(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return ;\\n        fun(root->left);\\n        val--;\\n        if(val==0)\\n            ans=root->val;\\n        fun(root->right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1047342,
                "title": "python-3-recursive-inorder-traversal-with-early-stopping",
                "content": "**Idea**:\\nDo a normal recursive inorder traversal. Add an extra check: if the length of our resulting list ```res``` becomes ```k```, then we have enough elements. Break your recursion and return the last element in ```res```.\\nIt works because an inorder traversal of a BST creates a sorted list.\\nProbably ```O(h)``` and ```O(k)``` time and space complexities respectively.\\n\\n```\\ndef kthSmallest_dfs_early_stopping(self, root, k):\\n\\tres = []\\n\\tdef _inorder(node):\\n\\t\\tif not node: return\\n\\t\\t_inorder(node.left)\\n\\t\\tif len(res) == k:\\n\\t\\t\\treturn\\n\\t\\tres.append(node.val)\\n\\t\\t_inorder(node.right)\\n\\t_inorder(root)\\n\\treturn res[-1]\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```res```\n```k```\n```res```\n```O(h)```\n```O(k)```\n```\\ndef kthSmallest_dfs_early_stopping(self, root, k):\\n\\tres = []\\n\\tdef _inorder(node):\\n\\t\\tif not node: return\\n\\t\\t_inorder(node.left)\\n\\t\\tif len(res) == k:\\n\\t\\t\\treturn\\n\\t\\tres.append(node.val)\\n\\t\\t_inorder(node.right)\\n\\t_inorder(root)\\n\\treturn res[-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 63824,
                "title": "c-solution-using-in-order-traversal",
                "content": "    class Solution {\\n    public:\\n        void inorder(TreeNode* root, vector<int> &res){\\n            if(!root)\\n                return;\\n            inorder(root->left, res);\\n            res.push_back(root->val);\\n            inorder(root->right,res);\\n            \\n        }\\n        int kthSmallest(TreeNode* root, int k) {\\n            if(!root)\\n                return -1;\\n            vector<int> arr;\\n            inorder(root, arr);\\n            return arr[k-1];\\n    \\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        void inorder(TreeNode* root, vector<int> &res){\\n            if(!root)\\n                return;\\n            inorder(root->left, res);\\n            res.push_back(root->val);\\n            inorder(root->right,res);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 816694,
                "title": "go-solution-using-channels",
                "content": "I feel this is the cleanest solution. Simple inorder traversal and we loop(k-1) over the values being passed and then return the kth element.\\n\\n```go\\nfunc walk(root *TreeNode, c chan int) {\\n\\tif root == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\twalk(root.Left, c)\\n\\tc <- root.Val\\n\\twalk(root.Right, c)\\n}\\n\\nfunc kthSmallest(root *TreeNode, k int) int {\\n\\tc := make(chan int)\\n\\tgo walk(root, c)\\n\\n\\tfor i := 0; i < k-1; i++ {\\n\\t\\t<-c\\n\\t}\\n\\treturn <-c\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc walk(root *TreeNode, c chan int) {\\n\\tif root == nil {\\n\\t\\treturn\\n\\t}\\n\\n\\twalk(root.Left, c)\\n\\tc <- root.Val\\n\\twalk(root.Right, c)\\n}\\n\\nfunc kthSmallest(root *TreeNode, k int) int {\\n\\tc := make(chan int)\\n\\tgo walk(root, c)\\n\\n\\tfor i := 0; i < k-1; i++ {\\n\\t\\t<-c\\n\\t}\\n\\treturn <-c\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 63772,
                "title": "o-k-java-solution",
                "content": "The number of nodes (**n**) in the tree is irrelevant to the complexity.  My code inorder traverse the tree and it stops when it finds the Kth node.  The time complexity for this code is O(k). \\n\\n=======Update============\\n\\nThe number of nodes in the tree does change the time complexity. The program actually goes to the left bottom node first and start from there to search for the Kth smallest. Thus the time complexity should be O(log(n) + K). What do you think ?\\n\\n    public class Solution {\\n    public int kthSmallest(TreeNode root, int k) {\\n        ArrayList<Integer> buffer = new ArrayList<Integer>();\\n        inorderSearch(root, buffer, k);\\n        return buffer.get(k-1);\\n    }\\n    public void inorderSearch(TreeNode node, ArrayList<Integer> buffer, int k){\\n        if(buffer.size() >= k)\\n            return;\\n        if(node.left != null){\\n            inorderSearch(node.left, buffer, k);\\n        }\\n        buffer.add(node.val);\\n        if(node.right != null){\\n            inorderSearch(node.right, buffer, k);\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int kthSmallest(TreeNode root, int k) {\\n        ArrayList<Integer> buffer = new ArrayList<Integer>();\\n        inorderSearch(root, buffer, k);\\n        return buffer.get(k-1);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1959037,
                "title": "well-explaned-dfs-inorder-0ms-100",
                "content": "```\\nclass Solution \\n{\\n    public void inorderSolve(TreeNode root, int k, int[] result)//BST inorder is ascendingly sorted \\n    {\\n        if(root == null)//Base Condition \\n            return;\\n        \\n        inorderSolve(root.left, k, result);//Recursing the Left side of the tree\\n        \\n        result[0]= result[0] + 1;//increamenting the of index \\n        \\n        if(result[0] == k){//when the required index is found \\n            result[1]= root.val;//Storing the value with the value present at kth index & -1 is for index out of bound \\n            return;\\n        }\\n        \\n        inorderSolve(root.right, k, result);//Recursing the Right side of the tree\\n        \\n        return;//returning to the callinng function \\n    }\\n    public int kthSmallest(TreeNode root, int k) \\n    {\\n        int[] result= {0, -1};\\n        \\n        inorderSolve(root, k, result);//calling the inorder function to get the samllest kth element \\n        \\n        return result[1];//if the index is out of bound then -1 is returned, else the value is returned \\n    }\\n}\\n```\\n<hr>\\n<hr>\\n\\n***Time complexity : O(N) to build a traversal.***\\n***Space complexity : O(N) to keep an inorder traversal.***\\n\\n<hr>\\n<hr>\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution \\n{\\n    public void inorderSolve(TreeNode root, int k, int[] result)//BST inorder is ascendingly sorted \\n    {\\n        if(root == null)//Base Condition \\n            return;\\n        \\n        inorderSolve(root.left, k, result);//Recursing the Left side of the tree\\n        \\n        result[0]= result[0] + 1;//increamenting the of index \\n        \\n        if(result[0] == k){//when the required index is found \\n            result[1]= root.val;//Storing the value with the value present at kth index & -1 is for index out of bound \\n            return;\\n        }\\n        \\n        inorderSolve(root.right, k, result);//Recursing the Right side of the tree\\n        \\n        return;//returning to the callinng function \\n    }\\n    public int kthSmallest(TreeNode root, int k) \\n    {\\n        int[] result= {0, -1};\\n        \\n        inorderSolve(root, k, result);//calling the inorder function to get the samllest kth element \\n        \\n        return result[1];//if the index is out of bound then -1 is returned, else the value is returned \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63789,
                "title": "iterative-in-order-traversal-using-stack-java-solution",
                "content": "As a lot of us know, this question can be solved by in-order traversal. Here, I am going to show how you can solve this question easily by performing iterative in-order traversal using stack.\\n\\nCode below is the iterative inorder traversal solution. It is pretty straightforward though, so I am not going to explain the code.\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(root != null || !stack.empty()){\\n            while(root != null){\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            list.add(root.val);\\n            root = root.right;\\n            \\n        }\\n        return list;\\n    }\\n\\nHere, we can solve the finding kth smallest element with as little tweak as possible. \\n\\n     public int kthSmallest(TreeNode root, int k) {\\n         Stack<TreeNode> stack = new Stack<>();\\n         while(root != null || !stack.isEmpty()) {\\n             while(root != null) {\\n                 stack.push(root);    \\n                 root = root.left;   \\n             } \\n             root = stack.pop();\\n             if(--k == 0) break;\\n             root = root.right;\\n         }\\n         return root.val;\\n     }",
                "solutionTags": [
                    "Java",
                    "Stack"
                ],
                "code": "As a lot of us know, this question can be solved by in-order traversal. Here, I am going to show how you can solve this question easily by performing iterative in-order traversal using stack.\\n\\nCode below is the iterative inorder traversal solution. It is pretty straightforward though, so I am not going to explain the code.\\n\\n    public List<Integer> inorderTraversal(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        if(root == null) return list;\\n        Stack<TreeNode> stack = new Stack<>();\\n        while(root != null || !stack.empty()){\\n            while(root != null){\\n                stack.push(root);\\n                root = root.left;\\n            }\\n            root = stack.pop();\\n            list.add(root.val);\\n            root = root.right;\\n            \\n        }\\n        return list;\\n    }\\n\\nHere, we can solve the finding kth smallest element with as little tweak as possible. \\n\\n     public int kthSmallest(TreeNode root, int k) {\\n         Stack<TreeNode> stack = new Stack<>();\\n         while(root != null || !stack.isEmpty()) {\\n             while(root != null) {\\n                 stack.push(root);    \\n                 root = root.left;   \\n             } \\n             root = stack.pop();\\n             if(--k == 0) break;\\n             root = root.right;\\n         }\\n         return root.val;\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 1095674,
                "title": "js-recursive-iterative-inorder-solutions",
                "content": "Recursive\\n```\\nconst kthSmallest = (root, k) => {\\n  let n = 0;\\n  let res;\\n  const inorder = (root) => {\\n    if (!root) return;\\n    inorder(root.left);\\n    if (n++ < k) res = root.val;\\n    inorder(root.right);\\n  };\\n  inorder(root);\\n  return res;\\n};\\n```\\n\\nIterative\\n```\\nvar kthSmallest = function (root, k) {\\n  const stack = [];\\n  let count = 1;\\n  let node = root;\\n\\n  while (node || stack.length) {\\n    while (node) {\\n      stack.push(node);\\n      node = node.left;\\n    }\\n    node = stack.pop();\\n    if (count === k) return node.val;\\n    else count++;\\n    node = node.right;\\n  }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nconst kthSmallest = (root, k) => {\\n  let n = 0;\\n  let res;\\n  const inorder = (root) => {\\n    if (!root) return;\\n    inorder(root.left);\\n    if (n++ < k) res = root.val;\\n    inorder(root.right);\\n  };\\n  inorder(root);\\n  return res;\\n};\\n```\n```\\nvar kthSmallest = function (root, k) {\\n  const stack = [];\\n  let count = 1;\\n  let node = root;\\n\\n  while (node || stack.length) {\\n    while (node) {\\n      stack.push(node);\\n      node = node.left;\\n    }\\n    node = stack.pop();\\n    if (count === k) return node.val;\\n    else count++;\\n    node = node.right;\\n  }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3230078,
                "title": "230-time-97-61-and-space-83-27-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nThe problem asks us to find the kth smallest value in a binary search tree. One way to do this is to traverse the tree in-order (left, root, right) and keep track of the number of nodes we have visited. Once we have visited k nodes, the next node we visit will be the kth smallest node.\\n\\nWe can do this using a stack to store the nodes we have visited so far. We start at the root of the tree and traverse as far left as possible, adding each node to the stack. Once we reach the leftmost node, we pop it off the stack (which is the smallest node we have seen so far) and decrement k. If k is 0, we have found the kth smallest value and can return it.\\n\\nIf k is not 0, we move to the right child of the node we just processed and repeat the process. This will visit the nodes in ascending order of value until we find the kth smallest node.\\n\\nNote that this algorithm has a time complexity of O(n) in the worst case (when the tree is skewed), since we need to visit every node in the tree. However, in the average case (when the tree is balanced), it has a time complexity of O(log n) since we only need to visit a subset of the nodes. Additionally, the space complexity is O(h) where h is the height of the tree, since we need to store at most h nodes on the stack at any given time.\\n\\n# Complexity\\n- Time complexity:\\n97.61%\\n\\n- Space complexity:\\n83.27%\\n\\n# Code\\n```\\nclass Solution:\\n    def kthSmallest(self, root: TreeNode, k: int) -> int:\\n        # create a stack to store the nodes\\n        stack = []\\n        # start at the root of the tree\\n        current = root\\n        \\n        # loop until we have processed all nodes and found the kth smallest value\\n        while True:\\n            # traverse as far left as possible from the current node, adding each node to the stack\\n            while current is not None:\\n                stack.append(current)\\n                current = current.left\\n            \\n            # if the stack is empty, we have processed all nodes and can exit the loop\\n            if not stack:\\n                break\\n                \\n            # pop the top node off the stack (which is the next smallest node) and decrement k\\n            node = stack.pop()\\n            k -= 1\\n            \\n            # if k is 0, we have found the kth smallest value and can return it\\n            if k == 0:\\n                return node.val\\n            \\n            # set the current node to the right child of the node we just processed\\n            current = node.right\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallest(self, root: TreeNode, k: int) -> int:\\n        # create a stack to store the nodes\\n        stack = []\\n        # start at the root of the tree\\n        current = root\\n        \\n        # loop until we have processed all nodes and found the kth smallest value\\n        while True:\\n            # traverse as far left as possible from the current node, adding each node to the stack\\n            while current is not None:\\n                stack.append(current)\\n                current = current.left\\n            \\n            # if the stack is empty, we have processed all nodes and can exit the loop\\n            if not stack:\\n                break\\n                \\n            # pop the top node off the stack (which is the next smallest node) and decrement k\\n            node = stack.pop()\\n            k -= 1\\n            \\n            # if k is 0, we have found the kth smallest value and can return it\\n            if k == 0:\\n                return node.val\\n            \\n            # set the current node to the right child of the node we just processed\\n            current = node.right\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1407567,
                "title": "follow-up-solution-with-o-log-n-time-complexity-orderstatisticstree",
                "content": "Solution for the follow-up:\\n**Follow up:** If the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?\\n\\n**We can find kthSmallest in O(log(n)) if we build a tree in a certain way**. \\nThe only addition we need - is to have \"size\" property for each TreeNode. Size can be found as:\\n```\\nnode.size = 1 + size(node.left) + size(node.right);\\n```\\n\\nIf we know size for each node, we can implement FindByRank operation in O(log(n)) time:\\nhttps://www.cs.yale.edu/homes/aspnes/pinewiki/OrderStatisticsTree.html\\n\\nSolution below will demonstrate how it works, however it is slower that regular O(n) solutions, because we are building the tree in custom way, calculating size for each node and only then calculating \"Rank\". \\n**Solution below is O(n*log(n)): build tree (O(n*log(n)) + findRank (O(log(n))\\nIf we had \"size\" property initially in the tree, we would have found kthSmallest (findByRank) in O(log(n)) time.**\\n```\\nclass Solution {\\n//region precoditions\\n    class TreeNodeWithSize {\\n        int val;\\n        int size;\\n        TreeNodeWithSize left;\\n        TreeNodeWithSize right;\\n        TreeNodeWithSize(int val) { this.val = val; }\\n    }\\n\\n    class OrderStatisticsTree {\\n        TreeNodeWithSize root;\\n\\n       public int size(TreeNodeWithSize node){\\n            if(node == null){\\n                return 0;\\n            }\\n            return node.size;\\n        }\\n\\n        public void put(TreeNodeWithSize node){\\n            root = put(root, node);\\n        }\\n\\n        private TreeNodeWithSize put(TreeNodeWithSize x, TreeNodeWithSize node){\\n            if(x == null) {\\n                node.size = 1;\\n                return node;\\n            }\\n\\n            if(node.val < x.val){\\n                x.left = put(x.left, node);\\n            }else if(node.val > x.val){\\n                x.right = put(x.right, node);\\n            }else{\\n                x.val = node.val; //redundant, but leaving it here for display purposes\\n            }\\n            x.size = 1 + size(x.left) + size(x.right);\\n            return x;\\n        }\\n\\n        public int findByRank(int rank){\\n            return findByRank(root, rank);\\n        }\\n\\n        private int findByRank(TreeNodeWithSize root, int rank){\\n            if(root == null) throw new IllegalArgumentException(\"empty tree\");\\n\\n            int leftSize = 0;\\n            if(root.left != null){\\n                leftSize = root.left.size;\\n            }\\n\\n            if(rank <= leftSize){\\n                return findByRank(root.left, rank);\\n            }else if(rank > leftSize + 1){\\n                return findByRank(root.right, rank - leftSize - 1);\\n            }\\n            return root.val;\\n        }\\n    }\\n//endregion\\t\\n\\n//region problem solving\\n    OrderStatisticsTree bst = new OrderStatisticsTree();\\n    public int kthSmallest(TreeNode root, int k) {\\n        buildOrderStatisticsTree(root);\\n        return bst.findByRank(k);\\n    }\\n//endregion\\t\\n\\n    public void buildOrderStatisticsTree(TreeNode node) {\\n        if (node == null){\\n            return;\\n        }\\n\\n        bst.put(new TreeNodeWithSize(node.val));\\n        buildOrderStatisticsTree(node.left);\\n        buildOrderStatisticsTree(node.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\nnode.size = 1 + size(node.left) + size(node.right);\\n```\n```\\nclass Solution {\\n//region precoditions\\n    class TreeNodeWithSize {\\n        int val;\\n        int size;\\n        TreeNodeWithSize left;\\n        TreeNodeWithSize right;\\n        TreeNodeWithSize(int val) { this.val = val; }\\n    }\\n\\n    class OrderStatisticsTree {\\n        TreeNodeWithSize root;\\n\\n       public int size(TreeNodeWithSize node){\\n            if(node == null){\\n                return 0;\\n            }\\n            return node.size;\\n        }\\n\\n        public void put(TreeNodeWithSize node){\\n            root = put(root, node);\\n        }\\n\\n        private TreeNodeWithSize put(TreeNodeWithSize x, TreeNodeWithSize node){\\n            if(x == null) {\\n                node.size = 1;\\n                return node;\\n            }\\n\\n            if(node.val < x.val){\\n                x.left = put(x.left, node);\\n            }else if(node.val > x.val){\\n                x.right = put(x.right, node);\\n            }else{\\n                x.val = node.val; //redundant, but leaving it here for display purposes\\n            }\\n            x.size = 1 + size(x.left) + size(x.right);\\n            return x;\\n        }\\n\\n        public int findByRank(int rank){\\n            return findByRank(root, rank);\\n        }\\n\\n        private int findByRank(TreeNodeWithSize root, int rank){\\n            if(root == null) throw new IllegalArgumentException(\"empty tree\");\\n\\n            int leftSize = 0;\\n            if(root.left != null){\\n                leftSize = root.left.size;\\n            }\\n\\n            if(rank <= leftSize){\\n                return findByRank(root.left, rank);\\n            }else if(rank > leftSize + 1){\\n                return findByRank(root.right, rank - leftSize - 1);\\n            }\\n            return root.val;\\n        }\\n    }\\n//endregion\\t\\n\\n//region problem solving\\n    OrderStatisticsTree bst = new OrderStatisticsTree();\\n    public int kthSmallest(TreeNode root, int k) {\\n        buildOrderStatisticsTree(root);\\n        return bst.findByRank(k);\\n    }\\n//endregion\\t\\n\\n    public void buildOrderStatisticsTree(TreeNode node) {\\n        if (node == null){\\n            return;\\n        }\\n\\n        bst.put(new TreeNodeWithSize(node.val));\\n        buildOrderStatisticsTree(node.left);\\n        buildOrderStatisticsTree(node.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63901,
                "title": "python-recursive-solution-averaged-time-o-lg-n-k",
                "content": "        \\n    # averaged time complexity: log(n) + k\\n    def kthSmallest(self, root, k):\\n        self.k = k\\n        self.res = 0\\n        self.helper(root)\\n        return self.res\\n        \\n    def helper(self, root):\\n        if root:\\n            self.helper(root.left)\\n            self.k -= 1\\n            if self.k == 0:\\n                self.res = root.val\\n                return \\n            self.helper(root.right)",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "        \\n    # averaged time complexity: log(n) + k\\n    def kthSmallest(self, root, k):\\n        self.k = k\\n        self.res = 0\\n        self.helper(root)\\n        return self.res\\n        \\n    def helper(self, root):\\n        if root:\\n            self.helper(root.left)\\n            self.k -= 1\\n            if self.k == 0:\\n                self.res = root.val\\n                return \\n            self.helper(root.right)",
                "codeTag": "Python3"
            },
            {
                "id": 682643,
                "title": "python-faster-than-100-in-order-traversal-using-stack-solution-easy",
                "content": "```\\nclass Solution:\\n    def kthSmallest(self, root: TreeNode, k: int) -> int:\\n        stack = []\\n        res = []\\n        while stack or root:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            res.append(root)\\n            root = root.right\\n        return res[k-1].val\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallest(self, root: TreeNode, k: int) -> int:\\n        stack = []\\n        res = []\\n        while stack or root:\\n            while root:\\n                stack.append(root)\\n                root = root.left\\n            root = stack.pop()\\n            res.append(root)\\n            root = root.right\\n        return res[k-1].val\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63849,
                "title": "five-solutions-in-python-recursive-iterative-in-order-binary-search",
                "content": "Five different ways.\\n\\nAccording to \\nhttps://leetcode.com/discuss/43771/implemented-java-binary-search-order-iterative-recursive\\nhttps://leetcode.com/discuss/44731/pythonic-approach-with-generator\\n\\n    # Binary search iterative\\n    class Solution(object):\\n        def kthSmallest(self, root, k):\\n            count = self.get_nodes(root.left)\\n            while count + 1 != k:\\n                if count + 1 < k:\\n                    root = root.right\\n                    k = k - count - 1\\n                else:\\n                    root = root.left\\n                count = self.get_nodes(root.left)\\n            return root.val\\n    \\n        def get_nodes(self, root):\\n            if not root:\\n                return 0\\n            return 1 + self.get_nodes(root.left) + self.get_nodes(root.right)\\n    \\n    \\n    # Binary search recursive\\n    class Solution_2(object):\\n        def kthSmallest(self, root, k):\\n            count = self.get_nodes(root.left)\\n            if count+1 < k:\\n                return self.kthSmallest(root.right, k-count-1)\\n            elif count+1 == k:\\n                return root.val\\n            else:\\n                return self.kthSmallest(root.left, k)\\n    \\n        def get_nodes(self, root):\\n            if not root:\\n                return 0\\n            return 1 + self.get_nodes(root.left) + self.get_nodes(root.right)\\n    \\n    \\n    # DFS in-order iterative:\\n    class Solution_3(object):\\n        def kthSmallest(self, root, k):\\n            node_stack = []\\n            count, result = 0, 0\\n            while root or node_stack:\\n                if root:\\n                    node_stack.append(root)\\n                    root = root.left\\n                else:\\n                    if node_stack:\\n                        root = node_stack.pop()\\n                        result = root.val\\n                        count += 1\\n                        if count == k:\\n                            return result\\n                        root = root.right\\n    \\n            return -1   # never hit if k is valid\\n    \\n    \\n    # DFS in-order recursive:\\n    class Solution_4(object):\\n        def kthSmallest(self, root, k):\\n            self.k = k\\n            self.num = 0\\n            self.in_order(root)\\n            return self.num\\n    \\n        def in_order(self, root):\\n            if root.left:\\n                self.in_order(root.left)\\n            self.k -= 1\\n            if self.k == 0:\\n                self.num = root.val\\n                return\\n            if root.right:\\n                self.in_order(root.right)\\n    \\n    \\n    # DFS in-order recursive, Pythonic approach with generator:\\n    class Solution_5(object):\\n        def kthSmallest(self, root, k):\\n            for val in self.in_order(root):\\n                if k == 1:\\n                    return val\\n                else:\\n                    k -= 1\\n    \\n        def in_order(self, root):\\n            if root:\\n                for val in self.in_order(root.left):\\n                    yield val\\n                yield root.val\\n                for val in self.in_order(root.right):\\n                    yield val",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "Five different ways.\\n\\nAccording to \\nhttps://leetcode.com/discuss/43771/implemented-java-binary-search-order-iterative-recursive\\nhttps://leetcode.com/discuss/44731/pythonic-approach-with-generator\\n\\n    # Binary search iterative\\n    class Solution(object):\\n        def kthSmallest(self, root, k):\\n            count = self.get_nodes(root.left)\\n            while count + 1 != k:\\n                if count + 1 < k:\\n                    root = root.right\\n                    k = k - count - 1\\n                else:\\n                    root = root.left\\n                count = self.get_nodes(root.left)\\n            return root.val\\n    \\n        def get_nodes(self, root):\\n            if not root:\\n                return 0\\n            return 1 + self.get_nodes(root.left) + self.get_nodes(root.right)\\n    \\n    \\n    # Binary search recursive\\n    class Solution_2(object):\\n        def kthSmallest(self, root, k):\\n            count = self.get_nodes(root.left)\\n            if count+1 < k:\\n                return self.kthSmallest(root.right, k-count-1)\\n            elif count+1 == k:\\n                return root.val\\n            else:\\n                return self.kthSmallest(root.left, k)\\n    \\n        def get_nodes(self, root):\\n            if not root:\\n                return 0\\n            return 1 + self.get_nodes(root.left) + self.get_nodes(root.right)\\n    \\n    \\n    # DFS in-order iterative:\\n    class Solution_3(object):\\n        def kthSmallest(self, root, k):\\n            node_stack = []\\n            count, result = 0, 0\\n            while root or node_stack:\\n                if root:\\n                    node_stack.append(root)\\n                    root = root.left\\n                else:\\n                    if node_stack:\\n                        root = node_stack.pop()\\n                        result = root.val\\n                        count += 1\\n                        if count == k:\\n                            return result\\n                        root = root.right\\n    \\n            return -1   # never hit if k is valid\\n    \\n    \\n    # DFS in-order recursive:\\n    class Solution_4(object):\\n        def kthSmallest(self, root, k):\\n            self.k = k\\n            self.num = 0\\n            self.in_order(root)\\n            return self.num\\n    \\n        def in_order(self, root):\\n            if root.left:\\n                self.in_order(root.left)\\n            self.k -= 1\\n            if self.k == 0:\\n                self.num = root.val\\n                return\\n            if root.right:\\n                self.in_order(root.right)\\n    \\n    \\n    # DFS in-order recursive, Pythonic approach with generator:\\n    class Solution_5(object):\\n        def kthSmallest(self, root, k):\\n            for val in self.in_order(root):\\n                if k == 1:\\n                    return val\\n                else:\\n                    k -= 1\\n    \\n        def in_order(self, root):\\n            if root:\\n                for val in self.in_order(root.left):\\n                    yield val\\n                yield root.val\\n                for val in self.in_order(root.right):\\n                    yield val",
                "codeTag": "Java"
            },
            {
                "id": 641669,
                "title": "trivial-question-inorder-tree-traversal-left-root-right",
                "content": "**Trivial inorder tree traversal question\\'s application** \\n\\n**INORDER traversal of binary search tree results in sorted elements with increasing value**\\n```\\ntraverse recursively : left > root > rigth and keep on counting, if you have reached nth smallest node,\\n( ie nth node in its INORDER traversal then return that node\\'s value )\\n```\\n\\n**Optimization** : early stopping , ( no need to traverse whole tree, return at the spot when you hits nth value in inorder traversal ).\\n```\\nint n, ans;\\n    void traverse(TreeNode *root)\\n    {\\n        if(!root)   return;\\n        \\n        if(root->left)                         // traverse left\\n            traverse(root->left);\\n        \\n        if(--n==0)                                   // if count becomes zero , means we have reached nth node in INORDER traversal\\n            { \\n\\t\\t\\t    ans = root->val;   // store answer\\n\\t\\t\\t\\treturn;                   // stop traversing, no need to go futher since we have already reached the answer\\n\\t\\t\\t}\\n        \\n        if(root->right)\\n            traverse(root->right);\\n            \\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        n=k;\\n        traverse(root);\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\ntraverse recursively : left > root > rigth and keep on counting, if you have reached nth smallest node,\\n( ie nth node in its INORDER traversal then return that node\\'s value )\\n```\n```\\nint n, ans;\\n    void traverse(TreeNode *root)\\n    {\\n        if(!root)   return;\\n        \\n        if(root->left)                         // traverse left\\n            traverse(root->left);\\n        \\n        if(--n==0)                                   // if count becomes zero , means we have reached nth node in INORDER traversal\\n            { \\n\\t\\t\\t    ans = root->val;   // store answer\\n\\t\\t\\t\\treturn;                   // stop traversing, no need to go futher since we have already reached the answer\\n\\t\\t\\t}\\n        \\n        if(root->right)\\n            traverse(root->right);\\n            \\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        n=k;\\n        traverse(root);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 63811,
                "title": "my-simple-20-ms-iterative-c-code",
                "content": "    /**\\n     * Definition for a binary tree node.\\n     * struct TreeNode {\\n     *     int val;\\n     *     TreeNode *left;\\n     *     TreeNode *right;\\n     *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n     * };\\n     */\\n    class Solution {\\n    public:\\n        int kthSmallest(TreeNode* root, int k) {\\n            \\n            TreeNode * current = root;\\n            stack<TreeNode*> s;\\n            while(!s.empty() || current != NULL)\\n            {\\n                if(current)\\n                {\\n                    s.push(current);\\n                    current = current->left;\\n                }\\n                else\\n                {\\n                    current = s.top();\\n                    s.pop();\\n                    k--;\\n                    if(k == 0)\\n                        return current->val;\\n                    current = current->right;    \\n                }\\n                \\n            }\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int kthSmallest(TreeNode* root, int k) {\\n            \\n            TreeNode * current = root;\\n            stack<TreeNode*> s;\\n            while(!s.empty() || current != NULL)\\n            {\\n                if(current)\\n                {\\n                    s.push(current);\\n                    current = current->left;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2733644,
                "title": "python-easy-recursive-solution-o-n-beats-96-85",
                "content": "# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n\\n        def tree_to_list(root) -> list:\\n            if not root:\\n                return []\\n\\n            return tree_to_list(root.right) + [root.val] + tree_to_list(root.left)\\n        \\n        tree_list = tree_to_list(root)\\n        return tree_list[-k]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n\\n        def tree_to_list(root) -> list:\\n            if not root:\\n                return []\\n\\n            return tree_to_list(root.right) + [root.val] + tree_to_list(root.left)\\n        \\n        tree_list = tree_to_list(root)\\n        return tree_list[-k]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960529,
                "title": "c-6-line-recursion-inorder-traversal-230-kth-smallest-element-in-a-bst",
                "content": "**Approach:**\\nSince **inorder traversal** of BST **gives values in sorted order**\\nStore values in a vector using *inorder* traversal.  As 1 based indexing is there hence\\n**1st** **Smallest** **Value will be v[0] 2nd smallest will be v[1].............** *likewise* \\n**kth smallest value will be v[k-1]** \\n\\n\\tclass Solution {\\n\\t\\tvector<int>v;\\n\\tpublic:\\n\\t\\tvoid inorder(TreeNode* root)\\n\\t\\t{\\n\\t\\t\\tif(root==NULL) return;\\n\\t\\t\\tinorder(root->left);\\n\\t\\t\\tv.push_back(root->val);\\n\\t\\t\\tinorder(root->right);\\n\\t\\t}\\n\\t\\tint kthSmallest(TreeNode* root, int k) {\\n\\t\\t\\tinorder(root);\\n\\t\\t\\t// v.resize(v.size());\\n\\t\\t\\treturn v[k-1];\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tvector<int>v;\\n\\tpublic:\\n\\t\\tvoid inorder(TreeNode* root)\\n\\t\\t{\\n\\t\\t\\tif(root==NULL) return;\\n\\t\\t\\tinorder(root->left);\\n\\t\\t\\tv.push_back(root->val);\\n\\t\\t\\tinorder(root->right);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 63790,
                "title": "easy-to-understand-answer-the-follow-up-question",
                "content": "\\n    public int kthSmallest(TreeNode root, int k) {\\n       PriorityQueue<Integer> queue = new PriorityQueue<>(k, Collections.reverseOrder());\\n\\n        kthHelper(queue, root, k);\\n        return queue.peek();\\n    }\\n\\n    private void kthHelper(PriorityQueue<Integer> queue, TreeNode root, int k) {\\n\\n        if (root == null || queue.size() >= k) return;\\n\\n       kthHelper(queue, root.left, k);\\n        if (queue.size() >= k) return;\\n\\n        queue.add(root.val);\\n\\n        if (root.right != null) kthHelper(queue, root.right, k);\\n    }",
                "solutionTags": [],
                "code": "\\n    public int kthSmallest(TreeNode root, int k) {\\n       PriorityQueue<Integer> queue = new PriorityQueue<>(k, Collections.reverseOrder());\\n\\n        kthHelper(queue, root, k);\\n        return queue.peek();\\n    }\\n\\n    private void kthHelper(PriorityQueue<Integer> queue, TreeNode root, int k) {\\n\\n        if (root == null || queue.size() >= k) return;\\n\\n       kthHelper(queue, root.left, k);\\n        if (queue.size() >= k) return;\\n\\n        queue.add(root.val);\\n\\n        if (root.right != null) kthHelper(queue, root.right, k);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 63843,
                "title": "simple-java-solution-perform-in-order-tree-traversal",
                "content": "    public class Solution {\\n    private TreeNode temp;\\n    private int counter;\\n    public int kthSmallest(TreeNode root, int k) {\\n        counter  = 0;\\n        dfs(root, k);\\n        return temp.val;\\n    }\\n    public void dfs(TreeNode node, int k){\\n        // perform in order tree traversal \\n        if(node == null) return; // base case\\n        dfs(node.left, k);\\n        if(++counter == k) {\\n            temp = node;\\n            return;\\n        }\\n        dfs(node.right, k);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private TreeNode temp;\\n    private int counter;\\n    public int kthSmallest(TreeNode root, int k) {\\n        counter  = 0;\\n        dfs(root, k);\\n        return temp.val;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 3689456,
                "title": "inorder-traversal-c-using-bst-property",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIn BST, Inorder travesal gives node\\'s values in sorted order.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe\\'ll store all values into a vector during inorder traversal, and return vec[k-1].\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(H)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   void Inorder(TreeNode* root, vector<int>&vec){\\n        if(root == NULL)\\n        return;\\n      Inorder(root->left,vec);\\n      vec.push_back(root->val);\\n      Inorder(root->right,vec);\\n   }\\n    int kthSmallest(TreeNode* root, int k) {\\n        vector<int>vec;\\n        Inorder(root,vec);\\n        return vec[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   void Inorder(TreeNode* root, vector<int>&vec){\\n        if(root == NULL)\\n        return;\\n      Inorder(root->left,vec);\\n      vec.push_back(root->val);\\n      Inorder(root->right,vec);\\n   }\\n    int kthSmallest(TreeNode* root, int k) {\\n        vector<int>vec;\\n        Inorder(root,vec);\\n        return vec[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2937662,
                "title": "easy-solution-short-simple-best-method-easy-to-understand",
                "content": "\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int ans;\\n    void inorder(TreeNode* root, int& k)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left,k);\\n        k--;\\n        if(k==0)\\n        {\\n            ans=root->val;\\n            return;\\n        }\\n        inorder(root->right,k);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        inorder(root, k);\\n        return ans;\\n        \\n    }\\n};\\n```\\nPlease **UPVOTE** if it helps \\u2764\\uFE0F\\uD83D\\uDE0A\\nThank You and Happy To Help You!!",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    int ans;\\n    void inorder(TreeNode* root, int& k)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left,k);\\n        k--;\\n        if(k==0)\\n        {\\n            ans=root->val;\\n            return;\\n        }\\n        inorder(root->right,k);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        inorder(root, k);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961661,
                "title": "day-18-daily-leetcode-challenge-problem-java-o-n-recursion",
                "content": "APPROACH:  O(N) time and O(1) space\\n\\n* Traverse the tree in inorder fashion, and on each function frame increase kth variable.\\n* Inorder gives the sorted order.\\n* when kth variable become equal to k that means we got our ans (i.e kth smallest element )\\n* O(1) space.\\n* O(N) time.\\n\\n### **JAVA**\\n\\n```\\n\\nclass Solution {\\n\\n    static int kth=0;\\n   \\n    static int kthsmall=0;\\n\\n   public int kthSmallest(TreeNode root, int k) {\\n    \\n\\t    kth=0;\\n        kthsmall=0;\\n        \\n        inorder(root,k);\\n        \\n        return ans;\\n    }\\n    \\n    public static void inorder(TreeNode root,int k){\\n        \\n        if(root==null){\\n            return ;\\n        }        \\n        \\n        inorder(root.left,k);\\n        \\n        kth++;\\n        if(kth==k){\\n            kthsmall=root.val;\\n        }\\n        \\n        inorder(root.right,k);     \\n    }\\n}\\n\\t\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n\\n    static int kth=0;\\n   \\n    static int kthsmall=0;\\n\\n   public int kthSmallest(TreeNode root, int k) {\\n    \\n\\t    kth=0;\\n        kthsmall=0;\\n        \\n        inorder(root,k);\\n        \\n        return ans;\\n    }\\n    \\n    public static void inorder(TreeNode root,int k){\\n        \\n        if(root==null){\\n            return ;\\n        }        \\n        \\n        inorder(root.left,k);\\n        \\n        kth++;\\n        if(kth==k){\\n            kthsmall=root.val;\\n        }\\n        \\n        inorder(root.right,k);     \\n    }\\n}\\n\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961001,
                "title": "python-recursive-solution-using-inorder-traversal",
                "content": "We Know in BST if we do inorder traversal  and store the values in an array then it will be in sorted order.By using this property we do the inorder traversal and return k-1th element in the array which stores the values while performing the inorder traversal \\n\\n```\\nclass Solution:\\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n        values = []\\n        arr = self.inorder(root,values)\\n        return arr[k-1]\\n    \\n    #Driver Function For Inorder Traversal\\n\\t#Inorder Traversal means Left -> Root -> Right\\n\\t\\n    def inorder(self,root,a):\\n        if(root):\\n            self.inorder(root.left,a)\\n            a.append(root.val)  #Storing The Values in the Array which is passed as an argument\\n            self.inorder(root.right,a)\\n        return a\\n```\\nPlease upvote if you understand the solution",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n        values = []\\n        arr = self.inorder(root,values)\\n        return arr[k-1]\\n    \\n    #Driver Function For Inorder Traversal\\n\\t#Inorder Traversal means Left -> Root -> Right\\n\\t\\n    def inorder(self,root,a):\\n        if(root):\\n            self.inorder(root.left,a)\\n            a.append(root.val)  #Storing The Values in the Array which is passed as an argument\\n            self.inorder(root.right,a)\\n        return a\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959253,
                "title": "c-easy-intuitive-recursion-extra-space",
                "content": "**Please Upvote if you Like :)**\\n```\\nclass Solution {\\npublic:\\n    set<int> s;\\n    void traverse(TreeNode* root){\\n        if(!root) return;\\n        s.insert(root->val);\\n        traverse(root->left);\\n        traverse(root->right);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {  \\n        traverse(root);\\n        for(auto ans:s){\\n            k--;\\n            if(!k) return ans;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    set<int> s;\\n    void traverse(TreeNode* root){\\n        if(!root) return;\\n        s.insert(root->val);\\n        traverse(root->left);\\n        traverse(root->right);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {  \\n        traverse(root);\\n        for(auto ans:s){\\n            k--;\\n            if(!k) return ans;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 134880,
                "title": "simple-javascript-iterative-solution-o-n-faster-than-100-of-solutions",
                "content": "```\\nvar kthSmallest = function(root, k) {\\n    let stack = [];\\n    let count = 0;\\n    let node = root;\\n    \\n    while (true){\\n        if (node){\\n            stack.push(node);\\n            node = node.left;\\n        } else {\\n            if (stack.length == 0) break;\\n            node = stack.pop();\\n            count += 1;\\n            if (count == k) return node.val;\\n            node = node.right;\\n        }\\n    }\\n};\\n```\\n\\nRelies on inorder traversal using a stack.",
                "solutionTags": [],
                "code": "```\\nvar kthSmallest = function(root, k) {\\n    let stack = [];\\n    let count = 0;\\n    let node = root;\\n    \\n    while (true){\\n        if (node){\\n            stack.push(node);\\n            node = node.left;\\n        } else {\\n            if (stack.length == 0) break;\\n            node = stack.pop();\\n            count += 1;\\n            if (count == k) return node.val;\\n            node = node.right;\\n        }\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 63914,
                "title": "c-code-log-h-space-and-o-n-concise-code",
                "content": "    public int KthSmallest(TreeNode root, int k) {\\n                    // Olog(n) ~ O(h)\\n            Stack<TreeNode> s = new Stack<TreeNode>();\\n            while (s.Count != 0 || root != null) {\\n                if (root != null)\\n                {\\n                    s.Push(root);\\n                    root = root.left;\\n                }\\n                else {\\n                    root = s.Pop();\\n                    k--; if (k == 0) break;\\n                    root = root.right;\\n                }\\n            }\\n\\n            if (k > 0) throw new Exception();\\n\\n            return root.val;\\n\\n    }",
                "solutionTags": [],
                "code": "    public int KthSmallest(TreeNode root, int k) {\\n                    // Olog(n) ~ O(h)\\n            Stack<TreeNode> s = new Stack<TreeNode>();\\n            while (s.Count != 0 || root != null) {\\n                if (root != null)\\n                {\\n                    s.Push(root);\\n                    root = root.left;\\n                }\\n                else {\\n                    root = s.Pop();\\n                    k--; if (k == 0) break;\\n                    root = root.right;\\n                }\\n            }\\n\\n            if (k > 0) throw new Exception();\\n\\n            return root.val;\\n\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2413780,
                "title": "2-approaches-easy-100ms-bst",
                "content": "AN UPVOTE WILL BE HIGHLY APPRECIATED\\n```\\n//APPROACH 1(ARRAYLIST ONE)\\nclass Solution {\\n    static ArrayList<Integer> arr = new ArrayList<Integer>();\\n    \\n    static void PreeOrder(TreeNode root){\\n        if(root == null){\\n            return;\\n        }\\n        arr.add(root.val);\\n        PreeOrder(root.left);\\n        PreeOrder(root.right);\\n    }\\n    \\n    public int kthSmallest(TreeNode root, int k) {\\n        arr = new ArrayList<Integer>();\\n        PreeOrder(root);\\n        Collections.sort(arr); \\n        return arr.get(k-1);\\n    }\\n}\\n\\n\\n//APPROACH 2(OPTIMIZED ONE)\\nclass Solution {\\n    int i =1;     //variable to track position of the element\\n    int ans = 0;\\n    public int kthSmallest(TreeNode root, int k) {\\n        inorder(root, k);\\n        return ans;\\n        \\n    }\\n    \\n    public void inorder(TreeNode root, int k) {\\n        if(root == null) {\\n            return;\\n        }\\n        \\n        inorder(root.left, k);\\n        \\n        if(i==k){\\n            ans = root.val;    // store root value in ans when i == k\\n        }\\n        i++;       //increament variable for every call\\n        inorder(root.right, k);\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n    static ArrayList<Integer> arr = new ArrayList<Integer>();\\n    \\n    static void PreeOrder(TreeNode root){\\n        if(root == null){\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2058977,
                "title": "c-in-order-traversal-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans = 0, kg, c = 1;\\n    void inOrder(TreeNode* root) {\\n        if(root){\\n            inOrder(root->left);\\n            if(c == kg)\\n                ans = root->val;\\n            c++;\\n            inOrder(root->right);\\n        }\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        kg = k;\\n        inOrder(root);\\n        return ans;\\n    }\\n};\\n```\\n**Do upvote if you liked it**",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0, kg, c = 1;\\n    void inOrder(TreeNode* root) {\\n        if(root){\\n            inOrder(root->left);\\n            if(c == kg)\\n                ans = root->val;\\n            c++;\\n            inOrder(root->right);\\n        }\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        kg = k;\\n        inOrder(root);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959292,
                "title": "clean-easy-c-both-iterative-and-recursive-methods",
                "content": "### Recursive Approach:\\n* A recursive `In-Order Traversal` could be performed, and a `count` value could be maintained to reach to the kth Smallest Node. Below is the implementation, which is self explainatory.\\n* Time Complexity: **O(N)**, since we are essentially performing a DFS starting at the `root`.\\n* Space Complexity: Recursion uses the stack space internally, hence **O(N)**. No additional data structures used to preserve values. Hence, **O(1) auxillary.**\\n```c++\\nclass Solution {\\n    int answer;\\npublic:\\n    Solution():answer(0){}\\n    void Solve(TreeNode *root, int k, int &count){\\n        if(not root) \\n\\t\\t  return;\\n        Solve(root->left, k, count);\\n        count++;\\n        if(count==k){\\n          answer = root->val;\\n          return;\\n        }\\n        Solve(root->right, k, count);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        int count = 0;\\n        Solve(root,k,count);\\n        return answer;\\n    }\\n};\\n```\\n\\n---\\n### Iterative Approach:\\n* We could utilize the stack data structure to perform the same traversal and maintain the count value, to reach to the kth smallest Node. Idea is essentially the same as above, instead of using `recursion`, we could use `stack` to write an iterative solution\\n* Time Complexity: **O(N)**\\n* Space Complexity: **O(N) auxillary space**, since we have used a `stack` data structure.\\n* Below is the clean iterative solution.\\n```c++\\n int kthSmallest(TreeNode* root, int k) {\\n        stack<TreeNode*> St;\\n        int count = 0;\\n        TreeNode *node = root;\\n        while(not St.empty() || node){\\n            if(node){\\n                St.push(node);\\n                node = node->left;\\n            }else{\\n                node = St.top(); St.pop();\\n                if(++count==k) return node->val;\\n                node = node->right;\\n            }\\n        }\\n        return INT_MIN;\\n    }\\n```\\n\\n> Please feel free to comment below your ideas, or any doubt regarding the aforementioned code. :)",
                "solutionTags": [
                    "C",
                    "Iterator"
                ],
                "code": "```c++\\nclass Solution {\\n    int answer;\\npublic:\\n    Solution():answer(0){}\\n    void Solve(TreeNode *root, int k, int &count){\\n        if(not root) \\n\\t\\t  return;\\n        Solve(root->left, k, count);\\n        count++;\\n        if(count==k){\\n          answer = root->val;\\n          return;\\n        }\\n        Solve(root->right, k, count);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        int count = 0;\\n        Solve(root,k,count);\\n        return answer;\\n    }\\n};\\n```\n```c++\\n int kthSmallest(TreeNode* root, int k) {\\n        stack<TreeNode*> St;\\n        int count = 0;\\n        TreeNode *node = root;\\n        while(not St.empty() || node){\\n            if(node){\\n                St.push(node);\\n                node = node->left;\\n            }else{\\n                node = St.top(); St.pop();\\n                if(++count==k) return node->val;\\n                node = node->right;\\n            }\\n        }\\n        return INT_MIN;\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959089,
                "title": "python3-faster-98-65-memory-99-79-tc-o-n-sc-o-1-morris-traversal",
                "content": "```\\ndef kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n        \\n        pos = 0\\n        ans = 0\\n        \\n        current = root\\n        \\n        while current and pos < k:\\n            \\n            if not current.left:\\n                pos += 1\\n                ans = current.val\\n                current = current.right\\n            \\n            else:\\n                pre = current.left\\n                while pre.right:\\n                    pre = pre.right\\n                \\n                pre.right = current\\n                left = current.left\\n                current.left = None\\n                current = left\\n        \\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\ndef kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n        \\n        pos = 0\\n        ans = 0\\n        \\n        current = root\\n        \\n        while current and pos < k:\\n            \\n            if not current.left:\\n                pos += 1\\n                ans = current.val\\n                current = current.right\\n            \\n            else:\\n                pre = current.left\\n                while pre.right:\\n                    pre = pre.right\\n                \\n                pre.right = current\\n                left = current.left\\n                current.left = None\\n                current = left\\n        \\n        return ans\\n\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1958785,
                "title": "java-inorder-explained",
                "content": "**Idea:** kth smallest element in a BST is the kth item in its inorder traversal because IOT of a BST gives the element in increasing order.\\n>**T/S:** O(h + k)/O(h), where h = height of BST\\n```\\npublic int kthSmallest(TreeNode root, int k) {\\n\\tvar kSmallest = new int[1];\\n\\tinorder(root, new int[]{k}, kSmallest);\\n\\treturn kSmallest[0];\\n}\\n\\nprivate void inorder(TreeNode root, int[] count, int[] kSmallest) {\\n\\tif (root == null || count[0] == 0)\\n\\t\\treturn;\\n\\t// recurse left\\n\\tinorder(root.left, count, kSmallest);\\n\\t// visit\\n\\tif (--count[0] == 0)\\n\\t\\tkSmallest[0] = root.val;\\n\\telse\\n\\t// recurse right\\n\\t\\tinorder(root.right, count, kSmallest);\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int kthSmallest(TreeNode root, int k) {\\n\\tvar kSmallest = new int[1];\\n\\tinorder(root, new int[]{k}, kSmallest);\\n\\treturn kSmallest[0];\\n}\\n\\nprivate void inorder(TreeNode root, int[] count, int[] kSmallest) {\\n\\tif (root == null || count[0] == 0)\\n\\t\\treturn;\\n\\t// recurse left\\n\\tinorder(root.left, count, kSmallest);\\n\\t// visit\\n\\tif (--count[0] == 0)\\n\\t\\tkSmallest[0] = root.val;\\n\\telse\\n\\t// recurse right\\n\\t\\tinorder(root.right, count, kSmallest);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1879096,
                "title": "c-inorder-solution-simple",
                "content": "```\\n    void inOrder(TreeNode* root)\\n    {\\n        if(!root)\\n            return ;\\n        inOrder(root->left);\\n        tree.push_back(root->val);\\n        inOrder(root->right);\\n        \\n    }\\n    \\n    int kthSmallest(TreeNode* root, int k) \\n    {\\n        inOrder(root);\\n        return tree[k-1];\\n    }\\n    \\nprivate:\\n    std::vector<int> tree;",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n    void inOrder(TreeNode* root)\\n    {\\n        if(!root)\\n            return ;\\n        inOrder(root->left);\\n        tree.push_back(root->val);\\n        inOrder(root->right);\\n        \\n    }\\n    \\n    int kthSmallest(TreeNode* root, int k) \\n    {\\n        inOrder(root);\\n        return tree[k-1];\\n    }\\n    \\nprivate:\\n    std::vector<int> tree;",
                "codeTag": "Unknown"
            },
            {
                "id": 1464509,
                "title": "c-recursive-approach-and-morris-traversal",
                "content": "**Please Upvote if you like!**\\n\\n# Recursive Approach:\\n    int solve(TreeNode *root,int &k)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int left=solve(root->left,k);\\n        if(left!=NULL)\\n            return left;\\n        k=k-1;\\n        if(k==0)\\n        {\\n            return root->val;\\n        }\\n        int right=solve(root->right,k);\\n        return right;\\n    }\\n    int kthSmallest(TreeNode* root, int k)\\n    {\\n        return solve(root,k);\\n    }\\n\\t\\n# \\t**Morris Traversal:**\\n    class Solution {\\n    public:\\n    int solve(TreeNode *root,int &k)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int count=0;int res=0;\\n        TreeNode *curr=root;\\n        \\n        while(curr)\\n        {\\n            if(curr->left==NULL)\\n            {\\n                count++;\\n                if(count==k)\\n                    res=curr->val;\\n                curr=curr->right;\\n            }\\n            else\\n            {\\n                TreeNode*prev=curr->left;\\n                while(prev->right && prev->right!=curr)\\n                {\\n                    prev=prev->right;\\n                }\\n                if(prev->right==NULL)\\n                {\\n                    prev->right=curr;\\n                    curr=curr->left;\\n                }\\n                else\\n                {\\n                    prev->right=NULL;\\n                    count++;\\n                    if(count==k)\\n                        res= curr->val;\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n    int kthSmallest(TreeNode* root, int k)\\n    {\\n        return solve(root,k);\\n    }\\n    };",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "class Solution {\\n    public:\\n    int solve(TreeNode *root,int &k)\\n    {\\n        if(root==NULL)\\n            return 0;\\n        int count=0;int res=0;\\n        TreeNode *curr=root;\\n        \\n        while(curr)\\n        {\\n            if(curr->left==NULL)\\n            {\\n                count++;\\n                if(count==k)\\n                    res=curr->val;\\n                curr=curr->right;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 915895,
                "title": "two-js-solutions",
                "content": "```\\n/*\\n1. Inorder traversal of BST represents the numbers in ascending order.\\n2. Get the kth element in the inorder traversal.\\n*/\\nvar kthSmallest = function(root, k) {\\n    let res = [];\\n    dfs(root, res);\\n    return res[k - 1];\\n\\t// T.C: O(N)\\n\\t// S.C: O(N)\\n};\\n\\nconst dfs = (root, res) => {\\n    if (!root) {\\n        return;\\n    }\\n    dfs(root.left, res);\\n    res.push(root.val);\\n    dfs(root.right, res);\\n}\\n```\\n\\n```\\nvar kthSmallest = function(root, k) {\\n    let res = null;\\n    dfs(root);\\n    return res;\\n    // T.C: O(H + K)\\n    // S.C: O(H)\\n    function dfs(root) {\\n        if (!root) {\\n            return;\\n        }\\n        dfs(root.left);\\n        if (res) {\\n            return;\\n        }\\n        k--; // a node is visited\\n        if (k === 0) {\\n            res = root.val;\\n            return;\\n        }\\n        dfs(root.right);\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/*\\n1. Inorder traversal of BST represents the numbers in ascending order.\\n2. Get the kth element in the inorder traversal.\\n*/\\nvar kthSmallest = function(root, k) {\\n    let res = [];\\n    dfs(root, res);\\n    return res[k - 1];\\n\\t// T.C: O(N)\\n\\t// S.C: O(N)\\n};\\n\\nconst dfs = (root, res) => {\\n    if (!root) {\\n        return;\\n    }\\n    dfs(root.left, res);\\n    res.push(root.val);\\n    dfs(root.right, res);\\n}\\n```\n```\\nvar kthSmallest = function(root, k) {\\n    let res = null;\\n    dfs(root);\\n    return res;\\n    // T.C: O(H + K)\\n    // S.C: O(H)\\n    function dfs(root) {\\n        if (!root) {\\n            return;\\n        }\\n        dfs(root.left);\\n        if (res) {\\n            return;\\n        }\\n        k--; // a node is visited\\n        if (k === 0) {\\n            res = root.val;\\n            return;\\n        }\\n        dfs(root.right);\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 541193,
                "title": "java-solution-for-the-follow-up",
                "content": "The idea is simple, keep a count of number of smaller nodes in the current node, and divide and conquer when query.\\n```\\n    public int kthSmallest(TreeNode root, int k) {\\n        Node node = buildTree(root);\\n        return findKth(node, k);\\n    }\\n    \\n    private int findKth(Node node, int k) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.count < k - 1) {\\n            return findKth(node.right, k - node.count - 1);\\n        } else if (node.count > k - 1) {\\n            return findKth(node.left, k);\\n        }\\n        return node.val;\\n    }\\n    \\n    private Node buildTree(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        Node node = new Node(root.val);\\n        \\n        int count = dfs(root.left);\\n        node.count = count;\\n        \\n        node.left = buildTree(root.left);\\n        node.right = buildTree(root.right);\\n        return node;\\n    }\\n    \\n    private int dfs(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        return dfs(root.left) + dfs(root.right) + 1;\\n    }\\n    \\n    class Node {\\n        Node left;\\n        Node right;\\n        int val;\\n        int count;\\n        Node (int val) {\\n            this.val = val;\\n        }\\n    }",
                "solutionTags": [],
                "code": "The idea is simple, keep a count of number of smaller nodes in the current node, and divide and conquer when query.\\n```\\n    public int kthSmallest(TreeNode root, int k) {\\n        Node node = buildTree(root);\\n        return findKth(node, k);\\n    }\\n    \\n    private int findKth(Node node, int k) {\\n        if (node == null) {\\n            return -1;\\n        }\\n        if (node.count < k - 1) {\\n            return findKth(node.right, k - node.count - 1);\\n        } else if (node.count > k - 1) {\\n            return findKth(node.left, k);\\n        }\\n        return node.val;\\n    }\\n    \\n    private Node buildTree(TreeNode root) {\\n        if (root == null) {\\n            return null;\\n        }\\n        Node node = new Node(root.val);\\n        \\n        int count = dfs(root.left);\\n        node.count = count;\\n        \\n        node.left = buildTree(root.left);\\n        node.right = buildTree(root.right);\\n        return node;\\n    }\\n    \\n    private int dfs(TreeNode root) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        return dfs(root.left) + dfs(root.right) + 1;\\n    }\\n    \\n    class Node {\\n        Node left;\\n        Node right;\\n        int val;\\n        int count;\\n        Node (int val) {\\n            this.val = val;\\n        }\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 63892,
                "title": "python-with-generators",
                "content": "    def iterate_tree(root):\\n        # inorder tree traversal generator\\n        if root.left:\\n            for i in iterate_tree(root.left):\\n                yield i\\n        yield root\\n        if root.right:\\n            for i in iterate_tree(root.right):\\n                yield i\\n    \\n    class Solution(object):\\n        def kthSmallest(self, root, k):\\n            # iterate over tree\\n            for p, v in enumerate(iterate_tree(root)):\\n                if p+1 == k:\\n                    return v.val",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def iterate_tree(root):\\n        # inorder tree traversal generator\\n        if root.left:\\n            for i in iterate_tree(root.left):\\n                yield i\\n        yield root\\n        if root.right:\\n            for i in iterate_tree(root.right):\\n                yield i\\n    \\n    class Solution(object):\\n        def kthSmallest(self, root, k):\\n            # iterate over tree\\n            for p, v in enumerate(iterate_tree(root)):\\n                if p+1 == k:\\n                    return v.val",
                "codeTag": "Java"
            },
            {
                "id": 63948,
                "title": "exceptional-python",
                "content": "To return a value from deep down... raise it :-)\\n\\n    def kthSmallest(self, root, k):\\n        def inorder(root, k):\\n            if root:\\n                k = inorder(root.left, k)\\n                if k == 1:\\n                    raise Exception(root.val)\\n                k = inorder(root.right, k-1)\\n            return k\\n        try:\\n            inorder(root, k)\\n        except Exception as e:\\n            return e.message",
                "solutionTags": [
                    "Python"
                ],
                "code": "To return a value from deep down... raise it :-)\\n\\n    def kthSmallest(self, root, k):\\n        def inorder(root, k):\\n            if root:\\n                k = inorder(root.left, k)\\n                if k == 1:\\n                    raise Exception(root.val)\\n                k = inorder(root.right, k-1)\\n            return k\\n        try:\\n            inorder(root, k)\\n        except Exception as e:\\n            return e.message",
                "codeTag": "Python3"
            },
            {
                "id": 3271483,
                "title": "best-o-n-solution",
                "content": "# Approach 1\\nPreorder Traversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$ \\n\\n- Space complexity:\\n$$O(n)$$ \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        vector <int> nodes;\\n        traversal(root, nodes);\\n        sort(nodes.begin(), nodes.end());\\n        return nodes[k-1];\\n    }\\n\\n    void traversal(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL)\\n            return;\\n        nodes.push_back(root->val);\\n        traversal(root->left, nodes);\\n        traversal(root->right, nodes);    \\n    }\\n};\\n```\\n\\n# Approach 2\\nInorder Traversal\\n\\n# Complexity\\n- Time complexity:\\n$$O(h)$$ --> h is height of the BST \\n\\n- Space complexity:\\n$$O(h)$$ --> h is height of the BST \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        TreeNode* kthSmallest = traversal(root, k);\\n        return kthSmallest->val;\\n    }\\n\\n    TreeNode* traversal(TreeNode* root, int& k) {\\n        if (root == NULL)\\n            return NULL;\\n        TreeNode* left = traversal(root->left, k);\\n        if (left != NULL)\\n            return left;\\n        k--;    \\n        if (k == 0)\\n            return root;\\n        return traversal(root->right, k);    \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        vector <int> nodes;\\n        traversal(root, nodes);\\n        sort(nodes.begin(), nodes.end());\\n        return nodes[k-1];\\n    }\\n\\n    void traversal(TreeNode* root, vector <int>& nodes) {\\n        if (root == NULL)\\n            return;\\n        nodes.push_back(root->val);\\n        traversal(root->left, nodes);\\n        traversal(root->right, nodes);    \\n    }\\n};\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        TreeNode* kthSmallest = traversal(root, k);\\n        return kthSmallest->val;\\n    }\\n\\n    TreeNode* traversal(TreeNode* root, int& k) {\\n        if (root == NULL)\\n            return NULL;\\n        TreeNode* left = traversal(root->left, k);\\n        if (left != NULL)\\n            return left;\\n        k--;    \\n        if (k == 0)\\n            return root;\\n        return traversal(root->right, k);    \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251944,
                "title": "simple-solution-easy-to-understand-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\uD83D\\uDC51 Let\\'s keep it simple and short.\\n\\nThe inorder traversal of a BST, will always be sorted if the tree is a valid BST. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nIf you think about the intution of this approach, it is simple, we just have to traverse the tree using Inorder and store elements, in an array, and after that we can return the k-1th element from that array, \\nor \\nwe can keep track of the element from smallest to largest, using an integer variable.\\n\\n# Complexity\\n- Time complexity: O(N) time for traversing the tree.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)+O(H)Aux;\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    // Simple inorder traversal.\\n    void inorder(TreeNode* root, vector<int>&res) {\\n        if(!root) return;\\n        inorder(root->left, res);\\n        res.push_back(root->val); // storing root\\'s val in res.\\n        inorder(root->right, res);\\n    }\\n\\n    int kthSmallest(TreeNode* root, int k) {\\n        vector<int> res;\\n        inorder(root, res);\\n\\n        return res[k-1]; // return k-1th element from res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search",
                    "Binary Indexed Tree",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    // Simple inorder traversal.\\n    void inorder(TreeNode* root, vector<int>&res) {\\n        if(!root) return;\\n        inorder(root->left, res);\\n        res.push_back(root->val); // storing root\\'s val in res.\\n        inorder(root->right, res);\\n    }\\n\\n    int kthSmallest(TreeNode* root, int k) {\\n        vector<int> res;\\n        inorder(root, res);\\n\\n        return res[k-1]; // return k-1th element from res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3204789,
                "title": "simple-and-clean-code-using-inorder-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst convert tree into a sorted array and return the kth element.\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBy using inorder traversal convert Tree into an array and since it is a BST ,the array is already sorted.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int>v;\\n    void inorder(TreeNode* root){\\n        if(root==NULL)return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        inorder(root);\\n        return v[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>v;\\n    void inorder(TreeNode* root){\\n        if(root==NULL)return;\\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        inorder(root);\\n        return v[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2748089,
                "title": "java-easiest-iterative-solution-using-stack",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int kthSmallest(TreeNode root, int k) {\\n       Stack<TreeNode> st = new Stack<>();\\n       TreeNode p = root;\\n       int count = 0;\\n\\n       while(!st.isEmpty() || p != null) {\\n           if(p != null) {\\n           st.push(p);\\n           p = p.left;\\n           }\\n           else {\\n               TreeNode node = st.pop();\\n               if(++ count == k) return node.val;\\n               p = node.right;\\n           }\\n       } \\n       return Integer.MIN_VALUE;\\n    }\\n}\\n```\\n# PLEASE UPVOTE IF IT WAS HELPFULL",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int kthSmallest(TreeNode root, int k) {\\n       Stack<TreeNode> st = new Stack<>();\\n       TreeNode p = root;\\n       int count = 0;\\n\\n       while(!st.isEmpty() || p != null) {\\n           if(p != null) {\\n           st.push(p);\\n           p = p.left;\\n           }\\n           else {\\n               TreeNode node = st.pop();\\n               if(++ count == k) return node.val;\\n               p = node.right;\\n           }\\n       } \\n       return Integer.MIN_VALUE;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2647785,
                "title": "iterative-solution-easiest-faster-than-95-solutions",
                "content": "```\\nclass Solution:\\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n        n=0\\n        stack=[]\\n        cur=root\\n        while cur or stack :\\n            while cur :\\n                stack.append(cur)\\n                cur=cur.left\\n            cur=stack.pop()\\n            n +=1\\n            if n==k :\\n                return cur.val\\n            cur = cur.right\\n```\\nDo upvote if its helpful,Thanks.",
                "solutionTags": [
                    "Python",
                    "Stack"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n        n=0\\n        stack=[]\\n        cur=root\\n        while cur or stack :\\n            while cur :\\n                stack.append(cur)\\n                cur=cur.left\\n            cur=stack.pop()\\n            n +=1\\n            if n==k :\\n                return cur.val\\n            cur = cur.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2500546,
                "title": "easy-c-recursive-inorder-fast",
                "content": "#### If you like the solution please upvote\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint kthSmallest(TreeNode* root, int &k) {\\n\\t\\t\\tif(root == NULL)\\n\\t\\t\\t\\treturn -1;\\n\\n\\t\\t\\tint val = kthSmallest(root->left, k);\\n\\t\\t\\tk--;\\n\\t\\t\\tif(k == 0)\\n\\t\\t\\t\\treturn root->val;\\n\\t\\t\\telse if(k < 0)\\n\\t\\t\\t\\treturn val;\\n\\n\\t\\t\\treturn kthSmallest(root->right, k);\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint kthSmallest(TreeNode* root, int &k) {\\n\\t\\t\\tif(root == NULL)\\n\\t\\t\\t\\treturn -1;\\n\\n\\t\\t\\tint val = kthSmallest(root->left, k);\\n\\t\\t\\tk--;\\n\\t\\t\\tif(k == 0)\\n\\t\\t\\t\\treturn root->val;\\n\\t\\t\\telse if(k < 0)\\n\\t\\t\\t\\treturn val;\\n\\n\\t\\t\\treturn kthSmallest(root->right, k);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1960604,
                "title": "c-inorder-traversal-using-recursion-with-example",
                "content": "## **Approach:** \\n1. First call recursion on the left subtree.\\n2. Then increment the count by 1 (storing the position of that element when arranged in increasing order)\\n3. If the count is equal to k, then we return that value. Else we recurse the right subtree.\\n\\n* If we come across a null node, return -1 so that we can differentiate the node values from null.\\n* After traversing the left subtree, check whether the returned value is unequal to k. If yes, return the value. Else, traverse the right side.\\n\\n## **Example**\\nFor a BST: [5,3,6,2,4,null,null,1] and k=4 the traversal would look like the following:\\n![image](https://assets.leetcode.com/users/images/b17130b9-567a-423f-adbb-e7578190848d_1650283426.9845426.png)\\n\\n## **Code**\\n```\\nclass Solution {\\npublic:\\n    int c=0;\\n    int kthSmallest(TreeNode* root, int k) {\\n        if(!root)return -1;\\n        int p=kthSmallest(root->left,k);\\n        if(p!=-1)return p;\\n        ++c;\\n        if(c==k) return root->val;\\n        return kthSmallest(root->right,k);\\n    }\\n};\\n```\\n**Time Complexity:** O(n) in worst case as we will traverse all the nodes once.\\n**Space Complexity:** O(n) due the recursive stack.\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int c=0;\\n    int kthSmallest(TreeNode* root, int k) {\\n        if(!root)return -1;\\n        int p=kthSmallest(root->left,k);\\n        if(p!=-1)return p;\\n        ++c;\\n        if(c==k) return root->val;\\n        return kthSmallest(root->right,k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959388,
                "title": "c-easiest-inorder-traversal-3-line-solution-not-any-extra-function",
                "content": "/*we have to find kth smallest value so using inorder traversal and also decreasing k when k=0 it means we are at right node which value will be kth smallest element ,that\\'s i used an int variable ans to store the val ...int k argument is reference argument so after  recursive call back the value of k will not  not same as it was when the function was called */\\n```\\nclass Solution {\\n   \\npublic:\\n    int ans;\\n    int kthSmallest(TreeNode* root, int &k) {\\n        if(root){\\n            kthSmallest(root->left,k);\\n            k--;\\n            if(k==0) ans=root->val;\\n            kthSmallest(root->right,k);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n   \\npublic:\\n    int ans;\\n    int kthSmallest(TreeNode* root, int &k) {\\n        if(root){\\n            kthSmallest(root->left,k);\\n            k--;\\n            if(k==0) ans=root->val;\\n            kthSmallest(root->right,k);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1706014,
                "title": "c-inorder-traversal-o-h-k-time-o-h-space",
                "content": "![image](https://assets.leetcode.com/users/images/34b55559-6599-4b80-b99c-8302def9e8e8_1642899779.1937017.jpeg)\\nSimple c++ inorder traversal with O(h+k) time and with no other extra space than call stacks ( O(h) )\\n ----------------------------------------------------------here is the code below----------------------------------------------------------\\n \\n```\\n\\nclass Solution {\\nprivate: \\n    vector<int> res;\\n    int cnt=0;\\n    int ans = -1;\\n    void solve(TreeNode* root, int &k)\\n    {\\n        if(!root) return;\\n        if(cnt==k) return;\\n        solve(root->left,k);\\n        if(cnt<k)\\n        {\\n           ans = root->val;\\n            cnt++;\\n        }\\n        solve(root->right,k); \\n    }\\n\\t\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        //if(!root) return -1;\\n        solve(root, k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\nprivate: \\n    vector<int> res;\\n    int cnt=0;\\n    int ans = -1;\\n    void solve(TreeNode* root, int &k)\\n    {\\n        if(!root) return;\\n        if(cnt==k) return;\\n        solve(root->left,k);\\n        if(cnt<k)\\n        {\\n           ans = root->val;\\n            cnt++;\\n        }\\n        solve(root->right,k); \\n    }\\n\\t\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        //if(!root) return -1;\\n        solve(root, k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1601343,
                "title": "c-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic: \\n    void inord(TreeNode*root,int &k,int &ans){\\n        if(root==NULL)\\n            return;\\n        inord(root->left,k,ans);\\n        k--;\\n        if(k==0){\\n            ans=root->val;\\n            \\n        }\\n        inord(root->right,k,ans);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n       int ans=-1;\\n        inord(root,k,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic: \\n    void inord(TreeNode*root,int &k,int &ans){\\n        if(root==NULL)\\n            return;\\n        inord(root->left,k,ans);\\n        k--;\\n        if(k==0){\\n            ans=root->val;\\n            \\n        }\\n        inord(root->right,k,ans);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n       int ans=-1;\\n        inord(root,k,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 641848,
                "title": "rust-o-h-k-minimalist-iterative-solution-with-explanations-0ms-faster-than-100",
                "content": "```rust\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\n\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn kth_smallest(mut node_opt: Option<Rc<RefCell<TreeNode>>>, mut k: i32) -> i32 {\\n        let mut nodes = Vec::new();\\n        while node_opt.is_some() || !nodes.is_empty() {\\n            // Go to the smallest (i.e. left-most) node:\\n            while let Some(node) = node_opt {\\n                nodes.push(node.clone());\\n                node_opt = node.borrow().left.clone();\\n            }\\n            if let Some(node) = nodes.pop() { // nodes contains Rc<RefCell<TreeNode>>s but pop returns Option<T>.\\n                // Check the current smallest node:\\n                k -= 1;\\n                if k == 0 {\\n                    return node.borrow().val;\\n                }\\n                // Check the right sub-tree:\\n                node_opt = node.borrow().right.clone();    \\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Iterator"
                ],
                "code": "```rust\\n// Definition for a binary tree node.\\n// #[derive(Debug, PartialEq, Eq)]\\n// pub struct TreeNode {\\n//   pub val: i32,\\n//   pub left: Option<Rc<RefCell<TreeNode>>>,\\n//   pub right: Option<Rc<RefCell<TreeNode>>>,\\n// }\\n// \\n// impl TreeNode {\\n//   #[inline]\\n//   pub fn new(val: i32) -> Self {\\n//     TreeNode {\\n//       val,\\n//       left: None,\\n//       right: None\\n//     }\\n//   }\\n// }\\n\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\n\\nimpl Solution {\\n    pub fn kth_smallest(mut node_opt: Option<Rc<RefCell<TreeNode>>>, mut k: i32) -> i32 {\\n        let mut nodes = Vec::new();\\n        while node_opt.is_some() || !nodes.is_empty() {\\n            // Go to the smallest (i.e. left-most) node:\\n            while let Some(node) = node_opt {\\n                nodes.push(node.clone());\\n                node_opt = node.borrow().left.clone();\\n            }\\n            if let Some(node) = nodes.pop() { // nodes contains Rc<RefCell<TreeNode>>s but pop returns Option<T>.\\n                // Check the current smallest node:\\n                k -= 1;\\n                if k == 0 {\\n                    return node.borrow().val;\\n                }\\n                // Check the right sub-tree:\\n                node_opt = node.borrow().right.clone();    \\n            }\\n        }\\n        unreachable!();\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 350326,
                "title": "scala-solution-with-recursion",
                "content": "Perform an in order traversal of the tree the kth item we encounter is the value to return.\\n```\\n  object Solution {\\n    def kthSmallest(root: TreeNode, k: Int): Int = {\\n      def inOrderTraversal(root: TreeNode, count: Int): (Int, Option[Int]) = {\\n        if (root == null) (count, None)\\n        else {\\n          inOrderTraversal(root.left, count) match {\\n            case (_, Some(solution: Int)) =>\\n              (0, Some(solution))\\n            case (countRemaining: Int, None) if countRemaining == 1 =>\\n              (0, Some(root.value))\\n            case (countRemaining: Int, None) =>\\n              inOrderTraversal(root.right, countRemaining - 1)\\n          }\\n        }\\n      }\\n\\n      inOrderTraversal(root, k)._2.get\\n    }\\n  }\\n````",
                "solutionTags": [
                    "Scala",
                    "Recursion"
                ],
                "code": "```\\n  object Solution {\\n    def kthSmallest(root: TreeNode, k: Int): Int = {\\n      def inOrderTraversal(root: TreeNode, count: Int): (Int, Option[Int]) = {\\n        if (root == null) (count, None)\\n        else {\\n          inOrderTraversal(root.left, count) match {\\n            case (_, Some(solution: Int)) =>\\n              (0, Some(solution))\\n            case (countRemaining: Int, None) if countRemaining == 1 =>\\n              (0, Some(root.value))\\n            case (countRemaining: Int, None) =>\\n              inOrderTraversal(root.right, countRemaining - 1)\\n          }\\n        }\\n      }\\n\\n      inOrderTraversal(root, k)._2.get\\n    }\\n  }\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 210432,
                "title": "javascript",
                "content": "```\\nvar kthSmallest = function(root, k) {\\n    let array = []\\n    dfs(root)\\n    return array[k - 1]\\n    \\n    function dfs(root){\\n        if(!root){\\n            return\\n        }\\n        dfs(root.left)\\n        array.push(root.val)\\n        dfs(root.right)\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar kthSmallest = function(root, k) {\\n    let array = []\\n    dfs(root)\\n    return array[k - 1]\\n    \\n    function dfs(root){\\n        if(!root){\\n            return\\n        }\\n        dfs(root.left)\\n        array.push(root.val)\\n        dfs(root.right)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 196359,
                "title": "c-with-recursion",
                "content": "```\\npublic class Solution {\\n  public int KthSmallest(TreeNode root, int k) {\\n\\n    IEnumerable<int> traverse(TreeNode r) {\\n      if (r != null) {\\n        foreach(var n in traverse(r.left)) yield return n;\\n        yield return r.val;\\n        foreach(var n in traverse(r.right)) yield return n;\\n      }\\n    }\\n    \\n    return traverse(root).ElementAt(k-1);\\n    \\n  }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n  public int KthSmallest(TreeNode root, int k) {\\n\\n    IEnumerable<int> traverse(TreeNode r) {\\n      if (r != null) {\\n        foreach(var n in traverse(r.left)) yield return n;\\n        yield return r.val;\\n        foreach(var n in traverse(r.right)) yield return n;\\n      }\\n    }\\n    \\n    return traverse(root).ElementAt(k-1);\\n    \\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 166699,
                "title": "python-solution",
                "content": "Inorder traversal:\\n```\\nclass Solution(object):\\n    def kthSmallest(self, root, k):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        stack = []\\n        trav = root\\n        count = 0\\n        while trav or stack:\\n            if trav:\\n                stack.append(trav)\\n                trav = trav.left\\n            else:\\n                u = stack.pop()\\n                count += 1\\n                if count == k:\\n                    return u.val\\n                trav = u.right\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def kthSmallest(self, root, k):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        stack = []\\n        trav = root\\n        count = 0\\n        while trav or stack:\\n            if trav:\\n                stack.append(trav)\\n                trav = trav.left\\n            else:\\n                u = stack.pop()\\n                count += 1\\n                if count == k:\\n                    return u.val\\n                trav = u.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63771,
                "title": "recursive-inorder-travel-solution",
                "content": "    // recursive inorder travel \\n    int kthSmallest(TreeNode* root, int k) {\\n        int iRet = 0;\\n        dfs(root, iRet, k);\\n        return iRet;\\n    }\\n    \\n    void dfs(TreeNode *root, int &iRet, int &k) {\\n        if (!root || k <= 0) return;\\n        \\n        dfs(root->left, iRet, k);\\n        \\n        if (k <= 0) return;\\n        --k;\\n        if (k == 0) { iRet = root->val; return;}\\n        \\n        dfs(root->right, iRet, k);\\n    }",
                "solutionTags": [],
                "code": "    // recursive inorder travel \\n    int kthSmallest(TreeNode* root, int k) {\\n        int iRet = 0;\\n        dfs(root, iRet, k);\\n        return iRet;\\n    }\\n    \\n    void dfs(TreeNode *root, int &iRet, int &k) {\\n        if (!root || k <= 0) return;\\n        \\n        dfs(root->left, iRet, k);\\n        \\n        if (k <= 0) return;\\n        --k;\\n        if (k == 0) { iRet = root->val; return;}\\n        \\n        dfs(root->right, iRet, k);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 3972736,
                "title": "2-best-c-solutions-recursive-iterative-and-morris-inorder-traversal-beats-100",
                "content": "# Code\\n```\\n// Inorder iterative solution\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        stack<TreeNode*> s;\\n\\n        while(!s.empty() || root != NULL){\\n            while(root != NULL){\\n                s.push(root);\\n                root = root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n            if(--k == 0)\\n                break;\\n            root = root->right;\\n        }\\n        return root->val;\\n    }\\n};\\n\\n// Inorder Recursive solution\\nclass Solution{\\npublic:\\n    void inorder(TreeNode *root, int &k, int &ans){\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root->left, k, ans);\\n        if(--k == 0)\\n            ans = root->val;\\n        inorder(root->right, k, ans);\\n    }\\n    \\n    int kthSmallest(TreeNode *root, int k){\\n        int ans = 0;\\n        inorder(root, k, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n// Inorder iterative solution\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        stack<TreeNode*> s;\\n\\n        while(!s.empty() || root != NULL){\\n            while(root != NULL){\\n                s.push(root);\\n                root = root->left;\\n            }\\n            root = s.top();\\n            s.pop();\\n            if(--k == 0)\\n                break;\\n            root = root->right;\\n        }\\n        return root->val;\\n    }\\n};\\n\\n// Inorder Recursive solution\\nclass Solution{\\npublic:\\n    void inorder(TreeNode *root, int &k, int &ans){\\n        if(root == NULL)\\n            return;\\n        \\n        inorder(root->left, k, ans);\\n        if(--k == 0)\\n            ans = root->val;\\n        inorder(root->right, k, ans);\\n    }\\n    \\n    int kthSmallest(TreeNode *root, int k){\\n        int ans = 0;\\n        inorder(root, k, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3619030,
                "title": "by-morris-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int kthSmallest(TreeNode root, int k) {\\n        int i=0;\\n        TreeNode curr=root;\\n        while(curr!=null){\\n          if(curr.left==null){\\n            i++;\\n            if(i==k)\\n              return curr.val;\\n            curr=curr.right;\\n          }\\n          else{\\n            TreeNode pre=find(curr);\\n            if(pre.right==null){\\n              pre.right=curr;\\n              curr=curr.left;\\n            }\\n            else{\\n              pre.right=null;\\n              i++;\\n              if(i==k)\\n                return curr.val;\\n              curr=curr.right;\\n            }\\n          }\\n        }\\n        return -1;\\n\\n    }\\n    public TreeNode find(TreeNode root){\\n      TreeNode curr=root.left;\\n      while(curr.right!=null && curr.right!=root)\\n         curr=curr.right;\\n        return curr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int kthSmallest(TreeNode root, int k) {\\n        int i=0;\\n        TreeNode curr=root;\\n        while(curr!=null){\\n          if(curr.left==null){\\n            i++;\\n            if(i==k)\\n              return curr.val;\\n            curr=curr.right;\\n          }\\n          else{\\n            TreeNode pre=find(curr);\\n            if(pre.right==null){\\n              pre.right=curr;\\n              curr=curr.left;\\n            }\\n            else{\\n              pre.right=null;\\n              i++;\\n              if(i==k)\\n                return curr.val;\\n              curr=curr.right;\\n            }\\n          }\\n        }\\n        return -1;\\n\\n    }\\n    public TreeNode find(TreeNode root){\\n      TreeNode curr=root.left;\\n      while(curr.right!=null && curr.right!=root)\\n         curr=curr.right;\\n        return curr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3606533,
                "title": "python-recursion-without-stack-easy",
                "content": "```\\nclass Solution:\\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n        def inorder(root):\\n            nonlocal k\\n            if root==None:\\n                return None\\n            left=inorder(root.left)\\n            if left!=None:\\n                return left\\n            k-=1\\n            if k==0:\\n                return root.val\\n            return inorder(root.right)\\n        return inorder(root)\\n```\\n**An upvote will be encouraging**",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n        def inorder(root):\\n            nonlocal k\\n            if root==None:\\n                return None\\n            left=inorder(root.left)\\n            if left!=None:\\n                return left\\n            k-=1\\n            if k==0:\\n                return root.val\\n            return inorder(root.right)\\n        return inorder(root)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3279033,
                "title": "easy-to-understand-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>v;\\nvoid pp(TreeNode* toot){\\n    if(toot==NULL){\\n        return;\\n    }\\n    pp(toot->left);\\n    v.push_back(toot->val);\\n    pp(toot->right);\\n}\\n    int kthSmallest(TreeNode* root, int k) {\\n       pp(root);\\n        return v[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\nvector<int>v;\\nvoid pp(TreeNode* toot){\\n    if(toot==NULL){\\n        return;\\n    }\\n    pp(toot->left);\\n    v.push_back(toot->val);\\n    pp(toot->right);\\n}\\n    int kthSmallest(TreeNode* root, int k) {\\n       pp(root);\\n        return v[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084920,
                "title": "0ms-100-faster-java-very-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int ans=0;\\n    int count=0;\\n    public int kthSmallest(TreeNode root, int k) {\\n        inOrder(root,k);\\n        return ans;\\n         \\n         //2nd approach------------(2ms)\\n\\n        // List<Integer>ar=new ArrayList<>();\\n        //inOrder(root,ar);        \\n        // return ar.get(k-1);\\n        \\n    }\\n    //2nd approach--------------(2ms)\\n\\n    // public void inOrder(TreeNode root,List<Integer>ar){\\n    //     if(root==null) return;\\n\\n    //     inOrder(root.left,ar);\\n    //     ar.add(root.val);\\n    //     inOrder(root.right,ar);\\n\\n    // }\\n    public void inOrder(TreeNode root,int k){\\n        if(root==null) return;\\n        \\n        inOrder(root.left,k);\\n        count++;\\n        if(count==k){\\n            ans=root.val;\\n            return;\\n        }\\n        inOrder(root.right,k);\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int ans=0;\\n    int count=0;\\n    public int kthSmallest(TreeNode root, int k) {\\n        inOrder(root,k);\\n        return ans;\\n         \\n         //2nd approach------------(2ms)\\n\\n        // List<Integer>ar=new ArrayList<>();\\n        //inOrder(root,ar);        \\n        // return ar.get(k-1);\\n        \\n    }\\n    //2nd approach--------------(2ms)\\n\\n    // public void inOrder(TreeNode root,List<Integer>ar){\\n    //     if(root==null) return;\\n\\n    //     inOrder(root.left,ar);\\n    //     ar.add(root.val);\\n    //     inOrder(root.right,ar);\\n\\n    // }\\n    public void inOrder(TreeNode root,int k){\\n        if(root==null) return;\\n        \\n        inOrder(root.left,k);\\n        count++;\\n        if(count==k){\\n            ans=root.val;\\n            return;\\n        }\\n        inOrder(root.right,k);\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3021415,
                "title": "c-inorder-traverse-tree-using-ienumerable",
                "content": "# Intuition\\nUse DFS and traverse BST inorder. \\n\\n# Approach\\nThe idea is to use one of key features of IEnumerable, namely Lazy Evaluation. The app should NOT enumerate through all collection and only traverses first K element(s). This should improve performance in contrast with approaches that uses List or Array structures.\\n\\nThis solution beats 99% (89 ms) execution time. Memory usage 42.8 MB (beats 10%).\\n\\n# Complexity\\n- Time complexity: O(k)\\n\\n- Space complexity: O(k) but I\\'m not sure.\\n\\n# Code\\n```\\npublic class Solution {\\n    public int KthSmallest(TreeNode root, int k) {\\n\\n        return Inorder(root).Skip(k-1).Take(1).First();\\n\\n        IEnumerable<int> Inorder(TreeNode node){\\n            if (node is not null){\\n                foreach(var n in Inorder(node.left)){\\n                    yield return n;\\n                }\\n                // Trace.WriteLine(node.val); // Output: 1, 2, .. k\\n                yield return node.val;\\n                foreach(var n in Inorder(node.right)){\\n                    yield return n;\\n                }\\n            }\\n\\n\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int KthSmallest(TreeNode root, int k) {\\n\\n        return Inorder(root).Skip(k-1).Take(1).First();\\n\\n        IEnumerable<int> Inorder(TreeNode node){\\n            if (node is not null){\\n                foreach(var n in Inorder(node.left)){\\n                    yield return n;\\n                }\\n                // Trace.WriteLine(node.val); // Output: 1, 2, .. k\\n                yield return node.val;\\n                foreach(var n in Inorder(node.right)){\\n                    yield return n;\\n                }\\n            }\\n\\n\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2178499,
                "title": "easy-recursive-and-iterative-python-solutions",
                "content": "**Iterative Solution:**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n        \\n        \\n        n = 0\\n        stack = []\\n        curr = root\\n        \\n        while curr or stack:\\n            \\n            while curr:\\n                stack.append(curr)\\n                curr = curr.left\\n            \\n            curr = stack.pop()\\n            n += 1\\n            if n == k:\\n                return curr.val\\n            curr = curr.right\\n            \\n```\\n**Recursive Solution:**\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n\\t\\n        self.inorder = []\\n        \\n        def inorder(root):\\n            if not root: return\\n            inorder(root.left)\\n            self.inorder.append(root.val)\\n            inorder(root.right)\\n            \\n        inorder(root)\\n        \\n        return self.inorder[k-1]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n        \\n        \\n        n = 0\\n        stack = []\\n        curr = root\\n        \\n        while curr or stack:\\n            \\n            while curr:\\n                stack.append(curr)\\n                curr = curr.left\\n            \\n            curr = stack.pop()\\n            n += 1\\n            if n == k:\\n                return curr.val\\n            curr = curr.right\\n            \\n```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n\\t\\n        self.inorder = []\\n        \\n        def inorder(root):\\n            if not root: return\\n            inorder(root.left)\\n            self.inorder.append(root.val)\\n            inorder(root.right)\\n            \\n        inorder(root)\\n        \\n        return self.inorder[k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1960099,
                "title": "python-inorder-traversal-explained",
                "content": "Just do inorder traversal with stack (see problem **94**). Then we have complexity `O(h + k)`, where `h` is the height of tree. If we want to do it a lot of times, we can keep number of all children for each node, which is `O(n)` memory, then we can have $O(h)$ complexity to find `k`-th element, using something like binary search.\\n\\n#### Complexity\\nTime complexity is `O(h + k)`, space complexity is `O(h)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def kthSmallest(self, root, k):\\n        stack, curr = [], root\\n        \\n        while stack or curr:\\n            while curr:\\n                stack.append(curr)\\n                curr = curr.left\\n            curr = stack.pop()\\n            \\n            if k == 1:\\n                return curr.val\\n            \\n            k -= 1\\n            curr = curr.right\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def kthSmallest(self, root, k):\\n        stack, curr = [], root\\n        \\n        while stack or curr:\\n            while curr:\\n                stack.append(curr)\\n                curr = curr.left\\n            curr = stack.pop()\\n            \\n            if k == 1:\\n                return curr.val\\n            \\n            k -= 1\\n            curr = curr.right\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1958846,
                "title": "python3-faster-than-98-65-and-memory-usage-less-than-99-08",
                "content": "\\t\\n\\tfrom typing import Generator\\n\\tclass Solution:\\n\\t\\tdef kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n\\t\\t\\tfor i, num in enumerate(self.helper(root),1):\\n\\t\\t\\t\\tif i == k: return num\\n\\n\\t\\tdef helper(self, root: Optional[TreeNode]) -> Generator:\\n\\t\\t\\tif root:\\n\\t\\t\\t\\tyield from self.helper(root.left)\\n\\t\\t\\t\\tyield root.val\\n\\t\\t\\t\\tyield from self.helper(root.right)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\t\\n\\tfrom typing import Generator\\n\\tclass Solution:\\n\\t\\tdef kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n\\t\\t\\tfor i, num in enumerate(self.helper(root),1):\\n\\t\\t\\t\\tif i == k: return num\\n\\n\\t\\tdef helper(self, root: Optional[TreeNode]) -> Generator:\\n\\t\\t\\tif root:\\n\\t\\t\\t\\tyield from self.helper(root.left)\\n\\t\\t\\t\\tyield root.val\\n\\t\\t\\t\\tyield from self.helper(root.right)",
                "codeTag": "Java"
            },
            {
                "id": 1872602,
                "title": "easy-c-sol-3-methods",
                "content": "**Inorder Traversal**\\n```\\nclass Solution {\\npublic:\\n    vector<int>a;\\n    void inorder(TreeNode*root)\\n    {\\n        if(root==nullptr)\\n            return;\\n        inorder(root->left);\\n        a.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        inorder(root);\\n        return a[k-1];\\n    }\\n};\\n```\\n**Min Heap**\\n```\\nclass Solution {\\n    priority_queue<int,vector<int>,greater<int>> ele;\\n    void getEle(TreeNode* root){\\n        if(root==nullptr) return;\\n        ele.push(root->val);\\n        getEle(root->left),getEle(root->right);\\n    }\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        getEle(root);\\n        while(k>1)  ele.pop(), --k;\\n        return ele.top();\\n    }\\n};\\n```\\n**Vector**\\n```\\nclass Solution {\\n    vector<int> ele;\\n    void getEle(TreeNode* root){\\n        if(root==nullptr) return;\\n        ele.push_back(root->val);\\n        getEle(root->left),getEle(root->right);\\n    }\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        getEle(root);\\n        sort(ele.begin(),ele.end());\\n        return ele[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>a;\\n    void inorder(TreeNode*root)\\n    {\\n        if(root==nullptr)\\n            return;\\n        inorder(root->left);\\n        a.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        inorder(root);\\n        return a[k-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\n    priority_queue<int,vector<int>,greater<int>> ele;\\n    void getEle(TreeNode* root){\\n        if(root==nullptr) return;\\n        ele.push(root->val);\\n        getEle(root->left),getEle(root->right);\\n    }\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        getEle(root);\\n        while(k>1)  ele.pop(), --k;\\n        return ele.top();\\n    }\\n};\\n```\n```\\nclass Solution {\\n    vector<int> ele;\\n    void getEle(TreeNode* root){\\n        if(root==nullptr) return;\\n        ele.push_back(root->val);\\n        getEle(root->left),getEle(root->right);\\n    }\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        getEle(root);\\n        sort(ele.begin(),ele.end());\\n        return ele[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588565,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int cnt=0,ans;\\n   void inorder(TreeNode * root,int k){\\n       if(!root)\\n           return;\\n     inorder(root->left,k);\\n        cnt++;\\n        if(cnt==k)\\n            ans= root->val;\\n   inorder(root->right,k);\\n            \\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n      inorder(root,k);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int cnt=0,ans;\\n   void inorder(TreeNode * root,int k){\\n       if(!root)\\n           return;\\n     inorder(root->left,k);\\n        cnt++;\\n        if(cnt==k)\\n            ans= root->val;\\n   inorder(root->right,k);\\n            \\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n      inorder(root,k);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1564195,
                "title": "c-easiest-solution-using-sorting",
                "content": "This solution made the question feel very easy. I don\\'t think it was meant to be solved like this, but still this solution is accepted and is fast.\\n\\n![image](https://assets.leetcode.com/users/images/fcf32e96-7cbc-47dd-bd62-0cae60f7c88c_1636271340.9211264.jpeg)\\n<br>\\n\\nSolution :-<br>\\n1) Iterate through the entire tree\\n2) Store all elements in an array or vector\\n3) Sort the vector\\n4) Return `[k - 1]` value of the sorted vector (since tree is <b>\"1-indexed\"</b>)\\n<br>\\n\\nCode :-\\n\\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, vector<int>& nums){\\n        if(!root)\\n            return;\\n        \\n        nums.push_back(root -> val);\\n        \\n        dfs(root -> left, nums);\\n        dfs(root -> right, nums);\\n    }\\n    \\n    int kthSmallest(TreeNode* root, int k) {\\n        vector<int> nums;\\n        \\n        dfs(root, nums);\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        return nums[k - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sorting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, vector<int>& nums){\\n        if(!root)\\n            return;\\n        \\n        nums.push_back(root -> val);\\n        \\n        dfs(root -> left, nums);\\n        dfs(root -> right, nums);\\n    }\\n    \\n    int kthSmallest(TreeNode* root, int k) {\\n        vector<int> nums;\\n        \\n        dfs(root, nums);\\n        \\n        sort(nums.begin(), nums.end());\\n        \\n        return nums[k - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1541891,
                "title": "c-inorder-without-helper-function-o-h-k-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int &k) {\\n        if(!root)\\n            return -1;\\n        \\n        int left = kthSmallest(root->left, k);\\n        if(left!=-1)\\n            return left;\\n        \\n        if(--k==0)\\n            return root->val;\\n        \\n        int right = kthSmallest(root->right, k);\\n        if(right!=-1)\\n            return right;\\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int &k) {\\n        if(!root)\\n            return -1;\\n        \\n        int left = kthSmallest(root->left, k);\\n        if(left!=-1)\\n            return left;\\n        \\n        if(--k==0)\\n            return root->val;\\n        \\n        int right = kthSmallest(root->right, k);\\n        if(right!=-1)\\n            return right;\\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1517757,
                "title": "java-easy-solution-0-ms-100",
                "content": "class Solution {\\n\\n\\n    int b=0;\\n    int a =0;\\n        public int kthSmallest(TreeNode root, int k) {\\n       return  helper(root,k);\\n    }\\n    \\n    public int helper(TreeNode root, int k){\\n        if(root==null){\\n            return 0;\\n        }\\n        \\n        helper(root.left,k);\\n        a++;\\n        if(k==a){\\n            b=root.val;\\n        }\\n        helper(root.right,k);\\n        return b;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "class Solution {\\n\\n\\n    int b=0;\\n    int a =0;\\n        public int kthSmallest(TreeNode root, int k) {\\n       return  helper(root,k);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 1199044,
                "title": "c-simple-easy-recursive-solution-95-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    void Smallestkth(TreeNode* root,int &k,int& ans)\\n    {\\n        if(root==NULL)\\n            return ;\\n        \\n        Smallestkth(root->left,k,ans);\\n        \\n        \\n        k--;\\n        if(k==0)\\n            ans=root->val;\\n        \\n        return Smallestkth(root->right,k,ans);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        int ans=-1;\\n        Smallestkth(root,k,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void Smallestkth(TreeNode* root,int &k,int& ans)\\n    {\\n        if(root==NULL)\\n            return ;\\n        \\n        Smallestkth(root->left,k,ans);\\n        \\n        \\n        k--;\\n        if(k==0)\\n            ans=root->val;\\n        \\n        return Smallestkth(root->right,k,ans);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        int ans=-1;\\n        Smallestkth(root,k,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 847115,
                "title": "morris-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n//method1: inorder traversal\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* node,vector<int> &v){\\n        if(node){\\n            inorder(node->left,v);\\n            v.push_back(node->val);\\n            inorder(node->right,v);\\n        }\\n    }\\n    \\n    int kthSmallest(TreeNode* root, int k) {\\n        vector<int> v;\\n        inorder(root,v);\\n        return v[k-1];\\n    }\\n};\\n```\\n\\n//method2: using Morris Traversal\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        TreeNode* curr=root,*pre;\\n        int ans;\\n        while(curr){\\n            if(curr->left==NULL){\\n                k--;\\n                if(k==0) ans=curr->val;\\n                curr=curr->right;\\n            }else{\\n                pre=curr->left;\\n                while(pre->right && pre->right!=curr) pre=pre->right;\\n                if(!pre->right){\\n                    //this indicates we have pointer to the root element from where we should continue the traversing, so for inorder we jump to this root element,\\n                    //& then traverse the right subtree from there.\\n                    //to leave the tree as we found, set right element to the NULL again & jumps to root(the current root, parent of the current subtree) & continue.\\n                    pre->right=curr;\\n                    curr=curr->left;\\n                }else{  //connecting rightmost element of the left subtree to current element, so we know where to continue when we finish with the \\n                    //left subtree, basically to maintain inorder.\\n                    //in inorder traversal after traversing all left elements root element should be traverse and then the rest of the right subtree elements.\\n                    //so for that in morris traversal we connect rightmost element to the root(of current subtree).\\n                    pre->right=NULL;\\n                    k--;\\n                    if(k==0) ans=curr->val;\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n\\n//method1: inorder traversal\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* node,vector<int> &v){\\n        if(node){\\n            inorder(node->left,v);\\n            v.push_back(node->val);\\n            inorder(node->right,v);\\n        }\\n    }\\n    \\n    int kthSmallest(TreeNode* root, int k) {\\n        vector<int> v;\\n        inorder(root,v);\\n        return v[k-1];\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        TreeNode* curr=root,*pre;\\n        int ans;\\n        while(curr){\\n            if(curr->left==NULL){\\n                k--;\\n                if(k==0) ans=curr->val;\\n                curr=curr->right;\\n            }else{\\n                pre=curr->left;\\n                while(pre->right && pre->right!=curr) pre=pre->right;\\n                if(!pre->right){\\n                    //this indicates we have pointer to the root element from where we should continue the traversing, so for inorder we jump to this root element,\\n                    //& then traverse the right subtree from there.\\n                    //to leave the tree as we found, set right element to the NULL again & jumps to root(the current root, parent of the current subtree) & continue.\\n                    pre->right=curr;\\n                    curr=curr->left;\\n                }else{  //connecting rightmost element of the left subtree to current element, so we know where to continue when we finish with the \\n                    //left subtree, basically to maintain inorder.\\n                    //in inorder traversal after traversing all left elements root element should be traverse and then the rest of the right subtree elements.\\n                    //so for that in morris traversal we connect rightmost element to the root(of current subtree).\\n                    pre->right=NULL;\\n                    k--;\\n                    if(k==0) ans=curr->val;\\n                    curr=curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 836338,
                "title": "c-faster-than-99-using-stack",
                "content": "Runtime: 92 ms, faster than 99.20% of C# online submissions for Kth Smallest Element in a BST.\\nMemory Usage: 28.1 MB, less than 55.98% of C# online submissions for Kth Smallest Element in a BST.\\n```\\npublic class Solution\\n{\\n    Stack<TreeNode> stack = new Stack<TreeNode>();\\n\\t\\n    public int KthSmallest(TreeNode root, int k)\\n    {\\n        TraverseToMin(root);\\n\\n        TreeNode node = null;\\n\\n        while(k > 0)\\n        {\\n            node = stack.Pop();\\n            k--;\\n            if(k == 0)\\n                break;\\n\\n            TraverseToMin(node.right);\\n        }\\n\\n        return node.val;\\n    }\\n\\n    private void TraverseToMin(TreeNode node)\\n    {\\n        while(node != null)\\n        {\\n            stack.Push(node);\\n            node = node.left;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution\\n{\\n    Stack<TreeNode> stack = new Stack<TreeNode>();\\n\\t\\n    public int KthSmallest(TreeNode root, int k)\\n    {\\n        TraverseToMin(root);\\n\\n        TreeNode node = null;\\n\\n        while(k > 0)\\n        {\\n            node = stack.Pop();\\n            k--;\\n            if(k == 0)\\n                break;\\n\\n            TraverseToMin(node.right);\\n        }\\n\\n        return node.val;\\n    }\\n\\n    private void TraverseToMin(TreeNode node)\\n    {\\n        while(node != null)\\n        {\\n            stack.Push(node);\\n            node = node.left;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642243,
                "title": "c-simple-iterative-in-order-traversal-with-comments",
                "content": "This submission beats only 30% in both run-time and memory, not sure how I can improve. I\\'d appreciate any suggestions! \\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        \\n        // Since BST is in increasing order when pre-order traversaled \\n        // do iterative inorder traversal till k elements are found\\n        \\n        if(!root) return -1;\\n        \\n        stack<TreeNode*> s;\\n                \\n        while(1){ // since k is in the range of 1 - #elements in the BST\\n            \\n            while(root){\\n                s.push(root);\\n                root = root->left;\\n            }\\n            \\n            root = s.top();\\n            s.pop();\\n            k--;\\n            if(k == 0){\\n                return root->val;\\n            }\\n            \\n            root = root->right;            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        \\n        // Since BST is in increasing order when pre-order traversaled \\n        // do iterative inorder traversal till k elements are found\\n        \\n        if(!root) return -1;\\n        \\n        stack<TreeNode*> s;\\n                \\n        while(1){ // since k is in the range of 1 - #elements in the BST\\n            \\n            while(root){\\n                s.push(root);\\n                root = root->left;\\n            }\\n            \\n            root = s.top();\\n            s.pop();\\n            k--;\\n            if(k == 0){\\n                return root->val;\\n            }\\n            \\n            root = root->right;            \\n        }\\n        \\n        return -1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 187791,
                "title": "go-solution",
                "content": "```\\nfunc Traverse(c chan int, root *TreeNode) {\\n    if root == nil {\\n        return\\n    }\\n    Traverse(c, root.Left)\\n    c <- root.Val\\n    Traverse(c, root.Right)\\n}\\n\\nfunc kthSmallest(root *TreeNode, k int) int {\\n    c := make(chan int)\\n    go func() {\\n        Traverse(c, root)\\n        close(c)\\n    }()\\n    x, ok := <-c\\n    for ; k > 1 && ok; x, ok = <-c {\\n        k--\\n    }\\n    return x\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc Traverse(c chan int, root *TreeNode) {\\n    if root == nil {\\n        return\\n    }\\n    Traverse(c, root.Left)\\n    c <- root.Val\\n    Traverse(c, root.Right)\\n}\\n\\nfunc kthSmallest(root *TreeNode, k int) int {\\n    c := make(chan int)\\n    go func() {\\n        Traverse(c, root)\\n        close(c)\\n    }()\\n    x, ok := <-c\\n    for ; k > 1 && ok; x, ok = <-c {\\n        k--\\n    }\\n    return x\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 164028,
                "title": "o-n-time-o-1-space-java-solution-with-explanation-beats-100",
                "content": "```\\n    private int numElements = 0;\\n    private int kthSmallest = 0;\\n    \\n    public int kthSmallest(TreeNode root, int k) {\\n        helper(root, k);\\n        return kthSmallest;\\n    }\\n    \\n    private void helper(TreeNode root, int targetCount) {\\n        if (root == null) return;\\n        \\n        helper(root.left, targetCount);\\n        if (++numElements == targetCount) {\\n            kthSmallest = root.val;\\n            return;\\n        }\\n        helper(root.right, targetCount);\\n    } \\n\\t\\t\\n```\\n\\nEssentially, this code performs a simple inorder traversal of the BST (which gives us the elements in order). However, instead of storing the elements in a list or array (which requires O(n) space complexity), the method stores the number of elements visited so far in an instance variable. When the number of elements visited equals k, the kthSmallest instance variable is set to the value of the current node. kthSmallest is guaranteed to be set to the right value because counting the number of elements with an inorder traversal counts them in ascending order. So, given the input [5,3,6,2,4,null,null,1], k = 3, numElements is incremented for the first time when the node with value 1 is visited (etc...). \\n\\nHope this helps! ",
                "solutionTags": [],
                "code": "```\\n    private int numElements = 0;\\n    private int kthSmallest = 0;\\n    \\n    public int kthSmallest(TreeNode root, int k) {\\n        helper(root, k);\\n        return kthSmallest;\\n    }\\n    \\n    private void helper(TreeNode root, int targetCount) {\\n        if (root == null) return;\\n        \\n        helper(root.left, targetCount);\\n        if (++numElements == targetCount) {\\n            kthSmallest = root.val;\\n            return;\\n        }\\n        helper(root.right, targetCount);\\n    } \\n\\t\\t\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 149427,
                "title": "clean-java-code-inorder-beat-100",
                "content": "```\\nclass Solution {\\n    int ans;\\n    int p = 0;\\n    public int kthSmallest(TreeNode root, int k) {\\n        inorder(root, k);\\n        return ans;\\n    }\\n    public void inorder(TreeNode root, int k){\\n        if(root == null) return;\\n        inorder(root.left, k);\\n        p++;\\n        if(p == k) ans = root.val;\\n        inorder(root.right, k);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int ans;\\n    int p = 0;\\n    public int kthSmallest(TreeNode root, int k) {\\n        inorder(root, k);\\n        return ans;\\n    }\\n    public void inorder(TreeNode root, int k){\\n        if(root == null) return;\\n        inorder(root.left, k);\\n        p++;\\n        if(p == k) ans = root.val;\\n        inorder(root.right, k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63877,
                "title": "ac-python-76ms-iterative-clean-solution",
                "content": "    def kthSmallest(self, root, k):\\n        stack = []\\n        node = root\\n        while True:\\n            if node:\\n                stack.append(node)\\n                node = node.left\\n            else:\\n                node = stack.pop()\\n                k -= 1\\n                if not k:\\n                    break\\n                node = node.right\\n        return node.val\\n\\n\\n    # 91 / 91 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 76 ms\\n    # 96.67%\\n\\nFinding the kth smallest in a sorted array is easy, which is just nums[k-1]. If we do a inorder traversal of the BST, the result will be the nodes in ascending order, then all we need is return inorder[k-1].\\n\\nOf course we are smarter than that. We do not need an array to store all the values during the traversal and we do not need to traversal the whole tree. Keeping a count of how many nodes have been traversaled allow us to return the node's value when count reaches k.",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "    def kthSmallest(self, root, k):\\n        stack = []\\n        node = root\\n        while True:\\n            if node:\\n                stack.append(node)\\n                node = node.left\\n            else:\\n                node = stack.pop()\\n                k -= 1\\n                if not k:\\n                    break\\n                node = node.right\\n        return node.val\\n\\n\\n    # 91 / 91 test cases passed.\\n    # Status: Accepted\\n    # Runtime: 76 ms\\n    # 96.67%\\n\\nFinding the kth smallest in a sorted array is easy, which is just nums[k-1]. If we do a inorder traversal of the BST, the result will be the nodes in ascending order, then all we need is return inorder[k-1].\\n\\nOf course we are smarter than that. We do not need an array to store all the values during the traversal and we do not need to traversal the whole tree. Keeping a count of how many nodes have been traversaled allow us to return the node's value when count reaches k.",
                "codeTag": "Python3"
            },
            {
                "id": 3505000,
                "title": "javascript-inorder-iterative-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nOne possible solution to approach this problem is to create an array using a recursive function and then return the Kth element. However, since the tree is sorted, we can optimize our approach by using a loop instead and stopping the loop once we reach the Kth element. In this way, we can traverse the tree without using recursion.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTo solve the problem, we can create a `stack` that stores the nodes we need to visit in the tree, and we can start at the `root` node. We also need to keep track of `n`, which we increment each time we `pop` a node from the stack, and we check whether `n` equals `K`. If the `root` node has a value, we keep adding the nodes to the left of the `root`. Once we have visited all the left nodes, we pop the top node from the `stack` and set that node to be the new `root`. We can then increment `n` and check whether it matches `K`. If it does, we have found the `kth` smallest value, and we can return it. If we haven\\'t reached `K` yet, we go to the right node and repeat the process until we reach `K`.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n) -> We only need to run through this tree at most one time, if it\\'s all left nodes. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) -> For the stack, which can only grow to be as big as the tree. \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} k\\n * @return {number}\\n */\\nvar kthSmallest = function(root, k) {\\n    let n = 0\\n    let stack = []\\n    let current = root\\n    while (current || stack.length > 0) {\\n        while (current) {\\n            stack.push(current)\\n            current = current.left\\n        }\\n        current = stack.pop()\\n        n += 1\\n        if (n === k) return current.val\\n        current = current.right\\n    }\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} k\\n * @return {number}\\n */\\nvar kthSmallest = function(root, k) {\\n    let n = 0\\n    let stack = []\\n    let current = root\\n    while (current || stack.length > 0) {\\n        while (current) {\\n            stack.push(current)\\n            current = current.left\\n        }\\n        current = stack.pop()\\n        n += 1\\n        if (n === k) return current.val\\n        current = current.right\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3472559,
                "title": "easy-c-using-recursion",
                "content": "# **PLS UPVOTE IF U LIKE MY SOLUTION**\\n\\n# Approach \\nFunction fun:\\nThis function performs an in-order traversal of the BST to find the kth smallest element.\\nIt takes three arguments: root (the current node being processed), i (a reference to an integer that keeps track of the number of visited nodes), and k (the target kth smallest element to find).\\nBase Case:\\nIf root is NULL, indicating that you\\'ve reached the end of a branch, return -1 to signal an empty value.\\nLeft Subtree:\\nRecursively call fun on the left subtree (root->left). If a value is returned (which means you\\'ve found the kth smallest element), return that value immediately.\\nNode Visit:\\nIncrement the i variable, which represents the count of visited nodes.\\nIf i becomes equal to k, you\\'ve found the kth smallest element, so return root->val.\\nRight Subtree:\\nIf the kth smallest element has not been found yet, recursively call fun on the right subtree (root->right).\\nMain Function kthSmallest:\\nThis function initializes the variable i to 0 (to keep track of visited nodes) and calls the fun function with the root of the BST and the target kth value k.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:0(N)\\n\\n- Space complexity:0(H)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic: \\n    void fun(TreeNode* root, vector<int>&arr)\\n    {\\n        if(root==NULL){\\n            return ;\\n        }\\n\\t\\tfun(root->left,arr);\\n        arr.push_back(root->val);\\n        fun(root->right,arr);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        vector<int>arr;\\n        fun(root,arr);\\n        int n=arr[k-1];\\n        return n;\\n\\n    }\\n};\\n\\n\\n```\\n\\n",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n\\nclass Solution {\\npublic: \\n    void fun(TreeNode* root, vector<int>&arr)\\n    {\\n        if(root==NULL){\\n            return ;\\n        }\\n\\t\\tfun(root->left,arr);\\n        arr.push_back(root->val);\\n        fun(root->right,arr);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        vector<int>arr;\\n        fun(root,arr);\\n        int n=arr[k-1];\\n        return n;\\n\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3469695,
                "title": "java-easy-solution-using-2dfs-approaches-beginner-friendly-dfs-k-1-dfs-pq",
                "content": "\\n# Approach\\n- Check if the root of the binary search tree is null. If it is null, return 0 as there are no elements in the tree.\\n\\n- Create an ArrayList li to store all the elements of the binary search tree in ascending order.\\n\\n- Call the dfs function with the root node and the ArrayList li as parameters.\\n\\n- The dfs function recursively traverses the binary search tree in an in-order fashion. It first visits the left subtree, then adds the root node to the ArrayList li, and then visits the right subtree.\\n\\n- Once the dfs function completes, all the elements of the binary search tree are stored in the ArrayList li in ascending order.\\n\\n- Return the kth element of the ArrayList li using the get() method. Note that the index of the kth element in the ArrayList is k-1.\\n\\nThe time complexity of the algorithm is O(n), where n is the number of nodes in the binary search tree. The space complexity of the algorithm is O(n), where n is the number of nodes in the binary search tree.\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n 1st sol using DFS\\n```\\n\\n      public int kthSmallest(TreeNode root, int k) {\\n        if(root==null) return 0;\\n         List<Integer> li=new ArrayList();\\n        dfs(root,li);\\n         return li.get(k-1);\\n\\n\\n    }\\n    static void dfs(TreeNode root,List<Integer> li){\\n        if(root==null) return;\\n\\n        dfs(root.left,li);\\n        li.add(root.val);\\n        dfs(root.right,li);\\n    }\\n}\\n\\n\\n```\\n- Check if the root of the binary search tree is null. If it is null, return 0 as there are no elements in the tree.\\n\\n- Create an ArrayList li to store all the elements of the binary search tree in ascending order.\\n\\n- Call the dfs function with the root node and the ArrayList li as parameters.\\n\\n- The dfs function recursively traverses the binary search tree in an in-order fashion. It first visits the left subtree, then adds the root node to the ArrayList li, and then visits the right subtree.\\n\\n- Once the dfs function completes, all the elements of the binary search tree are stored in the ArrayList li in ascending order.\\n\\n- Create a PriorityQueue ans to store the elements of the ArrayList li in ascending order.\\n\\n- Add all the elements of the ArrayList li to the PriorityQueue ans.\\n\\n- Use a while loop to remove elements from the PriorityQueue ans until the kth smallest element is found or the PriorityQueue is empty. The loop decrements the value of k with each iteration.\\n\\n- If the kth smallest element is found, store it in the variable val.\\n\\nReturn the value of val as the kth smallest element in the binary search tree.\\n\\nThe time complexity of the algorithm is O(nlogn), where n is the number of nodes in the binary search tree. The space complexity of the algorithm is O(n), where n is the number of nodes in the binary search tree.\\n\\n\\n\\n\\n\\n\\n$$O(logn)$$\\n$$O(n)$$\\n\\n2nd sol using dfs+priorityQueue\\n```\\npublic int kthSmallest(TreeNode root, int k) {\\n        if(root==null) return 0;\\n      \\n         List<Integer> li=new ArrayList();\\n        dfs(root,li);\\n        PriorityQueue<Integer> ans=new PriorityQueue();\\n        for(int i=0;i<li.size();i++)ans.add(li.get(i));\\n        int val=0;\\n        while(!ans.isEmpty() && k-->0){\\n            val=ans.remove();\\n        }\\n\\n         return val;\\n\\n\\n    }\\n    static void dfs(TreeNode root,List<Integer> li){\\n        if(root==null) return;\\n\\n        dfs(root.left,li);\\n        li.add(root.val);\\n        dfs(root.right,li);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\n\\n      public int kthSmallest(TreeNode root, int k) {\\n        if(root==null) return 0;\\n         List<Integer> li=new ArrayList();\\n        dfs(root,li);\\n         return li.get(k-1);\\n\\n\\n    }\\n    static void dfs(TreeNode root,List<Integer> li){\\n        if(root==null) return;\\n\\n        dfs(root.left,li);\\n        li.add(root.val);\\n        dfs(root.right,li);\\n    }\\n}\\n\\n\\n```\n```\\npublic int kthSmallest(TreeNode root, int k) {\\n        if(root==null) return 0;\\n      \\n         List<Integer> li=new ArrayList();\\n        dfs(root,li);\\n        PriorityQueue<Integer> ans=new PriorityQueue();\\n        for(int i=0;i<li.size();i++)ans.add(li.get(i));\\n        int val=0;\\n        while(!ans.isEmpty() && k-->0){\\n            val=ans.remove();\\n        }\\n\\n         return val;\\n\\n\\n    }\\n    static void dfs(TreeNode root,List<Integer> li){\\n        if(root==null) return;\\n\\n        dfs(root.left,li);\\n        li.add(root.val);\\n        dfs(root.right,li);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3337410,
                "title": "java-in-order-traversal-clean-code-8-lines",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAn in-order traversal of a BST will always be in sorted ascending order. We just need to do an in-order traversal and keep counting values from the beginning till we reach the `kth`value. Then we can stop the traversal and return the obtained value.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(k)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(k)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  int k;\\n\\n  private int inOrder(TreeNode node) {\\n    if (node == null) return -1;\\n\\n    var ans = inOrder(node.left);\\n    if (ans != -1 && --k <= 0) return ans;\\n\\n    if (--k <= 0) return node.val;\\n\\n    return inOrder(node.right);\\n  }\\n\\n  public int kthSmallest(TreeNode root, int k) {\\n    this.k = k;\\n    return inOrder(root);\\n  }\\n}\\n```\\nIf you like my solution, please upvote it!",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n  int k;\\n\\n  private int inOrder(TreeNode node) {\\n    if (node == null) return -1;\\n\\n    var ans = inOrder(node.left);\\n    if (ans != -1 && --k <= 0) return ans;\\n\\n    if (--k <= 0) return node.val;\\n\\n    return inOrder(node.right);\\n  }\\n\\n  public int kthSmallest(TreeNode root, int k) {\\n    this.k = k;\\n    return inOrder(root);\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290590,
                "title": "dfs-approach-easy-0ms",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(h)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int count=0;\\n    int smallest=0;\\n    public int kthSmallest(TreeNode root, int k) {\\n        DFS(root,k);\\n        return smallest;\\n    }\\n    public void DFS(TreeNode root, int k){\\n        if(root==null) return;\\n        DFS(root.left,k);\\n        count++;\\n        if(count==k){\\n            smallest=root.val;\\n            return;\\n        }\\n        DFS(root.right,k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int count=0;\\n    int smallest=0;\\n    public int kthSmallest(TreeNode root, int k) {\\n        DFS(root,k);\\n        return smallest;\\n    }\\n    public void DFS(TreeNode root, int k){\\n        if(root==null) return;\\n        DFS(root.left,k);\\n        count++;\\n        if(count==k){\\n            smallest=root.val;\\n            return;\\n        }\\n        DFS(root.right,k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248913,
                "title": "recursive-and-iterative-solutions-with-index-counter",
                "content": "# Intuition\\ntwo solutios with index counter so we can stop when we find the kth smallest element.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\nRecursive Solution\\n\\n```\\nclass Solution {\\n    func kthSmallest(_ root: TreeNode?, _ k: Int) -> Int {\\n        var index = 0\\n        guard let node = inorderTraverse(root, k, &index) else {\\n            return 0\\n        }\\n        return node.val\\n    }\\n\\n    func inorderTraverse(_ node: TreeNode?, _ k: Int, _ index: inout Int) -> TreeNode? {\\n        guard let node = node else {\\n            return nil\\n        }\\n\\n        if let targetNode = inorderTraverse(node.left, k, &index) {\\n            return targetNode\\n        }\\n\\n        index += 1\\n        if index == k {\\n            return node\\n        }\\n\\n        return inorderTraverse(node.right, k, &index)\\n    }\\n}\\n```\\n\\n\\nIterarive solution\\n```\\nclass Solution {\\n    func kthSmallest(_ root: TreeNode?, _ k: Int) -> Int {\\n        var stack = [ TreeNode? ]()\\n        var index = 0\\n        var curNode = root\\n        while !stack.isEmpty || curNode != nil {\\n            while curNode != nil {\\n                stack.append(curNode)\\n                curNode = curNode?.left\\n            }\\n\\n            curNode = stack.removeLast()\\n            index += 1\\n            if index == k {\\n                break\\n            }\\n            curNode = curNode?.right\\n        }\\n\\n        return curNode?.val ?? 0\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func kthSmallest(_ root: TreeNode?, _ k: Int) -> Int {\\n        var index = 0\\n        guard let node = inorderTraverse(root, k, &index) else {\\n            return 0\\n        }\\n        return node.val\\n    }\\n\\n    func inorderTraverse(_ node: TreeNode?, _ k: Int, _ index: inout Int) -> TreeNode? {\\n        guard let node = node else {\\n            return nil\\n        }\\n\\n        if let targetNode = inorderTraverse(node.left, k, &index) {\\n            return targetNode\\n        }\\n\\n        index += 1\\n        if index == k {\\n            return node\\n        }\\n\\n        return inorderTraverse(node.right, k, &index)\\n    }\\n}\\n```\n```\\nclass Solution {\\n    func kthSmallest(_ root: TreeNode?, _ k: Int) -> Int {\\n        var stack = [ TreeNode? ]()\\n        var index = 0\\n        var curNode = root\\n        while !stack.isEmpty || curNode != nil {\\n            while curNode != nil {\\n                stack.append(curNode)\\n                curNode = curNode?.left\\n            }\\n\\n            curNode = stack.removeLast()\\n            index += 1\\n            if index == k {\\n                break\\n            }\\n            curNode = curNode?.right\\n        }\\n\\n        return curNode?.val ?? 0\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219178,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int a[10001] = {0};\\n    int count = 0;\\n    void traversal(TreeNode* root) {\\n        if(!root) return;\\n        traversal(root->left);\\n        a[count++] = root->val;\\n        traversal(root->right);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        traversal(root);\\n        return a[k - 1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int a[10001] = {0};\\n    int count = 0;\\n    void traversal(TreeNode* root) {\\n        if(!root) return;\\n        traversal(root->left);\\n        a[count++] = root->val;\\n        traversal(root->right);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        traversal(root);\\n        return a[k - 1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3189101,
                "title": "simple-solution-inorder-traversal-dfs-beats-93-runtime-python",
                "content": "\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n\\n        preorder = []\\n        \\n        def dfs(node : TreeNode):\\n            if not(node) : return\\n\\n            dfs(node.left)\\n            preorder.append(node.val)\\n            dfs(node.right)\\n\\n        dfs(root)\\n        \\n        return preorder[k-1]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n\\n        preorder = []\\n        \\n        def dfs(node : TreeNode):\\n            if not(node) : return\\n\\n            dfs(node.left)\\n            preorder.append(node.val)\\n            dfs(node.right)\\n\\n        dfs(root)\\n        \\n        return preorder[k-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3126123,
                "title": "100-beats-java-solution",
                "content": "# Intuition\\nAs we know Inorder Traversal of a binary search tree returns value in sorted order. Hence we can keep track of count of return value.\\n\\n# Approach\\nInorder Traversal\\n\\n# Complexity\\n- Time complexity:\\no(n)\\n\\n- Space complexity:\\no(h) or o(log(n))\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    static int count;\\n    static int res;\\n    public int kthSmallest(TreeNode root, int k) {\\n        count = 0;\\n        res = 0;\\n        inorder(root,k);\\n        return res;\\n    }\\n    private void inorder(TreeNode root, int k){\\n        if(root == null)\\n            return;\\n        \\n        inorder(root.left,k);\\n        count++;\\n        if(count == k){\\n            res = root.val;\\n            return;\\n        }\\n        inorder(root.right,k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    static int count;\\n    static int res;\\n    public int kthSmallest(TreeNode root, int k) {\\n        count = 0;\\n        res = 0;\\n        inorder(root,k);\\n        return res;\\n    }\\n    private void inorder(TreeNode root, int k){\\n        if(root == null)\\n            return;\\n        \\n        inorder(root.left,k);\\n        count++;\\n        if(count == k){\\n            res = root.val;\\n            return;\\n        }\\n        inorder(root.right,k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3056650,
                "title": "java-using-inorder-traversal",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<Integer> list=new ArrayList<>();\\n    public int kthSmallest(TreeNode root, int k) {\\n        if(root==null)return 0;\\n        help(root,k);\\n        return list.get(k-1);\\n    }\\n    public void help(TreeNode root,int k)\\n    {\\n        if(root==null)return;\\n        help(root.left,k);\\n        list.add(root.val);\\n        if(list.size()==k)return;\\n        help(root.right,k);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    List<Integer> list=new ArrayList<>();\\n    public int kthSmallest(TreeNode root, int k) {\\n        if(root==null)return 0;\\n        help(root,k);\\n        return list.get(k-1);\\n    }\\n    public void help(TreeNode root,int k)\\n    {\\n        if(root==null)return;\\n        help(root.left,k);\\n        list.add(root.val);\\n        if(list.size()==k)return;\\n        help(root.right,k);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3006245,
                "title": "c-easy-inorder",
                "content": "\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimply using inorder traversal in the BST gives the sorted order storing that in the array or vector and returning the kth location of that array.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void helper(TreeNode * root,int k){\\n        if(k > 0){\\n            if(root == NULL){\\n                return;\\n            }\\n            helper(root->left,k--);\\n            ans.push_back(root->val);\\n            helper(root->right,k--);\\n        }\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        helper(root,k);\\n        return ans[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> ans;\\n    void helper(TreeNode * root,int k){\\n        if(k > 0){\\n            if(root == NULL){\\n                return;\\n            }\\n            helper(root->left,k--);\\n            ans.push_back(root->val);\\n            helper(root->right,k--);\\n        }\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        helper(root,k);\\n        return ans[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2954020,
                "title": "c-in-order-dfs-traversal-clean-short-code",
                "content": "![image](https://assets.leetcode.com/users/images/821a141e-0ebf-4881-8e38-fc677defc5d3_1672066309.0664287.png)\\n\\n**T->O(k) && S->O(n) [ASS]** \\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint target=-1,count=1;\\n\\t\\tvoid dfs(TreeNode* curr,int k){\\n\\t\\t\\tif(!curr) return;\\n\\t\\t\\tif(target==-1)dfs(curr->left,k);\\n\\t\\t\\tif(count++==k) target=curr->val;\\n\\t\\t\\tif(target==-1)dfs(curr->right,k);\\n\\t\\t}\\n\\n\\t\\tint kthSmallest(TreeNode* root, int k) {\\n\\t//      Inorder of BST is always Sorted!\\n\\t\\t\\tdfs(root,k);\\n\\t\\t\\treturn target;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint target=-1,count=1;\\n\\t\\tvoid dfs(TreeNode* curr,int k){\\n\\t\\t\\tif(!curr) return;\\n\\t\\t\\tif(target==-1)dfs(curr->left,k);\\n\\t\\t\\tif(count++==k) target=curr->val;\\n\\t\\t\\tif(target==-1)dfs(curr->right,k);\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2886479,
                "title": "easy-c-solution-using-recurion",
                "content": "\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n   void solve(TreeNode* root,int &k,int &ans)\\n{\\n    if(!root)return ;\\n    solve(root->left,k,ans);\\n    k-=1;\\n    if(k==0) ans=root->val;\\n    solve(root->right,k,ans);\\n    return;\\n}\\n    int kthSmallest(TreeNode* root, int k) {\\n        int ans=-1;\\n        solve(root,k,ans);\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n   void solve(TreeNode* root,int &k,int &ans)\\n{\\n    if(!root)return ;\\n    solve(root->left,k,ans);\\n    k-=1;\\n    if(k==0) ans=root->val;\\n    solve(root->right,k,ans);\\n    return;\\n}\\n    int kthSmallest(TreeNode* root, int k) {\\n        int ans=-1;\\n        solve(root,k,ans);\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882247,
                "title": "easy-to-read-iterative-dfs-and-inorder-traversal-approach",
                "content": "Iterative Approach\\n\\n```\\npublic int kthSmallest(TreeNode root, int k) {\\n        \\n\\tStack<TreeNode> stack = new Stack<>();\\n\\n\\twhile(root!=null || !stack.isEmpty()){\\n\\t\\twhile(root != null){\\n\\t\\t\\tstack.push(root);\\n\\t\\t\\troot = root.left;\\n\\t\\t}\\n\\n\\t\\troot = stack.pop();\\n\\t\\tk--;\\n\\t\\tif(k == 0) return root.val;\\n\\t\\troot = root.right;\\n\\t}\\n\\n\\treturn -1;\\n}\\n```\\n\\nRecursive Inorder\\n```\\n    public ArrayList<Integer> inorder(TreeNode root, ArrayList<Integer> arr) {\\n\\t\\tif (root == null) return arr;\\n\\t\\tinorder(root.left, arr);\\n\\t\\tarr.add(root.val);\\n\\t\\tinorder(root.right, arr);\\n\\t\\treturn arr;\\n\\t  }\\n    \\n    public int kthSmallest(TreeNode root, int k) {\\n        ArrayList<Integer> nums = inorder(root, new ArrayList<Integer>());\\n        return nums.get(k-1);\\n    }\\n```\\n\\nTime Complexity - O(n), as we are traversing all nodes in worst case",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "```\\npublic int kthSmallest(TreeNode root, int k) {\\n        \\n\\tStack<TreeNode> stack = new Stack<>();\\n\\n\\twhile(root!=null || !stack.isEmpty()){\\n\\t\\twhile(root != null){\\n\\t\\t\\tstack.push(root);\\n\\t\\t\\troot = root.left;\\n\\t\\t}\\n\\n\\t\\troot = stack.pop();\\n\\t\\tk--;\\n\\t\\tif(k == 0) return root.val;\\n\\t\\troot = root.right;\\n\\t}\\n\\n\\treturn -1;\\n}\\n```\n```\\n    public ArrayList<Integer> inorder(TreeNode root, ArrayList<Integer> arr) {\\n\\t\\tif (root == null) return arr;\\n\\t\\tinorder(root.left, arr);\\n\\t\\tarr.add(root.val);\\n\\t\\tinorder(root.right, arr);\\n\\t\\treturn arr;\\n\\t  }\\n    \\n    public int kthSmallest(TreeNode root, int k) {\\n        ArrayList<Integer> nums = inorder(root, new ArrayList<Integer>());\\n        return nums.get(k-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2735129,
                "title": "2-approaches-recursive-using-bst-iterator-java-easy-1ms",
                "content": "```\\n Solve  BST iterator  question then this question will be cakewalk--\\n \\n https://leetcode.com/problems/binary-search-tree-iterator/\\n \\n** --------------------------------------------Iterative(1ms)-------------------------**\\nclass BSTIterator {\\n\\n    Stack<TreeNode> s;\\n  \\n    public BSTIterator(TreeNode root) {\\n       this.s=new Stack<TreeNode>(); \\n      \\n       pushAll(root);\\n        \\n    }\\n    public void pushAll(TreeNode node){\\n        while(node!=null){\\n            s.push(node);\\n            node=node.left;\\n        }\\n    }\\n    \\n    public int next() {\\n      \\n        if(s.size()==0)return -1;\\n        TreeNode root=s.pop();\\n        int v=root.val;\\n        if(root.right!=null){\\n            pushAll(root.right);\\n        }\\n        return v;\\n    }\\n    \\n    public boolean hasNext() {\\n        if(s.size()>0)return true;\\n        return false;\\n    }\\n}\\n\\nclass Solution {\\n    public int kthSmallest(TreeNode root, int k) {\\n        \\n        if(root==null)return -1;\\n        \\n      BSTIterator itr=new BSTIterator(root);\\n        int ans=-1;\\n        while( itr.hasNext() && k-->0){\\n            ans=itr.next();\\n        }\\n        return ans;\\n    }\\n}\\n```\\n**-----------------------recursive Approach(2ms)-----------------------------**\\n```\\nclass Solution {\\n    void help(TreeNode root, List<Integer> list){\\n        if(root==null)return;\\n        \\n        help(root.left,list);\\n        list.add(root.val);\\n        help(root.right,list);        \\n    }    \\n    public int kthSmallest(TreeNode root, int k) {\\n        List<Integer> list=new ArrayList<>();\\n        help(root,list);\\n        if(k>list.size())\\n            return -1;\\n        return list.get(k-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\n Solve  BST iterator  question then this question will be cakewalk--\\n \\n https://leetcode.com/problems/binary-search-tree-iterator/\\n \\n** --------------------------------------------Iterative(1ms)-------------------------**\\nclass BSTIterator {\\n\\n    Stack<TreeNode> s;\\n  \\n    public BSTIterator(TreeNode root) {\\n       this.s=new Stack<TreeNode>(); \\n      \\n       pushAll(root);\\n        \\n    }\\n    public void pushAll(TreeNode node){\\n        while(node!=null){\\n            s.push(node);\\n            node=node.left;\\n        }\\n    }\\n    \\n    public int next() {\\n      \\n        if(s.size()==0)return -1;\\n        TreeNode root=s.pop();\\n        int v=root.val;\\n        if(root.right!=null){\\n            pushAll(root.right);\\n        }\\n        return v;\\n    }\\n    \\n    public boolean hasNext() {\\n        if(s.size()>0)return true;\\n        return false;\\n    }\\n}\\n\\nclass Solution {\\n    public int kthSmallest(TreeNode root, int k) {\\n        \\n        if(root==null)return -1;\\n        \\n      BSTIterator itr=new BSTIterator(root);\\n        int ans=-1;\\n        while( itr.hasNext() && k-->0){\\n            ans=itr.next();\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    void help(TreeNode root, List<Integer> list){\\n        if(root==null)return;\\n        \\n        help(root.left,list);\\n        list.add(root.val);\\n        help(root.right,list);        \\n    }    \\n    public int kthSmallest(TreeNode root, int k) {\\n        List<Integer> list=new ArrayList<>();\\n        help(root,list);\\n        if(k>list.size())\\n            return -1;\\n        return list.get(k-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2699478,
                "title": "230-kth-smallest-element-in-a-bst",
                "content": "230. Kth Smallest Element in a BST\\n\\nGiven the root of a binary search tree, and an integer k, return the kth smallest value (1-indexed) of all the values of the nodes in the tree.\\n\\n```\\n# Definition for a binary tree node.\\nclass TreeNode(object):\\n    def __init__(self, x):\\n        self.val = x\\n        self.left = None\\n        self.right = None\\n\\nclass Solution(object):\\n    def traverse(self, root):\\n        if root:\\n            self.traverse(root.left)\\n            self.k -= 1\\n            if self.k == 0:\\n                self.ans = root.val\\n                return\\n            self.traverse(root.right)\\n            \\n    def kthSmallest(self, root, k):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        self.k = k\\n        self.traverse(root)\\n        return self.ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# Definition for a binary tree node.\\nclass TreeNode(object):\\n    def __init__(self, x):\\n        self.val = x\\n        self.left = None\\n        self.right = None\\n\\nclass Solution(object):\\n    def traverse(self, root):\\n        if root:\\n            self.traverse(root.left)\\n            self.k -= 1\\n            if self.k == 0:\\n                self.ans = root.val\\n                return\\n            self.traverse(root.right)\\n            \\n    def kthSmallest(self, root, k):\\n        \"\"\"\\n        :type root: TreeNode\\n        :type k: int\\n        :rtype: int\\n        \"\"\"\\n        self.k = k\\n        self.traverse(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551012,
                "title": "python-standard-quick-select",
                "content": "```\\nclass Solution:\\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n        n_left = self.count(root.left)\\n        if n_left == k - 1: return root.val\\n        elif n_left < k - 1: return self.kthSmallest(root.right, k - n_left - 1)\\n        else: return self.kthSmallest(root.left, k)\\n        \\n    def count(self, root):\\n        if not root: return 0\\n        return 1 + self.count(root.left) + self.count(root.right)\\n```",
                "solutionTags": [
                    "Python",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n        n_left = self.count(root.left)\\n        if n_left == k - 1: return root.val\\n        elif n_left < k - 1: return self.kthSmallest(root.right, k - n_left - 1)\\n        else: return self.kthSmallest(root.left, k)\\n        \\n    def count(self, root):\\n        if not root: return 0\\n        return 1 + self.count(root.left) + self.count(root.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2440376,
                "title": "recursive-c-o-n-time-and-o-h-space",
                "content": "**Intuition**: Visit from the left nodes first. Keep track of number of nodes visited and last visited node. When the visited node count becomes k, don\\u2019t visit any other node.\\n\\n**Algorithm**\\nIntitially we have lastVisitedNode = -1, visitedNodeCount = 0\\n1. If root == NULL then return\\n1. Visit left nodes recursively\\n1. If visitedNodeCount < k\\n\\t1. Visited current node by making lastVisitedNode = root \\u2192 val\\n\\t1. visitedNodeCount++\\n\\t1. visited right subtree nodes recursively\\n\\n**Code**\\n```\\nvoid kthSmallestHelper(TreeNode *root, int k, int &nodeVisitedCount, int &lastVisitedNode){\\n        if(root == NULL) return  ;\\n        kthSmallestHelper(root -> left, k, nodeVisitedCount, lastVisitedNode) ;\\n        \\n        if(nodeVisitedCount < k){\\n            lastVisitedNode = root -> val ;\\n            nodeVisitedCount++ ;\\n            kthSmallestHelper(root -> right, k, nodeVisitedCount, lastVisitedNode) ;\\n        }\\n    }\\n    \\n    int kthSmallest(TreeNode* root, int k) {\\n        int nodeVisitedCount = 0, lastVisitedNode = -1 ;\\n        kthSmallestHelper(root, k, nodeVisitedCount, lastVisitedNode) ;\\n        return lastVisitedNode ;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid kthSmallestHelper(TreeNode *root, int k, int &nodeVisitedCount, int &lastVisitedNode){\\n        if(root == NULL) return  ;\\n        kthSmallestHelper(root -> left, k, nodeVisitedCount, lastVisitedNode) ;\\n        \\n        if(nodeVisitedCount < k){\\n            lastVisitedNode = root -> val ;\\n            nodeVisitedCount++ ;\\n            kthSmallestHelper(root -> right, k, nodeVisitedCount, lastVisitedNode) ;\\n        }\\n    }\\n    \\n    int kthSmallest(TreeNode* root, int k) {\\n        int nodeVisitedCount = 0, lastVisitedNode = -1 ;\\n        kthSmallestHelper(root, k, nodeVisitedCount, lastVisitedNode) ;\\n        return lastVisitedNode ;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2383011,
                "title": "easy-c-solution",
                "content": "\\tvector<int> ans;\\n    void inorder(TreeNode* root){\\n        if(root==NULL) return ;\\n        inorder(root->left);\\n        ans.push_back(root->val);\\n        inorder(root->right);      \\n    }\\n\\t\\n\\t\\n    int kthSmallest(TreeNode* root, int k) {\\n        inorder(root);\\n        return ans[k-1];\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tvector<int> ans;\\n    void inorder(TreeNode* root){\\n        if(root==NULL) return ;\\n        inorder(root->left);\\n        ans.push_back(root->val);\\n        inorder(root->right);      \\n    }\\n\\t\\n\\t\\n    int kthSmallest(TreeNode* root, int k) {\\n        inorder(root);\\n        return ans[k-1];\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2236513,
                "title": "simple-java-solution-easy-to-understand",
                "content": "\\tclass Solution {\\n\\t\\tint count=1;\\n\\t\\tint x;\\n\\t\\tpublic int kthSmallest(TreeNode root, int k) {\\n\\t\\t\\t if(root==null){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}\\n\\t\\t\\tkthSmallest(root.left,k);\\n\\t\\t\\tif(count==k){\\n\\t\\t\\t\\tx=root.val;\\n\\t\\t\\t}\\n\\t\\t\\tcount++;\\n\\t\\t\\tkthSmallest(root.right,k);\\n\\t\\t\\treturn x;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "class Solution {\\n\\t\\tint count=1;\\n\\t\\tint x;\\n\\t\\tpublic int kthSmallest(TreeNode root, int k) {\\n\\t\\t\\t if(root==null){\\n\\t\\t\\t\\treturn 0;\\n\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1992149,
                "title": "c-very-simple-and-easy-inorder",
                "content": "If you like please upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n  \\n     int ans,num=0 ;\\n    \\n    void find(TreeNode* root, int k){\\n        if(!root) return ;\\n        \\n        find(root->left,k);\\n         num++;\\n        if(num==k) ans = root->val;\\n    \\n        find(root->right,k);\\n        \\n    }\\n    \\n    int kthSmallest(TreeNode* root, int k) {\\n        \\n        find(root, k);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n     int ans,num=0 ;\\n    \\n    void find(TreeNode* root, int k){\\n        if(!root) return ;\\n        \\n        find(root->left,k);\\n         num++;\\n        if(num==k) ans = root->val;\\n    \\n        find(root->right,k);\\n        \\n    }\\n    \\n    int kthSmallest(TreeNode* root, int k) {\\n        \\n        find(root, k);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961739,
                "title": "c-easy-to-understand-o-1-space-complexity-inorder-traversal",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count = 0;\\n    int value = 0;\\n    \\n    int kthSmallest(TreeNode* root, int k) {\\n        Inorder_Traversal(root, k);\\n        \\n        return value;\\n    }\\n    \\n    void Inorder_Traversal(TreeNode* root, int k) {\\n        if(root == NULL)\\n            return;\\n        \\n        Inorder_Traversal(root -> left, k);\\n        count++;\\n        if(count == k) {\\n            value = root -> val;\\n            return;\\n        }\\n        Inorder_Traversal(root -> right, k);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int count = 0;\\n    int value = 0;\\n    \\n    int kthSmallest(TreeNode* root, int k) {\\n        Inorder_Traversal(root, k);\\n        \\n        return value;\\n    }\\n    \\n    void Inorder_Traversal(TreeNode* root, int k) {\\n        if(root == NULL)\\n            return;\\n        \\n        Inorder_Traversal(root -> left, k);\\n        count++;\\n        if(count == k) {\\n            value = root -> val;\\n            return;\\n        }\\n        Inorder_Traversal(root -> right, k);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1961053,
                "title": "simple-inorder-traversal",
                "content": "```\\n    void inorder(TreeNode *root , vector<int> &v){\\n        if(root==NULL)\\n            return;\\n        \\n        inorder(root->left , v);\\n        v.push_back(root->val);\\n        inorder(root->right , v);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        vector<int> v;\\n        inorder(root , v);\\n        return v[k-1];\\n     \\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    void inorder(TreeNode *root , vector<int> &v){\\n        if(root==NULL)\\n            return;\\n        \\n        inorder(root->left , v);\\n        v.push_back(root->val);\\n        inorder(root->right , v);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        vector<int> v;\\n        inorder(root , v);\\n        return v[k-1];\\n     \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1960096,
                "title": "kth-smallest-element-in-a-bst",
                "content": "Simple c++ solution ------>\\n\\nUsing extra space............\\n\\n\\n```\\n   \\n             void kSmallest(TreeNode* root, vector<int>&v){\\n               if(root==NULL) return;\\n              \\n              kSmallest(root->left,v);\\n              v.push_back(root->val);\\n              kSmallest(root->right,v);\\n              \\n          }\\n    int kthSmallest(TreeNode* root, int k) {\\n          if(root==NULL) return 0;\\n           \\n              vector<int>v;\\n        kSmallest(root,v);\\n        \\n        return v[k-1];\\n              \\n            \\n    }\\n\\t\\n\\t```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n   \\n             void kSmallest(TreeNode* root, vector<int>&v){\\n               if(root==NULL) return;\\n              \\n              kSmallest(root->left,v);\\n              v.push_back(root->val);\\n              kSmallest(root->right,v);\\n              \\n          }\\n    int kthSmallest(TreeNode* root, int k) {\\n          if(root==NULL) return 0;\\n           \\n              vector<int>v;\\n        kSmallest(root,v);\\n        \\n        return v[k-1];\\n              \\n            \\n    }\\n\\t\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 1959563,
                "title": "easy-solution",
                "content": "* Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\n```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    void fun(TreeNode* root)\\n    {\\n        if(!root) return;\\n        if(root->left) fun(root->left);\\n        ans.push_back(root->val);\\n        if(root->right) fun(root->right);\\n        \\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        fun(root);\\n        return ans[k-1];\\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    void fun(TreeNode* root)\\n    {\\n        if(!root) return;\\n        if(root->left) fun(root->left);\\n        ans.push_back(root->val);\\n        if(root->right) fun(root->right);\\n        \\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        fun(root);\\n        return ans[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959472,
                "title": "javascript-recursive-solution-with-inorder-traversal",
                "content": "```\\nvar kthSmallest = function (root, k) {\\n  let temp = root,\\n    count = 1,\\n    val;\\n  function inOrder(temp) {\\n    if (!temp) return;\\n\\n    inOrder(temp.left);\\n\\n    if (count === k) {\\n      val = temp.val;\\n    }\\n    count++;\\n\\n    inOrder(temp.right);\\n  }\\n  inOrder(temp);\\n  return val;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\nvar kthSmallest = function (root, k) {\\n  let temp = root,\\n    count = 1,\\n    val;\\n  function inOrder(temp) {\\n    if (!temp) return;\\n\\n    inOrder(temp.left);\\n\\n    if (count === k) {\\n      val = temp.val;\\n    }\\n    count++;\\n\\n    inOrder(temp.right);\\n  }\\n  inOrder(temp);\\n  return val;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1959254,
                "title": "c-90-27-7-lines",
                "content": "```\\nclass Solution {\\npublic:\\n    int result = 0;\\n    int index = 1;\\n    \\n    void kthSmall(TreeNode* root, int k) {\\n        if ( root == nullptr ) { return; }\\n        kthSmall(root->left, k);\\n        if (index == k ) result = root->val;\\n        index++;\\n        kthSmall(root->right, k);\\n    }\\n    \\n    int kthSmallest(TreeNode* root, int k) {\\n        kthSmall(root, k);\\n        return result;\\n    }\\n};\\n```\\n\\n**For more solutions, check out this \\uD83C\\uDFC6  [GITHUB REPOSITORY](https://github.com/MuhtasimTanmoy/playground) with over 1500+ solutions.**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int result = 0;\\n    int index = 1;\\n    \\n    void kthSmall(TreeNode* root, int k) {\\n        if ( root == nullptr ) { return; }\\n        kthSmall(root->left, k);\\n        if (index == k ) result = root->val;\\n        index++;\\n        kthSmall(root->right, k);\\n    }\\n    \\n    int kthSmallest(TreeNode* root, int k) {\\n        kthSmall(root, k);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1959118,
                "title": "easy-c-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    // store values of bst in sorted order\\n    vector<int> result;\\n    \\n    // inorder traversal to get values in sorted order\\n    void getinorder(TreeNode *root){\\n        if(root==nullptr) return;\\n        getinorder(root->left);\\n        result.push_back(root->val);\\n        getinorder(root->right);\\n    }\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        getinorder(root);\\n        \\n        // return the value at k position in sorted array\\n        return result[k-1];\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    // store values of bst in sorted order\\n    vector<int> result;\\n    \\n    // inorder traversal to get values in sorted order\\n    void getinorder(TreeNode *root){\\n        if(root==nullptr) return;\\n        getinorder(root->left);\\n        result.push_back(root->val);\\n        getinorder(root->right);\\n    }\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        getinorder(root);\\n        \\n        // return the value at k position in sorted array\\n        return result[k-1];\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1842527,
                "title": "c-2-solutions-with-w-o-extra-space-recursion-inorder-easy-clean-code",
                "content": "**1. Using extra space**\\nTime - O(n)\\nSpace - O(n)\\n```\\n    vector<int> v;\\n    \\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n        \\n    int kthSmallest(TreeNode* root, int k)\\n    {\\n        inorder(root);\\n        return v[k-1];\\n    }\\n```\\n\\n**2. W/O extra space**\\nTime - O(k) (not sure)\\nSpace - O(1)\\n```\\nint ans;\\n    int in;\\n    \\n    void inorder(TreeNode* root,int k)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root->left,k);\\n        \\n        in++;\\n        if(in==k)\\n        {\\n            ans=root->val;\\n            return;\\n        }\\n        \\n        if(ans==-1)\\n            inorder(root->right,k);\\n    }\\n    \\n    int kthSmallest(TreeNode* root, int k)\\n    {\\n        ans=-1;\\n        in=0;\\n        inorder(root,k);\\n        return ans;\\n    }\\n```\\n\\n**Do share your views & upvote if you like !!!**  \\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Binary Search Tree",
                    "Recursion"
                ],
                "code": "```\\n    vector<int> v;\\n    \\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root->left);\\n        v.push_back(root->val);\\n        inorder(root->right);\\n    }\\n        \\n    int kthSmallest(TreeNode* root, int k)\\n    {\\n        inorder(root);\\n        return v[k-1];\\n    }\\n```\n```\\nint ans;\\n    int in;\\n    \\n    void inorder(TreeNode* root,int k)\\n    {\\n        if(!root)\\n            return;\\n        \\n        inorder(root->left,k);\\n        \\n        in++;\\n        if(in==k)\\n        {\\n            ans=root->val;\\n            return;\\n        }\\n        \\n        if(ans==-1)\\n            inorder(root->right,k);\\n    }\\n    \\n    int kthSmallest(TreeNode* root, int k)\\n    {\\n        ans=-1;\\n        in=0;\\n        inorder(root,k);\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1836492,
                "title": "3-lines-of-code-check-it-cpp-solution",
                "content": "# Easy to Understand \\n**@iprincekumark**\\n```\\nvector<int> ans;\\n    void inorder(TreeNode* root) {\\n        if(root == NULL)\\n            return ;\\n        inorder(root->left);\\n        ans.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        inorder(root);\\n        return ans.at(k-1);\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nvector<int> ans;\\n    void inorder(TreeNode* root) {\\n        if(root == NULL)\\n            return ;\\n        inorder(root->left);\\n        ans.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    int kthSmallest(TreeNode* root, int k) {\\n        inorder(root);\\n        return ans.at(k-1);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1764047,
                "title": "python-easy-to-read-and-understand-inorder",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorder(self, node):\\n        if not node:\\n            return []\\n        l, r = self.inorder(node.left), self.inorder(node.right)\\n        return l + [node.val] + r\\n    \\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n        nums = self.inorder(root)\\n        return nums[k-1]",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def inorder(self, node):\\n        if not node:\\n            return []\\n        l, r = self.inorder(node.left), self.inorder(node.right)\\n        return l + [node.val] + r\\n    \\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\\n        nums = self.inorder(root)\\n        return nums[k-1]",
                "codeTag": "Java"
            },
            {
                "id": 1728059,
                "title": "java-time-o-n-space-o-h-dfs-explain",
                "content": "##### The conditions are:\\n1. This tree is a binary search tree.\\n2. At least one node.\\n3. The k value is smaller than the number of nodes.\\n\\n##### List some examples:\\n\\n![image](https://assets.leetcode.com/users/images/64d5e57a-0499-4b14-8e63-ac351d332db1_1643441583.840334.png)\\n\\n\\n\\n\\n\\n##### Think aloud:\\n\\n1. This is a typical problem of finding a specific node. I prefer to use DFS to solve this problem.\\n2. Because a valid BST\\u2019s left child is always smaller than its parent node, and the parent node is always smaller than its right child. So, I will use in-order traversal to traverse the tree.\\n3. Use a variable to record the traversal history. When the value of this variable is equal to k, return the value of the current node.\\n\\n\\n```\\n/**\\n * Time O(n)\\n * Space O(h)\\n */\\nclass Solution {\\n  private int val = 0;\\n  private int count = 0;\\n  \\n  public int kthSmallest(TreeNode root, int k) {\\n    dfs(root, k);\\n    return val;\\n  }\\n\\n  /**\\n   * Time O(n)\\n   * Space O(h)\\n   *   - Each element costs constant space O(1).\\n   *     And the size of the stack is exactly the depth of DFS.\\n   *     So in the worst case, it costs O(h) to maintain the system stack,\\n   *     where h is the maximum depth of DFS.\\n   */\\n  public void dfs(TreeNode node, int k) {\\n    if (node == null) return;\\n    dfs(node.left, k);\\n    if (++count == k) {\\n\\t  this.val = node.val;\\n\\t  return;\\n    }\\n    dfs(node.right, k);\\n  }\\n}\\n```\\n\\n\\n##### Follow Up:\\nIf the BST is modified often (i.e., we can do insert and delete operations) and you need to find the kth smallest frequently, how would you optimize?\\n\\n##### Think aloud:\\n1. The BST is modified often, so the answer will be different even if we asked for the same kth smallest node.\\n2. Each node should store the number of descendant nodes including itself. And update the value if its descendants have any modifications.\\n3. We should check the number of left descendants first. Because it is a binary search tree, the left child is always smaller than the current node and right child. The descendants from the left child represent kth smallest nodes in the tree.\\n4. When k is smaller or equal to descendants from the left child, we will traverse to the left child.\\n5. We know that the right child is greater than the current node and all of the left descendants. So, when k is greater than descendants from the left child + 1 (current node). We will traverse to the right child.\\n6. If we can\\u2019t go left even right. It means the answer is the current node.\\n\\n##### List some examples:\\n![image](https://assets.leetcode.com/users/images/cd6e6ca2-31e0-4798-95c5-7aabd6fe2c5b_1643465669.9555423.png)\\n\\n\\n```\\npublic class TreeNode {\\n  int val;\\n  int descendant; // Add variable to store the number of descendant nodes including itself.\\n  TreeNode left;\\n  TreeNode right;\\n  TreeNode() {}\\n  TreeNode(int val) {\\n    this.val = val;\\n    this.descendant = 1;\\n  }\\n  TreeNode(int val, int descendant, TreeNode left, TreeNode right) {\\n    this.val = val;\\n    this.left = left;\\n    this.right = right;\\n    this.descendant = descendant;\\n  }\\n}\\n\\nclass Solution {\\n  \\n /**\\n  * Time O(n), Tree traversal\\n  * Space O(h)\\n  */\\n  private void rebuildTree(TreeNode root) {\\n    if (root == null) return;\\n    if (root.left != null) {\\n      rebuildTree(root.left);\\n      root.descendant += root.left.descendant;\\n    }\\n    if (root.right != null) {\\n      rebuildTree(root.right);\\n      root.descendant += root.right.descendant;\\n    }\\n  }\\n  \\n  public int kthSmallest(TreeNode root, int k) {\\n\\t // This rebuild function should update every time when BST is modified.\\n    rebuildTree(root);\\n\\t/**\\n\\t * So, we have more efficient time to get the answer.\\n\\t * Time O(log n)\\n\\t * Space O(h)\\n\\t */\\n    return dfs(root, k);\\n  }\\n\\n  /**\\n   * Time O(log n)\\n   *   - Without traverse\\n   * Space O(h)\\n   *   - Each element costs constant space O(1).\\n   *     And the size of the stack is exactly the depth of DFS.\\n   *     So in the worst case, it costs O(h) to maintain the system stack,\\n   *     where h is the maximum depth of DFS.\\n   */\\n  public int dfs(TreeNode node, int k) {\\n    if (node.left != null) {\\n      if (k <= node.left.descendant) {\\n        return dfs(node.left, k);\\n      } else if (k > node.left.descendant + 1) { \\n        return dfs(node.right, k - node.left.descendant - 1);\\n      }\\n      return node.val;\\n    } else {\\n      if (k == 1) return node.val;\\n      return dfs(node.right, k - 1);\\n    }\\n  }\\n}\\n```\\n\\nIf my explanation can help you. Please give me a thumbs up.\\n",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Time O(n)\\n * Space O(h)\\n */\\nclass Solution {\\n  private int val = 0;\\n  private int count = 0;\\n  \\n  public int kthSmallest(TreeNode root, int k) {\\n    dfs(root, k);\\n    return val;\\n  }\\n\\n  /**\\n   * Time O(n)\\n   * Space O(h)\\n   *   - Each element costs constant space O(1).\\n   *     And the size of the stack is exactly the depth of DFS.\\n   *     So in the worst case, it costs O(h) to maintain the system stack,\\n   *     where h is the maximum depth of DFS.\\n   */\\n  public void dfs(TreeNode node, int k) {\\n    if (node == null) return;\\n    dfs(node.left, k);\\n    if (++count == k) {\\n\\t  this.val = node.val;\\n\\t  return;\\n    }\\n    dfs(node.right, k);\\n  }\\n}\\n```\n```\\npublic class TreeNode {\\n  int val;\\n  int descendant; // Add variable to store the number of descendant nodes including itself.\\n  TreeNode left;\\n  TreeNode right;\\n  TreeNode() {}\\n  TreeNode(int val) {\\n    this.val = val;\\n    this.descendant = 1;\\n  }\\n  TreeNode(int val, int descendant, TreeNode left, TreeNode right) {\\n    this.val = val;\\n    this.left = left;\\n    this.right = right;\\n    this.descendant = descendant;\\n  }\\n}\\n\\nclass Solution {\\n  \\n /**\\n  * Time O(n), Tree traversal\\n  * Space O(h)\\n  */\\n  private void rebuildTree(TreeNode root) {\\n    if (root == null) return;\\n    if (root.left != null) {\\n      rebuildTree(root.left);\\n      root.descendant += root.left.descendant;\\n    }\\n    if (root.right != null) {\\n      rebuildTree(root.right);\\n      root.descendant += root.right.descendant;\\n    }\\n  }\\n  \\n  public int kthSmallest(TreeNode root, int k) {\\n\\t // This rebuild function should update every time when BST is modified.\\n    rebuildTree(root);\\n\\t/**\\n\\t * So, we have more efficient time to get the answer.\\n\\t * Time O(log n)\\n\\t * Space O(h)\\n\\t */\\n    return dfs(root, k);\\n  }\\n\\n  /**\\n   * Time O(log n)\\n   *   - Without traverse\\n   * Space O(h)\\n   *   - Each element costs constant space O(1).\\n   *     And the size of the stack is exactly the depth of DFS.\\n   *     So in the worst case, it costs O(h) to maintain the system stack,\\n   *     where h is the maximum depth of DFS.\\n   */\\n  public int dfs(TreeNode node, int k) {\\n    if (node.left != null) {\\n      if (k <= node.left.descendant) {\\n        return dfs(node.left, k);\\n      } else if (k > node.left.descendant + 1) { \\n        return dfs(node.right, k - node.left.descendant - 1);\\n      }\\n      return node.val;\\n    } else {\\n      if (k == 1) return node.val;\\n      return dfs(node.right, k - 1);\\n    }\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1650304,
                "title": "c-o-n-time-o-1-space-using-morris-traversal",
                "content": "**Please upvote if you found it useful.**\\nJust do simple morris traversal and keep increasing the counter everytime and check.\\n\\nReverse morris order can be used to find out kth largest element in O(1) space.\\n\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        int ans = INT_MIN;\\n        TreeNode* curr = root;\\n        int count = 0;\\n        while(curr){\\n            if(!curr->left){\\n                if(++count == k) ans = curr->val;\\n                curr = curr->right;\\n            } else{\\n                TreeNode* prev = curr->left;\\n                while(prev->right and prev->right != curr) prev = prev->right;\\n                if(!prev->right){\\n                    prev->right = curr;\\n                    curr = curr->left;\\n                } else{\\n                    prev->right = NULL;\\n                    if(++count == k) ans = curr->val;\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        int ans = INT_MIN;\\n        TreeNode* curr = root;\\n        int count = 0;\\n        while(curr){\\n            if(!curr->left){\\n                if(++count == k) ans = curr->val;\\n                curr = curr->right;\\n            } else{\\n                TreeNode* prev = curr->left;\\n                while(prev->right and prev->right != curr) prev = prev->right;\\n                if(!prev->right){\\n                    prev->right = curr;\\n                    curr = curr->left;\\n                } else{\\n                    prev->right = NULL;\\n                    if(++count == k) ans = curr->val;\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 913000,
                "title": "python-recursive-solution-using-inorder-traversal",
                "content": "```\\ndef kthSmallest(self, root: TreeNode, k: int) -> int:\\n        def inorder(root):\\n            if root is None:\\n                return []\\n            return inorder(root.left) + [root.val]  + inorder(root.right)\\n        \\n        ans = inorder(root)\\n        return ans[k-1]\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\ndef kthSmallest(self, root: TreeNode, k: int) -> int:\\n        def inorder(root):\\n            if root is None:\\n                return []\\n            return inorder(root.left) + [root.val]  + inorder(root.right)\\n        \\n        ans = inorder(root)\\n        return ans[k-1]\\n        \\n```",
                "codeTag": "Python3"
            },
            {
                "id": 567166,
                "title": "follow-up-o-h-query-bst",
                "content": "Assuming the tree is balanced, if not we can use RedBlack or AVl trees. My code uses BST, the main focus here is to explain the logic and AVL trees.\\n\\nIn order to solve this you can simply maintain, extra info. in each BST node i.e, size of left sub tree and size of right sub tree including node itself.\\n```\\n    public int kthSmallest(TreeNode root, int k) {\\n        BstNode copy = copy(null, root);\\n        return kthSmallest(copy, k);\\n    }\\n\\n    public int kthSmallest(BstNode root, int k) {\\n        if (root.lesser == k - 1) return root.val; //since there are k-1 elements in the left root itself is the kth element.\\n        if (root.lesser >= k) { //Kth element lies on left side.\\n            return kthSmallest(root.left, k);\\n        }\\n        return kthSmallest(root.right, k - root.lesser - 1);//kth elemtns lies on right side.\\n    }\\n\\n    private BstNode copy(BstNode target, TreeNode root) {\\n        if (root == null) return null;\\n        target = insert(target, root.val);\\n        copy(target, root.left);\\n//        target = insert(target, root.val);\\n        copy(target, root.right);\\n\\n        return target;\\n    }\\n\\n    BstNode insert(BstNode root, int k) {\\n        if (root == null) return new BstNode(k);\\n        if (k < root.val) {\\n            root.left = insert(root.left, k);\\n            root.lesser++;\\n            return root;\\n        } else {\\n            root.right = insert(root.right, k);\\n            root.greaterOrEqual++;\\n            return root;\\n        }\\n    }\\n\\n    private static class BstNode {\\n        int lesser = 0;\\n        int greaterOrEqual = 0;\\n        int val;\\n        int node;\\n        BstNode left;\\n        BstNode right;\\n\\n        public BstNode(int val) {\\n            this.val = val;\\n            lesser = 0;\\n            greaterOrEqual = 1;\\n        }\\n\\n    }\\n\\t\\t```",
                "solutionTags": [],
                "code": "```\\n    public int kthSmallest(TreeNode root, int k) {\\n        BstNode copy = copy(null, root);\\n        return kthSmallest(copy, k);\\n    }\\n\\n    public int kthSmallest(BstNode root, int k) {\\n        if (root.lesser == k - 1) return root.val; //since there are k-1 elements in the left root itself is the kth element.\\n        if (root.lesser >= k) { //Kth element lies on left side.\\n            return kthSmallest(root.left, k);\\n        }\\n        return kthSmallest(root.right, k - root.lesser - 1);//kth elemtns lies on right side.\\n    }\\n\\n    private BstNode copy(BstNode target, TreeNode root) {\\n        if (root == null) return null;\\n        target = insert(target, root.val);\\n        copy(target, root.left);\\n//        target = insert(target, root.val);\\n        copy(target, root.right);\\n\\n        return target;\\n    }\\n\\n    BstNode insert(BstNode root, int k) {\\n        if (root == null) return new BstNode(k);\\n        if (k < root.val) {\\n            root.left = insert(root.left, k);\\n            root.lesser++;\\n            return root;\\n        } else {\\n            root.right = insert(root.right, k);\\n            root.greaterOrEqual++;\\n            return root;\\n        }\\n    }\\n\\n    private static class BstNode {\\n        int lesser = 0;\\n        int greaterOrEqual = 0;\\n        int val;\\n        int node;\\n        BstNode left;\\n        BstNode right;\\n\\n        public BstNode(int val) {\\n            this.val = val;\\n            lesser = 0;\\n            greaterOrEqual = 1;\\n        }\\n\\n    }\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 566077,
                "title": "inorder-traversal-c-beats-99-45-in-time-100-space",
                "content": "```\\nclass Solution {\\n    bool foundKthSmallest(TreeNode* root, int &currCount, const int k, int &result) {\\n        if (root == nullptr)\\n            return false;\\n        \\n        if (foundKthSmallest(root->left, currCount, k, result))\\n            return true;\\n        \\n        currCount++;\\n        if (currCount == k)\\n        {\\n            result = root->val;\\n            return true;\\n        }\\n        \\n        if(foundKthSmallest(root->right, currCount, k, result))\\n            return true;\\n        \\n        return false;\\n    }\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        int res = INT_MAX;\\n        int currCount = 0;\\n        foundKthSmallest(root, currCount, k, res);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    bool foundKthSmallest(TreeNode* root, int &currCount, const int k, int &result) {\\n        if (root == nullptr)\\n            return false;\\n        \\n        if (foundKthSmallest(root->left, currCount, k, result))\\n            return true;\\n        \\n        currCount++;\\n        if (currCount == k)\\n        {\\n            result = root->val;\\n            return true;\\n        }\\n        \\n        if(foundKthSmallest(root->right, currCount, k, result))\\n            return true;\\n        \\n        return false;\\n    }\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        int res = INT_MAX;\\n        int currCount = 0;\\n        foundKthSmallest(root, currCount, k, res);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 536629,
                "title": "c-solutions-recursive-and-iterative",
                "content": "**Approach1: Recursive**\\n```\\npublic class Solution {\\n    \\n    public int count = 0;\\n    public int res = 0;\\n    \\n    public int KthSmallest(TreeNode root, int k) {\\n        \\n        Inorder(root, k);\\n        return res;\\n    }\\n    \\n    public void Inorder(TreeNode root, int k)\\n    {\\n        if(root == null)\\n            return;\\n        \\n        Inorder(root.left, k);\\n        \\n        count++;\\n        if(count == k)\\n            res = root.val;\\n        \\n        Inorder(root.right, k);\\n    }\\n}\\n```\\n\\n**Approach2: Recursive**\\n```\\npublic class Solution {\\n    \\n    public int res = -1;\\n    \\n    public int KthSmallest(TreeNode root, int k) {\\n        \\n        if(root == null)\\n            return -1;\\n        \\n\\t\\t// note: pass reference, otherwise the value of k won\\'t change in the calling method\\n        dfs(root, ref k);\\n        return res;\\n    }\\n    \\n    private void dfs(TreeNode root, ref int k)\\n    {\\n        if(root == null)\\n            return;\\n\\n        dfs(root.left, ref k);\\n        \\n        k--;\\n        if(k == 0)\\n        {\\n            res = root.val;\\n            return;\\n        }\\n        \\n        dfs(root.right, ref k);\\n    }\\n}\\n```\\n\\n**Approach3: Iterative**\\n```\\npublic class Solution {\\n    public int KthSmallest(TreeNode root, int k) {\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        TreeNode curr = root;\\n        int count = 0, res = 0;\\n        \\n        while(curr != null || stack.Count > 0)\\n        {\\n            while(curr != null)\\n            {\\n                stack.Push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            curr = stack.Pop();\\n            count++;\\n            if(count == k)\\n                res = curr.val;\\n            \\n            curr = curr.right;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    public int count = 0;\\n    public int res = 0;\\n    \\n    public int KthSmallest(TreeNode root, int k) {\\n        \\n        Inorder(root, k);\\n        return res;\\n    }\\n    \\n    public void Inorder(TreeNode root, int k)\\n    {\\n        if(root == null)\\n            return;\\n        \\n        Inorder(root.left, k);\\n        \\n        count++;\\n        if(count == k)\\n            res = root.val;\\n        \\n        Inorder(root.right, k);\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    \\n    public int res = -1;\\n    \\n    public int KthSmallest(TreeNode root, int k) {\\n        \\n        if(root == null)\\n            return -1;\\n        \\n\\t\\t// note: pass reference, otherwise the value of k won\\'t change in the calling method\\n        dfs(root, ref k);\\n        return res;\\n    }\\n    \\n    private void dfs(TreeNode root, ref int k)\\n    {\\n        if(root == null)\\n            return;\\n\\n        dfs(root.left, ref k);\\n        \\n        k--;\\n        if(k == 0)\\n        {\\n            res = root.val;\\n            return;\\n        }\\n        \\n        dfs(root.right, ref k);\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int KthSmallest(TreeNode root, int k) {\\n        \\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        TreeNode curr = root;\\n        int count = 0, res = 0;\\n        \\n        while(curr != null || stack.Count > 0)\\n        {\\n            while(curr != null)\\n            {\\n                stack.Push(curr);\\n                curr = curr.left;\\n            }\\n            \\n            curr = stack.Pop();\\n            count++;\\n            if(count == k)\\n                res = curr.val;\\n            \\n            curr = curr.right;\\n        }\\n        \\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 519979,
                "title": "rust-in-order-traversal-solution",
                "content": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn kth_smallest(root: Option<Rc<RefCell<TreeNode>>>, k: i32) -> i32 {\\n        let mut k = k;\\n        Solution::inorder(&root, &mut k).unwrap()\\n    }\\n    fn inorder(node: &Option<Rc<RefCell<TreeNode>>>, k: &mut i32) -> Option<i32> {\\n        if let Some(n) = node {\\n            if let Some(val) = Solution::inorder(&n.borrow().left, k) {\\n                return Some(val);\\n            }\\n            *k -= 1;\\n            if *k == 0 {\\n                return Some(n.borrow().val);\\n            }\\n            if let Some(val) = Solution::inorder(&n.borrow().right, k) {\\n                return Some(val);\\n            }\\n        }\\n        None\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nimpl Solution {\\n    pub fn kth_smallest(root: Option<Rc<RefCell<TreeNode>>>, k: i32) -> i32 {\\n        let mut k = k;\\n        Solution::inorder(&root, &mut k).unwrap()\\n    }\\n    fn inorder(node: &Option<Rc<RefCell<TreeNode>>>, k: &mut i32) -> Option<i32> {\\n        if let Some(n) = node {\\n            if let Some(val) = Solution::inorder(&n.borrow().left, k) {\\n                return Some(val);\\n            }\\n            *k -= 1;\\n            if *k == 0 {\\n                return Some(n.borrow().val);\\n            }\\n            if let Some(val) = Solution::inorder(&n.borrow().right, k) {\\n                return Some(val);\\n            }\\n        }\\n        None\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 507448,
                "title": "javascript-simple-iterative-solution",
                "content": "```\\nvar kthSmallest = function(root, k) {\\n    \\n    if(root== null) return null;\\n    \\n    let mini = 0;\\n    let stack = [];\\n    let temp ;\\n    while(true){\\n        if(root!== null){\\n            stack.push(root);\\n            root = root.left;\\n        }else{\\n            mini += 1;\\n            if(mini === k && stack.length !== 0) return stack[stack.length-1].val;\\n            else temp = stack.pop();\\n            root = temp.right; \\n        }\\n    }\\n    \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar kthSmallest = function(root, k) {\\n    \\n    if(root== null) return null;\\n    \\n    let mini = 0;\\n    let stack = [];\\n    let temp ;\\n    while(true){\\n        if(root!== null){\\n            stack.push(root);\\n            root = root.left;\\n        }else{\\n            mini += 1;\\n            if(mini === k && stack.length !== 0) return stack[stack.length-1].val;\\n            else temp = stack.pop();\\n            root = temp.right; \\n        }\\n    }\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 497404,
                "title": "python-easy-iterative-solution",
                "content": "```\\ndef kthSmallest(self, root, k):\\n\\t\\tstack = []\\n\\t\\t\\n        while True:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            elif stack:\\n                root = stack.pop()\\n                k -= 1\\n                \\n                if k == 0:\\n                    return root.val\\n                root = root.right\\n            else:\\n                break\\n```",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\ndef kthSmallest(self, root, k):\\n\\t\\tstack = []\\n\\t\\t\\n        while True:\\n            if root:\\n                stack.append(root)\\n                root = root.left\\n            elif stack:\\n                root = stack.pop()\\n                k -= 1\\n                \\n                if k == 0:\\n                    return root.val\\n                root = root.right\\n            else:\\n                break\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 296947,
                "title": "c-inorder-stack",
                "content": "```\\npublic class Solution {\\n    public int KthSmallest(TreeNode root, int k) {\\n        var stack = new Stack<TreeNode>();\\n        var cur = root;\\n        while (cur != null) {\\n            stack.Push(cur);\\n            cur = cur.left;\\n        }\\n\\n        while (stack.Any()) {\\n            cur = stack.Pop();\\n            if (k == 1) {\\n                return cur.val;\\n            }\\n            k--;\\n\\n            if (cur.right != null) {\\n                cur = cur.right;\\n                while (cur != null) {\\n                    stack.Push(cur);\\n                    cur = cur.left;\\n                }\\n            }\\n        }\\n\\n        throw new Exception(\"k is invalid.\");\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int KthSmallest(TreeNode root, int k) {\\n        var stack = new Stack<TreeNode>();\\n        var cur = root;\\n        while (cur != null) {\\n            stack.Push(cur);\\n            cur = cur.left;\\n        }\\n\\n        while (stack.Any()) {\\n            cur = stack.Pop();\\n            if (k == 1) {\\n                return cur.val;\\n            }\\n            k--;\\n\\n            if (cur.right != null) {\\n                cur = cur.right;\\n                while (cur != null) {\\n                    stack.Push(cur);\\n                    cur = cur.left;\\n                }\\n            }\\n        }\\n\\n        throw new Exception(\"k is invalid.\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 274182,
                "title": "c-iterative-inorder-with-early-termination-runtime-99-25",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        stack<TreeNode*> sta;\\n        int maxV = k;\\n\\t\\t\\n        while(sta.size() || root){\\n            while(root){\\n                sta.push(root);\\n                root = root->left;\\n            }\\n            TreeNode* top = sta.top();\\n            sta.pop();\\n            maxV--;\\n            if(maxV == 0)\\n                return top->val;\\n            root = top->right;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Iterator"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        stack<TreeNode*> sta;\\n        int maxV = k;\\n\\t\\t\\n        while(sta.size() || root){\\n            while(root){\\n                sta.push(root);\\n                root = root->left;\\n            }\\n            TreeNode* top = sta.top();\\n            sta.pop();\\n            maxV--;\\n            if(maxV == 0)\\n                return top->val;\\n            root = top->right;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63684,
                "title": "beautiful-java-solution-using-stack",
                "content": "```\\npublic class Solution {\\n    \\n    public int kthSmallest(TreeNode root, int k) {    \\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode cur = root;\\n        while (!stack.isEmpty() || cur != null) {\\n            while (cur != null) {\\n                stack.push(cur);\\n                cur = cur.left;\\n            }\\n            \\n            cur = stack.pop();\\n            if (--k == 0) {\\n                break;\\n            }\\n            \\n            cur = cur.right;\\n        }\\n        \\n        return cur.val;\\n    }\\n    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    public int kthSmallest(TreeNode root, int k) {    \\n        Stack<TreeNode> stack = new Stack<>();\\n        TreeNode cur = root;\\n        while (!stack.isEmpty() || cur != null) {\\n            while (cur != null) {\\n                stack.push(cur);\\n                cur = cur.left;\\n            }\\n            \\n            cur = stack.pop();\\n            if (--k == 0) {\\n                break;\\n            }\\n            \\n            cur = cur.right;\\n        }\\n        \\n        return cur.val;\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63728,
                "title": "java-inorder-recursive-solution-without-global-variant",
                "content": "```\\npublic class Solution {\\n    public int kthSmallest(TreeNode root, int k) {\\n        int[] index = new int[1];\\n        index[0] = k;\\n        return inorder(root, index);\\n    }\\n    \\n    public int inorder(TreeNode root, int[] index) {\\n        if(root == null) return -1;\\n        int left = inorder(root.left, index);\\n        if(left != -1) return left;\\n        index[0]--;\\n        if(index[0] == 0) return root.val;\\n        return inorder(root.right, index);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int kthSmallest(TreeNode root, int k) {\\n        int[] index = new int[1];\\n        index[0] = k;\\n        return inorder(root, index);\\n    }\\n    \\n    public int inorder(TreeNode root, int[] index) {\\n        if(root == null) return -1;\\n        int left = inorder(root.left, index);\\n        if(left != -1) return left;\\n        index[0]--;\\n        if(index[0] == 0) return root.val;\\n        return inorder(root.right, index);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 63784,
                "title": "java-solution-with-inorder-traversing-using-stack-easy-to-understand",
                "content": "    public class Solution {\\n    private Stack<TreeNode> s;\\n    public int kthSmallest(TreeNode root, int k) {\\n        s=new Stack<TreeNode>();\\n        if(root==null)  return 0;\\n        \\n        pushLeft(root);\\n        while(!s.empty()){\\n           \\n            TreeNode tn=s.pop();\\n            if(--k==0)\\n                return tn.val;\\n            if(tn.right!=null)  \\n                pushLeft(tn.right);\\n        }\\n        return 0;\\n    }\\n    private void pushLeft(TreeNode root){\\n        \\n        s.push(root);\\n        TreeNode p=root.left;\\n        while(p!=null){\\n            s.push(p);\\n            p=p.left;\\n            \\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    private Stack<TreeNode> s;\\n    public int kthSmallest(TreeNode root, int k) {\\n        s=new Stack<TreeNode>();\\n        if(root==null)  return 0;\\n        \\n        pushLeft(root);\\n        while(!s.empty()){\\n           \\n            TreeNode tn=s.pop();\\n            if(--k==0)\\n                return tn.val;\\n            if(tn.right!=null)  \\n                pushLeft(tn.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 63798,
                "title": "java-easy-recursive-solution-beats-95",
                "content": "        private int cnt=0;\\n    \\tprivate int res=0;\\n    \\tprivate boolean founded=false;\\n        public int kthSmallest(TreeNode root, int k) {\\n            helper(root,k);\\n            return res;\\n        }\\n        private void helper(TreeNode cur,int k){\\n        \\tif(!founded&&cur!=null){\\n        \\t\\thelper(cur.left,k);\\n        \\t\\tcnt++;\\n        \\t\\tif(cnt==k) {res=cur.val;founded=true;return;}\\n        \\t\\thelper(cur.right,k);\\n        \\t}\\n        }",
                "solutionTags": [],
                "code": "        private int cnt=0;\\n    \\tprivate int res=0;\\n    \\tprivate boolean founded=false;\\n        public int kthSmallest(TreeNode root, int k) {\\n            helper(root,k);\\n            return res;\\n        }\\n        private void helper(TreeNode cur,int k){\\n        \\tif(!founded&&cur!=null){\\n        \\t\\thelper(cur.left,k);\\n        \\t\\tcnt++;\\n        \\t\\tif(cnt==k) {res=cur.val;founded=true;return;}\\n        \\t\\thelper(cur.right,k);\\n        \\t}\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 63773,
                "title": "233333-summary-of-the-iterative-traversal-of-pre-order-in-order-post-order",
                "content": "**Update :  you can GET the\" RUN on OJ directly C++ implementation \" in the below  first answer .**\\n\\nFirst for the pre-order, it is easy to implement the stack-based iterative solution \\n\\n**Pre-Order-Non-recursion-Traversal ....**\\n\\n     1) Create an empty stack nodeStack and push root node to stack.\\n     2) Do following while nodeStack is not empty.\\n         \\u2026.a) Pop an item from stack and print it.\\n         \\u2026.b) Push right child of popped item to stack\\n         \\u2026.c) Push left child of popped item to stack\\n\\nHere is the C++ implementation :\\n\\n    // An iterative process to print preorder traversal of Binary tree\\n    void iterativePreorder(node *root)\\n    {\\n        // Base Case\\n        if (root == NULL)\\n           return;\\n     \\n        // Create an empty stack and push root to it\\n        stack<node *> nodeStack;\\n        nodeStack.push(root);\\n     \\n        /* Pop all items one by one. Do following for every popped item\\n           a) print it\\n           b) push its right child\\n           c) push its left child\\n        Note that right child is pushed first so that left is processed first */\\n        while (nodeStack.empty() == false)\\n        {\\n            // Pop the top item from stack and print it\\n            struct node *node = nodeStack.top();\\n            printf (\"%d \", node->data);\\n            nodeStack.pop();\\n     \\n            // Push right and left children of the popped node to stack\\n            if (node->right)\\n                nodeStack.push(node->right);\\n            if (node->left)\\n                nodeStack.push(node->left);\\n        }\\n    }\\n\\n**Inorder  Tree  Traversal  without  Recursion**\\n\\n       1) Create an empty stack S.\\n       2) Initialize current node as root\\n       3) Push the current node to S and set current = current->left until current is NULL\\n       4) If current is NULL and stack is not empty then \\n              a) Pop the top item from stack.\\n              b) Print the popped item, set current = popped_item->right \\n              c) Go to step 3.\\n       5) If current is NULL and stack is empty then we are done.\\n\\nHere is the C++ implementation ....\\n\\n    int In_Order_Traversal(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        \\n        while(root) {\\n            st.push(root);\\n            root = root->left;\\n        }\\n        \\n        while(!st.empty()) {\\n            TreeNode * n = st.top();\\n            st.pop();\\n            cout<<n->val<<endl;;\\n            TreeNode* right = n->right;\\n            while(right) {\\n                st.push(right);\\n                right = right->left;\\n            }\\n        }\\n        return 0;\\n    }\\n\\nHow about the Post-Order ?\\n\\n**Post-Order-Non-Recursive-Traversal**\\n\\nSolution 1 : **using 2 stacks**\\n\\n\\n  \\n\\n      int Post_Order_Traversal(TreeNode* root) {\\n            stack<TreeNode*> st1;\\n            stack<TreeNode*> st2;\\n            \\n            st1.push(root);\\n            while(!st1.empty()) {\\n                TreeNode* cur = st1.top();\\n                st2.push(cur);\\n                st1.pop();\\n                if(cur->left) st1.push(cur->left);\\n                if(cur->right) st1.push(cur->right);\\n            }\\n            while(!st2.empty()) {\\n                cout<<(st2.top())->val;\\n                st2.pop();\\n            }\\n            return 0;\\n        }\\n\\nSolution 2 , \\n\\nYou can also use one stack to do the post-order-traversal ....\\n\\nHere I do not talk about it .... YOU CAN refer to the below posts :\\n\\n[http://www.geeksforgeeks.org/iterative-postorder-traversal-using-stack/][1]\\n\\n\\n  [1]: http://www.geeksforgeeks.org/iterative-postorder-traversal-using-stack/",
                "solutionTags": [],
                "code": "**Update :  you can GET the\" RUN on OJ directly C++ implementation \" in the below  first answer .**\\n\\nFirst for the pre-order, it is easy to implement the stack-based iterative solution \\n\\n**Pre-Order-Non-recursion-Traversal ....**\\n\\n     1) Create an empty stack nodeStack and push root node to stack.\\n     2) Do following while nodeStack is not empty.\\n         \\u2026.a) Pop an item from stack and print it.\\n         \\u2026.b) Push right child of popped item to stack\\n         \\u2026.c) Push left child of popped item to stack\\n\\nHere is the C++ implementation :\\n\\n    // An iterative process to print preorder traversal of Binary tree\\n    void iterativePreorder(node *root)\\n    {\\n        // Base Case\\n        if (root == NULL)\\n           return;\\n     \\n        // Create an empty stack and push root to it\\n        stack<node *> nodeStack;\\n        nodeStack.push(root);\\n     \\n        /* Pop all items one by one. Do following for every popped item\\n           a) print it\\n           b) push its right child\\n           c) push its left child\\n        Note that right child is pushed first so that left is processed first */\\n        while (nodeStack.empty() == false)\\n        {\\n            // Pop the top item from stack and print it\\n            struct node *node = nodeStack.top();\\n            printf (\"%d \", node->data);\\n            nodeStack.pop();\\n     \\n            // Push right and left children of the popped node to stack\\n            if (node->right)\\n                nodeStack.push(node->right);\\n            if (node->left)\\n                nodeStack.push(node->left);\\n        }\\n    }\\n\\n**Inorder  Tree  Traversal  without  Recursion**\\n\\n       1) Create an empty stack S.\\n       2) Initialize current node as root\\n       3) Push the current node to S and set current = current->left until current is NULL\\n       4) If current is NULL and stack is not empty then \\n              a) Pop the top item from stack.\\n              b) Print the popped item, set current = popped_item->right \\n              c) Go to step 3.\\n       5) If current is NULL and stack is empty then we are done.\\n\\nHere is the C++ implementation ....\\n\\n    int In_Order_Traversal(TreeNode* root) {\\n        stack<TreeNode*> st;\\n        \\n        while(root) {\\n            st.push(root);\\n            root = root->left;\\n        }\\n        \\n        while(!st.empty()) {\\n            TreeNode * n = st.top();\\n            st.pop();\\n            cout<<n->val<<endl;;\\n            TreeNode* right = n->right;\\n            while(right) {\\n                st.push(right);\\n                right = right->left;\\n            }\\n        }\\n        return 0;\\n    }\\n\\nHow about the Post-Order ?\\n\\n**Post-Order-Non-Recursive-Traversal**\\n\\nSolution 1 : **using 2 stacks**\\n\\n\\n  \\n\\n      int Post_Order_Traversal(TreeNode* root) {\\n            stack<TreeNode*> st1;\\n            stack<TreeNode*> st2;\\n            \\n            st1.push(root);\\n            while(!st1.empty()) {\\n                TreeNode* cur = st1.top();\\n                st2.push(cur);\\n                st1.pop();\\n                if(cur->left) st1.push(cur->left);\\n                if(cur->right) st1.push(cur->right);\\n            }\\n            while(!st2.empty()) {\\n                cout<<(st2.top())->val;\\n                st2.pop();\\n            }\\n            return 0;\\n        }\\n\\nSolution 2 , \\n\\nYou can also use one stack to do the post-order-traversal ....\\n\\nHere I do not talk about it .... YOU CAN refer to the below posts :\\n\\n[http://www.geeksforgeeks.org/iterative-postorder-traversal-using-stack/][1]\\n\\n\\n  [1]: http://www.geeksforgeeks.org/iterative-postorder-traversal-using-stack/",
                "codeTag": "C++"
            },
            {
                "id": 63853,
                "title": "iterative-inorder-traversal-in-java-using-stack",
                "content": "    // inorder traversal\\n    public int kthSmallest(TreeNode root, int k) {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        stack.push(root);\\n        TreeNode node = root;\\n        int count = 0;\\n        // node == null, might get to the leaf but stack is not empty\\n        while(node!=null || !stack.isEmpty()){\\n            while(node!=null){\\n                stack.push(node);\\n                node = node.left;\\n            } \\n            node = stack.pop();\\n            count++;\\n            if(count==k) return node.val;\\n            node = node.right;\\n        }\\n        return -1;\\n    }",
                "solutionTags": [
                    "Java",
                    "Binary Search",
                    "Stack",
                    "Tree"
                ],
                "code": "    // inorder traversal\\n    public int kthSmallest(TreeNode root, int k) {\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        stack.push(root);\\n        TreeNode node = root;\\n        int count = 0;\\n        // node == null, might get to the leaf but stack is not empty\\n        while(node!=null || !stack.isEmpty()){\\n            while(node!=null){\\n                stack.push(node);\\n                node = node.left;\\n            } \\n            node = stack.pop();\\n            count++;\\n            if(count==k) return node.val;\\n            node = node.right;\\n        }\\n        return -1;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 63814,
                "title": "o-h-complexity-by-add-left-subtree-node-count-into-treenode-structure",
                "content": "Modify TreeNode structure and add left subtree node count and find kth smallest element base on (http://www.geeksforgeeks.org/find-k-th-smallest-element-in-bst-order-statistics-in-bst/)\\n\\nThe idea is to maintain rank of each node. We can keep track of elements in a subtree of any node while building the tree. Since we need K-th smallest element, we can maintain number of elements of left subtree in every node.\\n\\nAssume that the root is having N nodes in its left subtree. If K = N + 1, root is K-th node. If K < N, we will continue our search (recursion) for the Kth smallest element in the left subtree of root. If K > N + 1, we continue our search in the right subtree for the (K \\u2013 N \\u2013 1)-th smallest element. Note that we need the count of elements in left subtree only.   \\n\\n1.travel tree by level and insert node into TreeNodeWithCount Tree.\\n\\n2.find kth smallest in the TreeNodeWithCount Tree.\\n        \\n    public class TreeNodeWithCount {\\n        int val;\\n        int lCount;\\n        TreeNodeWithCount left;\\n        TreeNodeWithCount right;\\n        TreeNodeWithCount(int x) { val = x; }\\n    }\\n    \\n    public int kthSmallest(TreeNode root, int k) {\\n        if(root == null) return -1;\\n        TreeNodeWithCount rootWithCount = createBSTWithCount(root);\\n        return kthSmallestWithCount(rootWithCount, k);\\n    }\\n    \\n    public TreeNodeWithCount createBSTWithCount(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.add(root);\\n        TreeNodeWithCount rootWithCount = null;\\n        while(!queue.isEmpty()) {\\n            TreeNode node = queue.remove();\\n            TreeNodeWithCount nodeWithCount = new TreeNodeWithCount(node.val);\\n            rootWithCount = insertBSTWithCount(rootWithCount, nodeWithCount);\\n            if(node.left != null) queue.add(node.left);\\n            if(node.right != null) queue.add(node.right);\\n        }\\n        return rootWithCount;\\n    }\\n    \\n    public TreeNodeWithCount insertBSTWithCount(TreeNodeWithCount rootWithCount, TreeNodeWithCount nodeWithCount) {\\n        TreeNodeWithCount cur = rootWithCount, parent = rootWithCount;\\n        while(cur != null) {\\n            parent = cur;\\n            if(nodeWithCount.val < cur.val) {\\n                cur.lCount++;\\n                cur = cur.left;\\n            } else {\\n                cur = cur.right;\\n            }\\n        }\\n        if(rootWithCount == null) {\\n            rootWithCount = nodeWithCount;\\n        } else if(nodeWithCount.val < parent.val) {\\n            parent.left = nodeWithCount;\\n        } else {\\n            parent.right = nodeWithCount;\\n        }\\n        return rootWithCount;\\n    }\\n    \\n    public int kthSmallestWithCount(TreeNodeWithCount rootWithCount, int k) {\\n        while(rootWithCount != null) {\\n            if(k == rootWithCount.lCount + 1) {\\n                return rootWithCount.val;\\n            } else if(k <= rootWithCount.lCount) {\\n                rootWithCount = rootWithCount.left;\\n            } else {\\n                k = k - rootWithCount.lCount - 1;\\n                rootWithCount = rootWithCount.right;\\n            }\\n        }\\n        return -1;\\n    }",
                "solutionTags": [],
                "code": "Modify TreeNode structure and add left subtree node count and find kth smallest element base on (http://www.geeksforgeeks.org/find-k-th-smallest-element-in-bst-order-statistics-in-bst/)\\n\\nThe idea is to maintain rank of each node. We can keep track of elements in a subtree of any node while building the tree. Since we need K-th smallest element, we can maintain number of elements of left subtree in every node.\\n\\nAssume that the root is having N nodes in its left subtree. If K = N + 1, root is K-th node. If K < N, we will continue our search (recursion) for the Kth smallest element in the left subtree of root. If K > N + 1, we continue our search in the right subtree for the (K \\u2013 N \\u2013 1)-th smallest element. Note that we need the count of elements in left subtree only.   \\n\\n1.travel tree by level and insert node into TreeNodeWithCount Tree.\\n\\n2.find kth smallest in the TreeNodeWithCount Tree.\\n        \\n    public class TreeNodeWithCount {\\n        int val;\\n        int lCount;\\n        TreeNodeWithCount left;\\n        TreeNodeWithCount right;\\n        TreeNodeWithCount(int x) { val = x; }\\n    }\\n    \\n    public int kthSmallest(TreeNode root, int k) {\\n        if(root == null) return -1;\\n        TreeNodeWithCount rootWithCount = createBSTWithCount(root);\\n        return kthSmallestWithCount(rootWithCount, k);\\n    }\\n    \\n    public TreeNodeWithCount createBSTWithCount(TreeNode root) {\\n        Queue<TreeNode> queue = new LinkedList<TreeNode>();\\n        queue.add(root);\\n        TreeNodeWithCount rootWithCount = null;\\n        while(!queue.isEmpty()) {\\n            TreeNode node = queue.remove();\\n            TreeNodeWithCount nodeWithCount = new TreeNodeWithCount(node.val);\\n            rootWithCount = insertBSTWithCount(rootWithCount, nodeWithCount);\\n            if(node.left != null) queue.add(node.left);\\n            if(node.right != null) queue.add(node.right);\\n        }\\n        return rootWithCount;\\n    }\\n    \\n    public TreeNodeWithCount insertBSTWithCount(TreeNodeWithCount rootWithCount, TreeNodeWithCount nodeWithCount) {\\n        TreeNodeWithCount cur = rootWithCount, parent = rootWithCount;\\n        while(cur != null) {\\n            parent = cur;\\n            if(nodeWithCount.val < cur.val) {\\n                cur.lCount++;\\n                cur = cur.left;\\n            } else {\\n                cur = cur.right;\\n            }\\n        }\\n        if(rootWithCount == null) {\\n            rootWithCount = nodeWithCount;\\n        } else if(nodeWithCount.val < parent.val) {\\n            parent.left = nodeWithCount;\\n        } else {\\n            parent.right = nodeWithCount;\\n        }\\n        return rootWithCount;\\n    }\\n    \\n    public int kthSmallestWithCount(TreeNodeWithCount rootWithCount, int k) {\\n        while(rootWithCount != null) {\\n            if(k == rootWithCount.lCount + 1) {\\n                return rootWithCount.val;\\n            } else if(k <= rootWithCount.lCount) {\\n                rootWithCount = rootWithCount.left;\\n            } else {\\n                k = k - rootWithCount.lCount - 1;\\n                rootWithCount = rootWithCount.right;\\n            }\\n        }\\n        return -1;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 63799,
                "title": "o-n-time-o-1-space-by-using-morris-inorder-traverse",
                "content": "    public class Solution {\\n        public int kthSmallest(TreeNode root, int k) {\\n    \\t\\tTreeNode now  = root;\\n    \\t\\tint count = k;\\n    \\t\\twhile (now != null) {\\n    \\t\\t\\tif (now.left != null) {\\n    \\t\\t\\t\\tTreeNode left = now.left;\\n    \\t\\t\\t\\twhile (left.right != null && left.right != now) {\\n    \\t\\t\\t\\t\\tleft = left.right;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tif (left.right == null) {\\n    \\t\\t\\t\\t\\tleft.right = now;\\n    \\t\\t\\t\\t\\tnow = now.left;\\n    \\t\\t\\t\\t} else {\\n    \\t\\t\\t\\t\\tleft.right = null;\\n    \\t\\t\\t\\t\\tcount--;\\n    \\t\\t\\t\\t\\tif (count == 0)\\n    \\t\\t\\t\\t\\t\\treturn now.val;\\n    \\t\\t\\t\\t\\tnow = now.right;\\t\\t\\t\\t\\t\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t} else {\\n    \\t\\t\\t\\tcount --;\\n    \\t\\t\\t\\tif (count == 0) {\\n    \\t\\t\\t\\t\\treturn now.val;\\n    \\t\\t\\t\\t}\\n    \\t\\t\\t\\tnow = now.right;\\n    \\t\\t\\t\\t\\n    \\t\\t\\t}\\t\\t\\t\\n    \\t\\t}\\n    \\t\\treturn -1;\\n        }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n        public int kthSmallest(TreeNode root, int k) {\\n    \\t\\tTreeNode now  = root;\\n    \\t\\tint count = k;\\n    \\t\\twhile (now != null) {\\n    \\t\\t\\tif (now.left != null) {\\n    \\t\\t\\t\\tTreeNode left = now.left;\\n    \\t\\t\\t\\twhile (left.right != null && left.right != now) {\\n    \\t\\t\\t\\t\\tleft = left.right;\\n    \\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 63746,
                "title": "c-solution-counting-numbers-of-left-tree",
                "content": "class Solution {\\n\\npublic:\\n\\n    int kthSmallest(TreeNode* root, int k) {\\n        if (!root) return 0;\\n        if (k==0) return root->val;\\n        \\n        int n=count_size(root->left);\\n        if (k==n+1) return root->val;\\n        \\n        if (n>=k){\\n            return kthSmallest(root->left, k);\\n        }\\n        if (n<k){\\n            return kthSmallest(root->right, k-n-1);\\n        }\\n        \\n    }\\n\\n    int count_size(TreeNode* root){\\n        if (!root) return 0;\\n        return 1+count_size(root->left)+count_size(root->right);\\n        \\n    }\\n  \\n};",
                "solutionTags": [
                    "C++",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\npublic:\\n\\n    int kthSmallest(TreeNode* root, int k) {\\n        if (!root) return 0;\\n        if (k==0) return root->val;\\n        \\n        int n=count_size(root->left);\\n        if (k==n+1) return root->val;\\n        \\n        if (n>=k){\\n            return kthSmallest(root->left, k);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 63925,
                "title": "easy-to-understand-java-solution",
                "content": "    public class Solution {\\n        public int kthSmallest(TreeNode root, int k) {\\n            int leftNum = countNodes(root.left);\\n            \\n            if (leftNum + 1 == k)\\n                return root.val;\\n            else if (leftNum  + 1 > k) {\\n                return kthSmallest(root.left, k);\\n            }\\n            else\\n                return kthSmallest(root.right, k - leftNum - 1);\\n        }\\n        \\n        private int countNodes(TreeNode root) {\\n            if (root == null)\\n                return 0;\\n            \\n            return 1 + countNodes(root.left) + countNodes(root.right);\\n        }\\n    }\\n\\n\\n\\nThe idea is to determine where the target falls (left side, the root, or the right side) at each level.",
                "solutionTags": [],
                "code": "class Solution {\\n        public int kthSmallest(TreeNode root, int k) {\\n            int leftNum = countNodes(root.left);\\n            \\n            if (leftNum + 1 == k)\\n                return root.val;\\n            else if (leftNum  + 1 > k) {\\n                return kthSmallest(root.left, k);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 63947,
                "title": "1-liner-in-ruby",
                "content": "Just do a recursive inorder traversal and stop at the k-th element and return that.\\n\\n    def kth_smallest(root, k)\\n        (f=->r{r&&(f[r.left]or(k-=1)<1?r.val: f[r.right])})[root]\\n    end\\n\\nHere's a more readable version:\\n\\n    def kth_smallest(root, k)\\n        find = -> root { root && (find[root.left] or\\n                                  (k-=1) == 0 ? root.val :\\n                                  find[root.right]) }\\n        find[root]\\n    end\\n\\nAt each actual node, search the wanted element in the left subtree. If found, return it right away. Otherwise, if decrementing `k` makes it zero, return the value of the current node. Otherwise, return what a search in the right subtree produces.",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "Just do a recursive inorder traversal and stop at the k-th element and return that.\\n\\n    def kth_smallest(root, k)\\n        (f=->r{r&&(f[r.left]or(k-=1)<1?r.val: f[r.right])})[root]\\n    end\\n\\nHere's a more readable version:\\n\\n    def kth_smallest(root, k)\\n        find = -> root { root && (find[root.left] or\\n                                  (k-=1) == 0 ? root.val :\\n                                  find[root.right]) }\\n        find[root]\\n    end\\n\\nAt each actual node, search the wanted element in the left subtree. If found, return it right away. Otherwise, if decrementing `k` makes it zero, return the value of the current node. Otherwise, return what a search in the right subtree produces.",
                "codeTag": "Python3"
            },
            {
                "id": 4092397,
                "title": "queue-dfs-solution-beats-100-of-c-users",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* This is a binary search tree. \\n* so smaller nodes are on the left, and larger ones are on the right. \\n* so the smallest node should be on the leftmost node. \\n* so we can just have a queue, and whenever we reach the left most node, we can insert the node into that node, then, while coming back insert its parent, then go check the right side. \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* we need to iterate over the whole tree, having a queue container to insert the nodes sorted inside it ascendingly. \\n* so we will just need to apply simple dfs on the Tree \\n## dfs (root, nodes queue)\\n### Return type and parameters\\n* This function is a void function, used just to iterate over all nodes. \\n* it takes a treenode pointer, which indicates the current node. \\n* and it takes queue of TreeNode pointers by reference in which we sort the nodes inside it. \\n### basecases \\n1. if we got empty tree, then we need just to return.\\n2. if we have reached a leaf, then we need to insert the leaf to the queue, as it is now the smallest element, after reaching that point.\\n### recursive cases \\n1. if the current node has no left child, then this means that it is the smallest node currently, so we need to insert it into the nodes queue, and check on the right subtree. \\n2. if the current node has no right subtree, then we need to continue iterating, and after coming back from that subtree, we should insert the current node, because we will return to its parent, as it is now its turn to be inserted. NOTICE THAT: if it was less than its parent, then it should be inserted before him, and if it was larger than him, so we have already inserted its parent before, so also it is now its turn to be inserted. \\n3. otherwise, this is a normal case, where the node has left child and right child, so we need to go to the left subtree, then after we come back from that call, we should insert the root into the queue, then after that we should call the right subtree.\\n\\n## kthSmallest(root, k)\\n* this is the main function.\\n### Return type and parameters\\n* it return int which is the kth smallest node value in the binary search tree. \\n* it takes root which is the root of the BST. \\n* it takes k which is the order of the node. \\n### body logic\\n* create a new queue of TreeNode pointers. \\n* call dfs. \\n* loop while k > 0\\n    * remove that node from the queue.\\n* after you exit from the queue, then the front node is the node which we are looking for.  \\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n- O(n + k) as we iterate over each node only once. \\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n- O(n) where n is the size of the tree.\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n \\nvoid dfs(TreeNode *root, queue<TreeNode *> &nodes)\\n{\\n    // empty tree\\n    if (!root)\\n        return;\\n    // leaf node\\n    if (!root->left && !root->right)\\n    {\\n        nodes.push(root);\\n        return;\\n    }\\n    // has right child only\\n    if (!root->left)\\n    {\\n        nodes.push(root);\\n        dfs(root->right, nodes);\\n    }else  if (!root->right){\\n        // has left child only\\n        dfs(root->left, nodes); \\n        nodes.push(root);\\n    }else {\\n        // has both children\\n        dfs(root->left, nodes); \\n        nodes.push(root);\\n        dfs(root->right, nodes);\\n    }\\n}\\n\\nint kthSmallest(TreeNode *root, int k)\\n{\\n    queue<TreeNode*> nodes ;\\n    dfs(root, nodes);\\n    while (--k)\\n        nodes.pop(); \\n    return nodes.front()->val;  \\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Recursion",
                    "Queue",
                    "Sorting",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n \\nvoid dfs(TreeNode *root, queue<TreeNode *> &nodes)\\n{\\n    // empty tree\\n    if (!root)\\n        return;\\n    // leaf node\\n    if (!root->left && !root->right)\\n    {\\n        nodes.push(root);\\n        return;\\n    }\\n    // has right child only\\n    if (!root->left)\\n    {\\n        nodes.push(root);\\n        dfs(root->right, nodes);\\n    }else  if (!root->right){\\n        // has left child only\\n        dfs(root->left, nodes); \\n        nodes.push(root);\\n    }else {\\n        // has both children\\n        dfs(root->left, nodes); \\n        nodes.push(root);\\n        dfs(root->right, nodes);\\n    }\\n}\\n\\nint kthSmallest(TreeNode *root, int k)\\n{\\n    queue<TreeNode*> nodes ;\\n    dfs(root, nodes);\\n    while (--k)\\n        nodes.pop(); \\n    return nodes.front()->val;  \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4024144,
                "title": "inorder-time-99-83-space-99-71",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\nint k=3,ans=0; //k->dummy value\\n    void helper(TreeNode* root){\\n        if(root==NULL || k==0){return;}\\n        helper(root->left);\\n        if(k==1){ans=root->val;k=0;return;}\\n        else{k--;}\\n        helper(root->right);\\n    }\\n    int kthSmallest(TreeNode* root, int j) {\\n        k=j;\\n        helper(root);\\n        root->left=NULL;root->right=NULL;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint k=3,ans=0; //k->dummy value\\n    void helper(TreeNode* root){\\n        if(root==NULL || k==0){return;}\\n        helper(root->left);\\n        if(k==1){ans=root->val;k=0;return;}\\n        else{k--;}\\n        helper(root->right);\\n    }\\n    int kthSmallest(TreeNode* root, int j) {\\n        k=j;\\n        helper(root);\\n        root->left=NULL;root->right=NULL;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3870004,
                "title": "most-easiest-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nInorder Traversal of BST is always ascending\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nDo Inorder traversal of BST and Store in ArrayList.\\nThen the arrayList will Contains elements in ascending order.\\nJust return the element at k-1 index using list.get(k-1). \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void inorder(TreeNode root,ArrayList<Integer> list)\\n    {\\n        if(root==null)\\n        {\\n            return ;\\n        }\\n        inorder(root.left,list);\\n        list.add(root.val);\\n        inorder(root.right,list);\\n    }\\n    public int kthSmallest(TreeNode root, int k) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        inorder(root,list);\\n        return list.get(k-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void inorder(TreeNode root,ArrayList<Integer> list)\\n    {\\n        if(root==null)\\n        {\\n            return ;\\n        }\\n        inorder(root.left,list);\\n        list.add(root.val);\\n        inorder(root.right,list);\\n    }\\n    public int kthSmallest(TreeNode root, int k) {\\n        ArrayList<Integer> list=new ArrayList<>();\\n        inorder(root,list);\\n        return list.get(k-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3762065,
                "title": "beginner-friendly-solution-only-arraylist-used",
                "content": "# Intuition\\nsimple property of bst\\n\\n# Approach\\nwe know inorder traversal of BST gives sorted sequence \\nthen just find k-1 th element  \\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int kthSmallest(TreeNode root, int k) {\\n        ArrayList<Integer> arr=new ArrayList<>();\\n        inorder(root,arr);\\n        return arr.get(k-1);\\n    }\\n    public static void inorder(TreeNode root,ArrayList<Integer> arr){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left,arr);\\n        arr.add(root.val);\\n        inorder(root.right,arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int kthSmallest(TreeNode root, int k) {\\n        ArrayList<Integer> arr=new ArrayList<>();\\n        inorder(root,arr);\\n        return arr.get(k-1);\\n    }\\n    public static void inorder(TreeNode root,ArrayList<Integer> arr){\\n        if(root==null){\\n            return;\\n        }\\n        inorder(root.left,arr);\\n        arr.add(root.val);\\n        inorder(root.right,arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3710107,
                "title": "easy-c-solution-beat-95",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* &root, int &k) {\\n        if(root==NULL)\\n        return -1;\\n        int leftans=kthSmallest(root->left,k);\\n        if(leftans!=-1)\\n            return leftans;\\n        k--;\\n        if(k==0)\\n        return root->val;\\n        int rightans=kthSmallest(root->right,k);\\n        return rightans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int kthSmallest(TreeNode* &root, int &k) {\\n        if(root==NULL)\\n        return -1;\\n        int leftans=kthSmallest(root->left,k);\\n        if(leftans!=-1)\\n            return leftans;\\n        k--;\\n        if(k==0)\\n        return root->val;\\n        int rightans=kthSmallest(root->right,k);\\n        return rightans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1723768,
                "content": [
                    {
                        "username": "Vicky_Prasad",
                        "content": "My Dummy Approach:\\nGet Inorder of BST and then return k-1 index value.\\nIts simple way to solve this problem."
                    },
                    {
                        "username": "firby121",
                        "content": "[@logical_thinker](/logical_thinker) if you use an array to store all elements then there\\'s no point of using the tree itself. max heap with size k is the way to go."
                    },
                    {
                        "username": "logical_thinker",
                        "content": "I think this is right approach, there is a catch here, when ever there is a insertion or a deletion we don\\'t traverse the tree again we just perform on the array that we have got when we do in-order initially, as in-order fetches us a sorted array we can insert into the array with complexity n and delete works the same way as well. So this is a better solution I think not a dummy one."
                    },
                    {
                        "username": "Evercode",
                        "content": "I think we can keep both the kth smallest element and (k-1)th smallest element. If we insert or delete an element larger than the kth smallest element, the result remains unaffected. If something smaller than is inserted, compare it with the (k-1)th smallest element. The larger one becomes the new kth smallest element and adjust (k-1)th element accordingly.\\nWe may also need to keep track of the (k+1)th smallest element in case of deleting a node smaller than the kth element. However if we keep deleting nodes, we may need the (k+2, k+3, .... )th smallest element to stay correct.\\nAny other ideas?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Using a max heap of size k would be easier to maintain"
                    },
                    {
                        "username": "SR2311",
                        "content": "When you are constructing the BST, at every node maintain a count - which is the number of nodes smaller than current node[ in other words number of nodes to the left of current node]. Also every node has a pointer which points to  it parent [ this is to handle the case when a node is deleted from the BST] .\\n\\nNow lets say everything is done and query comes:\\n\\t Starting at root in O(1) you know if your k is the left half of right half by comparing k with the count of current node. If k is smaller than the count that means our answer lies in the left half otherwise it is in the right half. Keep repeating this until we find our node\\n\\t \\nInsert Operation:\\nJust do normal BST insert and ensure to increment the count of the node if you are going down left of the tree and once you find the spot to insert assign the parent to the node.\\n\\nDelete operation:\\nConsider deleting some x node now since we have reference to the parent of every node we simply check if the node being deleted is to left or right of parent by comparing its value and if it is in the left simply decrement the count of the parent.\\n"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "basically you are keeping track of inorder predecessor and successor for each node so that when insertion/deletion occurs, you can go to next/previous node in O(1) time."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Inorder Traversal\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arch11Tech",
                        "content": "Follow up:\\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\\n\\nI think this is about find next smallest element in BST, with time complexity being O(log(n))\\nwhich should be better than O(k)\\n\\nRight?"
                    },
                    {
                        "username": "dan_stark123",
                        "content": "I think you need to come up with some logic that decides to minimize the search space ,after a node is deleted or inserted\\n"
                    },
                    {
                        "username": "pygirl5",
                        "content": "![image](https://assets.leetcode.com/users/pygirl5/image_1579402446.png)\\n@Leetcode could you please correct this?\\nThanks in advance!\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "just a tip:\\ndo in-order traversal to get the sorted array or u can do any BFS/DFS and get the array and sort it \\nthen return the array\\'s \"k-1\"th element"
                    },
                    {
                        "username": "pinkfloyda",
                        "content": "From what I can tell, the running time is O(height of BST) + O(k), optimal means lower bound?"
                    },
                    {
                        "username": "npostavs",
                        "content": "[@brandon_busby](/brandon_busby) The tree is sorted so you don\\'t have to look at all of the nodes. E.g., if `k =1`, just go down to the left-most node and don\\'t visit any others (that\\'s `O(height)`). For larger `k` you need to visit `k` more."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "That seems like the memory requirement, not the running time. The best conceivable running time is `O(number of nodes)` since you have to look at all nodes."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "We know InOrder traversal of BST is ascending order list. So, return k-1th element."
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "is it the most optimise solution for this problem and for the follow up given for this problem ???\\n"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here are my 4 methods to solve the problem:\\n-> Binary Search\\n-> Recursive\\n-> Iterative\\n-> Morris Traversal\\n[LeetCode Solution](https://techgeekyan.blogspot.ca/2017/09/leetcode-solution-230-kth-smallest.html)"
                    },
                    {
                        "username": "victCh",
                        "content": "What is kth smallest value???"
                    }
                ]
            },
            {
                "id": 1565529,
                "content": [
                    {
                        "username": "Vicky_Prasad",
                        "content": "My Dummy Approach:\\nGet Inorder of BST and then return k-1 index value.\\nIts simple way to solve this problem."
                    },
                    {
                        "username": "firby121",
                        "content": "[@logical_thinker](/logical_thinker) if you use an array to store all elements then there\\'s no point of using the tree itself. max heap with size k is the way to go."
                    },
                    {
                        "username": "logical_thinker",
                        "content": "I think this is right approach, there is a catch here, when ever there is a insertion or a deletion we don\\'t traverse the tree again we just perform on the array that we have got when we do in-order initially, as in-order fetches us a sorted array we can insert into the array with complexity n and delete works the same way as well. So this is a better solution I think not a dummy one."
                    },
                    {
                        "username": "Evercode",
                        "content": "I think we can keep both the kth smallest element and (k-1)th smallest element. If we insert or delete an element larger than the kth smallest element, the result remains unaffected. If something smaller than is inserted, compare it with the (k-1)th smallest element. The larger one becomes the new kth smallest element and adjust (k-1)th element accordingly.\\nWe may also need to keep track of the (k+1)th smallest element in case of deleting a node smaller than the kth element. However if we keep deleting nodes, we may need the (k+2, k+3, .... )th smallest element to stay correct.\\nAny other ideas?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Using a max heap of size k would be easier to maintain"
                    },
                    {
                        "username": "SR2311",
                        "content": "When you are constructing the BST, at every node maintain a count - which is the number of nodes smaller than current node[ in other words number of nodes to the left of current node]. Also every node has a pointer which points to  it parent [ this is to handle the case when a node is deleted from the BST] .\\n\\nNow lets say everything is done and query comes:\\n\\t Starting at root in O(1) you know if your k is the left half of right half by comparing k with the count of current node. If k is smaller than the count that means our answer lies in the left half otherwise it is in the right half. Keep repeating this until we find our node\\n\\t \\nInsert Operation:\\nJust do normal BST insert and ensure to increment the count of the node if you are going down left of the tree and once you find the spot to insert assign the parent to the node.\\n\\nDelete operation:\\nConsider deleting some x node now since we have reference to the parent of every node we simply check if the node being deleted is to left or right of parent by comparing its value and if it is in the left simply decrement the count of the parent.\\n"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "basically you are keeping track of inorder predecessor and successor for each node so that when insertion/deletion occurs, you can go to next/previous node in O(1) time."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Inorder Traversal\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arch11Tech",
                        "content": "Follow up:\\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\\n\\nI think this is about find next smallest element in BST, with time complexity being O(log(n))\\nwhich should be better than O(k)\\n\\nRight?"
                    },
                    {
                        "username": "dan_stark123",
                        "content": "I think you need to come up with some logic that decides to minimize the search space ,after a node is deleted or inserted\\n"
                    },
                    {
                        "username": "pygirl5",
                        "content": "![image](https://assets.leetcode.com/users/pygirl5/image_1579402446.png)\\n@Leetcode could you please correct this?\\nThanks in advance!\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "just a tip:\\ndo in-order traversal to get the sorted array or u can do any BFS/DFS and get the array and sort it \\nthen return the array\\'s \"k-1\"th element"
                    },
                    {
                        "username": "pinkfloyda",
                        "content": "From what I can tell, the running time is O(height of BST) + O(k), optimal means lower bound?"
                    },
                    {
                        "username": "npostavs",
                        "content": "[@brandon_busby](/brandon_busby) The tree is sorted so you don\\'t have to look at all of the nodes. E.g., if `k =1`, just go down to the left-most node and don\\'t visit any others (that\\'s `O(height)`). For larger `k` you need to visit `k` more."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "That seems like the memory requirement, not the running time. The best conceivable running time is `O(number of nodes)` since you have to look at all nodes."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "We know InOrder traversal of BST is ascending order list. So, return k-1th element."
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "is it the most optimise solution for this problem and for the follow up given for this problem ???\\n"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here are my 4 methods to solve the problem:\\n-> Binary Search\\n-> Recursive\\n-> Iterative\\n-> Morris Traversal\\n[LeetCode Solution](https://techgeekyan.blogspot.ca/2017/09/leetcode-solution-230-kth-smallest.html)"
                    },
                    {
                        "username": "victCh",
                        "content": "What is kth smallest value???"
                    }
                ]
            },
            {
                "id": 1565704,
                "content": [
                    {
                        "username": "Vicky_Prasad",
                        "content": "My Dummy Approach:\\nGet Inorder of BST and then return k-1 index value.\\nIts simple way to solve this problem."
                    },
                    {
                        "username": "firby121",
                        "content": "[@logical_thinker](/logical_thinker) if you use an array to store all elements then there\\'s no point of using the tree itself. max heap with size k is the way to go."
                    },
                    {
                        "username": "logical_thinker",
                        "content": "I think this is right approach, there is a catch here, when ever there is a insertion or a deletion we don\\'t traverse the tree again we just perform on the array that we have got when we do in-order initially, as in-order fetches us a sorted array we can insert into the array with complexity n and delete works the same way as well. So this is a better solution I think not a dummy one."
                    },
                    {
                        "username": "Evercode",
                        "content": "I think we can keep both the kth smallest element and (k-1)th smallest element. If we insert or delete an element larger than the kth smallest element, the result remains unaffected. If something smaller than is inserted, compare it with the (k-1)th smallest element. The larger one becomes the new kth smallest element and adjust (k-1)th element accordingly.\\nWe may also need to keep track of the (k+1)th smallest element in case of deleting a node smaller than the kth element. However if we keep deleting nodes, we may need the (k+2, k+3, .... )th smallest element to stay correct.\\nAny other ideas?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Using a max heap of size k would be easier to maintain"
                    },
                    {
                        "username": "SR2311",
                        "content": "When you are constructing the BST, at every node maintain a count - which is the number of nodes smaller than current node[ in other words number of nodes to the left of current node]. Also every node has a pointer which points to  it parent [ this is to handle the case when a node is deleted from the BST] .\\n\\nNow lets say everything is done and query comes:\\n\\t Starting at root in O(1) you know if your k is the left half of right half by comparing k with the count of current node. If k is smaller than the count that means our answer lies in the left half otherwise it is in the right half. Keep repeating this until we find our node\\n\\t \\nInsert Operation:\\nJust do normal BST insert and ensure to increment the count of the node if you are going down left of the tree and once you find the spot to insert assign the parent to the node.\\n\\nDelete operation:\\nConsider deleting some x node now since we have reference to the parent of every node we simply check if the node being deleted is to left or right of parent by comparing its value and if it is in the left simply decrement the count of the parent.\\n"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "basically you are keeping track of inorder predecessor and successor for each node so that when insertion/deletion occurs, you can go to next/previous node in O(1) time."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Inorder Traversal\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arch11Tech",
                        "content": "Follow up:\\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\\n\\nI think this is about find next smallest element in BST, with time complexity being O(log(n))\\nwhich should be better than O(k)\\n\\nRight?"
                    },
                    {
                        "username": "dan_stark123",
                        "content": "I think you need to come up with some logic that decides to minimize the search space ,after a node is deleted or inserted\\n"
                    },
                    {
                        "username": "pygirl5",
                        "content": "![image](https://assets.leetcode.com/users/pygirl5/image_1579402446.png)\\n@Leetcode could you please correct this?\\nThanks in advance!\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "just a tip:\\ndo in-order traversal to get the sorted array or u can do any BFS/DFS and get the array and sort it \\nthen return the array\\'s \"k-1\"th element"
                    },
                    {
                        "username": "pinkfloyda",
                        "content": "From what I can tell, the running time is O(height of BST) + O(k), optimal means lower bound?"
                    },
                    {
                        "username": "npostavs",
                        "content": "[@brandon_busby](/brandon_busby) The tree is sorted so you don\\'t have to look at all of the nodes. E.g., if `k =1`, just go down to the left-most node and don\\'t visit any others (that\\'s `O(height)`). For larger `k` you need to visit `k` more."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "That seems like the memory requirement, not the running time. The best conceivable running time is `O(number of nodes)` since you have to look at all nodes."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "We know InOrder traversal of BST is ascending order list. So, return k-1th element."
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "is it the most optimise solution for this problem and for the follow up given for this problem ???\\n"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here are my 4 methods to solve the problem:\\n-> Binary Search\\n-> Recursive\\n-> Iterative\\n-> Morris Traversal\\n[LeetCode Solution](https://techgeekyan.blogspot.ca/2017/09/leetcode-solution-230-kth-smallest.html)"
                    },
                    {
                        "username": "victCh",
                        "content": "What is kth smallest value???"
                    }
                ]
            },
            {
                "id": 1566058,
                "content": [
                    {
                        "username": "Vicky_Prasad",
                        "content": "My Dummy Approach:\\nGet Inorder of BST and then return k-1 index value.\\nIts simple way to solve this problem."
                    },
                    {
                        "username": "firby121",
                        "content": "[@logical_thinker](/logical_thinker) if you use an array to store all elements then there\\'s no point of using the tree itself. max heap with size k is the way to go."
                    },
                    {
                        "username": "logical_thinker",
                        "content": "I think this is right approach, there is a catch here, when ever there is a insertion or a deletion we don\\'t traverse the tree again we just perform on the array that we have got when we do in-order initially, as in-order fetches us a sorted array we can insert into the array with complexity n and delete works the same way as well. So this is a better solution I think not a dummy one."
                    },
                    {
                        "username": "Evercode",
                        "content": "I think we can keep both the kth smallest element and (k-1)th smallest element. If we insert or delete an element larger than the kth smallest element, the result remains unaffected. If something smaller than is inserted, compare it with the (k-1)th smallest element. The larger one becomes the new kth smallest element and adjust (k-1)th element accordingly.\\nWe may also need to keep track of the (k+1)th smallest element in case of deleting a node smaller than the kth element. However if we keep deleting nodes, we may need the (k+2, k+3, .... )th smallest element to stay correct.\\nAny other ideas?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Using a max heap of size k would be easier to maintain"
                    },
                    {
                        "username": "SR2311",
                        "content": "When you are constructing the BST, at every node maintain a count - which is the number of nodes smaller than current node[ in other words number of nodes to the left of current node]. Also every node has a pointer which points to  it parent [ this is to handle the case when a node is deleted from the BST] .\\n\\nNow lets say everything is done and query comes:\\n\\t Starting at root in O(1) you know if your k is the left half of right half by comparing k with the count of current node. If k is smaller than the count that means our answer lies in the left half otherwise it is in the right half. Keep repeating this until we find our node\\n\\t \\nInsert Operation:\\nJust do normal BST insert and ensure to increment the count of the node if you are going down left of the tree and once you find the spot to insert assign the parent to the node.\\n\\nDelete operation:\\nConsider deleting some x node now since we have reference to the parent of every node we simply check if the node being deleted is to left or right of parent by comparing its value and if it is in the left simply decrement the count of the parent.\\n"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "basically you are keeping track of inorder predecessor and successor for each node so that when insertion/deletion occurs, you can go to next/previous node in O(1) time."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Inorder Traversal\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arch11Tech",
                        "content": "Follow up:\\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\\n\\nI think this is about find next smallest element in BST, with time complexity being O(log(n))\\nwhich should be better than O(k)\\n\\nRight?"
                    },
                    {
                        "username": "dan_stark123",
                        "content": "I think you need to come up with some logic that decides to minimize the search space ,after a node is deleted or inserted\\n"
                    },
                    {
                        "username": "pygirl5",
                        "content": "![image](https://assets.leetcode.com/users/pygirl5/image_1579402446.png)\\n@Leetcode could you please correct this?\\nThanks in advance!\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "just a tip:\\ndo in-order traversal to get the sorted array or u can do any BFS/DFS and get the array and sort it \\nthen return the array\\'s \"k-1\"th element"
                    },
                    {
                        "username": "pinkfloyda",
                        "content": "From what I can tell, the running time is O(height of BST) + O(k), optimal means lower bound?"
                    },
                    {
                        "username": "npostavs",
                        "content": "[@brandon_busby](/brandon_busby) The tree is sorted so you don\\'t have to look at all of the nodes. E.g., if `k =1`, just go down to the left-most node and don\\'t visit any others (that\\'s `O(height)`). For larger `k` you need to visit `k` more."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "That seems like the memory requirement, not the running time. The best conceivable running time is `O(number of nodes)` since you have to look at all nodes."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "We know InOrder traversal of BST is ascending order list. So, return k-1th element."
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "is it the most optimise solution for this problem and for the follow up given for this problem ???\\n"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here are my 4 methods to solve the problem:\\n-> Binary Search\\n-> Recursive\\n-> Iterative\\n-> Morris Traversal\\n[LeetCode Solution](https://techgeekyan.blogspot.ca/2017/09/leetcode-solution-230-kth-smallest.html)"
                    },
                    {
                        "username": "victCh",
                        "content": "What is kth smallest value???"
                    }
                ]
            },
            {
                "id": 1571465,
                "content": [
                    {
                        "username": "Vicky_Prasad",
                        "content": "My Dummy Approach:\\nGet Inorder of BST and then return k-1 index value.\\nIts simple way to solve this problem."
                    },
                    {
                        "username": "firby121",
                        "content": "[@logical_thinker](/logical_thinker) if you use an array to store all elements then there\\'s no point of using the tree itself. max heap with size k is the way to go."
                    },
                    {
                        "username": "logical_thinker",
                        "content": "I think this is right approach, there is a catch here, when ever there is a insertion or a deletion we don\\'t traverse the tree again we just perform on the array that we have got when we do in-order initially, as in-order fetches us a sorted array we can insert into the array with complexity n and delete works the same way as well. So this is a better solution I think not a dummy one."
                    },
                    {
                        "username": "Evercode",
                        "content": "I think we can keep both the kth smallest element and (k-1)th smallest element. If we insert or delete an element larger than the kth smallest element, the result remains unaffected. If something smaller than is inserted, compare it with the (k-1)th smallest element. The larger one becomes the new kth smallest element and adjust (k-1)th element accordingly.\\nWe may also need to keep track of the (k+1)th smallest element in case of deleting a node smaller than the kth element. However if we keep deleting nodes, we may need the (k+2, k+3, .... )th smallest element to stay correct.\\nAny other ideas?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Using a max heap of size k would be easier to maintain"
                    },
                    {
                        "username": "SR2311",
                        "content": "When you are constructing the BST, at every node maintain a count - which is the number of nodes smaller than current node[ in other words number of nodes to the left of current node]. Also every node has a pointer which points to  it parent [ this is to handle the case when a node is deleted from the BST] .\\n\\nNow lets say everything is done and query comes:\\n\\t Starting at root in O(1) you know if your k is the left half of right half by comparing k with the count of current node. If k is smaller than the count that means our answer lies in the left half otherwise it is in the right half. Keep repeating this until we find our node\\n\\t \\nInsert Operation:\\nJust do normal BST insert and ensure to increment the count of the node if you are going down left of the tree and once you find the spot to insert assign the parent to the node.\\n\\nDelete operation:\\nConsider deleting some x node now since we have reference to the parent of every node we simply check if the node being deleted is to left or right of parent by comparing its value and if it is in the left simply decrement the count of the parent.\\n"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "basically you are keeping track of inorder predecessor and successor for each node so that when insertion/deletion occurs, you can go to next/previous node in O(1) time."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Inorder Traversal\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arch11Tech",
                        "content": "Follow up:\\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\\n\\nI think this is about find next smallest element in BST, with time complexity being O(log(n))\\nwhich should be better than O(k)\\n\\nRight?"
                    },
                    {
                        "username": "dan_stark123",
                        "content": "I think you need to come up with some logic that decides to minimize the search space ,after a node is deleted or inserted\\n"
                    },
                    {
                        "username": "pygirl5",
                        "content": "![image](https://assets.leetcode.com/users/pygirl5/image_1579402446.png)\\n@Leetcode could you please correct this?\\nThanks in advance!\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "just a tip:\\ndo in-order traversal to get the sorted array or u can do any BFS/DFS and get the array and sort it \\nthen return the array\\'s \"k-1\"th element"
                    },
                    {
                        "username": "pinkfloyda",
                        "content": "From what I can tell, the running time is O(height of BST) + O(k), optimal means lower bound?"
                    },
                    {
                        "username": "npostavs",
                        "content": "[@brandon_busby](/brandon_busby) The tree is sorted so you don\\'t have to look at all of the nodes. E.g., if `k =1`, just go down to the left-most node and don\\'t visit any others (that\\'s `O(height)`). For larger `k` you need to visit `k` more."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "That seems like the memory requirement, not the running time. The best conceivable running time is `O(number of nodes)` since you have to look at all nodes."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "We know InOrder traversal of BST is ascending order list. So, return k-1th element."
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "is it the most optimise solution for this problem and for the follow up given for this problem ???\\n"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here are my 4 methods to solve the problem:\\n-> Binary Search\\n-> Recursive\\n-> Iterative\\n-> Morris Traversal\\n[LeetCode Solution](https://techgeekyan.blogspot.ca/2017/09/leetcode-solution-230-kth-smallest.html)"
                    },
                    {
                        "username": "victCh",
                        "content": "What is kth smallest value???"
                    }
                ]
            },
            {
                "id": 1569745,
                "content": [
                    {
                        "username": "Vicky_Prasad",
                        "content": "My Dummy Approach:\\nGet Inorder of BST and then return k-1 index value.\\nIts simple way to solve this problem."
                    },
                    {
                        "username": "firby121",
                        "content": "[@logical_thinker](/logical_thinker) if you use an array to store all elements then there\\'s no point of using the tree itself. max heap with size k is the way to go."
                    },
                    {
                        "username": "logical_thinker",
                        "content": "I think this is right approach, there is a catch here, when ever there is a insertion or a deletion we don\\'t traverse the tree again we just perform on the array that we have got when we do in-order initially, as in-order fetches us a sorted array we can insert into the array with complexity n and delete works the same way as well. So this is a better solution I think not a dummy one."
                    },
                    {
                        "username": "Evercode",
                        "content": "I think we can keep both the kth smallest element and (k-1)th smallest element. If we insert or delete an element larger than the kth smallest element, the result remains unaffected. If something smaller than is inserted, compare it with the (k-1)th smallest element. The larger one becomes the new kth smallest element and adjust (k-1)th element accordingly.\\nWe may also need to keep track of the (k+1)th smallest element in case of deleting a node smaller than the kth element. However if we keep deleting nodes, we may need the (k+2, k+3, .... )th smallest element to stay correct.\\nAny other ideas?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Using a max heap of size k would be easier to maintain"
                    },
                    {
                        "username": "SR2311",
                        "content": "When you are constructing the BST, at every node maintain a count - which is the number of nodes smaller than current node[ in other words number of nodes to the left of current node]. Also every node has a pointer which points to  it parent [ this is to handle the case when a node is deleted from the BST] .\\n\\nNow lets say everything is done and query comes:\\n\\t Starting at root in O(1) you know if your k is the left half of right half by comparing k with the count of current node. If k is smaller than the count that means our answer lies in the left half otherwise it is in the right half. Keep repeating this until we find our node\\n\\t \\nInsert Operation:\\nJust do normal BST insert and ensure to increment the count of the node if you are going down left of the tree and once you find the spot to insert assign the parent to the node.\\n\\nDelete operation:\\nConsider deleting some x node now since we have reference to the parent of every node we simply check if the node being deleted is to left or right of parent by comparing its value and if it is in the left simply decrement the count of the parent.\\n"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "basically you are keeping track of inorder predecessor and successor for each node so that when insertion/deletion occurs, you can go to next/previous node in O(1) time."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Inorder Traversal\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arch11Tech",
                        "content": "Follow up:\\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\\n\\nI think this is about find next smallest element in BST, with time complexity being O(log(n))\\nwhich should be better than O(k)\\n\\nRight?"
                    },
                    {
                        "username": "dan_stark123",
                        "content": "I think you need to come up with some logic that decides to minimize the search space ,after a node is deleted or inserted\\n"
                    },
                    {
                        "username": "pygirl5",
                        "content": "![image](https://assets.leetcode.com/users/pygirl5/image_1579402446.png)\\n@Leetcode could you please correct this?\\nThanks in advance!\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "just a tip:\\ndo in-order traversal to get the sorted array or u can do any BFS/DFS and get the array and sort it \\nthen return the array\\'s \"k-1\"th element"
                    },
                    {
                        "username": "pinkfloyda",
                        "content": "From what I can tell, the running time is O(height of BST) + O(k), optimal means lower bound?"
                    },
                    {
                        "username": "npostavs",
                        "content": "[@brandon_busby](/brandon_busby) The tree is sorted so you don\\'t have to look at all of the nodes. E.g., if `k =1`, just go down to the left-most node and don\\'t visit any others (that\\'s `O(height)`). For larger `k` you need to visit `k` more."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "That seems like the memory requirement, not the running time. The best conceivable running time is `O(number of nodes)` since you have to look at all nodes."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "We know InOrder traversal of BST is ascending order list. So, return k-1th element."
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "is it the most optimise solution for this problem and for the follow up given for this problem ???\\n"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here are my 4 methods to solve the problem:\\n-> Binary Search\\n-> Recursive\\n-> Iterative\\n-> Morris Traversal\\n[LeetCode Solution](https://techgeekyan.blogspot.ca/2017/09/leetcode-solution-230-kth-smallest.html)"
                    },
                    {
                        "username": "victCh",
                        "content": "What is kth smallest value???"
                    }
                ]
            },
            {
                "id": 1569036,
                "content": [
                    {
                        "username": "Vicky_Prasad",
                        "content": "My Dummy Approach:\\nGet Inorder of BST and then return k-1 index value.\\nIts simple way to solve this problem."
                    },
                    {
                        "username": "firby121",
                        "content": "[@logical_thinker](/logical_thinker) if you use an array to store all elements then there\\'s no point of using the tree itself. max heap with size k is the way to go."
                    },
                    {
                        "username": "logical_thinker",
                        "content": "I think this is right approach, there is a catch here, when ever there is a insertion or a deletion we don\\'t traverse the tree again we just perform on the array that we have got when we do in-order initially, as in-order fetches us a sorted array we can insert into the array with complexity n and delete works the same way as well. So this is a better solution I think not a dummy one."
                    },
                    {
                        "username": "Evercode",
                        "content": "I think we can keep both the kth smallest element and (k-1)th smallest element. If we insert or delete an element larger than the kth smallest element, the result remains unaffected. If something smaller than is inserted, compare it with the (k-1)th smallest element. The larger one becomes the new kth smallest element and adjust (k-1)th element accordingly.\\nWe may also need to keep track of the (k+1)th smallest element in case of deleting a node smaller than the kth element. However if we keep deleting nodes, we may need the (k+2, k+3, .... )th smallest element to stay correct.\\nAny other ideas?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Using a max heap of size k would be easier to maintain"
                    },
                    {
                        "username": "SR2311",
                        "content": "When you are constructing the BST, at every node maintain a count - which is the number of nodes smaller than current node[ in other words number of nodes to the left of current node]. Also every node has a pointer which points to  it parent [ this is to handle the case when a node is deleted from the BST] .\\n\\nNow lets say everything is done and query comes:\\n\\t Starting at root in O(1) you know if your k is the left half of right half by comparing k with the count of current node. If k is smaller than the count that means our answer lies in the left half otherwise it is in the right half. Keep repeating this until we find our node\\n\\t \\nInsert Operation:\\nJust do normal BST insert and ensure to increment the count of the node if you are going down left of the tree and once you find the spot to insert assign the parent to the node.\\n\\nDelete operation:\\nConsider deleting some x node now since we have reference to the parent of every node we simply check if the node being deleted is to left or right of parent by comparing its value and if it is in the left simply decrement the count of the parent.\\n"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "basically you are keeping track of inorder predecessor and successor for each node so that when insertion/deletion occurs, you can go to next/previous node in O(1) time."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Inorder Traversal\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arch11Tech",
                        "content": "Follow up:\\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\\n\\nI think this is about find next smallest element in BST, with time complexity being O(log(n))\\nwhich should be better than O(k)\\n\\nRight?"
                    },
                    {
                        "username": "dan_stark123",
                        "content": "I think you need to come up with some logic that decides to minimize the search space ,after a node is deleted or inserted\\n"
                    },
                    {
                        "username": "pygirl5",
                        "content": "![image](https://assets.leetcode.com/users/pygirl5/image_1579402446.png)\\n@Leetcode could you please correct this?\\nThanks in advance!\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "just a tip:\\ndo in-order traversal to get the sorted array or u can do any BFS/DFS and get the array and sort it \\nthen return the array\\'s \"k-1\"th element"
                    },
                    {
                        "username": "pinkfloyda",
                        "content": "From what I can tell, the running time is O(height of BST) + O(k), optimal means lower bound?"
                    },
                    {
                        "username": "npostavs",
                        "content": "[@brandon_busby](/brandon_busby) The tree is sorted so you don\\'t have to look at all of the nodes. E.g., if `k =1`, just go down to the left-most node and don\\'t visit any others (that\\'s `O(height)`). For larger `k` you need to visit `k` more."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "That seems like the memory requirement, not the running time. The best conceivable running time is `O(number of nodes)` since you have to look at all nodes."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "We know InOrder traversal of BST is ascending order list. So, return k-1th element."
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "is it the most optimise solution for this problem and for the follow up given for this problem ???\\n"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here are my 4 methods to solve the problem:\\n-> Binary Search\\n-> Recursive\\n-> Iterative\\n-> Morris Traversal\\n[LeetCode Solution](https://techgeekyan.blogspot.ca/2017/09/leetcode-solution-230-kth-smallest.html)"
                    },
                    {
                        "username": "victCh",
                        "content": "What is kth smallest value???"
                    }
                ]
            },
            {
                "id": 1892146,
                "content": [
                    {
                        "username": "Vicky_Prasad",
                        "content": "My Dummy Approach:\\nGet Inorder of BST and then return k-1 index value.\\nIts simple way to solve this problem."
                    },
                    {
                        "username": "firby121",
                        "content": "[@logical_thinker](/logical_thinker) if you use an array to store all elements then there\\'s no point of using the tree itself. max heap with size k is the way to go."
                    },
                    {
                        "username": "logical_thinker",
                        "content": "I think this is right approach, there is a catch here, when ever there is a insertion or a deletion we don\\'t traverse the tree again we just perform on the array that we have got when we do in-order initially, as in-order fetches us a sorted array we can insert into the array with complexity n and delete works the same way as well. So this is a better solution I think not a dummy one."
                    },
                    {
                        "username": "Evercode",
                        "content": "I think we can keep both the kth smallest element and (k-1)th smallest element. If we insert or delete an element larger than the kth smallest element, the result remains unaffected. If something smaller than is inserted, compare it with the (k-1)th smallest element. The larger one becomes the new kth smallest element and adjust (k-1)th element accordingly.\\nWe may also need to keep track of the (k+1)th smallest element in case of deleting a node smaller than the kth element. However if we keep deleting nodes, we may need the (k+2, k+3, .... )th smallest element to stay correct.\\nAny other ideas?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Using a max heap of size k would be easier to maintain"
                    },
                    {
                        "username": "SR2311",
                        "content": "When you are constructing the BST, at every node maintain a count - which is the number of nodes smaller than current node[ in other words number of nodes to the left of current node]. Also every node has a pointer which points to  it parent [ this is to handle the case when a node is deleted from the BST] .\\n\\nNow lets say everything is done and query comes:\\n\\t Starting at root in O(1) you know if your k is the left half of right half by comparing k with the count of current node. If k is smaller than the count that means our answer lies in the left half otherwise it is in the right half. Keep repeating this until we find our node\\n\\t \\nInsert Operation:\\nJust do normal BST insert and ensure to increment the count of the node if you are going down left of the tree and once you find the spot to insert assign the parent to the node.\\n\\nDelete operation:\\nConsider deleting some x node now since we have reference to the parent of every node we simply check if the node being deleted is to left or right of parent by comparing its value and if it is in the left simply decrement the count of the parent.\\n"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "basically you are keeping track of inorder predecessor and successor for each node so that when insertion/deletion occurs, you can go to next/previous node in O(1) time."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Inorder Traversal\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arch11Tech",
                        "content": "Follow up:\\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\\n\\nI think this is about find next smallest element in BST, with time complexity being O(log(n))\\nwhich should be better than O(k)\\n\\nRight?"
                    },
                    {
                        "username": "dan_stark123",
                        "content": "I think you need to come up with some logic that decides to minimize the search space ,after a node is deleted or inserted\\n"
                    },
                    {
                        "username": "pygirl5",
                        "content": "![image](https://assets.leetcode.com/users/pygirl5/image_1579402446.png)\\n@Leetcode could you please correct this?\\nThanks in advance!\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "just a tip:\\ndo in-order traversal to get the sorted array or u can do any BFS/DFS and get the array and sort it \\nthen return the array\\'s \"k-1\"th element"
                    },
                    {
                        "username": "pinkfloyda",
                        "content": "From what I can tell, the running time is O(height of BST) + O(k), optimal means lower bound?"
                    },
                    {
                        "username": "npostavs",
                        "content": "[@brandon_busby](/brandon_busby) The tree is sorted so you don\\'t have to look at all of the nodes. E.g., if `k =1`, just go down to the left-most node and don\\'t visit any others (that\\'s `O(height)`). For larger `k` you need to visit `k` more."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "That seems like the memory requirement, not the running time. The best conceivable running time is `O(number of nodes)` since you have to look at all nodes."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "We know InOrder traversal of BST is ascending order list. So, return k-1th element."
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "is it the most optimise solution for this problem and for the follow up given for this problem ???\\n"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here are my 4 methods to solve the problem:\\n-> Binary Search\\n-> Recursive\\n-> Iterative\\n-> Morris Traversal\\n[LeetCode Solution](https://techgeekyan.blogspot.ca/2017/09/leetcode-solution-230-kth-smallest.html)"
                    },
                    {
                        "username": "victCh",
                        "content": "What is kth smallest value???"
                    }
                ]
            },
            {
                "id": 1571463,
                "content": [
                    {
                        "username": "Vicky_Prasad",
                        "content": "My Dummy Approach:\\nGet Inorder of BST and then return k-1 index value.\\nIts simple way to solve this problem."
                    },
                    {
                        "username": "firby121",
                        "content": "[@logical_thinker](/logical_thinker) if you use an array to store all elements then there\\'s no point of using the tree itself. max heap with size k is the way to go."
                    },
                    {
                        "username": "logical_thinker",
                        "content": "I think this is right approach, there is a catch here, when ever there is a insertion or a deletion we don\\'t traverse the tree again we just perform on the array that we have got when we do in-order initially, as in-order fetches us a sorted array we can insert into the array with complexity n and delete works the same way as well. So this is a better solution I think not a dummy one."
                    },
                    {
                        "username": "Evercode",
                        "content": "I think we can keep both the kth smallest element and (k-1)th smallest element. If we insert or delete an element larger than the kth smallest element, the result remains unaffected. If something smaller than is inserted, compare it with the (k-1)th smallest element. The larger one becomes the new kth smallest element and adjust (k-1)th element accordingly.\\nWe may also need to keep track of the (k+1)th smallest element in case of deleting a node smaller than the kth element. However if we keep deleting nodes, we may need the (k+2, k+3, .... )th smallest element to stay correct.\\nAny other ideas?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Using a max heap of size k would be easier to maintain"
                    },
                    {
                        "username": "SR2311",
                        "content": "When you are constructing the BST, at every node maintain a count - which is the number of nodes smaller than current node[ in other words number of nodes to the left of current node]. Also every node has a pointer which points to  it parent [ this is to handle the case when a node is deleted from the BST] .\\n\\nNow lets say everything is done and query comes:\\n\\t Starting at root in O(1) you know if your k is the left half of right half by comparing k with the count of current node. If k is smaller than the count that means our answer lies in the left half otherwise it is in the right half. Keep repeating this until we find our node\\n\\t \\nInsert Operation:\\nJust do normal BST insert and ensure to increment the count of the node if you are going down left of the tree and once you find the spot to insert assign the parent to the node.\\n\\nDelete operation:\\nConsider deleting some x node now since we have reference to the parent of every node we simply check if the node being deleted is to left or right of parent by comparing its value and if it is in the left simply decrement the count of the parent.\\n"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "basically you are keeping track of inorder predecessor and successor for each node so that when insertion/deletion occurs, you can go to next/previous node in O(1) time."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Inorder Traversal\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arch11Tech",
                        "content": "Follow up:\\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\\n\\nI think this is about find next smallest element in BST, with time complexity being O(log(n))\\nwhich should be better than O(k)\\n\\nRight?"
                    },
                    {
                        "username": "dan_stark123",
                        "content": "I think you need to come up with some logic that decides to minimize the search space ,after a node is deleted or inserted\\n"
                    },
                    {
                        "username": "pygirl5",
                        "content": "![image](https://assets.leetcode.com/users/pygirl5/image_1579402446.png)\\n@Leetcode could you please correct this?\\nThanks in advance!\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "just a tip:\\ndo in-order traversal to get the sorted array or u can do any BFS/DFS and get the array and sort it \\nthen return the array\\'s \"k-1\"th element"
                    },
                    {
                        "username": "pinkfloyda",
                        "content": "From what I can tell, the running time is O(height of BST) + O(k), optimal means lower bound?"
                    },
                    {
                        "username": "npostavs",
                        "content": "[@brandon_busby](/brandon_busby) The tree is sorted so you don\\'t have to look at all of the nodes. E.g., if `k =1`, just go down to the left-most node and don\\'t visit any others (that\\'s `O(height)`). For larger `k` you need to visit `k` more."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "That seems like the memory requirement, not the running time. The best conceivable running time is `O(number of nodes)` since you have to look at all nodes."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "We know InOrder traversal of BST is ascending order list. So, return k-1th element."
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "is it the most optimise solution for this problem and for the follow up given for this problem ???\\n"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here are my 4 methods to solve the problem:\\n-> Binary Search\\n-> Recursive\\n-> Iterative\\n-> Morris Traversal\\n[LeetCode Solution](https://techgeekyan.blogspot.ca/2017/09/leetcode-solution-230-kth-smallest.html)"
                    },
                    {
                        "username": "victCh",
                        "content": "What is kth smallest value???"
                    }
                ]
            },
            {
                "id": 1830611,
                "content": [
                    {
                        "username": "Vicky_Prasad",
                        "content": "My Dummy Approach:\\nGet Inorder of BST and then return k-1 index value.\\nIts simple way to solve this problem."
                    },
                    {
                        "username": "firby121",
                        "content": "[@logical_thinker](/logical_thinker) if you use an array to store all elements then there\\'s no point of using the tree itself. max heap with size k is the way to go."
                    },
                    {
                        "username": "logical_thinker",
                        "content": "I think this is right approach, there is a catch here, when ever there is a insertion or a deletion we don\\'t traverse the tree again we just perform on the array that we have got when we do in-order initially, as in-order fetches us a sorted array we can insert into the array with complexity n and delete works the same way as well. So this is a better solution I think not a dummy one."
                    },
                    {
                        "username": "Evercode",
                        "content": "I think we can keep both the kth smallest element and (k-1)th smallest element. If we insert or delete an element larger than the kth smallest element, the result remains unaffected. If something smaller than is inserted, compare it with the (k-1)th smallest element. The larger one becomes the new kth smallest element and adjust (k-1)th element accordingly.\\nWe may also need to keep track of the (k+1)th smallest element in case of deleting a node smaller than the kth element. However if we keep deleting nodes, we may need the (k+2, k+3, .... )th smallest element to stay correct.\\nAny other ideas?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Using a max heap of size k would be easier to maintain"
                    },
                    {
                        "username": "SR2311",
                        "content": "When you are constructing the BST, at every node maintain a count - which is the number of nodes smaller than current node[ in other words number of nodes to the left of current node]. Also every node has a pointer which points to  it parent [ this is to handle the case when a node is deleted from the BST] .\\n\\nNow lets say everything is done and query comes:\\n\\t Starting at root in O(1) you know if your k is the left half of right half by comparing k with the count of current node. If k is smaller than the count that means our answer lies in the left half otherwise it is in the right half. Keep repeating this until we find our node\\n\\t \\nInsert Operation:\\nJust do normal BST insert and ensure to increment the count of the node if you are going down left of the tree and once you find the spot to insert assign the parent to the node.\\n\\nDelete operation:\\nConsider deleting some x node now since we have reference to the parent of every node we simply check if the node being deleted is to left or right of parent by comparing its value and if it is in the left simply decrement the count of the parent.\\n"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "basically you are keeping track of inorder predecessor and successor for each node so that when insertion/deletion occurs, you can go to next/previous node in O(1) time."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Inorder Traversal\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arch11Tech",
                        "content": "Follow up:\\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\\n\\nI think this is about find next smallest element in BST, with time complexity being O(log(n))\\nwhich should be better than O(k)\\n\\nRight?"
                    },
                    {
                        "username": "dan_stark123",
                        "content": "I think you need to come up with some logic that decides to minimize the search space ,after a node is deleted or inserted\\n"
                    },
                    {
                        "username": "pygirl5",
                        "content": "![image](https://assets.leetcode.com/users/pygirl5/image_1579402446.png)\\n@Leetcode could you please correct this?\\nThanks in advance!\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "just a tip:\\ndo in-order traversal to get the sorted array or u can do any BFS/DFS and get the array and sort it \\nthen return the array\\'s \"k-1\"th element"
                    },
                    {
                        "username": "pinkfloyda",
                        "content": "From what I can tell, the running time is O(height of BST) + O(k), optimal means lower bound?"
                    },
                    {
                        "username": "npostavs",
                        "content": "[@brandon_busby](/brandon_busby) The tree is sorted so you don\\'t have to look at all of the nodes. E.g., if `k =1`, just go down to the left-most node and don\\'t visit any others (that\\'s `O(height)`). For larger `k` you need to visit `k` more."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "That seems like the memory requirement, not the running time. The best conceivable running time is `O(number of nodes)` since you have to look at all nodes."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "We know InOrder traversal of BST is ascending order list. So, return k-1th element."
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "is it the most optimise solution for this problem and for the follow up given for this problem ???\\n"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here are my 4 methods to solve the problem:\\n-> Binary Search\\n-> Recursive\\n-> Iterative\\n-> Morris Traversal\\n[LeetCode Solution](https://techgeekyan.blogspot.ca/2017/09/leetcode-solution-230-kth-smallest.html)"
                    },
                    {
                        "username": "victCh",
                        "content": "What is kth smallest value???"
                    }
                ]
            },
            {
                "id": 1723768,
                "content": [
                    {
                        "username": "Vicky_Prasad",
                        "content": "My Dummy Approach:\\nGet Inorder of BST and then return k-1 index value.\\nIts simple way to solve this problem."
                    },
                    {
                        "username": "firby121",
                        "content": "[@logical_thinker](/logical_thinker) if you use an array to store all elements then there\\'s no point of using the tree itself. max heap with size k is the way to go."
                    },
                    {
                        "username": "logical_thinker",
                        "content": "I think this is right approach, there is a catch here, when ever there is a insertion or a deletion we don\\'t traverse the tree again we just perform on the array that we have got when we do in-order initially, as in-order fetches us a sorted array we can insert into the array with complexity n and delete works the same way as well. So this is a better solution I think not a dummy one."
                    },
                    {
                        "username": "Evercode",
                        "content": "I think we can keep both the kth smallest element and (k-1)th smallest element. If we insert or delete an element larger than the kth smallest element, the result remains unaffected. If something smaller than is inserted, compare it with the (k-1)th smallest element. The larger one becomes the new kth smallest element and adjust (k-1)th element accordingly.\\nWe may also need to keep track of the (k+1)th smallest element in case of deleting a node smaller than the kth element. However if we keep deleting nodes, we may need the (k+2, k+3, .... )th smallest element to stay correct.\\nAny other ideas?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Using a max heap of size k would be easier to maintain"
                    },
                    {
                        "username": "SR2311",
                        "content": "When you are constructing the BST, at every node maintain a count - which is the number of nodes smaller than current node[ in other words number of nodes to the left of current node]. Also every node has a pointer which points to  it parent [ this is to handle the case when a node is deleted from the BST] .\\n\\nNow lets say everything is done and query comes:\\n\\t Starting at root in O(1) you know if your k is the left half of right half by comparing k with the count of current node. If k is smaller than the count that means our answer lies in the left half otherwise it is in the right half. Keep repeating this until we find our node\\n\\t \\nInsert Operation:\\nJust do normal BST insert and ensure to increment the count of the node if you are going down left of the tree and once you find the spot to insert assign the parent to the node.\\n\\nDelete operation:\\nConsider deleting some x node now since we have reference to the parent of every node we simply check if the node being deleted is to left or right of parent by comparing its value and if it is in the left simply decrement the count of the parent.\\n"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "basically you are keeping track of inorder predecessor and successor for each node so that when insertion/deletion occurs, you can go to next/previous node in O(1) time."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Inorder Traversal\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arch11Tech",
                        "content": "Follow up:\\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\\n\\nI think this is about find next smallest element in BST, with time complexity being O(log(n))\\nwhich should be better than O(k)\\n\\nRight?"
                    },
                    {
                        "username": "dan_stark123",
                        "content": "I think you need to come up with some logic that decides to minimize the search space ,after a node is deleted or inserted\\n"
                    },
                    {
                        "username": "pygirl5",
                        "content": "![image](https://assets.leetcode.com/users/pygirl5/image_1579402446.png)\\n@Leetcode could you please correct this?\\nThanks in advance!\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "just a tip:\\ndo in-order traversal to get the sorted array or u can do any BFS/DFS and get the array and sort it \\nthen return the array\\'s \"k-1\"th element"
                    },
                    {
                        "username": "pinkfloyda",
                        "content": "From what I can tell, the running time is O(height of BST) + O(k), optimal means lower bound?"
                    },
                    {
                        "username": "npostavs",
                        "content": "[@brandon_busby](/brandon_busby) The tree is sorted so you don\\'t have to look at all of the nodes. E.g., if `k =1`, just go down to the left-most node and don\\'t visit any others (that\\'s `O(height)`). For larger `k` you need to visit `k` more."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "That seems like the memory requirement, not the running time. The best conceivable running time is `O(number of nodes)` since you have to look at all nodes."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "We know InOrder traversal of BST is ascending order list. So, return k-1th element."
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "is it the most optimise solution for this problem and for the follow up given for this problem ???\\n"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here are my 4 methods to solve the problem:\\n-> Binary Search\\n-> Recursive\\n-> Iterative\\n-> Morris Traversal\\n[LeetCode Solution](https://techgeekyan.blogspot.ca/2017/09/leetcode-solution-230-kth-smallest.html)"
                    },
                    {
                        "username": "victCh",
                        "content": "What is kth smallest value???"
                    }
                ]
            },
            {
                "id": 1565529,
                "content": [
                    {
                        "username": "Vicky_Prasad",
                        "content": "My Dummy Approach:\\nGet Inorder of BST and then return k-1 index value.\\nIts simple way to solve this problem."
                    },
                    {
                        "username": "firby121",
                        "content": "[@logical_thinker](/logical_thinker) if you use an array to store all elements then there\\'s no point of using the tree itself. max heap with size k is the way to go."
                    },
                    {
                        "username": "logical_thinker",
                        "content": "I think this is right approach, there is a catch here, when ever there is a insertion or a deletion we don\\'t traverse the tree again we just perform on the array that we have got when we do in-order initially, as in-order fetches us a sorted array we can insert into the array with complexity n and delete works the same way as well. So this is a better solution I think not a dummy one."
                    },
                    {
                        "username": "Evercode",
                        "content": "I think we can keep both the kth smallest element and (k-1)th smallest element. If we insert or delete an element larger than the kth smallest element, the result remains unaffected. If something smaller than is inserted, compare it with the (k-1)th smallest element. The larger one becomes the new kth smallest element and adjust (k-1)th element accordingly.\\nWe may also need to keep track of the (k+1)th smallest element in case of deleting a node smaller than the kth element. However if we keep deleting nodes, we may need the (k+2, k+3, .... )th smallest element to stay correct.\\nAny other ideas?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Using a max heap of size k would be easier to maintain"
                    },
                    {
                        "username": "SR2311",
                        "content": "When you are constructing the BST, at every node maintain a count - which is the number of nodes smaller than current node[ in other words number of nodes to the left of current node]. Also every node has a pointer which points to  it parent [ this is to handle the case when a node is deleted from the BST] .\\n\\nNow lets say everything is done and query comes:\\n\\t Starting at root in O(1) you know if your k is the left half of right half by comparing k with the count of current node. If k is smaller than the count that means our answer lies in the left half otherwise it is in the right half. Keep repeating this until we find our node\\n\\t \\nInsert Operation:\\nJust do normal BST insert and ensure to increment the count of the node if you are going down left of the tree and once you find the spot to insert assign the parent to the node.\\n\\nDelete operation:\\nConsider deleting some x node now since we have reference to the parent of every node we simply check if the node being deleted is to left or right of parent by comparing its value and if it is in the left simply decrement the count of the parent.\\n"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "basically you are keeping track of inorder predecessor and successor for each node so that when insertion/deletion occurs, you can go to next/previous node in O(1) time."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Inorder Traversal\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arch11Tech",
                        "content": "Follow up:\\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\\n\\nI think this is about find next smallest element in BST, with time complexity being O(log(n))\\nwhich should be better than O(k)\\n\\nRight?"
                    },
                    {
                        "username": "dan_stark123",
                        "content": "I think you need to come up with some logic that decides to minimize the search space ,after a node is deleted or inserted\\n"
                    },
                    {
                        "username": "pygirl5",
                        "content": "![image](https://assets.leetcode.com/users/pygirl5/image_1579402446.png)\\n@Leetcode could you please correct this?\\nThanks in advance!\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "just a tip:\\ndo in-order traversal to get the sorted array or u can do any BFS/DFS and get the array and sort it \\nthen return the array\\'s \"k-1\"th element"
                    },
                    {
                        "username": "pinkfloyda",
                        "content": "From what I can tell, the running time is O(height of BST) + O(k), optimal means lower bound?"
                    },
                    {
                        "username": "npostavs",
                        "content": "[@brandon_busby](/brandon_busby) The tree is sorted so you don\\'t have to look at all of the nodes. E.g., if `k =1`, just go down to the left-most node and don\\'t visit any others (that\\'s `O(height)`). For larger `k` you need to visit `k` more."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "That seems like the memory requirement, not the running time. The best conceivable running time is `O(number of nodes)` since you have to look at all nodes."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "We know InOrder traversal of BST is ascending order list. So, return k-1th element."
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "is it the most optimise solution for this problem and for the follow up given for this problem ???\\n"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here are my 4 methods to solve the problem:\\n-> Binary Search\\n-> Recursive\\n-> Iterative\\n-> Morris Traversal\\n[LeetCode Solution](https://techgeekyan.blogspot.ca/2017/09/leetcode-solution-230-kth-smallest.html)"
                    },
                    {
                        "username": "victCh",
                        "content": "What is kth smallest value???"
                    }
                ]
            },
            {
                "id": 1565704,
                "content": [
                    {
                        "username": "Vicky_Prasad",
                        "content": "My Dummy Approach:\\nGet Inorder of BST and then return k-1 index value.\\nIts simple way to solve this problem."
                    },
                    {
                        "username": "firby121",
                        "content": "[@logical_thinker](/logical_thinker) if you use an array to store all elements then there\\'s no point of using the tree itself. max heap with size k is the way to go."
                    },
                    {
                        "username": "logical_thinker",
                        "content": "I think this is right approach, there is a catch here, when ever there is a insertion or a deletion we don\\'t traverse the tree again we just perform on the array that we have got when we do in-order initially, as in-order fetches us a sorted array we can insert into the array with complexity n and delete works the same way as well. So this is a better solution I think not a dummy one."
                    },
                    {
                        "username": "Evercode",
                        "content": "I think we can keep both the kth smallest element and (k-1)th smallest element. If we insert or delete an element larger than the kth smallest element, the result remains unaffected. If something smaller than is inserted, compare it with the (k-1)th smallest element. The larger one becomes the new kth smallest element and adjust (k-1)th element accordingly.\\nWe may also need to keep track of the (k+1)th smallest element in case of deleting a node smaller than the kth element. However if we keep deleting nodes, we may need the (k+2, k+3, .... )th smallest element to stay correct.\\nAny other ideas?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Using a max heap of size k would be easier to maintain"
                    },
                    {
                        "username": "SR2311",
                        "content": "When you are constructing the BST, at every node maintain a count - which is the number of nodes smaller than current node[ in other words number of nodes to the left of current node]. Also every node has a pointer which points to  it parent [ this is to handle the case when a node is deleted from the BST] .\\n\\nNow lets say everything is done and query comes:\\n\\t Starting at root in O(1) you know if your k is the left half of right half by comparing k with the count of current node. If k is smaller than the count that means our answer lies in the left half otherwise it is in the right half. Keep repeating this until we find our node\\n\\t \\nInsert Operation:\\nJust do normal BST insert and ensure to increment the count of the node if you are going down left of the tree and once you find the spot to insert assign the parent to the node.\\n\\nDelete operation:\\nConsider deleting some x node now since we have reference to the parent of every node we simply check if the node being deleted is to left or right of parent by comparing its value and if it is in the left simply decrement the count of the parent.\\n"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "basically you are keeping track of inorder predecessor and successor for each node so that when insertion/deletion occurs, you can go to next/previous node in O(1) time."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Inorder Traversal\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arch11Tech",
                        "content": "Follow up:\\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\\n\\nI think this is about find next smallest element in BST, with time complexity being O(log(n))\\nwhich should be better than O(k)\\n\\nRight?"
                    },
                    {
                        "username": "dan_stark123",
                        "content": "I think you need to come up with some logic that decides to minimize the search space ,after a node is deleted or inserted\\n"
                    },
                    {
                        "username": "pygirl5",
                        "content": "![image](https://assets.leetcode.com/users/pygirl5/image_1579402446.png)\\n@Leetcode could you please correct this?\\nThanks in advance!\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "just a tip:\\ndo in-order traversal to get the sorted array or u can do any BFS/DFS and get the array and sort it \\nthen return the array\\'s \"k-1\"th element"
                    },
                    {
                        "username": "pinkfloyda",
                        "content": "From what I can tell, the running time is O(height of BST) + O(k), optimal means lower bound?"
                    },
                    {
                        "username": "npostavs",
                        "content": "[@brandon_busby](/brandon_busby) The tree is sorted so you don\\'t have to look at all of the nodes. E.g., if `k =1`, just go down to the left-most node and don\\'t visit any others (that\\'s `O(height)`). For larger `k` you need to visit `k` more."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "That seems like the memory requirement, not the running time. The best conceivable running time is `O(number of nodes)` since you have to look at all nodes."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "We know InOrder traversal of BST is ascending order list. So, return k-1th element."
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "is it the most optimise solution for this problem and for the follow up given for this problem ???\\n"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here are my 4 methods to solve the problem:\\n-> Binary Search\\n-> Recursive\\n-> Iterative\\n-> Morris Traversal\\n[LeetCode Solution](https://techgeekyan.blogspot.ca/2017/09/leetcode-solution-230-kth-smallest.html)"
                    },
                    {
                        "username": "victCh",
                        "content": "What is kth smallest value???"
                    }
                ]
            },
            {
                "id": 1566058,
                "content": [
                    {
                        "username": "Vicky_Prasad",
                        "content": "My Dummy Approach:\\nGet Inorder of BST and then return k-1 index value.\\nIts simple way to solve this problem."
                    },
                    {
                        "username": "firby121",
                        "content": "[@logical_thinker](/logical_thinker) if you use an array to store all elements then there\\'s no point of using the tree itself. max heap with size k is the way to go."
                    },
                    {
                        "username": "logical_thinker",
                        "content": "I think this is right approach, there is a catch here, when ever there is a insertion or a deletion we don\\'t traverse the tree again we just perform on the array that we have got when we do in-order initially, as in-order fetches us a sorted array we can insert into the array with complexity n and delete works the same way as well. So this is a better solution I think not a dummy one."
                    },
                    {
                        "username": "Evercode",
                        "content": "I think we can keep both the kth smallest element and (k-1)th smallest element. If we insert or delete an element larger than the kth smallest element, the result remains unaffected. If something smaller than is inserted, compare it with the (k-1)th smallest element. The larger one becomes the new kth smallest element and adjust (k-1)th element accordingly.\\nWe may also need to keep track of the (k+1)th smallest element in case of deleting a node smaller than the kth element. However if we keep deleting nodes, we may need the (k+2, k+3, .... )th smallest element to stay correct.\\nAny other ideas?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Using a max heap of size k would be easier to maintain"
                    },
                    {
                        "username": "SR2311",
                        "content": "When you are constructing the BST, at every node maintain a count - which is the number of nodes smaller than current node[ in other words number of nodes to the left of current node]. Also every node has a pointer which points to  it parent [ this is to handle the case when a node is deleted from the BST] .\\n\\nNow lets say everything is done and query comes:\\n\\t Starting at root in O(1) you know if your k is the left half of right half by comparing k with the count of current node. If k is smaller than the count that means our answer lies in the left half otherwise it is in the right half. Keep repeating this until we find our node\\n\\t \\nInsert Operation:\\nJust do normal BST insert and ensure to increment the count of the node if you are going down left of the tree and once you find the spot to insert assign the parent to the node.\\n\\nDelete operation:\\nConsider deleting some x node now since we have reference to the parent of every node we simply check if the node being deleted is to left or right of parent by comparing its value and if it is in the left simply decrement the count of the parent.\\n"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "basically you are keeping track of inorder predecessor and successor for each node so that when insertion/deletion occurs, you can go to next/previous node in O(1) time."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Inorder Traversal\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arch11Tech",
                        "content": "Follow up:\\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\\n\\nI think this is about find next smallest element in BST, with time complexity being O(log(n))\\nwhich should be better than O(k)\\n\\nRight?"
                    },
                    {
                        "username": "dan_stark123",
                        "content": "I think you need to come up with some logic that decides to minimize the search space ,after a node is deleted or inserted\\n"
                    },
                    {
                        "username": "pygirl5",
                        "content": "![image](https://assets.leetcode.com/users/pygirl5/image_1579402446.png)\\n@Leetcode could you please correct this?\\nThanks in advance!\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "just a tip:\\ndo in-order traversal to get the sorted array or u can do any BFS/DFS and get the array and sort it \\nthen return the array\\'s \"k-1\"th element"
                    },
                    {
                        "username": "pinkfloyda",
                        "content": "From what I can tell, the running time is O(height of BST) + O(k), optimal means lower bound?"
                    },
                    {
                        "username": "npostavs",
                        "content": "[@brandon_busby](/brandon_busby) The tree is sorted so you don\\'t have to look at all of the nodes. E.g., if `k =1`, just go down to the left-most node and don\\'t visit any others (that\\'s `O(height)`). For larger `k` you need to visit `k` more."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "That seems like the memory requirement, not the running time. The best conceivable running time is `O(number of nodes)` since you have to look at all nodes."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "We know InOrder traversal of BST is ascending order list. So, return k-1th element."
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "is it the most optimise solution for this problem and for the follow up given for this problem ???\\n"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here are my 4 methods to solve the problem:\\n-> Binary Search\\n-> Recursive\\n-> Iterative\\n-> Morris Traversal\\n[LeetCode Solution](https://techgeekyan.blogspot.ca/2017/09/leetcode-solution-230-kth-smallest.html)"
                    },
                    {
                        "username": "victCh",
                        "content": "What is kth smallest value???"
                    }
                ]
            },
            {
                "id": 1571465,
                "content": [
                    {
                        "username": "Vicky_Prasad",
                        "content": "My Dummy Approach:\\nGet Inorder of BST and then return k-1 index value.\\nIts simple way to solve this problem."
                    },
                    {
                        "username": "firby121",
                        "content": "[@logical_thinker](/logical_thinker) if you use an array to store all elements then there\\'s no point of using the tree itself. max heap with size k is the way to go."
                    },
                    {
                        "username": "logical_thinker",
                        "content": "I think this is right approach, there is a catch here, when ever there is a insertion or a deletion we don\\'t traverse the tree again we just perform on the array that we have got when we do in-order initially, as in-order fetches us a sorted array we can insert into the array with complexity n and delete works the same way as well. So this is a better solution I think not a dummy one."
                    },
                    {
                        "username": "Evercode",
                        "content": "I think we can keep both the kth smallest element and (k-1)th smallest element. If we insert or delete an element larger than the kth smallest element, the result remains unaffected. If something smaller than is inserted, compare it with the (k-1)th smallest element. The larger one becomes the new kth smallest element and adjust (k-1)th element accordingly.\\nWe may also need to keep track of the (k+1)th smallest element in case of deleting a node smaller than the kth element. However if we keep deleting nodes, we may need the (k+2, k+3, .... )th smallest element to stay correct.\\nAny other ideas?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Using a max heap of size k would be easier to maintain"
                    },
                    {
                        "username": "SR2311",
                        "content": "When you are constructing the BST, at every node maintain a count - which is the number of nodes smaller than current node[ in other words number of nodes to the left of current node]. Also every node has a pointer which points to  it parent [ this is to handle the case when a node is deleted from the BST] .\\n\\nNow lets say everything is done and query comes:\\n\\t Starting at root in O(1) you know if your k is the left half of right half by comparing k with the count of current node. If k is smaller than the count that means our answer lies in the left half otherwise it is in the right half. Keep repeating this until we find our node\\n\\t \\nInsert Operation:\\nJust do normal BST insert and ensure to increment the count of the node if you are going down left of the tree and once you find the spot to insert assign the parent to the node.\\n\\nDelete operation:\\nConsider deleting some x node now since we have reference to the parent of every node we simply check if the node being deleted is to left or right of parent by comparing its value and if it is in the left simply decrement the count of the parent.\\n"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "basically you are keeping track of inorder predecessor and successor for each node so that when insertion/deletion occurs, you can go to next/previous node in O(1) time."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Inorder Traversal\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arch11Tech",
                        "content": "Follow up:\\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\\n\\nI think this is about find next smallest element in BST, with time complexity being O(log(n))\\nwhich should be better than O(k)\\n\\nRight?"
                    },
                    {
                        "username": "dan_stark123",
                        "content": "I think you need to come up with some logic that decides to minimize the search space ,after a node is deleted or inserted\\n"
                    },
                    {
                        "username": "pygirl5",
                        "content": "![image](https://assets.leetcode.com/users/pygirl5/image_1579402446.png)\\n@Leetcode could you please correct this?\\nThanks in advance!\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "just a tip:\\ndo in-order traversal to get the sorted array or u can do any BFS/DFS and get the array and sort it \\nthen return the array\\'s \"k-1\"th element"
                    },
                    {
                        "username": "pinkfloyda",
                        "content": "From what I can tell, the running time is O(height of BST) + O(k), optimal means lower bound?"
                    },
                    {
                        "username": "npostavs",
                        "content": "[@brandon_busby](/brandon_busby) The tree is sorted so you don\\'t have to look at all of the nodes. E.g., if `k =1`, just go down to the left-most node and don\\'t visit any others (that\\'s `O(height)`). For larger `k` you need to visit `k` more."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "That seems like the memory requirement, not the running time. The best conceivable running time is `O(number of nodes)` since you have to look at all nodes."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "We know InOrder traversal of BST is ascending order list. So, return k-1th element."
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "is it the most optimise solution for this problem and for the follow up given for this problem ???\\n"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here are my 4 methods to solve the problem:\\n-> Binary Search\\n-> Recursive\\n-> Iterative\\n-> Morris Traversal\\n[LeetCode Solution](https://techgeekyan.blogspot.ca/2017/09/leetcode-solution-230-kth-smallest.html)"
                    },
                    {
                        "username": "victCh",
                        "content": "What is kth smallest value???"
                    }
                ]
            },
            {
                "id": 1569745,
                "content": [
                    {
                        "username": "Vicky_Prasad",
                        "content": "My Dummy Approach:\\nGet Inorder of BST and then return k-1 index value.\\nIts simple way to solve this problem."
                    },
                    {
                        "username": "firby121",
                        "content": "[@logical_thinker](/logical_thinker) if you use an array to store all elements then there\\'s no point of using the tree itself. max heap with size k is the way to go."
                    },
                    {
                        "username": "logical_thinker",
                        "content": "I think this is right approach, there is a catch here, when ever there is a insertion or a deletion we don\\'t traverse the tree again we just perform on the array that we have got when we do in-order initially, as in-order fetches us a sorted array we can insert into the array with complexity n and delete works the same way as well. So this is a better solution I think not a dummy one."
                    },
                    {
                        "username": "Evercode",
                        "content": "I think we can keep both the kth smallest element and (k-1)th smallest element. If we insert or delete an element larger than the kth smallest element, the result remains unaffected. If something smaller than is inserted, compare it with the (k-1)th smallest element. The larger one becomes the new kth smallest element and adjust (k-1)th element accordingly.\\nWe may also need to keep track of the (k+1)th smallest element in case of deleting a node smaller than the kth element. However if we keep deleting nodes, we may need the (k+2, k+3, .... )th smallest element to stay correct.\\nAny other ideas?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Using a max heap of size k would be easier to maintain"
                    },
                    {
                        "username": "SR2311",
                        "content": "When you are constructing the BST, at every node maintain a count - which is the number of nodes smaller than current node[ in other words number of nodes to the left of current node]. Also every node has a pointer which points to  it parent [ this is to handle the case when a node is deleted from the BST] .\\n\\nNow lets say everything is done and query comes:\\n\\t Starting at root in O(1) you know if your k is the left half of right half by comparing k with the count of current node. If k is smaller than the count that means our answer lies in the left half otherwise it is in the right half. Keep repeating this until we find our node\\n\\t \\nInsert Operation:\\nJust do normal BST insert and ensure to increment the count of the node if you are going down left of the tree and once you find the spot to insert assign the parent to the node.\\n\\nDelete operation:\\nConsider deleting some x node now since we have reference to the parent of every node we simply check if the node being deleted is to left or right of parent by comparing its value and if it is in the left simply decrement the count of the parent.\\n"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "basically you are keeping track of inorder predecessor and successor for each node so that when insertion/deletion occurs, you can go to next/previous node in O(1) time."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Inorder Traversal\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arch11Tech",
                        "content": "Follow up:\\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\\n\\nI think this is about find next smallest element in BST, with time complexity being O(log(n))\\nwhich should be better than O(k)\\n\\nRight?"
                    },
                    {
                        "username": "dan_stark123",
                        "content": "I think you need to come up with some logic that decides to minimize the search space ,after a node is deleted or inserted\\n"
                    },
                    {
                        "username": "pygirl5",
                        "content": "![image](https://assets.leetcode.com/users/pygirl5/image_1579402446.png)\\n@Leetcode could you please correct this?\\nThanks in advance!\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "just a tip:\\ndo in-order traversal to get the sorted array or u can do any BFS/DFS and get the array and sort it \\nthen return the array\\'s \"k-1\"th element"
                    },
                    {
                        "username": "pinkfloyda",
                        "content": "From what I can tell, the running time is O(height of BST) + O(k), optimal means lower bound?"
                    },
                    {
                        "username": "npostavs",
                        "content": "[@brandon_busby](/brandon_busby) The tree is sorted so you don\\'t have to look at all of the nodes. E.g., if `k =1`, just go down to the left-most node and don\\'t visit any others (that\\'s `O(height)`). For larger `k` you need to visit `k` more."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "That seems like the memory requirement, not the running time. The best conceivable running time is `O(number of nodes)` since you have to look at all nodes."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "We know InOrder traversal of BST is ascending order list. So, return k-1th element."
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "is it the most optimise solution for this problem and for the follow up given for this problem ???\\n"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here are my 4 methods to solve the problem:\\n-> Binary Search\\n-> Recursive\\n-> Iterative\\n-> Morris Traversal\\n[LeetCode Solution](https://techgeekyan.blogspot.ca/2017/09/leetcode-solution-230-kth-smallest.html)"
                    },
                    {
                        "username": "victCh",
                        "content": "What is kth smallest value???"
                    }
                ]
            },
            {
                "id": 1569036,
                "content": [
                    {
                        "username": "Vicky_Prasad",
                        "content": "My Dummy Approach:\\nGet Inorder of BST and then return k-1 index value.\\nIts simple way to solve this problem."
                    },
                    {
                        "username": "firby121",
                        "content": "[@logical_thinker](/logical_thinker) if you use an array to store all elements then there\\'s no point of using the tree itself. max heap with size k is the way to go."
                    },
                    {
                        "username": "logical_thinker",
                        "content": "I think this is right approach, there is a catch here, when ever there is a insertion or a deletion we don\\'t traverse the tree again we just perform on the array that we have got when we do in-order initially, as in-order fetches us a sorted array we can insert into the array with complexity n and delete works the same way as well. So this is a better solution I think not a dummy one."
                    },
                    {
                        "username": "Evercode",
                        "content": "I think we can keep both the kth smallest element and (k-1)th smallest element. If we insert or delete an element larger than the kth smallest element, the result remains unaffected. If something smaller than is inserted, compare it with the (k-1)th smallest element. The larger one becomes the new kth smallest element and adjust (k-1)th element accordingly.\\nWe may also need to keep track of the (k+1)th smallest element in case of deleting a node smaller than the kth element. However if we keep deleting nodes, we may need the (k+2, k+3, .... )th smallest element to stay correct.\\nAny other ideas?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Using a max heap of size k would be easier to maintain"
                    },
                    {
                        "username": "SR2311",
                        "content": "When you are constructing the BST, at every node maintain a count - which is the number of nodes smaller than current node[ in other words number of nodes to the left of current node]. Also every node has a pointer which points to  it parent [ this is to handle the case when a node is deleted from the BST] .\\n\\nNow lets say everything is done and query comes:\\n\\t Starting at root in O(1) you know if your k is the left half of right half by comparing k with the count of current node. If k is smaller than the count that means our answer lies in the left half otherwise it is in the right half. Keep repeating this until we find our node\\n\\t \\nInsert Operation:\\nJust do normal BST insert and ensure to increment the count of the node if you are going down left of the tree and once you find the spot to insert assign the parent to the node.\\n\\nDelete operation:\\nConsider deleting some x node now since we have reference to the parent of every node we simply check if the node being deleted is to left or right of parent by comparing its value and if it is in the left simply decrement the count of the parent.\\n"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "basically you are keeping track of inorder predecessor and successor for each node so that when insertion/deletion occurs, you can go to next/previous node in O(1) time."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Inorder Traversal\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arch11Tech",
                        "content": "Follow up:\\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\\n\\nI think this is about find next smallest element in BST, with time complexity being O(log(n))\\nwhich should be better than O(k)\\n\\nRight?"
                    },
                    {
                        "username": "dan_stark123",
                        "content": "I think you need to come up with some logic that decides to minimize the search space ,after a node is deleted or inserted\\n"
                    },
                    {
                        "username": "pygirl5",
                        "content": "![image](https://assets.leetcode.com/users/pygirl5/image_1579402446.png)\\n@Leetcode could you please correct this?\\nThanks in advance!\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "just a tip:\\ndo in-order traversal to get the sorted array or u can do any BFS/DFS and get the array and sort it \\nthen return the array\\'s \"k-1\"th element"
                    },
                    {
                        "username": "pinkfloyda",
                        "content": "From what I can tell, the running time is O(height of BST) + O(k), optimal means lower bound?"
                    },
                    {
                        "username": "npostavs",
                        "content": "[@brandon_busby](/brandon_busby) The tree is sorted so you don\\'t have to look at all of the nodes. E.g., if `k =1`, just go down to the left-most node and don\\'t visit any others (that\\'s `O(height)`). For larger `k` you need to visit `k` more."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "That seems like the memory requirement, not the running time. The best conceivable running time is `O(number of nodes)` since you have to look at all nodes."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "We know InOrder traversal of BST is ascending order list. So, return k-1th element."
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "is it the most optimise solution for this problem and for the follow up given for this problem ???\\n"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here are my 4 methods to solve the problem:\\n-> Binary Search\\n-> Recursive\\n-> Iterative\\n-> Morris Traversal\\n[LeetCode Solution](https://techgeekyan.blogspot.ca/2017/09/leetcode-solution-230-kth-smallest.html)"
                    },
                    {
                        "username": "victCh",
                        "content": "What is kth smallest value???"
                    }
                ]
            },
            {
                "id": 1892146,
                "content": [
                    {
                        "username": "Vicky_Prasad",
                        "content": "My Dummy Approach:\\nGet Inorder of BST and then return k-1 index value.\\nIts simple way to solve this problem."
                    },
                    {
                        "username": "firby121",
                        "content": "[@logical_thinker](/logical_thinker) if you use an array to store all elements then there\\'s no point of using the tree itself. max heap with size k is the way to go."
                    },
                    {
                        "username": "logical_thinker",
                        "content": "I think this is right approach, there is a catch here, when ever there is a insertion or a deletion we don\\'t traverse the tree again we just perform on the array that we have got when we do in-order initially, as in-order fetches us a sorted array we can insert into the array with complexity n and delete works the same way as well. So this is a better solution I think not a dummy one."
                    },
                    {
                        "username": "Evercode",
                        "content": "I think we can keep both the kth smallest element and (k-1)th smallest element. If we insert or delete an element larger than the kth smallest element, the result remains unaffected. If something smaller than is inserted, compare it with the (k-1)th smallest element. The larger one becomes the new kth smallest element and adjust (k-1)th element accordingly.\\nWe may also need to keep track of the (k+1)th smallest element in case of deleting a node smaller than the kth element. However if we keep deleting nodes, we may need the (k+2, k+3, .... )th smallest element to stay correct.\\nAny other ideas?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Using a max heap of size k would be easier to maintain"
                    },
                    {
                        "username": "SR2311",
                        "content": "When you are constructing the BST, at every node maintain a count - which is the number of nodes smaller than current node[ in other words number of nodes to the left of current node]. Also every node has a pointer which points to  it parent [ this is to handle the case when a node is deleted from the BST] .\\n\\nNow lets say everything is done and query comes:\\n\\t Starting at root in O(1) you know if your k is the left half of right half by comparing k with the count of current node. If k is smaller than the count that means our answer lies in the left half otherwise it is in the right half. Keep repeating this until we find our node\\n\\t \\nInsert Operation:\\nJust do normal BST insert and ensure to increment the count of the node if you are going down left of the tree and once you find the spot to insert assign the parent to the node.\\n\\nDelete operation:\\nConsider deleting some x node now since we have reference to the parent of every node we simply check if the node being deleted is to left or right of parent by comparing its value and if it is in the left simply decrement the count of the parent.\\n"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "basically you are keeping track of inorder predecessor and successor for each node so that when insertion/deletion occurs, you can go to next/previous node in O(1) time."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Inorder Traversal\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arch11Tech",
                        "content": "Follow up:\\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\\n\\nI think this is about find next smallest element in BST, with time complexity being O(log(n))\\nwhich should be better than O(k)\\n\\nRight?"
                    },
                    {
                        "username": "dan_stark123",
                        "content": "I think you need to come up with some logic that decides to minimize the search space ,after a node is deleted or inserted\\n"
                    },
                    {
                        "username": "pygirl5",
                        "content": "![image](https://assets.leetcode.com/users/pygirl5/image_1579402446.png)\\n@Leetcode could you please correct this?\\nThanks in advance!\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "just a tip:\\ndo in-order traversal to get the sorted array or u can do any BFS/DFS and get the array and sort it \\nthen return the array\\'s \"k-1\"th element"
                    },
                    {
                        "username": "pinkfloyda",
                        "content": "From what I can tell, the running time is O(height of BST) + O(k), optimal means lower bound?"
                    },
                    {
                        "username": "npostavs",
                        "content": "[@brandon_busby](/brandon_busby) The tree is sorted so you don\\'t have to look at all of the nodes. E.g., if `k =1`, just go down to the left-most node and don\\'t visit any others (that\\'s `O(height)`). For larger `k` you need to visit `k` more."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "That seems like the memory requirement, not the running time. The best conceivable running time is `O(number of nodes)` since you have to look at all nodes."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "We know InOrder traversal of BST is ascending order list. So, return k-1th element."
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "is it the most optimise solution for this problem and for the follow up given for this problem ???\\n"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here are my 4 methods to solve the problem:\\n-> Binary Search\\n-> Recursive\\n-> Iterative\\n-> Morris Traversal\\n[LeetCode Solution](https://techgeekyan.blogspot.ca/2017/09/leetcode-solution-230-kth-smallest.html)"
                    },
                    {
                        "username": "victCh",
                        "content": "What is kth smallest value???"
                    }
                ]
            },
            {
                "id": 1571463,
                "content": [
                    {
                        "username": "Vicky_Prasad",
                        "content": "My Dummy Approach:\\nGet Inorder of BST and then return k-1 index value.\\nIts simple way to solve this problem."
                    },
                    {
                        "username": "firby121",
                        "content": "[@logical_thinker](/logical_thinker) if you use an array to store all elements then there\\'s no point of using the tree itself. max heap with size k is the way to go."
                    },
                    {
                        "username": "logical_thinker",
                        "content": "I think this is right approach, there is a catch here, when ever there is a insertion or a deletion we don\\'t traverse the tree again we just perform on the array that we have got when we do in-order initially, as in-order fetches us a sorted array we can insert into the array with complexity n and delete works the same way as well. So this is a better solution I think not a dummy one."
                    },
                    {
                        "username": "Evercode",
                        "content": "I think we can keep both the kth smallest element and (k-1)th smallest element. If we insert or delete an element larger than the kth smallest element, the result remains unaffected. If something smaller than is inserted, compare it with the (k-1)th smallest element. The larger one becomes the new kth smallest element and adjust (k-1)th element accordingly.\\nWe may also need to keep track of the (k+1)th smallest element in case of deleting a node smaller than the kth element. However if we keep deleting nodes, we may need the (k+2, k+3, .... )th smallest element to stay correct.\\nAny other ideas?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Using a max heap of size k would be easier to maintain"
                    },
                    {
                        "username": "SR2311",
                        "content": "When you are constructing the BST, at every node maintain a count - which is the number of nodes smaller than current node[ in other words number of nodes to the left of current node]. Also every node has a pointer which points to  it parent [ this is to handle the case when a node is deleted from the BST] .\\n\\nNow lets say everything is done and query comes:\\n\\t Starting at root in O(1) you know if your k is the left half of right half by comparing k with the count of current node. If k is smaller than the count that means our answer lies in the left half otherwise it is in the right half. Keep repeating this until we find our node\\n\\t \\nInsert Operation:\\nJust do normal BST insert and ensure to increment the count of the node if you are going down left of the tree and once you find the spot to insert assign the parent to the node.\\n\\nDelete operation:\\nConsider deleting some x node now since we have reference to the parent of every node we simply check if the node being deleted is to left or right of parent by comparing its value and if it is in the left simply decrement the count of the parent.\\n"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "basically you are keeping track of inorder predecessor and successor for each node so that when insertion/deletion occurs, you can go to next/previous node in O(1) time."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Inorder Traversal\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arch11Tech",
                        "content": "Follow up:\\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\\n\\nI think this is about find next smallest element in BST, with time complexity being O(log(n))\\nwhich should be better than O(k)\\n\\nRight?"
                    },
                    {
                        "username": "dan_stark123",
                        "content": "I think you need to come up with some logic that decides to minimize the search space ,after a node is deleted or inserted\\n"
                    },
                    {
                        "username": "pygirl5",
                        "content": "![image](https://assets.leetcode.com/users/pygirl5/image_1579402446.png)\\n@Leetcode could you please correct this?\\nThanks in advance!\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "just a tip:\\ndo in-order traversal to get the sorted array or u can do any BFS/DFS and get the array and sort it \\nthen return the array\\'s \"k-1\"th element"
                    },
                    {
                        "username": "pinkfloyda",
                        "content": "From what I can tell, the running time is O(height of BST) + O(k), optimal means lower bound?"
                    },
                    {
                        "username": "npostavs",
                        "content": "[@brandon_busby](/brandon_busby) The tree is sorted so you don\\'t have to look at all of the nodes. E.g., if `k =1`, just go down to the left-most node and don\\'t visit any others (that\\'s `O(height)`). For larger `k` you need to visit `k` more."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "That seems like the memory requirement, not the running time. The best conceivable running time is `O(number of nodes)` since you have to look at all nodes."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "We know InOrder traversal of BST is ascending order list. So, return k-1th element."
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "is it the most optimise solution for this problem and for the follow up given for this problem ???\\n"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here are my 4 methods to solve the problem:\\n-> Binary Search\\n-> Recursive\\n-> Iterative\\n-> Morris Traversal\\n[LeetCode Solution](https://techgeekyan.blogspot.ca/2017/09/leetcode-solution-230-kth-smallest.html)"
                    },
                    {
                        "username": "victCh",
                        "content": "What is kth smallest value???"
                    }
                ]
            },
            {
                "id": 1830611,
                "content": [
                    {
                        "username": "Vicky_Prasad",
                        "content": "My Dummy Approach:\\nGet Inorder of BST and then return k-1 index value.\\nIts simple way to solve this problem."
                    },
                    {
                        "username": "firby121",
                        "content": "[@logical_thinker](/logical_thinker) if you use an array to store all elements then there\\'s no point of using the tree itself. max heap with size k is the way to go."
                    },
                    {
                        "username": "logical_thinker",
                        "content": "I think this is right approach, there is a catch here, when ever there is a insertion or a deletion we don\\'t traverse the tree again we just perform on the array that we have got when we do in-order initially, as in-order fetches us a sorted array we can insert into the array with complexity n and delete works the same way as well. So this is a better solution I think not a dummy one."
                    },
                    {
                        "username": "Evercode",
                        "content": "I think we can keep both the kth smallest element and (k-1)th smallest element. If we insert or delete an element larger than the kth smallest element, the result remains unaffected. If something smaller than is inserted, compare it with the (k-1)th smallest element. The larger one becomes the new kth smallest element and adjust (k-1)th element accordingly.\\nWe may also need to keep track of the (k+1)th smallest element in case of deleting a node smaller than the kth element. However if we keep deleting nodes, we may need the (k+2, k+3, .... )th smallest element to stay correct.\\nAny other ideas?"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Using a max heap of size k would be easier to maintain"
                    },
                    {
                        "username": "SR2311",
                        "content": "When you are constructing the BST, at every node maintain a count - which is the number of nodes smaller than current node[ in other words number of nodes to the left of current node]. Also every node has a pointer which points to  it parent [ this is to handle the case when a node is deleted from the BST] .\\n\\nNow lets say everything is done and query comes:\\n\\t Starting at root in O(1) you know if your k is the left half of right half by comparing k with the count of current node. If k is smaller than the count that means our answer lies in the left half otherwise it is in the right half. Keep repeating this until we find our node\\n\\t \\nInsert Operation:\\nJust do normal BST insert and ensure to increment the count of the node if you are going down left of the tree and once you find the spot to insert assign the parent to the node.\\n\\nDelete operation:\\nConsider deleting some x node now since we have reference to the parent of every node we simply check if the node being deleted is to left or right of parent by comparing its value and if it is in the left simply decrement the count of the parent.\\n"
                    },
                    {
                        "username": "srivastavaanchal000",
                        "content": "basically you are keeping track of inorder predecessor and successor for each node so that when insertion/deletion occurs, you can go to next/previous node in O(1) time."
                    },
                    {
                        "username": "LeetCode",
                        "content": "This problem is the Daily LeetCoding Challenge for April, Day 18.\n\nFeel free to share anything related to this problem here!\n\nYou can ask questions, discuss what you've learned from this problem, or show off how many days of streak you've made!\n\n---\n\nIf you'd like to share a detailed solution to the problem, please create a new post in the discuss section and provide\n- **Detailed Explanations**: Describe the algorithm you used to solve this problem. Include any insights you used to solve this problem.\n- **Images** that help explain the algorithm.\n- **Language and Code** you used to pass the problem.\n- **Time and Space complexity analysis**.\n\n---\n\n  **📌 Do you want to learn the problem thoroughly?**\n  Read [**⭐  LeetCode Official Solution⭐**](https://leetcode.com/problems/kth-smallest-element-in-a-bst/solution) to learn the 3 approaches to the problem with detailed explanations to the algorithms, codes, and complexity analysis.\n  <details>\n  <summary> Spoiler Alert! We'll explain these 2 approaches in the official solution</summary>\n\n  \n**Approach 1:** Recursive Inorder Traversal\n\n  \n**Approach 2:** Iterative Inorder Traversal\n\n  \n</details>\n\n\n\nIf you're new to Daily LeetCoding Challenge, [**check out this post**](https://leetcode.com/discuss/general-discussion/655704/)!\n\n\n---\n\n<br>\n\n<p align=\"center\">\n<a href=\"https://leetcode.com/subscribe/?ref=ex_dc\" target=\"_blank\">\n  <img src=\"https://assets.leetcode.com/static_assets/marketing/daily_leetcoding_banner.png\" width=\"560px\" />\n</a>\n</p>\n\n<br>"
                    },
                    {
                        "username": "Arch11Tech",
                        "content": "Follow up:\\nWhat if the BST is modified (insert/delete operations) often and you need to find the kth smallest frequently? How would you optimize the kthSmallest routine?\\n\\nI think this is about find next smallest element in BST, with time complexity being O(log(n))\\nwhich should be better than O(k)\\n\\nRight?"
                    },
                    {
                        "username": "dan_stark123",
                        "content": "I think you need to come up with some logic that decides to minimize the search space ,after a node is deleted or inserted\\n"
                    },
                    {
                        "username": "pygirl5",
                        "content": "![image](https://assets.leetcode.com/users/pygirl5/image_1579402446.png)\\n@Leetcode could you please correct this?\\nThanks in advance!\\n"
                    },
                    {
                        "username": "ranbir7",
                        "content": "just a tip:\\ndo in-order traversal to get the sorted array or u can do any BFS/DFS and get the array and sort it \\nthen return the array\\'s \"k-1\"th element"
                    },
                    {
                        "username": "pinkfloyda",
                        "content": "From what I can tell, the running time is O(height of BST) + O(k), optimal means lower bound?"
                    },
                    {
                        "username": "npostavs",
                        "content": "[@brandon_busby](/brandon_busby) The tree is sorted so you don\\'t have to look at all of the nodes. E.g., if `k =1`, just go down to the left-most node and don\\'t visit any others (that\\'s `O(height)`). For larger `k` you need to visit `k` more."
                    },
                    {
                        "username": "brandon_busby",
                        "content": "That seems like the memory requirement, not the running time. The best conceivable running time is `O(number of nodes)` since you have to look at all nodes."
                    },
                    {
                        "username": "HARSHIT_4U",
                        "content": "We know InOrder traversal of BST is ascending order list. So, return k-1th element."
                    },
                    {
                        "username": "prajjwal002dubey",
                        "content": "is it the most optimise solution for this problem and for the follow up given for this problem ???\\n"
                    },
                    {
                        "username": "monkeykingyan",
                        "content": "Here are my 4 methods to solve the problem:\\n-> Binary Search\\n-> Recursive\\n-> Iterative\\n-> Morris Traversal\\n[LeetCode Solution](https://techgeekyan.blogspot.ca/2017/09/leetcode-solution-230-kth-smallest.html)"
                    },
                    {
                        "username": "victCh",
                        "content": "What is kth smallest value???"
                    }
                ]
            },
            {
                "id": 1739372,
                "content": [
                    {
                        "username": "minkowskiq",
                        "content": "For the followup, assuming k is fixed:\\n\\nWe can maintain an additional linked list. Each node in the tree points to a node in the linked list. Nodes of the linked list are sorted. We also maintain a pointer to the kth element in the linked list.\\n\\nNow, when an element is added or removed from the tree, we can modify the linked list accordingly in O(1) additional time.\\nAdditionally, if the element added/removed is smaller then/equal to the kth element, we decrement/increment the kth element pointer."
                    },
                    {
                        "username": "vaibhav_chachra",
                        "content": "We can probably go for something like, in the beginning we find the kth smallest node. After add or delete we can see that the node being added is greater than or less than the current node. If greater, than no changes but still be go again for log(n) for smaller."
                    },
                    {
                        "username": "MitchellHe",
                        "content": "Can anybody help solving the follow up?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Why is it labelled as Medium? This should be under easy category"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Do it in O(1) space then it\\'s not that easy"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Because of the follow up question"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To solve this problem optimally, you need to remember what a **BST** is and its properties:\n\n> In computer science, a binary search tree, also called an ordered or sorted binary tree, is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node's left subtree and less than the ones in its right subtree.\n>\n> -- Wikipedia\n\nWhat tree traversal technique would come in handy here? `Hint`"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "**First Submission:** Beats 14% Runtime\\n**Second Submission:** Beats 100% Runtime (no change in code) \\uD83D\\uDC4D\\n\\n`Rant`"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": " `HINT`\n\n-->Inorder of BST always provide node value in sorted order."
                    },
                    {
                        "username": "begin_it",
                        "content": "Should be kept in easy one."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jmakwana06",
                        "content": "should be an easy\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "koushikvsv",
                        "content": "`function kthSmallest(root: TreeNode | null, k: number): number {`\n`     let count: number = 0;`\n`    let kVal: number = -Infinity;`\n`    while (root != null) {`\n`        if (root.left == null) {`\n`            count++;`\n`            if (count == k) kVal = root.val;`\n`            root = root.right;`\n`        } else {`\n`            let R: TreeNode = rightMostNodeInLeftSubTree(root);`\n`            if (R.right == null) {`\n                 // building link\n`                R.right = root;`\n`                root = root.left;`\n`            } else {`\n                 // breaking link in next visit\n`                R.right = null;`\n`                count++;`\n`                if (count == k) kVal = root.val;`\n`              root = root.right;`\n`           }`\n`        }`\n`   }`\n`    return kVal;`\n`};`\n\n`function rightMostNodeInLeftSubTree(node) {`\n`   let temp = node.left;`\n`    if (temp.right != null && temp.right != node) {`\n`        temp = temp.right;`\n`    }`\n`    return temp;`\n`}`\n\nThis code failing for following testcase:\nroot =[41,37,44,24,39,42,48,1,35,38,40,null,43,46,49,0,2,30,36,null,null,null,null,null,null,45,47,null,null,null,null,null,4,29,32,null,null,null,null,null,null,3,9,26,null,31,34,null,null,7,11,25,27,null,null,33,null,6,8,10,16,null,null,null,28,null,null,5,null,null,null,null,null,15,19,null,null,null,null,12,null,18,20,null,13,17,null,null,22,null,14,null,null,21,23]\nk = 25\nAny idea? Any help would be highly appreciated."
                    },
                    {
                        "username": "harshshukla5810",
                        "content": "try to use inorder traversal and make use of the k given in the question"
                    }
                ]
            },
            {
                "id": 1571464,
                "content": [
                    {
                        "username": "minkowskiq",
                        "content": "For the followup, assuming k is fixed:\\n\\nWe can maintain an additional linked list. Each node in the tree points to a node in the linked list. Nodes of the linked list are sorted. We also maintain a pointer to the kth element in the linked list.\\n\\nNow, when an element is added or removed from the tree, we can modify the linked list accordingly in O(1) additional time.\\nAdditionally, if the element added/removed is smaller then/equal to the kth element, we decrement/increment the kth element pointer."
                    },
                    {
                        "username": "vaibhav_chachra",
                        "content": "We can probably go for something like, in the beginning we find the kth smallest node. After add or delete we can see that the node being added is greater than or less than the current node. If greater, than no changes but still be go again for log(n) for smaller."
                    },
                    {
                        "username": "MitchellHe",
                        "content": "Can anybody help solving the follow up?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Why is it labelled as Medium? This should be under easy category"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Do it in O(1) space then it\\'s not that easy"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Because of the follow up question"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To solve this problem optimally, you need to remember what a **BST** is and its properties:\n\n> In computer science, a binary search tree, also called an ordered or sorted binary tree, is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node's left subtree and less than the ones in its right subtree.\n>\n> -- Wikipedia\n\nWhat tree traversal technique would come in handy here? `Hint`"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "**First Submission:** Beats 14% Runtime\\n**Second Submission:** Beats 100% Runtime (no change in code) \\uD83D\\uDC4D\\n\\n`Rant`"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": " `HINT`\n\n-->Inorder of BST always provide node value in sorted order."
                    },
                    {
                        "username": "begin_it",
                        "content": "Should be kept in easy one."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jmakwana06",
                        "content": "should be an easy\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "koushikvsv",
                        "content": "`function kthSmallest(root: TreeNode | null, k: number): number {`\n`     let count: number = 0;`\n`    let kVal: number = -Infinity;`\n`    while (root != null) {`\n`        if (root.left == null) {`\n`            count++;`\n`            if (count == k) kVal = root.val;`\n`            root = root.right;`\n`        } else {`\n`            let R: TreeNode = rightMostNodeInLeftSubTree(root);`\n`            if (R.right == null) {`\n                 // building link\n`                R.right = root;`\n`                root = root.left;`\n`            } else {`\n                 // breaking link in next visit\n`                R.right = null;`\n`                count++;`\n`                if (count == k) kVal = root.val;`\n`              root = root.right;`\n`           }`\n`        }`\n`   }`\n`    return kVal;`\n`};`\n\n`function rightMostNodeInLeftSubTree(node) {`\n`   let temp = node.left;`\n`    if (temp.right != null && temp.right != node) {`\n`        temp = temp.right;`\n`    }`\n`    return temp;`\n`}`\n\nThis code failing for following testcase:\nroot =[41,37,44,24,39,42,48,1,35,38,40,null,43,46,49,0,2,30,36,null,null,null,null,null,null,45,47,null,null,null,null,null,4,29,32,null,null,null,null,null,null,3,9,26,null,31,34,null,null,7,11,25,27,null,null,33,null,6,8,10,16,null,null,null,28,null,null,5,null,null,null,null,null,15,19,null,null,null,null,12,null,18,20,null,13,17,null,null,22,null,14,null,null,21,23]\nk = 25\nAny idea? Any help would be highly appreciated."
                    },
                    {
                        "username": "harshshukla5810",
                        "content": "try to use inorder traversal and make use of the k given in the question"
                    }
                ]
            },
            {
                "id": 1960304,
                "content": [
                    {
                        "username": "minkowskiq",
                        "content": "For the followup, assuming k is fixed:\\n\\nWe can maintain an additional linked list. Each node in the tree points to a node in the linked list. Nodes of the linked list are sorted. We also maintain a pointer to the kth element in the linked list.\\n\\nNow, when an element is added or removed from the tree, we can modify the linked list accordingly in O(1) additional time.\\nAdditionally, if the element added/removed is smaller then/equal to the kth element, we decrement/increment the kth element pointer."
                    },
                    {
                        "username": "vaibhav_chachra",
                        "content": "We can probably go for something like, in the beginning we find the kth smallest node. After add or delete we can see that the node being added is greater than or less than the current node. If greater, than no changes but still be go again for log(n) for smaller."
                    },
                    {
                        "username": "MitchellHe",
                        "content": "Can anybody help solving the follow up?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Why is it labelled as Medium? This should be under easy category"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Do it in O(1) space then it\\'s not that easy"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Because of the follow up question"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To solve this problem optimally, you need to remember what a **BST** is and its properties:\n\n> In computer science, a binary search tree, also called an ordered or sorted binary tree, is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node's left subtree and less than the ones in its right subtree.\n>\n> -- Wikipedia\n\nWhat tree traversal technique would come in handy here? `Hint`"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "**First Submission:** Beats 14% Runtime\\n**Second Submission:** Beats 100% Runtime (no change in code) \\uD83D\\uDC4D\\n\\n`Rant`"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": " `HINT`\n\n-->Inorder of BST always provide node value in sorted order."
                    },
                    {
                        "username": "begin_it",
                        "content": "Should be kept in easy one."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jmakwana06",
                        "content": "should be an easy\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "koushikvsv",
                        "content": "`function kthSmallest(root: TreeNode | null, k: number): number {`\n`     let count: number = 0;`\n`    let kVal: number = -Infinity;`\n`    while (root != null) {`\n`        if (root.left == null) {`\n`            count++;`\n`            if (count == k) kVal = root.val;`\n`            root = root.right;`\n`        } else {`\n`            let R: TreeNode = rightMostNodeInLeftSubTree(root);`\n`            if (R.right == null) {`\n                 // building link\n`                R.right = root;`\n`                root = root.left;`\n`            } else {`\n                 // breaking link in next visit\n`                R.right = null;`\n`                count++;`\n`                if (count == k) kVal = root.val;`\n`              root = root.right;`\n`           }`\n`        }`\n`   }`\n`    return kVal;`\n`};`\n\n`function rightMostNodeInLeftSubTree(node) {`\n`   let temp = node.left;`\n`    if (temp.right != null && temp.right != node) {`\n`        temp = temp.right;`\n`    }`\n`    return temp;`\n`}`\n\nThis code failing for following testcase:\nroot =[41,37,44,24,39,42,48,1,35,38,40,null,43,46,49,0,2,30,36,null,null,null,null,null,null,45,47,null,null,null,null,null,4,29,32,null,null,null,null,null,null,3,9,26,null,31,34,null,null,7,11,25,27,null,null,33,null,6,8,10,16,null,null,null,28,null,null,5,null,null,null,null,null,15,19,null,null,null,null,12,null,18,20,null,13,17,null,null,22,null,14,null,null,21,23]\nk = 25\nAny idea? Any help would be highly appreciated."
                    },
                    {
                        "username": "harshshukla5810",
                        "content": "try to use inorder traversal and make use of the k given in the question"
                    }
                ]
            },
            {
                "id": 2057629,
                "content": [
                    {
                        "username": "minkowskiq",
                        "content": "For the followup, assuming k is fixed:\\n\\nWe can maintain an additional linked list. Each node in the tree points to a node in the linked list. Nodes of the linked list are sorted. We also maintain a pointer to the kth element in the linked list.\\n\\nNow, when an element is added or removed from the tree, we can modify the linked list accordingly in O(1) additional time.\\nAdditionally, if the element added/removed is smaller then/equal to the kth element, we decrement/increment the kth element pointer."
                    },
                    {
                        "username": "vaibhav_chachra",
                        "content": "We can probably go for something like, in the beginning we find the kth smallest node. After add or delete we can see that the node being added is greater than or less than the current node. If greater, than no changes but still be go again for log(n) for smaller."
                    },
                    {
                        "username": "MitchellHe",
                        "content": "Can anybody help solving the follow up?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Why is it labelled as Medium? This should be under easy category"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Do it in O(1) space then it\\'s not that easy"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Because of the follow up question"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To solve this problem optimally, you need to remember what a **BST** is and its properties:\n\n> In computer science, a binary search tree, also called an ordered or sorted binary tree, is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node's left subtree and less than the ones in its right subtree.\n>\n> -- Wikipedia\n\nWhat tree traversal technique would come in handy here? `Hint`"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "**First Submission:** Beats 14% Runtime\\n**Second Submission:** Beats 100% Runtime (no change in code) \\uD83D\\uDC4D\\n\\n`Rant`"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": " `HINT`\n\n-->Inorder of BST always provide node value in sorted order."
                    },
                    {
                        "username": "begin_it",
                        "content": "Should be kept in easy one."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jmakwana06",
                        "content": "should be an easy\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "koushikvsv",
                        "content": "`function kthSmallest(root: TreeNode | null, k: number): number {`\n`     let count: number = 0;`\n`    let kVal: number = -Infinity;`\n`    while (root != null) {`\n`        if (root.left == null) {`\n`            count++;`\n`            if (count == k) kVal = root.val;`\n`            root = root.right;`\n`        } else {`\n`            let R: TreeNode = rightMostNodeInLeftSubTree(root);`\n`            if (R.right == null) {`\n                 // building link\n`                R.right = root;`\n`                root = root.left;`\n`            } else {`\n                 // breaking link in next visit\n`                R.right = null;`\n`                count++;`\n`                if (count == k) kVal = root.val;`\n`              root = root.right;`\n`           }`\n`        }`\n`   }`\n`    return kVal;`\n`};`\n\n`function rightMostNodeInLeftSubTree(node) {`\n`   let temp = node.left;`\n`    if (temp.right != null && temp.right != node) {`\n`        temp = temp.right;`\n`    }`\n`    return temp;`\n`}`\n\nThis code failing for following testcase:\nroot =[41,37,44,24,39,42,48,1,35,38,40,null,43,46,49,0,2,30,36,null,null,null,null,null,null,45,47,null,null,null,null,null,4,29,32,null,null,null,null,null,null,3,9,26,null,31,34,null,null,7,11,25,27,null,null,33,null,6,8,10,16,null,null,null,28,null,null,5,null,null,null,null,null,15,19,null,null,null,null,12,null,18,20,null,13,17,null,null,22,null,14,null,null,21,23]\nk = 25\nAny idea? Any help would be highly appreciated."
                    },
                    {
                        "username": "harshshukla5810",
                        "content": "try to use inorder traversal and make use of the k given in the question"
                    }
                ]
            },
            {
                "id": 2057611,
                "content": [
                    {
                        "username": "minkowskiq",
                        "content": "For the followup, assuming k is fixed:\\n\\nWe can maintain an additional linked list. Each node in the tree points to a node in the linked list. Nodes of the linked list are sorted. We also maintain a pointer to the kth element in the linked list.\\n\\nNow, when an element is added or removed from the tree, we can modify the linked list accordingly in O(1) additional time.\\nAdditionally, if the element added/removed is smaller then/equal to the kth element, we decrement/increment the kth element pointer."
                    },
                    {
                        "username": "vaibhav_chachra",
                        "content": "We can probably go for something like, in the beginning we find the kth smallest node. After add or delete we can see that the node being added is greater than or less than the current node. If greater, than no changes but still be go again for log(n) for smaller."
                    },
                    {
                        "username": "MitchellHe",
                        "content": "Can anybody help solving the follow up?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Why is it labelled as Medium? This should be under easy category"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Do it in O(1) space then it\\'s not that easy"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Because of the follow up question"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To solve this problem optimally, you need to remember what a **BST** is and its properties:\n\n> In computer science, a binary search tree, also called an ordered or sorted binary tree, is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node's left subtree and less than the ones in its right subtree.\n>\n> -- Wikipedia\n\nWhat tree traversal technique would come in handy here? `Hint`"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "**First Submission:** Beats 14% Runtime\\n**Second Submission:** Beats 100% Runtime (no change in code) \\uD83D\\uDC4D\\n\\n`Rant`"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": " `HINT`\n\n-->Inorder of BST always provide node value in sorted order."
                    },
                    {
                        "username": "begin_it",
                        "content": "Should be kept in easy one."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jmakwana06",
                        "content": "should be an easy\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "koushikvsv",
                        "content": "`function kthSmallest(root: TreeNode | null, k: number): number {`\n`     let count: number = 0;`\n`    let kVal: number = -Infinity;`\n`    while (root != null) {`\n`        if (root.left == null) {`\n`            count++;`\n`            if (count == k) kVal = root.val;`\n`            root = root.right;`\n`        } else {`\n`            let R: TreeNode = rightMostNodeInLeftSubTree(root);`\n`            if (R.right == null) {`\n                 // building link\n`                R.right = root;`\n`                root = root.left;`\n`            } else {`\n                 // breaking link in next visit\n`                R.right = null;`\n`                count++;`\n`                if (count == k) kVal = root.val;`\n`              root = root.right;`\n`           }`\n`        }`\n`   }`\n`    return kVal;`\n`};`\n\n`function rightMostNodeInLeftSubTree(node) {`\n`   let temp = node.left;`\n`    if (temp.right != null && temp.right != node) {`\n`        temp = temp.right;`\n`    }`\n`    return temp;`\n`}`\n\nThis code failing for following testcase:\nroot =[41,37,44,24,39,42,48,1,35,38,40,null,43,46,49,0,2,30,36,null,null,null,null,null,null,45,47,null,null,null,null,null,4,29,32,null,null,null,null,null,null,3,9,26,null,31,34,null,null,7,11,25,27,null,null,33,null,6,8,10,16,null,null,null,28,null,null,5,null,null,null,null,null,15,19,null,null,null,null,12,null,18,20,null,13,17,null,null,22,null,14,null,null,21,23]\nk = 25\nAny idea? Any help would be highly appreciated."
                    },
                    {
                        "username": "harshshukla5810",
                        "content": "try to use inorder traversal and make use of the k given in the question"
                    }
                ]
            },
            {
                "id": 2057306,
                "content": [
                    {
                        "username": "minkowskiq",
                        "content": "For the followup, assuming k is fixed:\\n\\nWe can maintain an additional linked list. Each node in the tree points to a node in the linked list. Nodes of the linked list are sorted. We also maintain a pointer to the kth element in the linked list.\\n\\nNow, when an element is added or removed from the tree, we can modify the linked list accordingly in O(1) additional time.\\nAdditionally, if the element added/removed is smaller then/equal to the kth element, we decrement/increment the kth element pointer."
                    },
                    {
                        "username": "vaibhav_chachra",
                        "content": "We can probably go for something like, in the beginning we find the kth smallest node. After add or delete we can see that the node being added is greater than or less than the current node. If greater, than no changes but still be go again for log(n) for smaller."
                    },
                    {
                        "username": "MitchellHe",
                        "content": "Can anybody help solving the follow up?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Why is it labelled as Medium? This should be under easy category"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Do it in O(1) space then it\\'s not that easy"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Because of the follow up question"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To solve this problem optimally, you need to remember what a **BST** is and its properties:\n\n> In computer science, a binary search tree, also called an ordered or sorted binary tree, is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node's left subtree and less than the ones in its right subtree.\n>\n> -- Wikipedia\n\nWhat tree traversal technique would come in handy here? `Hint`"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "**First Submission:** Beats 14% Runtime\\n**Second Submission:** Beats 100% Runtime (no change in code) \\uD83D\\uDC4D\\n\\n`Rant`"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": " `HINT`\n\n-->Inorder of BST always provide node value in sorted order."
                    },
                    {
                        "username": "begin_it",
                        "content": "Should be kept in easy one."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jmakwana06",
                        "content": "should be an easy\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "koushikvsv",
                        "content": "`function kthSmallest(root: TreeNode | null, k: number): number {`\n`     let count: number = 0;`\n`    let kVal: number = -Infinity;`\n`    while (root != null) {`\n`        if (root.left == null) {`\n`            count++;`\n`            if (count == k) kVal = root.val;`\n`            root = root.right;`\n`        } else {`\n`            let R: TreeNode = rightMostNodeInLeftSubTree(root);`\n`            if (R.right == null) {`\n                 // building link\n`                R.right = root;`\n`                root = root.left;`\n`            } else {`\n                 // breaking link in next visit\n`                R.right = null;`\n`                count++;`\n`                if (count == k) kVal = root.val;`\n`              root = root.right;`\n`           }`\n`        }`\n`   }`\n`    return kVal;`\n`};`\n\n`function rightMostNodeInLeftSubTree(node) {`\n`   let temp = node.left;`\n`    if (temp.right != null && temp.right != node) {`\n`        temp = temp.right;`\n`    }`\n`    return temp;`\n`}`\n\nThis code failing for following testcase:\nroot =[41,37,44,24,39,42,48,1,35,38,40,null,43,46,49,0,2,30,36,null,null,null,null,null,null,45,47,null,null,null,null,null,4,29,32,null,null,null,null,null,null,3,9,26,null,31,34,null,null,7,11,25,27,null,null,33,null,6,8,10,16,null,null,null,28,null,null,5,null,null,null,null,null,15,19,null,null,null,null,12,null,18,20,null,13,17,null,null,22,null,14,null,null,21,23]\nk = 25\nAny idea? Any help would be highly appreciated."
                    },
                    {
                        "username": "harshshukla5810",
                        "content": "try to use inorder traversal and make use of the k given in the question"
                    }
                ]
            },
            {
                "id": 2008095,
                "content": [
                    {
                        "username": "minkowskiq",
                        "content": "For the followup, assuming k is fixed:\\n\\nWe can maintain an additional linked list. Each node in the tree points to a node in the linked list. Nodes of the linked list are sorted. We also maintain a pointer to the kth element in the linked list.\\n\\nNow, when an element is added or removed from the tree, we can modify the linked list accordingly in O(1) additional time.\\nAdditionally, if the element added/removed is smaller then/equal to the kth element, we decrement/increment the kth element pointer."
                    },
                    {
                        "username": "vaibhav_chachra",
                        "content": "We can probably go for something like, in the beginning we find the kth smallest node. After add or delete we can see that the node being added is greater than or less than the current node. If greater, than no changes but still be go again for log(n) for smaller."
                    },
                    {
                        "username": "MitchellHe",
                        "content": "Can anybody help solving the follow up?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Why is it labelled as Medium? This should be under easy category"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Do it in O(1) space then it\\'s not that easy"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Because of the follow up question"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To solve this problem optimally, you need to remember what a **BST** is and its properties:\n\n> In computer science, a binary search tree, also called an ordered or sorted binary tree, is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node's left subtree and less than the ones in its right subtree.\n>\n> -- Wikipedia\n\nWhat tree traversal technique would come in handy here? `Hint`"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "**First Submission:** Beats 14% Runtime\\n**Second Submission:** Beats 100% Runtime (no change in code) \\uD83D\\uDC4D\\n\\n`Rant`"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": " `HINT`\n\n-->Inorder of BST always provide node value in sorted order."
                    },
                    {
                        "username": "begin_it",
                        "content": "Should be kept in easy one."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jmakwana06",
                        "content": "should be an easy\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "koushikvsv",
                        "content": "`function kthSmallest(root: TreeNode | null, k: number): number {`\n`     let count: number = 0;`\n`    let kVal: number = -Infinity;`\n`    while (root != null) {`\n`        if (root.left == null) {`\n`            count++;`\n`            if (count == k) kVal = root.val;`\n`            root = root.right;`\n`        } else {`\n`            let R: TreeNode = rightMostNodeInLeftSubTree(root);`\n`            if (R.right == null) {`\n                 // building link\n`                R.right = root;`\n`                root = root.left;`\n`            } else {`\n                 // breaking link in next visit\n`                R.right = null;`\n`                count++;`\n`                if (count == k) kVal = root.val;`\n`              root = root.right;`\n`           }`\n`        }`\n`   }`\n`    return kVal;`\n`};`\n\n`function rightMostNodeInLeftSubTree(node) {`\n`   let temp = node.left;`\n`    if (temp.right != null && temp.right != node) {`\n`        temp = temp.right;`\n`    }`\n`    return temp;`\n`}`\n\nThis code failing for following testcase:\nroot =[41,37,44,24,39,42,48,1,35,38,40,null,43,46,49,0,2,30,36,null,null,null,null,null,null,45,47,null,null,null,null,null,4,29,32,null,null,null,null,null,null,3,9,26,null,31,34,null,null,7,11,25,27,null,null,33,null,6,8,10,16,null,null,null,28,null,null,5,null,null,null,null,null,15,19,null,null,null,null,12,null,18,20,null,13,17,null,null,22,null,14,null,null,21,23]\nk = 25\nAny idea? Any help would be highly appreciated."
                    },
                    {
                        "username": "harshshukla5810",
                        "content": "try to use inorder traversal and make use of the k given in the question"
                    }
                ]
            },
            {
                "id": 2003484,
                "content": [
                    {
                        "username": "minkowskiq",
                        "content": "For the followup, assuming k is fixed:\\n\\nWe can maintain an additional linked list. Each node in the tree points to a node in the linked list. Nodes of the linked list are sorted. We also maintain a pointer to the kth element in the linked list.\\n\\nNow, when an element is added or removed from the tree, we can modify the linked list accordingly in O(1) additional time.\\nAdditionally, if the element added/removed is smaller then/equal to the kth element, we decrement/increment the kth element pointer."
                    },
                    {
                        "username": "vaibhav_chachra",
                        "content": "We can probably go for something like, in the beginning we find the kth smallest node. After add or delete we can see that the node being added is greater than or less than the current node. If greater, than no changes but still be go again for log(n) for smaller."
                    },
                    {
                        "username": "MitchellHe",
                        "content": "Can anybody help solving the follow up?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Why is it labelled as Medium? This should be under easy category"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Do it in O(1) space then it\\'s not that easy"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Because of the follow up question"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To solve this problem optimally, you need to remember what a **BST** is and its properties:\n\n> In computer science, a binary search tree, also called an ordered or sorted binary tree, is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node's left subtree and less than the ones in its right subtree.\n>\n> -- Wikipedia\n\nWhat tree traversal technique would come in handy here? `Hint`"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "**First Submission:** Beats 14% Runtime\\n**Second Submission:** Beats 100% Runtime (no change in code) \\uD83D\\uDC4D\\n\\n`Rant`"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": " `HINT`\n\n-->Inorder of BST always provide node value in sorted order."
                    },
                    {
                        "username": "begin_it",
                        "content": "Should be kept in easy one."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jmakwana06",
                        "content": "should be an easy\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "koushikvsv",
                        "content": "`function kthSmallest(root: TreeNode | null, k: number): number {`\n`     let count: number = 0;`\n`    let kVal: number = -Infinity;`\n`    while (root != null) {`\n`        if (root.left == null) {`\n`            count++;`\n`            if (count == k) kVal = root.val;`\n`            root = root.right;`\n`        } else {`\n`            let R: TreeNode = rightMostNodeInLeftSubTree(root);`\n`            if (R.right == null) {`\n                 // building link\n`                R.right = root;`\n`                root = root.left;`\n`            } else {`\n                 // breaking link in next visit\n`                R.right = null;`\n`                count++;`\n`                if (count == k) kVal = root.val;`\n`              root = root.right;`\n`           }`\n`        }`\n`   }`\n`    return kVal;`\n`};`\n\n`function rightMostNodeInLeftSubTree(node) {`\n`   let temp = node.left;`\n`    if (temp.right != null && temp.right != node) {`\n`        temp = temp.right;`\n`    }`\n`    return temp;`\n`}`\n\nThis code failing for following testcase:\nroot =[41,37,44,24,39,42,48,1,35,38,40,null,43,46,49,0,2,30,36,null,null,null,null,null,null,45,47,null,null,null,null,null,4,29,32,null,null,null,null,null,null,3,9,26,null,31,34,null,null,7,11,25,27,null,null,33,null,6,8,10,16,null,null,null,28,null,null,5,null,null,null,null,null,15,19,null,null,null,null,12,null,18,20,null,13,17,null,null,22,null,14,null,null,21,23]\nk = 25\nAny idea? Any help would be highly appreciated."
                    },
                    {
                        "username": "harshshukla5810",
                        "content": "try to use inorder traversal and make use of the k given in the question"
                    }
                ]
            },
            {
                "id": 1977369,
                "content": [
                    {
                        "username": "minkowskiq",
                        "content": "For the followup, assuming k is fixed:\\n\\nWe can maintain an additional linked list. Each node in the tree points to a node in the linked list. Nodes of the linked list are sorted. We also maintain a pointer to the kth element in the linked list.\\n\\nNow, when an element is added or removed from the tree, we can modify the linked list accordingly in O(1) additional time.\\nAdditionally, if the element added/removed is smaller then/equal to the kth element, we decrement/increment the kth element pointer."
                    },
                    {
                        "username": "vaibhav_chachra",
                        "content": "We can probably go for something like, in the beginning we find the kth smallest node. After add or delete we can see that the node being added is greater than or less than the current node. If greater, than no changes but still be go again for log(n) for smaller."
                    },
                    {
                        "username": "MitchellHe",
                        "content": "Can anybody help solving the follow up?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Why is it labelled as Medium? This should be under easy category"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Do it in O(1) space then it\\'s not that easy"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Because of the follow up question"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To solve this problem optimally, you need to remember what a **BST** is and its properties:\n\n> In computer science, a binary search tree, also called an ordered or sorted binary tree, is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node's left subtree and less than the ones in its right subtree.\n>\n> -- Wikipedia\n\nWhat tree traversal technique would come in handy here? `Hint`"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "**First Submission:** Beats 14% Runtime\\n**Second Submission:** Beats 100% Runtime (no change in code) \\uD83D\\uDC4D\\n\\n`Rant`"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": " `HINT`\n\n-->Inorder of BST always provide node value in sorted order."
                    },
                    {
                        "username": "begin_it",
                        "content": "Should be kept in easy one."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jmakwana06",
                        "content": "should be an easy\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "koushikvsv",
                        "content": "`function kthSmallest(root: TreeNode | null, k: number): number {`\n`     let count: number = 0;`\n`    let kVal: number = -Infinity;`\n`    while (root != null) {`\n`        if (root.left == null) {`\n`            count++;`\n`            if (count == k) kVal = root.val;`\n`            root = root.right;`\n`        } else {`\n`            let R: TreeNode = rightMostNodeInLeftSubTree(root);`\n`            if (R.right == null) {`\n                 // building link\n`                R.right = root;`\n`                root = root.left;`\n`            } else {`\n                 // breaking link in next visit\n`                R.right = null;`\n`                count++;`\n`                if (count == k) kVal = root.val;`\n`              root = root.right;`\n`           }`\n`        }`\n`   }`\n`    return kVal;`\n`};`\n\n`function rightMostNodeInLeftSubTree(node) {`\n`   let temp = node.left;`\n`    if (temp.right != null && temp.right != node) {`\n`        temp = temp.right;`\n`    }`\n`    return temp;`\n`}`\n\nThis code failing for following testcase:\nroot =[41,37,44,24,39,42,48,1,35,38,40,null,43,46,49,0,2,30,36,null,null,null,null,null,null,45,47,null,null,null,null,null,4,29,32,null,null,null,null,null,null,3,9,26,null,31,34,null,null,7,11,25,27,null,null,33,null,6,8,10,16,null,null,null,28,null,null,5,null,null,null,null,null,15,19,null,null,null,null,12,null,18,20,null,13,17,null,null,22,null,14,null,null,21,23]\nk = 25\nAny idea? Any help would be highly appreciated."
                    },
                    {
                        "username": "harshshukla5810",
                        "content": "try to use inorder traversal and make use of the k given in the question"
                    }
                ]
            },
            {
                "id": 1950812,
                "content": [
                    {
                        "username": "minkowskiq",
                        "content": "For the followup, assuming k is fixed:\\n\\nWe can maintain an additional linked list. Each node in the tree points to a node in the linked list. Nodes of the linked list are sorted. We also maintain a pointer to the kth element in the linked list.\\n\\nNow, when an element is added or removed from the tree, we can modify the linked list accordingly in O(1) additional time.\\nAdditionally, if the element added/removed is smaller then/equal to the kth element, we decrement/increment the kth element pointer."
                    },
                    {
                        "username": "vaibhav_chachra",
                        "content": "We can probably go for something like, in the beginning we find the kth smallest node. After add or delete we can see that the node being added is greater than or less than the current node. If greater, than no changes but still be go again for log(n) for smaller."
                    },
                    {
                        "username": "MitchellHe",
                        "content": "Can anybody help solving the follow up?"
                    },
                    {
                        "username": "Divyam6969",
                        "content": "Why is it labelled as Medium? This should be under easy category"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "Rightlyso",
                        "content": "Do it in O(1) space then it\\'s not that easy"
                    },
                    {
                        "username": "tanmayyyj",
                        "content": "Because of the follow up question"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "To solve this problem optimally, you need to remember what a **BST** is and its properties:\n\n> In computer science, a binary search tree, also called an ordered or sorted binary tree, is a rooted binary tree data structure with the key of each internal node being greater than all the keys in the respective node's left subtree and less than the ones in its right subtree.\n>\n> -- Wikipedia\n\nWhat tree traversal technique would come in handy here? `Hint`"
                    },
                    {
                        "username": "SSHshadow2222",
                        "content": "**First Submission:** Beats 14% Runtime\\n**Second Submission:** Beats 100% Runtime (no change in code) \\uD83D\\uDC4D\\n\\n`Rant`"
                    },
                    {
                        "username": "RCchoudhary",
                        "content": " `HINT`\n\n-->Inorder of BST always provide node value in sorted order."
                    },
                    {
                        "username": "begin_it",
                        "content": "Should be kept in easy one."
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "jmakwana06",
                        "content": "should be an easy\\n"
                    },
                    {
                        "username": "georgezakharov",
                        "content": "They all say that the problem should be easy until they got it on an interview (c)"
                    },
                    {
                        "username": "koushikvsv",
                        "content": "`function kthSmallest(root: TreeNode | null, k: number): number {`\n`     let count: number = 0;`\n`    let kVal: number = -Infinity;`\n`    while (root != null) {`\n`        if (root.left == null) {`\n`            count++;`\n`            if (count == k) kVal = root.val;`\n`            root = root.right;`\n`        } else {`\n`            let R: TreeNode = rightMostNodeInLeftSubTree(root);`\n`            if (R.right == null) {`\n                 // building link\n`                R.right = root;`\n`                root = root.left;`\n`            } else {`\n                 // breaking link in next visit\n`                R.right = null;`\n`                count++;`\n`                if (count == k) kVal = root.val;`\n`              root = root.right;`\n`           }`\n`        }`\n`   }`\n`    return kVal;`\n`};`\n\n`function rightMostNodeInLeftSubTree(node) {`\n`   let temp = node.left;`\n`    if (temp.right != null && temp.right != node) {`\n`        temp = temp.right;`\n`    }`\n`    return temp;`\n`}`\n\nThis code failing for following testcase:\nroot =[41,37,44,24,39,42,48,1,35,38,40,null,43,46,49,0,2,30,36,null,null,null,null,null,null,45,47,null,null,null,null,null,4,29,32,null,null,null,null,null,null,3,9,26,null,31,34,null,null,7,11,25,27,null,null,33,null,6,8,10,16,null,null,null,28,null,null,5,null,null,null,null,null,15,19,null,null,null,null,12,null,18,20,null,13,17,null,null,22,null,14,null,null,21,23]\nk = 25\nAny idea? Any help would be highly appreciated."
                    },
                    {
                        "username": "harshshukla5810",
                        "content": "try to use inorder traversal and make use of the k given in the question"
                    }
                ]
            },
            {
                "id": 1929354,
                "content": [
                    {
                        "username": "rajender7",
                        "content": "Why does Morris Traversal give a `stack-overflow` in C++?"
                    },
                    {
                        "username": "amalyshev",
                        "content": "Because you have a mistake somewhere in your code."
                    },
                    {
                        "username": "amalyshev",
                        "content": "This looks like a simple in order tree traversal. What\\'s the catch? Why is this Medium? I think this should be Easy."
                    },
                    {
                        "username": "user8256RW",
                        "content": "Is the test case number 12 broken? It says the output fot [1,null,2], k = 2 is 1.[@LeetCode](/LeetCode)\\n "
                    },
                    {
                        "username": "prasadborse",
                        "content": " class Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        TreeNode* curr = root;\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                k--;\\n                if(k==0)    \\n                    return curr->val;\\n                curr = curr->right;\\n            }\\n            else{\\n                TreeNode* prev = curr->left;\\n                while(prev->right && prev->right!=curr){\\n                    prev = prev->right;\\n                }\\n                if(!prev->right){\\n                    prev->right = curr;\\n                    curr = curr->left;\\n                }\\n                else if(prev->right == curr){\\n                    prev->right = NULL;\\n                    k--;\\n                    if(k==0)\\n                        return curr->val;\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\nfor this code why I\\'m getting error \\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==22==ERROR: AddressSanitizer: stack-overflow on address 0x7ffe29182ff8 (pc 0x00000037d5f9 bp 0x7ffe29183010 sp 0x7ffe29183000 T0)\\n==22==ABORTING\\n\\nwhere as it\\'s working on my local compiler"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Could Someone help me with my solution my solution is based on three steps:-\n1-get the min by traversing the tree in level-order.\n2- create a treeSet and adding all the values of the tree in my treeSet.\n3-i made recursion call to get the kth-smallest base on my min base on k\nlike if k==1 it will return the minimum value of the Tree \n                    4\n                   / \\\n                 2   5\n                / \\\n              1   3\nbut  if k=3 it should return 4 so in the recursion function it will get the ceiling of the min and make it the min until k==1.\n\nHeres is my code:-\n\n\nits ok i solve it .\n \n\n\n\n class Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        \n        // 1-get the min in the root and the root to the treeSet.\n\n        int min=Integer.MAX_VALUE;\n\n        TreeSet<Integer>treeSet=new  TreeSet<>();\n        Queue<TreeNode>q=new LinkedList<>();\n        q.add(root);\n\n        while(!q.isEmpty()){\n            TreeNode curr=q.poll();\n            min=Math.min(min,curr.val);\n            treeSet.add(curr.val);\n\n            if(curr.left!=null)\n               q.add(curr.left);\n\n             if(curr.right!=null)\n               q.add(curr.right);    \n        }\n             \n        if(k>treeSet.size())\n           return -1;\n\n           int mink=min;\n\n           while(k!=1){\n               mink=treeSet.higher(mink);\n               k--;\n           }\n             \n        return mink;\n    }\n}\n\n"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "Great question to apply Morris Traversal."
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the follow up question, the rules don\\'t say that the tree needs to be preserved so you can just remove nodes one by one until you have removed the kth node then return that node\\'s value."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Can we use Morris TraverSal?"
                    },
                    {
                        "username": "cagils",
                        "content": "you can use k as the counter with inorder recursive traversal, and with js sprinkle in some IIFE and you got this:\\n```js\\n    (function dfs(n) {\\n        if (!n) return\\n        dfs(n.left)\\n        if (!--k) res = n.val\\n        dfs(n.right)\\n    })(root);\\n};\\n```"
                    },
                    {
                        "username": "Caleb_hknyc",
                        "content": "class Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        start = 0\n        stack = []\n        stack.append(root)\n        visited = set()\n        while stack:\n            cur = stack.pop()\n            if cur in visited:\n                continue\n            while cur.left and cur.left not in visited:\n                stack.append(cur)\n                cur = cur.left\n            if cur != None:\n                start += 1\n            if start == k:\n                return cur.val\n            if cur.right:\n                while cur.right:\n                    cur = cur.right\n                    stack.append(cur)\n            if cur:\n                     visited.add(cur)\n        \nTypeError: None is not valid value for the expected return type integer\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\nLine 98 in _driver (Solution.py)\n    _driver()\nLine 105 in <module> (Solution.py)\nDuring handling of the above exception, another exception occurred:\nTypeError: '<' not supported between instances of 'int' and 'NoneType'\nLine 12 in _serialize_int (./python3/__serializer__.py)\nLine 61 in _serialize (./python3/__serializer__.py)\n    out = ser._serialize(ret, 'integer')\nLine 96 in _driver (Solution.py)\n\nwhy am I getting a error in here.....how "
                    }
                ]
            },
            {
                "id": 1925977,
                "content": [
                    {
                        "username": "rajender7",
                        "content": "Why does Morris Traversal give a `stack-overflow` in C++?"
                    },
                    {
                        "username": "amalyshev",
                        "content": "Because you have a mistake somewhere in your code."
                    },
                    {
                        "username": "amalyshev",
                        "content": "This looks like a simple in order tree traversal. What\\'s the catch? Why is this Medium? I think this should be Easy."
                    },
                    {
                        "username": "user8256RW",
                        "content": "Is the test case number 12 broken? It says the output fot [1,null,2], k = 2 is 1.[@LeetCode](/LeetCode)\\n "
                    },
                    {
                        "username": "prasadborse",
                        "content": " class Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        TreeNode* curr = root;\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                k--;\\n                if(k==0)    \\n                    return curr->val;\\n                curr = curr->right;\\n            }\\n            else{\\n                TreeNode* prev = curr->left;\\n                while(prev->right && prev->right!=curr){\\n                    prev = prev->right;\\n                }\\n                if(!prev->right){\\n                    prev->right = curr;\\n                    curr = curr->left;\\n                }\\n                else if(prev->right == curr){\\n                    prev->right = NULL;\\n                    k--;\\n                    if(k==0)\\n                        return curr->val;\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\nfor this code why I\\'m getting error \\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==22==ERROR: AddressSanitizer: stack-overflow on address 0x7ffe29182ff8 (pc 0x00000037d5f9 bp 0x7ffe29183010 sp 0x7ffe29183000 T0)\\n==22==ABORTING\\n\\nwhere as it\\'s working on my local compiler"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Could Someone help me with my solution my solution is based on three steps:-\n1-get the min by traversing the tree in level-order.\n2- create a treeSet and adding all the values of the tree in my treeSet.\n3-i made recursion call to get the kth-smallest base on my min base on k\nlike if k==1 it will return the minimum value of the Tree \n                    4\n                   / \\\n                 2   5\n                / \\\n              1   3\nbut  if k=3 it should return 4 so in the recursion function it will get the ceiling of the min and make it the min until k==1.\n\nHeres is my code:-\n\n\nits ok i solve it .\n \n\n\n\n class Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        \n        // 1-get the min in the root and the root to the treeSet.\n\n        int min=Integer.MAX_VALUE;\n\n        TreeSet<Integer>treeSet=new  TreeSet<>();\n        Queue<TreeNode>q=new LinkedList<>();\n        q.add(root);\n\n        while(!q.isEmpty()){\n            TreeNode curr=q.poll();\n            min=Math.min(min,curr.val);\n            treeSet.add(curr.val);\n\n            if(curr.left!=null)\n               q.add(curr.left);\n\n             if(curr.right!=null)\n               q.add(curr.right);    \n        }\n             \n        if(k>treeSet.size())\n           return -1;\n\n           int mink=min;\n\n           while(k!=1){\n               mink=treeSet.higher(mink);\n               k--;\n           }\n             \n        return mink;\n    }\n}\n\n"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "Great question to apply Morris Traversal."
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the follow up question, the rules don\\'t say that the tree needs to be preserved so you can just remove nodes one by one until you have removed the kth node then return that node\\'s value."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Can we use Morris TraverSal?"
                    },
                    {
                        "username": "cagils",
                        "content": "you can use k as the counter with inorder recursive traversal, and with js sprinkle in some IIFE and you got this:\\n```js\\n    (function dfs(n) {\\n        if (!n) return\\n        dfs(n.left)\\n        if (!--k) res = n.val\\n        dfs(n.right)\\n    })(root);\\n};\\n```"
                    },
                    {
                        "username": "Caleb_hknyc",
                        "content": "class Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        start = 0\n        stack = []\n        stack.append(root)\n        visited = set()\n        while stack:\n            cur = stack.pop()\n            if cur in visited:\n                continue\n            while cur.left and cur.left not in visited:\n                stack.append(cur)\n                cur = cur.left\n            if cur != None:\n                start += 1\n            if start == k:\n                return cur.val\n            if cur.right:\n                while cur.right:\n                    cur = cur.right\n                    stack.append(cur)\n            if cur:\n                     visited.add(cur)\n        \nTypeError: None is not valid value for the expected return type integer\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\nLine 98 in _driver (Solution.py)\n    _driver()\nLine 105 in <module> (Solution.py)\nDuring handling of the above exception, another exception occurred:\nTypeError: '<' not supported between instances of 'int' and 'NoneType'\nLine 12 in _serialize_int (./python3/__serializer__.py)\nLine 61 in _serialize (./python3/__serializer__.py)\n    out = ser._serialize(ret, 'integer')\nLine 96 in _driver (Solution.py)\n\nwhy am I getting a error in here.....how "
                    }
                ]
            },
            {
                "id": 1918230,
                "content": [
                    {
                        "username": "rajender7",
                        "content": "Why does Morris Traversal give a `stack-overflow` in C++?"
                    },
                    {
                        "username": "amalyshev",
                        "content": "Because you have a mistake somewhere in your code."
                    },
                    {
                        "username": "amalyshev",
                        "content": "This looks like a simple in order tree traversal. What\\'s the catch? Why is this Medium? I think this should be Easy."
                    },
                    {
                        "username": "user8256RW",
                        "content": "Is the test case number 12 broken? It says the output fot [1,null,2], k = 2 is 1.[@LeetCode](/LeetCode)\\n "
                    },
                    {
                        "username": "prasadborse",
                        "content": " class Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        TreeNode* curr = root;\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                k--;\\n                if(k==0)    \\n                    return curr->val;\\n                curr = curr->right;\\n            }\\n            else{\\n                TreeNode* prev = curr->left;\\n                while(prev->right && prev->right!=curr){\\n                    prev = prev->right;\\n                }\\n                if(!prev->right){\\n                    prev->right = curr;\\n                    curr = curr->left;\\n                }\\n                else if(prev->right == curr){\\n                    prev->right = NULL;\\n                    k--;\\n                    if(k==0)\\n                        return curr->val;\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\nfor this code why I\\'m getting error \\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==22==ERROR: AddressSanitizer: stack-overflow on address 0x7ffe29182ff8 (pc 0x00000037d5f9 bp 0x7ffe29183010 sp 0x7ffe29183000 T0)\\n==22==ABORTING\\n\\nwhere as it\\'s working on my local compiler"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Could Someone help me with my solution my solution is based on three steps:-\n1-get the min by traversing the tree in level-order.\n2- create a treeSet and adding all the values of the tree in my treeSet.\n3-i made recursion call to get the kth-smallest base on my min base on k\nlike if k==1 it will return the minimum value of the Tree \n                    4\n                   / \\\n                 2   5\n                / \\\n              1   3\nbut  if k=3 it should return 4 so in the recursion function it will get the ceiling of the min and make it the min until k==1.\n\nHeres is my code:-\n\n\nits ok i solve it .\n \n\n\n\n class Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        \n        // 1-get the min in the root and the root to the treeSet.\n\n        int min=Integer.MAX_VALUE;\n\n        TreeSet<Integer>treeSet=new  TreeSet<>();\n        Queue<TreeNode>q=new LinkedList<>();\n        q.add(root);\n\n        while(!q.isEmpty()){\n            TreeNode curr=q.poll();\n            min=Math.min(min,curr.val);\n            treeSet.add(curr.val);\n\n            if(curr.left!=null)\n               q.add(curr.left);\n\n             if(curr.right!=null)\n               q.add(curr.right);    \n        }\n             \n        if(k>treeSet.size())\n           return -1;\n\n           int mink=min;\n\n           while(k!=1){\n               mink=treeSet.higher(mink);\n               k--;\n           }\n             \n        return mink;\n    }\n}\n\n"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "Great question to apply Morris Traversal."
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the follow up question, the rules don\\'t say that the tree needs to be preserved so you can just remove nodes one by one until you have removed the kth node then return that node\\'s value."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Can we use Morris TraverSal?"
                    },
                    {
                        "username": "cagils",
                        "content": "you can use k as the counter with inorder recursive traversal, and with js sprinkle in some IIFE and you got this:\\n```js\\n    (function dfs(n) {\\n        if (!n) return\\n        dfs(n.left)\\n        if (!--k) res = n.val\\n        dfs(n.right)\\n    })(root);\\n};\\n```"
                    },
                    {
                        "username": "Caleb_hknyc",
                        "content": "class Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        start = 0\n        stack = []\n        stack.append(root)\n        visited = set()\n        while stack:\n            cur = stack.pop()\n            if cur in visited:\n                continue\n            while cur.left and cur.left not in visited:\n                stack.append(cur)\n                cur = cur.left\n            if cur != None:\n                start += 1\n            if start == k:\n                return cur.val\n            if cur.right:\n                while cur.right:\n                    cur = cur.right\n                    stack.append(cur)\n            if cur:\n                     visited.add(cur)\n        \nTypeError: None is not valid value for the expected return type integer\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\nLine 98 in _driver (Solution.py)\n    _driver()\nLine 105 in <module> (Solution.py)\nDuring handling of the above exception, another exception occurred:\nTypeError: '<' not supported between instances of 'int' and 'NoneType'\nLine 12 in _serialize_int (./python3/__serializer__.py)\nLine 61 in _serialize (./python3/__serializer__.py)\n    out = ser._serialize(ret, 'integer')\nLine 96 in _driver (Solution.py)\n\nwhy am I getting a error in here.....how "
                    }
                ]
            },
            {
                "id": 1898745,
                "content": [
                    {
                        "username": "rajender7",
                        "content": "Why does Morris Traversal give a `stack-overflow` in C++?"
                    },
                    {
                        "username": "amalyshev",
                        "content": "Because you have a mistake somewhere in your code."
                    },
                    {
                        "username": "amalyshev",
                        "content": "This looks like a simple in order tree traversal. What\\'s the catch? Why is this Medium? I think this should be Easy."
                    },
                    {
                        "username": "user8256RW",
                        "content": "Is the test case number 12 broken? It says the output fot [1,null,2], k = 2 is 1.[@LeetCode](/LeetCode)\\n "
                    },
                    {
                        "username": "prasadborse",
                        "content": " class Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        TreeNode* curr = root;\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                k--;\\n                if(k==0)    \\n                    return curr->val;\\n                curr = curr->right;\\n            }\\n            else{\\n                TreeNode* prev = curr->left;\\n                while(prev->right && prev->right!=curr){\\n                    prev = prev->right;\\n                }\\n                if(!prev->right){\\n                    prev->right = curr;\\n                    curr = curr->left;\\n                }\\n                else if(prev->right == curr){\\n                    prev->right = NULL;\\n                    k--;\\n                    if(k==0)\\n                        return curr->val;\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\nfor this code why I\\'m getting error \\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==22==ERROR: AddressSanitizer: stack-overflow on address 0x7ffe29182ff8 (pc 0x00000037d5f9 bp 0x7ffe29183010 sp 0x7ffe29183000 T0)\\n==22==ABORTING\\n\\nwhere as it\\'s working on my local compiler"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Could Someone help me with my solution my solution is based on three steps:-\n1-get the min by traversing the tree in level-order.\n2- create a treeSet and adding all the values of the tree in my treeSet.\n3-i made recursion call to get the kth-smallest base on my min base on k\nlike if k==1 it will return the minimum value of the Tree \n                    4\n                   / \\\n                 2   5\n                / \\\n              1   3\nbut  if k=3 it should return 4 so in the recursion function it will get the ceiling of the min and make it the min until k==1.\n\nHeres is my code:-\n\n\nits ok i solve it .\n \n\n\n\n class Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        \n        // 1-get the min in the root and the root to the treeSet.\n\n        int min=Integer.MAX_VALUE;\n\n        TreeSet<Integer>treeSet=new  TreeSet<>();\n        Queue<TreeNode>q=new LinkedList<>();\n        q.add(root);\n\n        while(!q.isEmpty()){\n            TreeNode curr=q.poll();\n            min=Math.min(min,curr.val);\n            treeSet.add(curr.val);\n\n            if(curr.left!=null)\n               q.add(curr.left);\n\n             if(curr.right!=null)\n               q.add(curr.right);    \n        }\n             \n        if(k>treeSet.size())\n           return -1;\n\n           int mink=min;\n\n           while(k!=1){\n               mink=treeSet.higher(mink);\n               k--;\n           }\n             \n        return mink;\n    }\n}\n\n"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "Great question to apply Morris Traversal."
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the follow up question, the rules don\\'t say that the tree needs to be preserved so you can just remove nodes one by one until you have removed the kth node then return that node\\'s value."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Can we use Morris TraverSal?"
                    },
                    {
                        "username": "cagils",
                        "content": "you can use k as the counter with inorder recursive traversal, and with js sprinkle in some IIFE and you got this:\\n```js\\n    (function dfs(n) {\\n        if (!n) return\\n        dfs(n.left)\\n        if (!--k) res = n.val\\n        dfs(n.right)\\n    })(root);\\n};\\n```"
                    },
                    {
                        "username": "Caleb_hknyc",
                        "content": "class Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        start = 0\n        stack = []\n        stack.append(root)\n        visited = set()\n        while stack:\n            cur = stack.pop()\n            if cur in visited:\n                continue\n            while cur.left and cur.left not in visited:\n                stack.append(cur)\n                cur = cur.left\n            if cur != None:\n                start += 1\n            if start == k:\n                return cur.val\n            if cur.right:\n                while cur.right:\n                    cur = cur.right\n                    stack.append(cur)\n            if cur:\n                     visited.add(cur)\n        \nTypeError: None is not valid value for the expected return type integer\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\nLine 98 in _driver (Solution.py)\n    _driver()\nLine 105 in <module> (Solution.py)\nDuring handling of the above exception, another exception occurred:\nTypeError: '<' not supported between instances of 'int' and 'NoneType'\nLine 12 in _serialize_int (./python3/__serializer__.py)\nLine 61 in _serialize (./python3/__serializer__.py)\n    out = ser._serialize(ret, 'integer')\nLine 96 in _driver (Solution.py)\n\nwhy am I getting a error in here.....how "
                    }
                ]
            },
            {
                "id": 1886967,
                "content": [
                    {
                        "username": "rajender7",
                        "content": "Why does Morris Traversal give a `stack-overflow` in C++?"
                    },
                    {
                        "username": "amalyshev",
                        "content": "Because you have a mistake somewhere in your code."
                    },
                    {
                        "username": "amalyshev",
                        "content": "This looks like a simple in order tree traversal. What\\'s the catch? Why is this Medium? I think this should be Easy."
                    },
                    {
                        "username": "user8256RW",
                        "content": "Is the test case number 12 broken? It says the output fot [1,null,2], k = 2 is 1.[@LeetCode](/LeetCode)\\n "
                    },
                    {
                        "username": "prasadborse",
                        "content": " class Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        TreeNode* curr = root;\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                k--;\\n                if(k==0)    \\n                    return curr->val;\\n                curr = curr->right;\\n            }\\n            else{\\n                TreeNode* prev = curr->left;\\n                while(prev->right && prev->right!=curr){\\n                    prev = prev->right;\\n                }\\n                if(!prev->right){\\n                    prev->right = curr;\\n                    curr = curr->left;\\n                }\\n                else if(prev->right == curr){\\n                    prev->right = NULL;\\n                    k--;\\n                    if(k==0)\\n                        return curr->val;\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\nfor this code why I\\'m getting error \\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==22==ERROR: AddressSanitizer: stack-overflow on address 0x7ffe29182ff8 (pc 0x00000037d5f9 bp 0x7ffe29183010 sp 0x7ffe29183000 T0)\\n==22==ABORTING\\n\\nwhere as it\\'s working on my local compiler"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Could Someone help me with my solution my solution is based on three steps:-\n1-get the min by traversing the tree in level-order.\n2- create a treeSet and adding all the values of the tree in my treeSet.\n3-i made recursion call to get the kth-smallest base on my min base on k\nlike if k==1 it will return the minimum value of the Tree \n                    4\n                   / \\\n                 2   5\n                / \\\n              1   3\nbut  if k=3 it should return 4 so in the recursion function it will get the ceiling of the min and make it the min until k==1.\n\nHeres is my code:-\n\n\nits ok i solve it .\n \n\n\n\n class Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        \n        // 1-get the min in the root and the root to the treeSet.\n\n        int min=Integer.MAX_VALUE;\n\n        TreeSet<Integer>treeSet=new  TreeSet<>();\n        Queue<TreeNode>q=new LinkedList<>();\n        q.add(root);\n\n        while(!q.isEmpty()){\n            TreeNode curr=q.poll();\n            min=Math.min(min,curr.val);\n            treeSet.add(curr.val);\n\n            if(curr.left!=null)\n               q.add(curr.left);\n\n             if(curr.right!=null)\n               q.add(curr.right);    \n        }\n             \n        if(k>treeSet.size())\n           return -1;\n\n           int mink=min;\n\n           while(k!=1){\n               mink=treeSet.higher(mink);\n               k--;\n           }\n             \n        return mink;\n    }\n}\n\n"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "Great question to apply Morris Traversal."
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the follow up question, the rules don\\'t say that the tree needs to be preserved so you can just remove nodes one by one until you have removed the kth node then return that node\\'s value."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Can we use Morris TraverSal?"
                    },
                    {
                        "username": "cagils",
                        "content": "you can use k as the counter with inorder recursive traversal, and with js sprinkle in some IIFE and you got this:\\n```js\\n    (function dfs(n) {\\n        if (!n) return\\n        dfs(n.left)\\n        if (!--k) res = n.val\\n        dfs(n.right)\\n    })(root);\\n};\\n```"
                    },
                    {
                        "username": "Caleb_hknyc",
                        "content": "class Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        start = 0\n        stack = []\n        stack.append(root)\n        visited = set()\n        while stack:\n            cur = stack.pop()\n            if cur in visited:\n                continue\n            while cur.left and cur.left not in visited:\n                stack.append(cur)\n                cur = cur.left\n            if cur != None:\n                start += 1\n            if start == k:\n                return cur.val\n            if cur.right:\n                while cur.right:\n                    cur = cur.right\n                    stack.append(cur)\n            if cur:\n                     visited.add(cur)\n        \nTypeError: None is not valid value for the expected return type integer\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\nLine 98 in _driver (Solution.py)\n    _driver()\nLine 105 in <module> (Solution.py)\nDuring handling of the above exception, another exception occurred:\nTypeError: '<' not supported between instances of 'int' and 'NoneType'\nLine 12 in _serialize_int (./python3/__serializer__.py)\nLine 61 in _serialize (./python3/__serializer__.py)\n    out = ser._serialize(ret, 'integer')\nLine 96 in _driver (Solution.py)\n\nwhy am I getting a error in here.....how "
                    }
                ]
            },
            {
                "id": 1883086,
                "content": [
                    {
                        "username": "rajender7",
                        "content": "Why does Morris Traversal give a `stack-overflow` in C++?"
                    },
                    {
                        "username": "amalyshev",
                        "content": "Because you have a mistake somewhere in your code."
                    },
                    {
                        "username": "amalyshev",
                        "content": "This looks like a simple in order tree traversal. What\\'s the catch? Why is this Medium? I think this should be Easy."
                    },
                    {
                        "username": "user8256RW",
                        "content": "Is the test case number 12 broken? It says the output fot [1,null,2], k = 2 is 1.[@LeetCode](/LeetCode)\\n "
                    },
                    {
                        "username": "prasadborse",
                        "content": " class Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        TreeNode* curr = root;\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                k--;\\n                if(k==0)    \\n                    return curr->val;\\n                curr = curr->right;\\n            }\\n            else{\\n                TreeNode* prev = curr->left;\\n                while(prev->right && prev->right!=curr){\\n                    prev = prev->right;\\n                }\\n                if(!prev->right){\\n                    prev->right = curr;\\n                    curr = curr->left;\\n                }\\n                else if(prev->right == curr){\\n                    prev->right = NULL;\\n                    k--;\\n                    if(k==0)\\n                        return curr->val;\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\nfor this code why I\\'m getting error \\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==22==ERROR: AddressSanitizer: stack-overflow on address 0x7ffe29182ff8 (pc 0x00000037d5f9 bp 0x7ffe29183010 sp 0x7ffe29183000 T0)\\n==22==ABORTING\\n\\nwhere as it\\'s working on my local compiler"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Could Someone help me with my solution my solution is based on three steps:-\n1-get the min by traversing the tree in level-order.\n2- create a treeSet and adding all the values of the tree in my treeSet.\n3-i made recursion call to get the kth-smallest base on my min base on k\nlike if k==1 it will return the minimum value of the Tree \n                    4\n                   / \\\n                 2   5\n                / \\\n              1   3\nbut  if k=3 it should return 4 so in the recursion function it will get the ceiling of the min and make it the min until k==1.\n\nHeres is my code:-\n\n\nits ok i solve it .\n \n\n\n\n class Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        \n        // 1-get the min in the root and the root to the treeSet.\n\n        int min=Integer.MAX_VALUE;\n\n        TreeSet<Integer>treeSet=new  TreeSet<>();\n        Queue<TreeNode>q=new LinkedList<>();\n        q.add(root);\n\n        while(!q.isEmpty()){\n            TreeNode curr=q.poll();\n            min=Math.min(min,curr.val);\n            treeSet.add(curr.val);\n\n            if(curr.left!=null)\n               q.add(curr.left);\n\n             if(curr.right!=null)\n               q.add(curr.right);    \n        }\n             \n        if(k>treeSet.size())\n           return -1;\n\n           int mink=min;\n\n           while(k!=1){\n               mink=treeSet.higher(mink);\n               k--;\n           }\n             \n        return mink;\n    }\n}\n\n"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "Great question to apply Morris Traversal."
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the follow up question, the rules don\\'t say that the tree needs to be preserved so you can just remove nodes one by one until you have removed the kth node then return that node\\'s value."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Can we use Morris TraverSal?"
                    },
                    {
                        "username": "cagils",
                        "content": "you can use k as the counter with inorder recursive traversal, and with js sprinkle in some IIFE and you got this:\\n```js\\n    (function dfs(n) {\\n        if (!n) return\\n        dfs(n.left)\\n        if (!--k) res = n.val\\n        dfs(n.right)\\n    })(root);\\n};\\n```"
                    },
                    {
                        "username": "Caleb_hknyc",
                        "content": "class Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        start = 0\n        stack = []\n        stack.append(root)\n        visited = set()\n        while stack:\n            cur = stack.pop()\n            if cur in visited:\n                continue\n            while cur.left and cur.left not in visited:\n                stack.append(cur)\n                cur = cur.left\n            if cur != None:\n                start += 1\n            if start == k:\n                return cur.val\n            if cur.right:\n                while cur.right:\n                    cur = cur.right\n                    stack.append(cur)\n            if cur:\n                     visited.add(cur)\n        \nTypeError: None is not valid value for the expected return type integer\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\nLine 98 in _driver (Solution.py)\n    _driver()\nLine 105 in <module> (Solution.py)\nDuring handling of the above exception, another exception occurred:\nTypeError: '<' not supported between instances of 'int' and 'NoneType'\nLine 12 in _serialize_int (./python3/__serializer__.py)\nLine 61 in _serialize (./python3/__serializer__.py)\n    out = ser._serialize(ret, 'integer')\nLine 96 in _driver (Solution.py)\n\nwhy am I getting a error in here.....how "
                    }
                ]
            },
            {
                "id": 1867171,
                "content": [
                    {
                        "username": "rajender7",
                        "content": "Why does Morris Traversal give a `stack-overflow` in C++?"
                    },
                    {
                        "username": "amalyshev",
                        "content": "Because you have a mistake somewhere in your code."
                    },
                    {
                        "username": "amalyshev",
                        "content": "This looks like a simple in order tree traversal. What\\'s the catch? Why is this Medium? I think this should be Easy."
                    },
                    {
                        "username": "user8256RW",
                        "content": "Is the test case number 12 broken? It says the output fot [1,null,2], k = 2 is 1.[@LeetCode](/LeetCode)\\n "
                    },
                    {
                        "username": "prasadborse",
                        "content": " class Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        TreeNode* curr = root;\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                k--;\\n                if(k==0)    \\n                    return curr->val;\\n                curr = curr->right;\\n            }\\n            else{\\n                TreeNode* prev = curr->left;\\n                while(prev->right && prev->right!=curr){\\n                    prev = prev->right;\\n                }\\n                if(!prev->right){\\n                    prev->right = curr;\\n                    curr = curr->left;\\n                }\\n                else if(prev->right == curr){\\n                    prev->right = NULL;\\n                    k--;\\n                    if(k==0)\\n                        return curr->val;\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\nfor this code why I\\'m getting error \\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==22==ERROR: AddressSanitizer: stack-overflow on address 0x7ffe29182ff8 (pc 0x00000037d5f9 bp 0x7ffe29183010 sp 0x7ffe29183000 T0)\\n==22==ABORTING\\n\\nwhere as it\\'s working on my local compiler"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Could Someone help me with my solution my solution is based on three steps:-\n1-get the min by traversing the tree in level-order.\n2- create a treeSet and adding all the values of the tree in my treeSet.\n3-i made recursion call to get the kth-smallest base on my min base on k\nlike if k==1 it will return the minimum value of the Tree \n                    4\n                   / \\\n                 2   5\n                / \\\n              1   3\nbut  if k=3 it should return 4 so in the recursion function it will get the ceiling of the min and make it the min until k==1.\n\nHeres is my code:-\n\n\nits ok i solve it .\n \n\n\n\n class Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        \n        // 1-get the min in the root and the root to the treeSet.\n\n        int min=Integer.MAX_VALUE;\n\n        TreeSet<Integer>treeSet=new  TreeSet<>();\n        Queue<TreeNode>q=new LinkedList<>();\n        q.add(root);\n\n        while(!q.isEmpty()){\n            TreeNode curr=q.poll();\n            min=Math.min(min,curr.val);\n            treeSet.add(curr.val);\n\n            if(curr.left!=null)\n               q.add(curr.left);\n\n             if(curr.right!=null)\n               q.add(curr.right);    \n        }\n             \n        if(k>treeSet.size())\n           return -1;\n\n           int mink=min;\n\n           while(k!=1){\n               mink=treeSet.higher(mink);\n               k--;\n           }\n             \n        return mink;\n    }\n}\n\n"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "Great question to apply Morris Traversal."
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the follow up question, the rules don\\'t say that the tree needs to be preserved so you can just remove nodes one by one until you have removed the kth node then return that node\\'s value."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Can we use Morris TraverSal?"
                    },
                    {
                        "username": "cagils",
                        "content": "you can use k as the counter with inorder recursive traversal, and with js sprinkle in some IIFE and you got this:\\n```js\\n    (function dfs(n) {\\n        if (!n) return\\n        dfs(n.left)\\n        if (!--k) res = n.val\\n        dfs(n.right)\\n    })(root);\\n};\\n```"
                    },
                    {
                        "username": "Caleb_hknyc",
                        "content": "class Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        start = 0\n        stack = []\n        stack.append(root)\n        visited = set()\n        while stack:\n            cur = stack.pop()\n            if cur in visited:\n                continue\n            while cur.left and cur.left not in visited:\n                stack.append(cur)\n                cur = cur.left\n            if cur != None:\n                start += 1\n            if start == k:\n                return cur.val\n            if cur.right:\n                while cur.right:\n                    cur = cur.right\n                    stack.append(cur)\n            if cur:\n                     visited.add(cur)\n        \nTypeError: None is not valid value for the expected return type integer\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\nLine 98 in _driver (Solution.py)\n    _driver()\nLine 105 in <module> (Solution.py)\nDuring handling of the above exception, another exception occurred:\nTypeError: '<' not supported between instances of 'int' and 'NoneType'\nLine 12 in _serialize_int (./python3/__serializer__.py)\nLine 61 in _serialize (./python3/__serializer__.py)\n    out = ser._serialize(ret, 'integer')\nLine 96 in _driver (Solution.py)\n\nwhy am I getting a error in here.....how "
                    }
                ]
            },
            {
                "id": 1844342,
                "content": [
                    {
                        "username": "rajender7",
                        "content": "Why does Morris Traversal give a `stack-overflow` in C++?"
                    },
                    {
                        "username": "amalyshev",
                        "content": "Because you have a mistake somewhere in your code."
                    },
                    {
                        "username": "amalyshev",
                        "content": "This looks like a simple in order tree traversal. What\\'s the catch? Why is this Medium? I think this should be Easy."
                    },
                    {
                        "username": "user8256RW",
                        "content": "Is the test case number 12 broken? It says the output fot [1,null,2], k = 2 is 1.[@LeetCode](/LeetCode)\\n "
                    },
                    {
                        "username": "prasadborse",
                        "content": " class Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        TreeNode* curr = root;\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                k--;\\n                if(k==0)    \\n                    return curr->val;\\n                curr = curr->right;\\n            }\\n            else{\\n                TreeNode* prev = curr->left;\\n                while(prev->right && prev->right!=curr){\\n                    prev = prev->right;\\n                }\\n                if(!prev->right){\\n                    prev->right = curr;\\n                    curr = curr->left;\\n                }\\n                else if(prev->right == curr){\\n                    prev->right = NULL;\\n                    k--;\\n                    if(k==0)\\n                        return curr->val;\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\nfor this code why I\\'m getting error \\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==22==ERROR: AddressSanitizer: stack-overflow on address 0x7ffe29182ff8 (pc 0x00000037d5f9 bp 0x7ffe29183010 sp 0x7ffe29183000 T0)\\n==22==ABORTING\\n\\nwhere as it\\'s working on my local compiler"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Could Someone help me with my solution my solution is based on three steps:-\n1-get the min by traversing the tree in level-order.\n2- create a treeSet and adding all the values of the tree in my treeSet.\n3-i made recursion call to get the kth-smallest base on my min base on k\nlike if k==1 it will return the minimum value of the Tree \n                    4\n                   / \\\n                 2   5\n                / \\\n              1   3\nbut  if k=3 it should return 4 so in the recursion function it will get the ceiling of the min and make it the min until k==1.\n\nHeres is my code:-\n\n\nits ok i solve it .\n \n\n\n\n class Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        \n        // 1-get the min in the root and the root to the treeSet.\n\n        int min=Integer.MAX_VALUE;\n\n        TreeSet<Integer>treeSet=new  TreeSet<>();\n        Queue<TreeNode>q=new LinkedList<>();\n        q.add(root);\n\n        while(!q.isEmpty()){\n            TreeNode curr=q.poll();\n            min=Math.min(min,curr.val);\n            treeSet.add(curr.val);\n\n            if(curr.left!=null)\n               q.add(curr.left);\n\n             if(curr.right!=null)\n               q.add(curr.right);    \n        }\n             \n        if(k>treeSet.size())\n           return -1;\n\n           int mink=min;\n\n           while(k!=1){\n               mink=treeSet.higher(mink);\n               k--;\n           }\n             \n        return mink;\n    }\n}\n\n"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "Great question to apply Morris Traversal."
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the follow up question, the rules don\\'t say that the tree needs to be preserved so you can just remove nodes one by one until you have removed the kth node then return that node\\'s value."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Can we use Morris TraverSal?"
                    },
                    {
                        "username": "cagils",
                        "content": "you can use k as the counter with inorder recursive traversal, and with js sprinkle in some IIFE and you got this:\\n```js\\n    (function dfs(n) {\\n        if (!n) return\\n        dfs(n.left)\\n        if (!--k) res = n.val\\n        dfs(n.right)\\n    })(root);\\n};\\n```"
                    },
                    {
                        "username": "Caleb_hknyc",
                        "content": "class Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        start = 0\n        stack = []\n        stack.append(root)\n        visited = set()\n        while stack:\n            cur = stack.pop()\n            if cur in visited:\n                continue\n            while cur.left and cur.left not in visited:\n                stack.append(cur)\n                cur = cur.left\n            if cur != None:\n                start += 1\n            if start == k:\n                return cur.val\n            if cur.right:\n                while cur.right:\n                    cur = cur.right\n                    stack.append(cur)\n            if cur:\n                     visited.add(cur)\n        \nTypeError: None is not valid value for the expected return type integer\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\nLine 98 in _driver (Solution.py)\n    _driver()\nLine 105 in <module> (Solution.py)\nDuring handling of the above exception, another exception occurred:\nTypeError: '<' not supported between instances of 'int' and 'NoneType'\nLine 12 in _serialize_int (./python3/__serializer__.py)\nLine 61 in _serialize (./python3/__serializer__.py)\n    out = ser._serialize(ret, 'integer')\nLine 96 in _driver (Solution.py)\n\nwhy am I getting a error in here.....how "
                    }
                ]
            },
            {
                "id": 1835137,
                "content": [
                    {
                        "username": "rajender7",
                        "content": "Why does Morris Traversal give a `stack-overflow` in C++?"
                    },
                    {
                        "username": "amalyshev",
                        "content": "Because you have a mistake somewhere in your code."
                    },
                    {
                        "username": "amalyshev",
                        "content": "This looks like a simple in order tree traversal. What\\'s the catch? Why is this Medium? I think this should be Easy."
                    },
                    {
                        "username": "user8256RW",
                        "content": "Is the test case number 12 broken? It says the output fot [1,null,2], k = 2 is 1.[@LeetCode](/LeetCode)\\n "
                    },
                    {
                        "username": "prasadborse",
                        "content": " class Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        TreeNode* curr = root;\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                k--;\\n                if(k==0)    \\n                    return curr->val;\\n                curr = curr->right;\\n            }\\n            else{\\n                TreeNode* prev = curr->left;\\n                while(prev->right && prev->right!=curr){\\n                    prev = prev->right;\\n                }\\n                if(!prev->right){\\n                    prev->right = curr;\\n                    curr = curr->left;\\n                }\\n                else if(prev->right == curr){\\n                    prev->right = NULL;\\n                    k--;\\n                    if(k==0)\\n                        return curr->val;\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\nfor this code why I\\'m getting error \\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==22==ERROR: AddressSanitizer: stack-overflow on address 0x7ffe29182ff8 (pc 0x00000037d5f9 bp 0x7ffe29183010 sp 0x7ffe29183000 T0)\\n==22==ABORTING\\n\\nwhere as it\\'s working on my local compiler"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Could Someone help me with my solution my solution is based on three steps:-\n1-get the min by traversing the tree in level-order.\n2- create a treeSet and adding all the values of the tree in my treeSet.\n3-i made recursion call to get the kth-smallest base on my min base on k\nlike if k==1 it will return the minimum value of the Tree \n                    4\n                   / \\\n                 2   5\n                / \\\n              1   3\nbut  if k=3 it should return 4 so in the recursion function it will get the ceiling of the min and make it the min until k==1.\n\nHeres is my code:-\n\n\nits ok i solve it .\n \n\n\n\n class Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        \n        // 1-get the min in the root and the root to the treeSet.\n\n        int min=Integer.MAX_VALUE;\n\n        TreeSet<Integer>treeSet=new  TreeSet<>();\n        Queue<TreeNode>q=new LinkedList<>();\n        q.add(root);\n\n        while(!q.isEmpty()){\n            TreeNode curr=q.poll();\n            min=Math.min(min,curr.val);\n            treeSet.add(curr.val);\n\n            if(curr.left!=null)\n               q.add(curr.left);\n\n             if(curr.right!=null)\n               q.add(curr.right);    \n        }\n             \n        if(k>treeSet.size())\n           return -1;\n\n           int mink=min;\n\n           while(k!=1){\n               mink=treeSet.higher(mink);\n               k--;\n           }\n             \n        return mink;\n    }\n}\n\n"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "Great question to apply Morris Traversal."
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the follow up question, the rules don\\'t say that the tree needs to be preserved so you can just remove nodes one by one until you have removed the kth node then return that node\\'s value."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Can we use Morris TraverSal?"
                    },
                    {
                        "username": "cagils",
                        "content": "you can use k as the counter with inorder recursive traversal, and with js sprinkle in some IIFE and you got this:\\n```js\\n    (function dfs(n) {\\n        if (!n) return\\n        dfs(n.left)\\n        if (!--k) res = n.val\\n        dfs(n.right)\\n    })(root);\\n};\\n```"
                    },
                    {
                        "username": "Caleb_hknyc",
                        "content": "class Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        start = 0\n        stack = []\n        stack.append(root)\n        visited = set()\n        while stack:\n            cur = stack.pop()\n            if cur in visited:\n                continue\n            while cur.left and cur.left not in visited:\n                stack.append(cur)\n                cur = cur.left\n            if cur != None:\n                start += 1\n            if start == k:\n                return cur.val\n            if cur.right:\n                while cur.right:\n                    cur = cur.right\n                    stack.append(cur)\n            if cur:\n                     visited.add(cur)\n        \nTypeError: None is not valid value for the expected return type integer\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\nLine 98 in _driver (Solution.py)\n    _driver()\nLine 105 in <module> (Solution.py)\nDuring handling of the above exception, another exception occurred:\nTypeError: '<' not supported between instances of 'int' and 'NoneType'\nLine 12 in _serialize_int (./python3/__serializer__.py)\nLine 61 in _serialize (./python3/__serializer__.py)\n    out = ser._serialize(ret, 'integer')\nLine 96 in _driver (Solution.py)\n\nwhy am I getting a error in here.....how "
                    }
                ]
            },
            {
                "id": 1825532,
                "content": [
                    {
                        "username": "rajender7",
                        "content": "Why does Morris Traversal give a `stack-overflow` in C++?"
                    },
                    {
                        "username": "amalyshev",
                        "content": "Because you have a mistake somewhere in your code."
                    },
                    {
                        "username": "amalyshev",
                        "content": "This looks like a simple in order tree traversal. What\\'s the catch? Why is this Medium? I think this should be Easy."
                    },
                    {
                        "username": "user8256RW",
                        "content": "Is the test case number 12 broken? It says the output fot [1,null,2], k = 2 is 1.[@LeetCode](/LeetCode)\\n "
                    },
                    {
                        "username": "prasadborse",
                        "content": " class Solution {\\npublic:\\n    int kthSmallest(TreeNode* root, int k) {\\n        TreeNode* curr = root;\\n        while(curr != NULL){\\n            if(curr->left == NULL){\\n                k--;\\n                if(k==0)    \\n                    return curr->val;\\n                curr = curr->right;\\n            }\\n            else{\\n                TreeNode* prev = curr->left;\\n                while(prev->right && prev->right!=curr){\\n                    prev = prev->right;\\n                }\\n                if(!prev->right){\\n                    prev->right = curr;\\n                    curr = curr->left;\\n                }\\n                else if(prev->right == curr){\\n                    prev->right = NULL;\\n                    k--;\\n                    if(k==0)\\n                        return curr->val;\\n                    curr = curr->right;\\n                }\\n            }\\n        }\\n        return 0;\\n    }\\n};\\n\\nfor this code why I\\'m getting error \\nAddressSanitizer:DEADLYSIGNAL\\n=================================================================\\n==22==ERROR: AddressSanitizer: stack-overflow on address 0x7ffe29182ff8 (pc 0x00000037d5f9 bp 0x7ffe29183010 sp 0x7ffe29183000 T0)\\n==22==ABORTING\\n\\nwhere as it\\'s working on my local compiler"
                    },
                    {
                        "username": "yousefbeiruty61",
                        "content": "Could Someone help me with my solution my solution is based on three steps:-\n1-get the min by traversing the tree in level-order.\n2- create a treeSet and adding all the values of the tree in my treeSet.\n3-i made recursion call to get the kth-smallest base on my min base on k\nlike if k==1 it will return the minimum value of the Tree \n                    4\n                   / \\\n                 2   5\n                / \\\n              1   3\nbut  if k=3 it should return 4 so in the recursion function it will get the ceiling of the min and make it the min until k==1.\n\nHeres is my code:-\n\n\nits ok i solve it .\n \n\n\n\n class Solution {\n    public int kthSmallest(TreeNode root, int k) {\n        \n        // 1-get the min in the root and the root to the treeSet.\n\n        int min=Integer.MAX_VALUE;\n\n        TreeSet<Integer>treeSet=new  TreeSet<>();\n        Queue<TreeNode>q=new LinkedList<>();\n        q.add(root);\n\n        while(!q.isEmpty()){\n            TreeNode curr=q.poll();\n            min=Math.min(min,curr.val);\n            treeSet.add(curr.val);\n\n            if(curr.left!=null)\n               q.add(curr.left);\n\n             if(curr.right!=null)\n               q.add(curr.right);    \n        }\n             \n        if(k>treeSet.size())\n           return -1;\n\n           int mink=min;\n\n           while(k!=1){\n               mink=treeSet.higher(mink);\n               k--;\n           }\n             \n        return mink;\n    }\n}\n\n"
                    },
                    {
                        "username": "gyt4x8ue7w6tf4y",
                        "content": "Great question to apply Morris Traversal."
                    },
                    {
                        "username": "psionl0",
                        "content": "In spite of the follow up question, the rules don\\'t say that the tree needs to be preserved so you can just remove nodes one by one until you have removed the kth node then return that node\\'s value."
                    },
                    {
                        "username": "ZeroSkillzzz",
                        "content": "Can we use Morris TraverSal?"
                    },
                    {
                        "username": "cagils",
                        "content": "you can use k as the counter with inorder recursive traversal, and with js sprinkle in some IIFE and you got this:\\n```js\\n    (function dfs(n) {\\n        if (!n) return\\n        dfs(n.left)\\n        if (!--k) res = n.val\\n        dfs(n.right)\\n    })(root);\\n};\\n```"
                    },
                    {
                        "username": "Caleb_hknyc",
                        "content": "class Solution:\n    def kthSmallest(self, root: Optional[TreeNode], k: int) -> int:\n        start = 0\n        stack = []\n        stack.append(root)\n        visited = set()\n        while stack:\n            cur = stack.pop()\n            if cur in visited:\n                continue\n            while cur.left and cur.left not in visited:\n                stack.append(cur)\n                cur = cur.left\n            if cur != None:\n                start += 1\n            if start == k:\n                return cur.val\n            if cur.right:\n                while cur.right:\n                    cur = cur.right\n                    stack.append(cur)\n            if cur:\n                     visited.add(cur)\n        \nTypeError: None is not valid value for the expected return type integer\n    raise TypeError(str(ret) + \" is not valid value for the expected return type integer\");\nLine 98 in _driver (Solution.py)\n    _driver()\nLine 105 in <module> (Solution.py)\nDuring handling of the above exception, another exception occurred:\nTypeError: '<' not supported between instances of 'int' and 'NoneType'\nLine 12 in _serialize_int (./python3/__serializer__.py)\nLine 61 in _serialize (./python3/__serializer__.py)\n    out = ser._serialize(ret, 'integer')\nLine 96 in _driver (Solution.py)\n\nwhy am I getting a error in here.....how "
                    }
                ]
            }
        ]
    },
    {
        "title": "Patching Array",
        "question_content": "<p>Given a sorted integer array <code>nums</code> and an integer <code>n</code>, add/patch elements to the array such that any number in the range <code>[1, n]</code> inclusive can be formed by the sum of some elements in the array.</p>\n\n<p>Return <em>the minimum number of patches required</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,3], n = 6\n<strong>Output:</strong> 1\nExplanation:\nCombinations of nums are [1], [3], [1,3], which form possible sums of: 1, 3, 4.\nNow if we add/patch 2 to nums, the combinations are: [1], [2], [3], [1,3], [2,3], [1,2,3].\nPossible sums are 1, 2, 3, 4, 5, 6, which now covers the range [1, 6].\nSo we only need 1 patch.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,5,10], n = 20\n<strong>Output:</strong> 2\nExplanation: The two patches can be [2, 4].\n</pre>\n\n<p><strong class=\"example\">Example 3:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,2], n = 5\n<strong>Output:</strong> 0\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= nums.length &lt;= 1000</code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>4</sup></code></li>\n\t<li><code>nums</code> is sorted in <strong>ascending order</strong>.</li>\n\t<li><code>1 &lt;= n &lt;= 2<sup>31</sup> - 1</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 78488,
                "title": "solution-explanation",
                "content": "**Solution**\\n\\n    int minPatches(vector<int>& nums, int n) {\\n        long miss = 1, added = 0, i = 0;\\n        while (miss <= n) {\\n            if (i < nums.size() && nums[i] <= miss) {\\n                miss += nums[i++];\\n            } else {\\n                miss += miss;\\n                added++;\\n            }\\n        }\\n        return added;\\n    }\\n\\n---\\n\\n**Explanation**\\n\\nLet `miss` be the smallest sum in `[0,n]` that we might be missing. Meaning we already know we can build all sums in `[0,miss)`. Then if we have a number `num <= miss` in the given array, we can add it to those smaller sums to build all sums in `[0,miss+num)`. If we don't, then we must add such a number to the array, and it's best to add `miss` itself, to maximize the reach.\\n\\n---\\n\\n**Example:** Let's say the input is `nums = [1, 2, 4, 13, 43]` and `n = 100`. We need to ensure that all sums in the range [1,100] are possible.\\n\\nUsing the given numbers 1, 2 and 4, we can already build all sums from 0 to 7, i.e., the range [0,8). But we can't build the sum 8, and the next given number (13) is too large. So we insert 8 into the array. Then we can build all sums in [0,16).\\n\\nDo we need to insert 16 into the array? No! We can already build the sum 3, and adding the given 13 gives us sum 16. We can also add the 13 to the other sums, extending our range to [0,29).\\n\\nAnd so on. The given 43 is too large to help with sum 29, so we must insert 29 into our array. This extends our range to [0,58). But then the 43 becomes useful and expands our range to [0,101). At which point we're done.\\n\\n---\\n\\n**Another implementation**, though I prefer the above one.\\n\\n    int minPatches(vector<int>& nums, int n) {\\n        int count = 0, i = 0;\\n        for (long miss=1; miss <= n; count++)\\n            miss += (i < nums.size() && nums[i] <= miss) ? nums[i++] : miss;\\n        return count - i;\\n    }",
                "solutionTags": [],
                "code": "**Solution**\\n\\n    int minPatches(vector<int>& nums, int n) {\\n        long miss = 1, added = 0, i = 0;\\n        while (miss <= n) {\\n            if (i < nums.size() && nums[i] <= miss) {\\n                miss += nums[i++];\\n            } else {\\n                miss += miss;\\n                added++;\\n            }\\n        }\\n        return added;\\n    }\\n\\n---\\n\\n**Explanation**\\n\\nLet `miss` be the smallest sum in `[0,n]` that we might be missing. Meaning we already know we can build all sums in `[0,miss)`. Then if we have a number `num <= miss` in the given array, we can add it to those smaller sums to build all sums in `[0,miss+num)`. If we don't, then we must add such a number to the array, and it's best to add `miss` itself, to maximize the reach.\\n\\n---\\n\\n**Example:** Let's say the input is `nums = [1, 2, 4, 13, 43]` and `n = 100`. We need to ensure that all sums in the range [1,100] are possible.\\n\\nUsing the given numbers 1, 2 and 4, we can already build all sums from 0 to 7, i.e., the range [0,8). But we can't build the sum 8, and the next given number (13) is too large. So we insert 8 into the array. Then we can build all sums in [0,16).\\n\\nDo we need to insert 16 into the array? No! We can already build the sum 3, and adding the given 13 gives us sum 16. We can also add the 13 to the other sums, extending our range to [0,29).\\n\\nAnd so on. The given 43 is too large to help with sum 29, so we must insert 29 into our array. This extends our range to [0,58). But then the 43 becomes useful and expands our range to [0,101). At which point we're done.\\n\\n---\\n\\n**Another implementation**, though I prefer the above one.\\n\\n    int minPatches(vector<int>& nums, int n) {\\n        int count = 0, i = 0;\\n        for (long miss=1; miss <= n; count++)\\n            miss += (i < nums.size() && nums[i] <= miss) ? nums[i++] : miss;\\n        return count - i;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 78492,
                "title": "c-8ms-greedy-solution-with-explanation",
                "content": "show the algorithm with an example,\\n\\nlet nums=[1 2 5 6 20], n = 50.\\n\\nInitial value: with 0 nums, we can only get 0 maximumly.\\n\\nThen we need to get 1, since nums[0]=1, then we can get 1 using [1]. now the maximum number we can get is 1. (actually, we can get all number no greater than the maximum number)\\n\\n    number used [1], number added []\\n    can achieve 1~1\\n\\nThen we need to get 2 (maximum number +1). Since nums[1]=2, we can get 2. Now we can get all number between 1 ~ 3 (3=previous maximum value + the new number 2). and 3 is current maximum number we can get.\\n\\n    number used [1 2], number added []\\n    can achieve 1~3\\n\\nThen we need to get 4 (3+1). Since nums[2]=5>4; we need to add a new number to get 4. The optimal solution is to add 4 directly. In this case, we could achieve maximumly 7, using [1,2,4].\\n\\n    number used [1 2], number added [4]\\n    can achieve 1~7\\n\\nThen we need to get 8 (7+1). Since nums[2]=5<8, we can first try to use 5. Now the maximum number we can get is 7+5=12. Since 12>8, we successfully get 8.\\n\\n    number used [1 2 5], number added [4]\\n    can achieve 1~12\\n\\nThen we need to get 13 (12+1), Since nums[3]=6<13, we can first try to use 6. Now the maximum number we can get is 12+6=18. Since 18>13, we successfully get 13.\\n\\n    number used [1 2 5 6], number added [4]\\n    can achieve 1~18\\n\\nThen we need to get 19 (18+1), Since nums[4]=20>19, we need to add a new number to get 19. The optimal solution is to add 19 directly. In this case, we could achieve maximumly 37.\\n\\n    number used [1 2 5 6], number added [4 19]\\n    can achieve 1~37\\n\\nThen we need to get 38(37+1), Since nums[4]=20<38, we can first try to use 20. Now the maximum number we can get is 37+20=57. Since 57>38, we successfully get 38.\\n\\n    number used [1 2 5 6 20], number added [4 19]\\n    can achieve 1~57\\n\\nSince 57>n=50, we can all number no greater than 50. \\n\\nThe extra number we added are 4 and 19,  so we return 2.\\n\\n\\nThe code is given as follows\\n\\n    class Solution {\\n    public:\\n    int minPatches(vector<int>& nums, int n) {\\n        int cnt=0,i=0;\\n        long long maxNum=0;\\n        while (maxNum<n){\\n           if (i<nums.size() && nums[i]<=maxNum+1)\\n                maxNum+=nums[i++];\\n           else{\\n                maxNum+=maxNum+1;cnt++;\\n           }\\n       }\\n       return cnt;\\n    }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n    int minPatches(vector<int>& nums, int n) {\\n        int cnt=0,i=0;\\n        long long maxNum=0;\\n        while (maxNum<n){\\n           if (i<nums.size() && nums[i]<=maxNum+1)\\n                maxNum+=nums[i++];\\n           else{\\n                maxNum+=maxNum+1;cnt++;\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1432422,
                "title": "python-2-solutions-merge-intervals-greedy-explained",
                "content": "#### Solution 1\\nLet as keep all possible numbers we can get as list of intervals, for example `0, 1, 2, 4, 5, 12` is `[[0, 2], [4, 5], [12, 12]]`. Then  when we add new number we can merge our intervals, using idea of Problem **0056**. What numbers we need to add next? We need to add number `3` in our example, the smallest possible number, which are not in our array. \\n\\n#### Complexity\\nComplexity is `O(m * log n)`, where `m <= 10000` is the biggest value of `num`. The idea is that in the beginning we can have not more than `m//2` intervals and then on each iteration number of intervals can not increase or increase not too fast (I do not have strict proof at the moment). Also number of iterations can not too big, because it is enough `log n` patches always.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def merge(self, intervals):\\n        intervals.sort(key=lambda x: x[0])\\n        merged = []\\n        \\n        for interval in intervals:\\n            if not merged or merged[-1][1] < interval[0] - 1:\\n                merged.append(interval)\\n            else:\\n                merged[-1][1] = max(merged[-1][1], interval[1])\\n\\n        return merged\\n\\n\\n    def minPatches(self, nums, n):\\n        ints, patches = [[0,0]], 0\\n        for num in nums:\\n            ints = self.merge(ints + [[i+num, j+num] for i,j in ints])\\n\\n        while ints[0][1] < n:\\n            ints = self.merge(ints + [[i+ints[0][1]+1, j+ints[0][1]+1] for i,j in ints])\\n            patches += 1\\n\\n        return patches\\n```\\n\\n#### Solution 2\\nWe can improve this solution, if we upgrade the idea of smallest number which we do not have yet. \\n\\n**Example**: `nums = [1, 2, 4, 13, 43]`. We go form the smallest number add them one by one and always keep the possible range of numbers we can get in the form `[0, k]`, that is, it is not union of intervals, but only one interval. Let us go through this example. \\n\\n1. We did not choose any numbers yet, so we have interval `[0, 0]`.\\n2. Are we missing something if we take next number `1`? No, let us take it, now we have interval `[0, 1]`.\\n3. Are we missing something if we take next number `2`? No, let us take it, now we have interval `[0, 3]`.\\n4. Are we missing something if we take next number `4`? No, let us take it, now we have interval `[0, 7]`.\\n5. Are we missing something if we take next number `13`? Yes, we missing! What we need to take next patch equal to `8`. So now, our interval is `[0, 15]`.\\n6. Our next missing number `16` is more, than next number in array: `13`. So if fact, we can create `[0, 28]`.\\n7. Our next missing number is `29`, it is less than `43`, so we add `29` as patch. and we have interval `[0, 57]`.\\n\\n#### Complexity\\n\\nComplexity of this solution is `O(n)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def minPatches(self, nums, n):\\n        reach, ans, idx = 0, 0, 0\\n        \\n        while reach < n:\\n            if idx < len(nums) and nums[idx] <= reach + 1:\\n                reach += nums[idx]\\n                idx += 1\\n            else:\\n                ans += 1\\n                reach = 2*reach + 1       \\n                \\n        return ans\\n```\\n\\nIf you have any questions, feel free to ask. If you like solution and explanations, please **Upvote!**",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```python\\nclass Solution:\\n    def merge(self, intervals):\\n        intervals.sort(key=lambda x: x[0])\\n        merged = []\\n        \\n        for interval in intervals:\\n            if not merged or merged[-1][1] < interval[0] - 1:\\n                merged.append(interval)\\n            else:\\n                merged[-1][1] = max(merged[-1][1], interval[1])\\n\\n        return merged\\n\\n\\n    def minPatches(self, nums, n):\\n        ints, patches = [[0,0]], 0\\n        for num in nums:\\n            ints = self.merge(ints + [[i+num, j+num] for i,j in ints])\\n\\n        while ints[0][1] < n:\\n            ints = self.merge(ints + [[i+ints[0][1]+1, j+ints[0][1]+1] for i,j in ints])\\n            patches += 1\\n\\n        return patches\\n```\n```python\\nclass Solution:\\n    def minPatches(self, nums, n):\\n        reach, ans, idx = 0, 0, 0\\n        \\n        while reach < n:\\n            if idx < len(nums) and nums[idx] <= reach + 1:\\n                reach += nums[idx]\\n                idx += 1\\n            else:\\n                ans += 1\\n                reach = 2*reach + 1       \\n                \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 338621,
                "title": "python-o-n-with-detailed-explanation",
                "content": "Initialize an empty list, keep adding new numbers from provided nums into this list, keep updating the coverage range and ensure a continus coverage range. If you do so, you only need to care about whether the newly added number will break the coverage range or not.\\n\\nSuppose 1~10 is already covered during this process, (by whatever combinations in the above list, doesn\\'t matter), then for the next number added\\n1. If the next number is \"11\", you will have these new sums: \\n      11, 11+1, 11+2, ..., 11+10, so your total coverage becomes 1~21, which is \"2 x coverage + 1\"\\n2. If the next numberis smaller than \"11\", for example \"3\", then the new coverage becomes: 10+3, 9+3, 8+3-> 1~13, which is \"num + coverage\"\\n3. If the next number is bigger than \"11\", for example \"12\", then number \"11\" is missing forever. There is no way to sum 11 by existing combinations. You have to manually patch \"11\" before being able to process the next number. Note that Patching number \"1~10\" can also cover the missing \"11\", but patching \"11\" is optimal because it maximizes the total coverage.\\n\\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        covered=0\\n        res=0\\n        for num in nums:\\n            while num>covered+1:\\n                res+=1\\n                covered=covered*2+1\\n                if covered>=n:\\n                    return res\\n            covered+=num\\n            if covered>=n:\\n                return res\\n        while covered<n:\\n            res+=1\\n            covered=covered*2+1            \\n        return res\\n```\\n\\nShorter version with same logic:\\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        covered,res,i=0,0,0\\n        while covered<n:\\n            num=nums[i] if i<len(nums) else math.inf\\n            if num>covered+1:\\n                covered=covered*2+1\\n                res+=1\\n            else:\\n                covered+=num\\n                i+=1       \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        covered=0\\n        res=0\\n        for num in nums:\\n            while num>covered+1:\\n                res+=1\\n                covered=covered*2+1\\n                if covered>=n:\\n                    return res\\n            covered+=num\\n            if covered>=n:\\n                return res\\n        while covered<n:\\n            res+=1\\n            covered=covered*2+1            \\n        return res\\n```\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        covered,res,i=0,0,0\\n        while covered<n:\\n            num=nums[i] if i<len(nums) else math.inf\\n            if num>covered+1:\\n                covered=covered*2+1\\n                res+=1\\n            else:\\n                covered+=num\\n                i+=1       \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 280183,
                "title": "detailed-explanation-with-example",
                "content": "**\\u4F8B\\u5B50\\uFF08Example\\uFF09**\\n\\n[1,2,3,5,10,50,70], n=100\\n1. Seeing 1, we know [1,1] can be covered\\n2. Seeing 2, we know [1,3] can be covered\\n3. Similarly for 3, [1,6] can be covered\\n4. for 5, [1,11] can be covered\\n5. for 10, [1, 21] can be covered\\n6. for 50, however, we have to add a patch, if the patch is 1, the range can be extended to [1, 22], if the patch is 2, the range can be extended to [1, 23]...From the observation we know in order to extend the range as longer as possible, we need to add 22, so that we get [1,43]. Why not add 23? Because [1,2,3,5,10,23] can NOT cover 22!\\n6. [1,43] does not cover 50 yet. Following a similar way of thinking, we know this time we need to add 44, extending the range to [1, 87]\\n7. for 70, it\\'s already in [1,87], add 70 would extend the range to [1,157]\\n8. 157 > 100, done\\n\\nIn conclusion, we need 2 patches, i.e., 22 and 44.\\nSo the key point is if the current range is [1,m], and the current number > m, we need to add m+1 as a patch, to extend the range to [1, 2m+1].\\n\\n--------\\n\\n[1,2,3,5,10,50,70], n=100\\n1. \\u770B\\u5230\\u7B2C\\u4E00\\u4E2A\\u65701\\uFF0C\\u6211\\u4EEC\\u77E5\\u9053[1,1]\\u53EF\\u4EE5\\u88AB\\u8986\\u76D6\\n2. \\u770B\\u5230\\u7B2C\\u4E8C\\u4E2A\\u65702\\uFF0C\\u6211\\u4EEC\\u77E5\\u9053[1,3]\\u53EF\\u4EE5\\u88AB\\u8986\\u76D6\\n3. 3\\u540C\\u7406\\uFF0C[1,6]\\u53EF\\u4EE5\\u88AB\\u8986\\u76D6\\n4. 5\\u540C\\u7406\\uFF0C[1,11]\\u53EF\\u4EE5\\u88AB\\u8986\\u76D6\\n5. 10\\u540C\\u7406\\uFF0C[1,21]\\u53EF\\u4EE5\\u88AB\\u8986\\u76D6\\n6. \\u73B0\\u5728\\u523050\\uFF0C\\u53D1\\u73B0\\u4E0D\\u5F97\\u4E0D\\u6253\\u8865\\u4E01\\u4E86\\uFF0C\\u5982\\u679C\\u6253\\u8865\\u4E011\\uFF0C\\u53EF\\u4EE5\\u6269\\u5C55\\u4E3A[1,22]\\uFF0C\\u5982\\u679C\\u6253\\u8865\\u4E012\\uFF0C\\u53EF\\u4EE5\\u6269\\u5C55\\u4E3A[1,23]...\\u53EF\\u89C1\\uFF0C\\u8981\\u5F97\\u5230\\u6700\\u5927\\u7684\\u8303\\u56F4\\uFF0C\\u5E94\\u8BE5\\u6253\\u7684\\u8865\\u4E01\\u662F22\\uFF0C\\u8FD9\\u6837\\u80FD\\u5F97\\u5230[1,43]\\uFF0C\\u4E3A\\u4EC0\\u4E48\\u4E0D\\u80FD\\u6253\\u8865\\u4E0123\\u5462\\uFF1F\\u56E0\\u4E3A[1,2,3,5,10,23]\\u5F97\\u4E0D\\u523022\\uFF01 \\n7. [1,43]\\u8FD8\\u662F\\u6CA1\\u6709\\u8986\\u76D650\\uFF0C\\u6309\\u7167\\u7C7B\\u4F3C\\u7684\\u903B\\u8F91\\uFF0C\\u8FD9\\u6B21\\u5E94\\u8BE5\\u6253\\u7684\\u8865\\u4E01\\u662F44\\uFF0C\\u5C06\\u8303\\u56F4\\u6269\\u5145\\u5230[1,87]\\n8. \\u6700\\u540E\\u523070\\uFF0C\\u5728[1,87]\\u5185\\uFF0C\\u8303\\u56F4\\u88AB\\u6269\\u5145\\u5230[1,157]\\n9. 157 > 100\\uFF0C\\u7ED3\\u675F\\n\\n\\u7EFC\\u4E0A\\uFF0C\\u4E00\\u5171\\u89812\\u4E2A\\u8865\\u4E01\\uFF0C\\u537322\\u548C44\\n\\u6240\\u4EE5\\uFF0C\\u9898\\u76EE\\u7684\\u8981\\u70B9\\u5728\\u4E8E\\uFF0C\\u5982\\u679C\\u5F53\\u524D\\u7684\\u8303\\u56F4\\u662F[1,m]\\uFF0C\\u4E14\\u5F53\\u524D\\u7684\\u6570\\u5B57num > m\\uFF0C\\u6211\\u4EEC\\u5E94\\u8BE5\\u6253\\u8865\\u4E01m+1\\uFF0C\\u4F7F\\u5F97\\u8303\\u56F4\\u6269\\u5145\\u5230[1\\uFF0C2m+1]\\u3002\\n\\n\\n**\\u4EE3\\u7801\\uFF08Code\\uFF09**\\n```\\ndef minPatches(self, nums: List[int], n: int) -> int:\\n\\tcnt = 0\\n\\tpatch = 0\\n\\ttot = len(nums)\\n\\ti = 0\\n\\twhile patch < n:\\n\\t\\tif i < tot and patch + 1 >= nums[i]:\\n\\t\\t\\tpatch += nums[i]\\n\\t\\t\\ti += 1\\n\\t\\telse:\\n\\t\\t\\tcnt += 1\\n\\t\\t\\t#print(patch+1)\\n\\t\\t\\tpatch += patch + 1  # patch + 1 is the new patch to be added\\n\\treturn cnt\\n```",
                "solutionTags": [],
                "code": "```\\ndef minPatches(self, nums: List[int], n: int) -> int:\\n\\tcnt = 0\\n\\tpatch = 0\\n\\ttot = len(nums)\\n\\ti = 0\\n\\twhile patch < n:\\n\\t\\tif i < tot and patch + 1 >= nums[i]:\\n\\t\\t\\tpatch += nums[i]\\n\\t\\t\\ti += 1\\n\\t\\telse:\\n\\t\\t\\tcnt += 1\\n\\t\\t\\t#print(patch+1)\\n\\t\\t\\tpatch += patch + 1  # patch + 1 is the new patch to be added\\n\\treturn cnt\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1432828,
                "title": "c-simple-and-easy-explained-solution-7-short-lines",
                "content": "**Idea:**\\nEvery time `count` reaches a number that the next element in `nums` is greater than it, we need a patch.\\nIf we add the number itself, `count` can be doubled because we can add the new number to any of the previous numbers.\\nSo if `count` = 7, and the next number in `nums` is 10, if we add 7 to `nums` now we have all numbers until 14.\\n```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long patches = 0, count = 1, i = 0, sz = nums.size();\\n        while (count <= n) {\\n            \\n            if (i < sz && nums[i] <= count) count += nums[i++];\\n            \\n            else {\\n                count *= 2;\\n                patches++;\\n            }\\n        }\\n        \\n        return patches;\\n    }\\n};\\n```\\n**Like it? please upvote!**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long patches = 0, count = 1, i = 0, sz = nums.size();\\n        while (count <= n) {\\n            \\n            if (i < sz && nums[i] <= count) count += nums[i++];\\n            \\n            else {\\n                count *= 2;\\n                patches++;\\n            }\\n        }\\n        \\n        return patches;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78490,
                "title": "share-my-greedy-solution-by-java-with-simple-explanation-time-1-ms",
                "content": "    public static int minPatches(int[] nums, int n) {\\n\\t\\tlong max = 0;\\n\\t\\tint cnt = 0;\\n\\t\\tfor (int i = 0; max < n;) {\\n\\t\\t\\tif (i >= nums.length || max < nums[i] - 1) {\\n\\t\\t\\t\\tmax += max + 1;\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmax += nums[i];\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cnt;\\n\\t}\\n\\nThe variable `max` records the maximal value that can be formed by the elements in `nums` and patched numbers. If `max` is less than `nums[i] - 1` which means we need to patch a new number, we then patch `max + 1`.",
                "solutionTags": [],
                "code": "    public static int minPatches(int[] nums, int n) {\\n\\t\\tlong max = 0;\\n\\t\\tint cnt = 0;\\n\\t\\tfor (int i = 0; max < n;) {\\n\\t\\t\\tif (i >= nums.length || max < nums[i] - 1) {\\n\\t\\t\\t\\tmax += max + 1;\\n\\t\\t\\t\\tcnt++;\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tmax += nums[i];\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn cnt;\\n\\t}\\n\\nThe variable `max` records the maximal value that can be formed by the elements in `nums` and patched numbers. If `max` is less than `nums[i] - 1` which means we need to patch a new number, we then patch `max + 1`.",
                "codeTag": "Unknown"
            },
            {
                "id": 1432323,
                "title": "patching-array-simple-solution-with-explanation",
                "content": "```\\nint minPatches(vector<int>& nums, int n) {\\n    long miss = 1, added = 0, i = 0;\\n    while (miss <= n) {\\n        if (i < nums.size() && nums[i] <= miss) {\\n            miss += nums[i++];\\n        } else {\\n            miss += miss;\\n            added++;\\n        }\\n    }\\n    return added;\\n}\\n```\\n\\nLet **miss** be the smallest sum in **[0,n]** that we might be missing. Meaning we already know we can build all sums in **[0,miss)**. Then if we have a number **num <= miss** in the given array, we can add it to those smaller sums to build all sums in **[0,miss+num)**. If we don\\'t, then we must add such a number to the array, and it\\'s best to add miss itself, to maximize the reach\\n\\n",
                "solutionTags": [],
                "code": "```\\nint minPatches(vector<int>& nums, int n) {\\n    long miss = 1, added = 0, i = 0;\\n    while (miss <= n) {\\n        if (i < nums.size() && nums[i] <= miss) {\\n            miss += nums[i++];\\n        } else {\\n            miss += miss;\\n            added++;\\n        }\\n    }\\n    return added;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 683493,
                "title": "a-concrete-example-to-work-down-the-algorithm",
                "content": "\\nThink it reversely: the maximum value we can form based on a given set of numsers?\\nif for a give set [1, ..., k], and anything less or equal to k is already covered. then anything [k+1 .... k + k) must also be covered! In another word, if we have k and all value before k is covered, then the later part [k, 2*k) is also covered.\\n**This is the most important observation.** coverage is just symmetric around the largest item in the array! \\nthe reason why 2k is not covered is because each element can only be pick only one time.\\n\\ne.g. [1, 2, 4] , since all value between [1, 4] is covered, this array will also cover [5, 8), the whole coverage is [1, 8).\\ntherefore, for this array, if we ask for a target value that is between [8, 16) to be covered, we just need to add 8 to the array.\\n\\nNow,  we want a coverage to N, how should we approach to it?\\nwe just need to scan the array and keep increasing our coverage until it >= N.\\n\\nexample:\\n`[1, 2, 4, 13, 43], n = 100`\\nprobable missing starts at 1, we encounter first item nums[0] = 1, it can cover `[1, 2)`\\nincrease probable missing to nums[0] + missing = 2; next iteration, we encounter second item nums[1] = 2, it can cover `[1, 2 * nums[1])`\\nincrease probable missing to nums[1] + missing = 4; next iteration, encounter `nums[2]  = 4`, covered, it can cover `[1, 4*nums[2])` = `[1, 8)`\\nincrease probable missing to nums[2] + missing = 8, next iteration, encounter `nums[3] = 13`, 13 is not covered!, so we must add 8 to the array!\\n    when we add 8 to the array, the coverage will become `2*8 = 16` (right open range), and since we have 13, we can extend the coverage to `16 + 13 = 29`. literally, `[1, 29)`\\nso the next probable missing number should be 29; next searching iteration, encounter 43, not covered! so we add 29.\\nand the coverage is extended to` [1, 43 + 29*2)` =  `[1, 101)`, we are done!\\n\\n\\n```cpp\\nint minPatches(vector<int>& nums, int n) {\\n    int missing = 1, patches = 0, int i = 0;\\n    while (missing <= n) {\\n        if (i < nums.size() && nums[i] <= missing) {\\n            missing += nums[i++];\\n        } else {\\n            missing += missing;\\n            patches++;\\n        }\\n    }\\n    return pathces;\\n}\\n```\\n\\n",
                "solutionTags": [],
                "code": "```cpp\\nint minPatches(vector<int>& nums, int n) {\\n    int missing = 1, patches = 0, int i = 0;\\n    while (missing <= n) {\\n        if (i < nums.size() && nums[i] <= missing) {\\n            missing += nums[i++];\\n        } else {\\n            missing += missing;\\n            patches++;\\n        }\\n    }\\n    return pathces;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 78515,
                "title": "my-simple-accepted-c-solution",
                "content": "Idea: 1. Check the content if the current one is within sum +1, which is the total sum of all previous existing numbers. If yes, we proceed and update sum. If not, we patch one number that is within sum + 1. \\n2. Keep updating the sum until it reaches n.\\n   \\n\\n\\n\\n\\n\\n     int minPatches(vector<int>& nums, int n) {\\n        \\n        int len = nums.size();\\n        int sum = 0;\\n        int patch = 0;\\n        int count = 0;\\n\\n        while (sum < n) {\\n            if (count != len && nums[count] <= sum + 1) {\\n                sum += nums[count];\\n                count ++;\\n            }\\n            else {\\n                patch ++;\\n                if (sum > (INT_MAX - 1) / 2) {\\n                    sum = INT_MAX;\\n                }\\n                else {\\n                    sum = sum * 2 + 1;\\n                }\\n            }\\n        }\\n        \\n        return patch;\\n    }",
                "solutionTags": [
                    "C++"
                ],
                "code": "Idea: 1. Check the content if the current one is within sum +1, which is the total sum of all previous existing numbers. If yes, we proceed and update sum. If not, we patch one number that is within sum + 1. \\n2. Keep updating the sum until it reaches n.\\n   \\n\\n\\n\\n\\n\\n     int minPatches(vector<int>& nums, int n) {\\n        \\n        int len = nums.size();\\n        int sum = 0;\\n        int patch = 0;\\n        int count = 0;\\n\\n        while (sum < n) {\\n            if (count != len && nums[count] <= sum + 1) {\\n                sum += nums[count];\\n                count ++;\\n            }\\n            else {\\n                patch ++;\\n                if (sum > (INT_MAX - 1) / 2) {\\n                    sum = INT_MAX;\\n                }\\n                else {\\n                    sum = sum * 2 + 1;\\n                }\\n            }\\n        }\\n        \\n        return patch;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 78512,
                "title": "simple-intuitive-and-well-explained-solution-accepted-as-best-in-c",
                "content": "Before we hack this, we should be generous and think nothing about performance and try to come up with a sub-problem of it and then boot it from the beginning point.\\n\\nSo before we truly get started, let's suppose we are in a state where we can reach <font color=\"#ff0000\">**top**</font> by its sub-array nums[0...i] then what should we consider for the next element nums[i+1]? \\n\\n - now we need to check if `nums[i+1]<=top+1` then update <font color=\"#ff0000\">**top**</font> to **top+nums[i+1]** and move to the next element;\\n\\n - but if nums[i+1] is greater than top+1, then there is a gap (how many? God knows) between top and nums[i+1]; in this case we need to patch a number to the array, then what number it should be? As we have discussed, it should top+1 which will be the largest we can achieve now  **by patching** and then the top will be updated to **2*top+1**, right? Good, let's move on...\\n - the generalised case have been discussed, then so what's the start? As we can easily get that the start value should be 1 then the top should be initialized to 0 and then everything just moves around! \\n\\n> End of the story!\\n\\nAs for the time cost, the nums array is limited and n is then determined by the **top = 2*top+1** equation, so O(logn) should be better to describe its time cost.\\n\\n - Space cost O(1)\\n - Time cost O(logn)\\n\\n----------\\n\\n    int minPatches(int* nums, int size, int n)\\n    {\\n        int count=0, index=0;\\n        long long top = 0;\\n        while(top < n)\\n        {\\n            if(index<size && nums[index]<=(top+1))\\n                top += nums[index++];\\n            else\\n            {\\n                count++;\\n                top = 2*top+1;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Iterator"
                ],
                "code": "Before we hack this, we should be generous and think nothing about performance and try to come up with a sub-problem of it and then boot it from the beginning point.\\n\\nSo before we truly get started, let's suppose we are in a state where we can reach <font color=\"#ff0000\">**top**</font> by its sub-array nums[0...i] then what should we consider for the next element nums[i+1]? \\n\\n - now we need to check if `nums[i+1]<=top+1` then update <font color=\"#ff0000\">**top**</font> to **top+nums[i+1]** and move to the next element;\\n\\n - but if nums[i+1] is greater than top+1, then there is a gap (how many? God knows) between top and nums[i+1]; in this case we need to patch a number to the array, then what number it should be? As we have discussed, it should top+1 which will be the largest we can achieve now  **by patching** and then the top will be updated to **2*top+1**, right? Good, let's move on...\\n - the generalised case have been discussed, then so what's the start? As we can easily get that the start value should be 1 then the top should be initialized to 0 and then everything just moves around! \\n\\n> End of the story!\\n\\nAs for the time cost, the nums array is limited and n is then determined by the **top = 2*top+1** equation, so O(logn) should be better to describe its time cost.\\n\\n - Space cost O(1)\\n - Time cost O(logn)\\n\\n----------\\n\\n    int minPatches(int* nums, int size, int n)\\n    {\\n        int count=0, index=0;\\n        long long top = 0;\\n        while(top < n)\\n        {\\n            if(index<size && nums[index]<=(top+1))\\n                top += nums[index++];\\n            else\\n            {\\n                count++;\\n                top = 2*top+1;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 78498,
                "title": "simple-9-line-python-solution",
                "content": "    class Solution(object):\\n        def minPatches(self, nums, n):\\n            \"\"\"\\n            :type nums: List[int]\\n            :type n: int\\n            :rtype: int\\n            \"\"\"\\n            miss, i, added = 1, 0, 0\\n            while miss <= n:\\n                if i < len(nums) and nums[i] <= miss:\\n                    miss += nums[i]\\n                    i += 1\\n                else:\\n                    miss += miss\\n                    added += 1\\n            return added",
                "solutionTags": [
                    "Python"
                ],
                "code": "    class Solution(object):\\n        def minPatches(self, nums, n):\\n            \"\"\"\\n            :type nums: List[int]\\n            :type n: int\\n            :rtype: int\\n            \"\"\"\\n            miss, i, added = 1, 0, 0\\n            while miss <= n:\\n                if i < len(nums) and nums[i] <= miss:\\n                    miss += nums[i]\\n                    i += 1\\n                else:\\n                    miss += miss\\n                    added += 1\\n            return added",
                "codeTag": "Java"
            },
            {
                "id": 78507,
                "title": "1ms-java-solution-with-explain",
                "content": "    public int minPatches(int[] nums, int n) {\\n        int index = 0;\\n        int addedCount = 0;\\n        long canReachTo = 0;\\n        while( canReachTo < n){\\n            if( nums.length > index){\\n                int nextExisting = nums[index];\\n                if(nextExisting == canReachTo + 1){\\n                    canReachTo = (canReachTo << 1) + 1;\\n                    index++;\\n                } else if(nextExisting > canReachTo + 1){\\n                    addedCount++;\\n                    canReachTo = (canReachTo << 1) + 1;\\n                } else {\\n                    canReachTo = nextExisting + canReachTo;\\n                    index++;\\n                }\\n            } else {\\n                addedCount++;\\n                canReachTo = (canReachTo << 1) + 1;\\n            }\\n        }\\n        return addedCount;\\n    }\\n\\nThis solution is based on greedy method. \\nFor example, if you have 1, 2, it can reach 2+(2-1) = 3. So when we want to add up to 4, we have to add 4 into the list. And 1,2,4 can reach to 4+(4-1). \\nSimilarly, for any added number n, they can add up to n+(n-1) without missing one number. \\nIf there is one number x which satisfies n < x < n+(n-1), then we don't have to worry about the numbers until x + n + n - 1. Repeatedly evaluate the next number that the list of numbers can reach to, and add into the list next one when missing.\\nSo basically this method is <log(n) time complexity and O(1) space complexity.",
                "solutionTags": [],
                "code": "    public int minPatches(int[] nums, int n) {\\n        int index = 0;\\n        int addedCount = 0;\\n        long canReachTo = 0;\\n        while( canReachTo < n){\\n            if( nums.length > index){\\n                int nextExisting = nums[index];\\n                if(nextExisting == canReachTo + 1){\\n                    canReachTo = (canReachTo << 1) + 1;\\n                    index++;\\n                } else if(nextExisting > canReachTo + 1){\\n                    addedCount++;\\n                    canReachTo = (canReachTo << 1) + 1;\\n                } else {\\n                    canReachTo = nextExisting + canReachTo;\\n                    index++;\\n                }\\n            } else {\\n                addedCount++;\\n                canReachTo = (canReachTo << 1) + 1;\\n            }\\n        }\\n        return addedCount;\\n    }\\n\\nThis solution is based on greedy method. \\nFor example, if you have 1, 2, it can reach 2+(2-1) = 3. So when we want to add up to 4, we have to add 4 into the list. And 1,2,4 can reach to 4+(4-1). \\nSimilarly, for any added number n, they can add up to n+(n-1) without missing one number. \\nIf there is one number x which satisfies n < x < n+(n-1), then we don't have to worry about the numbers until x + n + n - 1. Repeatedly evaluate the next number that the list of numbers can reach to, and add into the list next one when missing.\\nSo basically this method is <log(n) time complexity and O(1) space complexity.",
                "codeTag": "Unknown"
            },
            {
                "id": 1219891,
                "title": "python-solution-faster-than-97-with-explanation",
                "content": "\\n* you just need to figure out one thing:\\n* if you can sum up from 1 to 10, what happen if you have another number\\n* suppose this number is 2, then you can sum up from 1 to 12\\n* suppose this number is 11, then you can sum up from 1 to 21 \\n* suppose this number is 12, then you can\\'t get 11 and the consecutive sum is broken at 11\\n* suppose this number is 100, then you can\\'t get the sum from 11 to 99\\n* so we know if you can sum up from 1 to k, the next largest number you can have is k+1, otherwise the consecutive sum will be invalid\\n* traverse from left, if the current number x is lower than or equal to k+1, let k = k+x, otherwise let k = k+1(k+1 is the largest we can have to keep the sum valid)\\n\\nclass Solution:\\n\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        ans = cum = index = 0 \\n        while(cum<n):\\n            if index<len(nums):\\n                if cum+1<nums[index]:\\n                    cum+=cum+1\\n                    ans+=1\\n                else:\\n                    cum+=nums[index]\\n                    index+=1     \\n            else:\\n                cum += cum+1\\n                ans+=1\\n\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n* you just need to figure out one thing:\\n* if you can sum up from 1 to 10, what happen if you have another number\\n* suppose this number is 2, then you can sum up from 1 to 12\\n* suppose this number is 11, then you can sum up from 1 to 21 \\n* suppose this number is 12, then you can\\'t get 11 and the consecutive sum is broken at 11\\n* suppose this number is 100, then you can\\'t get the sum from 11 to 99\\n* so we know if you can sum up from 1 to k, the next largest number you can have is k+1, otherwise the consecutive sum will be invalid\\n* traverse from left, if the current number x is lower than or equal to k+1, let k = k+x, otherwise let k = k+1(k+1 is the largest we can have to keep the sum valid)\\n\\nclass Solution:\\n\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        ans = cum = index = 0 \\n        while(cum<n):\\n            if index<len(nums):\\n                if cum+1<nums[index]:\\n                    cum+=cum+1\\n                    ans+=1\\n                else:\\n                    cum+=nums[index]\\n                    index+=1     \\n            else:\\n                cum += cum+1\\n                ans+=1\\n\\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 78544,
                "title": "simple-c-12ms-easy-understanding-o-n",
                "content": "    class Solution {\\n    public:\\n        int minPatches(vector<int>& nums, int n) {\\n            if (n == 0) return 0;\\n            int num = nums.size();\\n            long reach = 0;\\n            int patch = 0;\\n            for (int i = 0; i < num; ){\\n                while (nums[i] > reach + 1){\\n                    reach += (reach + 1);\\n                    ++patch;\\n                    if (reach >= n) return patch;\\n                }\\n                reach += nums[i];\\n                if (reach >= n) return patch;\\n                ++i;\\n            }\\n            while (reach < n){\\n                reach += (reach + 1);\\n                ++patch;\\n            } \\n            return patch;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minPatches(vector<int>& nums, int n) {\\n            if (n == 0) return 0;\\n            int num = nums.size();\\n            long reach = 0;\\n            int patch = 0;\\n            for (int i = 0; i < num; ){\\n                while (nums[i] > reach + 1){\\n                    reach += (reach + 1);\\n                    ++patch;\\n                    if (reach >= n) return patch;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 78548,
                "title": "java-here-is-my-greedy-version-with-brief-explanations-1ms",
                "content": "Greedy idea: add the maximum possible element whenever there is a gap\\n\\n    public int minPatches(int[] nums, int n) {\\n        int count = 0;\\n        long priorSum = 0; // sum of elements prior to current index\\n        for(int i=0; i<nums.length; i++) {\\n        \\tif(priorSum>=n) return count; // done\\n        \\twhile(priorSum<n && nums[i]>priorSum+1) { // whenever there is a gap between priorSum and current value, add elements in a greedy manner\\n        \\t\\t++count;\\n        \\t\\tpriorSum = (priorSum<<1) + 1;\\n        \\t}\\n        \\tpriorSum += nums[i];\\n        }\\n        while(priorSum<n) {\\n        \\t++count;\\n        \\tpriorSum = (priorSum<<1) + 1;\\n        }\\n        return count;\\n    }\\n\\nThe above one can be further simplified to one-pass as follows:\\n\\n    public int minPatches(int[] nums, int n) {\\n        int count = 0, i = 0;\\n        long priorSum = 0;\\n        while(priorSum<n) {\\n            if(i>=nums.length || nums[i]>priorSum+1) {\\n                ++count;\\n                priorSum = (priorSum<<1) + 1;\\n            }\\n            else priorSum += nums[i++];\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "Greedy idea: add the maximum possible element whenever there is a gap\\n\\n    public int minPatches(int[] nums, int n) {\\n        int count = 0;\\n        long priorSum = 0; // sum of elements prior to current index\\n        for(int i=0; i<nums.length; i++) {\\n        \\tif(priorSum>=n) return count; // done\\n        \\twhile(priorSum<n && nums[i]>priorSum+1) { // whenever there is a gap between priorSum and current value, add elements in a greedy manner\\n        \\t\\t++count;\\n        \\t\\tpriorSum = (priorSum<<1) + 1;\\n        \\t}\\n        \\tpriorSum += nums[i];\\n        }\\n        while(priorSum<n) {\\n        \\t++count;\\n        \\tpriorSum = (priorSum<<1) + 1;\\n        }\\n        return count;\\n    }\\n\\nThe above one can be further simplified to one-pass as follows:\\n\\n    public int minPatches(int[] nums, int n) {\\n        int count = 0, i = 0;\\n        long priorSum = 0;\\n        while(priorSum<n) {\\n            if(i>=nums.length || nums[i]>priorSum+1) {\\n                ++count;\\n                priorSum = (priorSum<<1) + 1;\\n            }\\n            else priorSum += nums[i++];\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1433222,
                "title": "simple-easy-to-understand-java-solution-faster-than-100",
                "content": "**Logic**\\n```\\nIterating the nums[], and keeps adding them up, and we are getting a running sum. At any position, if nums[i] > sum+1, them we are sure we have to patch \\na sum+1 because all nums before index i can\\'t make sum+1 even add all of them up, and all nums after index i are all simply too large.\\n```\\n\\n**Solution**\\n```\\nclass Solution {\\n     public int minPatches(int[] nums, int n) {\\n        long sum = 0;\\n        int count = 0;\\n        for (int x : nums) {\\n            if (sum >= n) break;\\n            while (sum+1 < x && sum < n) { \\n                ++count;\\n                sum += sum+1;\\n            }\\n            sum += x;\\n        }\\n        while (sum < n) {\\n            sum += sum+1;\\n            ++count;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nIterating the nums[], and keeps adding them up, and we are getting a running sum. At any position, if nums[i] > sum+1, them we are sure we have to patch \\na sum+1 because all nums before index i can\\'t make sum+1 even add all of them up, and all nums after index i are all simply too large.\\n```\n```\\nclass Solution {\\n     public int minPatches(int[] nums, int n) {\\n        long sum = 0;\\n        int count = 0;\\n        for (int x : nums) {\\n            if (sum >= n) break;\\n            while (sum+1 < x && sum < n) { \\n                ++count;\\n                sum += sum+1;\\n            }\\n            sum += x;\\n        }\\n        while (sum < n) {\\n            sum += sum+1;\\n            ++count;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 363319,
                "title": "c-4ms-98-greedy-solution-w-explanation",
                "content": "The idea is to greedily add the maximum missing number, and the numbers from ```nums``` once we can reach those numbers.\\n\\n**Why this works**\\n\\nAssume we have ```nums = [1, 5, 10]``` and we want all numbers to 20. To start thing off, we need to look for a 1. We have a 1 in the array, so are we good. Then we look for a 2. We do not have a 2 in the array, and the next element in the array is 5. This means **we must add a patch to get ```2```**. \\n\\nHow do we decide which patch to add? Well since we already have `1`, we can either add a `1`, or we can add a `2`. However, if we add a `2`, we will be able to make ```2``` _and_ ```3```, but if we add a ```1```, we will only be able to get ```2```. Since we want the minimum number of patches, we should aim to maximize the new numbers we can make from each patch. \\n\\nNow we can make ```[1, 4)```, and we are missing `4`, so by the previous logic we would add a `4` as the second patch, to get all numbers between ```0``` and ```7```. If we look at the next number in `nums`, we can see that it is a 5, so we have already covered it. But this is a \"free\" number. We can add it to any of our sums from ```0 ... 7``` and get a new number. The maximum number is now ```12```. This means we are able to increase the numbers we can reach _without having to add a patch_. Thus, we keep this up, and either add mandatory patches that maximizes the numbers we get, or add in free numbers from ```nums``` that extends our maximum range, until we reach the required range.\\n\\n```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        uint32_t m = 1, i = 0, p = 0, size = nums.size();\\n        while(m <= n) {\\n            if(i < size && nums[i] <= m) m += nums[i++];\\n            else {\\n                m += m;\\n                ++p;\\n            }\\n        }\\n        return p;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "solutionTags": [],
                "code": "```nums```\n```nums = [1, 5, 10]```\n```2```\n```2```\n```3```\n```1```\n```2```\n```[1, 4)```\n```0```\n```7```\n```0 ... 7```\n```12```\n```nums```\n```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        uint32_t m = 1, i = 0, p = 0, size = nums.size();\\n        while(m <= n) {\\n            if(i < size && nums[i] <= m) m += nums[i++];\\n            else {\\n                m += m;\\n                ++p;\\n            }\\n        }\\n        return p;\\n    }\\n};\\n\\nauto gucciGang = []() {std::ios::sync_with_stdio(false);cin.tie(nullptr);cout.tie(nullptr);return 0;}();\\n```",
                "codeTag": "C++"
            },
            {
                "id": 196326,
                "title": "4ms-c-greedy-solution-with-explanation",
                "content": "```\\n/*\\n\\u9996\\u5148\\u53EF\\u4EE5\\u786E\\u5B9A\\u7684\\u662F\\uFF0C\\nnums\\u4E2D\\u5FC5\\u7136\\u5305\\u542B1\\uFF0C\\u5982\\u679C\\u4E0D\\u5305\\u542B1\\uFF0C\\u90A3\\u4E48[1,n]\\u8FD9\\u4E2A\\u8303\\u56F4\\u4E2D\\u76841\\u5C31\\u6CA1\\u6CD5\\u5B9E\\u73B0\\n\\u5176\\u6B21\\u6570\\u7EC4\\u4E2D\\u7684\\u5143\\u7D20\\u4E0D\\u80FD\\u91CD\\u590D\\u4F7F\\u7528\\uFF0C\\u5982\\u679C\\u5141\\u8BB8\\u91CD\\u590D\\u4F7F\\u7528\\uFF0C\\u90A3\\u4E48\\u628A1\\u91CD\\u590D\\u591A\\u6B21\\uFF0C\\u5C31\\u53EF\\u4EE5\\u7EC4\\u6210\\u4EFB\\u610F\\u6574\\u6570\\u3002\\n\\u4EE4miss\\u4E3A[0,n]\\u4E2D\\u7F3A\\u5C11\\u7684\\u6700\\u5C0F\\u6574\\u6570\\uFF0C\\u610F\\u5473\\u7740\\u6211\\u4EEC\\u53EF\\u4EE5\\u5B9E\\u73B0[0,miss)\\u8303\\u56F4\\u5185\\u7684\\u4EFB\\u610F\\u6574\\u6570\\u3002\\n\\u5982\\u679C\\u6570\\u7EC4\\u4E2D\\u6709\\u67D0\\u4E2A\\u6574\\u6570x<=miss, \\u90A3\\u4E48\\u6211\\u4EEC\\u53EF\\u4EE5\\u628A[0,miss)\\u533A\\u95F4\\u7684\\u6240\\u6709\\u6574\\u6570\\u52A0\\u4E0Ax\\uFF0C\\u533A\\u95F4\\u53D8\\u6210\\u4E86[x, miss+x)\\uFF0C\\u7531\\u4E8E\\u533A\\u95F4[0,miss)\\u548C[x, miss+x)\\u91CD\\u53E0\\uFF0C\\u4E24\\u4E2A\\u533A\\u95F4\\u53EF\\u4EE5\\u65E0\\u7F1D\\u8FDE\\u63A5\\u8D77\\u6765\\uFF0C\\u610F\\u5473\\u7740\\u6211\\u4EEC\\u53EF\\u4EE5\\u628A\\u533A\\u95F4[0,miss)\\u6269\\u5C55\\u5230[0, miss+x)\\u3002\\n\\u5982\\u679C\\u6570\\u7EC4\\u4E2D\\u4E0D\\u5B58\\u5728\\u5C0F\\u4E8E\\u6216\\u7B49\\u4E8Emiss\\u7684\\u5143\\u7D20\\uFF0C\\u5219\\u533A\\u95F4[0,miss)\\u548C[x, miss+x) \\u8131\\u8282\\u4E86\\uFF0C\\u8FDE\\u4E0D\\u8D77\\u6765\\u3002\\u6B64\\u65F6\\u6211\\u4EEC\\u9700\\u8981\\u6DFB\\u52A0\\u4E00\\u4E2A\\u6570\\uFF0C\\u6700\\u5927\\u9650\\u5EA6\\u7684\\u6269\\u5C55\\u533A\\u95F4[0, miss)\\u3002\\u90A3\\u6DFB\\u52A0\\u54EA\\u4E2A\\u6570\\u5462\\uFF1F\\u5F53\\u7136\\u662F\\u6DFB\\u52A0miss\\u672C\\u8EAB\\uFF0C\\u8FD9\\u6837\\u533A\\u95F4[0,miss)\\u548C[miss, miss+miss)\\u6070\\u597D\\u53EF\\u4EE5\\u65E0\\u7F1D\\u62FC\\u63A5\\u3002\\n\\u4E3E\\u4E2A\\u4F8B\\u5B50\\uFF0C\\u4EE4nums=[1, 2, 4, 13, 43], n=100\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u8BA9[1,100]\\u5185\\u7684\\u6570\\u90FD\\u80FD\\u591F\\u7EC4\\u5408\\u51FA\\u6765\\u3002\\n\\u4F7F\\u7528\\u6570\\u5B571,2,4\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u7EC4\\u5408\\u51FA[0, 8)\\u5185\\u7684\\u6240\\u6709\\u6570\\uFF0C\\u4F46\\u65E0\\u6CD5\\u7EC4\\u5408\\u51FA8\\uFF0C\\u7531\\u4E8E\\u4E0B\\u4E00\\u4E2A\\u6570\\u662F13\\uFF0C\\u6BD48\\u5927\\uFF0C\\u6839\\u636E\\u89C4\\u52192\\uFF0C\\u6211\\u4EEC\\u6DFB\\u52A08\\uFF0C\\u628A\\u533A\\u95F4\\u4ECE[0,8)\\u6269\\u5C55\\u5230[0,16)\\u3002\\n\\u4E0B\\u4E00\\u4E2A\\u6570\\u662F13\\uFF0C\\u6BD416\\u5C0F\\uFF0C\\u6839\\u636E\\u89C4\\u52191\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u628A\\u533A\\u95F4\\u4ECE[0,16)\\u6269\\u5C55\\u5230[0,29)\\u3002\\n\\n\\u4E0B\\u4E00\\u4E2A\\u6570\\u662F43\\uFF0C\\u6BD429\\u5927\\uFF0C\\u6839\\u636E\\u89C4\\u52192\\uFF0C\\u6DFB\\u52A029\\uFF0C\\u628A\\u533A\\u95F4\\u4ECE[0,29)\\u6269\\u5927\\u5230[0,58)\\u3002\\n\\n\\u7531\\u4E8E43\\u6BD458\\u5C0F\\uFF0C\\u6839\\u636E\\u89C4\\u52191\\uFF0C\\u53EF\\u4EE5\\u628A\\u533A\\u95F4\\u4ECE[0,58)\\u6269\\u5C55\\u5230[0,101)\\uFF0C\\u521A\\u597D\\u8986\\u76D6\\u4E86[1,100]\\u5185\\u7684\\u6240\\u6709\\u6570\\u3002\\n\\n\\u6700\\u7EC8\\u7ED3\\u679C\\u662F\\u6DFB\\u52A02\\u4E2A\\u6570\\uFF0C8\\u548C29\\uFF0C\\u5C31\\u53EF\\u4EE5\\u7EC4\\u5408\\u51FA[1,100]\\u5185\\u7684\\u6240\\u6709\\u6574\\u6570\\u3002\\n*/\\n\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long r=0;\\n        int nextn=1;\\n        int index=0;\\n        int res=0;\\n        while(r<n){\\n            if(index<(int)nums.size()&&r>=(nums[index]-1)){\\n                r+=nums[index++];\\n            }else{\\n                res++;\\n                r+=(r+1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n/*\\n\\u9700\\u8981\\u6CE8\\u610F\\u7684\\u6D4B\\u8BD5\\u7528\\u4F8B\\uFF1A\\n[1,2,31,33]\\n2147483647\\n\\n[1000000]\\n1000\\n*/\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n\\u9996\\u5148\\u53EF\\u4EE5\\u786E\\u5B9A\\u7684\\u662F\\uFF0C\\nnums\\u4E2D\\u5FC5\\u7136\\u5305\\u542B1\\uFF0C\\u5982\\u679C\\u4E0D\\u5305\\u542B1\\uFF0C\\u90A3\\u4E48[1,n]\\u8FD9\\u4E2A\\u8303\\u56F4\\u4E2D\\u76841\\u5C31\\u6CA1\\u6CD5\\u5B9E\\u73B0\\n\\u5176\\u6B21\\u6570\\u7EC4\\u4E2D\\u7684\\u5143\\u7D20\\u4E0D\\u80FD\\u91CD\\u590D\\u4F7F\\u7528\\uFF0C\\u5982\\u679C\\u5141\\u8BB8\\u91CD\\u590D\\u4F7F\\u7528\\uFF0C\\u90A3\\u4E48\\u628A1\\u91CD\\u590D\\u591A\\u6B21\\uFF0C\\u5C31\\u53EF\\u4EE5\\u7EC4\\u6210\\u4EFB\\u610F\\u6574\\u6570\\u3002\\n\\u4EE4miss\\u4E3A[0,n]\\u4E2D\\u7F3A\\u5C11\\u7684\\u6700\\u5C0F\\u6574\\u6570\\uFF0C\\u610F\\u5473\\u7740\\u6211\\u4EEC\\u53EF\\u4EE5\\u5B9E\\u73B0[0,miss)\\u8303\\u56F4\\u5185\\u7684\\u4EFB\\u610F\\u6574\\u6570\\u3002\\n\\u5982\\u679C\\u6570\\u7EC4\\u4E2D\\u6709\\u67D0\\u4E2A\\u6574\\u6570x<=miss, \\u90A3\\u4E48\\u6211\\u4EEC\\u53EF\\u4EE5\\u628A[0,miss)\\u533A\\u95F4\\u7684\\u6240\\u6709\\u6574\\u6570\\u52A0\\u4E0Ax\\uFF0C\\u533A\\u95F4\\u53D8\\u6210\\u4E86[x, miss+x)\\uFF0C\\u7531\\u4E8E\\u533A\\u95F4[0,miss)\\u548C[x, miss+x)\\u91CD\\u53E0\\uFF0C\\u4E24\\u4E2A\\u533A\\u95F4\\u53EF\\u4EE5\\u65E0\\u7F1D\\u8FDE\\u63A5\\u8D77\\u6765\\uFF0C\\u610F\\u5473\\u7740\\u6211\\u4EEC\\u53EF\\u4EE5\\u628A\\u533A\\u95F4[0,miss)\\u6269\\u5C55\\u5230[0, miss+x)\\u3002\\n\\u5982\\u679C\\u6570\\u7EC4\\u4E2D\\u4E0D\\u5B58\\u5728\\u5C0F\\u4E8E\\u6216\\u7B49\\u4E8Emiss\\u7684\\u5143\\u7D20\\uFF0C\\u5219\\u533A\\u95F4[0,miss)\\u548C[x, miss+x) \\u8131\\u8282\\u4E86\\uFF0C\\u8FDE\\u4E0D\\u8D77\\u6765\\u3002\\u6B64\\u65F6\\u6211\\u4EEC\\u9700\\u8981\\u6DFB\\u52A0\\u4E00\\u4E2A\\u6570\\uFF0C\\u6700\\u5927\\u9650\\u5EA6\\u7684\\u6269\\u5C55\\u533A\\u95F4[0, miss)\\u3002\\u90A3\\u6DFB\\u52A0\\u54EA\\u4E2A\\u6570\\u5462\\uFF1F\\u5F53\\u7136\\u662F\\u6DFB\\u52A0miss\\u672C\\u8EAB\\uFF0C\\u8FD9\\u6837\\u533A\\u95F4[0,miss)\\u548C[miss, miss+miss)\\u6070\\u597D\\u53EF\\u4EE5\\u65E0\\u7F1D\\u62FC\\u63A5\\u3002\\n\\u4E3E\\u4E2A\\u4F8B\\u5B50\\uFF0C\\u4EE4nums=[1, 2, 4, 13, 43], n=100\\uFF0C\\u6211\\u4EEC\\u9700\\u8981\\u8BA9[1,100]\\u5185\\u7684\\u6570\\u90FD\\u80FD\\u591F\\u7EC4\\u5408\\u51FA\\u6765\\u3002\\n\\u4F7F\\u7528\\u6570\\u5B571,2,4\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u7EC4\\u5408\\u51FA[0, 8)\\u5185\\u7684\\u6240\\u6709\\u6570\\uFF0C\\u4F46\\u65E0\\u6CD5\\u7EC4\\u5408\\u51FA8\\uFF0C\\u7531\\u4E8E\\u4E0B\\u4E00\\u4E2A\\u6570\\u662F13\\uFF0C\\u6BD48\\u5927\\uFF0C\\u6839\\u636E\\u89C4\\u52192\\uFF0C\\u6211\\u4EEC\\u6DFB\\u52A08\\uFF0C\\u628A\\u533A\\u95F4\\u4ECE[0,8)\\u6269\\u5C55\\u5230[0,16)\\u3002\\n\\u4E0B\\u4E00\\u4E2A\\u6570\\u662F13\\uFF0C\\u6BD416\\u5C0F\\uFF0C\\u6839\\u636E\\u89C4\\u52191\\uFF0C\\u6211\\u4EEC\\u53EF\\u4EE5\\u628A\\u533A\\u95F4\\u4ECE[0,16)\\u6269\\u5C55\\u5230[0,29)\\u3002\\n\\n\\u4E0B\\u4E00\\u4E2A\\u6570\\u662F43\\uFF0C\\u6BD429\\u5927\\uFF0C\\u6839\\u636E\\u89C4\\u52192\\uFF0C\\u6DFB\\u52A029\\uFF0C\\u628A\\u533A\\u95F4\\u4ECE[0,29)\\u6269\\u5927\\u5230[0,58)\\u3002\\n\\n\\u7531\\u4E8E43\\u6BD458\\u5C0F\\uFF0C\\u6839\\u636E\\u89C4\\u52191\\uFF0C\\u53EF\\u4EE5\\u628A\\u533A\\u95F4\\u4ECE[0,58)\\u6269\\u5C55\\u5230[0,101)\\uFF0C\\u521A\\u597D\\u8986\\u76D6\\u4E86[1,100]\\u5185\\u7684\\u6240\\u6709\\u6570\\u3002\\n\\n\\u6700\\u7EC8\\u7ED3\\u679C\\u662F\\u6DFB\\u52A02\\u4E2A\\u6570\\uFF0C8\\u548C29\\uFF0C\\u5C31\\u53EF\\u4EE5\\u7EC4\\u5408\\u51FA[1,100]\\u5185\\u7684\\u6240\\u6709\\u6574\\u6570\\u3002\\n*/\\n\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long r=0;\\n        int nextn=1;\\n        int index=0;\\n        int res=0;\\n        while(r<n){\\n            if(index<(int)nums.size()&&r>=(nums[index]-1)){\\n                r+=nums[index++];\\n            }else{\\n                res++;\\n                r+=(r+1);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n\\n/*\\n\\u9700\\u8981\\u6CE8\\u610F\\u7684\\u6D4B\\u8BD5\\u7528\\u4F8B\\uFF1A\\n[1,2,31,33]\\n2147483647\\n\\n[1000000]\\n1000\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78523,
                "title": "share-my-simple-java-code",
                "content": "    public class Solution {\\n        public int minPatches(int[] nums, int n) {\\n            int count = 0, i = 0;\\n            for (long covered=0; covered < n; ) {\\n                if ((i<nums.length && nums[i]>covered+1) || i>=nums.length) {  // at this moment, we need (covered+1), patch it.\\n                    covered += covered+1;\\n                    ++count;\\n                } else { covered += nums[i++]; }\\n            }\\n            return count;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution {\\n        public int minPatches(int[] nums, int n) {\\n            int count = 0, i = 0;\\n            for (long covered=0; covered < n; ) {\\n                if ((i<nums.length && nums[i]>covered+1) || i>=nums.length) {  // at this moment, we need (covered+1), patch it.\\n                    covered += covered+1;\\n                    ++count;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 78547,
                "title": "greedy-solution-in-python",
                "content": "I used a greedy algorithm. When traversing through the given number list, consider each number as a **goal** and **resource**. When in the for loop for the *ith* number, try to add some numbers so that you can represent every number in the range [ 1, nums[i] ). Then, add the *ith* number to your source for further loops. \\n\\nTo reach the goal, suppose all the resource (the numbers smaller than the goal) sums to a number `sum`, then, `sum+1` is what we don't have. So we need to add a `sum+1` to our resource. And now you can represent all the numbers not bigger than `sum+sum+1`.\\n\\n    class Solution(object):\\n\\n    def minPatches(self, nums, n):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        sum = 0\\n        for x in nums:\\n            if sum >= n:\\n                return count\\n            while sum < x-1:  # x-1 is the goal; when reaches the goal, we can represent [1, x)\\n                count += 1\\n                sum += sum + 1  # add a resource number\\n                if sum >= n:\\n                    return count\\n            sum += x\\n        while sum + 1 <= n:\\n            count += 1\\n            sum += sum + 1\\n        return count",
                "solutionTags": [],
                "code": "I used a greedy algorithm. When traversing through the given number list, consider each number as a **goal** and **resource**. When in the for loop for the *ith* number, try to add some numbers so that you can represent every number in the range [ 1, nums[i] ). Then, add the *ith* number to your source for further loops. \\n\\nTo reach the goal, suppose all the resource (the numbers smaller than the goal) sums to a number `sum`, then, `sum+1` is what we don't have. So we need to add a `sum+1` to our resource. And now you can represent all the numbers not bigger than `sum+sum+1`.\\n\\n    class Solution(object):\\n\\n    def minPatches(self, nums, n):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        sum = 0\\n        for x in nums:\\n            if sum >= n:\\n                return count\\n            while sum < x-1:  # x-1 is the goal; when reaches the goal, we can represent [1, x)\\n                count += 1\\n                sum += sum + 1  # add a resource number\\n                if sum >= n:\\n                    return count\\n            sum += x\\n        while sum + 1 <= n:\\n            count += 1\\n            sum += sum + 1\\n        return count",
                "codeTag": "Java"
            },
            {
                "id": 1843478,
                "title": "c-explained-in-hinglish-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    //  Approach -\\n    //  Ham kya karege ki ek reach variable lenge\\n    //  Reach hame bataega ki kis number tak ham pohoch sakte he jo hamare pass number he unse\\n    //  Ham kya krege ki jab tak reach < n tab tak lopp chalaege\\n    \\n    //  Agar reach < nums[i] to matlab abhi ham nums[i] tak number generate nahi kar sakte\\n    //  isliye hame kuch patch add karna hoga, or bo patch reach + 1 hoga kyuki reach tak ke number ham generate kar sakte he\\n    //  Lekin Reach se Jyada nahi isliye ham reach se ek jyada number ko patch kaarege array me jisse reach increase ho jaegi\\n    //  reach += reach + 1 se\\n    \\n    \\n    // Or jab reach nums[i] se jyada ho to matlab ham nums[i] se jyada generate kar sakte nums[i] ke bina \\n    // or agar nums[i] ko bhi saath le le to reach increase ho jaegi reach + nums[i] kyoki nums[i] ko ham 1 to reach sabke saath\\n    // add kar sakte he to jisse max reach hamari reach + nums[i] ho jaegi\\n    \\n    //Ek case or jab reach nums[i] se ek kam ho tab means (nums[i] == reach + 1) is time ham reach ko nums[i] se increase kar denge\\n    // kyoki ham nums[i] - 1 tak generate kar sakte agar nums[i] aa jaega to nums[i] + reach ista generate kar paege\\n    \\n    // For Ex - 1 5 10\\n        // reach = 0         nums[i] = 1         nums[i] <= reach + 1    ye last bala case jab nums[i] == reach + 1 to reach me num[i] add karege  == > i++ (jab bhi nums[i] add ho jaega tabhi i++ karege)\\n        // reach = 1         nums[i] = 5         nums[i] > reach         array me patch karege reach + 1 (1 + 1 = 2) or reach increase karege\\n        // reach = 3 (1 +2)  nums[i] = 5         nums[i] > reach         array me patch karege reach + 1 (3 + 1 = 4) or reach increase karege\\n        // reach = 7 (3 +4)  nums[i] = 5         nums[i] <= reach + 1    reach += nums[i]   ==> i++\\n        // reach = 12(7 +5)  nums[i] = 10         nums[i] <= reach + 1    reach += nums[i]  ==> i++\\n        // reach = 22 (12+10)  reach > n breack loop return the patch count (we added 2 and 4 so count will be 2)\\n    \\n    \\n    int minPatches(vector<int>& nums, int n) {\\n        long long reach = 0;             \\n        int patches = 0;\\n        int i = 0;\\n        \\n        while(reach < n)\\n        {\\n            if(i < nums.size() && nums[i] <= reach+1) reach += nums[i++];\\n            else\\n            {\\n                reach += reach + 1;\\n                patches++;\\n            }\\n        }\\n        \\n        return patches;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //  Approach -\\n    //  Ham kya karege ki ek reach variable lenge\\n    //  Reach hame bataega ki kis number tak ham pohoch sakte he jo hamare pass number he unse\\n    //  Ham kya krege ki jab tak reach < n tab tak lopp chalaege\\n    \\n    //  Agar reach < nums[i] to matlab abhi ham nums[i] tak number generate nahi kar sakte\\n    //  isliye hame kuch patch add karna hoga, or bo patch reach + 1 hoga kyuki reach tak ke number ham generate kar sakte he\\n    //  Lekin Reach se Jyada nahi isliye ham reach se ek jyada number ko patch kaarege array me jisse reach increase ho jaegi\\n    //  reach += reach + 1 se\\n    \\n    \\n    // Or jab reach nums[i] se jyada ho to matlab ham nums[i] se jyada generate kar sakte nums[i] ke bina \\n    // or agar nums[i] ko bhi saath le le to reach increase ho jaegi reach + nums[i] kyoki nums[i] ko ham 1 to reach sabke saath\\n    // add kar sakte he to jisse max reach hamari reach + nums[i] ho jaegi\\n    \\n    //Ek case or jab reach nums[i] se ek kam ho tab means (nums[i] == reach + 1) is time ham reach ko nums[i] se increase kar denge\\n    // kyoki ham nums[i] - 1 tak generate kar sakte agar nums[i] aa jaega to nums[i] + reach ista generate kar paege\\n    \\n    // For Ex - 1 5 10\\n        // reach = 0         nums[i] = 1         nums[i] <= reach + 1    ye last bala case jab nums[i] == reach + 1 to reach me num[i] add karege  == > i++ (jab bhi nums[i] add ho jaega tabhi i++ karege)\\n        // reach = 1         nums[i] = 5         nums[i] > reach         array me patch karege reach + 1 (1 + 1 = 2) or reach increase karege\\n        // reach = 3 (1 +2)  nums[i] = 5         nums[i] > reach         array me patch karege reach + 1 (3 + 1 = 4) or reach increase karege\\n        // reach = 7 (3 +4)  nums[i] = 5         nums[i] <= reach + 1    reach += nums[i]   ==> i++\\n        // reach = 12(7 +5)  nums[i] = 10         nums[i] <= reach + 1    reach += nums[i]  ==> i++\\n        // reach = 22 (12+10)  reach > n breack loop return the patch count (we added 2 and 4 so count will be 2)\\n    \\n    \\n    int minPatches(vector<int>& nums, int n) {\\n        long long reach = 0;             \\n        int patches = 0;\\n        int i = 0;\\n        \\n        while(reach < n)\\n        {\\n            if(i < nums.size() && nums[i] <= reach+1) reach += nums[i++];\\n            else\\n            {\\n                reach += reach + 1;\\n                patches++;\\n            }\\n        }\\n        \\n        return patches;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1460448,
                "title": "concise-java-solution-faster-than-100-with-in-depth-explanation",
                "content": "Explaination:\\nInput: [1, 5, 10]\\n\\nInitially, our **reach is 0**. Let\\'s start the process of adding elts step by step:\\n1) Adding 1st elt, doesn\\'t make us miss elts. Since, reach is 0 and 1st element is 1. So Now **reach=1**.\\n2) Now, adding 2nd elt(i.e. 5) makes us miss elts 2,3,4 since reach is only 1 till now. So we add the lowest unreachable elt yet i.e. 2. So, now **reach=reach+(reach+1) i.e. 1 +2 = 3**.\\n**Why?**\\nSince, reach at any stage means that all elts from 1 to reach are reachable for example if reach is 5, all elements i.e 1, 2, 3, 4, 5 are reachable now suppose if we add 6 to it, then we get 6 more elements which can be reached i.e. [1+6, 2+6, 3+6, 4+6, 5+6]. Hence, reach increases by the element we add.\\nSo, in above case previous reach was 1, we added (reach+1) element **hence, reach=reach+(reach+1) i.e. reach = 2 * reach + 1.**\\n3) Again 2nd element(i.e. 5) cannot be added since reach is still 3, hence 4 is missing. So we add 4 to the array which makes **reach=reach+4 = 3 + 4 = 7.**\\n4) Now, we can add 2nd element because it\\'s less than reach, hence we don\\'t miss any element. \\n**Now, reach = reach + 5 = 7 + 5 = 12.**\\n5) Next, we add the 3rd element(i.e. 10) since it\\'s less than reach and that means we don\\'t miss any element.\\n**Now, reach = reach + 10 = 12 + 10 = 22**.\\nWhich is greater than n, hence we added 2 and 4 to the array as in step 2 and 3.\\n\\n**Key Points:**\\n**1) From 2nd Point:\\n\\tif(arr[i]>(reach+1)){\\n\\t\\t// This indicates certain elts are missing and we add lowest elt after reach i.e. (reach+1)\\n\\t\\t// 2nd and 3rd Points indicate this.\\n\\t\\treach=reach+(reach+1)\\n\\t\\telts_added+=1;\\n\\t}else{\\n\\t\\t// This indicates that no elts are missing - 4th and 5th Points indicates this.\\n\\t\\treach=reach+(arr[i]);\\n\\t}**\\n\\t\\n\\tNow below code should make sense.\\n\\t`\\n\\tpublic int minPatches(int[] nums, int n) {\\n        int ans=0,i=0;\\n        long reach=0;\\n        while(reach<n){\\n            if(i<nums.length && nums[i]<=(reach+1))\\n                reach+=nums[i++];\\n            else{\\n                reach=(reach<<1)+1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t`",
                "solutionTags": [],
                "code": "Explaination:\\nInput: [1, 5, 10]\\n\\nInitially, our **reach is 0**. Let\\'s start the process of adding elts step by step:\\n1) Adding 1st elt, doesn\\'t make us miss elts. Since, reach is 0 and 1st element is 1. So Now **reach=1**.\\n2) Now, adding 2nd elt(i.e. 5) makes us miss elts 2,3,4 since reach is only 1 till now. So we add the lowest unreachable elt yet i.e. 2. So, now **reach=reach+(reach+1) i.e. 1 +2 = 3**.\\n**Why?**\\nSince, reach at any stage means that all elts from 1 to reach are reachable for example if reach is 5, all elements i.e 1, 2, 3, 4, 5 are reachable now suppose if we add 6 to it, then we get 6 more elements which can be reached i.e. [1+6, 2+6, 3+6, 4+6, 5+6]. Hence, reach increases by the element we add.\\nSo, in above case previous reach was 1, we added (reach+1) element **hence, reach=reach+(reach+1) i.e. reach = 2 * reach + 1.**\\n3) Again 2nd element(i.e. 5) cannot be added since reach is still 3, hence 4 is missing. So we add 4 to the array which makes **reach=reach+4 = 3 + 4 = 7.**\\n4) Now, we can add 2nd element because it\\'s less than reach, hence we don\\'t miss any element. \\n**Now, reach = reach + 5 = 7 + 5 = 12.**\\n5) Next, we add the 3rd element(i.e. 10) since it\\'s less than reach and that means we don\\'t miss any element.\\n**Now, reach = reach + 10 = 12 + 10 = 22**.\\nWhich is greater than n, hence we added 2 and 4 to the array as in step 2 and 3.\\n\\n**Key Points:**\\n**1) From 2nd Point:\\n\\tif(arr[i]>(reach+1)){\\n\\t\\t// This indicates certain elts are missing and we add lowest elt after reach i.e. (reach+1)\\n\\t\\t// 2nd and 3rd Points indicate this.\\n\\t\\treach=reach+(reach+1)\\n\\t\\telts_added+=1;\\n\\t}else{\\n\\t\\t// This indicates that no elts are missing - 4th and 5th Points indicates this.\\n\\t\\treach=reach+(arr[i]);\\n\\t}**\\n\\t\\n\\tNow below code should make sense.\\n\\t`\\n\\tpublic int minPatches(int[] nums, int n) {\\n        int ans=0,i=0;\\n        long reach=0;\\n        while(reach<n){\\n            if(i<nums.length && nums[i]<=(reach+1))\\n                reach+=nums[i++];\\n            else{\\n                reach=(reach<<1)+1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t`",
                "codeTag": "Unknown"
            },
            {
                "id": 1432739,
                "title": "c-python3-java-easy-approach-with-simple-solution",
                "content": "**APPROACH**\\n* Let us assume that we are on some `i`th element of the array.\\n* We were successfullly able to create each and every number till the range `arr[i]-1` by taking some numbers from arr in the range `0` to `i-1`. \\n* Hence after choosing `arr[i]` we can create numbers from `0` to `arr[i]-1 + arr[i]` . \\n\\t* Extra `arr[i]+1 to arr[i]+arr[i] -1` can be created by using `some numbers` and `arr[i]`\\n* If we are able to create numbers upto `arr[i]-1` \\n\\t* No need to patch\\n* Else \\n\\t* patch it with whatever numbers we are able to make +1 i.e `sum+1`\\n\\n\\n**SOLUTION**\\n`In C++`\\n```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        int m = nums.size() ;\\n        long long i = 1, sum = 1 ,ans = 0 ;\\n        if(nums[0] != 1)\\n        {\\n            ans++ ;\\n            i--;\\n        }\\n        while(i < m && sum < n)\\n        {\\n            while(sum < nums[i]-1 && sum < n)\\n            {\\n                ans++ ;\\n                sum += sum + 1 ;\\n            }\\n            sum += nums[i] ;\\n            i++ ;\\n        }\\n        while(sum < n)\\n        {\\n            ans++ ;\\n            sum += sum + 1 ;\\n        }\\n        return ans;\\n    }\\n}; \\n```\\n`In JAVA`\\n```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        int m = nums.length ;\\n        int i = 1 , ans = 0 ;\\n        long sum = 1 ;\\n        if(nums[0] != 1)\\n        {\\n            ans++ ;\\n            i-- ;\\n        }\\n        while(i < m && sum < n)\\n        {\\n            while(sum < nums[i]-1 && sum < n)\\n            {\\n                ans++ ;\\n                sum = (sum<<1) + 1 ;\\n            }\\n            sum += nums[i] ;\\n            i++ ;\\n        }\\n        while(sum < n)\\n        {\\n            ans++ ;\\n            sum = (sum<<1) + 1;\\n        }\\n        return ans ;\\n    }\\n}\\n```\\n`In Python3`\\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        m = len(nums)\\n        i = 1 \\n        ans = 0\\n        summ = 1\\n        if nums[0] != 1:\\n            ans+=1\\n            i -= 1\\n        while i < m and summ < n:\\n            while summ < nums[i]-1 and summ < n:\\n                ans+=1\\n                summ += summ + 1\\n                \\n            summ += nums[i] \\n            i+=1\\n        while summ < n:\\n            ans+=1\\n            summ += summ + 1\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        int m = nums.size() ;\\n        long long i = 1, sum = 1 ,ans = 0 ;\\n        if(nums[0] != 1)\\n        {\\n            ans++ ;\\n            i--;\\n        }\\n        while(i < m && sum < n)\\n        {\\n            while(sum < nums[i]-1 && sum < n)\\n            {\\n                ans++ ;\\n                sum += sum + 1 ;\\n            }\\n            sum += nums[i] ;\\n            i++ ;\\n        }\\n        while(sum < n)\\n        {\\n            ans++ ;\\n            sum += sum + 1 ;\\n        }\\n        return ans;\\n    }\\n}; \\n```\n```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        int m = nums.length ;\\n        int i = 1 , ans = 0 ;\\n        long sum = 1 ;\\n        if(nums[0] != 1)\\n        {\\n            ans++ ;\\n            i-- ;\\n        }\\n        while(i < m && sum < n)\\n        {\\n            while(sum < nums[i]-1 && sum < n)\\n            {\\n                ans++ ;\\n                sum = (sum<<1) + 1 ;\\n            }\\n            sum += nums[i] ;\\n            i++ ;\\n        }\\n        while(sum < n)\\n        {\\n            ans++ ;\\n            sum = (sum<<1) + 1;\\n        }\\n        return ans ;\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        m = len(nums)\\n        i = 1 \\n        ans = 0\\n        summ = 1\\n        if nums[0] != 1:\\n            ans+=1\\n            i -= 1\\n        while i < m and summ < n:\\n            while summ < nums[i]-1 and summ < n:\\n                ans+=1\\n                summ += summ + 1\\n                \\n            summ += nums[i] \\n            i+=1\\n        while summ < n:\\n            ans+=1\\n            summ += summ + 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78501,
                "title": "python-solution-clear-explanation-o-nums-log-n",
                "content": "We want to form all numbers from 1 to n. Let's assume we already have the solutions for a smaller problem. We have an array to reach all numbers up to k, 1 <= k < n, but not more. We have used nums<sub>0</sub> to nums<sub>i</sub> to create that array plus some patches. The next element is k+1. There is no way we can create k+1 with our current array (we defined the array that way), so I need to add a new element to it, nums<sub>i+1</sub>. As my previous array was able to give all elements from 1 to k, adding nums<sub>i+1</sub> will give me all elements between 1 and k+nums<sub>i+1</sub>.\\n\\nThe trick here is to find those compact arrays that are able to produce all values between 1 and k. We can do that starting in k=1 and adding elements from nums or patching our array. To reach k=1 I need a 1. If nums_0 is 1, I can add it to my array otherwise I need to pad with 1. To reach k=2 I need another 1 or a 2.\\n\\nAnd so on. So, if you keep track of the highest number you can reach in your current array there could be two possibilities:\\n- nums<sub>i</sub> is smaller than k. Just increase k.\\n- nums<sub>i</sub> is bigger than k. That means that you can't create any number between k+1 and nums<sub>i</sub>-1. Add k+1 instead. That will move k to 2*k+1.\\n\\nRepeat until k>=n.\\n\\n```python\\ndef minPatches(self, nums, n):\\n    i, k, added = 0,0,0\\n    while k < n:\\n        if i < len(nums) and nums[i] <= k+1:\\n            k += nums[i]\\n            i+=1\\n        else:\\n            k += k+1\\n            added += 1\\n    return added\\n```",
                "solutionTags": [],
                "code": "```python\\ndef minPatches(self, nums, n):\\n    i, k, added = 0,0,0\\n    while k < n:\\n        if i < len(nums) and nums[i] <= k+1:\\n            k += nums[i]\\n            i+=1\\n        else:\\n            k += k+1\\n            added += 1\\n    return added\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 78525,
                "title": "recommend-for-beginners-clean-c-implementation-with-detailed-explanation",
                "content": "we run the code on an example to illustrate the ideas:\\n  \\n        [1, miss)   : the right miss is open field\\n\\n         nums=[1,5,10]      n=20\\n\\n        initialize state : miss=1   i=0   size=3\\n\\nmiss=1 :   i=0\\n\\n        if find [number<=1] in nums {  i++  }  else add 1 to nums   update    miss+=1         [1,2)\\n        found 1,  i++, so added 1 to the nums \\n  \\nmiss=2 :  i=1\\n\\n        if find [number<=2] in nums  { i++ }   else add 2 to nums    update  miss+=2;        [1,4)\\n        not found ,  so add 2 to the nums\\n\\nmiss=4 : i=1\\n\\n        if find [number<=4] in nums  { i++ }   else add 4 to nums    update  miss+=2;        [1,8)\\n        not found ,  so add 4 to the nums\\n       \\nmiss=8: i=1\\n\\n        if find [number<=8] in nums  { i++ }   else add 8 to nums    update  miss+=2;        [1,13)\\n        found 5 , so add 5 to the nums  \\n\\nmiss=13:i=2\\n\\n        if find [number<=13] in nums  { i++ }   else add 13 to nums    update  miss+=2;        [1,23)\\n        found 10 , so add 10 to the nums \\n\\nmiss=23 \\n\\n        covers [1,20], done!\\n\\nreturn added=2\\n\\n\\nCode:\\n\\n\\n    class Solution {\\n    public:\\n        int minPatches(vector<int>& nums, int n) {\\n            long miss=1, added=0, i=0;\\n            while(miss<=n){\\n                /*** update the miss to the (miss+nums[i]) **/\\n                if(i<nums.size() && nums[i]<=miss){\\n                    miss+=nums[i++];\\n                }else{\\n                /*** update the miss to the miss+miss **/\\n                    miss+=miss;\\n                    added++;\\n                }\\n            }\\n            return added;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minPatches(vector<int>& nums, int n) {\\n            long miss=1, added=0, i=0;\\n            while(miss<=n){\\n                /*** update the miss to the (miss+nums[i]) **/\\n                if(i<nums.size() && nums[i]<=miss){\\n                    miss+=nums[i++];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 78539,
                "title": "my-8-ms-o-n-c-code",
                "content": "The basic idea is to use \"bound\" to save the maximum number that can be generated with nums[0..i-1] and the added numbers (i.e. using nums[0..i-1] and the added numbers, we can generate all the numbers in [1..bound]). If bound is less than n and nums[i] is larger than bound+1, then we need to add bound+1, which extend the maximum number that can be generated to bound*2 +1. If nums[i] is no larger than bound+1, then by add nums[i], we can extend the maximum number that can be generated to bound + nums[i].\\n\\n    class Solution {\\n    public:\\n        int minPatches(vector<int>& nums, int n) {\\n            int len = nums.size(),  i=0, res=0;\\n            long long bound = 0;\\n            while(bound<n) \\n            {// if it does not reach to the end\\n                if(i<len && nums[i]<=(bound+1)) bound+=nums[i++]; // if nums[i] is no larger than bound, then including nums[i] allow us to generate all the numbers [1.. bound+nums[i]]\\n                else{++res; bound= 2*bound+1;}  // we need to add a new number bound+1, and that extend the bound to 2*bound+1\\n            }\\n            return res;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minPatches(vector<int>& nums, int n) {\\n            int len = nums.size(),  i=0, res=0;\\n            long long bound = 0;\\n            while(bound<n) \\n            {// if it does not reach to the end\\n                if(i<len && nums[i]<=(bound+1)) bound+=nums[i++]; // if nums[i] is no larger than bound, then including nums[i] allow us to generate all the numbers [1.. bound+nums[i]]\\n                else{++res; bound= 2*bound+1;}",
                "codeTag": "Java"
            },
            {
                "id": 3242439,
                "title": "330-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n\\nTo solve this problem, we can use a greedy approach. We start with a variable miss that represents the smallest number that cannot be formed by summing up any combination of the numbers in the array. Initially, miss is set to 1, since we can always form 1 by taking an empty combination. We also initialize a variable i to 0, which represents the index of the next number that we need to consider adding to the array.\\n\\nWe then loop while miss is less than or equal to n, which means that we still need to add more numbers to the array. If i is less than the length of the array and the next number in the array is less than or equal to miss, we add that number to the sum and increment i. Otherwise, we add miss to the array and update miss to be the new smallest number that cannot be formed by summing up any combination of the numbers in the array.\\n\\nThe reason why this greedy approach works is that whenever we add a number to the array, we can form all the numbers up to miss + number - 1. If we then update miss to be miss + number, we can now form all the numbers up to 2 * miss - 1. Therefore, we keep increasing miss until we can form all the numbers up to n.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n  def minPatches(self, nums: List[int], n: int) -> int:\\n    miss, i, patches = 1, 0, 0\\n    while miss <= n:\\n        if i < len(nums) and nums[i] <= miss:\\n            miss += nums[i]\\n            i += 1\\n        else:\\n            miss *= 2\\n            patches += 1\\n    return patches\\n\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n  def minPatches(self, nums: List[int], n: int) -> int:\\n    miss, i, patches = 1, 0, 0\\n    while miss <= n:\\n        if i < len(nums) and nums[i] <= miss:\\n            miss += nums[i]\\n            i += 1\\n        else:\\n            miss *= 2\\n            patches += 1\\n    return patches\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1562606,
                "title": "python-o-n-greedy",
                "content": "Consider some prefix of our array and say the minimal number it can\\'t achieve is `minn`, if the next number is greater than `minn` we won\\'t be able to achieve `minn` at all (since all numbers are increasing and greater than `minn`) thus next number must be less or equal than `minn` if not so we need to patch with such a number. Say our next number `k` satisfies being less or equal than `minn` or otherwise we patched it with some number `k`, then in the new prefix minimal number it can\\'t achieve will be `minn + k` and so on we keep maintaining our minimal unachievable number until it is greater than `n`. It is better to patch with such `k` that maximizes `minn+k` and satisfies `k<=minn`, such `k` is actually equal to `minn`. (This part is greedy). After performing such linear scan we will achieve what we want.\\n\\n```\\nclass Solution:\\n    def minPatches(self, nums, n):\\n        i, ct, minn = 0, 0, 1\\n        while minn <= n:\\n            if i < len(nums) and nums[i] <= minn:\\n                minn += nums[i]\\n                i += 1\\n            else:\\n                minn += minn\\n                ct += 1\\n        return ct\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPatches(self, nums, n):\\n        i, ct, minn = 0, 0, 1\\n        while minn <= n:\\n            if i < len(nums) and nums[i] <= minn:\\n                minn += nums[i]\\n                i += 1\\n            else:\\n                minn += minn\\n                ct += 1\\n        return ct\\n```",
                "codeTag": "Java"
            },
            {
                "id": 992250,
                "title": "easy-python-solution-defeat-100",
                "content": "Let\\'s see a situation, for example the n is 10 and `nums` is empty, the optimal solution to \"reach\" 10 is `0 1 2 4 7 15`, we can find the pattern that we start from `stack = [0]`, the next number should be sum of stack plus 1 equal to 1, and put 1 into stack, it become [0, 1], then the next number should be 2, the stack should be [0, 1, 2]...\\nThen what about if we have a 3 in nums? \\n```\\n1. [0]\\n2. [0, 1]\\n3. [0, 1, 2]\\n4. [0, 1, 2, 4] # becase 4 is greater than 3 which we already have in nums, let\\'s replace 4 with 3\\n4. [0, 1, 2, 3]\\n5. [0, 1, 2, 3, 7] # next step will reach target n=10!\\n6. [0, 1, 2, 3, 7, 14]\\n```\\nIf current nums is >= nums[i], use nums[i] replace current number and add it into SUM until SUM is >= n.\\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        ret = i = s = 0 # ret: return value, s: SUM\\n        while True:\\n            if s >= n:\\n                return ret\\n            if i < len(nums) and s + 1 >= nums[i]:\\n                s += nums[i]\\n                i += 1\\n            else:\\n                s += s + 1\\n                ret += 1\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n1. [0]\\n2. [0, 1]\\n3. [0, 1, 2]\\n4. [0, 1, 2, 4] # becase 4 is greater than 3 which we already have in nums, let\\'s replace 4 with 3\\n4. [0, 1, 2, 3]\\n5. [0, 1, 2, 3, 7] # next step will reach target n=10!\\n6. [0, 1, 2, 3, 7, 14]\\n```\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        ret = i = s = 0 # ret: return value, s: SUM\\n        while True:\\n            if s >= n:\\n                return ret\\n            if i < len(nums) and s + 1 >= nums[i]:\\n                s += nums[i]\\n                i += 1\\n            else:\\n                s += s + 1\\n                ret += 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350441,
                "title": "time-o-n-space-1-c-easy-to-understand-short-sweet",
                "content": "````\\n/*\\ni E to [1,n]\\nreach at ith day if nums[j]<=i+1 than add nums[j] into i  else add i+1 in to ith day\\n*/\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long sum = 0, cnt = 0, i = 0;\\n        while(sum<n){\\n            if(i<nums.size()&&nums[i]<=sum+1){\\n                sum += nums[i++];\\n            }else{\\n                cnt++;\\n                sum += sum+1;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n````",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array",
                    "Greedy"
                ],
                "code": "````\\n/*\\ni E to [1,n]\\nreach at ith day if nums[j]<=i+1 than add nums[j] into i  else add i+1 in to ith day\\n*/\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long sum = 0, cnt = 0, i = 0;\\n        while(sum<n){\\n            if(i<nums.size()&&nums[i]<=sum+1){\\n                sum += nums[i++];\\n            }else{\\n                cnt++;\\n                sum += sum+1;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3147544,
                "title": "python-math",
                "content": "# Intuition\\nIf sum of all the numbers considered till now is x, we can form all the numbers from 1 to x. This condition is True every time.\\n\\n# Approach\\nKeep a variable limit which tracks till what max value we can form which is nothing but sum of all values considered till now.\\nIf we encounter any number i.e. num which is greater than limit+1, it means we can\\'t get any number between limit+1 to num-1.So we add limit+1 to our limit to extend our current limit and increase our answer count by 1 (Internally we are adding limit+1 to our array).Continue this process untill num is greater than limit+1.Meanwhile if at any moment limit >=ssum break off the loop.\\nAfter considering all numbers from array , check if limit is still less than ssum and keep adding limit+1 and incrementing answer count to our limit till limit<ssum.\\nNote : We need to necessarily add limit+1 every time and not any number greater than this as we can\\'t form limit+1 using any of our previously considered numbers.\\n\\n# Complexity\\n- Time complexity:\\nO(n) \\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], ssum: int) -> int:\\n        n=len(nums)\\n        limit,cnt=0,0\\n        for i in range(n):\\n            if nums[i]>limit+1:\\n                while nums[i]>limit+1:\\n                    limit+=limit+1\\n                    cnt+=1\\n                    if limit>=ssum: break\\n            limit+=nums[i]\\n            if limit>=ssum: break\\n        while limit<ssum:\\n            limit+=limit+1\\n            cnt+=1\\n        return cnt\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Math"
                ],
                "code": "```\\nclass Solution:\\n    def minPatches(self, nums: List[int], ssum: int) -> int:\\n        n=len(nums)\\n        limit,cnt=0,0\\n        for i in range(n):\\n            if nums[i]>limit+1:\\n                while nums[i]>limit+1:\\n                    limit+=limit+1\\n                    cnt+=1\\n                    if limit>=ssum: break\\n            limit+=nums[i]\\n            if limit>=ssum: break\\n        while limit<ssum:\\n            limit+=limit+1\\n            cnt+=1\\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696845,
                "title": "shortest-solution-c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        int patches = 0, i = 0, sz = nums.size();\\n        long count = 1;\\n        while (count <= n) {\\n            \\n            if (i < sz && nums[i] <= count) \\n                count += nums[i++];\\n            \\n            else {\\n                count *= 2;\\n                patches++;\\n            }\\n        }\\n        \\n        return patches;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        int patches = 0, i = 0, sz = nums.size();\\n        long count = 1;\\n        while (count <= n) {\\n            \\n            if (i < sz && nums[i] <= count) \\n                count += nums[i++];\\n            \\n            else {\\n                count *= 2;\\n                patches++;\\n            }\\n        }\\n        \\n        return patches;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1813234,
                "title": "java-simple-solution",
                "content": "<hr>\\n\\n***UPVOTE IF YOU FIND IT USEFUL***\\n<hr>\\n\\n```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        int patches = 0, i = 0;\\n        long val = 1;\\n        \\n        while(val <= n){\\n            if(i < nums.length && nums[i] <= val){\\n                val += nums[i++];\\n            }\\n            else{\\n                val += val;\\n                patches++;\\n            }\\n            \\n            //System.out.println(val);\\n        }\\n        \\n        return patches;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        int patches = 0, i = 0;\\n        long val = 1;\\n        \\n        while(val <= n){\\n            if(i < nums.length && nums[i] <= val){\\n                val += nums[i++];\\n            }\\n            else{\\n                val += val;\\n                patches++;\\n            }\\n            \\n            //System.out.println(val);\\n        }\\n        \\n        return patches;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1630905,
                "title": "c-sol-runtime-4ms-faster-than-91-33",
                "content": "**Let\\'s consider an example: **\\n\\nLet\\'s say the input is nums = [1, 2, 4, 13, 43] and n = 100. We need to ensure that all sums in the range [1,100] are possible.\\nUsing the given numbers 1, 2 and 4, we can already build all sums from 0 to 7, i.e., the range [0,8). But we can\\'t build the sum 8, and the next given number (13) is too large. So we insert 8 into the array. Then we can build all sums in [0,16).\\n\\nDo we need to insert 16 into the array? No! We can already build the sum 3, and adding the given 13 gives us sum 16. We can also add the 13 to the other sums, extending our range to [0,29).\\n\\nAnd so on. The given 43 is too large to help with sum 29, so we must insert 29 into our array. This extends our range to [0,58). But then the 43 becomes useful and expands our range to [0,101). At which point we\\'re done.\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n\\t// To play safe from int overflow\\n        unsigned missing = 1, i = 0, ans = 0;\\n\\t\\t// we will run this loop in the range of [1,n]\\n        while(missing <= n){\\n\\t\\t// First check is to stay safe from runtime error\\n\\t// secondly we\\'ll check if the each element of the array is smaller than or equals to the missing one\\n\\t\\t// then we\\'ll keep that element else we\\'ll keep the twice of missing because of the concept I\\'ve written above\\n            if(i < nums.size() && nums[i] <= missing){\\n                missing += nums[i];\\n                i++;\\n            }else{\\n\\t\\t\\t// if we got our nums[i] greater than the missing one then we can\\'t keep it \\n\\t\\t\\t// so with this conclusion we can increase the count of our ans\\n                missing += missing;\\n                ans++;\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n\\t// To play safe from int overflow\\n        unsigned missing = 1, i = 0, ans = 0;\\n\\t\\t// we will run this loop in the range of [1,n]\\n        while(missing <= n){\\n\\t\\t// First check is to stay safe from runtime error\\n\\t// secondly we\\'ll check if the each element of the array is smaller than or equals to the missing one\\n\\t\\t// then we\\'ll keep that element else we\\'ll keep the twice of missing because of the concept I\\'ve written above\\n            if(i < nums.size() && nums[i] <= missing){\\n                missing += nums[i];\\n                i++;\\n            }else{\\n\\t\\t\\t// if we got our nums[i] greater than the missing one then we can\\'t keep it \\n\\t\\t\\t// so with this conclusion we can increase the count of our ans\\n                missing += missing;\\n                ans++;\\n            }  \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1462305,
                "title": "java-with-explanation",
                "content": "```\\n  /*\\n    Idea:\\n    Watch the case [1,5,10], n = 20\\n    let r as the right side number value of continuous sum range [0, r]\\n    initial r=0; and expected next number nums[i] should be <= r+1, else need a patch = r+1;\\n    if  nums[i]==r+1 then r will be r+(r+1)\\n    if  nums[i]< r+1 then r will be r+nums[i];\\n    i=0 numb[0] is 1, so need not patch and r=r+1= 1;\\n    i=1,numb[1] is 5, not expected <=2\\n         so need a patch =2;\\n         with the patch, now r=r+2=3 and expected <=4, but numb[1] is 5\\n         so need a patch =4;\\n         with the patch, now r=r+4=7 and expected <=8,   numb[1] is 5 works now\\n         so now r=r+5=12,  expected <=13,  move i to next\\n     i=2,numb[2] is 10, need not patch\\n         r=r+10=22> target 20 then break the loop.\\n\\n    Note \\' 1 <= n <= 2^31 - 1\\'\\n    so the `r` of continuous sum range [0, r] should be a long type\\n\\n    Observe\\n      - we must patch the expected number else continuous sum range [0, r] can not continue\\n\\n\\n   O(m+logN) time, M is the length of nums. N is the give number n;\\n   O(1) space\\n  */\\n  public static int minPatches(int[] nums, int n) {\\n    int patches = 0, N = nums.length;\\n    long r = 0; // need use long to avoid overflow\\n    int i = 0;\\n    while (r < n) {\\n      if (i < N && nums[i] > r + 1 || i == N) {\\n        patches++; // patch = r+1\\n        r = 2 * r + 1;\\n      } else {\\n        r = r + nums[i];\\n        i++;\\n      }\\n    }\\n    return patches;\\n  }\\n```",
                "solutionTags": [],
                "code": "```\\n  /*\\n    Idea:\\n    Watch the case [1,5,10], n = 20\\n    let r as the right side number value of continuous sum range [0, r]\\n    initial r=0; and expected next number nums[i] should be <= r+1, else need a patch = r+1;\\n    if  nums[i]==r+1 then r will be r+(r+1)\\n    if  nums[i]< r+1 then r will be r+nums[i];\\n    i=0 numb[0] is 1, so need not patch and r=r+1= 1;\\n    i=1,numb[1] is 5, not expected <=2\\n         so need a patch =2;\\n         with the patch, now r=r+2=3 and expected <=4, but numb[1] is 5\\n         so need a patch =4;\\n         with the patch, now r=r+4=7 and expected <=8,   numb[1] is 5 works now\\n         so now r=r+5=12,  expected <=13,  move i to next\\n     i=2,numb[2] is 10, need not patch\\n         r=r+10=22> target 20 then break the loop.\\n\\n    Note \\' 1 <= n <= 2^31 - 1\\'\\n    so the `r` of continuous sum range [0, r] should be a long type\\n\\n    Observe\\n      - we must patch the expected number else continuous sum range [0, r] can not continue\\n\\n\\n   O(m+logN) time, M is the length of nums. N is the give number n;\\n   O(1) space\\n  */\\n  public static int minPatches(int[] nums, int n) {\\n    int patches = 0, N = nums.length;\\n    long r = 0; // need use long to avoid overflow\\n    int i = 0;\\n    while (r < n) {\\n      if (i < N && nums[i] > r + 1 || i == N) {\\n        patches++; // patch = r+1\\n        r = 2 * r + 1;\\n      } else {\\n        r = r + nums[i];\\n        i++;\\n      }\\n    }\\n    return patches;\\n  }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1434359,
                "title": "very-easy-c-code-explained",
                "content": "# \\tSteps:\\n   Please upvote if you find it helpful .\\n\\tEvery Interation we can have either of the three conditions:\\n\\tWe keep interating unitll our **reach>=n**\\n\\t\\n\\t1. If my current number is less than or equal to reach, then add that to the reach and move i forward.\\n\\t2. If my current element, nums[i] is greater than the current reach then we search for the smallest number we should add to make the current element in reach, which is going to be  (reach+1).\\n\\t3. If we surpass the array boundary i.e. i>nums.size(), we are again going to look for the smallest element we can add to reach the desired target n. This smallest number is going to be again (reach+1).\\n```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        int count=0;\\n        long long reach=0;\\n        int i=0;\\n        while(reach<n){\\n            if(i>=nums.size()){\\n                reach+=reach+1;\\n                count++;\\n            }\\n            else if(i<nums.size() && nums[i]<=reach+1){\\n                reach+=nums[i];\\n                i++;\\n            }\\n            else {\\n                reach+=reach+1;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        int count=0;\\n        long long reach=0;\\n        int i=0;\\n        while(reach<n){\\n            if(i>=nums.size()){\\n                reach+=reach+1;\\n                count++;\\n            }\\n            else if(i<nums.size() && nums[i]<=reach+1){\\n                reach+=nums[i];\\n                i++;\\n            }\\n            else {\\n                reach+=reach+1;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433023,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        int count = 0;\\n        int i = 0;\\n        long reach = 0;\\n        \\n        while(reach<n){\\n            \\n            if(i>=nums.length){\\n                reach += reach + 1;\\n                count++;\\n            }\\n            \\n            else if(i<nums.length && nums[i] <= (reach+1)){\\n                reach += nums[i];\\n                i++;\\n            }\\n            else{\\n                reach += reach + 1;\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        int count = 0;\\n        int i = 0;\\n        long reach = 0;\\n        \\n        while(reach<n){\\n            \\n            if(i>=nums.length){\\n                reach += reach + 1;\\n                count++;\\n            }\\n            \\n            else if(i<nums.length && nums[i] <= (reach+1)){\\n                reach += nums[i];\\n                i++;\\n            }\\n            else{\\n                reach += reach + 1;\\n                count++;\\n            }\\n            \\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1140044,
                "title": "java-greedy-100-faster",
                "content": "```\\n\\tpublic int minPatches(int[] nums, int n) {\\n        int patches= 0;\\n        long sum= 0, limit= (long)n;\\n        for(int i=0; i<nums.length; i++){\\n            if(sum>=limit) break;\\n            if(sum+1<nums[i]){\\n                i--; patches++;\\n                sum+= sum+1;\\n            }else sum+= (long)nums[i];\\n        }\\n        while(sum<limit){\\n            sum+= sum+1; patches++;\\n        }\\n        return patches;\\n    }",
                "solutionTags": [],
                "code": "```\\n\\tpublic int minPatches(int[] nums, int n) {\\n        int patches= 0;\\n        long sum= 0, limit= (long)n;\\n        for(int i=0; i<nums.length; i++){\\n            if(sum>=limit) break;\\n            if(sum+1<nums[i]){\\n                i--; patches++;\\n                sum+= sum+1;\\n            }else sum+= (long)nums[i];\\n        }\\n        while(sum<limit){\\n            sum+= sum+1; patches++;\\n        }\\n        return patches;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 651574,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long maxReach = 0;\\n        int ans = 0;\\n        for(int i = 0; maxReach < n;) {\\n            if(i < nums.size() && nums[i] <= (maxReach + 1)) {\\n                maxReach = maxReach + nums[i];\\n                i++;\\n            } else {\\n                maxReach = maxReach + maxReach + 1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long maxReach = 0;\\n        int ans = 0;\\n        for(int i = 0; maxReach < n;) {\\n            if(i < nums.size() && nums[i] <= (maxReach + 1)) {\\n                maxReach = maxReach + nums[i];\\n                i++;\\n            } else {\\n                maxReach = maxReach + maxReach + 1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 351975,
                "title": "complete-insightful-explanation-recursive-and-iterative-solutions",
                "content": "####  Ignore the provided numbers array for a minute and just consider this:\\nIf you wanted to use a numbering system that allowed you to make ANY sum, which numbers would you use?\\nWe could just use a sequence of ones [1,1,1,1,..,1], but we would need a LOT of them to make big sums (N of them to make all sums up to N).\\n\\nWe already know a numbering system that does this well: **binary**.\\nWIth each binary digit we have, the largest sum, x, we can make increases by 2x + 1.\\nFor example, if we have 4 digits, the largest sum we can make in binary is 2^n - 1 = 15 and it looks like: 1111.\\nThe more significant the position, the more the digit is worth:\\n* The 0th is worth 2^0 = 1\\n* The 1st is worth 2^1 = 2\\n* The 2nd is worth 2^2 = 4\\n* ..And so on.\\n\\nIf we showed their values in base 10 in an array, it would look like this: [1, 2, 4, 8, 16, 32, ..., 2^n]\\nIn fact, it is this array that is the smallest amount of numbers needed to make any sum!\\nIf you understand binary, it should be intuitive why.\\n\\n#### How can we use this to find a solution?\\nIf we want to increase the range of sums we can make, the best we can do is to add double the previous number.\\nAnything larger would mean there is a sum that can\\'t be made.\\nFor example, if we had [1,2,4,9], we could make 7, but not 8, because 9 is larger than 4 * 2.\\n\\nHowever, we **can** use a number smaller than the previous, it just won\\'t increase our range as much.\\nWe are interested in minimizing the number of \\'patches\\' we make, and the numbers provided in the \\'nums\\' array come for free!\\nWe can take advantage of this.\\n\\n#### OK - Let\\'s see a full solution.\\n\\nWe will keep track of the largest possible sum we can make starting with 0 and incrementally extend it all the way to the target N.\\nAt each step, we have two choices:\\n* We can use a \\'patch\\' operation, in which case we would add the value \"previous + 1\". (Because this is largest we can extend the sum)\\n* We can use the number provided in the nums array, which only extends it by the num\\'s value, but it comes for free.\\n\\nAny time we CAN use the number provided, we should! This greedy approach yields an optimal solution.\\nBut when CAN\\'T we use the provided number? When it\\'s **larger** than previous + 1!\\n\\nThat brings us full circle to a solution we can implement.\\nI hope this was useful!\\n\\n#### Below are iterative and recursive implementations (in JS) for the described solution:\\n\\n**Recursive:**\\n```js\\n/**\\n* @param tgt - The target sum.\\n* @param cnt - Counts the number of patch operations so far.\\n* @param S - Tracks the largest sum we can currently reach.\\n* @param nums - The array of provided numbers\\n*/\\nlet solve = (tgt, cnt, S, [head, ...tail]) => {\\n    // Base Case -> We can now reach the target sum\\n    if (S >= tgt) return cnt\\n    \\n    // We\\'re out of provided numbers -> Patch the largest reachable num (previous + 1).\\n    if (!head) return solve(tgt, cnt + 1, S + S + 1, [])\\n    \\n    // We CAN reach the next number -> Extend the range by that amount.\\n    if (head <= S + 1) return solve(tgt, cnt, S + head, tail)\\n\\n    // Can\\'t reach the next number -> Patch the largest reachable num.\\n    return solve(tgt, cnt + 1, S + S + 1, [head, ...tail])\\n}\\n\\nlet minPatches = (nums, n) => solve(n, 0, 0, nums)\\n```\\n\\n**Iterative:**\\n```js\\nvar minPatches = function(nums, n) {\\n    // Counts the number of patch operations.\\n    let operations = 0\\n    \\n    // Tracks the index in the nums array we are at. Moves left to right.\\n    let idx = 0\\n    \\n    // Tracks highest sum we can make using numbers below \\'idx\\' and with \\'operations\\'.\\n    let upper = 0\\n    \\n    // Keeping going until we can reach the target sum, n.\\n    while (upper < n) {\\n        \\n        if (idx < nums.length && nums[idx] <= upper + 1) {\\n            // If we can reach the next num, use it and extend the range (upper) by that amount.\\n            upper += nums[idx++]\\n        } else {\\n            // We can\\'t reach the next num, so we need to patch.\\n            // For the patch, we want to extend the range as far as possible.\\n            // That is, upper + 1\\n            operations += 1\\n            upper += upper + 1\\n        }\\n    }\\n    return operations\\n};\\n```",
                "solutionTags": [],
                "code": "```js\\n/**\\n* @param tgt - The target sum.\\n* @param cnt - Counts the number of patch operations so far.\\n* @param S - Tracks the largest sum we can currently reach.\\n* @param nums - The array of provided numbers\\n*/\\nlet solve = (tgt, cnt, S, [head, ...tail]) => {\\n    // Base Case -> We can now reach the target sum\\n    if (S >= tgt) return cnt\\n    \\n    // We\\'re out of provided numbers -> Patch the largest reachable num (previous + 1).\\n    if (!head) return solve(tgt, cnt + 1, S + S + 1, [])\\n    \\n    // We CAN reach the next number -> Extend the range by that amount.\\n    if (head <= S + 1) return solve(tgt, cnt, S + head, tail)\\n\\n    // Can\\'t reach the next number -> Patch the largest reachable num.\\n    return solve(tgt, cnt + 1, S + S + 1, [head, ...tail])\\n}\\n\\nlet minPatches = (nums, n) => solve(n, 0, 0, nums)\\n```\n```js\\nvar minPatches = function(nums, n) {\\n    // Counts the number of patch operations.\\n    let operations = 0\\n    \\n    // Tracks the index in the nums array we are at. Moves left to right.\\n    let idx = 0\\n    \\n    // Tracks highest sum we can make using numbers below \\'idx\\' and with \\'operations\\'.\\n    let upper = 0\\n    \\n    // Keeping going until we can reach the target sum, n.\\n    while (upper < n) {\\n        \\n        if (idx < nums.length && nums[idx] <= upper + 1) {\\n            // If we can reach the next num, use it and extend the range (upper) by that amount.\\n            upper += nums[idx++]\\n        } else {\\n            // We can\\'t reach the next num, so we need to patch.\\n            // For the patch, we want to extend the range as far as possible.\\n            // That is, upper + 1\\n            operations += 1\\n            upper += upper + 1\\n        }\\n    }\\n    return operations\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 187184,
                "title": "c-solution-with-detailed-comments",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long maxReach = 0;\\n        int patch = 0;\\n        int S = nums.size();\\n        \\n        // traverse the array while maintaining the maxRead - the furthest number we can generate/\\n        // from the given numbers\\n        for(int i = 0; maxReach < n;){\\n            \\n            // if the next number is already covered by the range [1.. maxReach]\\n            // or it is just one passed maxReach we can add it to our total sum \\n            // to create a new maxReach range. \\n            if(i < S && nums[i] <= maxReach + 1){\\n                maxReach += (long long)nums[i];\\n                i++;\\n            }else{\\n                // if the next number is passed maxReach + 1 (or we have exhausted our array)\\n                // we should add a new number to our range (e.g. patch) and then this new number \\n                // effecitvely increases our ranges. By how much? we just need to add it to our range\\n                // to get a new range (which means that it doubles our range + 1)\\n                patch++;\\n                maxReach = maxReach*2 + 1;\\n            }\\n        }\\n\\t\\t\\t\\t\\n        return patch;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long maxReach = 0;\\n        int patch = 0;\\n        int S = nums.size();\\n        \\n        // traverse the array while maintaining the maxRead - the furthest number we can generate/\\n        // from the given numbers\\n        for(int i = 0; maxReach < n;){\\n            \\n            // if the next number is already covered by the range [1.. maxReach]\\n            // or it is just one passed maxReach we can add it to our total sum \\n            // to create a new maxReach range. \\n            if(i < S && nums[i] <= maxReach + 1){\\n                maxReach += (long long)nums[i];\\n                i++;\\n            }else{\\n                // if the next number is passed maxReach + 1 (or we have exhausted our array)\\n                // we should add a new number to our range (e.g. patch) and then this new number \\n                // effecitvely increases our ranges. By how much? we just need to add it to our range\\n                // to get a new range (which means that it doubles our range + 1)\\n                patch++;\\n                maxReach = maxReach*2 + 1;\\n            }\\n        }\\n\\t\\t\\t\\t\\n        return patch;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78527,
                "title": "javascript-solution",
                "content": "    var minPatches = function(nums, n) {\\n        var covered=1,count=0,i=0;\\n        //current covered range is [1,covered)\\n        while(covered<=n){\\n            if(i>=nums.length||covered<nums[i]){\\n                count++;\\n                covered+=covered;\\n            }else covered+=nums[i++];\\n        }\\n        return count;\\n    };",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    var minPatches = function(nums, n) {\\n        var covered=1,count=0,i=0;\\n        //current covered range is [1,covered)\\n        while(covered<=n){\\n            if(i>=nums.length||covered<nums[i]){\\n                count++;\\n                covered+=covered;\\n            }else covered+=nums[i++];\\n        }\\n        return count;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 78533,
                "title": "simple-python-solution",
                "content": "    def minPatches(self, nums, n):\\n        ans, nsum = 0, 0\\n        nums.append(n+1)\\n        for i in nums:\\n            num = min(i,n+1)\\n            while nsum + 1 < num:\\n                nsum += nsum + 1\\n                ans += 1\\n            nsum += num\\n        return ans",
                "solutionTags": [
                    "Python"
                ],
                "code": "    def minPatches(self, nums, n):\\n        ans, nsum = 0, 0\\n        nums.append(n+1)\\n        for i in nums:\\n            num = min(i,n+1)\\n            while nsum + 1 < num:\\n                nsum += nsum + 1\\n                ans += 1\\n            nsum += num\\n        return ans",
                "codeTag": "Python3"
            },
            {
                "id": 78535,
                "title": "7-line-javascript-solution",
                "content": "    function minPatches(nums, n) {\\n    \\tfor (var sum = 0, idx = 0, added = 0; sum < n;) {\\n    \\t\\tadded += idx === nums.length || nums[idx] > sum + 1 ? 1 : 0;\\n    \\t\\tsum += (nums[idx] || n) > sum + 1 ? sum + 1 : nums[idx++];\\n    \\t}\\n    \\treturn added;\\n    }",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "    function minPatches(nums, n) {\\n    \\tfor (var sum = 0, idx = 0, added = 0; sum < n;) {\\n    \\t\\tadded += idx === nums.length || nums[idx] > sum + 1 ? 1 : 0;\\n    \\t\\tsum += (nums[idx] || n) > sum + 1 ? sum + 1 : nums[idx++];\\n    \\t}\\n    \\treturn added;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 78528,
                "title": "easy-to-understand-1ms-java-solution",
                "content": "    public int minPatches(int[] nums, int n) {\\n        if(n<1) return 0;\\n        int patch=0;//number of patches\\n        int covers=0;//the cover range of current array\\n        for(int i=0;i<nums.length;i++){\\n            if(covers>=n) return patch;\\n            while(nums[i]-covers>1){\\n                patch++;  //patch the covers+1\\n                covers=covers*2+1;\\n                if(covers>=n) return patch;\\n            }\\n            if(nums[i]>Integer.MAX_VALUE-covers) return patch;\\n            covers=nums[i]+covers;\\n        }\\n        while(covers<n){\\n            patch++;\\n            if(covers>Integer.MAX_VALUE-covers) return patch;\\n            covers=covers*2+1;\\n        }\\n        return patch;\\n    }",
                "solutionTags": [],
                "code": "    public int minPatches(int[] nums, int n) {\\n        if(n<1) return 0;\\n        int patch=0;//number of patches\\n        int covers=0;//the cover range of current array\\n        for(int i=0;i<nums.length;i++){\\n            if(covers>=n) return patch;\\n            while(nums[i]-covers>1){\\n                patch++;  //patch the covers+1\\n                covers=covers*2+1;\\n                if(covers>=n) return patch;\\n            }\\n            if(nums[i]>Integer.MAX_VALUE-covers) return patch;\\n            covers=nums[i]+covers;\\n        }\\n        while(covers<n){\\n            patch++;\\n            if(covers>Integer.MAX_VALUE-covers) return patch;\\n            covers=covers*2+1;\\n        }\\n        return patch;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 78541,
                "title": "why-long-data-type-makes-a-difference",
                "content": "I tried write my own version of the code after understanding this fancy algorithm, however, i find that declare the variable with 'long' instead of 'int' really make a difference:\\n\\n    class Solution {\\n    public:\\n        int minPatches(vector<int>& nums, int n) {\\n            int miss_least = 1, i=0, cnt= 0;\\n            int M=nums.size();\\n    \\n            while(miss_least <= n){\\n                if (i<M  && nums[i] <= miss_least){\\n                    miss_least += nums[i++];\\n                }\\n                else{\\n                    miss_least+=miss_least;    // [1, miss_least +miss_least) to maximize the boundary\\n                    cnt++;\\n                }\\n            }\\n            \\n            return cnt;\\n    \\n        }\\n    };\\n\\nHere, I declare the miss_least as an integer, the online judge  just got TLE, when I change it to 'long',  the code get Accepted. Anyone knows the reason?",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minPatches(vector<int>& nums, int n) {\\n            int miss_least = 1, i=0, cnt= 0;\\n            int M=nums.size();\\n    \\n            while(miss_least <= n){\\n                if (i<M  && nums[i] <= miss_least){\\n                    miss_least += nums[i++];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 78543,
                "title": "o-k-log-n-time-o-1-space-java-with-explanation",
                "content": "Iterating the nums[], while keep adding them up, and we are getting a running sum starting from 0. At any position i, if nums[i] > sum+1, them we are sure we have to patch a (sum+1) because all nums before index i can't make sum+1 even adding all of them up, and all nums after index i are all simply too large. Since the sum is growing from 0, we also can be sure that any number equal or smaller than the current sum is covered.\\n\\nIn the worst case, the code will go thru all the numbers in the array before the sum goes doubling itself towards n. Therefore, the time is O(k+log(n)) where k being the size of the array and n being the target n to sum up. Thanks @StefanPochmann for pointing it out.\\n\\nHere is the accepted code,\\n\\n    public class Solution {\\n        public int minPatches(int[] nums, int n) {\\n            long sum = 0;\\n            int count = 0;\\n            for (int x : nums) {\\n                if (sum >= n) break;\\n                while (sum+1 < x && sum < n) { \\n                    ++count;\\n                    sum += sum+1;\\n                }\\n                sum += x;\\n            }\\n            while (sum < n) {\\n                sum += sum+1;\\n                ++count;\\n            }\\n            return count;\\n        }\\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n        public int minPatches(int[] nums, int n) {\\n            long sum = 0;\\n            int count = 0;\\n            for (int x : nums) {\\n                if (sum >= n) break;\\n                while (sum+1 < x && sum < n) { \\n                    ++count;\\n                    sum += sum+1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 3474163,
                "title": "simple-and-efficient-c-solution-90-beats",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        int ans=0;\\n       long long int sum=1;\\n        int m=nums.size();\\n        for(int i=0;i<m&&sum<=n;)\\n        {\\n            if(nums[i]>sum)\\n            {\\n                ans++;\\n                sum=(long long)sum+sum;\\n\\n            }\\n            else{\\n                 sum=(long long)sum+nums[i];\\n                 i++ ; }\\n        }\\n        while(sum<n)\\n        {\\n            sum=(long long)sum+sum;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        int ans=0;\\n       long long int sum=1;\\n        int m=nums.size();\\n        for(int i=0;i<m&&sum<=n;)\\n        {\\n            if(nums[i]>sum)\\n            {\\n                ans++;\\n                sum=(long long)sum+sum;\\n\\n            }\\n            else{\\n                 sum=(long long)sum+nums[i];\\n                 i++ ; }\\n        }\\n        while(sum<n)\\n        {\\n            sum=(long long)sum+sum;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2866989,
                "title": "90-faster-easy-understand-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    //find sum till ith index for sum < n if sum for k (k E [1,n]) not found k <= n than add k in our array and increment no of elemrnt in our addition array by 1.\\nint minPatches(vector<int>& nums, int n) {\\n        long long int sum = 0, cnt = 0, i = 0;\\n        while(sum < n){\\n            // cout<<sum<<\" \";\\n            if(i<nums.size() && nums[i]<=sum+1){\\n                sum += nums[i++];\\n            }else{\\n                cnt++;\\n                sum += sum+1;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //find sum till ith index for sum < n if sum for k (k E [1,n]) not found k <= n than add k in our array and increment no of elemrnt in our addition array by 1.\\nint minPatches(vector<int>& nums, int n) {\\n        long long int sum = 0, cnt = 0, i = 0;\\n        while(sum < n){\\n            // cout<<sum<<\" \";\\n            if(i<nums.size() && nums[i]<=sum+1){\\n                sum += nums[i++];\\n            }else{\\n                cnt++;\\n                sum += sum+1;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2752684,
                "title": "java-bruteforce-solution-beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n) - (Though it can be solved in O(1))\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n\\n        Stack<Integer> stack = new Stack<>();\\n        int count = 0;\\n        for(int i = nums.length - 1; i >= 0; i--) stack.push(nums[i]);\\n        long runningSum = 0l;\\n\\n        while(runningSum < n) {\\n            if(!stack.isEmpty() && stack.peek() <= runningSum+1) {\\n                runningSum += stack.pop();\\n            }\\n            else{\\n                count++;\\n                runningSum += (runningSum + 1);\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Stack",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n\\n        Stack<Integer> stack = new Stack<>();\\n        int count = 0;\\n        for(int i = nums.length - 1; i >= 0; i--) stack.push(nums[i]);\\n        long runningSum = 0l;\\n\\n        while(runningSum < n) {\\n            if(!stack.isEmpty() && stack.peek() <= runningSum+1) {\\n                runningSum += stack.pop();\\n            }\\n            else{\\n                count++;\\n                runningSum += (runningSum + 1);\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1979644,
                "title": "c-beats-100-greedy-o-n",
                "content": "```\\n/* \\n    Time: O(max(nums.size(), logn)\\n    Space: O(1)\\n    Tag: Greedy\\n    Difficulty: H\\n*/\\n\\nclass Solution {\\npublic:\\n    int minPatches(vector<int> &nums, int n) {\\n        int res = 0;\\n        long long curMax = 1;\\n        int idx = 0;\\n        while (curMax <= n) {\\n            if (idx<nums.size() && curMax >= nums[idx])\\n                curMax = curMax + nums[idx++];\\n            else {\\n                res++;\\n                curMax += curMax;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\n/* \\n    Time: O(max(nums.size(), logn)\\n    Space: O(1)\\n    Tag: Greedy\\n    Difficulty: H\\n*/\\n\\nclass Solution {\\npublic:\\n    int minPatches(vector<int> &nums, int n) {\\n        int res = 0;\\n        long long curMax = 1;\\n        int idx = 0;\\n        while (curMax <= n) {\\n            if (idx<nums.size() && curMax >= nums[idx])\\n                curMax = curMax + nums[idx++];\\n            else {\\n                res++;\\n                curMax += curMax;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1529560,
                "title": "c-intutive-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long reach = 0;\\n        int count = 0;\\n        int i = 0;\\n        while(reach < n){\\n            if(i >= nums.size()){\\n                reach += reach+1;\\n                count++;\\n            }else if(i < nums.size() and nums[i] <= (reach+1)){\\n                reach += nums[i];\\n                i++;\\n            }else{\\n                count++;\\n                reach += reach+1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long reach = 0;\\n        int count = 0;\\n        int i = 0;\\n        while(reach < n){\\n            if(i >= nums.size()){\\n                reach += reach+1;\\n                count++;\\n            }else if(i < nums.size() and nums[i] <= (reach+1)){\\n                reach += nums[i];\\n                i++;\\n            }else{\\n                count++;\\n                reach += reach+1;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434350,
                "title": "greedy-c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        \\n        int m = nums.size();\\n        int i = 0;\\n        int ans =0;\\n        long long temp = 0;\\n        while(temp<n)\\n        {   \\n       \\n            if(i<m)\\n            {\\n              if(nums[i]-temp>1)\\n              {\\n                ans++;\\n                temp = temp + temp + 1;\\n              }\\n              else\\n              {\\n                temp = temp + nums[i];\\n                i++;\\n              }\\n            }\\n            else\\n            {\\n                 ans++;\\n                temp = temp + temp + 1;\\n            }\\n            \\n        }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        \\n        int m = nums.size();\\n        int i = 0;\\n        int ans =0;\\n        long long temp = 0;\\n        while(temp<n)\\n        {   \\n       \\n            if(i<m)\\n            {\\n              if(nums[i]-temp>1)\\n              {\\n                ans++;\\n                temp = temp + temp + 1;\\n              }\\n              else\\n              {\\n                temp = temp + nums[i];\\n                i++;\\n              }\\n            }\\n            else\\n            {\\n                 ans++;\\n                temp = temp + temp + 1;\\n            }\\n            \\n        }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1434337,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        int len = nums.size();\\n        \\n        int sum = 0;\\n        int patch = 0;\\n        int i =0;\\n        while(sum<n){\\n            if(i != len && nums[i] <= sum + 1){\\n                sum += nums[i];\\n                i++;\\n            }else{\\n                patch++;\\n                if( sum > INT_MAX/2){\\n                    sum = INT_MAX;\\n                }else{\\n                    sum = 2 * sum + 1;\\n                }\\n            }\\n        }\\n        return patch;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        int len = nums.size();\\n        \\n        int sum = 0;\\n        int patch = 0;\\n        int i =0;\\n        while(sum<n){\\n            if(i != len && nums[i] <= sum + 1){\\n                sum += nums[i];\\n                i++;\\n            }else{\\n                patch++;\\n                if( sum > INT_MAX/2){\\n                    sum = INT_MAX;\\n                }else{\\n                    sum = 2 * sum + 1;\\n                }\\n            }\\n        }\\n        return patch;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1433987,
                "title": "javascript-greedy-103ms",
                "content": "```\\nconst minPatches = (a, n) => {\\n    let m = a.length, miss = 1, res = 0, i = 0;\\n    while (miss <= n) {\\n        if (i < m && a[i] <= miss) {\\n            miss += a[i];\\n            i++;\\n        } else {\\n            miss *= 2;\\n            res++;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\nconst minPatches = (a, n) => {\\n    let m = a.length, miss = 1, res = 0, i = 0;\\n    while (miss <= n) {\\n        if (i < m && a[i] <= miss) {\\n            miss += a[i];\\n            i++;\\n        } else {\\n            miss *= 2;\\n            res++;\\n        }\\n    }\\n    return res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1433706,
                "title": "patching-array-simple-java-solution",
                "content": "```\\n//if we patch or add with sum then we get till 2*sum so we add sum+1 to get  upto 2*sum+1 \\n//we add only when the given number in array is greater than the number to be added .\\n\\n\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n       long patch=1,sum=0;\\n        int ans=0,i=0;\\n        int l=nums.length;\\n        while(sum<n){\\n           while(i<l && patch>=nums[i]){\\n               sum = sum+nums[i++];\\n           }\\n            if(sum<patch){   //if number to be added is smaller then current sum then no need of adding.\\n                sum = sum+patch;       // here patching is done and then sum get updated.\\n               ans++;\\n\\t\\t\\t   }\\n             patch = sum+1;\\n            \\n            \\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minPatches(int[] nums, int n) {\\n       long patch=1,sum=0;\\n        int ans=0,i=0;\\n        int l=nums.length;\\n        while(sum<n){\\n           while(i<l && patch>=nums[i]){\\n               sum = sum+nums[i++];\\n           }",
                "codeTag": "Java"
            },
            {
                "id": 1433694,
                "title": "javascript-explained-solution",
                "content": "```\\n// time complexity: \\n// while loop is - o(n) beacuse we can potentially get to n with nums array full of ones and we will pass on each of them\\n// in some cases it will hit o(logn) if the nums array is pretty empty\\nvar minPatches = function(nums, n) {\\n    // nums is sorted so we don\\'t have to sort it\\n    let index = 0;\\n    let sumCanCreate = 0;\\n    let patchCount = 0;\\n    while(sumCanCreate < n) {\\n        // if we can\\'t create nums[index] or we at the end of nums and can\\'t create n.\\n        // we can create nums[index] only if it is lower or equal to sumCanCreate+1.\\n        if(sumCanCreate+1 < nums[index] || (index >= nums.length && sumCanCreate+1 < n)) {\\n            patchCount++;\\n            // because we \"patch\" the next number in the sequence.\\n            sumCanCreate += (sumCanCreate+1);\\n        // if we can create nums[index].\\n        } else {\\n            // we can create anything from current sumCanCreate to (sumCanCreate + nums[index]).\\n            sumCanCreate += nums[index];\\n            index++;\\n        }\\n    }\\n    return patchCount;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// time complexity: \\n// while loop is - o(n) beacuse we can potentially get to n with nums array full of ones and we will pass on each of them\\n// in some cases it will hit o(logn) if the nums array is pretty empty\\nvar minPatches = function(nums, n) {\\n    // nums is sorted so we don\\'t have to sort it\\n    let index = 0;\\n    let sumCanCreate = 0;\\n    let patchCount = 0;\\n    while(sumCanCreate < n) {\\n        // if we can\\'t create nums[index] or we at the end of nums and can\\'t create n.\\n        // we can create nums[index] only if it is lower or equal to sumCanCreate+1.\\n        if(sumCanCreate+1 < nums[index] || (index >= nums.length && sumCanCreate+1 < n)) {\\n            patchCount++;\\n            // because we \"patch\" the next number in the sequence.\\n            sumCanCreate += (sumCanCreate+1);\\n        // if we can create nums[index].\\n        } else {\\n            // we can create anything from current sumCanCreate to (sumCanCreate + nums[index]).\\n            sumCanCreate += nums[index];\\n            index++;\\n        }\\n    }\\n    return patchCount;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1433116,
                "title": "simple-easy-to-understand-java-solution",
                "content": "```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        int i=0; \\n        long reach = 0;\\n        int count = 0;\\n        while(reach<n){\\n            if(i>nums.length-1)\\n            {\\n                reach+= reach+1;\\n                count++;\\n            }\\n            else if(i<nums.length && nums[i]<=reach+1){\\n                reach+=nums[i];\\n                i++;\\n            }\\n            else\\n            {\\n                reach+=reach+1;\\n                count++;\\n            }\\n        }\\n        return count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minPatches(int[] nums, int n) {\\n        int i=0; \\n        long reach = 0;\\n        int count = 0;\\n        while(reach<n){\\n            if(i>nums.length-1)\\n            {\\n                reach+= reach+1;\\n                count++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1433100,
                "title": "c-simple-intuitive-o-n-solution-explained-beats-95",
                "content": "**Thought Process**\\nLet us first think about how we would create numbers [1..20] if we had an empty vector to begin with.\\n\\n* Let\\'s start off with the empty subset.\\n* We need the number 1 to cover 1, hence we add it.\\n* We need the number 2 to cover 2, hence we add it. We are now covering {1, 2, 3}.\\n* Now we add 4 to cover {1, 2, 3, 4, 5, 6, 7}.\\n* Now we add 8 to cover {1..15}\\n* Finally add 16 to cover {1..31}.\\n\\nDo you notice the pattern? At every instance we had a current cover, and we added the number just after the maximum number covered. More formally if we are covering [1..n], then we should add n+1 to cover all numbers from [1..2*n+1]. This is the best we can do.\\n\\nFor the given problem, we have some numbers given to us to aid us. The logic remains the same, the given numbers allow us to skip addition of few numbers.\\n\\nCode:\\n```\\nint minPatches(vector<int>& nums, int num) {\\n\\t// Stores the current number n, such that we can form all numbers [1..n] using the current subset.\\n\\tlong long int cap = 0;\\n\\tint i=0;\\n\\n\\t// You can\\'t include numbers which are > num to build [1..n], hence we work on a prefix of the array.\\n\\tfor (i; i<nums.size(); i++) {\\n\\t\\tif (nums[i] > num) break;\\n\\t}\\n\\n\\tint n = i-1;\\n\\ti = 0;\\n\\n\\tint ans = 0;\\n\\n\\twhile (i<=n && cap < num) {\\n\\t\\t/*\\n\\t\\tOn every iteration, we have some subset of numbers currently with us. We can form all numbers [1..cap].\\n\\t\\tCheck if there are numbers in the range [cap+1, nums[i]-1]. If yes, that means we need to add a number.\\n\\t\\t*/\\n\\t\\twhile (cap+1 < nums[i]) {\\n\\t\\t\\t// Adding a number, increases the total number of patches.\\n\\t\\t\\tans++;\\n\\n\\t\\t\\t// If you can currently form all {1..cap} by adding the number cap+1, you can form all number {1..2*cap+1}.\\n\\t\\t\\t// This is the best you could possible do.\\n\\t\\t\\tcap = 2*cap + 1;\\n\\t\\t}\\n\\n\\t\\t// Now use the nums[i] to further increase the cap size free of charge.\\n\\t\\tcap += nums[i];\\n\\t\\ti++;\\n\\t}\\n\\n\\t// It is possible that we have reached the end of (usable) numbers, and still not reached the desired cap.\\n\\t// We must add more numbers.\\n\\t// Not that we did delete numbers at the beginning, but those were unusuble (> num) anyways.\\n\\twhile (cap < num) {\\n\\t\\tans++;\\n\\t\\tcap = 2*cap + 1;\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minPatches(vector<int>& nums, int num) {\\n\\t// Stores the current number n, such that we can form all numbers [1..n] using the current subset.\\n\\tlong long int cap = 0;\\n\\tint i=0;\\n\\n\\t// You can\\'t include numbers which are > num to build [1..n], hence we work on a prefix of the array.\\n\\tfor (i; i<nums.size(); i++) {\\n\\t\\tif (nums[i] > num) break;\\n\\t}\\n\\n\\tint n = i-1;\\n\\ti = 0;\\n\\n\\tint ans = 0;\\n\\n\\twhile (i<=n && cap < num) {\\n\\t\\t/*\\n\\t\\tOn every iteration, we have some subset of numbers currently with us. We can form all numbers [1..cap].\\n\\t\\tCheck if there are numbers in the range [cap+1, nums[i]-1]. If yes, that means we need to add a number.\\n\\t\\t*/\\n\\t\\twhile (cap+1 < nums[i]) {\\n\\t\\t\\t// Adding a number, increases the total number of patches.\\n\\t\\t\\tans++;\\n\\n\\t\\t\\t// If you can currently form all {1..cap} by adding the number cap+1, you can form all number {1..2*cap+1}.\\n\\t\\t\\t// This is the best you could possible do.\\n\\t\\t\\tcap = 2*cap + 1;\\n\\t\\t}\\n\\n\\t\\t// Now use the nums[i] to further increase the cap size free of charge.\\n\\t\\tcap += nums[i];\\n\\t\\ti++;\\n\\t}\\n\\n\\t// It is possible that we have reached the end of (usable) numbers, and still not reached the desired cap.\\n\\t// We must add more numbers.\\n\\t// Not that we did delete numbers at the beginning, but those were unusuble (> num) anyways.\\n\\twhile (cap < num) {\\n\\t\\tans++;\\n\\t\\tcap = 2*cap + 1;\\n\\t}\\n\\n\\treturn ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1432934,
                "title": "c-intelligent-idea",
                "content": "To cover the interval `[1,n]`, we use `miss` to denote the *minimum number we cannot cover*, that is, we can represent the interval `[1,miss)`, now for a new `num`, there are two cases:\\n1. `num>miss`, we need to add the number `miss` by the definition of `miss`\\n2. `num<=miss`, now we can extend the interval to `[1, miss+num)`.\\nInitially `miss` is set as `1`.\\n\\nfor example, `nums=[1,5,10]`, `n=20`, the algorithm goes as follows:\\n1. `i=0`, since `nums[0]=1<=miss`, `miss= miss +nums[0]=2`\\n2. `i=1`, since `nums[1]=5>miss`, 2 cannot be represented, so we need add 2 to the nums, now we can update `miss=miss + miss=4`, where the second miss represents the number we added to the nums\\n3. `i=1`, since `nums[1]=5>miss=4`, we need add 4 again, and we update the miss as `miss = miss + miss = 8`\\n4.  `i=1`, since `nums[1]=5<=miss=8`, `miss= miss +nums[1]=13`\\n5.  `i=2`, since `nums[2]=10<=miss=13`, `miss= miss +nums[1]=23`\\nNote that now `miss>20`, so we can end our algorithm. The code is given as follows, the result denotes how many numbers we need to add the `nums`.\\n\\n```\\nint minPatches(vector<int>& nums, int n) {\\n    long miss = 1, result = 0;\\n    int i = 0;\\n    while (miss <= n){\\n        if (i < nums.size() && nums[i] <= miss){\\n            miss += nums[i++];\\n        }else{\\n            miss += miss;\\n            result++;\\n        }\\n    }\\n    return result;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minPatches(vector<int>& nums, int n) {\\n    long miss = 1, result = 0;\\n    int i = 0;\\n    while (miss <= n){\\n        if (i < nums.size() && nums[i] <= miss){\\n            miss += nums[i++];\\n        }else{\\n            miss += miss;\\n            result++;\\n        }\\n    }\\n    return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1432774,
                "title": "kotlin-simple-short-solution",
                "content": "```\\nclass Solution {\\n    fun minPatches(nums: IntArray, n: Int): Int {\\n        var currentMax = 0L\\n        var currentNumIndex = 0\\n        var res = 0\\n        while (currentMax < n) {\\n            if (currentNumIndex < nums.size && nums[currentNumIndex] <= currentMax + 1) {\\n                currentMax += nums[currentNumIndex]\\n                ++currentNumIndex\\n            } else {\\n                currentMax += currentMax + 1 \\n                ++res\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minPatches(nums: IntArray, n: Int): Int {\\n        var currentMax = 0L\\n        var currentNumIndex = 0\\n        var res = 0\\n        while (currentMax < n) {\\n            if (currentNumIndex < nums.size && nums[currentNumIndex] <= currentMax + 1) {\\n                currentMax += nums[currentNumIndex]\\n                ++currentNumIndex\\n            } else {\\n                currentMax += currentMax + 1 \\n                ++res\\n            }\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432712,
                "title": "python-greedy",
                "content": "```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        # assume that we have an array covers from 0 to n\\n        # if new value x is less than or equel to n, then we can create combinations from 0 to n+x\\n        # as we can add x to the previous formed combination\\n        # otherwise, we add n+1 to the num so that we can go further        \\n        curr_end = 0\\n        res = 0\\n        curr = 0\\n        while (curr_end < n):\\n            if curr >= len(nums) or nums[curr] > curr_end + 1: # cant add anything from the original list\\n                curr_end += curr_end + 1\\n                res += 1\\n            else:\\n                curr_end += nums[curr]\\n                curr += 1\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        # assume that we have an array covers from 0 to n\\n        # if new value x is less than or equel to n, then we can create combinations from 0 to n+x\\n        # as we can add x to the previous formed combination\\n        # otherwise, we add n+1 to the num so that we can go further        \\n        curr_end = 0\\n        res = 0\\n        curr = 0\\n        while (curr_end < n):\\n            if curr >= len(nums) or nums[curr] > curr_end + 1: # cant add anything from the original list\\n                curr_end += curr_end + 1\\n                res += 1\\n            else:\\n                curr_end += nums[curr]\\n                curr += 1\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432607,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long int s=nums.size();\\n        long long int i=0,v=0,p=0;\\n        while(v<n && i<s)\\n        {\\n           if(v+1<nums[i]) {p++; v+=v+1;} \\n            else v+=nums[i++];\\n        }\\n        while(v<n)\\n        {\\n            v+=v+1; p++;\\n        }\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long int s=nums.size();\\n        long long int i=0,v=0,p=0;\\n        while(v<n && i<s)\\n        {\\n           if(v+1<nums[i]) {p++; v+=v+1;} \\n            else v+=nums[i++];\\n        }\\n        while(v<n)\\n        {\\n            v+=v+1; p++;\\n        }\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1432474,
                "title": "python-easy-to-understand-solution",
                "content": "```\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        prevNum=0\\n        patches=0\\n        i=0\\n        while i<len(nums):\\n            num=nums[i]\\n            if(prevNum>=n): return patches\\n            if(num<=prevNum+1):\\n                prevNum=prevNum+num\\n                i+=1\\n            else:\\n                patches+=1\\n                prevNum=prevNum+prevNum+1\\n        if(prevNum<n):\\n            while prevNum<n:\\n                patches+=1\\n                prevNum+=prevNum+1\\n        return patches",
                "solutionTags": [],
                "code": "```\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        prevNum=0\\n        patches=0\\n        i=0\\n        while i<len(nums):\\n            num=nums[i]\\n            if(prevNum>=n): return patches\\n            if(num<=prevNum+1):\\n                prevNum=prevNum+num\\n                i+=1\\n            else:\\n                patches+=1\\n                prevNum=prevNum+prevNum+1\\n        if(prevNum<n):\\n            while prevNum<n:\\n                patches+=1\\n                prevNum+=prevNum+1\\n        return patches",
                "codeTag": "Python3"
            },
            {
                "id": 1432390,
                "title": "python-3-easy-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef minPatches(self, nums: List[int], n: int) -> int:\\n\\t\\t\\tans, total = 0, 0\\n\\t\\t\\tnum_idx = 0\\n\\t\\t\\twhile total < n:\\n\\t\\t\\t\\tif num_idx < len(nums):\\n\\t\\t\\t\\t\\tif total < nums[num_idx] - 1:\\n\\t\\t\\t\\t\\t\\ttotal = total * 2 + 1\\n\\t\\t\\t\\t\\t\\tans += 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ttotal += nums[num_idx]\\n\\t\\t\\t\\t\\t\\tnum_idx += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ttotal = total * 2 + 1\\n\\t\\t\\t\\t\\tans += 1\\n\\t\\t\\treturn ans",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tclass Solution:\\n\\t\\tdef minPatches(self, nums: List[int], n: int) -> int:\\n\\t\\t\\tans, total = 0, 0\\n\\t\\t\\tnum_idx = 0\\n\\t\\t\\twhile total < n:\\n\\t\\t\\t\\tif num_idx < len(nums):\\n\\t\\t\\t\\t\\tif total < nums[num_idx] - 1:\\n\\t\\t\\t\\t\\t\\ttotal = total * 2 + 1\\n\\t\\t\\t\\t\\t\\tans += 1\\n\\t\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\t\\ttotal += nums[num_idx]\\n\\t\\t\\t\\t\\t\\tnum_idx += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ttotal = total * 2 + 1\\n\\t\\t\\t\\t\\tans += 1\\n\\t\\t\\treturn ans",
                "codeTag": "Java"
            },
            {
                "id": 1307402,
                "title": "java-100-0ms-solution",
                "content": "\\tclass Solution {\\n\\t\\tpublic int minPatches(int[] nums, int n) {\\n\\t\\t\\tint patches=0,ind=0;\\n\\t\\t\\tlong coveredTill=1l;\\n\\t\\t\\twhile(coveredTill<=n){\\n\\t\\t\\t\\tif(ind<nums.length && nums[ind]<=coveredTill){\\n\\t\\t\\t\\t\\tcoveredTill+=nums[ind++];\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tpatches++;\\n\\t\\t\\t\\t\\tcoveredTill+=coveredTill;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn patches;\\n\\t\\t}\\n\\t}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic int minPatches(int[] nums, int n) {\\n\\t\\t\\tint patches=0,ind=0;\\n\\t\\t\\tlong coveredTill=1l;\\n\\t\\t\\twhile(coveredTill<=n){\\n\\t\\t\\t\\tif(ind<nums.length && nums[ind]<=coveredTill){\\n\\t\\t\\t\\t\\tcoveredTill+=nums[ind++];\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1297714,
                "title": "c-solution-detailed-explanation-greedy",
                "content": "Let\\'s start from an example, the given vector input = {1, 4, 6, 10}, n = 20;\\n\\nSince we are aimed to cover all the numbers in range [1, 20], let\\'s consider the elements one by one.\\nWe may create an aiding vector<int> aid, which is used to contain all the elements that have been covered SO FAR.\\nOf course, this \"aid\" is empty from the begining. What\\'s more, use a counter to count how many extra elements should we provide, i.e. the output. \\n\\nFirstly, we expect the first element \"1\" to be added into the aid. After check the input vector, we find we have an \"1\", so just use it add it into our \"aid\" vector;\\naid = {1} so far, count = 0\\n\\nNext, we expect \"2\" to be added. Looking at the input vector, since the first element has already been used, we check from the second element, which is \"4\". Apparently, we need to patch one extra element to get the expected \"2\". \\nNow the problem comes, should we directly give a \"2\" or we may give an \"1\" since 1+1 also yeilds \"2\". The answer is that both ways work, HOWEVER, \"2\" is a better choice since 1+2 gives 3, adding a \"2\" expand aid into {1,2,3} while adding an \"1\" just turns aid = {1,2}. So we patch a \"2\", and the count++; BTW, this this can be though as \"greedy strategy\"\\naid = {1,2,3} so far, count =1\\n\\nAfter that, we expect \"4\". Checking input, we find a 4 and so there\\'s no need for extra patching. Add 4 into the aid would expand it into {1, 2, 3 ,4 ,1+4, 2+4, 3+4}. You may have notice that\\n\\n#### adding an element x would incrase the size of the aid vector by x. \\n\\naid = {1,2,3,4,5,6,7} so far, count = 1\\n\\nThen we expect 8, searching the input vector, the next element not used is \"6\", since we may use the \"2\" in aid vector to add 6 and get 8, so it meets our needs. What\\'s more, as said before, the \"6\" would expand our aid vector into {1, 2, 3, 4, 5, 6, 7, 2+6, 3+6, 4+6, 5+6, 6+6, 7+6}.\\naid = {1,2,3,4,5,6,7,8,9,10,11,12,13} by now, count = 1\\n\\nThe next expected element is 14, and the next element provided by input is \"10\", again, this would turn our aid vector into {1,2,3,....,23} and we notice that 23 > 20, which means the task is completed.\\n\\n\\nLooking back the whole process, we could easily draw two conclucions:\\n#### 1. We only need to patch when the next element that the input vector offers is bigger that what we expect. When this circumstance occurs, just patch the desired element and add it into aid vector.\\n#### 2. Once we add an element x to aid vector, no matter whether it\\'s provided by input vector or patching, the aid vector\\'s size increase x, which would turn the next \"expected value\" into \"current expected value + x\". When the next expected value > n, the task is finished.\\n\\nActually, why do we need an aid vector? We can just use the \"expected value\" to indicate the aid vector we have, since aid vector = [1, expected value - 1]. This yeilds my final result:\\n\\n```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        int index = 0;\\n        int count = 0;\\n        if(nums[0]>1){\\n            ++count;   \\n        }\\n        else{\\n            ++index;\\n        }\\n        long long expect = 2;\\n        while(expect <= n){\\n            if(index>=nums.size() || nums[index]>expect){\\n                // need to add this number\\n                ++count;\\n                // expect += expect -> expect<<1\\n                expect = expect<<1;  \\n            }\\n            else{\\n                // expand the range\\n                expect += nums[index];\\n                ++index;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        int index = 0;\\n        int count = 0;\\n        if(nums[0]>1){\\n            ++count;   \\n        }\\n        else{\\n            ++index;\\n        }\\n        long long expect = 2;\\n        while(expect <= n){\\n            if(index>=nums.size() || nums[index]>expect){\\n                // need to add this number\\n                ++count;\\n                // expect += expect -> expect<<1\\n                expect = expect<<1;  \\n            }\\n            else{\\n                // expand the range\\n                expect += nums[index];\\n                ++index;\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1196758,
                "title": "python3-greedy",
                "content": "\\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        ans = prefix = k = 0 \\n        while prefix < n: \\n            if k < len(nums) and nums[k] <= prefix + 1: \\n                prefix += nums[k]\\n                k += 1\\n            else: \\n                ans += 1\\n                prefix += prefix + 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        ans = prefix = k = 0 \\n        while prefix < n: \\n            if k < len(nums) and nums[k] <= prefix + 1: \\n                prefix += nums[k]\\n                k += 1\\n            else: \\n                ans += 1\\n                prefix += prefix + 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1154103,
                "title": "quick-solution",
                "content": "```\\npublic int minPatches(int[] nums, int n) {\\n\\tint miss = 1, result = 0, i = 0;\\n\\t// \\'miss\\' might overflow to negative number\\n\\twhile (miss <= n && miss > 0) {\\n\\t\\tif (i < nums.length && nums[i] <= miss) {\\n\\t\\t\\tmiss += nums[i++];\\n\\t\\t} else {\\n\\t\\t\\tmiss += miss;\\n\\t\\t\\tresult++;\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minPatches(int[] nums, int n) {\\n\\tint miss = 1, result = 0, i = 0;\\n\\t// \\'miss\\' might overflow to negative number\\n\\twhile (miss <= n && miss > 0) {\\n\\t\\tif (i < nums.length && nums[i] <= miss) {\\n\\t\\t\\tmiss += nums[i++];\\n\\t\\t} else {\\n\\t\\t\\tmiss += miss;\\n\\t\\t\\tresult++;\\n\\t\\t}\\n\\t}\\n\\n\\treturn result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1082784,
                "title": "python3-greedy-solution",
                "content": "Time complexity: O(m+logn), where m=len(nums)\\nSpace complexity: O(1)\\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        \\n        res = 0\\n        \\n        # initial coverage\\n        right = 0 \\n        \\n        for c in nums:\\n            \\n            # current coverage [1,right], but (right+1) not in nums\\n            # then must add a num(<=right+1) and extend coverage to [1, right+num]\\n            # greedy: add (right+1) and extend coverage to [1, 2*right+1]\\n            while c > right+1: \\n                res += 1\\n                right += right+1\\n                if right >= n:\\n                    return res\\n            \\n            # c(<=right+1) in nums, extend coverage to [1, right+c]\\n            right += c \\n            \\n            if right >= n:\\n                return res\\n        \\n        # (right+1) never in nums any more\\n        # greedy: add (right+1) and extend coverage to [1, 2*right+1]\\n        # loop times < logn\\n        while right < n:\\n            res += 1\\n            right += right+1\\n            \\n        return res\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        \\n        res = 0\\n        \\n        # initial coverage\\n        right = 0 \\n        \\n        for c in nums:\\n            \\n            # current coverage [1,right], but (right+1) not in nums\\n            # then must add a num(<=right+1) and extend coverage to [1, right+num]\\n            # greedy: add (right+1) and extend coverage to [1, 2*right+1]\\n            while c > right+1: \\n                res += 1\\n                right += right+1\\n                if right >= n:\\n                    return res\\n            \\n            # c(<=right+1) in nums, extend coverage to [1, right+c]\\n            right += c \\n            \\n            if right >= n:\\n                return res\\n        \\n        # (right+1) never in nums any more\\n        # greedy: add (right+1) and extend coverage to [1, 2*right+1]\\n        # loop times < logn\\n        while right < n:\\n            res += 1\\n            right += right+1\\n            \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 910092,
                "title": "c-nlogn-solution",
                "content": "```\\nclass Solution {\\npublic:\\n\\n/*\\n\\tObservations:\\n\\tIf you can have possible sum range  [1,K],\\n\\t1>> you can extend the range the most by adding K+1 to the set making the resulting range to be [1,2*K+1].\\n\\t2>> then to extend the range using an int A, we need to have K>=A+1 to ensure that the range remains continuous.\\n*/\\n    int minPatches(vector<int>& nums, int n) {\\n        if(n==0)\\n            return 0;\\n        int ans = 0;\\n        long curr = 0;\\n        for(int& u: nums)\\n        {\\n            if(curr>=n)\\n                break;\\n            while(curr+1<u and curr<n)\\n            {\\n                ans++;\\n                curr += curr + 1;\\n            }\\n            curr += u;\\n        }\\n        while(curr<n)\\n        {\\n            curr += curr+1;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n/*\\n\\tObservations:\\n\\tIf you can have possible sum range  [1,K],\\n\\t1>> you can extend the range the most by adding K+1 to the set making the resulting range to be [1,2*K+1].\\n\\t2>> then to extend the range using an int A, we need to have K>=A+1 to ensure that the range remains continuous.\\n*/\\n    int minPatches(vector<int>& nums, int n) {\\n        if(n==0)\\n            return 0;\\n        int ans = 0;\\n        long curr = 0;\\n        for(int& u: nums)\\n        {\\n            if(curr>=n)\\n                break;\\n            while(curr+1<u and curr<n)\\n            {\\n                ans++;\\n                curr += curr + 1;\\n            }\\n            curr += u;\\n        }\\n        while(curr<n)\\n        {\\n            curr += curr+1;\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 754990,
                "title": "go-greedy",
                "content": "```\\nfunc minPatches(nums []int, n int) int {\\n    l := len(nums)\\n    max_val := 0\\n   \\n    res := 0\\n    \\n    i := 0\\n    for max_val < n {\\n        if i < l && nums[i] <= max_val + 1 {\\n            max_val += nums[i]\\n            i++\\n        } else {\\n            max_val += max_val + 1\\n            res++\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc minPatches(nums []int, n int) int {\\n    l := len(nums)\\n    max_val := 0\\n   \\n    res := 0\\n    \\n    i := 0\\n    for max_val < n {\\n        if i < l && nums[i] <= max_val + 1 {\\n            max_val += nums[i]\\n            i++\\n        } else {\\n            max_val += max_val + 1\\n            res++\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 555042,
                "title": "short-c-solution",
                "content": "```\\n    public class Solution\\n    {\\n        public int MinPatches(int[] nums, int n)\\n        {\\n            checked\\n            {\\n                (long from, long to) range = (1, 1);\\n                int res = 0;\\n                int idx = 0;\\n\\n                while (n >= range.to)\\n                {\\n                    if (idx < nums.Length && nums[idx] <= range.to)\\n                    {\\n                        range = (range.from, range.to + nums[idx]);\\n                        idx++;\\n                    }\\n                    else\\n                    {\\n                        res++;\\n                        range = (range.from, 2 * range.to);\\n                    }\\n                }\\n\\n                return res;\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public class Solution\\n    {\\n        public int MinPatches(int[] nums, int n)\\n        {\\n            checked\\n            {\\n                (long from, long to) range = (1, 1);\\n                int res = 0;\\n                int idx = 0;\\n\\n                while (n >= range.to)\\n                {\\n                    if (idx < nums.Length && nums[idx] <= range.to)\\n                    {\\n                        range = (range.from, range.to + nums[idx]);\\n                        idx++;\\n                    }\\n                    else\\n                    {\\n                        res++;\\n                        range = (range.from, 2 * range.to);\\n                    }\\n                }\\n\\n                return res;\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 448073,
                "title": "python-covered-area",
                "content": "assuming this is the covered area [1,2,3,4,5,6]\\nthen I say 6 is the max it can covered, **covered == 6**\\n\\nif I wanna proceed imma gonna add 7\\nand cover 7 more units by using the same sum to cover [1, ... , 6] then add 7\\n\\nmy coverage is now\\n[1,2,3,4,5,6, 7, ... , 6+7 = 13]\\nit costs me one **step** to add the 7 but it expanded efficiently my coverage not leaving any gaps\\n\\nnow some numbers (from the array) are free to add, so using them as much as i can, (problem statement looking for a min)\\n\\n\\n1. if the coverage hits nums[i] -1 exactly then we should add nums[i]\\n1. if the coverage hits larger than nums[i] -1  then we still should add nums[i] (for free)\\n1. if the coverage hits less than nums[i] -1  then we **expand** the coverage to cover nums[i]-1 at least, and still should add nums[i] (its garanteed nums[i] has not been used)\\n\\n\\n```\\nclass Solution(object):\\n    def minPatches(self, nums, n):\\n        covered = 0\\n        steps = 0\\n        i = 0\\n        while(covered < n and i < len(nums)):\\n            num = nums[i]\\n            while(covered < n and not(covered >= num - 1)):\\n                steps +=1\\n                covered += covered + 1\\n            covered += num\\n            i += 1\\n        while( covered < n):\\n            steps +=1\\n            covered += covered + 1\\n\\n        return steps\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minPatches(self, nums, n):\\n        covered = 0\\n        steps = 0\\n        i = 0\\n        while(covered < n and i < len(nums)):\\n            num = nums[i]\\n            while(covered < n and not(covered >= num - 1)):\\n                steps +=1\\n                covered += covered + 1\\n            covered += num\\n            i += 1\\n        while( covered < n):\\n            steps +=1\\n            covered += covered + 1\\n\\n        return steps\\n```",
                "codeTag": "Java"
            },
            {
                "id": 424433,
                "title": "simple-python3-faster-than-99-17-less-memory-than-100-with-clear-explanations",
                "content": "Let P denote a way of patching the array, which spans from 1 to N and includes the least number of patches possible.\\nLet us assume that we are on track with P at an index i. That is, all the patchings that we have made until the index i are consistent with the patchings until the index i, in the way P.\\n\\nLet Span be the maximum number upto which we can span, with the elements of the array and the patchings made until the index i. \\n\\n1) Span  >=  nums[i] - 1\\n In this case, including nums[i] to our span would be a correct approach\\n This is true because, so far we are on the right track, and picking up nums[i] would ensure that we are on a right track, as it is something that comes our way. Need not patch.\\n \\n 2) Span < nums[i] - 1\\n  In this case, we have to include Span + 1 in our span, since we are on a right track, which cannot span Span + 1,  and to proceed further we have to include Span + 1, as nums[i] alone does not help span Span + 1.\\n  Hence Span = Span + (Span + 1)\\n  We add 1 to the number of patchings\\n  \\nWe repeat this process till either n is spanned or 1) is satisfied for the given index 1 \\n\\nIf by the end of the last index of the array, we are still unable to span n, we, set n as the new target in place of a nums[i] and continue.\\nClearly, at the starting of the array we are on track with a valid minimal solution, focusing on spanning 1. \\nTherefore, by induction our algorithm works and returns the minimum number of patchings required\\n\\n```class Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        if nums == []:\\n            Span, Min = 1, 1\\n            while Span < n:\\n                Span = 2*Span + 1\\n                Min = Min + 1\\n            \\n            return Min    \\n        Min, Span, i = 0, 0, 0\\n        if nums[0] == 1:\\n            Span, i = 1, 1  \\n                \\n        while i < len(nums) and Span < n:\\n            if nums[i] > Span + 1:\\n                Span = 2*Span + 1\\n                Min = Min + 1\\n            else:\\n                Span = Span + nums[i]\\n                i = i + 1\\n        while Span < n:\\n            Span = 2*Span + 1\\n            Min = Min + 1\\n                \\n        return Min\\n",
                "solutionTags": [],
                "code": "Let P denote a way of patching the array, which spans from 1 to N and includes the least number of patches possible.\\nLet us assume that we are on track with P at an index i. That is, all the patchings that we have made until the index i are consistent with the patchings until the index i, in the way P.\\n\\nLet Span be the maximum number upto which we can span, with the elements of the array and the patchings made until the index i. \\n\\n1) Span  >=  nums[i] - 1\\n In this case, including nums[i] to our span would be a correct approach\\n This is true because, so far we are on the right track, and picking up nums[i] would ensure that we are on a right track, as it is something that comes our way. Need not patch.\\n \\n 2) Span < nums[i] - 1\\n  In this case, we have to include Span + 1 in our span, since we are on a right track, which cannot span Span + 1,  and to proceed further we have to include Span + 1, as nums[i] alone does not help span Span + 1.\\n  Hence Span = Span + (Span + 1)\\n  We add 1 to the number of patchings\\n  \\nWe repeat this process till either n is spanned or 1) is satisfied for the given index 1 \\n\\nIf by the end of the last index of the array, we are still unable to span n, we, set n as the new target in place of a nums[i] and continue.\\nClearly, at the starting of the array we are on track with a valid minimal solution, focusing on spanning 1. \\nTherefore, by induction our algorithm works and returns the minimum number of patchings required\\n\\n```class Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        if nums == []:\\n            Span, Min = 1, 1\\n            while Span < n:\\n                Span = 2*Span + 1\\n                Min = Min + 1\\n            \\n            return Min    \\n        Min, Span, i = 0, 0, 0\\n        if nums[0] == 1:\\n            Span, i = 1, 1  \\n                \\n        while i < len(nums) and Span < n:\\n            if nums[i] > Span + 1:\\n                Span = 2*Span + 1\\n                Min = Min + 1\\n            else:\\n                Span = Span + nums[i]\\n                i = i + 1\\n        while Span < n:\\n            Span = 2*Span + 1\\n            Min = Min + 1\\n                \\n        return Min\\n",
                "codeTag": "Java"
            },
            {
                "id": 345826,
                "title": "python-o-logn-time-o-1-space",
                "content": "This solution progresses through the sorted values of ```last``` in ```nums```. It operates with the invariant that every integer in [1, ```total```], where ```total``` is the sum of all values we have observed in nums or have patched in excluding ```last``` itself, can be formed with those values. Notice that this also maintains the invariant that every integer in [1, ```last - 1```] can be constructed, a corollary we will use. This is trivial in the base case of ```last = 1```, which is a value that must be patched in if it is not already present in nums.\\n\\nFrom this we can see that every integer in [1, ```last + total```] can be formed with ```last``` and its preceding values. Those values in [1, ```total```] are covered by the invariant and every integer ```total  + last - i```, where ```i <= total```, can be constructed by including every value then withholding the subset that would sum to ```i```. If ```total >= last```, every value in [1, ```last + total```] is covered.  If ```total < last```, by our corollary we can construct every value in [1, ```2 * last - 1```], an interval that encompasses [1, ```last + total```].\\n\\nTherefore, we know we are finished when ```n <= last + total```, and we would only patch in values when the next value is ```<= last + total```. We set ```last``` to the patched in value whenever we do so. Since last must at least double with every iteration, the time complexity is logarithmic with respect to n. \\n\\n\\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        patched = 0    \\n        last = total = i = 0\\n        \\n        while last + total < n:           \\n            if i < len(nums) and nums[i] <= last + total + 1:\\n                total += last\\n                last = nums[i]\\n                i += 1\\n                \\n            else:\\n                total += last\\n                last = total + 1\\n                patched += 1\\n\\n        return patched\\n```",
                "solutionTags": [],
                "code": "```last```\n```nums```\n```total```\n```total```\n```last```\n```last - 1```\n```last = 1```\n```last + total```\n```last```\n```total```\n```total  + last - i```\n```i <= total```\n```i```\n```total >= last```\n```last + total```\n```total < last```\n```2 * last - 1```\n```last + total```\n```n <= last + total```\n```<= last + total```\n```last```\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        patched = 0    \\n        last = total = i = 0\\n        \\n        while last + total < n:           \\n            if i < len(nums) and nums[i] <= last + total + 1:\\n                total += last\\n                last = nums[i]\\n                i += 1\\n                \\n            else:\\n                total += last\\n                last = total + 1\\n                patched += 1\\n\\n        return patched\\n```",
                "codeTag": "Java"
            },
            {
                "id": 186111,
                "title": "java-0ms-solution",
                "content": "The code explains itself.\n```\nclass Solution {\n    public int minPatches(int[] nums, int n) {\n        if (nums == null) return 0;\n\t\t\n\t\tlong sum = 0;\n        int cnt = 0;\n\t\tfor (int idx = 0; idx < nums.length || sum < n; idx ++) {\n\t\t\tlong limit = (idx < nums.length) ? Math.min(nums[idx] - 1, n) : n;\n\t\t\twhile (sum < limit) {\n\t\t\t\tsum += sum + 1;\n\t\t\t\tcnt ++;\n\t\t\t}\n\t\t\tif (idx < nums.length) sum += nums[idx];\n\t\t}\n        \n\t\treturn cnt;\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\nclass Solution {\n    public int minPatches(int[] nums, int n) {\n        if (nums == null) return 0;\n\t\t\n\t\tlong sum = 0;\n        int cnt = 0;\n\t\tfor (int idx = 0; idx < nums.length || sum < n; idx ++) {\n\t\t\tlong limit = (idx < nums.length) ? Math.min(nums[idx] - 1, n) : n;\n\t\t\twhile (sum < limit) {\n\t\t\t\tsum += sum + 1;\n\t\t\t\tcnt ++;\n\t\t\t}\n\t\t\tif (idx < nums.length) sum += nums[idx];\n\t\t}\n        \n\t\treturn cnt;\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 78493,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Patching Array** https://leetcode.com/problems/patching-array/\\n\\n**Algorithm**\\n1. curr_sum refers to the sum that can be accomplished sequentially so far.\\n2. next_sum = curr_sum+1. \\n3. Assume next_sum = 7. curr_sum =6. nums[index] = any number less than 7. We can simply pick nums[index] and that makes sure we have covered next_sum. Why? Because we have combinations of [1,2,3,4,5,6] already covered. lowest value of nums[index] will be 1. maximum value will be 7. Say nums[index] = 5, then adding that will increase curr_sum to 6+5 = 11 (7 = 5+2, 8 = 5+3, 9 = %+4)...\\n4. Now if nums[index] > next_sum, say it is 20. Then we need to add 7 as a patch. Now we can cover until 6 + 7 = 13.\\n\\n```\\nclass Solution(object):\\n    def minPatches(self, nums, n):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        index, curr_sum, next_sum = 0, 0, 0\\n        num_patches = 0\\n        while curr_sum < n:\\n            next_sum = curr_sum + 1\\n            # Add the next element in the nums array\\n            if index < len(nums) and nums[index] <= next_sum:\\n                curr_sum, index = curr_sum + nums[index], index + 1\\n            else:\\n                # Add the next_sum as the next patc\\n                num_patches = num_patches + 1\\n                curr_sum = curr_sum + next_sum\\n        return num_patches\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def minPatches(self, nums, n):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        index, curr_sum, next_sum = 0, 0, 0\\n        num_patches = 0\\n        while curr_sum < n:\\n            next_sum = curr_sum + 1\\n            # Add the next element in the nums array\\n            if index < len(nums) and nums[index] <= next_sum:\\n                curr_sum, index = curr_sum + nums[index], index + 1\\n            else:\\n                # Add the next_sum as the next patc\\n                num_patches = num_patches + 1\\n                curr_sum = curr_sum + next_sum\\n        return num_patches\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78504,
                "title": "share-my-explanation-and-code",
                "content": "Assume the upper bound we can not reach is miss, i.e the largest number we can reach is (miss-1), i.e we can already reach number among [1, miss-1] (both inclusive), what number should we patch to reach miss?\\nWe can patch any number among [1, miss] (both inclusive), but only patching the largest number can make sure we patch least count of numbers, because the by patching the largest number, we extend to the largest upper bound.\\nFor example currently the upper bound is miss, so we can already reach [1, miss-1], the after patching miss, the largest number we can reach is miss-1+miss, so then upper bound becomes miss + miss; \\n\\nFor more details, please read the comment in the code:\\n```java\\npublic class Solution {\\n    public int minPatches(int[] nums, int n) {\\n        int i = 0; //beginning index\\n        long miss = 1; //current upper bound\\n        int count = 0; //count of number patched\\n        \\n\\n        while(miss <= n){\\n            if(i == nums.length || (i < nums.length && nums[i] > miss)){\\n                //i == nums.length means there's no given number, so we can only patch a number\\n                //we want to reach nums[i], but currently we only reach miss-1\\n                //so we should patch miss to extend to the largest upper bound\\n                //after patching, we can reach miss-1+miss\\n                //so the upper bound should be miss += miss\\n                miss += miss;\\n                count++; \\n            }\\n            else if(i < nums.length && nums[i] <= miss){\\n                //we want to reach nums[i], but we already reach miss-1\\n                //so we can actually reach nums[i]+miss-1\\n                //so the upper bound should be nums[i]+miss\\n                miss += nums[i];\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\nThe code is not very concise, but the redundancy makes the code easier to understand.",
                "solutionTags": [],
                "code": "```java\\npublic class Solution {\\n    public int minPatches(int[] nums, int n) {\\n        int i = 0; //beginning index\\n        long miss = 1; //current upper bound\\n        int count = 0; //count of number patched\\n        \\n\\n        while(miss <= n){\\n            if(i == nums.length || (i < nums.length && nums[i] > miss)){\\n                //i == nums.length means there's no given number, so we can only patch a number\\n                //we want to reach nums[i], but currently we only reach miss-1\\n                //so we should patch miss to extend to the largest upper bound\\n                //after patching, we can reach miss-1+miss\\n                //so the upper bound should be miss += miss\\n                miss += miss;\\n                count++; \\n            }\\n            else if(i < nums.length && nums[i] <= miss){\\n                //we want to reach nums[i], but we already reach miss-1\\n                //so we can actually reach nums[i]+miss-1\\n                //so the upper bound should be nums[i]+miss\\n                miss += nums[i];\\n                i++;\\n            }\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 78513,
                "title": "a-simple-js-solution",
                "content": "    /**\\n     * @param {number[]} nums\\n     * @param {number} n\\n     * @return {number}\\n     */\\n    var minPatches = function(nums, n) {\\n        var sum = 0, patch = 0, i = 0, num = nums[0];\\n        \\n        while(sum < n){\\n            if(!num || sum + 1 < num){\\n                patch++;\\n                sum += sum + 1;\\n            }else if(num){\\n                sum += num;\\n                num = nums[++i];\\n            }\\n        }\\n        \\n        return patch;\\n    };",
                "solutionTags": [],
                "code": "    /**\\n     * @param {number[]} nums\\n     * @param {number} n\\n     * @return {number}\\n     */\\n    var minPatches = function(nums, n) {\\n        var sum = 0, patch = 0, i = 0, num = nums[0];\\n        \\n        while(sum < n){\\n            if(!num || sum + 1 < num){\\n                patch++;\\n                sum += sum + 1;\\n            }else if(num){\\n                sum += num;\\n                num = nums[++i];\\n            }\\n        }\\n        \\n        return patch;\\n    };",
                "codeTag": "Unknown"
            },
            {
                "id": 78508,
                "title": "my-1ms-java-solution",
                "content": "This is a solution that I came up with by myself. If this follows the same idea as yours, there's nothing to be surprised with, as the basic idea for the optimal solution should be unique in most leetcode problems. I tried out several special cases to finally get the high-level idea, and then this solution. \\n\\nnextToMaxSum: The next integer to the maximum value of the range that can all be covered up to now. In other words, with some added integers and the elements in array 'nums' we've already checked, nextToMaxSum stands for the first value we cannot reach.\\n\\nFor example, for nums=[1,1,2,9] and n=23. If we've checked 1,1,2, then 5 is the next integer to the current sum.\\n\\nNeedless to say, we'll have to add nextToMaxSum to the array, if it's not there yet. For example, we need to add 5 to the array in the example above. However, if nextToMaxSum is already in the array(If nums=[1,1,2,5]), then we don't need to add it.\\n\\nOnce nextToMaxSum is added to the array, the range almost doubles: Previously, it's (nextToMaxSum-1), but now, it's (nextToMaxSum-1+nextToMaxSum=2*nextToMaxSum-1). So the new value for nextToMaxSum should be 2*nextToMaxSum. Similarly, if we have an element x in array 'nums', then now the bound should be x+nextToMaxSum-1.\\n\\n    public class Solution {\\n        public int minPatches(int[] nums, int n) {\\n            int cnt;\\n            int patches = 0;\\n            long nextToMaxSum = 1;\\n            \\n            for(cnt = 0; cnt<nums.length && nextToMaxSum-1<n; ){\\n                if(nextToMaxSum < nums[ cnt ]){ \\n                    nextToMaxSum = nextToMaxSum << 1;\\n                    patches++;\\n                } else {\\n                    nextToMaxSum += nums[ cnt++ ];\\n                }\\n            }\\n            \\n            while(nextToMaxSum-1 < n){\\n                nextToMaxSum = nextToMaxSum << 1;\\n                patches++;\\n            }\\n            \\n            return patches;\\n        }\\n    }\\n\\nAs for the time complexity, since we need to iterate through array 'nums', it's at least O(nums.length). Also, we need to keep doubling nextToMaxSum from 1, until it exceeds n. Since n is an integer that has only 32 bits, the time complexity for this is a constant. So the total time complexity is O(nums.length+32)=O(nums.length)",
                "solutionTags": [],
                "code": "class Solution {\\n        public int minPatches(int[] nums, int n) {\\n            int cnt;\\n            int patches = 0;\\n            long nextToMaxSum = 1;\\n            \\n            for(cnt = 0; cnt<nums.length && nextToMaxSum-1<n; ){\\n                if(nextToMaxSum < nums[ cnt ]){ \\n                    nextToMaxSum = nextToMaxSum << 1;\\n                    patches++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 78516,
                "title": "share-my-4-ms-c-solution-with-explanation",
                "content": " If you can reach [1,n] ,then you patch n+1 ,you get [1,2n+1]. that's it\\n\\n    int minPatches(int* nums, int numsSize, int n)\\n    {\\n        int ret = 0,ptr = 0;\\n        unsigned int range = 0,limit = n;\\n        while(range < limit)\\n        {\\n            if(ptr == numsSize || range + 1 < nums[ptr])\\n                ret ++,range = (range << 1) | 1;\\n            else \\n                range += nums[ptr++];\\n        }\\n        return ret;\\n    }",
                "solutionTags": [],
                "code": " If you can reach [1,n] ,then you patch n+1 ,you get [1,2n+1]. that's it\\n\\n    int minPatches(int* nums, int numsSize, int n)\\n    {\\n        int ret = 0,ptr = 0;\\n        unsigned int range = 0,limit = n;\\n        while(range < limit)\\n        {\\n            if(ptr == numsSize || range + 1 < nums[ptr])\\n                ret ++,range = (range << 1) | 1;\\n            else \\n                range += nums[ptr++];\\n        }\\n        return ret;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 78520,
                "title": "8ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        int minPatches(vector<int>& nums, int n) {\\n            unsigned int farNum = 0;\\n            int idx = 0, padding = 0;\\n        \\n            while(farNum < n) {\\n                if( idx < nums.size() && nums[idx] <= farNum+1 ) {\\n                    farNum += nums[idx++];\\n                } else {\\n                    padding++;\\n                    farNum =  farNum*2+1;\\n                }\\n            }\\n            return padding;\\n        }\\n    };\\n    `",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int minPatches(vector<int>& nums, int n) {\\n            unsigned int farNum = 0;\\n            int idx = 0, padding = 0;\\n        \\n            while(farNum < n) {\\n                if( idx < nums.size() && nums[idx] <= farNum+1 ) {\\n                    farNum += nums[idx++];\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 78521,
                "title": "c-ac-solution",
                "content": "    class Solution {\\n    public:\\n        int minPatches(vector<int>& nums, int n) {\\n            int ret=0,i=0;\\n            long k=1;\\n            while(k<=n){\\n                if(i==nums.size()||nums[i]>k){ret++;k*=2;}\\n                else k+=nums[i++];\\n            }\\n            return ret;\\n        }\\n    };",
                "solutionTags": [],
                "code": "class Solution {\\n    public:\\n        int minPatches(vector<int>& nums, int n) {\\n            int ret=0,i=0;\\n            long k=1;\\n            while(k<=n){\\n                if(i==nums.size()||nums[i]>k){ret++;k*=2;}",
                "codeTag": "Java"
            },
            {
                "id": 78526,
                "title": "sharing-my-8ms-c-solution",
                "content": "    class Solution {\\n    public:\\n        int minPatches(vector<int>& nums, int n) {\\n            int i = 0, N = nums.size();\\n            int result=0;\\n            long long int element=1;\\n            while(element<=n)\\n            {\\n                if(i>=N || nums[i]>element)\\n                {\\n                    result++;\\n                    element = element*2;\\n                }\\n                else\\n                {\\n                    element = element+nums[i];\\n                    i++;\\n                }\\n            }\\n            \\n            return result;\\n        }\\n    };",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int minPatches(vector<int>& nums, int n) {\\n            int i = 0, N = nums.size();\\n            int result=0;\\n            long long int element=1;\\n            while(element<=n)\\n            {\\n                if(i>=N || nums[i]>element)\\n                {\\n                    result++;\\n                    element = element*2;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 78532,
                "title": "simple-8-ms-c-solution-using-greedy",
                "content": "        long long covered=0;\\n        int np=0;\\n        const int l=nums.size();\\n        int i=0;\\n        while(i<l){\\n            if(covered>=n) break;\\n            if(nums[i]<=covered+1){\\n                covered+=nums[i];\\n                i++;\\n            }\\n            else {\\n                covered=2*covered+1;\\n                np++;\\n            }\\n        }\\n        while(covered<n){\\n            covered=2*covered+1;\\n            np++;\\n        }\\n        return np;\\n    }",
                "solutionTags": [],
                "code": "        long long covered=0;\\n        int np=0;\\n        const int l=nums.size();\\n        int i=0;\\n        while(i<l){\\n            if(covered>=n) break;\\n            if(nums[i]<=covered+1){\\n                covered+=nums[i];\\n                i++;\\n            }\\n            else {\\n                covered=2*covered+1;\\n                np++;\\n            }\\n        }\\n        while(covered<n){\\n            covered=2*covered+1;\\n            np++;\\n        }\\n        return np;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 78537,
                "title": "simple-c-solution",
                "content": "    class Solution {\\n    public:\\n        int minPatches(vector<int>& nums, int n) {\\n            int ret = 0;\\n            int i = 0;\\n            long long nid = 1;\\n            while(nid <= n)\\n            {\\n                if(i >= nums.size() || nums[i] > nid)\\n                {\\n                    ret++;\\n                    nid += nid;\\n                }\\n                else\\n                {\\n                    nid += nums[i];\\n                    i++;\\n                }\\n            }\\n            \\n            return ret;\\n        }\\n    };\\n\\nBasic idea is to check every nid from 1 to n.\\nIf number from nums is too large, then we need to patch nid itself, otherwise we can use nums[i].\\nwe know that 1 to nid -1 all meet requirements. Adding nid or nums[i] will extend this range to nid + (nid or nums[i]) - 1. Then we start next check at nid + (nid or nums[i]).",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n    public:\\n        int minPatches(vector<int>& nums, int n) {\\n            int ret = 0;\\n            int i = 0;\\n            long long nid = 1;\\n            while(nid <= n)\\n            {\\n                if(i >= nums.size() || nums[i] > nid)\\n                {\\n                    ret++;\\n                    nid += nid;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 78546,
                "title": "actually-patching",
                "content": "    int minPatches(vector<int>& nums, int n) {\\n        int k = nums.size();\\n        for (long miss=1, i=0; miss<=n; miss+=nums[i++])\\n            if (i == nums.size() || nums[i] > miss)\\n                nums.insert(nums.begin()+i, miss);\\n        return nums.size() - k;\\n    }\\n\\nO(k\\xb7log(n)) instead of O(k+log(n)), but not too bad.",
                "solutionTags": [],
                "code": "    int minPatches(vector<int>& nums, int n) {\\n        int k = nums.size();\\n        for (long miss=1, i=0; miss<=n; miss+=nums[i++])\\n            if (i == nums.size() || nums[i] > miss)\\n                nums.insert(nums.begin()+i, miss);\\n        return nums.size() - k;\\n    }\\n\\nO(k\\xb7log(n)) instead of O(k+log(n)), but not too bad.",
                "codeTag": "Unknown"
            },
            {
                "id": 4096654,
                "title": "how-do-i-show-this-to-the-interviewer-lmfao",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        covered, res, i = 0, 0, 0\\n        while covered < n:\\n            if i < len(nums) and nums[i] <= covered + 1:\\n                covered += nums[i]\\n                i += 1\\n            else:\\n                covered = 2 * covered + 1\\n                res += 1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        covered, res, i = 0, 0, 0\\n        while covered < n:\\n            if i < len(nums) and nums[i] <= covered + 1:\\n                covered += nums[i]\\n                i += 1\\n            else:\\n                covered = 2 * covered + 1\\n                res += 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4094869,
                "title": "i-dont-know-how-this-works",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        covered, res, i = 1, 0, 0\\n        while covered <= n:\\n            if i < len(nums) and nums[i] <= covered:\\n                covered += nums[i]\\n                i += 1\\n            else:\\n                covered += covered\\n                res += 1\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        covered, res, i = 1, 0, 0\\n        while covered <= n:\\n            if i < len(nums) and nums[i] <= covered:\\n                covered += nums[i]\\n                i += 1\\n            else:\\n                covered += covered\\n                res += 1\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086570,
                "title": "dart",
                "content": "![image.png](https://assets.leetcode.com/users/images/f5fd5d8c-b355-4d2b-90d8-b2abc32882c9_1695604093.4610822.png)\\n\\nWe keep patching until we cover n\\n\\n# Code\\n```\\nclass Solution {\\n  int minPatches(List<int> nums, int n) {\\n    var res = 0;\\n    var reachable = 0;\\n    var idx = 0;\\n    while (reachable < n) {\\n      if (idx < nums.length && nums[idx] <= reachable + 1) {\\n        reachable += nums[idx++];\\n      } else {\\n        reachable = 2 * reachable + 1;\\n        res++;\\n      }\\n    }\\n    return res;\\n  }\\n}\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\nclass Solution {\\n  int minPatches(List<int> nums, int n) {\\n    var res = 0;\\n    var reachable = 0;\\n    var idx = 0;\\n    while (reachable < n) {\\n      if (idx < nums.length && nums[idx] <= reachable + 1) {\\n        reachable += nums[idx++];\\n      } else {\\n        reachable = 2 * reachable + 1;\\n        res++;\\n      }\\n    }\\n    return res;\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4001993,
                "title": "aditya-college-of-engineering-and-technology",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minPatches(self, nums, n):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        missing = 1\\n        count = 0\\n        i = 0\\n        while missing<=n:\\n            if i<len(nums) and nums[i]<=missing:\\n                missing += nums[i]\\n                i = i+1\\n            else:\\n                missing += missing\\n                count  += 1\\n            #i = i+1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minPatches(self, nums, n):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type n: int\\n        :rtype: int\\n        \"\"\"\\n        missing = 1\\n        count = 0\\n        i = 0\\n        while missing<=n:\\n            if i<len(nums) and nums[i]<=missing:\\n                missing += nums[i]\\n                i = i+1\\n            else:\\n                missing += missing\\n                count  += 1\\n            #i = i+1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3952369,
                "title": "100-optimize-solution-using-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\tpublic int minPatches(int[] nums, int n) {\\n        return CountMissing(nums, n);\\n    }\\n    public static int CountMissing(int [] arr, int n){\\n\\t\\tint count = 0;\\n\\t\\tlong missing = 1;\\n\\t\\tint i = 0;\\n\\t\\twhile(missing <= n){\\n\\t\\t\\tif(i<arr.length && missing>=arr[i]){\\n\\t    \\t\\tmissing += arr[i];\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tmissing += missing;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\tpublic int minPatches(int[] nums, int n) {\\n        return CountMissing(nums, n);\\n    }\\n    public static int CountMissing(int [] arr, int n){\\n\\t\\tint count = 0;\\n\\t\\tlong missing = 1;\\n\\t\\tint i = 0;\\n\\t\\twhile(missing <= n){\\n\\t\\t\\tif(i<arr.length && missing>=arr[i]){\\n\\t    \\t\\tmissing += arr[i];\\n\\t\\t\\t\\ti++;\\n\\t\\t\\t}\\n\\t\\t\\telse{\\n\\t\\t\\t\\tmissing += missing;\\n\\t\\t\\t\\tcount++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn count;\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3939229,
                "title": "c-cinch-solution-amazon-vvvip",
                "content": "# Note\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMy friend if after seeing the solution ,u dont understand then no problem ,u simply dry run code with input={1,5,10}n=20 ,after dry running ,u clearly understand the everything and u proud yourself when u get that thing,that makes this question very important(THANK YOU)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n//Here you havev to think more and more,basically u hvae to divide the problem into smaller and \\n// smaller part,so that u understand and then apply property of sorted order,whenever there is gap\\n// between current element and next element we update current element and increment the cnt of patches requried(but we canot add any random number,we have to add minimum number that extend our coverage)\\n// sum+=sum+1,doubling apporach(means you cover all the sums that u had + new number(sum+1))\\n    int minPatches(vector<int>& nums, int n) {\\n        int i=0,cnt=0;\\n        long long sum=0;\\n        while(  sum<n){\\n            if(i<nums.size() && nums[i]<=sum+1){\\n                sum+=nums[i++];\\n            }else{\\n                cnt++;\\n\\n                sum+=sum+1;\\n                cout<<sum<<\" \";\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};  \\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n//Here you havev to think more and more,basically u hvae to divide the problem into smaller and \\n// smaller part,so that u understand and then apply property of sorted order,whenever there is gap\\n// between current element and next element we update current element and increment the cnt of patches requried(but we canot add any random number,we have to add minimum number that extend our coverage)\\n// sum+=sum+1,doubling apporach(means you cover all the sums that u had + new number(sum+1))\\n    int minPatches(vector<int>& nums, int n) {\\n        int i=0,cnt=0;\\n        long long sum=0;\\n        while(  sum<n){\\n            if(i<nums.size() && nums[i]<=sum+1){\\n                sum+=nums[i++];\\n            }else{\\n                cnt++;\\n\\n                sum+=sum+1;\\n                cout<<sum<<\" \";\\n            }\\n\\n        }\\n        return cnt;\\n    }\\n};  \\n```",
                "codeTag": "C++"
            },
            {
                "id": 3913395,
                "title": "consize-solution-java-kotlin-hyder-nabi",
                "content": "# java\\n```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        long lastVal = 0;\\n        int i = 0,patches=0;\\n        while(lastVal < n) {\\n        \\tif(i<nums.length && lastVal+1<nums[i] || i>=nums.length) {\\n\\t\\t\\t\\tpatches++;\\n        \\t\\tlastVal += lastVal+1;\\n        \\t} else {\\n        \\t\\tlastVal += nums[i++];\\n        \\t}\\n        }\\n        return patches;\\n    }\\n}\\n```\\n# Kotlin\\n```\\nclass Solution {\\n    fun minPatches(nums: IntArray, n: Int): Int {\\n        var i = 0\\n\\t    var lastVal: Long = 0;\\n\\t\\tvar result = 0;\\n\\t\\twhile(lastVal < n) {\\n\\t\\t\\tif(i<nums.size && lastVal+1 < nums[i] || i>= nums.size){\\n\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\tlastVal += lastVal+1;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tlastVal += nums[i++];\\n\\t\\t    }\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        long lastVal = 0;\\n        int i = 0,patches=0;\\n        while(lastVal < n) {\\n        \\tif(i<nums.length && lastVal+1<nums[i] || i>=nums.length) {\\n\\t\\t\\t\\tpatches++;\\n        \\t\\tlastVal += lastVal+1;\\n        \\t} else {\\n        \\t\\tlastVal += nums[i++];\\n        \\t}\\n        }\\n        return patches;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    fun minPatches(nums: IntArray, n: Int): Int {\\n        var i = 0\\n\\t    var lastVal: Long = 0;\\n\\t\\tvar result = 0;\\n\\t\\twhile(lastVal < n) {\\n\\t\\t\\tif(i<nums.size && lastVal+1 < nums[i] || i>= nums.size){\\n\\t\\t\\t\\tresult++;\\n\\t\\t\\t\\tlastVal += lastVal+1;\\n\\t\\t\\t}else{\\n\\t\\t\\t\\tlastVal += nums[i++];\\n\\t\\t    }\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906341,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public:\\n  int minPatches(vector<int>& nums, int n) {\\n    int ans = 0;\\n    int i = 0;      // Point to nums\\n    long miss = 1;  // Min sum in [1, n] we might miss\\n\\n    while (miss <= n)\\n      if (i < nums.size() && nums[i] <= miss) {\\n        miss += nums[i++];\\n      } else {\\n        // Greedily add miss itself to increase the range\\n        // From [1, miss) to [1, 2 * miss)\\n        miss += miss;\\n        ++ans;\\n      }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\n public:\\n  int minPatches(vector<int>& nums, int n) {\\n    int ans = 0;\\n    int i = 0;      // Point to nums\\n    long miss = 1;  // Min sum in [1, n] we might miss\\n\\n    while (miss <= n)\\n      if (i < nums.size() && nums[i] <= miss) {\\n        miss += nums[i++];\\n      } else {\\n        // Greedily add miss itself to increase the range\\n        // From [1, miss) to [1, 2 * miss)\\n        miss += miss;\\n        ++ans;\\n      }\\n\\n    return ans;\\n  }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3828960,
                "title": "easy-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long mncv=1;\\n        int i=0;\\n        int add_patch=0;\\n        while(mncv<=n) {\\n            if(i>=nums.size() || nums[i] > mncv) {\\n                add_patch+=1;\\n                mncv *= 2;\\n            } else {\\n                mncv += nums[i];\\n                i++;\\n            }\\n        }\\n        return add_patch;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long mncv=1;\\n        int i=0;\\n        int add_patch=0;\\n        while(mncv<=n) {\\n            if(i>=nums.size() || nums[i] > mncv) {\\n                add_patch+=1;\\n                mncv *= 2;\\n            } else {\\n                mncv += nums[i];\\n                i++;\\n            }\\n        }\\n        return add_patch;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3777586,
                "title": "explanation-for-beginners-like-me",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\ninitially, we assume that 1 is missing from the array, so we set miss to 1. let ```miss``` be the smallest sum in the```[0,n)``` that we might be missing. meaning we already can build all sums in ```[0,miss)```.\\n\\nif we have a number ```nums[i]<=miss``` in the given array, we can add it to miss to build all ```[0,miss+nums[i])```.\\n\\nhowever, if ```nums[i]>miss```, that means ```miss``` is too small to reach nums[i], so we must add a number to the array, the best choive is to add ```miss``` itself,to maximize the reach.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nexample: ```nums=[1,2,4,13,43],n=100```\\nuse 1, 2, 4 we can reach ```[0,8)``` \\n\\nnow```miss=1(initial)+1 (nums[0])+ 2(nums[1])+3(nums[2]) = 8```\\n i=3, nums[i]=13 ```nums[3]>miss```, we can not build 8 use the number in the array , so we add 8 to the array and double the miss to 16. now we can build ```[0,16)```.\\n\\nthan we the miss become 16+13=29 , the reach is ```[0,29)```.\\n29<43, so we add 29 to the array thurn the miss to 58, the reach is ```[0,58)```.\\n\\nand the 43 becomes useful , the reach is ```[0,101)```.\\n\\nand the patches is 2.\\n\\n- the doubling of miss serves two purposes. \\n1. **cover the current missing number**.\\n2. **extend the range of the reach between** ```[miss,2*miss-1]``` **or the whole ```[0,2*miss)```.**\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        #track the smallest missing number in the array, first we assume 1 is missing because we start with a empty array\\n        miss=1\\n        patches=0\\n        i=0\\n\\n        while miss <=n:\\n            if i<len(nums) and nums[i]<=miss:\\n                miss+=nums[i]\\n                i+=1\\n            else:\\n        \\n                miss*=2\\n                patches+=1\\n        return patches\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```miss```\n```[0,n)```\n```[0,miss)```\n```nums[i]<=miss```\n```[0,miss+nums[i])```\n```nums[i]>miss```\n```miss```\n```miss```\n```nums=[1,2,4,13,43],n=100```\n```[0,8)```\n```miss=1(initial)+1 (nums[0])+ 2(nums[1])+3(nums[2]) = 8```\n```nums[3]>miss```\n```[0,16)```\n```[0,29)```\n```[0,58)```\n```[0,101)```\n```[miss,2*miss-1]```\n```[0,2*miss)```\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        #track the smallest missing number in the array, first we assume 1 is missing because we start with a empty array\\n        miss=1\\n        patches=0\\n        i=0\\n\\n        while miss <=n:\\n            if i<len(nums) and nums[i]<=miss:\\n                miss+=nums[i]\\n                i+=1\\n            else:\\n        \\n                miss*=2\\n                patches+=1\\n        return patches\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3764420,
                "title": "java",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) { \\n        long canReach = 0;\\n        int added = 0 , iter = 0;\\n        while (canReach < n){\\n            while (iter < nums.length &&  nums[iter] <= canReach + 1){ // each number until canReach is aleady reachable and if new num is up to  canReach + 1 we can  -\\n                canReach +=  nums[iter++]; // - combine it with lower numbers to reach any number between canReach - canReach + new num. if its bigger then we can\\'t reach canReach + 1 and must add it to nums\\n                if (canReach >= n) return added;\\n            }   \\n            canReach += canReach + 1; // by adding canReach + 1\\n            added++;\\n        }\\n        return added;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) { \\n        long canReach = 0;\\n        int added = 0 , iter = 0;\\n        while (canReach < n){\\n            while (iter < nums.length &&  nums[iter] <= canReach + 1){ // each number until canReach is aleady reachable and if new num is up to  canReach + 1 we can  -\\n                canReach +=  nums[iter++]; // - combine it with lower numbers to reach any number between canReach - canReach + new num. if its bigger then we can\\'t reach canReach + 1 and must add it to nums\\n                if (canReach >= n) return added;\\n            }   \\n            canReach += canReach + 1; // by adding canReach + 1\\n            added++;\\n        }\\n        return added;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3578298,
                "title": "greedy-approach",
                "content": "# Code\\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        patches = 0\\n        max_reachable = 0\\n        i = 0\\n        \\n        while max_reachable < n:\\n            if i < len(nums) and nums[i] <= max_reachable + 1:\\n                max_reachable += nums[i]\\n                i += 1\\n            else:\\n                patches += 1\\n                max_reachable += max_reachable + 1\\n        \\n        return patches\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        patches = 0\\n        max_reachable = 0\\n        i = 0\\n        \\n        while max_reachable < n:\\n            if i < len(nums) and nums[i] <= max_reachable + 1:\\n                max_reachable += nums[i]\\n                i += 1\\n            else:\\n                patches += 1\\n                max_reachable += max_reachable + 1\\n        \\n        return patches\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3532434,
                "title": "greedy-approach-casually-beats-100",
                "content": "# Approach\\nGreedy approach to solve this problem.\\n\\nThe idea is to add the smallest missing number (initially 1) to our set of sums and patches, then double the upper limit of the covered range. We do this by iterating through the input array. If the current number is within our covered range, it extends the upper limit. If not, we add the smallest missing number (upper limit + 1) to the set.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\n#include <limits.h>\\n\\nint minPatches(int* nums, int numsSize, int n) {\\n    long miss = 1; // the smallest sum that we might be missing, initialized to 1\\n    int i = 0;     // index of current element in the array\\n    int patches = 0;  // number of patches used\\n    \\n    // While the missing sum is within the target range\\n    while (miss <= n) {\\n        if (i < numsSize && nums[i] <= miss) {\\n            // If current array element is less than or equal to missing sum, we can use it to extend the covered range\\n            miss += nums[i++];\\n        } else {\\n            // If current array element is larger than missing sum, we need to patch the array\\n            miss = miss << 1;\\n            patches++;\\n        }\\n    }\\n    return patches;\\n}\\n\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\n#include <limits.h>\\n\\nint minPatches(int* nums, int numsSize, int n) {\\n    long miss = 1; // the smallest sum that we might be missing, initialized to 1\\n    int i = 0;     // index of current element in the array\\n    int patches = 0;  // number of patches used\\n    \\n    // While the missing sum is within the target range\\n    while (miss <= n) {\\n        if (i < numsSize && nums[i] <= miss) {\\n            // If current array element is less than or equal to missing sum, we can use it to extend the covered range\\n            miss += nums[i++];\\n        } else {\\n            // If current array element is larger than missing sum, we need to patch the array\\n            miss = miss << 1;\\n            patches++;\\n        }\\n    }\\n    return patches;\\n}\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3518387,
                "title": "c-100-beat-solution-easy-way-understandable-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach \\n  : Greedy\\n\\n\\n# Complexity\\n- Time complexity:\\n O(max(nums.size(), logn)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int> &nums, int n) {\\n        int res = 0;\\n        long long curMax = 1;\\n        int idx = 0;\\n        while (curMax <= n) {\\n            if (idx<nums.size() && curMax >= nums[idx])\\n                curMax = curMax + nums[idx++];\\n            else {\\n                res++;\\n                curMax += curMax;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int> &nums, int n) {\\n        int res = 0;\\n        long long curMax = 1;\\n        int idx = 0;\\n        while (curMax <= n) {\\n            if (idx<nums.size() && curMax >= nums[idx])\\n                curMax = curMax + nums[idx++];\\n            else {\\n                res++;\\n                curMax += curMax;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3502389,
                "title": "using-the-greedy-algorithm",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n\\n        Stack<Integer> stack = new Stack<>();\\n        int count = 0;\\n        for(int i = nums.length - 1; i >= 0; i--) stack.push(nums[i]);\\n        long runningSum = 0l;\\n\\n        while(runningSum < n) {\\n            if(!stack.isEmpty() && stack.peek() <= runningSum+1) {\\n                runningSum += stack.pop();\\n            }\\n            else{\\n                count++;\\n                runningSum += (runningSum + 1);\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n\\n        Stack<Integer> stack = new Stack<>();\\n        int count = 0;\\n        for(int i = nums.length - 1; i >= 0; i--) stack.push(nums[i]);\\n        long runningSum = 0l;\\n\\n        while(runningSum < n) {\\n            if(!stack.isEmpty() && stack.peek() <= runningSum+1) {\\n                runningSum += stack.pop();\\n            }\\n            else{\\n                count++;\\n                runningSum += (runningSum + 1);\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3499974,
                "title": "simple-mathematics-solution-o-n-python",
                "content": "# Intuition and Approach\\n* use previous formed no. to form new numbers.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity:O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        ans=0\\n        pre=0\\n        i=0\\n        nextn=pre+1\\n        while(nextn<=n):\\n            if(i<len(nums) and nums[i]>nextn):\\n                ans+=1\\n                pre+=nextn\\n            elif(i<len(nums)):\\n                pre+=nums[i]\\n                i+=1\\n            else:\\n                ans+=1\\n                pre+=nextn\\n            nextn=pre+1\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        ans=0\\n        pre=0\\n        i=0\\n        nextn=pre+1\\n        while(nextn<=n):\\n            if(i<len(nums) and nums[i]>nextn):\\n                ans+=1\\n                pre+=nextn\\n            elif(i<len(nums)):\\n                pre+=nums[i]\\n                i+=1\\n            else:\\n                ans+=1\\n                pre+=nextn\\n            nextn=pre+1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3407629,
                "title": "java-beats-100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        int numPatches = 0;\\n        long currSum = 0;\\n        int currIdx = 0;\\n        while (currIdx < nums.length) {\\n            // nums = 1, 2, 4, (10)\\n            // currSum = 7\\n            int currNum = nums[currIdx];\\n            if (currNum - 1 > currSum) {\\n                // we will patch currNum + 1\\n                // System.out.printf(\"Patching %d\\\\n\", currSum + 1);\\n                currSum += currSum + 1;\\n                numPatches += 1;\\n            } else {\\n                ++currIdx;\\n                currSum += currNum;\\n            }\\n            if (currSum >= n) {\\n                return numPatches;\\n            }\\n        }\\n        while (currSum < n) {\\n            // System.out.printf(\"Patching %d\\\\n\", currSum + 1);\\n            currSum += currSum + 1;\\n            numPatches += 1;\\n        }\\n        return numPatches;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        int numPatches = 0;\\n        long currSum = 0;\\n        int currIdx = 0;\\n        while (currIdx < nums.length) {\\n            // nums = 1, 2, 4, (10)\\n            // currSum = 7\\n            int currNum = nums[currIdx];\\n            if (currNum - 1 > currSum) {\\n                // we will patch currNum + 1\\n                // System.out.printf(\"Patching %d\\\\n\", currSum + 1);\\n                currSum += currSum + 1;\\n                numPatches += 1;\\n            } else {\\n                ++currIdx;\\n                currSum += currNum;\\n            }\\n            if (currSum >= n) {\\n                return numPatches;\\n            }\\n        }\\n        while (currSum < n) {\\n            // System.out.printf(\"Patching %d\\\\n\", currSum + 1);\\n            currSum += currSum + 1;\\n            numPatches += 1;\\n        }\\n        return numPatches;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3370203,
                "title": "java-four-line-code-only-no-any-time-taken-0sec",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n\\n        Stack<Integer> stack = new Stack<>();\\n        int count = 0;\\n        for(int i = nums.length - 1; i >= 0; i--) stack.push(nums[i]);\\n        long runningSum = 0l;\\n\\n        while(runningSum < n) {\\n            if(!stack.isEmpty() && stack.peek() <= runningSum+1) {\\n                runningSum += stack.pop();\\n            }\\n            else{\\n                count++;\\n                runningSum += (runningSum + 1);\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n\\n        Stack<Integer> stack = new Stack<>();\\n        int count = 0;\\n        for(int i = nums.length - 1; i >= 0; i--) stack.push(nums[i]);\\n        long runningSum = 0l;\\n\\n        while(runningSum < n) {\\n            if(!stack.isEmpty() && stack.peek() <= runningSum+1) {\\n                runningSum += stack.pop();\\n            }\\n            else{\\n                count++;\\n                runningSum += (runningSum + 1);\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3350003,
                "title": "python-longest-increasing-path-in-a-matrix",
                "content": "# Intuition\\nOne way to solve this problem is to use a greedy approach. We can keep track of the smallest number we cannot make using the numbers we have encountered so far. We start with missing = 1, since we can always make 1 with an empty array. Then, we iterate through the given array and check if the current number is less than or equal to missing. If it is, then we can update missing to missing + nums[i], since we can now make all the numbers from missing to missing + nums[i] - 1. If the current number is greater than missing, then we need to add missing to the array to make missing + 1 up to nums[i] - 1, and then update missing to missing + nums[i].\\n\\n# Approach\\n1. Initialize missing = 1, patches = 0, and i = 0.\\n2. While missing <= n, repeat steps 3-5.\\n3. If i < len(nums) and nums[i] <= missing, then update missing to missing + nums[i].\\n4. Otherwise, add missing to the array and update missing to missing * 2. Also, increment patches.\\n5. Increment i.\\n6. Return patches.\\n# Complexity\\n- Time complexity:\\nO(n), where n is the size of the array nums.\\n- Space complexity:\\nO(1). We are using constant space to keep track of variables like missing, patches, and i.\\n\\n# Code\\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        patches = 0\\n        missed = 1\\n        i = 0\\n        \\n        while missed <= n:\\n            if i < len(nums) and nums[i] <= missed:\\n                missed += nums[i]\\n                i += 1\\n            else:\\n                missed += missed\\n                patches += 1\\n                \\n        return patches\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming",
                    "Depth-First Search",
                    "Memoization",
                    "Matrix"
                ],
                "code": "```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        patches = 0\\n        missed = 1\\n        i = 0\\n        \\n        while missed <= n:\\n            if i < len(nums) and nums[i] <= missed:\\n                missed += nums[i]\\n                i += 1\\n            else:\\n                missed += missed\\n                patches += 1\\n                \\n        return patches\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3344318,
                "title": "easy-c-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long index=0 , reach =0, cnt=0;\\n    while (reach<n)\\n    {\\n        if(index>=nums.size())\\n        {\\n            reach+=(reach+1);\\n            cnt++;\\n        }\\n        else if(index<nums.size()&&nums[index]<=(reach+1)){\\n            reach+=nums[index];\\n            index++;\\n        }\\n        else{\\n            reach+=(reach+1);\\n            cnt++;\\n        }\\n    }\\n    return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long index=0 , reach =0, cnt=0;\\n    while (reach<n)\\n    {\\n        if(index>=nums.size())\\n        {\\n            reach+=(reach+1);\\n            cnt++;\\n        }\\n        else if(index<nums.size()&&nums[index]<=(reach+1)){\\n            reach+=nums[index];\\n            index++;\\n        }\\n        else{\\n            reach+=(reach+1);\\n            cnt++;\\n        }\\n    }\\n    return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324538,
                "title": "java-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTHE MOST SIMPLE JAVA CODE\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nbeats 100 %\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        long range = 0;\\n        int cnt = 0;\\n        for (int num : nums) {\\n            while (range < num - 1 && range < n) {\\n                cnt++;\\n                range += range + 1;\\n            }\\n            range += num;\\n        }\\n        while (range < n) {\\n            cnt++;\\n            range += range + 1;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        long range = 0;\\n        int cnt = 0;\\n        for (int num : nums) {\\n            while (range < num - 1 && range < n) {\\n                cnt++;\\n                range += range + 1;\\n            }\\n            range += num;\\n        }\\n        while (range < n) {\\n            cnt++;\\n            range += range + 1;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3323462,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        int m=nums.size();\\n\\n        sort(nums.begin(),nums.end());\\n\\n         long long cur=0;\\n        int cnt=0;\\n        for(int i=0;i<m;i++){\\n\\n            while(cur<n && nums[i]>cur+1){\\n               cur+=cur+1;\\n               cnt++;\\n            }\\n            if(cur>=n)\\n            break;\\n            cur+=nums[i];\\n        }\\n        while(cur<n){\\n            cur+=cur+1;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        upper=0\\n        res=0\\n        i=0\\n        ln=len(nums)\\n\\n        while upper<n:\\n            if i<ln:\\n                while nums[i]>upper+1:\\n                    res+=1\\n                    upper+=upper+1\\n                    if upper>=n: return res\\n                upper+=nums[i]\\n                i+=1\\n            else:\\n                res+=1\\n                upper+=upper+1\\n        return res\\n```\\n\\n```Java []\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        \\n        int m=nums.length;\\n        \\n        int count=0;\\n        \\n        int i=0;\\n        long  val=1;\\n        long sum=0;\\n        \\n        while(i<m || sum<n){\\n            \\n            if(sum>n)break;\\n            \\n            if(i<m && nums[i]<=val){\\n               sum+=nums[i];\\n               i++; \\n            }\\n            else{\\n                sum+=val;\\n            }\\n            val=sum+1;\\n            \\n            count++;\\n        }\\n        return count-i;\\n        \\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        int m=nums.size();\\n\\n        sort(nums.begin(),nums.end());\\n\\n         long long cur=0;\\n        int cnt=0;\\n        for(int i=0;i<m;i++){\\n\\n            while(cur<n && nums[i]>cur+1){\\n               cur+=cur+1;\\n               cnt++;\\n            }\\n            if(cur>=n)\\n            break;\\n            cur+=nums[i];\\n        }\\n        while(cur<n){\\n            cur+=cur+1;\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        upper=0\\n        res=0\\n        i=0\\n        ln=len(nums)\\n\\n        while upper<n:\\n            if i<ln:\\n                while nums[i]>upper+1:\\n                    res+=1\\n                    upper+=upper+1\\n                    if upper>=n: return res\\n                upper+=nums[i]\\n                i+=1\\n            else:\\n                res+=1\\n                upper+=upper+1\\n        return res\\n```\n```Java []\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        \\n        int m=nums.length;\\n        \\n        int count=0;\\n        \\n        int i=0;\\n        long  val=1;\\n        long sum=0;\\n        \\n        while(i<m || sum<n){\\n            \\n            if(sum>n)break;\\n            \\n            if(i<m && nums[i]<=val){\\n               sum+=nums[i];\\n               i++; \\n            }\\n            else{\\n                sum+=val;\\n            }\\n            val=sum+1;\\n            \\n            count++;\\n        }\\n        return count-i;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3312434,
                "title": "c-cinch-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long maxi = 1;\\n        long long m = nums.size();\\n        long long count=0;\\n        for(int i=0; i<m; ){\\n            if(maxi > n)\\n                return count;\\n            if(maxi < nums[i]){\\n                count++;\\n                maxi += maxi;\\n                continue;\\n            }\\n            maxi += (long long)nums[i];\\n            i++;\\n        }\\n        while(maxi <= n){\\n            maxi += maxi;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long maxi = 1;\\n        long long m = nums.size();\\n        long long count=0;\\n        for(int i=0; i<m; ){\\n            if(maxi > n)\\n                return count;\\n            if(maxi < nums[i]){\\n                count++;\\n                maxi += maxi;\\n                continue;\\n            }\\n            maxi += (long long)nums[i];\\n            i++;\\n        }\\n        while(maxi <= n){\\n            maxi += maxi;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3268359,
                "title": "java-soln-best-i-found",
                "content": "# If this helps Dont Forget to `Upvote` and\\n![meme.jfif](https://assets.leetcode.com/users/images/2912517d-1727-442b-919a-1d98ae03d9e4_1678188101.7936957.jpeg)\\n\\n\\n# Approach\\nIterating the nums[], and keeps adding them up, and we are getting a running sum. \\n        At any position, if nums[i] > sum+1, then we are sure we have to patch a sum+1, \\n        because all nums before index i can\\'t make sum+1 even if we add all of them up, \\n        and all nums after index i are all simply too large.\\n\\nAll credit goes to @rohitkumarsingh369\\nhttps://leetcode.com/problems/patching-array/solutions/1433222/simple-easy-to-understand-java-solution-faster-than-100/?page=2\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n\\n        long sum=0;\\n        int count=0;\\n        for(int i=0 ; i<nums.length ; i++){\\n            //check if the integer is a running sum \\n            if(sum>=n) break;\\n            while(sum+1 < nums[i] && sum<n){\\n                sum += sum+1;\\n                count++;\\n            }\\n            sum += nums[i];\\n        }\\n\\n        //when we reach the last pos of the arr\\n        while(sum+1 < n){\\n            sum += sum+1;\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n\\n        long sum=0;\\n        int count=0;\\n        for(int i=0 ; i<nums.length ; i++){\\n            //check if the integer is a running sum \\n            if(sum>=n) break;\\n            while(sum+1 < nums[i] && sum<n){\\n                sum += sum+1;\\n                count++;\\n            }\\n            sum += nums[i];\\n        }\\n\\n        //when we reach the last pos of the arr\\n        while(sum+1 < n){\\n            sum += sum+1;\\n            count++;\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253628,
                "title": "java-simple-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\n     public int minPatches(int[] nums, int n) {\\n        long prev=0,patchCount=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(prev>=n){\\n                break;\\n            }else {\\n                while (nums[i]>prev+1 && prev<n){\\n                    patchCount++;\\n                    prev+=prev+1;\\n                }\\n            }\\n            prev+=nums[i];\\n        }\\n        while (n>prev+1){\\n            patchCount++;\\n            prev+=prev+1;\\n        }\\n        \\n        return (int) patchCount;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n     public int minPatches(int[] nums, int n) {\\n        long prev=0,patchCount=0;\\n        for (int i=0;i<nums.length;i++){\\n            if(prev>=n){\\n                break;\\n            }else {\\n                while (nums[i]>prev+1 && prev<n){\\n                    patchCount++;\\n                    prev+=prev+1;\\n                }\\n            }\\n            prev+=nums[i];\\n        }\\n        while (n>prev+1){\\n            patchCount++;\\n            prev+=prev+1;\\n        }\\n        \\n        return (int) patchCount;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253343,
                "title": "java-beats-100-of-the-solutions",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        long sum=0;\\n        int count=0;\\n        while(sum<nums[0]-1){\\n                sum=sum+(sum+1);\\n                count++;\\n            }\\n        sum=Math.max(sum,sum+nums[0]);\\n        for(int i=1;i<nums.length;i++){\\n            while(sum<Math.min(nums[i]-1,n)){\\n                sum=sum+(sum+1);\\n                count++;\\n            }\\n            sum=sum+nums[i];\\n        }\\n        while(sum<=n-1){\\n                sum=sum+(sum+1);\\n                count++;\\n            }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        long sum=0;\\n        int count=0;\\n        while(sum<nums[0]-1){\\n                sum=sum+(sum+1);\\n                count++;\\n            }\\n        sum=Math.max(sum,sum+nums[0]);\\n        for(int i=1;i<nums.length;i++){\\n            while(sum<Math.min(nums[i]-1,n)){\\n                sum=sum+(sum+1);\\n                count++;\\n            }\\n            sum=sum+nums[i];\\n        }\\n        while(sum<=n-1){\\n                sum=sum+(sum+1);\\n                count++;\\n            }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209697,
                "title": "c-simple-greedy-approach-8-ms",
                "content": "# Intuition\\nStart from 1, if found then search for 2 and so on.\\nIf not found then add it.(Maintain a variable ans which stores number of elements that are added).\\nMaintain a variable sum, which calculate sum of the elements in the array (including those which are newly added).\\n\\n\\nNOTE: If sum=x, then it\\'s always possible to make any number between(1 to x).\\n\\n# Approach\\nGreedy\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n\\npublic:\\n    long long int minPatches(vector<int>& nums, int n1) {\\n        long long int n=n1;\\n        long long int ans=0;\\n        long long int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(sum>=n) break;\\n            if(sum+1==nums[i]){\\n                sum+=nums[i];\\n            }else if(sum+1<nums[i]){\\n                ans+=1;\\n                //cout<<sum+1<<endl;\\n                sum+=(sum+1);\\n                i-=1;\\n            }\\n            else{\\n                sum+=nums[i];\\n                //ans+=1;\\n            }\\n        }\\n\\n        while(sum<n){\\n            sum+=(sum+1);\\n            ans+=1;\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n\\npublic:\\n    long long int minPatches(vector<int>& nums, int n1) {\\n        long long int n=n1;\\n        long long int ans=0;\\n        long long int sum=0;\\n        for(int i=0;i<nums.size();i++){\\n            if(sum>=n) break;\\n            if(sum+1==nums[i]){\\n                sum+=nums[i];\\n            }else if(sum+1<nums[i]){\\n                ans+=1;\\n                //cout<<sum+1<<endl;\\n                sum+=(sum+1);\\n                i-=1;\\n            }\\n            else{\\n                sum+=nums[i];\\n                //ans+=1;\\n            }\\n        }\\n\\n        while(sum<n){\\n            sum+=(sum+1);\\n            ans+=1;\\n        }\\n\\n        return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3142294,
                "title": "c-solution-runtime-3-ms-beats-96-97",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        int i = 0, res = 0;\\n        long long miss = 1;\\n        while (miss <= n) {\\n            if (i < nums.size() && nums[i] <= miss) {\\n                miss += nums[i++];\\n            } else {\\n                miss += miss;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        int i = 0, res = 0;\\n        long long miss = 1;\\n        while (miss <= n) {\\n            if (i < nums.size() && nums[i] <= miss) {\\n                miss += nums[i++];\\n            } else {\\n                miss += miss;\\n                res++;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3138118,
                "title": "python-solution-simple-and-fast",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        sum, patch, i = 0, 0, 0\\n\\n        while sum < n:\\n            if i < len(nums) and nums[i] <= sum+1:\\n                sum += nums[i]\\n                i += 1\\n            else:\\n                patch += 1\\n                sum += sum+1\\n\\n        return patch\\n        \\n```\\n![image.png](https://assets.leetcode.com/users/images/6e6955b9-62e4-4694-9983-2d19617d1d3e_1675460275.5475147.png)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        sum, patch, i = 0, 0, 0\\n\\n        while sum < n:\\n            if i < len(nums) and nums[i] <= sum+1:\\n                sum += nums[i]\\n                i += 1\\n            else:\\n                patch += 1\\n                sum += sum+1\\n\\n        return patch\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3133043,
                "title": "c-faster-solution-greedy-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n\\t\\tint i = 0, additions = 0; \\n\\t\\tlong miss = 1;\\n\\t\\tconst int L = nums.size();\\n\\t\\twhile (miss <= n && i < L)\\n\\t\\t{\\n\\t\\t\\tif (nums[i] <= miss)\\n\\t\\t\\t\\tmiss += nums[i++];\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tmiss <<= 1;\\n\\t\\t\\t\\tadditions++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile (miss <= n)\\n\\t\\t{\\n\\t\\t\\tmiss <<= 1;\\n\\t\\t\\tadditions++;\\n\\t\\t}\\n\\t\\treturn additions;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n\\t\\tint i = 0, additions = 0; \\n\\t\\tlong miss = 1;\\n\\t\\tconst int L = nums.size();\\n\\t\\twhile (miss <= n && i < L)\\n\\t\\t{\\n\\t\\t\\tif (nums[i] <= miss)\\n\\t\\t\\t\\tmiss += nums[i++];\\n\\t\\t\\telse\\n\\t\\t\\t{\\n\\t\\t\\t\\tmiss <<= 1;\\n\\t\\t\\t\\tadditions++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\twhile (miss <= n)\\n\\t\\t{\\n\\t\\t\\tmiss <<= 1;\\n\\t\\t\\tadditions++;\\n\\t\\t}\\n\\t\\treturn additions;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105798,
                "title": "greedy-easy-solution-and-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n         long sum = 0;\\n        int cnt = 0;\\n        int i = 0;\\n        while(sum<n)\\n        {\\n           if(i<nums.length&& nums[i]<=sum+1) //for each number \\n               sum+=nums[i++];\\n           else{\\n               sum+=sum+1;\\n               cnt++;\\n               }\\n        }\\n        return cnt; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n         long sum = 0;\\n        int cnt = 0;\\n        int i = 0;\\n        while(sum<n)\\n        {\\n           if(i<nums.length&& nums[i]<=sum+1) //for each number \\n               sum+=nums[i++];\\n           else{\\n               sum+=sum+1;\\n               cnt++;\\n               }\\n        }\\n        return cnt; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3105797,
                "title": "greedy-easy-solution-and-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n         long sum = 0;\\n        int cnt = 0;\\n        int i = 0;\\n        while(sum<n)\\n        {\\n           if(i<nums.length&& nums[i]<=sum+1) //for each number \\n               sum+=nums[i++];\\n           else{\\n               sum+=sum+1;\\n               cnt++;\\n               }\\n        }\\n        return cnt; \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n         long sum = 0;\\n        int cnt = 0;\\n        int i = 0;\\n        while(sum<n)\\n        {\\n           if(i<nums.length&& nums[i]<=sum+1) //for each number \\n               sum+=nums[i++];\\n           else{\\n               sum+=sum+1;\\n               cnt++;\\n               }\\n        }\\n        return cnt; \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032211,
                "title": "go-pyton-o-m-log-n-time-o-1-space",
                "content": "# Complexity\\n- Time complexity: $$O(m+log(n))$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```golang []\\nfunc minPatches(nums []int, n int) int {\\n    covered := 0\\n    i := 0\\n    answer := 0\\n    for i<len(nums) && covered < n{\\n        if nums[i] <= covered+1{\\n            covered+=nums[i]\\n            i+=1\\n        }else{\\n            covered+=covered+1\\n            answer+=1\\n        }\\n    }\\n        \\n    for covered < n{\\n        covered+=covered+1\\n        answer+=1\\n    }\\n    return answer\\n}\\n```\\n```python []\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        covered = 0\\n        i = 0\\n        answer = 0\\n        while i<len(nums) and covered < n:\\n            if nums[i] <= covered+1:\\n                covered+=nums[i]\\n                i+=1\\n            else:\\n                covered+=covered+1\\n                answer+=1\\n        while covered < n:\\n            covered+=covered+1\\n            answer+=1\\n        return answer\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Go",
                    "Array",
                    "Greedy"
                ],
                "code": "```golang []\\nfunc minPatches(nums []int, n int) int {\\n    covered := 0\\n    i := 0\\n    answer := 0\\n    for i<len(nums) && covered < n{\\n        if nums[i] <= covered+1{\\n            covered+=nums[i]\\n            i+=1\\n        }else{\\n            covered+=covered+1\\n            answer+=1\\n        }\\n    }\\n        \\n    for covered < n{\\n        covered+=covered+1\\n        answer+=1\\n    }\\n    return answer\\n}\\n```\n```python []\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        covered = 0\\n        i = 0\\n        answer = 0\\n        while i<len(nums) and covered < n:\\n            if nums[i] <= covered+1:\\n                covered+=nums[i]\\n                i+=1\\n            else:\\n                covered+=covered+1\\n                answer+=1\\n        while covered < n:\\n            covered+=covered+1\\n            answer+=1\\n        return answer\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026344,
                "title": "easy-approach-c-code",
                "content": "**DO UPVOTE**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long reach=0;  // to keep track of the max number that we can reach so far\\n        int i=0,sz=nums.size();\\n        int ans=0;\\n        while(i<sz and reach<n)\\n        {\\n            if(nums[i]>reach+1)  // if we are on a number that is greater than our reach that would mean that we are missing some number in between\\n// and that we would need to path a number just greater thatn the current number, so  we add reach +1 in the array and \\n            {\\n                ans++; // increase the count of patched numberes\\n                reach=(2*reach)+1;  //as recently added number is reach +1, so new reach becomes reach+ (reach +1)\\n            }\\n            else{\\n            reach=reach + nums[i];  // else reach would be current reach (reach) + current number (nums[i])\\n            i++;}\\n        }\\n        //if array is finished and reach is still less than reach than we keep adding reach +1 and keep updating reach as well as ans.\\n        while(reach < n)\\n        {\\n            reach*=2;\\n            reach+=1;\\n            ans++;\\n        }\\n        return ans;\\n        // Do UPVOTE pls\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long reach=0;  // to keep track of the max number that we can reach so far\\n        int i=0,sz=nums.size();\\n        int ans=0;\\n        while(i<sz and reach<n)\\n        {\\n            if(nums[i]>reach+1)  // if we are on a number that is greater than our reach that would mean that we are missing some number in between\\n// and that we would need to path a number just greater thatn the current number, so  we add reach +1 in the array and \\n            {\\n                ans++; // increase the count of patched numberes\\n                reach=(2*reach)+1;  //as recently added number is reach +1, so new reach becomes reach+ (reach +1)\\n            }\\n            else{\\n            reach=reach + nums[i];  // else reach would be current reach (reach) + current number (nums[i])\\n            i++;}\\n        }\\n        //if array is finished and reach is still less than reach than we keep adding reach +1 and keep updating reach as well as ans.\\n        while(reach < n)\\n        {\\n            reach*=2;\\n            reach+=1;\\n            ans++;\\n        }\\n        return ans;\\n        // Do UPVOTE pls\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3012513,
                "title": "simple-o-n-solution-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long int ans = 0, sum = 0;\\n        int i=0;\\n        while(sum < n){\\n            if(i < nums.size() && nums[i] <= sum + 1){\\n                sum += nums[i];\\n                i++;\\n            }else{\\n                sum += sum + 1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long int ans = 0, sum = 0;\\n        int i=0;\\n        while(sum < n){\\n            if(i < nums.size() && nums[i] <= sum + 1){\\n                sum += nums[i];\\n                i++;\\n            }else{\\n                sum += sum + 1;\\n                ans++;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2969642,
                "title": "javascript-greedy-approach-with-dry-run-sample",
                "content": "![image](https://assets.leetcode.com/users/images/d084edc3-c345-4b3f-8d0c-98cfcfe28276_1672372982.1921132.jpeg)\\nvar minPatches = function (nums, n) {\\n  let patch = 0;\\n  let reach = 0;\\n  let i = 0;\\n  while (reach < n) {\\n    if (i < nums.length && nums[i] <= reach + 1) {\\n      reach += nums[i];\\n      i++;\\n    } else {\\n      console.log(reach, nums[i]);\\n      reach += reach + 1;\\n      console.log(reach, nums[i]);\\n      patch++;\\n    }\\n  }\\n  return patch;\\n};\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/d084edc3-c345-4b3f-8d0c-98cfcfe28276_1672372982.1921132.jpeg)\\nvar minPatches = function (nums, n) {\\n  let patch = 0;\\n  let reach = 0;\\n  let i = 0;\\n  while (reach < n) {\\n    if (i < nums.length && nums[i] <= reach + 1) {\\n      reach += nums[i];\\n      i++;\\n    } else {\\n      console.log(reach, nums[i]);\\n      reach += reach + 1;\\n      console.log(reach, nums[i]);\\n      patch++;\\n    }\\n  }\\n  return patch;\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2944958,
                "title": "very-basic-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(log(n))\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& v, int n) {\\n        ll x=0,c=0,i=0;\\n\\n        while(x<n){\\n           if( i<v.size() && v[i]<=x+1){\\n               x+=(v[i]);\\n               i++;\\n           }\\n           else{\\n               x=2*x+1;\\n               c++;\\n           }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& v, int n) {\\n        ll x=0,c=0,i=0;\\n\\n        while(x<n){\\n           if( i<v.size() && v[i]<=x+1){\\n               x+=(v[i]);\\n               i++;\\n           }\\n           else{\\n               x=2*x+1;\\n               c++;\\n           }\\n        }\\n        return c;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2882916,
                "title": "greedy-to-find-the-next-number-in-array-or-not",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nthe array is sorted, and need patch to make [1, n]\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nif nothing: [0, 0]\\nif add 1: [0, 1]\\nif we need to get [1, n]\\ndo we have 2 in nums, then it will become [0, 1] + [2 + 0, 2 + 1] = [0, 3]\\nthe next number is added or in the nums is always depend on previous state.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        res, N, reach, i = 0, len(nums), 0, 0\\n        while reach < n: # if didn\\'t reach n\\n            if i < N and nums[i] <= reach + 1: # no need to add\\n                reach += nums[i]\\n                i += 1\\n            else: # need to add, the nums are sorted, means others numbers after this one is not possible\\n                res += 1\\n                reach += reach + 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n        res, N, reach, i = 0, len(nums), 0, 0\\n        while reach < n: # if didn\\'t reach n\\n            if i < N and nums[i] <= reach + 1: # no need to add\\n                reach += nums[i]\\n                i += 1\\n            else: # need to add, the nums are sorted, means others numbers after this one is not possible\\n                res += 1\\n                reach += reach + 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2866373,
                "title": "python-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom collections import Counter\\nclass Solution:\\n    def minPatches(self, nums, n: int) -> int:\\n        ald = Counter(nums)\\n        cur_range = 0\\n        cnt = 0\\n        keys = sorted(ald.keys())\\n        idx = 0\\n        while cur_range < n:\\n            \\n            while idx < len(keys) and keys[idx] <= cur_range:\\n                added = keys[idx]\\n                cur_range += ald[added] * added\\n                idx += 1\\n            if cur_range >= n:\\n                break\\n            next_to_pick = cur_range + 1\\n            if next_to_pick in ald:\\n                added = keys[idx]\\n                cur_range += ald[added] * added\\n                idx += 1\\n            else:\\n                cur_range += next_to_pick\\n                cnt += 1\\n\\n            \\n        return cnt\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\nclass Solution:\\n    def minPatches(self, nums, n: int) -> int:\\n        ald = Counter(nums)\\n        cur_range = 0\\n        cnt = 0\\n        keys = sorted(ald.keys())\\n        idx = 0\\n        while cur_range < n:\\n            \\n            while idx < len(keys) and keys[idx] <= cur_range:\\n                added = keys[idx]\\n                cur_range += ald[added] * added\\n                idx += 1\\n            if cur_range >= n:\\n                break\\n            next_to_pick = cur_range + 1\\n            if next_to_pick in ald:\\n                added = keys[idx]\\n                cur_range += ald[added] * added\\n                idx += 1\\n            else:\\n                cur_range += next_to_pick\\n                cnt += 1\\n\\n            \\n        return cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829603,
                "title": "just-a-runnable-solution",
                "content": "# Code\\n```\\nimpl Solution {\\n    pub fn min_patches(nums: Vec<i32>, n: i32) -> i32 {\\n        let nums = nums.into_iter().map(|x| x as i64).collect::<Vec<_>>();\\n\\n        let mut index = 0;\\n        let mut count = 0;\\n        let mut value_need = 1_i64;\\n        while value_need <= n as i64 {\\n            if index < nums.len() && value_need >= nums[index] {\\n                value_need += nums[index];\\n                index += 1;\\n            } else {\\n                value_need += value_need;\\n                count += 1;\\n            }\\n        }\\n        count\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn min_patches(nums: Vec<i32>, n: i32) -> i32 {\\n        let nums = nums.into_iter().map(|x| x as i64).collect::<Vec<_>>();\\n\\n        let mut index = 0;\\n        let mut count = 0;\\n        let mut value_need = 1_i64;\\n        while value_need <= n as i64 {\\n            if index < nums.len() && value_need >= nums[index] {\\n                value_need += nums[index];\\n                index += 1;\\n            } else {\\n                value_need += value_need;\\n                count += 1;\\n            }\\n        }\\n        count\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2766821,
                "title": "nice",
                "content": "class Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        \\n        int s = nums.size(),i=0;\\n        long long rq=1,upto_sum=0;\\n        vector<long long> ans;\\n  \\n        while(upto_sum < n){\\n            if( i<s and upto_sum+1>=nums[i]){\\n                // ans.push_back(s[i]);\\n                upto_sum = upto_sum+nums[i];\\n                i++;\\n            }\\n            else{\\n                ans.push_back(upto_sum+1);\\n                upto_sum = 2*upto_sum + 1;\\n            }\\n        }\\n        // for(int i=0;i<ans.size();i++){\\n        //     cout<<ans[i]<<endl;\\n        // }\\n        return ans.size();\\n        \\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        \\n        int s = nums.size(),i=0;\\n        long long rq=1,upto_sum=0;\\n        vector<long long> ans;\\n  \\n        while(upto_sum < n){\\n            if( i<s and upto_sum+1>=nums[i]){\\n                // ans.push_back(s[i]);\\n                upto_sum = upto_sum+nums[i];\\n                i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2722573,
                "title": "how-to-take-note-of-different-sums-without-creatig-powerset",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n//  Let miss be the smallest sum in [0,n] that we might be missing. Meaning we already know we can build all sums in [0,miss). \\n// Then if we have a number num <= miss in the given array, we can add it to those smaller sums to build all sums in [0,miss+num). If we don\\'t, then we must add such a number to the array, and it\\'s best to add miss itself, to maximize the reach.\\n\\n//    EXAMPLE : Let\\'s say the input is nums = [1, 2, 4, 13, 43] and n = 100. We need to ensure that all sums in the range [1,100] are possible.\\n// Miss == 1 , we find 1 , can we make sum in [0, 1) , yes we can : miss = 1 + 1\\n// miss == 2, we find 2 next in the array , can we make sum in range [0, 2), yes we can : miss = 2 + 2\\n// miss == 4, we find 4 , can we make sum in range [0, 4), yes we can : miss = 4 + 4\\n// we can make sum in range [1, 8)\\n\\n//     Using the given numbers 1, 2 and 4, we can already build all sums from 0 to 7, i.e., the range [0,8). But we can\\'t build the sum 8, and the next given number (13) is too large. So we insert 8 into the array. Then we can build all sums in [0,16).\\n\\n//     Do we need to insert 16 into the array? No! We can already build the sum 3, and adding the given 13 gives us sum 16. We can also add the 13 to the other sums, extending our range to [0,29).\\n\\n//     And so on. The given 43 is too large to help with sum 29, so we must insert 29 into our array. This extends our range to [0,58). But then the 43 becomes useful and expands our range to [0,101). At which point we\\'re done.\\n\\n    \\n    int minPatches(vector<int>& nums, int n) {\\n        long miss = 1, added = 0, i = 0;\\n        while (miss <= n) {\\n            if (i < nums.size() && nums[i] <= miss) {\\n                miss += nums[i++];\\n            } else {\\n                miss += miss;\\n                added++;\\n            }\\n        }\\n        return added;\\n    }\\n};\\n```\\n\\nSimilar Question : https://leetcode.com/problems/maximum-number-of-consecutive-values-you-can-make/",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n//  Let miss be the smallest sum in [0,n] that we might be missing. Meaning we already know we can build all sums in [0,miss). \\n// Then if we have a number num <= miss in the given array, we can add it to those smaller sums to build all sums in [0,miss+num). If we don\\'t, then we must add such a number to the array, and it\\'s best to add miss itself, to maximize the reach.\\n\\n//    EXAMPLE : Let\\'s say the input is nums = [1, 2, 4, 13, 43] and n = 100. We need to ensure that all sums in the range [1,100] are possible.\\n// Miss == 1 , we find 1 , can we make sum in [0, 1) , yes we can : miss = 1 + 1\\n// miss == 2, we find 2 next in the array , can we make sum in range [0, 2), yes we can : miss = 2 + 2\\n// miss == 4, we find 4 , can we make sum in range [0, 4), yes we can : miss = 4 + 4\\n// we can make sum in range [1, 8)\\n\\n//     Using the given numbers 1, 2 and 4, we can already build all sums from 0 to 7, i.e., the range [0,8). But we can\\'t build the sum 8, and the next given number (13) is too large. So we insert 8 into the array. Then we can build all sums in [0,16).\\n\\n//     Do we need to insert 16 into the array? No! We can already build the sum 3, and adding the given 13 gives us sum 16. We can also add the 13 to the other sums, extending our range to [0,29).\\n\\n//     And so on. The given 43 is too large to help with sum 29, so we must insert 29 into our array. This extends our range to [0,58). But then the 43 becomes useful and expands our range to [0,101). At which point we\\'re done.\\n\\n    \\n    int minPatches(vector<int>& nums, int n) {\\n        long miss = 1, added = 0, i = 0;\\n        while (miss <= n) {\\n            if (i < nums.size() && nums[i] <= miss) {\\n                miss += nums[i++];\\n            } else {\\n                miss += miss;\\n                added++;\\n            }\\n        }\\n        return added;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2694162,
                "title": "easy-to-understand-for-begineers",
                "content": "int minPatches(vector<int>& nums, int n) {\\n        // make reach variable long long to avoid overflow\\n        long reach=0; //intitally reach is zero\\n        int i=0; \\n        int cnt=0;   // no of elemens added        \\n            while(reach<n)\\n            {\\n                if(i>=nums.size())   // if array becomes empty then for it\\n                {\\n                     cnt++;\\n                    reach+=(1+reach);\\n                }\\n                else if(i<nums.size() && nums[i]<=1+reach) \\n                {\\n                    // reach = accumulate(v.begin(),v.end(),0);\\n                    reach+=(nums[i]);\\n                    i++;\\n                }\\n                else //array element is greater than (1+reach) then we add 1+reach to arr\\n                {\\n                    cnt++;\\n                    reach+=(1+reach);\\n                }\\n            }\\n        \\n        return cnt;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "int minPatches(vector<int>& nums, int n) {\\n        // make reach variable long long to avoid overflow\\n        long reach=0; //intitally reach is zero\\n        int i=0; \\n        int cnt=0;   // no of elemens added        \\n            while(reach<n)\\n            {\\n                if(i>=nums.size())   // if array becomes empty then for it\\n                {\\n                     cnt++;\\n                    reach+=(1+reach);\\n                }\\n                else if(i<nums.size() && nums[i]<=1+reach) \\n                {\\n                    // reach = accumulate(v.begin(),v.end(),0);\\n                    reach+=(nums[i]);\\n                    i++;\\n                }\\n                else //array element is greater than (1+reach) then we add 1+reach to arr\\n                {\\n                    cnt++;\\n                    reach+=(1+reach);\\n                }\\n            }\\n        \\n        return cnt;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2607920,
                "title": "python-greedy-tc-o-len-nums-o-log-n-sc-o-1",
                "content": "```\\nclass Solution(object):\\n    def minPatches(self, nums, n):\\n        #cur:current index, total: sum numbers before cur, patch: patched sofar\\n        #Algo: if sum before current index is greater that current keep going (O(len(nums)))\\n        #else enter sum+1(O(log(n))) --> O(len(nums)+Log(n))\\n        cur,total,patch,m=0,0,0,len(nums)\\n        while total<n:\\n            while total<n and cur<m and nums[cur]<=total+1:\\n                total+=nums[cur]\\n                cur+=1\\n            if total<n:\\n                patch+=1\\n                total+=total+1\\n        return patch\\n\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution(object):\\n    def minPatches(self, nums, n):\\n        #cur:current index, total: sum numbers before cur, patch: patched sofar\\n        #Algo: if sum before current index is greater that current keep going (O(len(nums)))\\n        #else enter sum+1(O(log(n))) --> O(len(nums)+Log(n))\\n        cur,total,patch,m=0,0,0,len(nums)\\n        while total<n:\\n            while total<n and cur<m and nums[cur]<=total+1:\\n                total+=nums[cur]\\n                cur+=1\\n            if total<n:\\n                patch+=1\\n                total+=total+1\\n        return patch\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2571189,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        long max = 0;\\n        int patches = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            while(nums[i] > (max + 1)){\\n                patches++;\\n                max += (max+1);\\n                if(max >= n) return patches;\\n            }\\n            max += nums[i];\\n            if(max >= n) return patches;\\n        }\\n        while(n > (max)){\\n            patches++;\\n            max += (max+1);\\n            if(max >= n) return patches;\\n        }\\n        return patches;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        long max = 0;\\n        int patches = 0;\\n        for(int i = 0; i < nums.length; i++){\\n            while(nums[i] > (max + 1)){\\n                patches++;\\n                max += (max+1);\\n                if(max >= n) return patches;\\n            }\\n            max += nums[i];\\n            if(max >= n) return patches;\\n        }\\n        while(n > (max)){\\n            patches++;\\n            max += (max+1);\\n            if(max >= n) return patches;\\n        }\\n        return patches;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2389937,
                "title": "easy-java-solution-using-greedy-algorithm-partial-sums",
                "content": "```\\nimport java.util.*;\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        ArrayList <Long> valuesToAdd = new ArrayList <Long>();\\n        long partialSum = 0; \\n        if (nums[0] == 1) {\\n            partialSum += nums[0];\\n            int i = 1; \\n            while (partialSum < n) {\\n                if (i < nums.length) {\\n                    while (partialSum + 1 < nums[i]) {\\n                        valuesToAdd.add (partialSum + 1);\\n                        partialSum += (partialSum + 1);\\n                        if (partialSum >= n) {\\n                        break;\\n                        }\\n                    }\\n                    partialSum += nums[i];\\n                    \\n                }\\n                else {\\n                    valuesToAdd.add (partialSum + 1);\\n                    partialSum += (partialSum + 1);\\n                }\\n                i++;\\n            }\\n        }\\n        else {\\n            partialSum += 1; \\n            valuesToAdd.add((long) 1);\\n            int i = 0; \\n            while (partialSum < n) {\\n                if (i < nums.length) {\\n                    while (partialSum + 1 < nums[i]) {\\n                        valuesToAdd.add (partialSum + 1);\\n                        partialSum += (partialSum + 1);\\n                    }\\n                    partialSum += nums[i];\\n                }\\n                else {\\n                    valuesToAdd.add (partialSum + 1);\\n                    partialSum += (partialSum + 1);\\n                }\\n                i++;\\n            }\\n        \\n            \\n        }\\n        System.out.println(valuesToAdd);\\n        return valuesToAdd.size();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nimport java.util.*;\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        ArrayList <Long> valuesToAdd = new ArrayList <Long>();\\n        long partialSum = 0; \\n        if (nums[0] == 1) {\\n            partialSum += nums[0];\\n            int i = 1; \\n            while (partialSum < n) {\\n                if (i < nums.length) {\\n                    while (partialSum + 1 < nums[i]) {\\n                        valuesToAdd.add (partialSum + 1);\\n                        partialSum += (partialSum + 1);\\n                        if (partialSum >= n) {\\n                        break;\\n                        }\\n                    }\\n                    partialSum += nums[i];\\n                    \\n                }\\n                else {\\n                    valuesToAdd.add (partialSum + 1);\\n                    partialSum += (partialSum + 1);\\n                }\\n                i++;\\n            }\\n        }\\n        else {\\n            partialSum += 1; \\n            valuesToAdd.add((long) 1);\\n            int i = 0; \\n            while (partialSum < n) {\\n                if (i < nums.length) {\\n                    while (partialSum + 1 < nums[i]) {\\n                        valuesToAdd.add (partialSum + 1);\\n                        partialSum += (partialSum + 1);\\n                    }\\n                    partialSum += nums[i];\\n                }\\n                else {\\n                    valuesToAdd.add (partialSum + 1);\\n                    partialSum += (partialSum + 1);\\n                }\\n                i++;\\n            }\\n        \\n            \\n        }\\n        System.out.println(valuesToAdd);\\n        return valuesToAdd.size();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2334045,
                "title": "easy-solution-with-full-explanation-multiset-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& a, int n) {\\n         int appends = 0;\\n         multiset<long> mset;\\n         for(int i=0; i<a.size(); i++) mset.insert(a[i]);\\n         long long sm  = 1;\\n         while(sm<n) {\\n             sm = 1;\\n             for(long x : mset) {\\n                  if(sm<x) {\\n                      break;\\n                  }else {\\n                      sm+=x;\\n                  }\\n             }\\n             // smallest number(Sm) that can\\'t be created between 1..N from the elements in the multiset!\\n             if(sm<=n) { \\n                 appends++;      \\n                 mset.insert(sm);  // append that number(Sm) in the multiset!\\n             }\\n             // now we can create sum from 1...number(Sm) from the elements of multiset!\\n         }\\n        return appends;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& a, int n) {\\n         int appends = 0;\\n         multiset<long> mset;\\n         for(int i=0; i<a.size(); i++) mset.insert(a[i]);\\n         long long sm  = 1;\\n         while(sm<n) {\\n             sm = 1;\\n             for(long x : mset) {\\n                  if(sm<x) {\\n                      break;\\n                  }else {\\n                      sm+=x;\\n                  }\\n             }\\n             // smallest number(Sm) that can\\'t be created between 1..N from the elements in the multiset!\\n             if(sm<=n) { \\n                 appends++;      \\n                 mset.insert(sm);  // append that number(Sm) in the multiset!\\n             }\\n             // now we can create sum from 1...number(Sm) from the elements of multiset!\\n         }\\n        return appends;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2330942,
                "title": "solution-c",
                "content": "class Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        int count{};\\n        long long sum{};\\n        for(auto x : nums)\\n        {\\n            if(sum >= n)\\n                break;\\n            \\n            while(sum + 1 < x && sum < n)\\n            {\\n                count++;\\n                sum += sum + 1;\\n            }\\n            \\n            sum += x;\\n        }\\n        \\n        while(sum + 1 < n)\\n        {\\n            count++;\\n            sum += sum + 1;\\n        }\\n        \\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        int count{}",
                "codeTag": "Java"
            },
            {
                "id": 2272185,
                "title": "c-greedy",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, long long n) {\\n        sort(nums.begin(),nums.end());\\n        long long h = 0, re = 0;\\n        for(int i = 0;i<nums.size() && h<n;++i){\\n            long long a = min(n+1,(long long)nums[i]);\\n            while(h<a-1){ h = 2*h+1; re++; }\\n            h+=a;\\n        }\\n        while(h<n-1){ h = 2*h+1; re++; }\\n        return re;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, long long n) {\\n        sort(nums.begin(),nums.end());\\n        long long h = 0, re = 0;\\n        for(int i = 0;i<nums.size() && h<n;++i){\\n            long long a = min(n+1,(long long)nums[i]);\\n            while(h<a-1){ h = 2*h+1; re++; }\\n            h+=a;\\n        }\\n        while(h<n-1){ h = 2*h+1; re++; }\\n        return re;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2207361,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long sz = nums.size(), patches = 0;\\n        long long lim = 0;\\n        for(int i = 0; i < sz; i++) {\\n            int mn = nums[i], mx = lim+nums[i];\\n            if(mn > lim+1) patches++, lim += lim+1, i--;\\n            else lim = mx;\\n            if(lim >= (long long)n) break;\\n        }\\n        \\n        while(lim < (long long)n) patches++, lim += lim+1;\\n        return patches;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long sz = nums.size(), patches = 0;\\n        long long lim = 0;\\n        for(int i = 0; i < sz; i++) {\\n            int mn = nums[i], mx = lim+nums[i];\\n            if(mn > lim+1) patches++, lim += lim+1, i--;\\n            else lim = mx;\\n            if(lim >= (long long)n) break;\\n        }\\n        \\n        while(lim < (long long)n) patches++, lim += lim+1;\\n        return patches;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2192542,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    \\n    int minPatches(vector<int>& nums, int n) {\\n        ll ans=0,count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]-ans>1)\\n            {\\n                int val=ans+1;\\n                ans+=val;\\n                count++;\\n                i--;\\n            }\\n            else{\\n                ans+=nums[i];\\n            }\\n            if(ans>=n)\\n                break;\\n        }\\n        \\n        while(ans<n)\\n        {\\n            int val=ans+1;\\n            ans+=val;\\n            count++;\\n        }\\n        \\n        return count;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    #define ll long long\\n    \\n    int minPatches(vector<int>& nums, int n) {\\n        ll ans=0,count=0;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n            if(nums[i]-ans>1)\\n            {\\n                int val=ans+1;\\n                ans+=val;\\n                count++;\\n                i--;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2175549,
                "title": "c-explaination",
                "content": "first solve this \\n1798. Maximum Number of Consecutive Values You Can Make\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int getMaximumConsecutive(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>sum+1)\\n                break;\\n            \\n                sum+=nums[i];\\n        }\\n        return sum+1;\\n    }\\n};\\n```\\n\\nso this is clear that \\n\\nif nums[i]<=sum+1\\n\\nthen we can form all consicutive numbers till  sum+nums[i]\\n\\nelse\\nwe need to add some number in middle \\n\\nadding numbers will generate a sequnce like\\n                                     \\nnums->  nums[i-1]  , sum+1 , 2*sum+2,        ...... (kth term)        nums[i]\\nsum  ->  sum  , 2*sum+1  ,  4*sum+3           \\n\\nk term of sum   === (2^k) * (sum+1)  -1  \\n\\nand the k th term is     >= nums[i]+1;\\n\\nafter inserting all the k values now  we can form all consicutive numbers till\\n\\n(2^k) * (sum+1)  -1  +nums[i]  ==>  nums[i-1] + (sum+1 ) + (2*sum+2) + (4*sum+3) ..+nums[i]\\n\\n\\n\\n\\n\\n\\n```\\ntypedef long long ll;\\ntypedef long double ld;\\n\\nclass Solution {\\npublic:\\n    \\n    int minPatches(vector<int>& nums, ll n) {\\n        \\n        \\n        ll res=0;\\n        \\n        int ans=0;\\n        \\n        int i=0;\\n        int m=nums.size();\\n        \\n        while(i<m && n>res)\\n        {\\n            int k=0;\\n            \\n            /*\\n            // so the orignal code shoulde be\\n            \\n            if(nums[i]<=n)\\n            {\\n            \\n            \\n            while((pow(2,k)*(res+1))<(ll)nums[i]))\\n                k++;\\n            \\n            }\\n            else\\n            {\\n                    while((pow(2,k)*(res+1))<=n)\\n                        k++;           \\n            }\\n            \\n            */\\n            while((pow(2,k)*(res+1))<=(min(n,(ll)nums[i]-1)))\\n            {\\n                k++;\\n            }\\n            \\n            ans+=k;\\n            \\n            if(nums[i]<=n)\\n            res=pow(2,k)*(res+1)+nums[i]-1;\\n            else\\n            res=pow(2,k)*(res+1)-1;\\n            \\n          \\n            i++;\\n        }\\n        \\n            int k=0;\\n            while((pow(2,k)*(res+1))<n)\\n            {\\n                k++;\\n            }\\n           \\n            ans+=k;\\n        \\n        return ans;\\n    }\\n};\\n\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int getMaximumConsecutive(vector<int>& nums) {\\n        sort(nums.begin(),nums.end());\\n        int n=nums.size();\\n        int sum=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(nums[i]>sum+1)\\n                break;\\n            \\n                sum+=nums[i];\\n        }\\n        return sum+1;\\n    }\\n};\\n```\n```\\ntypedef long long ll;\\ntypedef long double ld;\\n\\nclass Solution {\\npublic:\\n    \\n    int minPatches(vector<int>& nums, ll n) {\\n        \\n        \\n        ll res=0;\\n        \\n        int ans=0;\\n        \\n        int i=0;\\n        int m=nums.size();\\n        \\n        while(i<m && n>res)\\n        {\\n            int k=0;\\n            \\n            /*\\n            // so the orignal code shoulde be\\n            \\n            if(nums[i]<=n)\\n            {\\n            \\n            \\n            while((pow(2,k)*(res+1))<(ll)nums[i]))\\n                k++;\\n            \\n            }\\n            else\\n            {\\n                    while((pow(2,k)*(res+1))<=n)\\n                        k++;           \\n            }\\n            \\n            */\\n            while((pow(2,k)*(res+1))<=(min(n,(ll)nums[i]-1)))\\n            {\\n                k++;\\n            }\\n            \\n            ans+=k;\\n            \\n            if(nums[i]<=n)\\n            res=pow(2,k)*(res+1)+nums[i]-1;\\n            else\\n            res=pow(2,k)*(res+1)-1;\\n            \\n          \\n            i++;\\n        }\\n        \\n            int k=0;\\n            while((pow(2,k)*(res+1))<n)\\n            {\\n                k++;\\n            }\\n           \\n            ans+=k;\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2163814,
                "title": "c",
                "content": "(```) class Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        \\n        long ans = 0, maxi = 0, i = 0;\\n        \\n        while(maxi < n)\\n        {\\n            \\n            if(i < nums.size( ) && nums[i] <= maxi+1)\\n            {\\n                maxi = maxi + nums[i++];\\n            }\\n            else\\n            {\\n                ans++;\\n                \\n                maxi = maxi+ maxi+1;\\n            }\\n        }\\n        \\n        return ans;\\n        \\n       \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        \\n        long ans = 0, maxi = 0, i = 0;\\n        \\n        while(maxi < n)\\n        {\\n            \\n            if(i < nums.size( ) && nums[i] <= maxi+1)\\n            {\\n                maxi = maxi + nums[i++];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2141528,
                "title": "c-dp",
                "content": "```\\nclass Solution {\\npublic:\\n    int f_min (int a, int b) {\\n        return (a < b)? a : b;\\n    }\\n    int minPatches(vector<int>& nums, int n) {        \\n        unsigned int maxv = 0; // 1 ~ maxv are available\\n        int cnt = 0; // minimum count\\n        nums.push_back(n);\\n        for (int num : nums) {\\n            // if maxv + 1 < num, it can not make maxv + 1 ~ num - 1\\n            // After maxv + maxv+1, 1 ~ 2*maxv +1 are available\\n            while(maxv + 1 < num) { \\n                cnt += 1;                \\n                maxv += maxv+1;\\n                if(maxv >= n) return cnt;                \\n            }            \\n            maxv += num; // maxv + num are available                  \\n            if(maxv >= n){\\n                return cnt;                            \\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int f_min (int a, int b) {\\n        return (a < b)? a : b;\\n    }\\n    int minPatches(vector<int>& nums, int n) {        \\n        unsigned int maxv = 0; // 1 ~ maxv are available\\n        int cnt = 0; // minimum count\\n        nums.push_back(n);\\n        for (int num : nums) {\\n            // if maxv + 1 < num, it can not make maxv + 1 ~ num - 1\\n            // After maxv + maxv+1, 1 ~ 2*maxv +1 are available\\n            while(maxv + 1 < num) { \\n                cnt += 1;                \\n                maxv += maxv+1;\\n                if(maxv >= n) return cnt;                \\n            }            \\n            maxv += num; // maxv + num are available                  \\n            if(maxv >= n){\\n                return cnt;                            \\n            }\\n        }\\n        \\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2043462,
                "title": "faster-than-100-clumsily-explain",
                "content": "\\n```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n\\t#pre-process for convenience\\n        nums.append(n+1)\\n        t=1\\n        sum=1\\n        rs=0\\n        if nums[0]!=1:\\n            nums=[1]+nums\\n            rs+=1\\n# the idea is sum from index 0 to index i should cover 1 to that sum*2 then we go form left to right to cover upto n\\n        while sum<n:\\n            if sum<nums[t]-1:\\n                sum+=(sum+1)\\n                rs+=1\\n            else:\\n                sum+=nums[t]\\n                t+=1\\n        return rs\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minPatches(self, nums: List[int], n: int) -> int:\\n\\t#pre-process for convenience\\n        nums.append(n+1)\\n        t=1\\n        sum=1\\n        rs=0\\n        if nums[0]!=1:\\n            nums=[1]+nums\\n            rs+=1\\n# the idea is sum from index 0 to index i should cover 1 to that sum*2 then we go form left to right to cover upto n\\n        while sum<n:\\n            if sum<nums[t]-1:\\n                sum+=(sum+1)\\n                rs+=1\\n            else:\\n                sum+=nums[t]\\n                t+=1\\n        return rs\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2024786,
                "title": "greedy-solution-c-with-comment-explanation",
                "content": "\\npseudo code\\n\\ndefine covered is set of covered using elements of [] array.\\ndefine miss is smallest value which should be covered.\\ndefine ret is answer\\n\\nif nums[i] < miss\\n\\tcover <- cover + nums[i]\\n\\tif miss < cover+1 \\n\\t\\tmiss = cover +1\\n\\t\\t\\nelse\\n\\tcover = (miss-1) + miss\\n\\tmiss = cover + 1\\n\\tret+=\\n\\t\\n\\n```\\n\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n\\n        int ret = 0;\\n        int idx = 0;\\n        long long covered = 0;\\n        long long miss = 1;\\n        \\n        // define {} (covered) is set of covered using elements of [] array.\\n        // define miss is smallest value which should be covered.\\n        \\n        while (miss <= n) { // miss should be covered if miss < n\\n            if (idx < nums.size() && nums[idx] <= miss) { //if there are num <= miss in nums array, take num and update covered\\n                covered = covered + nums[idx]; // nums array could have same number, so, select nums[idx] will cover covered + nums[idx]\\n                long long tmpMiss = covered + 1; // next miss number\\n                \\n                //ex) if {1,2} are alreay covered, and miss = 3 => {1,2,1+3,2+3} will be covered if 3 is selected.\\n\\n                if (miss < tmpMiss) miss = tmpMiss;  //if covered number is over than miss, update miss // else -> miss target will not be changed\\n                idx++;\\n            }\\n            else { \\n                covered = (miss-1)+miss; // once pick miss num, it will cover {1 .... (miss-1) + miss}\\n                miss = covered+1;  // next miss number\\n                \\n                ret++;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n\\n        int ret = 0;\\n        int idx = 0;\\n        long long covered = 0;\\n        long long miss = 1;\\n        \\n        // define {} (covered) is set of covered using elements of [] array.\\n        // define miss is smallest value which should be covered.\\n        \\n        while (miss <= n) { // miss should be covered if miss < n\\n            if (idx < nums.size() && nums[idx] <= miss) { //if there are num <= miss in nums array, take num and update covered\\n                covered = covered + nums[idx]; // nums array could have same number, so, select nums[idx] will cover covered + nums[idx]\\n                long long tmpMiss = covered + 1; // next miss number\\n                \\n                //ex) if {1,2} are alreay covered, and miss = 3 => {1,2,1+3,2+3} will be covered if 3 is selected.\\n\\n                if (miss < tmpMiss) miss = tmpMiss;  //if covered number is over than miss, update miss // else -> miss target will not be changed\\n                idx++;\\n            }\\n            else { \\n                covered = (miss-1)+miss; // once pick miss num, it will cover {1 .... (miss-1) + miss}\\n                miss = covered+1;  // next miss number\\n                \\n                ret++;\\n            }\\n        }\\n\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2003267,
                "title": "inspired-by-lee215-solution",
                "content": "To understand this problem first understand it\\'s parent problem : [](http://)https://leetcode.com/problems/maximum-number-of-consecutive-values-you-can-make/\\n\\ncheckout @lee215 solution for parent problem : [](http://)https://leetcode.com/problems/maximum-number-of-consecutive-values-you-can-make/discuss/1118770/JavaC%2B%2BPython-Accumulate-the-Coins\\n\\nhe made this problem a cakewalk for me\\n\\n```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long sum=0,count=0;\\n        int i=0;\\n        while(i<nums.size() && sum<n)\\n        {\\n            if(nums[i]>sum+1)\\n            {\\n                sum+=sum+1;\\n                count++;\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                i++;\\n            }\\n        }\\n        while(sum<n)\\n        {\\n            sum+=sum+1;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        long long sum=0,count=0;\\n        int i=0;\\n        while(i<nums.size() && sum<n)\\n        {\\n            if(nums[i]>sum+1)\\n            {\\n                sum+=sum+1;\\n                count++;\\n            }\\n            else\\n            {\\n                sum+=nums[i];\\n                i++;\\n            }\\n        }\\n        while(sum<n)\\n        {\\n            sum+=sum+1;\\n            count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1942862,
                "title": "illegal-if-first-n-nums-possible-then-for-extra-k-belongs-to-1-n-1-n-k-nums-can-be-found",
                "content": "Just weird maths, frankly, this should not be asked in an interview if one does not claim maths as one of his/her skills. Although, visualization skill may help you here.\\n\\nPre-req: https://leetcode.com/problems/maximum-number-of-consecutive-values-you-can-make/\\nIf you know the solution of pre-req, then this one is just a piece of cake. \\n\\nAnyhow, I will try to explain this one. Let\\'s say, you can find the 1, 2, 3, 4, 5 already, and now you have an extra 4 which you can use.\\nSo, with that extra 4, if you will add it to 1 then you will find 5, if you will add it to 2 then you will find 6, and so on, if you will add it to 5 then you will find 9. So, if we had 1,2,3,4,5 and an extra 4, then we can always reach till 9. Hence, if you can create first N digits, and if you have an extra K which belongs to [1, N+1], then you can always find all the numbers till N + K.\\n\\n```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        nums.push_back(0);\\n        sort(nums.begin(), nums.end());\\n        long sum = 0;\\n        int ans = 0;\\n        for(int i = 1; i < nums.size(); i++){\\n            while((long)nums[i] > (long)(sum + 1)){\\n                ans++;\\n                sum += (long)(sum + 1);\\n                if(sum >= (long)n)\\n                    return ans;\\n            }\\n            sum += nums[i];\\n            if(sum >= (long)n)\\n                return ans;\\n        }\\n        while(sum < (long)n){\\n            ans++;\\n            sum += (long)(sum + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Math"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minPatches(vector<int>& nums, int n) {\\n        nums.push_back(0);\\n        sort(nums.begin(), nums.end());\\n        long sum = 0;\\n        int ans = 0;\\n        for(int i = 1; i < nums.size(); i++){\\n            while((long)nums[i] > (long)(sum + 1)){\\n                ans++;\\n                sum += (long)(sum + 1);\\n                if(sum >= (long)n)\\n                    return ans;\\n            }\\n            sum += nums[i];\\n            if(sum >= (long)n)\\n                return ans;\\n        }\\n        while(sum < (long)n){\\n            ans++;\\n            sum += (long)(sum + 1);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1902398,
                "title": "follow-up-of-1798-leetcode",
                "content": "the prerequsite to solve this question is to solve that 1798 leetcode then it will be easy to solve\\n```\\nlong long int sum = 0;\\nlong long int ind =0;\\nlong long int cnt =0;\\n\\nwhile(sum<n)\\n{\\n\\tif(ind<nums.size())\\n\\t{\\n\\t\\tif(nums[ind] <= sum+1)\\n\\t\\t{\\n\\t\\t\\tsum+= nums[ind];\\n\\t\\t\\tind++;    \\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcnt++;\\n\\t\\t\\tlong long int add = sum+1;\\n\\t\\t\\tsum+= add;\\n\\t\\t}\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tcnt++;\\n\\t\\tlong long int add = sum+1;\\n\\t\\tsum+= add;\\n\\t}\\n}\\n\\nreturn cnt;\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nlong long int sum = 0;\\nlong long int ind =0;\\nlong long int cnt =0;\\n\\nwhile(sum<n)\\n{\\n\\tif(ind<nums.size())\\n\\t{\\n\\t\\tif(nums[ind] <= sum+1)\\n\\t\\t{\\n\\t\\t\\tsum+= nums[ind];\\n\\t\\t\\tind++;    \\n\\t\\t}\\n\\t\\telse\\n\\t\\t{\\n\\t\\t\\tcnt++;\\n\\t\\t\\tlong long int add = sum+1;\\n\\t\\t\\tsum+= add;\\n\\t\\t}\\n\\t}\\n\\telse\\n\\t{\\n\\t\\tcnt++;\\n\\t\\tlong long int add = sum+1;\\n\\t\\tsum+= add;\\n\\t}\\n}\\n\\nreturn cnt;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1877308,
                "title": "most-popular-ans-explanation-in-comments",
                "content": "You may refer to the original answer [here](https://leetcode.com/problems/patching-array/discuss/78488/Solution-%2B-explanation), but i have tried to give a simpler explanation mathematically in the comments. (better read the original answer first and then come here)\\n\\nmissing_smallest is the smallest number missing in [1,n] and we try to make that first and do the rest.\\n\\n\\n\\n```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        \\n//         copy paste of most popular quesiotn\\n//         ishwar problem\\n        \\n        long missing_smallest=1;\\n        // i.e we try to make the missing first which is 1\\n        \\n        int counter=0;\\n        int insertions=0;\\n        \\n        \\n        \\n        while(missing_smallest<=n)\\n        {\\n            if(counter<nums.length && missing_smallest>= nums[counter])    \\n            {\\n//                 the equality in missing >=nums[i]\\n                /*\\n                we have 1, 2, .... missing -1\\n                \\n                therefore adding anything les than eual to  missing -1\\n                is fine as continutity \\n                \\n                if new new number is big like 1L\\n                then like many middle numbers would be lost.\\n                \\n                \\n                if missing == num[i] then also tbe continuity would be there\\n                as missing is added then missing +1 , missing +2 ... onwards\\n                \\n                */\\n\\n                \\n                missing_smallest+=nums[counter++];\\n                \\n            }\\n            \\n            else{\\n                missing_smallest*=2;\\n                //we have 1, 2, ...missing -1 , now on adding missing the highest term\\n//                  we get is missing -1 + missing , therefore next messing is 2 missing\\n                insertions++;\\n            }\\n                    \\n        }\\n        return insertions;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minPatches(int[] nums, int n) {\\n        \\n//         copy paste of most popular quesiotn\\n//         ishwar problem\\n        \\n        long missing_smallest=1;\\n        // i.e we try to make the missing first which is 1\\n        \\n        int counter=0;\\n        int insertions=0;\\n        \\n        \\n        \\n        while(missing_smallest<=n)\\n        {\\n            if(counter<nums.length && missing_smallest>= nums[counter])    \\n            {\\n//                 the equality in missing >=nums[i]\\n                /*\\n                we have 1, 2, .... missing -1\\n                \\n                therefore adding anything les than eual to  missing -1\\n                is fine as continutity \\n                \\n                if new new number is big like 1L\\n                then like many middle numbers would be lost.\\n                \\n                \\n                if missing == num[i] then also tbe continuity would be there\\n                as missing is added then missing +1 , missing +2 ... onwards\\n                \\n                */\\n\\n                \\n                missing_smallest+=nums[counter++];\\n                \\n            }\\n            \\n            else{\\n                missing_smallest*=2;\\n                //we have 1, 2, ...missing -1 , now on adding missing the highest term\\n//                  we get is missing -1 + missing , therefore next messing is 2 missing\\n                insertions++;\\n            }\\n                    \\n        }\\n        return insertions;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1839415,
                "title": "python-greedy",
                "content": "\\n```\\nclass Solution(object):\\n    def minPatches(self, nums, n):\\n        count=0\\n        i=1\\n        while(i<=n):\\n            if len(nums)>0 and i<nums[0]:\\n                count+=1\\n                i=i*2\\n            elif len(nums)>0 and  i==nums[0]:\\n                i=i*2\\n                nums.pop(0)\\n            elif len(nums)>0 and  i>nums[0]:\\n                while len(nums)>0 and (i>nums[0]):\\n                    i=i+nums[0]\\n                    nums.pop(0)\\n            elif len(nums)==0:\\n                count+=1\\n                i=i*2\\n        return count\\n        \\n            \\n",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "\\n```\\nclass Solution(object):\\n    def minPatches(self, nums, n):\\n        count=0\\n        i=1\\n        while(i<=n):\\n            if len(nums)>0 and i<nums[0]:\\n                count+=1\\n                i=i*2\\n            elif len(nums)>0 and  i==nums[0]:\\n                i=i*2\\n                nums.pop(0)\\n            elif len(nums)>0 and  i>nums[0]:\\n                while len(nums)>0 and (i>nums[0]):\\n                    i=i+nums[0]\\n                    nums.pop(0)\\n            elif len(nums)==0:\\n                count+=1\\n                i=i*2\\n        return count\\n        \\n            \\n",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1564582,
                "content": [
                    {
                        "username": "bravejia",
                        "content": "The question asked for the \"**minimum** number of patches required\". In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? \\n\\nThink about this example: nums = [1, 2, 3, 9].  We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1...1 is patched completely. After encountered 2, we know 1...3 (1+2) is patched completely. After we encountered 3, we know 1...6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don't miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 ... 7. Any number greater than 7 won't help here. Patching  8 will not help you get 7. So we have 7 numbers (1...7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1...13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1...22 is completely patched. If we still did't reach n, we can then patch 23, which makes 1...45 (22+23) completely patched. We continue until we reach n."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "I have to say, reading this problem and several explanation posts/discussion really inspire me a lot.\\n\\nAfter first time reading this problem, i am overwhelmed by so many cases/ possibilities. Well, typically this indicates dynamic programming.\\n\\nIt is so complicate because I am looking into a wrong way.\\n\\nsay have A =  [1, 2, 10, 20]  n=100\\n\\nThings come to my mind is, how many kinds of different sums could A provide? by adding a number how those sums to expand? how to choose this one number to add? \\n\\nHow about this.\\nsay have A=[1] n = 100 . how do we patch ?\\n\\nwell, everybody knows need to patch 2 fist,  of course there is no other choice.\\n\\nthen, it is not hard to realize we need to add 4 then, because [1,2] result in 1,2,3 and stopped at 3.\\n\\nOf course we would choose 4 as next, compared  1,2,3  ( adding 1 give us all sum as : 1,2,3,4  however adding 4 give us all sum as : 1,2,3,4,5,6,7)\\n\\nI believe now everybody knows how to tackle this problem. Same thing repeat till  100 is reached.\\n\\nlet's look back at A = [1,2,10,20]\\n\\nby having 1 ,2, we have all possible sum as : 1,2,3\\n\\nthen we have 10\\n\\n(10 itself gives a sum as 10, and  having 10 of course all sums from 10 to 13)\\n\\nbut we missing 4 - 10 here, and the one we miss immediately is 4\\n\\nIt is the same thing as we only have [1,2], we also miss 4. what we do is adding 4 \\n\\nsame here, we add 4, and now we have all sum as : 1, 2, 3, 4, 5, 6, 7\\n\\nSo u can tell now, though we having a number 10 sitting there, but what we doing is exactly the same as we not having it. just patch the immediate missing one.\\n\\nU can just consider 10 the same as we patch it when it is the immediate missing.  after a patching, it expand our all sum. \\n\\nSo the question, why having A = [1] instead of A = [1,2, 10, 20] make this problem much easier?\\nBecause A = [1] kindly remove the confusing and unnecessary complicity for us. \\n\\nNow let's look back those complicity, the reason it is so complicated is because we are not seeing the pattern but seeing the whole issue at one time instead. \\n\\nThe pattern is the subproblem and the connection between subproblems.\\n\\nIn this case a subproblem is when we have A = [...] which could give us all sum from 1 to k. \\nhow to we patch to expand it most efficiently ?  we know now by adding k+1\\n\\nYes, and that is the connection. now subproblem turns into A = [...., k+1] give us all sum from\\n1 to k+k+1 , how to expand it most efficiently?\\n\\nEach question could be very unique, but as long as it is a dp/greedy problem. Everybody knows, find the subproblem and find the transfer between subproblems. \\n\\nBut how to discover the subproblem is really challenging always.\\n\\nTill now, I would say, first is never be deceived by the complicity. \\nsecond, analyze what is the final goal of the question.\\nthird, how does this problem initiate, what is the first stage.\\nforth, again, understand in context what is A step\\nfinally, figure out the restrictions/requirement to transfer between steps\\n\\nThis is just for my own information and for yours if needed the same."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "Seriously I saw this problem and I couldn't come up with any working approach at all, and this really lowers my confidence for interviews.."
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "I am just wondering how the question maker came up with this question."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "lucasmus",
                        "content": "You already can make any sum leading up to the next missing number, in this case 7. You want to make progress as fast as possible because you need the least amount of patches. 7 gives you more progress than 4 (7 + 6 vs 4 + 6). Each time you achieve a new cover range, the individual numbers (7 or 4) are not relevant anymore for the algorithm, only the covered range is relevant. Therefore there is no moment were a particular number (say 4) would come in handy."
                    },
                    {
                        "username": "lly_0620",
                        "content": "Example 2:\\n\\nInput: nums = [1,5,10], n = 20\\nOutput: 2\\nExplanation: The two patches can be [2, 4].\\n\\nmy question is how about [2,3]???"
                    },
                    {
                        "username": "ayuanx",
                        "content": "It seems there isn't a comprehensive, easy to understand explanation in other posts yet. So let me explain it here.\\n\\nSuppose we already have a collection of positive integers `A, B, C, ..., M` that can cover a range of `[1, k]` inclusive by selectively summing up some elements in our collection. We know that `k` must be the total sum of all elements in our collection.\\n\\nLet's take in a new integer `N = k+1` into our collection. We know without thinking that we can cover a range of `[1, (k+1)]` now, but is that all? No! Instead we claim that we can cover a range of `[1, (k+1)+k]` now. Why? Let's list all the numbers we have to cover between range `[(k+1)+1, (k+1)+k]` to make such claim true:\\n> (k+1) + `1`\\n> (k+1) + `2`\\n> (k+1) + `3`\\n> (k+1) + `...`\\n> (k+1) + `k`\\n\\nFocus on the highlighted addends. They simply form a range of `[1, k]`, which is already covered by our original collection `A, B, C, ..., M`. And the other addend `k+1` is merely our new member `N` we just took it.\\n\\nSo in summary, if we can already cover range `[1, k]`, then by just taking in the next integer `k+1`, we will be able to cover a new range `[1, k+(k+1)]` inclusive. There is no need to investigate all the numbers falling in between one by one as explained above.\\n\\nOnce you understand this, the rest would be quite simple.\\n\\nFor example, when we already have a coverage of `[1, k-1]`. What would be our best choice in order to cover `k`? No doubt, our best choice would be `k` itself. Because choosing any integer greater than `k` would not help. On the other hand, if we choose an integer smaller than `k`, let's say we choose `j` and `j < k`. We can write it as `k = j + P`, `P` is a positive integer. So from the above proof, we know that if we choose `j`, our new coverage would be `[1, (k-1)+j]`. But if we choose `k` itself, our new coverage would be `[1, (k-1)+k]`, and `(k-1)+k = (k-1)+(j+P) = ((k-1)+j) + P`, which means we will have greater coverage by choosing `k` instead of `j`. Since `j` can be any positive integer smaller than `k`. QED."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Solving a hard problem always feels so empowering :D"
                    },
                    {
                        "username": "alhazeem",
                        "content": "the most accurate explanation\n\nhttps://www.youtube. com/watch?v=N-tcCOCNSZY"
                    }
                ]
            },
            {
                "id": 1567956,
                "content": [
                    {
                        "username": "bravejia",
                        "content": "The question asked for the \"**minimum** number of patches required\". In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? \\n\\nThink about this example: nums = [1, 2, 3, 9].  We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1...1 is patched completely. After encountered 2, we know 1...3 (1+2) is patched completely. After we encountered 3, we know 1...6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don't miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 ... 7. Any number greater than 7 won't help here. Patching  8 will not help you get 7. So we have 7 numbers (1...7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1...13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1...22 is completely patched. If we still did't reach n, we can then patch 23, which makes 1...45 (22+23) completely patched. We continue until we reach n."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "I have to say, reading this problem and several explanation posts/discussion really inspire me a lot.\\n\\nAfter first time reading this problem, i am overwhelmed by so many cases/ possibilities. Well, typically this indicates dynamic programming.\\n\\nIt is so complicate because I am looking into a wrong way.\\n\\nsay have A =  [1, 2, 10, 20]  n=100\\n\\nThings come to my mind is, how many kinds of different sums could A provide? by adding a number how those sums to expand? how to choose this one number to add? \\n\\nHow about this.\\nsay have A=[1] n = 100 . how do we patch ?\\n\\nwell, everybody knows need to patch 2 fist,  of course there is no other choice.\\n\\nthen, it is not hard to realize we need to add 4 then, because [1,2] result in 1,2,3 and stopped at 3.\\n\\nOf course we would choose 4 as next, compared  1,2,3  ( adding 1 give us all sum as : 1,2,3,4  however adding 4 give us all sum as : 1,2,3,4,5,6,7)\\n\\nI believe now everybody knows how to tackle this problem. Same thing repeat till  100 is reached.\\n\\nlet's look back at A = [1,2,10,20]\\n\\nby having 1 ,2, we have all possible sum as : 1,2,3\\n\\nthen we have 10\\n\\n(10 itself gives a sum as 10, and  having 10 of course all sums from 10 to 13)\\n\\nbut we missing 4 - 10 here, and the one we miss immediately is 4\\n\\nIt is the same thing as we only have [1,2], we also miss 4. what we do is adding 4 \\n\\nsame here, we add 4, and now we have all sum as : 1, 2, 3, 4, 5, 6, 7\\n\\nSo u can tell now, though we having a number 10 sitting there, but what we doing is exactly the same as we not having it. just patch the immediate missing one.\\n\\nU can just consider 10 the same as we patch it when it is the immediate missing.  after a patching, it expand our all sum. \\n\\nSo the question, why having A = [1] instead of A = [1,2, 10, 20] make this problem much easier?\\nBecause A = [1] kindly remove the confusing and unnecessary complicity for us. \\n\\nNow let's look back those complicity, the reason it is so complicated is because we are not seeing the pattern but seeing the whole issue at one time instead. \\n\\nThe pattern is the subproblem and the connection between subproblems.\\n\\nIn this case a subproblem is when we have A = [...] which could give us all sum from 1 to k. \\nhow to we patch to expand it most efficiently ?  we know now by adding k+1\\n\\nYes, and that is the connection. now subproblem turns into A = [...., k+1] give us all sum from\\n1 to k+k+1 , how to expand it most efficiently?\\n\\nEach question could be very unique, but as long as it is a dp/greedy problem. Everybody knows, find the subproblem and find the transfer between subproblems. \\n\\nBut how to discover the subproblem is really challenging always.\\n\\nTill now, I would say, first is never be deceived by the complicity. \\nsecond, analyze what is the final goal of the question.\\nthird, how does this problem initiate, what is the first stage.\\nforth, again, understand in context what is A step\\nfinally, figure out the restrictions/requirement to transfer between steps\\n\\nThis is just for my own information and for yours if needed the same."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "Seriously I saw this problem and I couldn't come up with any working approach at all, and this really lowers my confidence for interviews.."
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "I am just wondering how the question maker came up with this question."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "lucasmus",
                        "content": "You already can make any sum leading up to the next missing number, in this case 7. You want to make progress as fast as possible because you need the least amount of patches. 7 gives you more progress than 4 (7 + 6 vs 4 + 6). Each time you achieve a new cover range, the individual numbers (7 or 4) are not relevant anymore for the algorithm, only the covered range is relevant. Therefore there is no moment were a particular number (say 4) would come in handy."
                    },
                    {
                        "username": "lly_0620",
                        "content": "Example 2:\\n\\nInput: nums = [1,5,10], n = 20\\nOutput: 2\\nExplanation: The two patches can be [2, 4].\\n\\nmy question is how about [2,3]???"
                    },
                    {
                        "username": "ayuanx",
                        "content": "It seems there isn't a comprehensive, easy to understand explanation in other posts yet. So let me explain it here.\\n\\nSuppose we already have a collection of positive integers `A, B, C, ..., M` that can cover a range of `[1, k]` inclusive by selectively summing up some elements in our collection. We know that `k` must be the total sum of all elements in our collection.\\n\\nLet's take in a new integer `N = k+1` into our collection. We know without thinking that we can cover a range of `[1, (k+1)]` now, but is that all? No! Instead we claim that we can cover a range of `[1, (k+1)+k]` now. Why? Let's list all the numbers we have to cover between range `[(k+1)+1, (k+1)+k]` to make such claim true:\\n> (k+1) + `1`\\n> (k+1) + `2`\\n> (k+1) + `3`\\n> (k+1) + `...`\\n> (k+1) + `k`\\n\\nFocus on the highlighted addends. They simply form a range of `[1, k]`, which is already covered by our original collection `A, B, C, ..., M`. And the other addend `k+1` is merely our new member `N` we just took it.\\n\\nSo in summary, if we can already cover range `[1, k]`, then by just taking in the next integer `k+1`, we will be able to cover a new range `[1, k+(k+1)]` inclusive. There is no need to investigate all the numbers falling in between one by one as explained above.\\n\\nOnce you understand this, the rest would be quite simple.\\n\\nFor example, when we already have a coverage of `[1, k-1]`. What would be our best choice in order to cover `k`? No doubt, our best choice would be `k` itself. Because choosing any integer greater than `k` would not help. On the other hand, if we choose an integer smaller than `k`, let's say we choose `j` and `j < k`. We can write it as `k = j + P`, `P` is a positive integer. So from the above proof, we know that if we choose `j`, our new coverage would be `[1, (k-1)+j]`. But if we choose `k` itself, our new coverage would be `[1, (k-1)+k]`, and `(k-1)+k = (k-1)+(j+P) = ((k-1)+j) + P`, which means we will have greater coverage by choosing `k` instead of `j`. Since `j` can be any positive integer smaller than `k`. QED."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Solving a hard problem always feels so empowering :D"
                    },
                    {
                        "username": "alhazeem",
                        "content": "the most accurate explanation\n\nhttps://www.youtube. com/watch?v=N-tcCOCNSZY"
                    }
                ]
            },
            {
                "id": 1571590,
                "content": [
                    {
                        "username": "bravejia",
                        "content": "The question asked for the \"**minimum** number of patches required\". In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? \\n\\nThink about this example: nums = [1, 2, 3, 9].  We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1...1 is patched completely. After encountered 2, we know 1...3 (1+2) is patched completely. After we encountered 3, we know 1...6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don't miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 ... 7. Any number greater than 7 won't help here. Patching  8 will not help you get 7. So we have 7 numbers (1...7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1...13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1...22 is completely patched. If we still did't reach n, we can then patch 23, which makes 1...45 (22+23) completely patched. We continue until we reach n."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "I have to say, reading this problem and several explanation posts/discussion really inspire me a lot.\\n\\nAfter first time reading this problem, i am overwhelmed by so many cases/ possibilities. Well, typically this indicates dynamic programming.\\n\\nIt is so complicate because I am looking into a wrong way.\\n\\nsay have A =  [1, 2, 10, 20]  n=100\\n\\nThings come to my mind is, how many kinds of different sums could A provide? by adding a number how those sums to expand? how to choose this one number to add? \\n\\nHow about this.\\nsay have A=[1] n = 100 . how do we patch ?\\n\\nwell, everybody knows need to patch 2 fist,  of course there is no other choice.\\n\\nthen, it is not hard to realize we need to add 4 then, because [1,2] result in 1,2,3 and stopped at 3.\\n\\nOf course we would choose 4 as next, compared  1,2,3  ( adding 1 give us all sum as : 1,2,3,4  however adding 4 give us all sum as : 1,2,3,4,5,6,7)\\n\\nI believe now everybody knows how to tackle this problem. Same thing repeat till  100 is reached.\\n\\nlet's look back at A = [1,2,10,20]\\n\\nby having 1 ,2, we have all possible sum as : 1,2,3\\n\\nthen we have 10\\n\\n(10 itself gives a sum as 10, and  having 10 of course all sums from 10 to 13)\\n\\nbut we missing 4 - 10 here, and the one we miss immediately is 4\\n\\nIt is the same thing as we only have [1,2], we also miss 4. what we do is adding 4 \\n\\nsame here, we add 4, and now we have all sum as : 1, 2, 3, 4, 5, 6, 7\\n\\nSo u can tell now, though we having a number 10 sitting there, but what we doing is exactly the same as we not having it. just patch the immediate missing one.\\n\\nU can just consider 10 the same as we patch it when it is the immediate missing.  after a patching, it expand our all sum. \\n\\nSo the question, why having A = [1] instead of A = [1,2, 10, 20] make this problem much easier?\\nBecause A = [1] kindly remove the confusing and unnecessary complicity for us. \\n\\nNow let's look back those complicity, the reason it is so complicated is because we are not seeing the pattern but seeing the whole issue at one time instead. \\n\\nThe pattern is the subproblem and the connection between subproblems.\\n\\nIn this case a subproblem is when we have A = [...] which could give us all sum from 1 to k. \\nhow to we patch to expand it most efficiently ?  we know now by adding k+1\\n\\nYes, and that is the connection. now subproblem turns into A = [...., k+1] give us all sum from\\n1 to k+k+1 , how to expand it most efficiently?\\n\\nEach question could be very unique, but as long as it is a dp/greedy problem. Everybody knows, find the subproblem and find the transfer between subproblems. \\n\\nBut how to discover the subproblem is really challenging always.\\n\\nTill now, I would say, first is never be deceived by the complicity. \\nsecond, analyze what is the final goal of the question.\\nthird, how does this problem initiate, what is the first stage.\\nforth, again, understand in context what is A step\\nfinally, figure out the restrictions/requirement to transfer between steps\\n\\nThis is just for my own information and for yours if needed the same."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "Seriously I saw this problem and I couldn't come up with any working approach at all, and this really lowers my confidence for interviews.."
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "I am just wondering how the question maker came up with this question."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "lucasmus",
                        "content": "You already can make any sum leading up to the next missing number, in this case 7. You want to make progress as fast as possible because you need the least amount of patches. 7 gives you more progress than 4 (7 + 6 vs 4 + 6). Each time you achieve a new cover range, the individual numbers (7 or 4) are not relevant anymore for the algorithm, only the covered range is relevant. Therefore there is no moment were a particular number (say 4) would come in handy."
                    },
                    {
                        "username": "lly_0620",
                        "content": "Example 2:\\n\\nInput: nums = [1,5,10], n = 20\\nOutput: 2\\nExplanation: The two patches can be [2, 4].\\n\\nmy question is how about [2,3]???"
                    },
                    {
                        "username": "ayuanx",
                        "content": "It seems there isn't a comprehensive, easy to understand explanation in other posts yet. So let me explain it here.\\n\\nSuppose we already have a collection of positive integers `A, B, C, ..., M` that can cover a range of `[1, k]` inclusive by selectively summing up some elements in our collection. We know that `k` must be the total sum of all elements in our collection.\\n\\nLet's take in a new integer `N = k+1` into our collection. We know without thinking that we can cover a range of `[1, (k+1)]` now, but is that all? No! Instead we claim that we can cover a range of `[1, (k+1)+k]` now. Why? Let's list all the numbers we have to cover between range `[(k+1)+1, (k+1)+k]` to make such claim true:\\n> (k+1) + `1`\\n> (k+1) + `2`\\n> (k+1) + `3`\\n> (k+1) + `...`\\n> (k+1) + `k`\\n\\nFocus on the highlighted addends. They simply form a range of `[1, k]`, which is already covered by our original collection `A, B, C, ..., M`. And the other addend `k+1` is merely our new member `N` we just took it.\\n\\nSo in summary, if we can already cover range `[1, k]`, then by just taking in the next integer `k+1`, we will be able to cover a new range `[1, k+(k+1)]` inclusive. There is no need to investigate all the numbers falling in between one by one as explained above.\\n\\nOnce you understand this, the rest would be quite simple.\\n\\nFor example, when we already have a coverage of `[1, k-1]`. What would be our best choice in order to cover `k`? No doubt, our best choice would be `k` itself. Because choosing any integer greater than `k` would not help. On the other hand, if we choose an integer smaller than `k`, let's say we choose `j` and `j < k`. We can write it as `k = j + P`, `P` is a positive integer. So from the above proof, we know that if we choose `j`, our new coverage would be `[1, (k-1)+j]`. But if we choose `k` itself, our new coverage would be `[1, (k-1)+k]`, and `(k-1)+k = (k-1)+(j+P) = ((k-1)+j) + P`, which means we will have greater coverage by choosing `k` instead of `j`. Since `j` can be any positive integer smaller than `k`. QED."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Solving a hard problem always feels so empowering :D"
                    },
                    {
                        "username": "alhazeem",
                        "content": "the most accurate explanation\n\nhttps://www.youtube. com/watch?v=N-tcCOCNSZY"
                    }
                ]
            },
            {
                "id": 1570292,
                "content": [
                    {
                        "username": "bravejia",
                        "content": "The question asked for the \"**minimum** number of patches required\". In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? \\n\\nThink about this example: nums = [1, 2, 3, 9].  We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1...1 is patched completely. After encountered 2, we know 1...3 (1+2) is patched completely. After we encountered 3, we know 1...6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don't miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 ... 7. Any number greater than 7 won't help here. Patching  8 will not help you get 7. So we have 7 numbers (1...7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1...13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1...22 is completely patched. If we still did't reach n, we can then patch 23, which makes 1...45 (22+23) completely patched. We continue until we reach n."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "I have to say, reading this problem and several explanation posts/discussion really inspire me a lot.\\n\\nAfter first time reading this problem, i am overwhelmed by so many cases/ possibilities. Well, typically this indicates dynamic programming.\\n\\nIt is so complicate because I am looking into a wrong way.\\n\\nsay have A =  [1, 2, 10, 20]  n=100\\n\\nThings come to my mind is, how many kinds of different sums could A provide? by adding a number how those sums to expand? how to choose this one number to add? \\n\\nHow about this.\\nsay have A=[1] n = 100 . how do we patch ?\\n\\nwell, everybody knows need to patch 2 fist,  of course there is no other choice.\\n\\nthen, it is not hard to realize we need to add 4 then, because [1,2] result in 1,2,3 and stopped at 3.\\n\\nOf course we would choose 4 as next, compared  1,2,3  ( adding 1 give us all sum as : 1,2,3,4  however adding 4 give us all sum as : 1,2,3,4,5,6,7)\\n\\nI believe now everybody knows how to tackle this problem. Same thing repeat till  100 is reached.\\n\\nlet's look back at A = [1,2,10,20]\\n\\nby having 1 ,2, we have all possible sum as : 1,2,3\\n\\nthen we have 10\\n\\n(10 itself gives a sum as 10, and  having 10 of course all sums from 10 to 13)\\n\\nbut we missing 4 - 10 here, and the one we miss immediately is 4\\n\\nIt is the same thing as we only have [1,2], we also miss 4. what we do is adding 4 \\n\\nsame here, we add 4, and now we have all sum as : 1, 2, 3, 4, 5, 6, 7\\n\\nSo u can tell now, though we having a number 10 sitting there, but what we doing is exactly the same as we not having it. just patch the immediate missing one.\\n\\nU can just consider 10 the same as we patch it when it is the immediate missing.  after a patching, it expand our all sum. \\n\\nSo the question, why having A = [1] instead of A = [1,2, 10, 20] make this problem much easier?\\nBecause A = [1] kindly remove the confusing and unnecessary complicity for us. \\n\\nNow let's look back those complicity, the reason it is so complicated is because we are not seeing the pattern but seeing the whole issue at one time instead. \\n\\nThe pattern is the subproblem and the connection between subproblems.\\n\\nIn this case a subproblem is when we have A = [...] which could give us all sum from 1 to k. \\nhow to we patch to expand it most efficiently ?  we know now by adding k+1\\n\\nYes, and that is the connection. now subproblem turns into A = [...., k+1] give us all sum from\\n1 to k+k+1 , how to expand it most efficiently?\\n\\nEach question could be very unique, but as long as it is a dp/greedy problem. Everybody knows, find the subproblem and find the transfer between subproblems. \\n\\nBut how to discover the subproblem is really challenging always.\\n\\nTill now, I would say, first is never be deceived by the complicity. \\nsecond, analyze what is the final goal of the question.\\nthird, how does this problem initiate, what is the first stage.\\nforth, again, understand in context what is A step\\nfinally, figure out the restrictions/requirement to transfer between steps\\n\\nThis is just for my own information and for yours if needed the same."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "Seriously I saw this problem and I couldn't come up with any working approach at all, and this really lowers my confidence for interviews.."
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "I am just wondering how the question maker came up with this question."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "lucasmus",
                        "content": "You already can make any sum leading up to the next missing number, in this case 7. You want to make progress as fast as possible because you need the least amount of patches. 7 gives you more progress than 4 (7 + 6 vs 4 + 6). Each time you achieve a new cover range, the individual numbers (7 or 4) are not relevant anymore for the algorithm, only the covered range is relevant. Therefore there is no moment were a particular number (say 4) would come in handy."
                    },
                    {
                        "username": "lly_0620",
                        "content": "Example 2:\\n\\nInput: nums = [1,5,10], n = 20\\nOutput: 2\\nExplanation: The two patches can be [2, 4].\\n\\nmy question is how about [2,3]???"
                    },
                    {
                        "username": "ayuanx",
                        "content": "It seems there isn't a comprehensive, easy to understand explanation in other posts yet. So let me explain it here.\\n\\nSuppose we already have a collection of positive integers `A, B, C, ..., M` that can cover a range of `[1, k]` inclusive by selectively summing up some elements in our collection. We know that `k` must be the total sum of all elements in our collection.\\n\\nLet's take in a new integer `N = k+1` into our collection. We know without thinking that we can cover a range of `[1, (k+1)]` now, but is that all? No! Instead we claim that we can cover a range of `[1, (k+1)+k]` now. Why? Let's list all the numbers we have to cover between range `[(k+1)+1, (k+1)+k]` to make such claim true:\\n> (k+1) + `1`\\n> (k+1) + `2`\\n> (k+1) + `3`\\n> (k+1) + `...`\\n> (k+1) + `k`\\n\\nFocus on the highlighted addends. They simply form a range of `[1, k]`, which is already covered by our original collection `A, B, C, ..., M`. And the other addend `k+1` is merely our new member `N` we just took it.\\n\\nSo in summary, if we can already cover range `[1, k]`, then by just taking in the next integer `k+1`, we will be able to cover a new range `[1, k+(k+1)]` inclusive. There is no need to investigate all the numbers falling in between one by one as explained above.\\n\\nOnce you understand this, the rest would be quite simple.\\n\\nFor example, when we already have a coverage of `[1, k-1]`. What would be our best choice in order to cover `k`? No doubt, our best choice would be `k` itself. Because choosing any integer greater than `k` would not help. On the other hand, if we choose an integer smaller than `k`, let's say we choose `j` and `j < k`. We can write it as `k = j + P`, `P` is a positive integer. So from the above proof, we know that if we choose `j`, our new coverage would be `[1, (k-1)+j]`. But if we choose `k` itself, our new coverage would be `[1, (k-1)+k]`, and `(k-1)+k = (k-1)+(j+P) = ((k-1)+j) + P`, which means we will have greater coverage by choosing `k` instead of `j`. Since `j` can be any positive integer smaller than `k`. QED."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Solving a hard problem always feels so empowering :D"
                    },
                    {
                        "username": "alhazeem",
                        "content": "the most accurate explanation\n\nhttps://www.youtube. com/watch?v=N-tcCOCNSZY"
                    }
                ]
            },
            {
                "id": 1567955,
                "content": [
                    {
                        "username": "bravejia",
                        "content": "The question asked for the \"**minimum** number of patches required\". In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? \\n\\nThink about this example: nums = [1, 2, 3, 9].  We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1...1 is patched completely. After encountered 2, we know 1...3 (1+2) is patched completely. After we encountered 3, we know 1...6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don't miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 ... 7. Any number greater than 7 won't help here. Patching  8 will not help you get 7. So we have 7 numbers (1...7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1...13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1...22 is completely patched. If we still did't reach n, we can then patch 23, which makes 1...45 (22+23) completely patched. We continue until we reach n."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "I have to say, reading this problem and several explanation posts/discussion really inspire me a lot.\\n\\nAfter first time reading this problem, i am overwhelmed by so many cases/ possibilities. Well, typically this indicates dynamic programming.\\n\\nIt is so complicate because I am looking into a wrong way.\\n\\nsay have A =  [1, 2, 10, 20]  n=100\\n\\nThings come to my mind is, how many kinds of different sums could A provide? by adding a number how those sums to expand? how to choose this one number to add? \\n\\nHow about this.\\nsay have A=[1] n = 100 . how do we patch ?\\n\\nwell, everybody knows need to patch 2 fist,  of course there is no other choice.\\n\\nthen, it is not hard to realize we need to add 4 then, because [1,2] result in 1,2,3 and stopped at 3.\\n\\nOf course we would choose 4 as next, compared  1,2,3  ( adding 1 give us all sum as : 1,2,3,4  however adding 4 give us all sum as : 1,2,3,4,5,6,7)\\n\\nI believe now everybody knows how to tackle this problem. Same thing repeat till  100 is reached.\\n\\nlet's look back at A = [1,2,10,20]\\n\\nby having 1 ,2, we have all possible sum as : 1,2,3\\n\\nthen we have 10\\n\\n(10 itself gives a sum as 10, and  having 10 of course all sums from 10 to 13)\\n\\nbut we missing 4 - 10 here, and the one we miss immediately is 4\\n\\nIt is the same thing as we only have [1,2], we also miss 4. what we do is adding 4 \\n\\nsame here, we add 4, and now we have all sum as : 1, 2, 3, 4, 5, 6, 7\\n\\nSo u can tell now, though we having a number 10 sitting there, but what we doing is exactly the same as we not having it. just patch the immediate missing one.\\n\\nU can just consider 10 the same as we patch it when it is the immediate missing.  after a patching, it expand our all sum. \\n\\nSo the question, why having A = [1] instead of A = [1,2, 10, 20] make this problem much easier?\\nBecause A = [1] kindly remove the confusing and unnecessary complicity for us. \\n\\nNow let's look back those complicity, the reason it is so complicated is because we are not seeing the pattern but seeing the whole issue at one time instead. \\n\\nThe pattern is the subproblem and the connection between subproblems.\\n\\nIn this case a subproblem is when we have A = [...] which could give us all sum from 1 to k. \\nhow to we patch to expand it most efficiently ?  we know now by adding k+1\\n\\nYes, and that is the connection. now subproblem turns into A = [...., k+1] give us all sum from\\n1 to k+k+1 , how to expand it most efficiently?\\n\\nEach question could be very unique, but as long as it is a dp/greedy problem. Everybody knows, find the subproblem and find the transfer between subproblems. \\n\\nBut how to discover the subproblem is really challenging always.\\n\\nTill now, I would say, first is never be deceived by the complicity. \\nsecond, analyze what is the final goal of the question.\\nthird, how does this problem initiate, what is the first stage.\\nforth, again, understand in context what is A step\\nfinally, figure out the restrictions/requirement to transfer between steps\\n\\nThis is just for my own information and for yours if needed the same."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "Seriously I saw this problem and I couldn't come up with any working approach at all, and this really lowers my confidence for interviews.."
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "I am just wondering how the question maker came up with this question."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "lucasmus",
                        "content": "You already can make any sum leading up to the next missing number, in this case 7. You want to make progress as fast as possible because you need the least amount of patches. 7 gives you more progress than 4 (7 + 6 vs 4 + 6). Each time you achieve a new cover range, the individual numbers (7 or 4) are not relevant anymore for the algorithm, only the covered range is relevant. Therefore there is no moment were a particular number (say 4) would come in handy."
                    },
                    {
                        "username": "lly_0620",
                        "content": "Example 2:\\n\\nInput: nums = [1,5,10], n = 20\\nOutput: 2\\nExplanation: The two patches can be [2, 4].\\n\\nmy question is how about [2,3]???"
                    },
                    {
                        "username": "ayuanx",
                        "content": "It seems there isn't a comprehensive, easy to understand explanation in other posts yet. So let me explain it here.\\n\\nSuppose we already have a collection of positive integers `A, B, C, ..., M` that can cover a range of `[1, k]` inclusive by selectively summing up some elements in our collection. We know that `k` must be the total sum of all elements in our collection.\\n\\nLet's take in a new integer `N = k+1` into our collection. We know without thinking that we can cover a range of `[1, (k+1)]` now, but is that all? No! Instead we claim that we can cover a range of `[1, (k+1)+k]` now. Why? Let's list all the numbers we have to cover between range `[(k+1)+1, (k+1)+k]` to make such claim true:\\n> (k+1) + `1`\\n> (k+1) + `2`\\n> (k+1) + `3`\\n> (k+1) + `...`\\n> (k+1) + `k`\\n\\nFocus on the highlighted addends. They simply form a range of `[1, k]`, which is already covered by our original collection `A, B, C, ..., M`. And the other addend `k+1` is merely our new member `N` we just took it.\\n\\nSo in summary, if we can already cover range `[1, k]`, then by just taking in the next integer `k+1`, we will be able to cover a new range `[1, k+(k+1)]` inclusive. There is no need to investigate all the numbers falling in between one by one as explained above.\\n\\nOnce you understand this, the rest would be quite simple.\\n\\nFor example, when we already have a coverage of `[1, k-1]`. What would be our best choice in order to cover `k`? No doubt, our best choice would be `k` itself. Because choosing any integer greater than `k` would not help. On the other hand, if we choose an integer smaller than `k`, let's say we choose `j` and `j < k`. We can write it as `k = j + P`, `P` is a positive integer. So from the above proof, we know that if we choose `j`, our new coverage would be `[1, (k-1)+j]`. But if we choose `k` itself, our new coverage would be `[1, (k-1)+k]`, and `(k-1)+k = (k-1)+(j+P) = ((k-1)+j) + P`, which means we will have greater coverage by choosing `k` instead of `j`. Since `j` can be any positive integer smaller than `k`. QED."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Solving a hard problem always feels so empowering :D"
                    },
                    {
                        "username": "alhazeem",
                        "content": "the most accurate explanation\n\nhttps://www.youtube. com/watch?v=N-tcCOCNSZY"
                    }
                ]
            },
            {
                "id": 1572379,
                "content": [
                    {
                        "username": "bravejia",
                        "content": "The question asked for the \"**minimum** number of patches required\". In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? \\n\\nThink about this example: nums = [1, 2, 3, 9].  We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1...1 is patched completely. After encountered 2, we know 1...3 (1+2) is patched completely. After we encountered 3, we know 1...6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don't miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 ... 7. Any number greater than 7 won't help here. Patching  8 will not help you get 7. So we have 7 numbers (1...7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1...13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1...22 is completely patched. If we still did't reach n, we can then patch 23, which makes 1...45 (22+23) completely patched. We continue until we reach n."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "I have to say, reading this problem and several explanation posts/discussion really inspire me a lot.\\n\\nAfter first time reading this problem, i am overwhelmed by so many cases/ possibilities. Well, typically this indicates dynamic programming.\\n\\nIt is so complicate because I am looking into a wrong way.\\n\\nsay have A =  [1, 2, 10, 20]  n=100\\n\\nThings come to my mind is, how many kinds of different sums could A provide? by adding a number how those sums to expand? how to choose this one number to add? \\n\\nHow about this.\\nsay have A=[1] n = 100 . how do we patch ?\\n\\nwell, everybody knows need to patch 2 fist,  of course there is no other choice.\\n\\nthen, it is not hard to realize we need to add 4 then, because [1,2] result in 1,2,3 and stopped at 3.\\n\\nOf course we would choose 4 as next, compared  1,2,3  ( adding 1 give us all sum as : 1,2,3,4  however adding 4 give us all sum as : 1,2,3,4,5,6,7)\\n\\nI believe now everybody knows how to tackle this problem. Same thing repeat till  100 is reached.\\n\\nlet's look back at A = [1,2,10,20]\\n\\nby having 1 ,2, we have all possible sum as : 1,2,3\\n\\nthen we have 10\\n\\n(10 itself gives a sum as 10, and  having 10 of course all sums from 10 to 13)\\n\\nbut we missing 4 - 10 here, and the one we miss immediately is 4\\n\\nIt is the same thing as we only have [1,2], we also miss 4. what we do is adding 4 \\n\\nsame here, we add 4, and now we have all sum as : 1, 2, 3, 4, 5, 6, 7\\n\\nSo u can tell now, though we having a number 10 sitting there, but what we doing is exactly the same as we not having it. just patch the immediate missing one.\\n\\nU can just consider 10 the same as we patch it when it is the immediate missing.  after a patching, it expand our all sum. \\n\\nSo the question, why having A = [1] instead of A = [1,2, 10, 20] make this problem much easier?\\nBecause A = [1] kindly remove the confusing and unnecessary complicity for us. \\n\\nNow let's look back those complicity, the reason it is so complicated is because we are not seeing the pattern but seeing the whole issue at one time instead. \\n\\nThe pattern is the subproblem and the connection between subproblems.\\n\\nIn this case a subproblem is when we have A = [...] which could give us all sum from 1 to k. \\nhow to we patch to expand it most efficiently ?  we know now by adding k+1\\n\\nYes, and that is the connection. now subproblem turns into A = [...., k+1] give us all sum from\\n1 to k+k+1 , how to expand it most efficiently?\\n\\nEach question could be very unique, but as long as it is a dp/greedy problem. Everybody knows, find the subproblem and find the transfer between subproblems. \\n\\nBut how to discover the subproblem is really challenging always.\\n\\nTill now, I would say, first is never be deceived by the complicity. \\nsecond, analyze what is the final goal of the question.\\nthird, how does this problem initiate, what is the first stage.\\nforth, again, understand in context what is A step\\nfinally, figure out the restrictions/requirement to transfer between steps\\n\\nThis is just for my own information and for yours if needed the same."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "Seriously I saw this problem and I couldn't come up with any working approach at all, and this really lowers my confidence for interviews.."
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "I am just wondering how the question maker came up with this question."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "lucasmus",
                        "content": "You already can make any sum leading up to the next missing number, in this case 7. You want to make progress as fast as possible because you need the least amount of patches. 7 gives you more progress than 4 (7 + 6 vs 4 + 6). Each time you achieve a new cover range, the individual numbers (7 or 4) are not relevant anymore for the algorithm, only the covered range is relevant. Therefore there is no moment were a particular number (say 4) would come in handy."
                    },
                    {
                        "username": "lly_0620",
                        "content": "Example 2:\\n\\nInput: nums = [1,5,10], n = 20\\nOutput: 2\\nExplanation: The two patches can be [2, 4].\\n\\nmy question is how about [2,3]???"
                    },
                    {
                        "username": "ayuanx",
                        "content": "It seems there isn't a comprehensive, easy to understand explanation in other posts yet. So let me explain it here.\\n\\nSuppose we already have a collection of positive integers `A, B, C, ..., M` that can cover a range of `[1, k]` inclusive by selectively summing up some elements in our collection. We know that `k` must be the total sum of all elements in our collection.\\n\\nLet's take in a new integer `N = k+1` into our collection. We know without thinking that we can cover a range of `[1, (k+1)]` now, but is that all? No! Instead we claim that we can cover a range of `[1, (k+1)+k]` now. Why? Let's list all the numbers we have to cover between range `[(k+1)+1, (k+1)+k]` to make such claim true:\\n> (k+1) + `1`\\n> (k+1) + `2`\\n> (k+1) + `3`\\n> (k+1) + `...`\\n> (k+1) + `k`\\n\\nFocus on the highlighted addends. They simply form a range of `[1, k]`, which is already covered by our original collection `A, B, C, ..., M`. And the other addend `k+1` is merely our new member `N` we just took it.\\n\\nSo in summary, if we can already cover range `[1, k]`, then by just taking in the next integer `k+1`, we will be able to cover a new range `[1, k+(k+1)]` inclusive. There is no need to investigate all the numbers falling in between one by one as explained above.\\n\\nOnce you understand this, the rest would be quite simple.\\n\\nFor example, when we already have a coverage of `[1, k-1]`. What would be our best choice in order to cover `k`? No doubt, our best choice would be `k` itself. Because choosing any integer greater than `k` would not help. On the other hand, if we choose an integer smaller than `k`, let's say we choose `j` and `j < k`. We can write it as `k = j + P`, `P` is a positive integer. So from the above proof, we know that if we choose `j`, our new coverage would be `[1, (k-1)+j]`. But if we choose `k` itself, our new coverage would be `[1, (k-1)+k]`, and `(k-1)+k = (k-1)+(j+P) = ((k-1)+j) + P`, which means we will have greater coverage by choosing `k` instead of `j`. Since `j` can be any positive integer smaller than `k`. QED."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Solving a hard problem always feels so empowering :D"
                    },
                    {
                        "username": "alhazeem",
                        "content": "the most accurate explanation\n\nhttps://www.youtube. com/watch?v=N-tcCOCNSZY"
                    }
                ]
            },
            {
                "id": 1571589,
                "content": [
                    {
                        "username": "bravejia",
                        "content": "The question asked for the \"**minimum** number of patches required\". In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? \\n\\nThink about this example: nums = [1, 2, 3, 9].  We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1...1 is patched completely. After encountered 2, we know 1...3 (1+2) is patched completely. After we encountered 3, we know 1...6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don't miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 ... 7. Any number greater than 7 won't help here. Patching  8 will not help you get 7. So we have 7 numbers (1...7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1...13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1...22 is completely patched. If we still did't reach n, we can then patch 23, which makes 1...45 (22+23) completely patched. We continue until we reach n."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "I have to say, reading this problem and several explanation posts/discussion really inspire me a lot.\\n\\nAfter first time reading this problem, i am overwhelmed by so many cases/ possibilities. Well, typically this indicates dynamic programming.\\n\\nIt is so complicate because I am looking into a wrong way.\\n\\nsay have A =  [1, 2, 10, 20]  n=100\\n\\nThings come to my mind is, how many kinds of different sums could A provide? by adding a number how those sums to expand? how to choose this one number to add? \\n\\nHow about this.\\nsay have A=[1] n = 100 . how do we patch ?\\n\\nwell, everybody knows need to patch 2 fist,  of course there is no other choice.\\n\\nthen, it is not hard to realize we need to add 4 then, because [1,2] result in 1,2,3 and stopped at 3.\\n\\nOf course we would choose 4 as next, compared  1,2,3  ( adding 1 give us all sum as : 1,2,3,4  however adding 4 give us all sum as : 1,2,3,4,5,6,7)\\n\\nI believe now everybody knows how to tackle this problem. Same thing repeat till  100 is reached.\\n\\nlet's look back at A = [1,2,10,20]\\n\\nby having 1 ,2, we have all possible sum as : 1,2,3\\n\\nthen we have 10\\n\\n(10 itself gives a sum as 10, and  having 10 of course all sums from 10 to 13)\\n\\nbut we missing 4 - 10 here, and the one we miss immediately is 4\\n\\nIt is the same thing as we only have [1,2], we also miss 4. what we do is adding 4 \\n\\nsame here, we add 4, and now we have all sum as : 1, 2, 3, 4, 5, 6, 7\\n\\nSo u can tell now, though we having a number 10 sitting there, but what we doing is exactly the same as we not having it. just patch the immediate missing one.\\n\\nU can just consider 10 the same as we patch it when it is the immediate missing.  after a patching, it expand our all sum. \\n\\nSo the question, why having A = [1] instead of A = [1,2, 10, 20] make this problem much easier?\\nBecause A = [1] kindly remove the confusing and unnecessary complicity for us. \\n\\nNow let's look back those complicity, the reason it is so complicated is because we are not seeing the pattern but seeing the whole issue at one time instead. \\n\\nThe pattern is the subproblem and the connection between subproblems.\\n\\nIn this case a subproblem is when we have A = [...] which could give us all sum from 1 to k. \\nhow to we patch to expand it most efficiently ?  we know now by adding k+1\\n\\nYes, and that is the connection. now subproblem turns into A = [...., k+1] give us all sum from\\n1 to k+k+1 , how to expand it most efficiently?\\n\\nEach question could be very unique, but as long as it is a dp/greedy problem. Everybody knows, find the subproblem and find the transfer between subproblems. \\n\\nBut how to discover the subproblem is really challenging always.\\n\\nTill now, I would say, first is never be deceived by the complicity. \\nsecond, analyze what is the final goal of the question.\\nthird, how does this problem initiate, what is the first stage.\\nforth, again, understand in context what is A step\\nfinally, figure out the restrictions/requirement to transfer between steps\\n\\nThis is just for my own information and for yours if needed the same."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "Seriously I saw this problem and I couldn't come up with any working approach at all, and this really lowers my confidence for interviews.."
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "I am just wondering how the question maker came up with this question."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "lucasmus",
                        "content": "You already can make any sum leading up to the next missing number, in this case 7. You want to make progress as fast as possible because you need the least amount of patches. 7 gives you more progress than 4 (7 + 6 vs 4 + 6). Each time you achieve a new cover range, the individual numbers (7 or 4) are not relevant anymore for the algorithm, only the covered range is relevant. Therefore there is no moment were a particular number (say 4) would come in handy."
                    },
                    {
                        "username": "lly_0620",
                        "content": "Example 2:\\n\\nInput: nums = [1,5,10], n = 20\\nOutput: 2\\nExplanation: The two patches can be [2, 4].\\n\\nmy question is how about [2,3]???"
                    },
                    {
                        "username": "ayuanx",
                        "content": "It seems there isn't a comprehensive, easy to understand explanation in other posts yet. So let me explain it here.\\n\\nSuppose we already have a collection of positive integers `A, B, C, ..., M` that can cover a range of `[1, k]` inclusive by selectively summing up some elements in our collection. We know that `k` must be the total sum of all elements in our collection.\\n\\nLet's take in a new integer `N = k+1` into our collection. We know without thinking that we can cover a range of `[1, (k+1)]` now, but is that all? No! Instead we claim that we can cover a range of `[1, (k+1)+k]` now. Why? Let's list all the numbers we have to cover between range `[(k+1)+1, (k+1)+k]` to make such claim true:\\n> (k+1) + `1`\\n> (k+1) + `2`\\n> (k+1) + `3`\\n> (k+1) + `...`\\n> (k+1) + `k`\\n\\nFocus on the highlighted addends. They simply form a range of `[1, k]`, which is already covered by our original collection `A, B, C, ..., M`. And the other addend `k+1` is merely our new member `N` we just took it.\\n\\nSo in summary, if we can already cover range `[1, k]`, then by just taking in the next integer `k+1`, we will be able to cover a new range `[1, k+(k+1)]` inclusive. There is no need to investigate all the numbers falling in between one by one as explained above.\\n\\nOnce you understand this, the rest would be quite simple.\\n\\nFor example, when we already have a coverage of `[1, k-1]`. What would be our best choice in order to cover `k`? No doubt, our best choice would be `k` itself. Because choosing any integer greater than `k` would not help. On the other hand, if we choose an integer smaller than `k`, let's say we choose `j` and `j < k`. We can write it as `k = j + P`, `P` is a positive integer. So from the above proof, we know that if we choose `j`, our new coverage would be `[1, (k-1)+j]`. But if we choose `k` itself, our new coverage would be `[1, (k-1)+k]`, and `(k-1)+k = (k-1)+(j+P) = ((k-1)+j) + P`, which means we will have greater coverage by choosing `k` instead of `j`. Since `j` can be any positive integer smaller than `k`. QED."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Solving a hard problem always feels so empowering :D"
                    },
                    {
                        "username": "alhazeem",
                        "content": "the most accurate explanation\n\nhttps://www.youtube. com/watch?v=N-tcCOCNSZY"
                    }
                ]
            },
            {
                "id": 1567250,
                "content": [
                    {
                        "username": "bravejia",
                        "content": "The question asked for the \"**minimum** number of patches required\". In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? \\n\\nThink about this example: nums = [1, 2, 3, 9].  We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1...1 is patched completely. After encountered 2, we know 1...3 (1+2) is patched completely. After we encountered 3, we know 1...6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don't miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 ... 7. Any number greater than 7 won't help here. Patching  8 will not help you get 7. So we have 7 numbers (1...7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1...13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1...22 is completely patched. If we still did't reach n, we can then patch 23, which makes 1...45 (22+23) completely patched. We continue until we reach n."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "I have to say, reading this problem and several explanation posts/discussion really inspire me a lot.\\n\\nAfter first time reading this problem, i am overwhelmed by so many cases/ possibilities. Well, typically this indicates dynamic programming.\\n\\nIt is so complicate because I am looking into a wrong way.\\n\\nsay have A =  [1, 2, 10, 20]  n=100\\n\\nThings come to my mind is, how many kinds of different sums could A provide? by adding a number how those sums to expand? how to choose this one number to add? \\n\\nHow about this.\\nsay have A=[1] n = 100 . how do we patch ?\\n\\nwell, everybody knows need to patch 2 fist,  of course there is no other choice.\\n\\nthen, it is not hard to realize we need to add 4 then, because [1,2] result in 1,2,3 and stopped at 3.\\n\\nOf course we would choose 4 as next, compared  1,2,3  ( adding 1 give us all sum as : 1,2,3,4  however adding 4 give us all sum as : 1,2,3,4,5,6,7)\\n\\nI believe now everybody knows how to tackle this problem. Same thing repeat till  100 is reached.\\n\\nlet's look back at A = [1,2,10,20]\\n\\nby having 1 ,2, we have all possible sum as : 1,2,3\\n\\nthen we have 10\\n\\n(10 itself gives a sum as 10, and  having 10 of course all sums from 10 to 13)\\n\\nbut we missing 4 - 10 here, and the one we miss immediately is 4\\n\\nIt is the same thing as we only have [1,2], we also miss 4. what we do is adding 4 \\n\\nsame here, we add 4, and now we have all sum as : 1, 2, 3, 4, 5, 6, 7\\n\\nSo u can tell now, though we having a number 10 sitting there, but what we doing is exactly the same as we not having it. just patch the immediate missing one.\\n\\nU can just consider 10 the same as we patch it when it is the immediate missing.  after a patching, it expand our all sum. \\n\\nSo the question, why having A = [1] instead of A = [1,2, 10, 20] make this problem much easier?\\nBecause A = [1] kindly remove the confusing and unnecessary complicity for us. \\n\\nNow let's look back those complicity, the reason it is so complicated is because we are not seeing the pattern but seeing the whole issue at one time instead. \\n\\nThe pattern is the subproblem and the connection between subproblems.\\n\\nIn this case a subproblem is when we have A = [...] which could give us all sum from 1 to k. \\nhow to we patch to expand it most efficiently ?  we know now by adding k+1\\n\\nYes, and that is the connection. now subproblem turns into A = [...., k+1] give us all sum from\\n1 to k+k+1 , how to expand it most efficiently?\\n\\nEach question could be very unique, but as long as it is a dp/greedy problem. Everybody knows, find the subproblem and find the transfer between subproblems. \\n\\nBut how to discover the subproblem is really challenging always.\\n\\nTill now, I would say, first is never be deceived by the complicity. \\nsecond, analyze what is the final goal of the question.\\nthird, how does this problem initiate, what is the first stage.\\nforth, again, understand in context what is A step\\nfinally, figure out the restrictions/requirement to transfer between steps\\n\\nThis is just for my own information and for yours if needed the same."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "Seriously I saw this problem and I couldn't come up with any working approach at all, and this really lowers my confidence for interviews.."
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "I am just wondering how the question maker came up with this question."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "lucasmus",
                        "content": "You already can make any sum leading up to the next missing number, in this case 7. You want to make progress as fast as possible because you need the least amount of patches. 7 gives you more progress than 4 (7 + 6 vs 4 + 6). Each time you achieve a new cover range, the individual numbers (7 or 4) are not relevant anymore for the algorithm, only the covered range is relevant. Therefore there is no moment were a particular number (say 4) would come in handy."
                    },
                    {
                        "username": "lly_0620",
                        "content": "Example 2:\\n\\nInput: nums = [1,5,10], n = 20\\nOutput: 2\\nExplanation: The two patches can be [2, 4].\\n\\nmy question is how about [2,3]???"
                    },
                    {
                        "username": "ayuanx",
                        "content": "It seems there isn't a comprehensive, easy to understand explanation in other posts yet. So let me explain it here.\\n\\nSuppose we already have a collection of positive integers `A, B, C, ..., M` that can cover a range of `[1, k]` inclusive by selectively summing up some elements in our collection. We know that `k` must be the total sum of all elements in our collection.\\n\\nLet's take in a new integer `N = k+1` into our collection. We know without thinking that we can cover a range of `[1, (k+1)]` now, but is that all? No! Instead we claim that we can cover a range of `[1, (k+1)+k]` now. Why? Let's list all the numbers we have to cover between range `[(k+1)+1, (k+1)+k]` to make such claim true:\\n> (k+1) + `1`\\n> (k+1) + `2`\\n> (k+1) + `3`\\n> (k+1) + `...`\\n> (k+1) + `k`\\n\\nFocus on the highlighted addends. They simply form a range of `[1, k]`, which is already covered by our original collection `A, B, C, ..., M`. And the other addend `k+1` is merely our new member `N` we just took it.\\n\\nSo in summary, if we can already cover range `[1, k]`, then by just taking in the next integer `k+1`, we will be able to cover a new range `[1, k+(k+1)]` inclusive. There is no need to investigate all the numbers falling in between one by one as explained above.\\n\\nOnce you understand this, the rest would be quite simple.\\n\\nFor example, when we already have a coverage of `[1, k-1]`. What would be our best choice in order to cover `k`? No doubt, our best choice would be `k` itself. Because choosing any integer greater than `k` would not help. On the other hand, if we choose an integer smaller than `k`, let's say we choose `j` and `j < k`. We can write it as `k = j + P`, `P` is a positive integer. So from the above proof, we know that if we choose `j`, our new coverage would be `[1, (k-1)+j]`. But if we choose `k` itself, our new coverage would be `[1, (k-1)+k]`, and `(k-1)+k = (k-1)+(j+P) = ((k-1)+j) + P`, which means we will have greater coverage by choosing `k` instead of `j`. Since `j` can be any positive integer smaller than `k`. QED."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Solving a hard problem always feels so empowering :D"
                    },
                    {
                        "username": "alhazeem",
                        "content": "the most accurate explanation\n\nhttps://www.youtube. com/watch?v=N-tcCOCNSZY"
                    }
                ]
            },
            {
                "id": 1875414,
                "content": [
                    {
                        "username": "bravejia",
                        "content": "The question asked for the \"**minimum** number of patches required\". In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? \\n\\nThink about this example: nums = [1, 2, 3, 9].  We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1...1 is patched completely. After encountered 2, we know 1...3 (1+2) is patched completely. After we encountered 3, we know 1...6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don't miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 ... 7. Any number greater than 7 won't help here. Patching  8 will not help you get 7. So we have 7 numbers (1...7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1...13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1...22 is completely patched. If we still did't reach n, we can then patch 23, which makes 1...45 (22+23) completely patched. We continue until we reach n."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "I have to say, reading this problem and several explanation posts/discussion really inspire me a lot.\\n\\nAfter first time reading this problem, i am overwhelmed by so many cases/ possibilities. Well, typically this indicates dynamic programming.\\n\\nIt is so complicate because I am looking into a wrong way.\\n\\nsay have A =  [1, 2, 10, 20]  n=100\\n\\nThings come to my mind is, how many kinds of different sums could A provide? by adding a number how those sums to expand? how to choose this one number to add? \\n\\nHow about this.\\nsay have A=[1] n = 100 . how do we patch ?\\n\\nwell, everybody knows need to patch 2 fist,  of course there is no other choice.\\n\\nthen, it is not hard to realize we need to add 4 then, because [1,2] result in 1,2,3 and stopped at 3.\\n\\nOf course we would choose 4 as next, compared  1,2,3  ( adding 1 give us all sum as : 1,2,3,4  however adding 4 give us all sum as : 1,2,3,4,5,6,7)\\n\\nI believe now everybody knows how to tackle this problem. Same thing repeat till  100 is reached.\\n\\nlet's look back at A = [1,2,10,20]\\n\\nby having 1 ,2, we have all possible sum as : 1,2,3\\n\\nthen we have 10\\n\\n(10 itself gives a sum as 10, and  having 10 of course all sums from 10 to 13)\\n\\nbut we missing 4 - 10 here, and the one we miss immediately is 4\\n\\nIt is the same thing as we only have [1,2], we also miss 4. what we do is adding 4 \\n\\nsame here, we add 4, and now we have all sum as : 1, 2, 3, 4, 5, 6, 7\\n\\nSo u can tell now, though we having a number 10 sitting there, but what we doing is exactly the same as we not having it. just patch the immediate missing one.\\n\\nU can just consider 10 the same as we patch it when it is the immediate missing.  after a patching, it expand our all sum. \\n\\nSo the question, why having A = [1] instead of A = [1,2, 10, 20] make this problem much easier?\\nBecause A = [1] kindly remove the confusing and unnecessary complicity for us. \\n\\nNow let's look back those complicity, the reason it is so complicated is because we are not seeing the pattern but seeing the whole issue at one time instead. \\n\\nThe pattern is the subproblem and the connection between subproblems.\\n\\nIn this case a subproblem is when we have A = [...] which could give us all sum from 1 to k. \\nhow to we patch to expand it most efficiently ?  we know now by adding k+1\\n\\nYes, and that is the connection. now subproblem turns into A = [...., k+1] give us all sum from\\n1 to k+k+1 , how to expand it most efficiently?\\n\\nEach question could be very unique, but as long as it is a dp/greedy problem. Everybody knows, find the subproblem and find the transfer between subproblems. \\n\\nBut how to discover the subproblem is really challenging always.\\n\\nTill now, I would say, first is never be deceived by the complicity. \\nsecond, analyze what is the final goal of the question.\\nthird, how does this problem initiate, what is the first stage.\\nforth, again, understand in context what is A step\\nfinally, figure out the restrictions/requirement to transfer between steps\\n\\nThis is just for my own information and for yours if needed the same."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "Seriously I saw this problem and I couldn't come up with any working approach at all, and this really lowers my confidence for interviews.."
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "I am just wondering how the question maker came up with this question."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "lucasmus",
                        "content": "You already can make any sum leading up to the next missing number, in this case 7. You want to make progress as fast as possible because you need the least amount of patches. 7 gives you more progress than 4 (7 + 6 vs 4 + 6). Each time you achieve a new cover range, the individual numbers (7 or 4) are not relevant anymore for the algorithm, only the covered range is relevant. Therefore there is no moment were a particular number (say 4) would come in handy."
                    },
                    {
                        "username": "lly_0620",
                        "content": "Example 2:\\n\\nInput: nums = [1,5,10], n = 20\\nOutput: 2\\nExplanation: The two patches can be [2, 4].\\n\\nmy question is how about [2,3]???"
                    },
                    {
                        "username": "ayuanx",
                        "content": "It seems there isn't a comprehensive, easy to understand explanation in other posts yet. So let me explain it here.\\n\\nSuppose we already have a collection of positive integers `A, B, C, ..., M` that can cover a range of `[1, k]` inclusive by selectively summing up some elements in our collection. We know that `k` must be the total sum of all elements in our collection.\\n\\nLet's take in a new integer `N = k+1` into our collection. We know without thinking that we can cover a range of `[1, (k+1)]` now, but is that all? No! Instead we claim that we can cover a range of `[1, (k+1)+k]` now. Why? Let's list all the numbers we have to cover between range `[(k+1)+1, (k+1)+k]` to make such claim true:\\n> (k+1) + `1`\\n> (k+1) + `2`\\n> (k+1) + `3`\\n> (k+1) + `...`\\n> (k+1) + `k`\\n\\nFocus on the highlighted addends. They simply form a range of `[1, k]`, which is already covered by our original collection `A, B, C, ..., M`. And the other addend `k+1` is merely our new member `N` we just took it.\\n\\nSo in summary, if we can already cover range `[1, k]`, then by just taking in the next integer `k+1`, we will be able to cover a new range `[1, k+(k+1)]` inclusive. There is no need to investigate all the numbers falling in between one by one as explained above.\\n\\nOnce you understand this, the rest would be quite simple.\\n\\nFor example, when we already have a coverage of `[1, k-1]`. What would be our best choice in order to cover `k`? No doubt, our best choice would be `k` itself. Because choosing any integer greater than `k` would not help. On the other hand, if we choose an integer smaller than `k`, let's say we choose `j` and `j < k`. We can write it as `k = j + P`, `P` is a positive integer. So from the above proof, we know that if we choose `j`, our new coverage would be `[1, (k-1)+j]`. But if we choose `k` itself, our new coverage would be `[1, (k-1)+k]`, and `(k-1)+k = (k-1)+(j+P) = ((k-1)+j) + P`, which means we will have greater coverage by choosing `k` instead of `j`. Since `j` can be any positive integer smaller than `k`. QED."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Solving a hard problem always feels so empowering :D"
                    },
                    {
                        "username": "alhazeem",
                        "content": "the most accurate explanation\n\nhttps://www.youtube. com/watch?v=N-tcCOCNSZY"
                    }
                ]
            },
            {
                "id": 1751811,
                "content": [
                    {
                        "username": "bravejia",
                        "content": "The question asked for the \"**minimum** number of patches required\". In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? \\n\\nThink about this example: nums = [1, 2, 3, 9].  We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1...1 is patched completely. After encountered 2, we know 1...3 (1+2) is patched completely. After we encountered 3, we know 1...6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don't miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 ... 7. Any number greater than 7 won't help here. Patching  8 will not help you get 7. So we have 7 numbers (1...7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1...13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1...22 is completely patched. If we still did't reach n, we can then patch 23, which makes 1...45 (22+23) completely patched. We continue until we reach n."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "I have to say, reading this problem and several explanation posts/discussion really inspire me a lot.\\n\\nAfter first time reading this problem, i am overwhelmed by so many cases/ possibilities. Well, typically this indicates dynamic programming.\\n\\nIt is so complicate because I am looking into a wrong way.\\n\\nsay have A =  [1, 2, 10, 20]  n=100\\n\\nThings come to my mind is, how many kinds of different sums could A provide? by adding a number how those sums to expand? how to choose this one number to add? \\n\\nHow about this.\\nsay have A=[1] n = 100 . how do we patch ?\\n\\nwell, everybody knows need to patch 2 fist,  of course there is no other choice.\\n\\nthen, it is not hard to realize we need to add 4 then, because [1,2] result in 1,2,3 and stopped at 3.\\n\\nOf course we would choose 4 as next, compared  1,2,3  ( adding 1 give us all sum as : 1,2,3,4  however adding 4 give us all sum as : 1,2,3,4,5,6,7)\\n\\nI believe now everybody knows how to tackle this problem. Same thing repeat till  100 is reached.\\n\\nlet's look back at A = [1,2,10,20]\\n\\nby having 1 ,2, we have all possible sum as : 1,2,3\\n\\nthen we have 10\\n\\n(10 itself gives a sum as 10, and  having 10 of course all sums from 10 to 13)\\n\\nbut we missing 4 - 10 here, and the one we miss immediately is 4\\n\\nIt is the same thing as we only have [1,2], we also miss 4. what we do is adding 4 \\n\\nsame here, we add 4, and now we have all sum as : 1, 2, 3, 4, 5, 6, 7\\n\\nSo u can tell now, though we having a number 10 sitting there, but what we doing is exactly the same as we not having it. just patch the immediate missing one.\\n\\nU can just consider 10 the same as we patch it when it is the immediate missing.  after a patching, it expand our all sum. \\n\\nSo the question, why having A = [1] instead of A = [1,2, 10, 20] make this problem much easier?\\nBecause A = [1] kindly remove the confusing and unnecessary complicity for us. \\n\\nNow let's look back those complicity, the reason it is so complicated is because we are not seeing the pattern but seeing the whole issue at one time instead. \\n\\nThe pattern is the subproblem and the connection between subproblems.\\n\\nIn this case a subproblem is when we have A = [...] which could give us all sum from 1 to k. \\nhow to we patch to expand it most efficiently ?  we know now by adding k+1\\n\\nYes, and that is the connection. now subproblem turns into A = [...., k+1] give us all sum from\\n1 to k+k+1 , how to expand it most efficiently?\\n\\nEach question could be very unique, but as long as it is a dp/greedy problem. Everybody knows, find the subproblem and find the transfer between subproblems. \\n\\nBut how to discover the subproblem is really challenging always.\\n\\nTill now, I would say, first is never be deceived by the complicity. \\nsecond, analyze what is the final goal of the question.\\nthird, how does this problem initiate, what is the first stage.\\nforth, again, understand in context what is A step\\nfinally, figure out the restrictions/requirement to transfer between steps\\n\\nThis is just for my own information and for yours if needed the same."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "Seriously I saw this problem and I couldn't come up with any working approach at all, and this really lowers my confidence for interviews.."
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "I am just wondering how the question maker came up with this question."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "lucasmus",
                        "content": "You already can make any sum leading up to the next missing number, in this case 7. You want to make progress as fast as possible because you need the least amount of patches. 7 gives you more progress than 4 (7 + 6 vs 4 + 6). Each time you achieve a new cover range, the individual numbers (7 or 4) are not relevant anymore for the algorithm, only the covered range is relevant. Therefore there is no moment were a particular number (say 4) would come in handy."
                    },
                    {
                        "username": "lly_0620",
                        "content": "Example 2:\\n\\nInput: nums = [1,5,10], n = 20\\nOutput: 2\\nExplanation: The two patches can be [2, 4].\\n\\nmy question is how about [2,3]???"
                    },
                    {
                        "username": "ayuanx",
                        "content": "It seems there isn't a comprehensive, easy to understand explanation in other posts yet. So let me explain it here.\\n\\nSuppose we already have a collection of positive integers `A, B, C, ..., M` that can cover a range of `[1, k]` inclusive by selectively summing up some elements in our collection. We know that `k` must be the total sum of all elements in our collection.\\n\\nLet's take in a new integer `N = k+1` into our collection. We know without thinking that we can cover a range of `[1, (k+1)]` now, but is that all? No! Instead we claim that we can cover a range of `[1, (k+1)+k]` now. Why? Let's list all the numbers we have to cover between range `[(k+1)+1, (k+1)+k]` to make such claim true:\\n> (k+1) + `1`\\n> (k+1) + `2`\\n> (k+1) + `3`\\n> (k+1) + `...`\\n> (k+1) + `k`\\n\\nFocus on the highlighted addends. They simply form a range of `[1, k]`, which is already covered by our original collection `A, B, C, ..., M`. And the other addend `k+1` is merely our new member `N` we just took it.\\n\\nSo in summary, if we can already cover range `[1, k]`, then by just taking in the next integer `k+1`, we will be able to cover a new range `[1, k+(k+1)]` inclusive. There is no need to investigate all the numbers falling in between one by one as explained above.\\n\\nOnce you understand this, the rest would be quite simple.\\n\\nFor example, when we already have a coverage of `[1, k-1]`. What would be our best choice in order to cover `k`? No doubt, our best choice would be `k` itself. Because choosing any integer greater than `k` would not help. On the other hand, if we choose an integer smaller than `k`, let's say we choose `j` and `j < k`. We can write it as `k = j + P`, `P` is a positive integer. So from the above proof, we know that if we choose `j`, our new coverage would be `[1, (k-1)+j]`. But if we choose `k` itself, our new coverage would be `[1, (k-1)+k]`, and `(k-1)+k = (k-1)+(j+P) = ((k-1)+j) + P`, which means we will have greater coverage by choosing `k` instead of `j`. Since `j` can be any positive integer smaller than `k`. QED."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Solving a hard problem always feels so empowering :D"
                    },
                    {
                        "username": "alhazeem",
                        "content": "the most accurate explanation\n\nhttps://www.youtube. com/watch?v=N-tcCOCNSZY"
                    }
                ]
            },
            {
                "id": 1564582,
                "content": [
                    {
                        "username": "bravejia",
                        "content": "The question asked for the \"**minimum** number of patches required\". In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? \\n\\nThink about this example: nums = [1, 2, 3, 9].  We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1...1 is patched completely. After encountered 2, we know 1...3 (1+2) is patched completely. After we encountered 3, we know 1...6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don't miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 ... 7. Any number greater than 7 won't help here. Patching  8 will not help you get 7. So we have 7 numbers (1...7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1...13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1...22 is completely patched. If we still did't reach n, we can then patch 23, which makes 1...45 (22+23) completely patched. We continue until we reach n."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "I have to say, reading this problem and several explanation posts/discussion really inspire me a lot.\\n\\nAfter first time reading this problem, i am overwhelmed by so many cases/ possibilities. Well, typically this indicates dynamic programming.\\n\\nIt is so complicate because I am looking into a wrong way.\\n\\nsay have A =  [1, 2, 10, 20]  n=100\\n\\nThings come to my mind is, how many kinds of different sums could A provide? by adding a number how those sums to expand? how to choose this one number to add? \\n\\nHow about this.\\nsay have A=[1] n = 100 . how do we patch ?\\n\\nwell, everybody knows need to patch 2 fist,  of course there is no other choice.\\n\\nthen, it is not hard to realize we need to add 4 then, because [1,2] result in 1,2,3 and stopped at 3.\\n\\nOf course we would choose 4 as next, compared  1,2,3  ( adding 1 give us all sum as : 1,2,3,4  however adding 4 give us all sum as : 1,2,3,4,5,6,7)\\n\\nI believe now everybody knows how to tackle this problem. Same thing repeat till  100 is reached.\\n\\nlet's look back at A = [1,2,10,20]\\n\\nby having 1 ,2, we have all possible sum as : 1,2,3\\n\\nthen we have 10\\n\\n(10 itself gives a sum as 10, and  having 10 of course all sums from 10 to 13)\\n\\nbut we missing 4 - 10 here, and the one we miss immediately is 4\\n\\nIt is the same thing as we only have [1,2], we also miss 4. what we do is adding 4 \\n\\nsame here, we add 4, and now we have all sum as : 1, 2, 3, 4, 5, 6, 7\\n\\nSo u can tell now, though we having a number 10 sitting there, but what we doing is exactly the same as we not having it. just patch the immediate missing one.\\n\\nU can just consider 10 the same as we patch it when it is the immediate missing.  after a patching, it expand our all sum. \\n\\nSo the question, why having A = [1] instead of A = [1,2, 10, 20] make this problem much easier?\\nBecause A = [1] kindly remove the confusing and unnecessary complicity for us. \\n\\nNow let's look back those complicity, the reason it is so complicated is because we are not seeing the pattern but seeing the whole issue at one time instead. \\n\\nThe pattern is the subproblem and the connection between subproblems.\\n\\nIn this case a subproblem is when we have A = [...] which could give us all sum from 1 to k. \\nhow to we patch to expand it most efficiently ?  we know now by adding k+1\\n\\nYes, and that is the connection. now subproblem turns into A = [...., k+1] give us all sum from\\n1 to k+k+1 , how to expand it most efficiently?\\n\\nEach question could be very unique, but as long as it is a dp/greedy problem. Everybody knows, find the subproblem and find the transfer between subproblems. \\n\\nBut how to discover the subproblem is really challenging always.\\n\\nTill now, I would say, first is never be deceived by the complicity. \\nsecond, analyze what is the final goal of the question.\\nthird, how does this problem initiate, what is the first stage.\\nforth, again, understand in context what is A step\\nfinally, figure out the restrictions/requirement to transfer between steps\\n\\nThis is just for my own information and for yours if needed the same."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "Seriously I saw this problem and I couldn't come up with any working approach at all, and this really lowers my confidence for interviews.."
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "I am just wondering how the question maker came up with this question."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "lucasmus",
                        "content": "You already can make any sum leading up to the next missing number, in this case 7. You want to make progress as fast as possible because you need the least amount of patches. 7 gives you more progress than 4 (7 + 6 vs 4 + 6). Each time you achieve a new cover range, the individual numbers (7 or 4) are not relevant anymore for the algorithm, only the covered range is relevant. Therefore there is no moment were a particular number (say 4) would come in handy."
                    },
                    {
                        "username": "lly_0620",
                        "content": "Example 2:\\n\\nInput: nums = [1,5,10], n = 20\\nOutput: 2\\nExplanation: The two patches can be [2, 4].\\n\\nmy question is how about [2,3]???"
                    },
                    {
                        "username": "ayuanx",
                        "content": "It seems there isn't a comprehensive, easy to understand explanation in other posts yet. So let me explain it here.\\n\\nSuppose we already have a collection of positive integers `A, B, C, ..., M` that can cover a range of `[1, k]` inclusive by selectively summing up some elements in our collection. We know that `k` must be the total sum of all elements in our collection.\\n\\nLet's take in a new integer `N = k+1` into our collection. We know without thinking that we can cover a range of `[1, (k+1)]` now, but is that all? No! Instead we claim that we can cover a range of `[1, (k+1)+k]` now. Why? Let's list all the numbers we have to cover between range `[(k+1)+1, (k+1)+k]` to make such claim true:\\n> (k+1) + `1`\\n> (k+1) + `2`\\n> (k+1) + `3`\\n> (k+1) + `...`\\n> (k+1) + `k`\\n\\nFocus on the highlighted addends. They simply form a range of `[1, k]`, which is already covered by our original collection `A, B, C, ..., M`. And the other addend `k+1` is merely our new member `N` we just took it.\\n\\nSo in summary, if we can already cover range `[1, k]`, then by just taking in the next integer `k+1`, we will be able to cover a new range `[1, k+(k+1)]` inclusive. There is no need to investigate all the numbers falling in between one by one as explained above.\\n\\nOnce you understand this, the rest would be quite simple.\\n\\nFor example, when we already have a coverage of `[1, k-1]`. What would be our best choice in order to cover `k`? No doubt, our best choice would be `k` itself. Because choosing any integer greater than `k` would not help. On the other hand, if we choose an integer smaller than `k`, let's say we choose `j` and `j < k`. We can write it as `k = j + P`, `P` is a positive integer. So from the above proof, we know that if we choose `j`, our new coverage would be `[1, (k-1)+j]`. But if we choose `k` itself, our new coverage would be `[1, (k-1)+k]`, and `(k-1)+k = (k-1)+(j+P) = ((k-1)+j) + P`, which means we will have greater coverage by choosing `k` instead of `j`. Since `j` can be any positive integer smaller than `k`. QED."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Solving a hard problem always feels so empowering :D"
                    },
                    {
                        "username": "alhazeem",
                        "content": "the most accurate explanation\n\nhttps://www.youtube. com/watch?v=N-tcCOCNSZY"
                    }
                ]
            },
            {
                "id": 1567956,
                "content": [
                    {
                        "username": "bravejia",
                        "content": "The question asked for the \"**minimum** number of patches required\". In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? \\n\\nThink about this example: nums = [1, 2, 3, 9].  We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1...1 is patched completely. After encountered 2, we know 1...3 (1+2) is patched completely. After we encountered 3, we know 1...6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don't miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 ... 7. Any number greater than 7 won't help here. Patching  8 will not help you get 7. So we have 7 numbers (1...7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1...13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1...22 is completely patched. If we still did't reach n, we can then patch 23, which makes 1...45 (22+23) completely patched. We continue until we reach n."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "I have to say, reading this problem and several explanation posts/discussion really inspire me a lot.\\n\\nAfter first time reading this problem, i am overwhelmed by so many cases/ possibilities. Well, typically this indicates dynamic programming.\\n\\nIt is so complicate because I am looking into a wrong way.\\n\\nsay have A =  [1, 2, 10, 20]  n=100\\n\\nThings come to my mind is, how many kinds of different sums could A provide? by adding a number how those sums to expand? how to choose this one number to add? \\n\\nHow about this.\\nsay have A=[1] n = 100 . how do we patch ?\\n\\nwell, everybody knows need to patch 2 fist,  of course there is no other choice.\\n\\nthen, it is not hard to realize we need to add 4 then, because [1,2] result in 1,2,3 and stopped at 3.\\n\\nOf course we would choose 4 as next, compared  1,2,3  ( adding 1 give us all sum as : 1,2,3,4  however adding 4 give us all sum as : 1,2,3,4,5,6,7)\\n\\nI believe now everybody knows how to tackle this problem. Same thing repeat till  100 is reached.\\n\\nlet's look back at A = [1,2,10,20]\\n\\nby having 1 ,2, we have all possible sum as : 1,2,3\\n\\nthen we have 10\\n\\n(10 itself gives a sum as 10, and  having 10 of course all sums from 10 to 13)\\n\\nbut we missing 4 - 10 here, and the one we miss immediately is 4\\n\\nIt is the same thing as we only have [1,2], we also miss 4. what we do is adding 4 \\n\\nsame here, we add 4, and now we have all sum as : 1, 2, 3, 4, 5, 6, 7\\n\\nSo u can tell now, though we having a number 10 sitting there, but what we doing is exactly the same as we not having it. just patch the immediate missing one.\\n\\nU can just consider 10 the same as we patch it when it is the immediate missing.  after a patching, it expand our all sum. \\n\\nSo the question, why having A = [1] instead of A = [1,2, 10, 20] make this problem much easier?\\nBecause A = [1] kindly remove the confusing and unnecessary complicity for us. \\n\\nNow let's look back those complicity, the reason it is so complicated is because we are not seeing the pattern but seeing the whole issue at one time instead. \\n\\nThe pattern is the subproblem and the connection between subproblems.\\n\\nIn this case a subproblem is when we have A = [...] which could give us all sum from 1 to k. \\nhow to we patch to expand it most efficiently ?  we know now by adding k+1\\n\\nYes, and that is the connection. now subproblem turns into A = [...., k+1] give us all sum from\\n1 to k+k+1 , how to expand it most efficiently?\\n\\nEach question could be very unique, but as long as it is a dp/greedy problem. Everybody knows, find the subproblem and find the transfer between subproblems. \\n\\nBut how to discover the subproblem is really challenging always.\\n\\nTill now, I would say, first is never be deceived by the complicity. \\nsecond, analyze what is the final goal of the question.\\nthird, how does this problem initiate, what is the first stage.\\nforth, again, understand in context what is A step\\nfinally, figure out the restrictions/requirement to transfer between steps\\n\\nThis is just for my own information and for yours if needed the same."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "Seriously I saw this problem and I couldn't come up with any working approach at all, and this really lowers my confidence for interviews.."
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "I am just wondering how the question maker came up with this question."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "lucasmus",
                        "content": "You already can make any sum leading up to the next missing number, in this case 7. You want to make progress as fast as possible because you need the least amount of patches. 7 gives you more progress than 4 (7 + 6 vs 4 + 6). Each time you achieve a new cover range, the individual numbers (7 or 4) are not relevant anymore for the algorithm, only the covered range is relevant. Therefore there is no moment were a particular number (say 4) would come in handy."
                    },
                    {
                        "username": "lly_0620",
                        "content": "Example 2:\\n\\nInput: nums = [1,5,10], n = 20\\nOutput: 2\\nExplanation: The two patches can be [2, 4].\\n\\nmy question is how about [2,3]???"
                    },
                    {
                        "username": "ayuanx",
                        "content": "It seems there isn't a comprehensive, easy to understand explanation in other posts yet. So let me explain it here.\\n\\nSuppose we already have a collection of positive integers `A, B, C, ..., M` that can cover a range of `[1, k]` inclusive by selectively summing up some elements in our collection. We know that `k` must be the total sum of all elements in our collection.\\n\\nLet's take in a new integer `N = k+1` into our collection. We know without thinking that we can cover a range of `[1, (k+1)]` now, but is that all? No! Instead we claim that we can cover a range of `[1, (k+1)+k]` now. Why? Let's list all the numbers we have to cover between range `[(k+1)+1, (k+1)+k]` to make such claim true:\\n> (k+1) + `1`\\n> (k+1) + `2`\\n> (k+1) + `3`\\n> (k+1) + `...`\\n> (k+1) + `k`\\n\\nFocus on the highlighted addends. They simply form a range of `[1, k]`, which is already covered by our original collection `A, B, C, ..., M`. And the other addend `k+1` is merely our new member `N` we just took it.\\n\\nSo in summary, if we can already cover range `[1, k]`, then by just taking in the next integer `k+1`, we will be able to cover a new range `[1, k+(k+1)]` inclusive. There is no need to investigate all the numbers falling in between one by one as explained above.\\n\\nOnce you understand this, the rest would be quite simple.\\n\\nFor example, when we already have a coverage of `[1, k-1]`. What would be our best choice in order to cover `k`? No doubt, our best choice would be `k` itself. Because choosing any integer greater than `k` would not help. On the other hand, if we choose an integer smaller than `k`, let's say we choose `j` and `j < k`. We can write it as `k = j + P`, `P` is a positive integer. So from the above proof, we know that if we choose `j`, our new coverage would be `[1, (k-1)+j]`. But if we choose `k` itself, our new coverage would be `[1, (k-1)+k]`, and `(k-1)+k = (k-1)+(j+P) = ((k-1)+j) + P`, which means we will have greater coverage by choosing `k` instead of `j`. Since `j` can be any positive integer smaller than `k`. QED."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Solving a hard problem always feels so empowering :D"
                    },
                    {
                        "username": "alhazeem",
                        "content": "the most accurate explanation\n\nhttps://www.youtube. com/watch?v=N-tcCOCNSZY"
                    }
                ]
            },
            {
                "id": 1571590,
                "content": [
                    {
                        "username": "bravejia",
                        "content": "The question asked for the \"**minimum** number of patches required\". In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? \\n\\nThink about this example: nums = [1, 2, 3, 9].  We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1...1 is patched completely. After encountered 2, we know 1...3 (1+2) is patched completely. After we encountered 3, we know 1...6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don't miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 ... 7. Any number greater than 7 won't help here. Patching  8 will not help you get 7. So we have 7 numbers (1...7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1...13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1...22 is completely patched. If we still did't reach n, we can then patch 23, which makes 1...45 (22+23) completely patched. We continue until we reach n."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "I have to say, reading this problem and several explanation posts/discussion really inspire me a lot.\\n\\nAfter first time reading this problem, i am overwhelmed by so many cases/ possibilities. Well, typically this indicates dynamic programming.\\n\\nIt is so complicate because I am looking into a wrong way.\\n\\nsay have A =  [1, 2, 10, 20]  n=100\\n\\nThings come to my mind is, how many kinds of different sums could A provide? by adding a number how those sums to expand? how to choose this one number to add? \\n\\nHow about this.\\nsay have A=[1] n = 100 . how do we patch ?\\n\\nwell, everybody knows need to patch 2 fist,  of course there is no other choice.\\n\\nthen, it is not hard to realize we need to add 4 then, because [1,2] result in 1,2,3 and stopped at 3.\\n\\nOf course we would choose 4 as next, compared  1,2,3  ( adding 1 give us all sum as : 1,2,3,4  however adding 4 give us all sum as : 1,2,3,4,5,6,7)\\n\\nI believe now everybody knows how to tackle this problem. Same thing repeat till  100 is reached.\\n\\nlet's look back at A = [1,2,10,20]\\n\\nby having 1 ,2, we have all possible sum as : 1,2,3\\n\\nthen we have 10\\n\\n(10 itself gives a sum as 10, and  having 10 of course all sums from 10 to 13)\\n\\nbut we missing 4 - 10 here, and the one we miss immediately is 4\\n\\nIt is the same thing as we only have [1,2], we also miss 4. what we do is adding 4 \\n\\nsame here, we add 4, and now we have all sum as : 1, 2, 3, 4, 5, 6, 7\\n\\nSo u can tell now, though we having a number 10 sitting there, but what we doing is exactly the same as we not having it. just patch the immediate missing one.\\n\\nU can just consider 10 the same as we patch it when it is the immediate missing.  after a patching, it expand our all sum. \\n\\nSo the question, why having A = [1] instead of A = [1,2, 10, 20] make this problem much easier?\\nBecause A = [1] kindly remove the confusing and unnecessary complicity for us. \\n\\nNow let's look back those complicity, the reason it is so complicated is because we are not seeing the pattern but seeing the whole issue at one time instead. \\n\\nThe pattern is the subproblem and the connection between subproblems.\\n\\nIn this case a subproblem is when we have A = [...] which could give us all sum from 1 to k. \\nhow to we patch to expand it most efficiently ?  we know now by adding k+1\\n\\nYes, and that is the connection. now subproblem turns into A = [...., k+1] give us all sum from\\n1 to k+k+1 , how to expand it most efficiently?\\n\\nEach question could be very unique, but as long as it is a dp/greedy problem. Everybody knows, find the subproblem and find the transfer between subproblems. \\n\\nBut how to discover the subproblem is really challenging always.\\n\\nTill now, I would say, first is never be deceived by the complicity. \\nsecond, analyze what is the final goal of the question.\\nthird, how does this problem initiate, what is the first stage.\\nforth, again, understand in context what is A step\\nfinally, figure out the restrictions/requirement to transfer between steps\\n\\nThis is just for my own information and for yours if needed the same."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "Seriously I saw this problem and I couldn't come up with any working approach at all, and this really lowers my confidence for interviews.."
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "I am just wondering how the question maker came up with this question."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "lucasmus",
                        "content": "You already can make any sum leading up to the next missing number, in this case 7. You want to make progress as fast as possible because you need the least amount of patches. 7 gives you more progress than 4 (7 + 6 vs 4 + 6). Each time you achieve a new cover range, the individual numbers (7 or 4) are not relevant anymore for the algorithm, only the covered range is relevant. Therefore there is no moment were a particular number (say 4) would come in handy."
                    },
                    {
                        "username": "lly_0620",
                        "content": "Example 2:\\n\\nInput: nums = [1,5,10], n = 20\\nOutput: 2\\nExplanation: The two patches can be [2, 4].\\n\\nmy question is how about [2,3]???"
                    },
                    {
                        "username": "ayuanx",
                        "content": "It seems there isn't a comprehensive, easy to understand explanation in other posts yet. So let me explain it here.\\n\\nSuppose we already have a collection of positive integers `A, B, C, ..., M` that can cover a range of `[1, k]` inclusive by selectively summing up some elements in our collection. We know that `k` must be the total sum of all elements in our collection.\\n\\nLet's take in a new integer `N = k+1` into our collection. We know without thinking that we can cover a range of `[1, (k+1)]` now, but is that all? No! Instead we claim that we can cover a range of `[1, (k+1)+k]` now. Why? Let's list all the numbers we have to cover between range `[(k+1)+1, (k+1)+k]` to make such claim true:\\n> (k+1) + `1`\\n> (k+1) + `2`\\n> (k+1) + `3`\\n> (k+1) + `...`\\n> (k+1) + `k`\\n\\nFocus on the highlighted addends. They simply form a range of `[1, k]`, which is already covered by our original collection `A, B, C, ..., M`. And the other addend `k+1` is merely our new member `N` we just took it.\\n\\nSo in summary, if we can already cover range `[1, k]`, then by just taking in the next integer `k+1`, we will be able to cover a new range `[1, k+(k+1)]` inclusive. There is no need to investigate all the numbers falling in between one by one as explained above.\\n\\nOnce you understand this, the rest would be quite simple.\\n\\nFor example, when we already have a coverage of `[1, k-1]`. What would be our best choice in order to cover `k`? No doubt, our best choice would be `k` itself. Because choosing any integer greater than `k` would not help. On the other hand, if we choose an integer smaller than `k`, let's say we choose `j` and `j < k`. We can write it as `k = j + P`, `P` is a positive integer. So from the above proof, we know that if we choose `j`, our new coverage would be `[1, (k-1)+j]`. But if we choose `k` itself, our new coverage would be `[1, (k-1)+k]`, and `(k-1)+k = (k-1)+(j+P) = ((k-1)+j) + P`, which means we will have greater coverage by choosing `k` instead of `j`. Since `j` can be any positive integer smaller than `k`. QED."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Solving a hard problem always feels so empowering :D"
                    },
                    {
                        "username": "alhazeem",
                        "content": "the most accurate explanation\n\nhttps://www.youtube. com/watch?v=N-tcCOCNSZY"
                    }
                ]
            },
            {
                "id": 1570292,
                "content": [
                    {
                        "username": "bravejia",
                        "content": "The question asked for the \"**minimum** number of patches required\". In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? \\n\\nThink about this example: nums = [1, 2, 3, 9].  We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1...1 is patched completely. After encountered 2, we know 1...3 (1+2) is patched completely. After we encountered 3, we know 1...6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don't miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 ... 7. Any number greater than 7 won't help here. Patching  8 will not help you get 7. So we have 7 numbers (1...7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1...13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1...22 is completely patched. If we still did't reach n, we can then patch 23, which makes 1...45 (22+23) completely patched. We continue until we reach n."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "I have to say, reading this problem and several explanation posts/discussion really inspire me a lot.\\n\\nAfter first time reading this problem, i am overwhelmed by so many cases/ possibilities. Well, typically this indicates dynamic programming.\\n\\nIt is so complicate because I am looking into a wrong way.\\n\\nsay have A =  [1, 2, 10, 20]  n=100\\n\\nThings come to my mind is, how many kinds of different sums could A provide? by adding a number how those sums to expand? how to choose this one number to add? \\n\\nHow about this.\\nsay have A=[1] n = 100 . how do we patch ?\\n\\nwell, everybody knows need to patch 2 fist,  of course there is no other choice.\\n\\nthen, it is not hard to realize we need to add 4 then, because [1,2] result in 1,2,3 and stopped at 3.\\n\\nOf course we would choose 4 as next, compared  1,2,3  ( adding 1 give us all sum as : 1,2,3,4  however adding 4 give us all sum as : 1,2,3,4,5,6,7)\\n\\nI believe now everybody knows how to tackle this problem. Same thing repeat till  100 is reached.\\n\\nlet's look back at A = [1,2,10,20]\\n\\nby having 1 ,2, we have all possible sum as : 1,2,3\\n\\nthen we have 10\\n\\n(10 itself gives a sum as 10, and  having 10 of course all sums from 10 to 13)\\n\\nbut we missing 4 - 10 here, and the one we miss immediately is 4\\n\\nIt is the same thing as we only have [1,2], we also miss 4. what we do is adding 4 \\n\\nsame here, we add 4, and now we have all sum as : 1, 2, 3, 4, 5, 6, 7\\n\\nSo u can tell now, though we having a number 10 sitting there, but what we doing is exactly the same as we not having it. just patch the immediate missing one.\\n\\nU can just consider 10 the same as we patch it when it is the immediate missing.  after a patching, it expand our all sum. \\n\\nSo the question, why having A = [1] instead of A = [1,2, 10, 20] make this problem much easier?\\nBecause A = [1] kindly remove the confusing and unnecessary complicity for us. \\n\\nNow let's look back those complicity, the reason it is so complicated is because we are not seeing the pattern but seeing the whole issue at one time instead. \\n\\nThe pattern is the subproblem and the connection between subproblems.\\n\\nIn this case a subproblem is when we have A = [...] which could give us all sum from 1 to k. \\nhow to we patch to expand it most efficiently ?  we know now by adding k+1\\n\\nYes, and that is the connection. now subproblem turns into A = [...., k+1] give us all sum from\\n1 to k+k+1 , how to expand it most efficiently?\\n\\nEach question could be very unique, but as long as it is a dp/greedy problem. Everybody knows, find the subproblem and find the transfer between subproblems. \\n\\nBut how to discover the subproblem is really challenging always.\\n\\nTill now, I would say, first is never be deceived by the complicity. \\nsecond, analyze what is the final goal of the question.\\nthird, how does this problem initiate, what is the first stage.\\nforth, again, understand in context what is A step\\nfinally, figure out the restrictions/requirement to transfer between steps\\n\\nThis is just for my own information and for yours if needed the same."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "Seriously I saw this problem and I couldn't come up with any working approach at all, and this really lowers my confidence for interviews.."
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "I am just wondering how the question maker came up with this question."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "lucasmus",
                        "content": "You already can make any sum leading up to the next missing number, in this case 7. You want to make progress as fast as possible because you need the least amount of patches. 7 gives you more progress than 4 (7 + 6 vs 4 + 6). Each time you achieve a new cover range, the individual numbers (7 or 4) are not relevant anymore for the algorithm, only the covered range is relevant. Therefore there is no moment were a particular number (say 4) would come in handy."
                    },
                    {
                        "username": "lly_0620",
                        "content": "Example 2:\\n\\nInput: nums = [1,5,10], n = 20\\nOutput: 2\\nExplanation: The two patches can be [2, 4].\\n\\nmy question is how about [2,3]???"
                    },
                    {
                        "username": "ayuanx",
                        "content": "It seems there isn't a comprehensive, easy to understand explanation in other posts yet. So let me explain it here.\\n\\nSuppose we already have a collection of positive integers `A, B, C, ..., M` that can cover a range of `[1, k]` inclusive by selectively summing up some elements in our collection. We know that `k` must be the total sum of all elements in our collection.\\n\\nLet's take in a new integer `N = k+1` into our collection. We know without thinking that we can cover a range of `[1, (k+1)]` now, but is that all? No! Instead we claim that we can cover a range of `[1, (k+1)+k]` now. Why? Let's list all the numbers we have to cover between range `[(k+1)+1, (k+1)+k]` to make such claim true:\\n> (k+1) + `1`\\n> (k+1) + `2`\\n> (k+1) + `3`\\n> (k+1) + `...`\\n> (k+1) + `k`\\n\\nFocus on the highlighted addends. They simply form a range of `[1, k]`, which is already covered by our original collection `A, B, C, ..., M`. And the other addend `k+1` is merely our new member `N` we just took it.\\n\\nSo in summary, if we can already cover range `[1, k]`, then by just taking in the next integer `k+1`, we will be able to cover a new range `[1, k+(k+1)]` inclusive. There is no need to investigate all the numbers falling in between one by one as explained above.\\n\\nOnce you understand this, the rest would be quite simple.\\n\\nFor example, when we already have a coverage of `[1, k-1]`. What would be our best choice in order to cover `k`? No doubt, our best choice would be `k` itself. Because choosing any integer greater than `k` would not help. On the other hand, if we choose an integer smaller than `k`, let's say we choose `j` and `j < k`. We can write it as `k = j + P`, `P` is a positive integer. So from the above proof, we know that if we choose `j`, our new coverage would be `[1, (k-1)+j]`. But if we choose `k` itself, our new coverage would be `[1, (k-1)+k]`, and `(k-1)+k = (k-1)+(j+P) = ((k-1)+j) + P`, which means we will have greater coverage by choosing `k` instead of `j`. Since `j` can be any positive integer smaller than `k`. QED."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Solving a hard problem always feels so empowering :D"
                    },
                    {
                        "username": "alhazeem",
                        "content": "the most accurate explanation\n\nhttps://www.youtube. com/watch?v=N-tcCOCNSZY"
                    }
                ]
            },
            {
                "id": 1567955,
                "content": [
                    {
                        "username": "bravejia",
                        "content": "The question asked for the \"**minimum** number of patches required\". In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? \\n\\nThink about this example: nums = [1, 2, 3, 9].  We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1...1 is patched completely. After encountered 2, we know 1...3 (1+2) is patched completely. After we encountered 3, we know 1...6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don't miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 ... 7. Any number greater than 7 won't help here. Patching  8 will not help you get 7. So we have 7 numbers (1...7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1...13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1...22 is completely patched. If we still did't reach n, we can then patch 23, which makes 1...45 (22+23) completely patched. We continue until we reach n."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "I have to say, reading this problem and several explanation posts/discussion really inspire me a lot.\\n\\nAfter first time reading this problem, i am overwhelmed by so many cases/ possibilities. Well, typically this indicates dynamic programming.\\n\\nIt is so complicate because I am looking into a wrong way.\\n\\nsay have A =  [1, 2, 10, 20]  n=100\\n\\nThings come to my mind is, how many kinds of different sums could A provide? by adding a number how those sums to expand? how to choose this one number to add? \\n\\nHow about this.\\nsay have A=[1] n = 100 . how do we patch ?\\n\\nwell, everybody knows need to patch 2 fist,  of course there is no other choice.\\n\\nthen, it is not hard to realize we need to add 4 then, because [1,2] result in 1,2,3 and stopped at 3.\\n\\nOf course we would choose 4 as next, compared  1,2,3  ( adding 1 give us all sum as : 1,2,3,4  however adding 4 give us all sum as : 1,2,3,4,5,6,7)\\n\\nI believe now everybody knows how to tackle this problem. Same thing repeat till  100 is reached.\\n\\nlet's look back at A = [1,2,10,20]\\n\\nby having 1 ,2, we have all possible sum as : 1,2,3\\n\\nthen we have 10\\n\\n(10 itself gives a sum as 10, and  having 10 of course all sums from 10 to 13)\\n\\nbut we missing 4 - 10 here, and the one we miss immediately is 4\\n\\nIt is the same thing as we only have [1,2], we also miss 4. what we do is adding 4 \\n\\nsame here, we add 4, and now we have all sum as : 1, 2, 3, 4, 5, 6, 7\\n\\nSo u can tell now, though we having a number 10 sitting there, but what we doing is exactly the same as we not having it. just patch the immediate missing one.\\n\\nU can just consider 10 the same as we patch it when it is the immediate missing.  after a patching, it expand our all sum. \\n\\nSo the question, why having A = [1] instead of A = [1,2, 10, 20] make this problem much easier?\\nBecause A = [1] kindly remove the confusing and unnecessary complicity for us. \\n\\nNow let's look back those complicity, the reason it is so complicated is because we are not seeing the pattern but seeing the whole issue at one time instead. \\n\\nThe pattern is the subproblem and the connection between subproblems.\\n\\nIn this case a subproblem is when we have A = [...] which could give us all sum from 1 to k. \\nhow to we patch to expand it most efficiently ?  we know now by adding k+1\\n\\nYes, and that is the connection. now subproblem turns into A = [...., k+1] give us all sum from\\n1 to k+k+1 , how to expand it most efficiently?\\n\\nEach question could be very unique, but as long as it is a dp/greedy problem. Everybody knows, find the subproblem and find the transfer between subproblems. \\n\\nBut how to discover the subproblem is really challenging always.\\n\\nTill now, I would say, first is never be deceived by the complicity. \\nsecond, analyze what is the final goal of the question.\\nthird, how does this problem initiate, what is the first stage.\\nforth, again, understand in context what is A step\\nfinally, figure out the restrictions/requirement to transfer between steps\\n\\nThis is just for my own information and for yours if needed the same."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "Seriously I saw this problem and I couldn't come up with any working approach at all, and this really lowers my confidence for interviews.."
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "I am just wondering how the question maker came up with this question."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "lucasmus",
                        "content": "You already can make any sum leading up to the next missing number, in this case 7. You want to make progress as fast as possible because you need the least amount of patches. 7 gives you more progress than 4 (7 + 6 vs 4 + 6). Each time you achieve a new cover range, the individual numbers (7 or 4) are not relevant anymore for the algorithm, only the covered range is relevant. Therefore there is no moment were a particular number (say 4) would come in handy."
                    },
                    {
                        "username": "lly_0620",
                        "content": "Example 2:\\n\\nInput: nums = [1,5,10], n = 20\\nOutput: 2\\nExplanation: The two patches can be [2, 4].\\n\\nmy question is how about [2,3]???"
                    },
                    {
                        "username": "ayuanx",
                        "content": "It seems there isn't a comprehensive, easy to understand explanation in other posts yet. So let me explain it here.\\n\\nSuppose we already have a collection of positive integers `A, B, C, ..., M` that can cover a range of `[1, k]` inclusive by selectively summing up some elements in our collection. We know that `k` must be the total sum of all elements in our collection.\\n\\nLet's take in a new integer `N = k+1` into our collection. We know without thinking that we can cover a range of `[1, (k+1)]` now, but is that all? No! Instead we claim that we can cover a range of `[1, (k+1)+k]` now. Why? Let's list all the numbers we have to cover between range `[(k+1)+1, (k+1)+k]` to make such claim true:\\n> (k+1) + `1`\\n> (k+1) + `2`\\n> (k+1) + `3`\\n> (k+1) + `...`\\n> (k+1) + `k`\\n\\nFocus on the highlighted addends. They simply form a range of `[1, k]`, which is already covered by our original collection `A, B, C, ..., M`. And the other addend `k+1` is merely our new member `N` we just took it.\\n\\nSo in summary, if we can already cover range `[1, k]`, then by just taking in the next integer `k+1`, we will be able to cover a new range `[1, k+(k+1)]` inclusive. There is no need to investigate all the numbers falling in between one by one as explained above.\\n\\nOnce you understand this, the rest would be quite simple.\\n\\nFor example, when we already have a coverage of `[1, k-1]`. What would be our best choice in order to cover `k`? No doubt, our best choice would be `k` itself. Because choosing any integer greater than `k` would not help. On the other hand, if we choose an integer smaller than `k`, let's say we choose `j` and `j < k`. We can write it as `k = j + P`, `P` is a positive integer. So from the above proof, we know that if we choose `j`, our new coverage would be `[1, (k-1)+j]`. But if we choose `k` itself, our new coverage would be `[1, (k-1)+k]`, and `(k-1)+k = (k-1)+(j+P) = ((k-1)+j) + P`, which means we will have greater coverage by choosing `k` instead of `j`. Since `j` can be any positive integer smaller than `k`. QED."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Solving a hard problem always feels so empowering :D"
                    },
                    {
                        "username": "alhazeem",
                        "content": "the most accurate explanation\n\nhttps://www.youtube. com/watch?v=N-tcCOCNSZY"
                    }
                ]
            },
            {
                "id": 1572379,
                "content": [
                    {
                        "username": "bravejia",
                        "content": "The question asked for the \"**minimum** number of patches required\". In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? \\n\\nThink about this example: nums = [1, 2, 3, 9].  We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1...1 is patched completely. After encountered 2, we know 1...3 (1+2) is patched completely. After we encountered 3, we know 1...6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don't miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 ... 7. Any number greater than 7 won't help here. Patching  8 will not help you get 7. So we have 7 numbers (1...7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1...13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1...22 is completely patched. If we still did't reach n, we can then patch 23, which makes 1...45 (22+23) completely patched. We continue until we reach n."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "I have to say, reading this problem and several explanation posts/discussion really inspire me a lot.\\n\\nAfter first time reading this problem, i am overwhelmed by so many cases/ possibilities. Well, typically this indicates dynamic programming.\\n\\nIt is so complicate because I am looking into a wrong way.\\n\\nsay have A =  [1, 2, 10, 20]  n=100\\n\\nThings come to my mind is, how many kinds of different sums could A provide? by adding a number how those sums to expand? how to choose this one number to add? \\n\\nHow about this.\\nsay have A=[1] n = 100 . how do we patch ?\\n\\nwell, everybody knows need to patch 2 fist,  of course there is no other choice.\\n\\nthen, it is not hard to realize we need to add 4 then, because [1,2] result in 1,2,3 and stopped at 3.\\n\\nOf course we would choose 4 as next, compared  1,2,3  ( adding 1 give us all sum as : 1,2,3,4  however adding 4 give us all sum as : 1,2,3,4,5,6,7)\\n\\nI believe now everybody knows how to tackle this problem. Same thing repeat till  100 is reached.\\n\\nlet's look back at A = [1,2,10,20]\\n\\nby having 1 ,2, we have all possible sum as : 1,2,3\\n\\nthen we have 10\\n\\n(10 itself gives a sum as 10, and  having 10 of course all sums from 10 to 13)\\n\\nbut we missing 4 - 10 here, and the one we miss immediately is 4\\n\\nIt is the same thing as we only have [1,2], we also miss 4. what we do is adding 4 \\n\\nsame here, we add 4, and now we have all sum as : 1, 2, 3, 4, 5, 6, 7\\n\\nSo u can tell now, though we having a number 10 sitting there, but what we doing is exactly the same as we not having it. just patch the immediate missing one.\\n\\nU can just consider 10 the same as we patch it when it is the immediate missing.  after a patching, it expand our all sum. \\n\\nSo the question, why having A = [1] instead of A = [1,2, 10, 20] make this problem much easier?\\nBecause A = [1] kindly remove the confusing and unnecessary complicity for us. \\n\\nNow let's look back those complicity, the reason it is so complicated is because we are not seeing the pattern but seeing the whole issue at one time instead. \\n\\nThe pattern is the subproblem and the connection between subproblems.\\n\\nIn this case a subproblem is when we have A = [...] which could give us all sum from 1 to k. \\nhow to we patch to expand it most efficiently ?  we know now by adding k+1\\n\\nYes, and that is the connection. now subproblem turns into A = [...., k+1] give us all sum from\\n1 to k+k+1 , how to expand it most efficiently?\\n\\nEach question could be very unique, but as long as it is a dp/greedy problem. Everybody knows, find the subproblem and find the transfer between subproblems. \\n\\nBut how to discover the subproblem is really challenging always.\\n\\nTill now, I would say, first is never be deceived by the complicity. \\nsecond, analyze what is the final goal of the question.\\nthird, how does this problem initiate, what is the first stage.\\nforth, again, understand in context what is A step\\nfinally, figure out the restrictions/requirement to transfer between steps\\n\\nThis is just for my own information and for yours if needed the same."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "Seriously I saw this problem and I couldn't come up with any working approach at all, and this really lowers my confidence for interviews.."
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "I am just wondering how the question maker came up with this question."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "lucasmus",
                        "content": "You already can make any sum leading up to the next missing number, in this case 7. You want to make progress as fast as possible because you need the least amount of patches. 7 gives you more progress than 4 (7 + 6 vs 4 + 6). Each time you achieve a new cover range, the individual numbers (7 or 4) are not relevant anymore for the algorithm, only the covered range is relevant. Therefore there is no moment were a particular number (say 4) would come in handy."
                    },
                    {
                        "username": "lly_0620",
                        "content": "Example 2:\\n\\nInput: nums = [1,5,10], n = 20\\nOutput: 2\\nExplanation: The two patches can be [2, 4].\\n\\nmy question is how about [2,3]???"
                    },
                    {
                        "username": "ayuanx",
                        "content": "It seems there isn't a comprehensive, easy to understand explanation in other posts yet. So let me explain it here.\\n\\nSuppose we already have a collection of positive integers `A, B, C, ..., M` that can cover a range of `[1, k]` inclusive by selectively summing up some elements in our collection. We know that `k` must be the total sum of all elements in our collection.\\n\\nLet's take in a new integer `N = k+1` into our collection. We know without thinking that we can cover a range of `[1, (k+1)]` now, but is that all? No! Instead we claim that we can cover a range of `[1, (k+1)+k]` now. Why? Let's list all the numbers we have to cover between range `[(k+1)+1, (k+1)+k]` to make such claim true:\\n> (k+1) + `1`\\n> (k+1) + `2`\\n> (k+1) + `3`\\n> (k+1) + `...`\\n> (k+1) + `k`\\n\\nFocus on the highlighted addends. They simply form a range of `[1, k]`, which is already covered by our original collection `A, B, C, ..., M`. And the other addend `k+1` is merely our new member `N` we just took it.\\n\\nSo in summary, if we can already cover range `[1, k]`, then by just taking in the next integer `k+1`, we will be able to cover a new range `[1, k+(k+1)]` inclusive. There is no need to investigate all the numbers falling in between one by one as explained above.\\n\\nOnce you understand this, the rest would be quite simple.\\n\\nFor example, when we already have a coverage of `[1, k-1]`. What would be our best choice in order to cover `k`? No doubt, our best choice would be `k` itself. Because choosing any integer greater than `k` would not help. On the other hand, if we choose an integer smaller than `k`, let's say we choose `j` and `j < k`. We can write it as `k = j + P`, `P` is a positive integer. So from the above proof, we know that if we choose `j`, our new coverage would be `[1, (k-1)+j]`. But if we choose `k` itself, our new coverage would be `[1, (k-1)+k]`, and `(k-1)+k = (k-1)+(j+P) = ((k-1)+j) + P`, which means we will have greater coverage by choosing `k` instead of `j`. Since `j` can be any positive integer smaller than `k`. QED."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Solving a hard problem always feels so empowering :D"
                    },
                    {
                        "username": "alhazeem",
                        "content": "the most accurate explanation\n\nhttps://www.youtube. com/watch?v=N-tcCOCNSZY"
                    }
                ]
            },
            {
                "id": 1571589,
                "content": [
                    {
                        "username": "bravejia",
                        "content": "The question asked for the \"**minimum** number of patches required\". In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? \\n\\nThink about this example: nums = [1, 2, 3, 9].  We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1...1 is patched completely. After encountered 2, we know 1...3 (1+2) is patched completely. After we encountered 3, we know 1...6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don't miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 ... 7. Any number greater than 7 won't help here. Patching  8 will not help you get 7. So we have 7 numbers (1...7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1...13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1...22 is completely patched. If we still did't reach n, we can then patch 23, which makes 1...45 (22+23) completely patched. We continue until we reach n."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "I have to say, reading this problem and several explanation posts/discussion really inspire me a lot.\\n\\nAfter first time reading this problem, i am overwhelmed by so many cases/ possibilities. Well, typically this indicates dynamic programming.\\n\\nIt is so complicate because I am looking into a wrong way.\\n\\nsay have A =  [1, 2, 10, 20]  n=100\\n\\nThings come to my mind is, how many kinds of different sums could A provide? by adding a number how those sums to expand? how to choose this one number to add? \\n\\nHow about this.\\nsay have A=[1] n = 100 . how do we patch ?\\n\\nwell, everybody knows need to patch 2 fist,  of course there is no other choice.\\n\\nthen, it is not hard to realize we need to add 4 then, because [1,2] result in 1,2,3 and stopped at 3.\\n\\nOf course we would choose 4 as next, compared  1,2,3  ( adding 1 give us all sum as : 1,2,3,4  however adding 4 give us all sum as : 1,2,3,4,5,6,7)\\n\\nI believe now everybody knows how to tackle this problem. Same thing repeat till  100 is reached.\\n\\nlet's look back at A = [1,2,10,20]\\n\\nby having 1 ,2, we have all possible sum as : 1,2,3\\n\\nthen we have 10\\n\\n(10 itself gives a sum as 10, and  having 10 of course all sums from 10 to 13)\\n\\nbut we missing 4 - 10 here, and the one we miss immediately is 4\\n\\nIt is the same thing as we only have [1,2], we also miss 4. what we do is adding 4 \\n\\nsame here, we add 4, and now we have all sum as : 1, 2, 3, 4, 5, 6, 7\\n\\nSo u can tell now, though we having a number 10 sitting there, but what we doing is exactly the same as we not having it. just patch the immediate missing one.\\n\\nU can just consider 10 the same as we patch it when it is the immediate missing.  after a patching, it expand our all sum. \\n\\nSo the question, why having A = [1] instead of A = [1,2, 10, 20] make this problem much easier?\\nBecause A = [1] kindly remove the confusing and unnecessary complicity for us. \\n\\nNow let's look back those complicity, the reason it is so complicated is because we are not seeing the pattern but seeing the whole issue at one time instead. \\n\\nThe pattern is the subproblem and the connection between subproblems.\\n\\nIn this case a subproblem is when we have A = [...] which could give us all sum from 1 to k. \\nhow to we patch to expand it most efficiently ?  we know now by adding k+1\\n\\nYes, and that is the connection. now subproblem turns into A = [...., k+1] give us all sum from\\n1 to k+k+1 , how to expand it most efficiently?\\n\\nEach question could be very unique, but as long as it is a dp/greedy problem. Everybody knows, find the subproblem and find the transfer between subproblems. \\n\\nBut how to discover the subproblem is really challenging always.\\n\\nTill now, I would say, first is never be deceived by the complicity. \\nsecond, analyze what is the final goal of the question.\\nthird, how does this problem initiate, what is the first stage.\\nforth, again, understand in context what is A step\\nfinally, figure out the restrictions/requirement to transfer between steps\\n\\nThis is just for my own information and for yours if needed the same."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "Seriously I saw this problem and I couldn't come up with any working approach at all, and this really lowers my confidence for interviews.."
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "I am just wondering how the question maker came up with this question."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "lucasmus",
                        "content": "You already can make any sum leading up to the next missing number, in this case 7. You want to make progress as fast as possible because you need the least amount of patches. 7 gives you more progress than 4 (7 + 6 vs 4 + 6). Each time you achieve a new cover range, the individual numbers (7 or 4) are not relevant anymore for the algorithm, only the covered range is relevant. Therefore there is no moment were a particular number (say 4) would come in handy."
                    },
                    {
                        "username": "lly_0620",
                        "content": "Example 2:\\n\\nInput: nums = [1,5,10], n = 20\\nOutput: 2\\nExplanation: The two patches can be [2, 4].\\n\\nmy question is how about [2,3]???"
                    },
                    {
                        "username": "ayuanx",
                        "content": "It seems there isn't a comprehensive, easy to understand explanation in other posts yet. So let me explain it here.\\n\\nSuppose we already have a collection of positive integers `A, B, C, ..., M` that can cover a range of `[1, k]` inclusive by selectively summing up some elements in our collection. We know that `k` must be the total sum of all elements in our collection.\\n\\nLet's take in a new integer `N = k+1` into our collection. We know without thinking that we can cover a range of `[1, (k+1)]` now, but is that all? No! Instead we claim that we can cover a range of `[1, (k+1)+k]` now. Why? Let's list all the numbers we have to cover between range `[(k+1)+1, (k+1)+k]` to make such claim true:\\n> (k+1) + `1`\\n> (k+1) + `2`\\n> (k+1) + `3`\\n> (k+1) + `...`\\n> (k+1) + `k`\\n\\nFocus on the highlighted addends. They simply form a range of `[1, k]`, which is already covered by our original collection `A, B, C, ..., M`. And the other addend `k+1` is merely our new member `N` we just took it.\\n\\nSo in summary, if we can already cover range `[1, k]`, then by just taking in the next integer `k+1`, we will be able to cover a new range `[1, k+(k+1)]` inclusive. There is no need to investigate all the numbers falling in between one by one as explained above.\\n\\nOnce you understand this, the rest would be quite simple.\\n\\nFor example, when we already have a coverage of `[1, k-1]`. What would be our best choice in order to cover `k`? No doubt, our best choice would be `k` itself. Because choosing any integer greater than `k` would not help. On the other hand, if we choose an integer smaller than `k`, let's say we choose `j` and `j < k`. We can write it as `k = j + P`, `P` is a positive integer. So from the above proof, we know that if we choose `j`, our new coverage would be `[1, (k-1)+j]`. But if we choose `k` itself, our new coverage would be `[1, (k-1)+k]`, and `(k-1)+k = (k-1)+(j+P) = ((k-1)+j) + P`, which means we will have greater coverage by choosing `k` instead of `j`. Since `j` can be any positive integer smaller than `k`. QED."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Solving a hard problem always feels so empowering :D"
                    },
                    {
                        "username": "alhazeem",
                        "content": "the most accurate explanation\n\nhttps://www.youtube. com/watch?v=N-tcCOCNSZY"
                    }
                ]
            },
            {
                "id": 1567250,
                "content": [
                    {
                        "username": "bravejia",
                        "content": "The question asked for the \"**minimum** number of patches required\". In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? \\n\\nThink about this example: nums = [1, 2, 3, 9].  We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1...1 is patched completely. After encountered 2, we know 1...3 (1+2) is patched completely. After we encountered 3, we know 1...6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don't miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 ... 7. Any number greater than 7 won't help here. Patching  8 will not help you get 7. So we have 7 numbers (1...7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1...13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1...22 is completely patched. If we still did't reach n, we can then patch 23, which makes 1...45 (22+23) completely patched. We continue until we reach n."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "I have to say, reading this problem and several explanation posts/discussion really inspire me a lot.\\n\\nAfter first time reading this problem, i am overwhelmed by so many cases/ possibilities. Well, typically this indicates dynamic programming.\\n\\nIt is so complicate because I am looking into a wrong way.\\n\\nsay have A =  [1, 2, 10, 20]  n=100\\n\\nThings come to my mind is, how many kinds of different sums could A provide? by adding a number how those sums to expand? how to choose this one number to add? \\n\\nHow about this.\\nsay have A=[1] n = 100 . how do we patch ?\\n\\nwell, everybody knows need to patch 2 fist,  of course there is no other choice.\\n\\nthen, it is not hard to realize we need to add 4 then, because [1,2] result in 1,2,3 and stopped at 3.\\n\\nOf course we would choose 4 as next, compared  1,2,3  ( adding 1 give us all sum as : 1,2,3,4  however adding 4 give us all sum as : 1,2,3,4,5,6,7)\\n\\nI believe now everybody knows how to tackle this problem. Same thing repeat till  100 is reached.\\n\\nlet's look back at A = [1,2,10,20]\\n\\nby having 1 ,2, we have all possible sum as : 1,2,3\\n\\nthen we have 10\\n\\n(10 itself gives a sum as 10, and  having 10 of course all sums from 10 to 13)\\n\\nbut we missing 4 - 10 here, and the one we miss immediately is 4\\n\\nIt is the same thing as we only have [1,2], we also miss 4. what we do is adding 4 \\n\\nsame here, we add 4, and now we have all sum as : 1, 2, 3, 4, 5, 6, 7\\n\\nSo u can tell now, though we having a number 10 sitting there, but what we doing is exactly the same as we not having it. just patch the immediate missing one.\\n\\nU can just consider 10 the same as we patch it when it is the immediate missing.  after a patching, it expand our all sum. \\n\\nSo the question, why having A = [1] instead of A = [1,2, 10, 20] make this problem much easier?\\nBecause A = [1] kindly remove the confusing and unnecessary complicity for us. \\n\\nNow let's look back those complicity, the reason it is so complicated is because we are not seeing the pattern but seeing the whole issue at one time instead. \\n\\nThe pattern is the subproblem and the connection between subproblems.\\n\\nIn this case a subproblem is when we have A = [...] which could give us all sum from 1 to k. \\nhow to we patch to expand it most efficiently ?  we know now by adding k+1\\n\\nYes, and that is the connection. now subproblem turns into A = [...., k+1] give us all sum from\\n1 to k+k+1 , how to expand it most efficiently?\\n\\nEach question could be very unique, but as long as it is a dp/greedy problem. Everybody knows, find the subproblem and find the transfer between subproblems. \\n\\nBut how to discover the subproblem is really challenging always.\\n\\nTill now, I would say, first is never be deceived by the complicity. \\nsecond, analyze what is the final goal of the question.\\nthird, how does this problem initiate, what is the first stage.\\nforth, again, understand in context what is A step\\nfinally, figure out the restrictions/requirement to transfer between steps\\n\\nThis is just for my own information and for yours if needed the same."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "Seriously I saw this problem and I couldn't come up with any working approach at all, and this really lowers my confidence for interviews.."
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "I am just wondering how the question maker came up with this question."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "lucasmus",
                        "content": "You already can make any sum leading up to the next missing number, in this case 7. You want to make progress as fast as possible because you need the least amount of patches. 7 gives you more progress than 4 (7 + 6 vs 4 + 6). Each time you achieve a new cover range, the individual numbers (7 or 4) are not relevant anymore for the algorithm, only the covered range is relevant. Therefore there is no moment were a particular number (say 4) would come in handy."
                    },
                    {
                        "username": "lly_0620",
                        "content": "Example 2:\\n\\nInput: nums = [1,5,10], n = 20\\nOutput: 2\\nExplanation: The two patches can be [2, 4].\\n\\nmy question is how about [2,3]???"
                    },
                    {
                        "username": "ayuanx",
                        "content": "It seems there isn't a comprehensive, easy to understand explanation in other posts yet. So let me explain it here.\\n\\nSuppose we already have a collection of positive integers `A, B, C, ..., M` that can cover a range of `[1, k]` inclusive by selectively summing up some elements in our collection. We know that `k` must be the total sum of all elements in our collection.\\n\\nLet's take in a new integer `N = k+1` into our collection. We know without thinking that we can cover a range of `[1, (k+1)]` now, but is that all? No! Instead we claim that we can cover a range of `[1, (k+1)+k]` now. Why? Let's list all the numbers we have to cover between range `[(k+1)+1, (k+1)+k]` to make such claim true:\\n> (k+1) + `1`\\n> (k+1) + `2`\\n> (k+1) + `3`\\n> (k+1) + `...`\\n> (k+1) + `k`\\n\\nFocus on the highlighted addends. They simply form a range of `[1, k]`, which is already covered by our original collection `A, B, C, ..., M`. And the other addend `k+1` is merely our new member `N` we just took it.\\n\\nSo in summary, if we can already cover range `[1, k]`, then by just taking in the next integer `k+1`, we will be able to cover a new range `[1, k+(k+1)]` inclusive. There is no need to investigate all the numbers falling in between one by one as explained above.\\n\\nOnce you understand this, the rest would be quite simple.\\n\\nFor example, when we already have a coverage of `[1, k-1]`. What would be our best choice in order to cover `k`? No doubt, our best choice would be `k` itself. Because choosing any integer greater than `k` would not help. On the other hand, if we choose an integer smaller than `k`, let's say we choose `j` and `j < k`. We can write it as `k = j + P`, `P` is a positive integer. So from the above proof, we know that if we choose `j`, our new coverage would be `[1, (k-1)+j]`. But if we choose `k` itself, our new coverage would be `[1, (k-1)+k]`, and `(k-1)+k = (k-1)+(j+P) = ((k-1)+j) + P`, which means we will have greater coverage by choosing `k` instead of `j`. Since `j` can be any positive integer smaller than `k`. QED."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Solving a hard problem always feels so empowering :D"
                    },
                    {
                        "username": "alhazeem",
                        "content": "the most accurate explanation\n\nhttps://www.youtube. com/watch?v=N-tcCOCNSZY"
                    }
                ]
            },
            {
                "id": 1875414,
                "content": [
                    {
                        "username": "bravejia",
                        "content": "The question asked for the \"**minimum** number of patches required\". In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? \\n\\nThink about this example: nums = [1, 2, 3, 9].  We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1...1 is patched completely. After encountered 2, we know 1...3 (1+2) is patched completely. After we encountered 3, we know 1...6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don't miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 ... 7. Any number greater than 7 won't help here. Patching  8 will not help you get 7. So we have 7 numbers (1...7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1...13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1...22 is completely patched. If we still did't reach n, we can then patch 23, which makes 1...45 (22+23) completely patched. We continue until we reach n."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "I have to say, reading this problem and several explanation posts/discussion really inspire me a lot.\\n\\nAfter first time reading this problem, i am overwhelmed by so many cases/ possibilities. Well, typically this indicates dynamic programming.\\n\\nIt is so complicate because I am looking into a wrong way.\\n\\nsay have A =  [1, 2, 10, 20]  n=100\\n\\nThings come to my mind is, how many kinds of different sums could A provide? by adding a number how those sums to expand? how to choose this one number to add? \\n\\nHow about this.\\nsay have A=[1] n = 100 . how do we patch ?\\n\\nwell, everybody knows need to patch 2 fist,  of course there is no other choice.\\n\\nthen, it is not hard to realize we need to add 4 then, because [1,2] result in 1,2,3 and stopped at 3.\\n\\nOf course we would choose 4 as next, compared  1,2,3  ( adding 1 give us all sum as : 1,2,3,4  however adding 4 give us all sum as : 1,2,3,4,5,6,7)\\n\\nI believe now everybody knows how to tackle this problem. Same thing repeat till  100 is reached.\\n\\nlet's look back at A = [1,2,10,20]\\n\\nby having 1 ,2, we have all possible sum as : 1,2,3\\n\\nthen we have 10\\n\\n(10 itself gives a sum as 10, and  having 10 of course all sums from 10 to 13)\\n\\nbut we missing 4 - 10 here, and the one we miss immediately is 4\\n\\nIt is the same thing as we only have [1,2], we also miss 4. what we do is adding 4 \\n\\nsame here, we add 4, and now we have all sum as : 1, 2, 3, 4, 5, 6, 7\\n\\nSo u can tell now, though we having a number 10 sitting there, but what we doing is exactly the same as we not having it. just patch the immediate missing one.\\n\\nU can just consider 10 the same as we patch it when it is the immediate missing.  after a patching, it expand our all sum. \\n\\nSo the question, why having A = [1] instead of A = [1,2, 10, 20] make this problem much easier?\\nBecause A = [1] kindly remove the confusing and unnecessary complicity for us. \\n\\nNow let's look back those complicity, the reason it is so complicated is because we are not seeing the pattern but seeing the whole issue at one time instead. \\n\\nThe pattern is the subproblem and the connection between subproblems.\\n\\nIn this case a subproblem is when we have A = [...] which could give us all sum from 1 to k. \\nhow to we patch to expand it most efficiently ?  we know now by adding k+1\\n\\nYes, and that is the connection. now subproblem turns into A = [...., k+1] give us all sum from\\n1 to k+k+1 , how to expand it most efficiently?\\n\\nEach question could be very unique, but as long as it is a dp/greedy problem. Everybody knows, find the subproblem and find the transfer between subproblems. \\n\\nBut how to discover the subproblem is really challenging always.\\n\\nTill now, I would say, first is never be deceived by the complicity. \\nsecond, analyze what is the final goal of the question.\\nthird, how does this problem initiate, what is the first stage.\\nforth, again, understand in context what is A step\\nfinally, figure out the restrictions/requirement to transfer between steps\\n\\nThis is just for my own information and for yours if needed the same."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "Seriously I saw this problem and I couldn't come up with any working approach at all, and this really lowers my confidence for interviews.."
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "I am just wondering how the question maker came up with this question."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "lucasmus",
                        "content": "You already can make any sum leading up to the next missing number, in this case 7. You want to make progress as fast as possible because you need the least amount of patches. 7 gives you more progress than 4 (7 + 6 vs 4 + 6). Each time you achieve a new cover range, the individual numbers (7 or 4) are not relevant anymore for the algorithm, only the covered range is relevant. Therefore there is no moment were a particular number (say 4) would come in handy."
                    },
                    {
                        "username": "lly_0620",
                        "content": "Example 2:\\n\\nInput: nums = [1,5,10], n = 20\\nOutput: 2\\nExplanation: The two patches can be [2, 4].\\n\\nmy question is how about [2,3]???"
                    },
                    {
                        "username": "ayuanx",
                        "content": "It seems there isn't a comprehensive, easy to understand explanation in other posts yet. So let me explain it here.\\n\\nSuppose we already have a collection of positive integers `A, B, C, ..., M` that can cover a range of `[1, k]` inclusive by selectively summing up some elements in our collection. We know that `k` must be the total sum of all elements in our collection.\\n\\nLet's take in a new integer `N = k+1` into our collection. We know without thinking that we can cover a range of `[1, (k+1)]` now, but is that all? No! Instead we claim that we can cover a range of `[1, (k+1)+k]` now. Why? Let's list all the numbers we have to cover between range `[(k+1)+1, (k+1)+k]` to make such claim true:\\n> (k+1) + `1`\\n> (k+1) + `2`\\n> (k+1) + `3`\\n> (k+1) + `...`\\n> (k+1) + `k`\\n\\nFocus on the highlighted addends. They simply form a range of `[1, k]`, which is already covered by our original collection `A, B, C, ..., M`. And the other addend `k+1` is merely our new member `N` we just took it.\\n\\nSo in summary, if we can already cover range `[1, k]`, then by just taking in the next integer `k+1`, we will be able to cover a new range `[1, k+(k+1)]` inclusive. There is no need to investigate all the numbers falling in between one by one as explained above.\\n\\nOnce you understand this, the rest would be quite simple.\\n\\nFor example, when we already have a coverage of `[1, k-1]`. What would be our best choice in order to cover `k`? No doubt, our best choice would be `k` itself. Because choosing any integer greater than `k` would not help. On the other hand, if we choose an integer smaller than `k`, let's say we choose `j` and `j < k`. We can write it as `k = j + P`, `P` is a positive integer. So from the above proof, we know that if we choose `j`, our new coverage would be `[1, (k-1)+j]`. But if we choose `k` itself, our new coverage would be `[1, (k-1)+k]`, and `(k-1)+k = (k-1)+(j+P) = ((k-1)+j) + P`, which means we will have greater coverage by choosing `k` instead of `j`. Since `j` can be any positive integer smaller than `k`. QED."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Solving a hard problem always feels so empowering :D"
                    },
                    {
                        "username": "alhazeem",
                        "content": "the most accurate explanation\n\nhttps://www.youtube. com/watch?v=N-tcCOCNSZY"
                    }
                ]
            },
            {
                "id": 1751811,
                "content": [
                    {
                        "username": "bravejia",
                        "content": "The question asked for the \"**minimum** number of patches required\". In other words, it asked for an optimal solution. Lots of problems involving optimal solution can be solved by dynamic programming and/or greedy algorithm. I started with greedy algorithm which is conceptually easy to design. Typically, a greedy algorithm needs selection of best moves for a subproblem. So what is our best move? \\n\\nThink about this example: nums = [1, 2, 3, 9].  We naturally want to iterate through nums from left to right and see what we would discover. After we encountered 1, we know 1...1 is patched completely. After encountered 2, we know 1...3 (1+2) is patched completely. After we encountered 3, we know 1...6 (1+2+3) is patched completely. After we encountered 9, the smallest number we can get is 9. So we must patch a new number here so that we don't miss 7, 8. To have 7, the numbers we can patch is 1, 2, 3 ... 7. Any number greater than 7 won't help here. Patching  8 will not help you get 7. So we have 7 numbers (1...7) to choose from. I hope you can see number 7 works best here because if we chose number 7, we can move all the way up to 1+2+3+7 = 13. (1...13 is patched completely) and it makes us reach n as quickly as possible. After we patched 7 and reach 13, we can consider last element 9 in nums. Having 9 makes us reach 13+9 = 22, which means 1...22 is completely patched. If we still did't reach n, we can then patch 23, which makes 1...45 (22+23) completely patched. We continue until we reach n."
                    },
                    {
                        "username": "Three_Thousand_world",
                        "content": "I have to say, reading this problem and several explanation posts/discussion really inspire me a lot.\\n\\nAfter first time reading this problem, i am overwhelmed by so many cases/ possibilities. Well, typically this indicates dynamic programming.\\n\\nIt is so complicate because I am looking into a wrong way.\\n\\nsay have A =  [1, 2, 10, 20]  n=100\\n\\nThings come to my mind is, how many kinds of different sums could A provide? by adding a number how those sums to expand? how to choose this one number to add? \\n\\nHow about this.\\nsay have A=[1] n = 100 . how do we patch ?\\n\\nwell, everybody knows need to patch 2 fist,  of course there is no other choice.\\n\\nthen, it is not hard to realize we need to add 4 then, because [1,2] result in 1,2,3 and stopped at 3.\\n\\nOf course we would choose 4 as next, compared  1,2,3  ( adding 1 give us all sum as : 1,2,3,4  however adding 4 give us all sum as : 1,2,3,4,5,6,7)\\n\\nI believe now everybody knows how to tackle this problem. Same thing repeat till  100 is reached.\\n\\nlet's look back at A = [1,2,10,20]\\n\\nby having 1 ,2, we have all possible sum as : 1,2,3\\n\\nthen we have 10\\n\\n(10 itself gives a sum as 10, and  having 10 of course all sums from 10 to 13)\\n\\nbut we missing 4 - 10 here, and the one we miss immediately is 4\\n\\nIt is the same thing as we only have [1,2], we also miss 4. what we do is adding 4 \\n\\nsame here, we add 4, and now we have all sum as : 1, 2, 3, 4, 5, 6, 7\\n\\nSo u can tell now, though we having a number 10 sitting there, but what we doing is exactly the same as we not having it. just patch the immediate missing one.\\n\\nU can just consider 10 the same as we patch it when it is the immediate missing.  after a patching, it expand our all sum. \\n\\nSo the question, why having A = [1] instead of A = [1,2, 10, 20] make this problem much easier?\\nBecause A = [1] kindly remove the confusing and unnecessary complicity for us. \\n\\nNow let's look back those complicity, the reason it is so complicated is because we are not seeing the pattern but seeing the whole issue at one time instead. \\n\\nThe pattern is the subproblem and the connection between subproblems.\\n\\nIn this case a subproblem is when we have A = [...] which could give us all sum from 1 to k. \\nhow to we patch to expand it most efficiently ?  we know now by adding k+1\\n\\nYes, and that is the connection. now subproblem turns into A = [...., k+1] give us all sum from\\n1 to k+k+1 , how to expand it most efficiently?\\n\\nEach question could be very unique, but as long as it is a dp/greedy problem. Everybody knows, find the subproblem and find the transfer between subproblems. \\n\\nBut how to discover the subproblem is really challenging always.\\n\\nTill now, I would say, first is never be deceived by the complicity. \\nsecond, analyze what is the final goal of the question.\\nthird, how does this problem initiate, what is the first stage.\\nforth, again, understand in context what is A step\\nfinally, figure out the restrictions/requirement to transfer between steps\\n\\nThis is just for my own information and for yours if needed the same."
                    },
                    {
                        "username": "IWantToPass",
                        "content": "Seriously I saw this problem and I couldn't come up with any working approach at all, and this really lowers my confidence for interviews.."
                    },
                    {
                        "username": "lifeofpriyam2",
                        "content": "I am just wondering how the question maker came up with this question."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "lucasmus",
                        "content": "You already can make any sum leading up to the next missing number, in this case 7. You want to make progress as fast as possible because you need the least amount of patches. 7 gives you more progress than 4 (7 + 6 vs 4 + 6). Each time you achieve a new cover range, the individual numbers (7 or 4) are not relevant anymore for the algorithm, only the covered range is relevant. Therefore there is no moment were a particular number (say 4) would come in handy."
                    },
                    {
                        "username": "lly_0620",
                        "content": "Example 2:\\n\\nInput: nums = [1,5,10], n = 20\\nOutput: 2\\nExplanation: The two patches can be [2, 4].\\n\\nmy question is how about [2,3]???"
                    },
                    {
                        "username": "ayuanx",
                        "content": "It seems there isn't a comprehensive, easy to understand explanation in other posts yet. So let me explain it here.\\n\\nSuppose we already have a collection of positive integers `A, B, C, ..., M` that can cover a range of `[1, k]` inclusive by selectively summing up some elements in our collection. We know that `k` must be the total sum of all elements in our collection.\\n\\nLet's take in a new integer `N = k+1` into our collection. We know without thinking that we can cover a range of `[1, (k+1)]` now, but is that all? No! Instead we claim that we can cover a range of `[1, (k+1)+k]` now. Why? Let's list all the numbers we have to cover between range `[(k+1)+1, (k+1)+k]` to make such claim true:\\n> (k+1) + `1`\\n> (k+1) + `2`\\n> (k+1) + `3`\\n> (k+1) + `...`\\n> (k+1) + `k`\\n\\nFocus on the highlighted addends. They simply form a range of `[1, k]`, which is already covered by our original collection `A, B, C, ..., M`. And the other addend `k+1` is merely our new member `N` we just took it.\\n\\nSo in summary, if we can already cover range `[1, k]`, then by just taking in the next integer `k+1`, we will be able to cover a new range `[1, k+(k+1)]` inclusive. There is no need to investigate all the numbers falling in between one by one as explained above.\\n\\nOnce you understand this, the rest would be quite simple.\\n\\nFor example, when we already have a coverage of `[1, k-1]`. What would be our best choice in order to cover `k`? No doubt, our best choice would be `k` itself. Because choosing any integer greater than `k` would not help. On the other hand, if we choose an integer smaller than `k`, let's say we choose `j` and `j < k`. We can write it as `k = j + P`, `P` is a positive integer. So from the above proof, we know that if we choose `j`, our new coverage would be `[1, (k-1)+j]`. But if we choose `k` itself, our new coverage would be `[1, (k-1)+k]`, and `(k-1)+k = (k-1)+(j+P) = ((k-1)+j) + P`, which means we will have greater coverage by choosing `k` instead of `j`. Since `j` can be any positive integer smaller than `k`. QED."
                    },
                    {
                        "username": "Realhacker",
                        "content": "I see in many solutions posted here, the strategy is to patch the next missing number itself:\\n\\nFor example, with [1, 2, 3] and N=20, I get 1-6 covered, and I patch 7. \\n\\nYes, 7 would push the frontier the furthest (to 13), but if I choose to patch 4 instead, maybe a 4 may come in handy when I need to  make other numbers down the road?\\n\\nWhy is this choice 7 optimal? Can any provide a solid proof?"
                    },
                    {
                        "username": "chibi_chihiro",
                        "content": "Solving a hard problem always feels so empowering :D"
                    },
                    {
                        "username": "alhazeem",
                        "content": "the most accurate explanation\n\nhttps://www.youtube. com/watch?v=N-tcCOCNSZY"
                    }
                ]
            }
        ]
    }
]