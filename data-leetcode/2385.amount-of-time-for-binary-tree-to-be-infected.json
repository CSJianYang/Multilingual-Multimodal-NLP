[
    {
        "title": "Time Needed to Rearrange a Binary String",
        "question_content": "You are given a binary string s. In one second, all occurrences of \"01\" are simultaneously replaced with \"10\". This process repeats until no occurrences of \"01\" exist.\nReturn the number of seconds needed to complete this process.\n&nbsp;\nExample 1:\n\nInput: s = \"0110101\"\nOutput: 4\nExplanation: \nAfter one second, s becomes \"1011010\".\nAfter another second, s becomes \"1101100\".\nAfter the third second, s becomes \"1110100\".\nAfter the fourth second, s becomes \"1111000\".\nNo occurrence of \"01\" exists any longer, and the process needed 4 seconds to complete,\nso we return 4.\n\nExample 2:\n\nInput: s = \"11100\"\nOutput: 0\nExplanation:\nNo occurrence of \"01\" exists in s, and the processes needed 0 seconds to complete,\nso we return 0.\n\n&nbsp;\nConstraints:\n\n\t1 <= s.length <= 1000\n\ts[i] is either '0' or '1'.\n\n&nbsp;\nFollow up:\nCan you solve this problem in O(n) time complexity?",
        "solutions": [
            {
                "id": 2454262,
                "title": "dp-vs-brute-force",
                "content": "DP is O(n) but could be tricky to figure out; Brute-Force is good enough for the contest since `n <= 1,000`.\\n\\n#### DP\\n\\nWe count \"zeros\" so far. If we have a string `00001`, we need `4` seconds (as we have `4` zeros) to make it `10000`.\\n\\nWe also track `seconds` we need to rearrange first `i` letters.\\n\\nIf `i + 1` letter is `1`, we need at least `seconds + 1` seconds, but not less than `zero` seconds.\\n\\nHere is calculation for the `\"100111110001000001\"` test case:\\n- For `i == 11` (yellow), the result is `7` as we need `6` seconds for `i - 1`.\\n- For `i == 17` (green), the result is `10` as we have `10` zeros, even though we need `7` seconds for `i - 1`.\\n\\n![image](https://assets.leetcode.com/users/images/c15cc22e-885f-47ab-8f67-4225cb40525c_1661020625.9402463.png)\\n\\n**Java**\\n```java\\npublic int secondsToRemoveOccurrences(String s) {\\n    int zeros = 0, seconds = 0;\\n    for (int i = 0; i < s.length(); ++i) {\\n        zeros += s.charAt(i) == \\'0\\' ? 1 : 0;\\n        if (s.charAt(i) == \\'1\\' && zeros > 0)\\n            seconds = Math.max(seconds + 1, zeros);\\n    }\\n    return seconds;        \\n}\\n```\\n**C++**\\n```cpp\\nint secondsToRemoveOccurrences(string s) {\\n    int zeros = 0, seconds = 0;\\n    for (int i = 0; i < s.size(); ++i) {\\n        zeros += s[i] == \\'0\\';\\n        if (s[i] == \\'1\\' && zeros)\\n            seconds = max(seconds + 1, zeros);\\n    }\\n    return seconds;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n)\\n- Memory: O(1)\\n\\n#### Brute-Force\\n**C++**\\n```cpp\\nint secondsToRemoveOccurrences(string s) {\\n    int seconds = 0, changed = true;\\n    while(changed) {\\n        changed = false;\\n        for (int i = 0; i < s.size() - 1; ++i) {\\n            if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                swap(s[i], s[i + 1]);\\n                ++i;\\n                changed = true;\\n            }\\n        }\\n        seconds += changed;\\n    }\\n    return seconds;\\n}\\n```\\n**Complexity Analysis**\\n- Time: O(n * n) - OK for n <= 1,000. We process `n` characters in the string `n` times in the worst case (`0111...1`).\\n- Memory: O(n) to store an interim string.",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int secondsToRemoveOccurrences(String s) {\\n    int zeros = 0, seconds = 0;\\n    for (int i = 0; i < s.length(); ++i) {\\n        zeros += s.charAt(i) == \\'0\\' ? 1 : 0;\\n        if (s.charAt(i) == \\'1\\' && zeros > 0)\\n            seconds = Math.max(seconds + 1, zeros);\\n    }\\n    return seconds;        \\n}\\n```\n```cpp\\nint secondsToRemoveOccurrences(string s) {\\n    int zeros = 0, seconds = 0;\\n    for (int i = 0; i < s.size(); ++i) {\\n        zeros += s[i] == \\'0\\';\\n        if (s[i] == \\'1\\' && zeros)\\n            seconds = max(seconds + 1, zeros);\\n    }\\n    return seconds;\\n}\\n```\n```cpp\\nint secondsToRemoveOccurrences(string s) {\\n    int seconds = 0, changed = true;\\n    while(changed) {\\n        changed = false;\\n        for (int i = 0; i < s.size() - 1; ++i) {\\n            if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                swap(s[i], s[i + 1]);\\n                ++i;\\n                changed = true;\\n            }\\n        }\\n        seconds += changed;\\n    }\\n    return seconds;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454884,
                "title": "no-dp-o-n-time-o-1-space",
                "content": "First off, the final string will be of the form 1111....000.... \\n\\nOne observation is that since a \\'1\\' has to be swapped with every occurence of \\'0\\' to its left, the time taken for that \\'1\\' to reach its final position is atleast the number of zeroes to its left.\\n\\nWhy is it not equal to number of \\'0\\'s to its left ?\\nIn a testcase like \\'011\\' -> \\'101\\' -> \\'110\\', the second \\'1\\' had to wait for the first \\'1\\' in the first turn. \\n\\nThe total number of time taken for a \\'1\\' to reach its final position is number of \\'0\\'s to its left + number of turns it waits.\\n\\nEvery time we come across two consequetive ones, the waiting time increases by one.\\n\\nAnd everytime we come acress two consequetive zeroes, the waiting time decreases by one.\\n( consider 0 1 1 0 0 1  The waiting time for the first \\'1\\' is 0, for the second \\'1\\' is 1 , but for the third \\'1\\' is again 0, because while the second \\'1\\' was waiting, the third \\'1\\' would not waste a turn by moving through the zeroes before it.)\\n\\nAlso, it is obvious that the last occurence of a \\'1\\' is the one that will reach its destination the last. \\nSo we just have to find the number of zeroes to the left of it + its waiting time\\n\\nPython:\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        waitingTime = zeroCount = 0\\n        lastOcc = s.rfind(\\'1\\')\\n    \\n        for i in range(lastOcc + 1):\\n\\t\\t\\t# increase waiting time if we come across 2 conseq 1\\'s\\n\\t\\t\\t# however, if there are no zeroes to the left, then there is no waiting time\\n            if i > 0 and s[i] == \\'1\\' and s[i - 1] == \\'1\\' and zeroCount > 0:\\n                waitingTime += 1\\n            \\n\\t\\t\\t# decrease waiting time if we come across 2 conseq 0\\'s\\n            if i > 0 and s[i] == \\'0\\' and s[i - 1] == \\'0\\' and waitingTime > 0:\\n                waitingTime -= 1\\n            \\n            if s[i] == \\'0\\':\\n                zeroCount += 1\\n                \\n        return zeroCount + waitingTime\\n```\\nTime Complexity: O(n)\\nSpace Complexity: O(1)\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        waitingTime = zeroCount = 0\\n        lastOcc = s.rfind(\\'1\\')\\n    \\n        for i in range(lastOcc + 1):\\n\\t\\t\\t# increase waiting time if we come across 2 conseq 1\\'s\\n\\t\\t\\t# however, if there are no zeroes to the left, then there is no waiting time\\n            if i > 0 and s[i] == \\'1\\' and s[i - 1] == \\'1\\' and zeroCount > 0:\\n                waitingTime += 1\\n            \\n\\t\\t\\t# decrease waiting time if we come across 2 conseq 0\\'s\\n            if i > 0 and s[i] == \\'0\\' and s[i - 1] == \\'0\\' and waitingTime > 0:\\n                waitingTime -= 1\\n            \\n            if s[i] == \\'0\\':\\n                zeroCount += 1\\n                \\n        return zeroCount + waitingTime\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454195,
                "title": "python3-o-n-dp-approach",
                "content": "Please pull this git [commit](https://github.com/gaosanyong/leetcode/commit/e999ea07dc2ea2e8b7aad97696f67a3b965e496d) for solutions of biweekly 85. \\n\\n**Intuition**\\nGiven the size of the problem, it is okay to run a simulation which takes `O(N^2)` to complete. However, a faster `O(N)` DP approach is available. \\nHere, we consider the task as \"moving 1s to the left\". Two key observatoins are \\n1) to move \\'1\\' at `i`th index it takes at least x steps if there are x \\'0\\'s preceeding it. \\n2) if there is a \\'1\\' at \\'i-1\\'st index, it takes at least one more step to move this \\'1\\' to proper position. \\n\\n**Analysis**\\nTime complexity `O(N)`\\nSpace complexity `O(1)`\\n```\\nclass Solution: \\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans = prefix = prev = 0 \\n        for i, ch in enumerate(s): \\n            if ch == \\'1\\': \\n                ans = max(prev, i - prefix)\\n                prefix += 1\\n                if ans: prev = ans+1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution: \\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans = prefix = prev = 0 \\n        for i, ch in enumerate(s): \\n            if ch == \\'1\\': \\n                ans = max(prev, i - prefix)\\n                prefix += 1\\n                if ans: prev = ans+1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454526,
                "title": "java-3-lines-easy-solution",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int seconds = 0;\\n        while (s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++seconds;\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int seconds = 0;\\n        while (s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++seconds;\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454176,
                "title": "c-brute-force-with-explanation",
                "content": "Upvote if it helps :)\\n```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int one = count(s.begin(), s.end(), \\'1\\');\\n        int i = 0;\\n        int swap = 0;\\n        while(one){//place a \\'1\\' at the index i and reduce one\\'s count and increase i, and place another \\'1\\' there and so on, till there is no \\'one\\' left\\n            if(s[i] == \\'1\\'){ //if i\\'th index has already \\'1\\', then reduce one\\'s count and update i to next index\\n                one--;\\n                i++;\\n            }else{//swap all possible \"01\" to \"10\" and increase swap count, don\\'t reduce one\\'s count, casue we don\\'t know s[i] == \\'1\\' or not\\n                for(int j = i; j < n-1; j++){\\n                    if(s[j] == \\'0\\' && s[j+1] == \\'1\\'){\\n                        s[j] = \\'1\\';\\n                        s[j+1] = \\'0\\';\\n                        j++;\\n                    }\\n                }\\n                swap++;\\n            }\\n        }\\n        return swap;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int one = count(s.begin(), s.end(), \\'1\\');\\n        int i = 0;\\n        int swap = 0;\\n        while(one){//place a \\'1\\' at the index i and reduce one\\'s count and increase i, and place another \\'1\\' there and so on, till there is no \\'one\\' left\\n            if(s[i] == \\'1\\'){ //if i\\'th index has already \\'1\\', then reduce one\\'s count and update i to next index\\n                one--;\\n                i++;\\n            }else{//swap all possible \"01\" to \"10\" and increase swap count, don\\'t reduce one\\'s count, casue we don\\'t know s[i] == \\'1\\' or not\\n                for(int j = i; j < n-1; j++){\\n                    if(s[j] == \\'0\\' && s[j+1] == \\'1\\'){\\n                        s[j] = \\'1\\';\\n                        s[j+1] = \\'0\\';\\n                        j++;\\n                    }\\n                }\\n                swap++;\\n            }\\n        }\\n        return swap;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454424,
                "title": "python-easy-approach-replace-5-lines",
                "content": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n\\n        ans = 0\\n\\n        while \\'01\\' in s:\\n            ans += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n            \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n\\n        ans = 0\\n\\n        while \\'01\\' in s:\\n            ans += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n            \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454160,
                "title": "easy-understanding-python",
                "content": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        cnt = 0\\n        while (\\'01\\' in s):\\n            s = s.replace(\\'01\\', \\'10\\')\\n            cnt += 1\\n        return cnt\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        cnt = 0\\n        while (\\'01\\' in s):\\n            s = s.replace(\\'01\\', \\'10\\')\\n            cnt += 1\\n        return cnt\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454388,
                "title": "c-straightforward-easy-short",
                "content": "![image](https://assets.leetcode.com/users/images/bc6076ed-f081-429f-a169-c78f621230f4_1661011671.1091099.png)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint secondsToRemoveOccurrences(string s) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tint n=s.size();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tbool flag=false;\\n\\t\\t\\t\\tfor(int j=0;j<n-1;j++){\\n\\t\\t\\t\\t\\tif(s[j]==\\'0\\' && s[j+1]==\\'1\\'){\\n\\t\\t\\t\\t\\t\\ts[j]=\\'1\\';\\n\\t\\t\\t\\t\\t\\ts[j+1]=\\'0\\';\\n\\t\\t\\t\\t\\t\\tflag=true;\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(flag) count++;\\n\\t\\t\\t}\\n\\t\\t\\treturn count;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint secondsToRemoveOccurrences(string s) {\\n\\t\\t\\tint count=0;\\n\\t\\t\\tint n=s.size();\\n\\t\\t\\tfor(int i=0;i<n;i++){\\n\\t\\t\\t\\tbool flag=false;\\n\\t\\t\\t\\tfor(int j=0;j<n-1;j++){\\n\\t\\t\\t\\t\\tif(s[j]==\\'0\\' && s[j+1]==\\'1\\'){\\n\\t\\t\\t\\t\\t\\ts[j]=\\'1\\';\\n\\t\\t\\t\\t\\t\\ts[j+1]=\\'0\\';\\n\\t\\t\\t\\t\\t\\tflag=true;\\n\\t\\t\\t\\t\\t\\tj++;\\n\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2467821,
                "title": "c-two-loop-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int t = 0;\\n        int n = s.size();\\n        if(n == 1) return 0;\\n        \\n        while(true){\\n            bool flag = false;\\n            int i=1;\\n            while(i < n){\\n                if(s[i-1] == \\'0\\' && s[i] == \\'1\\'){\\n                    s[i-1] = \\'1\\' , s[i] = \\'0\\';\\n                    i = i+2;\\n                    flag = true;\\n                }\\n                else i++;\\n            }\\n            if(flag == false) break;\\n            t++;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int t = 0;\\n        int n = s.size();\\n        if(n == 1) return 0;\\n        \\n        while(true){\\n            bool flag = false;\\n            int i=1;\\n            while(i < n){\\n                if(s[i-1] == \\'0\\' && s[i] == \\'1\\'){\\n                    s[i-1] = \\'1\\' , s[i] = \\'0\\';\\n                    i = i+2;\\n                    flag = true;\\n                }\\n                else i++;\\n            }\\n            if(flag == false) break;\\n            t++;\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488547,
                "title": "java-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int ans=0;\\n        \\n        while(s.indexOf(\"01\")!=-1){\\n            s=s.replaceAll(\"01\",\"10\");\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int ans=0;\\n        \\n        while(s.indexOf(\"01\")!=-1){\\n            s=s.replaceAll(\"01\",\"10\");\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454162,
                "title": "c-simple-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int count=0;                       // counter for counting the operations\\n        int flag=1;                        // declare a flag value for check we have 01 pair or not\\n        int n=s.length();\\n        \\n        // while we still have pair\\n        while(flag==1)\\n        {\\n            // check from start to end\\n            for(int i=0;i<n-1;i++)\\n            { \\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\')              // if we our pair then just swap it move i to next value and make flag 0 that will show we have pair 01\\n                {\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                    flag=0;\\n                }\\n            }\\n            \\n            flag = 1-flag;                                // update flag\\n            count++;                                      // make operations count+1\\n        }\\n        \\n        return (count-1);                                 // return count-1 because at the last call when we will not find pair although count will increase by one while eding the loop\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int count=0;                       // counter for counting the operations\\n        int flag=1;                        // declare a flag value for check we have 01 pair or not\\n        int n=s.length();\\n        \\n        // while we still have pair\\n        while(flag==1)\\n        {\\n            // check from start to end\\n            for(int i=0;i<n-1;i++)\\n            { \\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\')              // if we our pair then just swap it move i to next value and make flag 0 that will show we have pair 01\\n                {\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                    flag=0;\\n                }\\n            }\\n            \\n            flag = 1-flag;                                // update flag\\n            count++;                                      // make operations count+1\\n        }\\n        \\n        return (count-1);                                 // return count-1 because at the last call when we will not find pair although count will increase by one while eding the loop\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467165,
                "title": "leetcode-the-hard-way-brute-force-approach-with-explanation",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), need = 1, ans = 0;\\n        // bruce force approach as n <= 1000\\n        while (need) {\\n            // unset need\\n            need = 0;\\n            // iterate the string\\n            for (int i = 1; i < n; i++) {\\n                // check if there is 01\\n                if (s[i - 1] == \\'0\\' && s[i] == \\'1\\') {\\n                    // if so, swap them to become 10\\n                    swap(s[i], s[i - 1]);\\n                    // skip this character\\n                    i += 1;\\n                    // after swapping, it could possibly produce another 01\\n                    // hence set it to 1\\n                    need = 1;\\n                }                \\n            }\\n            // if we swapped it, then we need 1 second for the action\\n            ans += need;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), need = 1, ans = 0;\\n        // bruce force approach as n <= 1000\\n        while (need) {\\n            // unset need\\n            need = 0;\\n            // iterate the string\\n            for (int i = 1; i < n; i++) {\\n                // check if there is 01\\n                if (s[i - 1] == \\'0\\' && s[i] == \\'1\\') {\\n                    // if so, swap them to become 10\\n                    swap(s[i], s[i - 1]);\\n                    // skip this character\\n                    i += 1;\\n                    // after swapping, it could possibly produce another 01\\n                    // hence set it to 1\\n                    need = 1;\\n                }                \\n            }\\n            // if we swapped it, then we need 1 second for the action\\n            ans += need;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458917,
                "title": "explanation-python-c-simple-and-concise-code",
                "content": "Intituion:\\nWe do the operation untill all the \\'1\\'s and \\'0\\'s are separated and take the count.\\n\\n\\n*  **C++** \\n```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), ans = 0;\\n        while(s.find(\"01\") != string::npos){   // iterate till a \\'01\\' is present, * string::npos is same as s.end()\\n            for(int i=0;i<n-1;i++){\\n                if(s.substr(i,2)==\"01\"){\\n                    swap(s[i],s[i+1]);             // change \\'01\\' to \\'10\\'\\n                    i++;                        // we increase the i since when \\'01\\' changed to \\'10\\' we can\\'t again swap this if there a \\'1\\' present after this \\'0\\'\\n                 }\\n            }\\n            ans++;          // for every loop we add 1 to ans \\n        }\\n        return ans;\\n    }\\n```\\n\\n\\n* **Python**\\n```\\ndef secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans = 0\\n        while \\'01\\' in s:\\n            ans += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n\\t\\t\\t\\n        return ans\\n```\\n\\nAppriciate an upvote...",
                "solutionTags": [
                    "Python",
                    "C"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), ans = 0;\\n        while(s.find(\"01\") != string::npos){   // iterate till a \\'01\\' is present, * string::npos is same as s.end()\\n            for(int i=0;i<n-1;i++){\\n                if(s.substr(i,2)==\"01\"){\\n                    swap(s[i],s[i+1]);             // change \\'01\\' to \\'10\\'\\n                    i++;                        // we increase the i since when \\'01\\' changed to \\'10\\' we can\\'t again swap this if there a \\'1\\' present after this \\'0\\'\\n                 }\\n            }\\n            ans++;          // for every loop we add 1 to ans \\n        }\\n        return ans;\\n    }\\n```\n```\\ndef secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans = 0\\n        while \\'01\\' in s:\\n            ans += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n\\t\\t\\t\\n        return ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2795812,
                "title": "python-simple-maths",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s):\\n        total = zeros = 0\\n\\n        for i in range(len(s)):\\n            zeros += 1 if s[i] == \"0\" else 0\\n\\n            if s[i] == \"1\" and zeros:\\n                total = max(total+1,zeros)\\n\\n        return total\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s):\\n        total = zeros = 0\\n\\n        for i in range(len(s)):\\n            zeros += 1 if s[i] == \"0\" else 0\\n\\n            if s[i] == \"1\" and zeros:\\n                total = max(total+1,zeros)\\n\\n        return total\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458535,
                "title": "python-c-java-beginner-level-as-simple-as-u-think-5-line-solution-simple-short-solution",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q2380. Time Needed to Rearrange a Binary String***\\nYou are given a binary string s. In one second, all occurrences of `\"01\"` are simultaneously replaced with `\"10\"`. This process repeats until no occurrences of `\"01\"` exist.\\n\\nReturn the number of seconds needed to complete this process.\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans=0\\n        while \\'01\\' in s:\\n            ans+=1\\n            s=s.replace(\\'01\\',\\'10\\')\\n        return ans\\n```\\n**Runtime:**  139 ms\\t\\n**Memory Usage:**  13.9 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\"))\\n        {\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\\n**Runtime:**  338 ms\\t\\t\\n**Memory Usage:**  114.8 MB\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            bool flag=false;\\n            for(int j=0;j<n-1;j++)\\n            {\\n                if(s[j]==\\'0\\'&&s[j+1]==\\'1\\')\\n                {\\n                    s[j]=\\'1\\';\\n                    s[j+1]=\\'0\\';\\n                    flag=true;\\n                    j++;\\n                }\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```\\n**Runtime:** 129 ms\\t\\n**Memory Usage:**  5.9 MB\\t\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        ans=0\\n        while \\'01\\' in s:\\n            ans+=1\\n            s=s.replace(\\'01\\',\\'10\\')\\n        return ans\\n```\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\"))\\n        {\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        int count=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            bool flag=false;\\n            for(int j=0;j<n-1;j++)\\n            {\\n                if(s[j]==\\'0\\'&&s[j+1]==\\'1\\')\\n                {\\n                    s[j]=\\'1\\';\\n                    s[j+1]=\\'0\\';\\n                    flag=true;\\n                    j++;\\n                }\\n            }\\n            if(flag)\\n                count++;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454989,
                "title": "my-dp-approach",
                "content": "\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(N)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        vector<int>zerocnt;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\')\\n                cnt++;\\n            zerocnt.push_back(cnt);\\n        }\\n      \\n        int sum=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'1\\' && zerocnt[i]){\\n                sum = max(sum + 1, zerocnt[i]);\\n            }\\n        }\\n      \\n        \\n        return sum;\\n    }\\n};\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        vector<int>zerocnt;\\n        int cnt=0;\\n        for(int i=0;i<n;i++){\\n            if(s[i]==\\'0\\')\\n                cnt++;\\n            zerocnt.push_back(cnt);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3684059,
                "title": "simple-recursive-c",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nSimulate the process until there is at least 1 swap.\\n# Complexity\\n- Time complexity:O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int solve(string &s)\\n    {\\n        int i = 1,n = s.size(),fleg = 1;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\' && s[i-1]==\\'0\\')\\n            {\\n                swap(s[i],s[i-1]);\\n                fleg = 0;\\n                i+=2;\\n            }\\n            else\\n            i+=1;\\n        }\\n        if(fleg) return 0;\\n        return 1+solve(s);\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n        return solve(s);\\n    }\\n};\\n```\\n![upvote.jpg](https://assets.leetcode.com/users/images/9d11b9c5-0846-4f56-b069-b501a37463f4_1687765172.989497.jpeg)\\n",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int solve(string &s)\\n    {\\n        int i = 1,n = s.size(),fleg = 1;\\n        while(i<n)\\n        {\\n            if(s[i]==\\'1\\' && s[i-1]==\\'0\\')\\n            {\\n                swap(s[i],s[i-1]);\\n                fleg = 0;\\n                i+=2;\\n            }\\n            else\\n            i+=1;\\n        }\\n        if(fleg) return 0;\\n        return 1+solve(s);\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n        return solve(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439289,
                "title": "c-very-easy-solution-beginner-friendly",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        int n=s.length();\\n        int flag=1;\\n        int cc=0;\\n        while(1){\\n            flag=1;\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    s[i]=\\'1\\';\\n                    s[i+1]=\\'0\\';\\n                    i++;\\n                    flag=0;\\n\\n                }\\n\\n            }\\n            \\n            if(flag==1){\\n                break;\\n            }\\n            cc++;\\n        }\\n        return cc;\\n            \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        int n=s.length();\\n        int flag=1;\\n        int cc=0;\\n        while(1){\\n            flag=1;\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    s[i]=\\'1\\';\\n                    s[i+1]=\\'0\\';\\n                    i++;\\n                    flag=0;\\n\\n                }\\n\\n            }\\n            \\n            if(flag==1){\\n                break;\\n            }\\n            cc++;\\n        }\\n        return cc;\\n            \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163010,
                "title": "brute-force-c-very-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nBrute Force\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n^2)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt=0;int st=0;int n=s.length();bool flag=false;\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(s[j]==\\'0\\'&&s[j+1]==\\'1\\'){swap(s[j],s[j+1]);j++;flag=true;}\\n            }\\n            if(flag==false){return i;}flag=false;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt=0;int st=0;int n=s.length();bool flag=false;\\n        for(int i=0;i<=n;i++){\\n            for(int j=0;j<n-1;j++){\\n                if(s[j]==\\'0\\'&&s[j+1]==\\'1\\'){swap(s[j],s[j+1]);j++;flag=true;}\\n            }\\n            if(flag==false){return i;}flag=false;\\n        }\\n        return n;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3032709,
                "title": "queue-solution",
                "content": "# Intuition\\nIdea come from that we can perform some operation and put it to the queue for the next iteration on it ( checking the number of swaps) and so on\\n\\n# Approach\\nInit queue and push the giving string. Start process of swap and push it again the queue\\n\\n# Complexity\\n- Time complexity:\\nO(N) * O(K), where the N is the length of string and K the number of \"seconds\"\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        Deque<StringBuilder> queue = new ArrayDeque();\\n        int ans = 0;\\n        queue.addLast(new StringBuilder(s));\\n\\n        while (!queue.isEmpty()){\\n            StringBuilder poped = queue.pollFirst();\\n            boolean isChange = false;\\n            for (int i=0; i<poped.length()-1; i++){\\n                if (poped.charAt(i)==\\'0\\' && poped.charAt(i+1)==\\'1\\'){\\n                    isChange = true;\\n                    poped.setCharAt(i,\\'1\\');\\n                    poped.setCharAt(i+1,\\'0\\');\\n                    i++;\\n                }\\n            }\\n\\n            if (isChange) {\\n                \\n                queue.addLast(poped);\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        Deque<StringBuilder> queue = new ArrayDeque();\\n        int ans = 0;\\n        queue.addLast(new StringBuilder(s));\\n\\n        while (!queue.isEmpty()){\\n            StringBuilder poped = queue.pollFirst();\\n            boolean isChange = false;\\n            for (int i=0; i<poped.length()-1; i++){\\n                if (poped.charAt(i)==\\'0\\' && poped.charAt(i+1)==\\'1\\'){\\n                    isChange = true;\\n                    poped.setCharAt(i,\\'1\\');\\n                    poped.setCharAt(i+1,\\'0\\');\\n                    i++;\\n                }\\n            }\\n\\n            if (isChange) {\\n                \\n                queue.addLast(poped);\\n                ans++;\\n            }\\n        }\\n\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2676981,
                "title": "brute-force-approach-easiest-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count=0;\\n        int idx=0;\\n        while(idx<s.length())\\n        {\\n            if(idx<s.length() and s[idx]==\\'0\\' and s[idx+1]==\\'1\\')\\n            {\\n                count++;\\n                swap(s[idx],s[idx+1]);\\n                idx+=2;\\n            }\\n            else\\n            {\\n                idx++;\\n            }\\n        }\\n        if(count==0)\\n        {\\n            return 0;\\n        }\\n        return 1+secondsToRemoveOccurrences(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count=0;\\n        int idx=0;\\n        while(idx<s.length())\\n        {\\n            if(idx<s.length() and s[idx]==\\'0\\' and s[idx+1]==\\'1\\')\\n            {\\n                count++;\\n                swap(s[idx],s[idx+1]);\\n                idx+=2;\\n            }\\n            else\\n            {\\n                idx++;\\n            }\\n        }\\n        if(count==0)\\n        {\\n            return 0;\\n        }\\n        return 1+secondsToRemoveOccurrences(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2585925,
                "title": "java-no-dp-o-n-time-o-1-space-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) \\n    {\\n        int count=0;\\n        while(s.contains(\"01\"))\\n        {\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) \\n    {\\n        int count=0;\\n        while(s.contains(\"01\"))\\n        {\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489509,
                "title": "single-pass-with-explanation",
                "content": "`jth` \"1\" at index `i` will take at a minimum `i-j` moves to reach `jth` index.\\nFirst incorrectly placed \\'1\\' will take `i-0` steps\\nIf the next \"1\" was right next to it, then it will have to wait a round. To extend it further, each \"1\" will take either `j-i` moves or it will take as many moves as the previous \"1\" takes + 1\\n\\nIf the ones are at indexes [1, 2], then `j-i` for both are [1-0, 2-1]. However, since the first one takes 1 move which is equal to the number of moves taken by the second \"1\", it means that the second \"1\" will have to wait a turn.\\n\\n```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        j = 0\\n        for i, e in enumerate(s):\\n            if e == \\'0\\':\\n                continue\\n            if count >= i-j and count != 0:\\n                count += 1\\n            else:\\n                count = i-j\\n            j +=1\\n        return count\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        count = 0\\n        j = 0\\n        for i, e in enumerate(s):\\n            if e == \\'0\\':\\n                continue\\n            if count >= i-j and count != 0:\\n                count += 1\\n            else:\\n                count = i-j\\n            j +=1\\n        return count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457959,
                "title": "3-lines-of-code-easy-and-simple-c-java",
                "content": "**Time Needed to Rearrange a Binary String Solution :**\\n.\\n.\\n**In Java :**\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int ans = 0;\\n        while(s.contains(\"01\")){\\n            s = s.replaceAll(\"01\", \"10\");\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```\\n\\n**In C++ :**\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt=0,check=1;\\n        while(check){\\n            check=0;\\n\\t\\t\\tfor(int i=1;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'1\\' && s[i-1]==\\'0\\'){\\n\\t\\t\\t\\t\\tswap(s[i],s[i-1]);\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tcheck=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            cnt++;\\n        }\\n        return cnt-1;\\n    }\\n};\\n```\\n.\\n.\\n.\\n**Happy Coding** \\uD83D\\uDE0A!!!\\nIf you get value from this, then show some love by ***upvoting*** it !!\\n\\n",
                "solutionTags": [
                    "Java",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int ans = 0;\\n        while(s.contains(\"01\")){\\n            s = s.replaceAll(\"01\", \"10\");\\n            ans++;\\n        }\\n        return ans;\\n    }\\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt=0,check=1;\\n        while(check){\\n            check=0;\\n\\t\\t\\tfor(int i=1;i<s.size();i++){\\n\\t\\t\\t\\tif(s[i]==\\'1\\' && s[i-1]==\\'0\\'){\\n\\t\\t\\t\\t\\tswap(s[i],s[i-1]);\\n\\t\\t\\t\\t\\ti++;\\n\\t\\t\\t\\t\\tcheck=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n            cnt++;\\n        }\\n        return cnt-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457634,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Brute Force***\\n\\n* ***Time Complexity :- O(N * N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string str) {\\n        \\n        int n = str.size();\\n        \\n        int time = 0;\\n        \\n        while(true)\\n        {\\n            // flag will keep track of is there any \"01\" pair in str or not\\n            \\n            bool flag = false;\\n            \\n            for(int i = 0; i < n - 1;)\\n            {\\n                // if there is \"01\" pair\\n                \\n                if(str[i] == \\'0\\' && str[i + 1] == \\'1\\')\\n                {\\n                    str[i] = \\'1\\';\\n                    \\n                    str[i + 1] = \\'0\\';\\n\\n                    flag = true;\\n                    \\n                    i += 2;\\n                }\\n                \\n                else\\n                    i++;\\n            }\\n            \\n            // flag == false, means there is not any \"01\" pair in str, return time\\n            \\n            if(flag == false)\\n                return time;\\n            else\\n                time++;\\n        }\\n        \\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string str) {\\n        \\n        int n = str.size();\\n        \\n        int time = 0;\\n        \\n        while(true)\\n        {\\n            // flag will keep track of is there any \"01\" pair in str or not\\n            \\n            bool flag = false;\\n            \\n            for(int i = 0; i < n - 1;)\\n            {\\n                // if there is \"01\" pair\\n                \\n                if(str[i] == \\'0\\' && str[i + 1] == \\'1\\')\\n                {\\n                    str[i] = \\'1\\';\\n                    \\n                    str[i + 1] = \\'0\\';\\n\\n                    flag = true;\\n                    \\n                    i += 2;\\n                }\\n                \\n                else\\n                    i++;\\n            }\\n            \\n            // flag == false, means there is not any \"01\" pair in str, return time\\n            \\n            if(flag == false)\\n                return time;\\n            else\\n                time++;\\n        }\\n        \\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456398,
                "title": "beginner-friendly-java-javascript-solution",
                "content": "**Java**\\n```\\nclass Solution {\\n    int count = -1;\\n    public int secondsToRemoveOccurrences(String s) {\\n        count++;\\n        StringBuilder str = new StringBuilder();\\n        boolean isvalid = true;\\n        for(int i=0; i<s.length(); i++){\\n            if(i < s.length()-1 && s.charAt(i) < s.charAt(i+1)){\\n                isvalid = false;\\n                str.append(s.charAt(i+1));\\n                str.append(s.charAt(i));\\n                i++;\\n            }else if(i < s.length()){\\n                str.append(s.charAt(i));\\n            }\\n        }\\n        return isvalid == true ? count : secondsToRemoveOccurrences(str.toString());\\n    }\\n}\\n```\\n**JavaScript**\\n```\\nvar secondsToRemoveOccurrences = function(s) {\\n    let cnt = -1\\n    \\n    function count(s){\\n        cnt++\\n        str = \"\"\\n        let isvalid = true\\n        for(let i=0; i<s.length; i++){\\n            if(i < s.length-1 && s[i] < s[i+1]){\\n                isvalid = false\\n                str += s[i+1]\\n                str += s[i]\\n                i++;\\n            }else if(i < s.length){\\n                str += s[i];\\n            }\\n        }\\n        return isvalid == true ? cnt : count(str);\\n    }\\n    \\n    return count(s)\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "JavaScript"
                ],
                "code": "```\\nclass Solution {\\n    int count = -1;\\n    public int secondsToRemoveOccurrences(String s) {\\n        count++;\\n        StringBuilder str = new StringBuilder();\\n        boolean isvalid = true;\\n        for(int i=0; i<s.length(); i++){\\n            if(i < s.length()-1 && s.charAt(i) < s.charAt(i+1)){\\n                isvalid = false;\\n                str.append(s.charAt(i+1));\\n                str.append(s.charAt(i));\\n                i++;\\n            }else if(i < s.length()){\\n                str.append(s.charAt(i));\\n            }\\n        }\\n        return isvalid == true ? count : secondsToRemoveOccurrences(str.toString());\\n    }\\n}\\n```\n```\\nvar secondsToRemoveOccurrences = function(s) {\\n    let cnt = -1\\n    \\n    function count(s){\\n        cnt++\\n        str = \"\"\\n        let isvalid = true\\n        for(let i=0; i<s.length; i++){\\n            if(i < s.length-1 && s[i] < s[i+1]){\\n                isvalid = false\\n                str += s[i+1]\\n                str += s[i]\\n                i++;\\n            }else if(i < s.length){\\n                str += s[i];\\n            }\\n        }\\n        return isvalid == true ? cnt : count(str);\\n    }\\n    \\n    return count(s)\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456280,
                "title": "go-solution",
                "content": "```\\nfunc secondsToRemoveOccurrences(s string) int {\\n    var res int\\n    \\n    for strings.Contains(s, \"01\") {\\n        res++ \\n        s = strings.Replace(s, \"01\", \"10\", -1)\\n    }\\n    \\n    return res\\n}\\n\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc secondsToRemoveOccurrences(s string) int {\\n    var res int\\n    \\n    for strings.Contains(s, \"01\") {\\n        res++ \\n        s = strings.Replace(s, \"01\", \"10\", -1)\\n    }\\n    \\n    return res\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455850,
                "title": "easy-approach-c-no-dp-simple-solution-beginners-friendly",
                "content": "```\\nint secondsToRemoveOccurrences(string s) {\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            bool flag=false;\\n            for(int j=0;j<s.size()-1;j++){\\n                if(s[j]==\\'0\\' and s[j+1]==\\'1\\'){\\n                    s[j]=\\'1\\';\\n                    s[j+1]=\\'0\\';\\n                    flag=true;\\n                    j++;\\n                }\\n            }\\n            if(flag==true)\\n                count++;\\n        }\\n        return count;  \\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "String"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(string s) {\\n        int count=0;\\n        for(int i=0;i<s.size();i++){\\n            bool flag=false;\\n            for(int j=0;j<s.size()-1;j++){\\n                if(s[j]==\\'0\\' and s[j+1]==\\'1\\'){\\n                    s[j]=\\'1\\';\\n                    s[j+1]=\\'0\\';\\n                    flag=true;\\n                    j++;\\n                }\\n            }\\n            if(flag==true)\\n                count++;\\n        }\\n        return count;  \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455588,
                "title": "c-brute-force-solution-easy-to-understand",
                "content": "```\\nbool check(string& s)       //to check whether the string is in desired form or not\\n{\\n        int n=s.size();\\n        for(int i=1;i<n;i++){\\n            if(s[i-1]==\\'0\\' && s[i]==\\'1\\'){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n\\t\\tint cnt=0;           //counter\\n        int n=s.size();\\n        if(check(s)){       // if string is already in desired form\\n            return 0;\\n        }\\n        while(!check(s)){      //while string is not in desired form\\n            cnt++;           //increase the count\\n            for(int i=1;i<n;i++)      //look for zeroes and ones together and swap them\\n\\t\\t\\t{\\n                if(s[i-1]==\\'0\\' && s[i]==\\'1\\'){\\n                    // cout<<\"yes\"<<endl;\\n                    swap(s[i-1],s[i]);\\n                    i++;    //also increment i by 1 everytime as you can swap and zero and one only once in one operation\\n                }   \\n            }\\n        }\\n        return cnt;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nbool check(string& s)       //to check whether the string is in desired form or not\\n{\\n        int n=s.size();\\n        for(int i=1;i<n;i++){\\n            if(s[i-1]==\\'0\\' && s[i]==\\'1\\'){\\n                return false;\\n            }\\n            \\n        }\\n        return true;\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n\\t\\tint cnt=0;           //counter\\n        int n=s.size();\\n        if(check(s)){       // if string is already in desired form\\n            return 0;\\n        }\\n        while(!check(s)){      //while string is not in desired form\\n            cnt++;           //increase the count\\n            for(int i=1;i<n;i++)      //look for zeroes and ones together and swap them\\n\\t\\t\\t{\\n                if(s[i-1]==\\'0\\' && s[i]==\\'1\\'){\\n                    // cout<<\"yes\"<<endl;\\n                    swap(s[i-1],s[i]);\\n                    i++;    //also increment i by 1 everytime as you can swap and zero and one only once in one operation\\n                }   \\n            }\\n        }\\n        return cnt;\\n    }",
                "codeTag": "C++"
            },
            {
                "id": 2454917,
                "title": "easy-o-n-2-brute-force-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int x=s.size();\\n        int ans=0;\\n        while(x) {\\n            int y=0;\\n            for(int i=1;i<s.size();i++) {\\n                if (s[i]==\\'1\\' && s[i-1]==\\'0\\') {\\n                    swap(s[i],s[i-1]);\\n                    y++;\\n                    i++;\\n                }\\n            }\\n            if (y) ans++;\\n            x=y;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int x=s.size();\\n        int ans=0;\\n        while(x) {\\n            int y=0;\\n            for(int i=1;i<s.size();i++) {\\n                if (s[i]==\\'1\\' && s[i-1]==\\'0\\') {\\n                    swap(s[i],s[i-1]);\\n                    y++;\\n                    i++;\\n                }\\n            }\\n            if (y) ans++;\\n            x=y;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454387,
                "title": "no-math-solution",
                "content": "I spent my whole time finding a math solution for this question. Is there any?\\n",
                "solutionTags": [
                    "Math"
                ],
                "code": "",
                "codeTag": "Unknown"
            },
            {
                "id": 2454358,
                "title": "simple-beginner-friendly-c-solution-o-n-2",
                "content": "**Upvote if You Like**\\n```\\nclass Solution {\\n    bool check(string &s)\\n    {\\n        for(int i = 0; i < s.size()-1; i++)\\n            if(s[i] == \\'0\\' and s[i+1] == \\'1\\')\\n                return true;\\n        return false;\\n    }\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        if(s.size()<2) return 0;\\n        while(check(s))\\n        {\\n            ans++;\\n\\t\\t\\tint i = 0;\\n            while(i <s.size()-1)\\n            {\\n                if(s[i] == \\'0\\' and s[i+1] == \\'1\\')\\n                    s[i] = \\'1\\',s[i+1] = \\'0\\',i+=2;\\n                else\\n                    i++;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    bool check(string &s)\\n    {\\n        for(int i = 0; i < s.size()-1; i++)\\n            if(s[i] == \\'0\\' and s[i+1] == \\'1\\')\\n                return true;\\n        return false;\\n    }\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        if(s.size()<2) return 0;\\n        while(check(s))\\n        {\\n            ans++;\\n\\t\\t\\tint i = 0;\\n            while(i <s.size()-1)\\n            {\\n                if(s[i] == \\'0\\' and s[i+1] == \\'1\\')\\n                    s[i] = \\'1\\',s[i+1] = \\'0\\',i+=2;\\n                else\\n                    i++;\\n            }\\n        }\\n        return ans ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454340,
                "title": "loop-until-all-ones-placed-at-left-side-and-zeros-places-right-side",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char str_string[]=s.toCharArray();\\n        int ans=0;\\n        \\n        boolean flag_enter=true;\\n        \\n        while(flag_enter){\\n            flag_enter=false;\\n            s=new String(str_string);\\n            for(int i=0; i<s.length()-1; i++){\\n                if(s.charAt(i)==\\'0\\' && s.charAt(i+1)==\\'1\\'){  \\n                    flag_enter=true;\\n                    swapChar(str_string,i,i+1);\\n                }\\n            }\\n            if(flag_enter==true) \\n                ans++;\\n        }\\n        return ans;\\n    }\\n    void swapChar(char ch_arr[],int i,int j){\\n        char temp=ch_arr[i];\\n        ch_arr[i]=ch_arr[j];\\n        ch_arr[j]=temp;\\n    }\\n}\\n\\n\\n\\n\\n```\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char str_string[]=s.toCharArray();\\n        int ans=0;\\n        \\n        boolean flag_enter=true;\\n        \\n        while(flag_enter){\\n            flag_enter=false;\\n            s=new String(str_string);\\n            for(int i=0; i<s.length()-1; i++){\\n                if(s.charAt(i)==\\'0\\' && s.charAt(i+1)==\\'1\\'){  \\n                    flag_enter=true;\\n                    swapChar(str_string,i,i+1);\\n                }\\n            }\\n            if(flag_enter==true) \\n                ans++;\\n        }\\n        return ans;\\n    }\\n    void swapChar(char ch_arr[],int i,int j){\\n        char temp=ch_arr[i];\\n        ch_arr[i]=ch_arr[j];\\n        ch_arr[j]=temp;\\n    }\\n}\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454319,
                "title": "c-easy-approach",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int cnt=0;\\n        int fl=1; //flag helps in checking whether any \"01\" exists or not\\n        \\n        while(fl) \\n        {\\n            fl=1;\\n            for(int i=0; i<s.size(); i++)\\n            {    \\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\' && i+1<s.size()) //if \"01\" exists we convert it into \"10\"\\n                {\\n                    swap(s[i], s[i+1]);\\n                    i++;\\n                    fl=0;\\n                }    \\n            }\\n            fl = 1-fl; \\n            cnt++; //increase time by 1 unit\\n        }\\n        return cnt-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int cnt=0;\\n        int fl=1; //flag helps in checking whether any \"01\" exists or not\\n        \\n        while(fl) \\n        {\\n            fl=1;\\n            for(int i=0; i<s.size(); i++)\\n            {    \\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\' && i+1<s.size()) //if \"01\" exists we convert it into \"10\"\\n                {\\n                    swap(s[i], s[i+1]);\\n                    i++;\\n                    fl=0;\\n                }    \\n            }\\n            fl = 1-fl; \\n            cnt++; //increase time by 1 unit\\n        }\\n        return cnt-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454264,
                "title": "simple-java-solution",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char c[]=s.toCharArray();\\n        int k=0;\\n        while(s.contains(\"01\"))\\n        {\\n            \\n            for(int i=0;i<c.length-1;i++)\\n            {\\n                if(c[i]==\\'0\\' && c[i+1]==\\'1\\')\\n                {\\n                    task(c,i,i+1);\\n                    i++;\\n                }\\n            }\\n            s=String.valueOf(c);\\n            c=s.toCharArray();\\n            k++;\\n        }\\n        return k;\\n    }\\n    public void task(char c[], int i, int j)\\n    {\\n        char d=c[i];\\n        c[i]=c[j];\\n        c[j]=d;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char c[]=s.toCharArray();\\n        int k=0;\\n        while(s.contains(\"01\"))\\n        {\\n            \\n            for(int i=0;i<c.length-1;i++)\\n            {\\n                if(c[i]==\\'0\\' && c[i+1]==\\'1\\')\\n                {\\n                    task(c,i,i+1);\\n                    i++;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2454241,
                "title": "python-7-lines",
                "content": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        ans = 0\\n        while s.count(\"01\") > 0 :\\n            s = s.replace(\"01\", \"10\");\\n            ans += 1\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        ans = 0\\n        while s.count(\"01\") > 0 :\\n            s = s.replace(\"01\", \"10\");\\n            ans += 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454214,
                "title": "c-brute-force-dp-o-n-time",
                "content": "**Method 1: Brute force**\\nTime O(n^2)\\n```\\n    public int SecondsToRemoveOccurrences(string s)\\n    {\\n        int count = 0;\\n        while (s.Contains(\"01\"))\\n        {\\n            count++;\\n            s = s.Replace(\"01\", \"10\");\\n        }\\n        return count;\\n    }\\n```\\n**Method 2: DP**\\nTime O(n)\\n```\\n    public int SecondsToRemoveOccurrences(string s)\\n    {\\n        int count = 0;\\n        int zeroCount = 0;\\n        for (int i = 0; i < s.Length; ++i)\\n        {\\n            if (s[i] == \\'0\\')\\n                zeroCount++;\\n            else if (s[i] == \\'1\\' && zeroCount > 0)\\n                count = Math.Max(count + 1, zeroCount);\\n        }\\n        return count;\\n    }\\n```\\n",
                "solutionTags": [],
                "code": "```\\n    public int SecondsToRemoveOccurrences(string s)\\n    {\\n        int count = 0;\\n        while (s.Contains(\"01\"))\\n        {\\n            count++;\\n            s = s.Replace(\"01\", \"10\");\\n        }\\n        return count;\\n    }\\n```\n```\\n    public int SecondsToRemoveOccurrences(string s)\\n    {\\n        int count = 0;\\n        int zeroCount = 0;\\n        for (int i = 0; i < s.Length; ++i)\\n        {\\n            if (s[i] == \\'0\\')\\n                zeroCount++;\\n            else if (s[i] == \\'1\\' && zeroCount > 0)\\n                count = Math.Max(count + 1, zeroCount);\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3724659,
                "title": "tc-o-n-sc-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int n=s.length();\\n        int time=0,zeros=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)==\\'0\\')\\n            {\\n                zeros++;\\n            }\\n            if(s.charAt(i)==\\'1\\'&&zeros>0)\\n            {\\n                time=Math.max(time+1,zeros);\\n            }\\n\\n\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int n=s.length();\\n        int time=0,zeros=0;\\n\\n        for(int i=0;i<n;i++){\\n            if(s.charAt(i)==\\'0\\')\\n            {\\n                zeros++;\\n            }\\n            if(s.charAt(i)==\\'1\\'&&zeros>0)\\n            {\\n                time=Math.max(time+1,zeros);\\n            }\\n\\n\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3439219,
                "title": "c-very-easy-solution-beginner-friendly",
                "content": "<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int ans = 0;\\n        string temp =\"-1\";\\n        while( true )\\n        {\\n            temp = s;\\n            for( int i=1 ; i<n ; i++ )\\n            {\\n                if( s[i]==\\'1\\' && s[i-1]==\\'0\\' )\\n                {\\n                    s[i]=\\'0\\';\\n                    s[i-1]=\\'1\\';\\n                    i++;\\n                }\\n            }\\n            if( temp==s )\\n            {\\n                break;\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int ans = 0;\\n        string temp =\"-1\";\\n        while( true )\\n        {\\n            temp = s;\\n            for( int i=1 ; i<n ; i++ )\\n            {\\n                if( s[i]==\\'1\\' && s[i-1]==\\'0\\' )\\n                {\\n                    s[i]=\\'0\\';\\n                    s[i-1]=\\'1\\';\\n                    i++;\\n                }\\n            }\\n            if( temp==s )\\n            {\\n                break;\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n};\\n//<--------------\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F PLEASE UPVOTE \\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F\\u2B06\\uFE0F--------------->\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3253347,
                "title": "python3-easy-with-string-replace",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        count = 0\\n        while \"01\" in s:\\n            s = s.replace(\"01\", \"10\")\\n            count += 1\\n        return count\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        count = 0\\n        while \"01\" in s:\\n            s = s.replace(\"01\", \"10\")\\n            count += 1\\n        return count\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2930334,
                "title": "runtime-35ms-memory-13-8mb-python-solution",
                "content": "# Approach\\n- The last \"1\" will take the longest time to travel to its destination in the string, which is the number of \"0\"s infront. \\n- The special case is when \"1\" is right next to another \"1\", which will add one more step for the second 1 to move to the right.\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        n = len(s)\\n        count, res = 0, 0\\n\\n        for i in range(n):\\n            if (s[i] == \\'0\\'):\\n                count += 1\\n            else:\\n                if count > 0:\\n                    res = max(res+1, count)\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        n = len(s)\\n        count, res = 0, 0\\n\\n        for i in range(n):\\n            if (s[i] == \\'0\\'):\\n                count += 1\\n            else:\\n                if count > 0:\\n                    res = max(res+1, count)\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2864901,
                "title": "simple-o-n-solution",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        \\n        int n = s.length();\\n        int zero =0;\\n        int ans =0;\\n        for(int i=0; i< n ; i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                zero++;\\n            }else{\\n                if(zero>0)\\n                ans = Math.max(ans+1, zero);\\n            }\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        \\n        int n = s.length();\\n        int zero =0;\\n        int ans =0;\\n        for(int i=0; i< n ; i++){\\n            if(s.charAt(i)==\\'0\\'){\\n                zero++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2677222,
                "title": "python-beginner-easy-81-faster",
                "content": "**Please upvode if it helps...**\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c=0\\n        for i in range(len(s)):\\n            if \"01\" in s:\\n                s=s.replace(\"01\",\"10\")\\n                c+=1\\n        return(c)\\n\\t\\t```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c=0\\n        for i in range(len(s)):\\n            if \"01\" in s:\\n                s=s.replace(\"01\",\"10\")\\n                c+=1\\n        return(c)\\n\\t\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2675000,
                "title": "brute-force-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        bool flag=false;\\n    \\n        for(int i=0;i<s.length()-1;)\\n        {\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\')\\n            {\\n                flag=true;\\n                swap(s[i],s[i+1]);\\n                i++;\\n                i++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n\\n        if(flag==false)\\n        return 0;\\n\\n        return 1+secondsToRemoveOccurrences(s);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        bool flag=false;\\n    \\n        for(int i=0;i<s.length()-1;)\\n        {\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\')\\n            {\\n                flag=true;\\n                swap(s[i],s[i+1]);\\n                i++;\\n                i++;\\n            }\\n            else\\n            {\\n                i++;\\n            }\\n        }\\n\\n        if(flag==false)\\n        return 0;\\n\\n        return 1+secondsToRemoveOccurrences(s);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2605893,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int n = 0;\\n        while(s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++n;\\n        }\\n        return n;\\n    }\\n}\\n```\\nDo upvote if you find helpful !",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int n = 0;\\n        while(s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++n;\\n        }\\n        return n;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2558947,
                "title": "c-don-t-know-the-time-complexity-simple-iterative",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        string s1=s;\\n        int n=s.size();\\n        int seconds=0;\\n        int count=0;\\n        do{\\n            count=0;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    count++;\\n                    s1[i]=\\'1\\';\\n                    s1[i+1]=\\'0\\';\\n                }\\n            }\\n            s=s1;\\n            if(count!=0)\\n                seconds++;\\n        }while(count!=0);\\n        return seconds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        string s1=s;\\n        int n=s.size();\\n        int seconds=0;\\n        int count=0;\\n        do{\\n            count=0;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    count++;\\n                    s1[i]=\\'1\\';\\n                    s1[i+1]=\\'0\\';\\n                }\\n            }\\n            s=s1;\\n            if(count!=0)\\n                seconds++;\\n        }while(count!=0);\\n        return seconds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2554095,
                "title": "rust-0-ms-functional-style-one-liner-with-detailed-comments",
                "content": "This [solution](https://leetcode.com/submissions/detail/795590438/) employs a functional-style approach to scan the string and count swaps. It demonstrated **0 ms runtime (100%)** and used **2.0 MB memory (83.87%)**. Detailed comments are provided.\\n\\n**IF YOU LIKE THIS SOLUTION, PLEASE UPVOTE.**\\n```\\nimpl Solution \\n{\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 \\n    {\\n        s.chars()\\n        // [1] leading \\'1\\'s are irrelevant \\n            .skip_while(|&c| c == \\'1\\')\\n        // [2] while iterating, we keep track of zeros and compute swaps\\n            .fold(\\n                (0,0), |(swaps, zeros), c|\\n        // [3] when we encounter \\'1\\', we conclude that the amount \\n        //     of swaps it requires to travel to left is not less than:\\n        //     - the amount of zeros seen before\\n        //     - the amount of swaps needed for previous \\'1\\'s plus one (if blocked)\\n                match c \\n                {\\n                    \\'1\\' => ((swaps + 1).max(zeros), zeros),\\n                    \\'0\\' => (swaps, zeros + 1),\\n                    _   => unreachable!(\"Wrong symbol {}\", c)\\n                }\\n            ).0 as i32\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution \\n{\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 \\n    {\\n        s.chars()\\n        // [1] leading \\'1\\'s are irrelevant \\n            .skip_while(|&c| c == \\'1\\')\\n        // [2] while iterating, we keep track of zeros and compute swaps\\n            .fold(\\n                (0,0), |(swaps, zeros), c|\\n        // [3] when we encounter \\'1\\', we conclude that the amount \\n        //     of swaps it requires to travel to left is not less than:\\n        //     - the amount of zeros seen before\\n        //     - the amount of swaps needed for previous \\'1\\'s plus one (if blocked)\\n                match c \\n                {\\n                    \\'1\\' => ((swaps + 1).max(zeros), zeros),\\n                    \\'0\\' => (swaps, zeros + 1),\\n                    _   => unreachable!(\"Wrong symbol {}\", c)\\n                }\\n            ).0 as i32\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2482625,
                "title": "2-appoach-dp-o-n-bruteforce-o-n-n",
                "content": "DP APPROACH\\n\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string a) {\\n        int n=a.size();\\n        int zero=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==\\'0\\')zero++;\\n            else{\\n                if(i>0&&a[i-1]==\\'1\\'&&zero>0)ans++;\\n                else if(i>0&&a[i-1]==\\'0\\'){\\n                    ans=max(ans+1,zero);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\nif(a[i]==0)\\n    does nt matter because we are coming from left to right and we have at the end of string till i is 0 and its placed correctly\\nif(a[i]==1){\\n    last = a[i-1]\\n    if(last==1){\\n        if(num of zeres till here are zero){ \\n            then its fine, no increment in answwert answer reamins 0 only because string till here is -> 111...i times\\n        }\\n        else if(numOfZero>0){\\n            then number of steps to make string i valid till here would be 1 greater than the steps required to make string valid till i-1\\n            to know y, dry run the problemStatment for the example 01 and 011.\\n        }\\n    }else if(last==\\'0\\'){\\n        0001\\n            then ans will be number of zereos before this\\n        or \\n        01111101\\n            then ans will be current ans+1, i.e. ( number of steps to make string i valid till here would be 1 greater than the steps required to make string valid till last 1)\\n            \\n        // simple mai agr zeroes bht zda aagye hai last 1 aur is one k bich mai then answer is total number of zereos till ith \\n        else bht sare one hogye toh asnwer is 1+ last one ji b tha :)\\n    }\\n}\\n*/\\n```\\n\\nBRUTE FORCE :\\n\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        bool ok=true;\\n        int ans=0;\\n        while(ok){\\n            ok=false;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\'&&s[i+1]==\\'1\\'){\\n                    swap(s[i],s[i+1]);i++;\\n                    ok=true;\\n                }\\n            }\\n            if(ok)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string a) {\\n        int n=a.size();\\n        int zero=0,ans=0;\\n        for(int i=0;i<n;i++){\\n            if(a[i]==\\'0\\')zero++;\\n            else{\\n                if(i>0&&a[i-1]==\\'1\\'&&zero>0)ans++;\\n                else if(i>0&&a[i-1]==\\'0\\'){\\n                    ans=max(ans+1,zero);\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n/*\\nif(a[i]==0)\\n    does nt matter because we are coming from left to right and we have at the end of string till i is 0 and its placed correctly\\nif(a[i]==1){\\n    last = a[i-1]\\n    if(last==1){\\n        if(num of zeres till here are zero){ \\n            then its fine, no increment in answwert answer reamins 0 only because string till here is -> 111...i times\\n        }\\n        else if(numOfZero>0){\\n            then number of steps to make string i valid till here would be 1 greater than the steps required to make string valid till i-1\\n            to know y, dry run the problemStatment for the example 01 and 011.\\n        }\\n    }else if(last==\\'0\\'){\\n        0001\\n            then ans will be number of zereos before this\\n        or \\n        01111101\\n            then ans will be current ans+1, i.e. ( number of steps to make string i valid till here would be 1 greater than the steps required to make string valid till last 1)\\n            \\n        // simple mai agr zeroes bht zda aagye hai last 1 aur is one k bich mai then answer is total number of zereos till ith \\n        else bht sare one hogye toh asnwer is 1+ last one ji b tha :)\\n    }\\n}\\n*/\\n```\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.size();\\n        bool ok=true;\\n        int ans=0;\\n        while(ok){\\n            ok=false;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\'&&s[i+1]==\\'1\\'){\\n                    swap(s[i],s[i+1]);i++;\\n                    ok=true;\\n                }\\n            }\\n            if(ok)ans++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478370,
                "title": "python-brute-force-step-by-step-solution-small-solution",
                "content": "### **Brute Force Solution**\\n\\n```\\nclass Solution:\\n\\tdef secondsToRemoveOccurrences(self, s: str) -> int:\\n\\t\\tcount = 0\\n\\t\\ttemp = \"\"\\n\\t\\tones = s.count(\"1\") # get the count of 1\\n\\t\\tfor _ in range(ones):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tmake a string with total number of 1\\n\\t\\t\\t\"\"\"\\n\\t\\t\\ttemp += \"1\"\\n\\n\\t\\twhile s[:ones] != temp:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tloop through index 0 to count of 1 while the string is not equal to temp string\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tleft, right = 0, 1\\n\\t\\t\\twhile right < len(s):\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tCompare the two index from left to right if\\n\\t\\t\\t\\tthey both are equal to \"01\"\\n\\t\\t\\t\\tif so then replace them\\n\\t\\t\\t\\tand count the number of occurrence\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tif s[left : left + 1] + s[right : right + 1] == \"01\":\\n\\t\\t\\t\\t\\ts = s.replace(s[left : left + 1] + s[right : right + 1], \"10\")\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tleft += 1\\n\\t\\t\\t\\tright += 1\\n\\t\\treturn count\\n```\\n\\n### **Easy & Small Solution**\\n\\n```\\nclass Solution:\\n\\tdef secondsToRemoveOccurrences(self, s: str) -> int:\\n\\t\\tcount = 0\\n\\t\\twhile \"01\" in s:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tWhile we are getting \"01\" in the string\\n\\t\\t\\twe will replace them into \"10\"\\n\\t\\t\\tand count the number of occurrence\\n\\t\\t\\t\"\"\"\\n\\t\\t\\ts = s.replace(\"01\", \"10\")\\n\\t\\t\\tcount += 1\\n\\t\\treturn count\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n\\tdef secondsToRemoveOccurrences(self, s: str) -> int:\\n\\t\\tcount = 0\\n\\t\\ttemp = \"\"\\n\\t\\tones = s.count(\"1\") # get the count of 1\\n\\t\\tfor _ in range(ones):\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tmake a string with total number of 1\\n\\t\\t\\t\"\"\"\\n\\t\\t\\ttemp += \"1\"\\n\\n\\t\\twhile s[:ones] != temp:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tloop through index 0 to count of 1 while the string is not equal to temp string\\n\\t\\t\\t\"\"\"\\n\\n\\t\\t\\tleft, right = 0, 1\\n\\t\\t\\twhile right < len(s):\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tCompare the two index from left to right if\\n\\t\\t\\t\\tthey both are equal to \"01\"\\n\\t\\t\\t\\tif so then replace them\\n\\t\\t\\t\\tand count the number of occurrence\\n\\t\\t\\t\\t\"\"\"\\n\\t\\t\\t\\tif s[left : left + 1] + s[right : right + 1] == \"01\":\\n\\t\\t\\t\\t\\ts = s.replace(s[left : left + 1] + s[right : right + 1], \"10\")\\n\\t\\t\\t\\t\\tcount += 1\\n\\t\\t\\t\\tleft += 1\\n\\t\\t\\t\\tright += 1\\n\\t\\treturn count\\n```\n```\\nclass Solution:\\n\\tdef secondsToRemoveOccurrences(self, s: str) -> int:\\n\\t\\tcount = 0\\n\\t\\twhile \"01\" in s:\\n\\t\\t\\t\"\"\"\\n\\t\\t\\tWhile we are getting \"01\" in the string\\n\\t\\t\\twe will replace them into \"10\"\\n\\t\\t\\tand count the number of occurrence\\n\\t\\t\\t\"\"\"\\n\\t\\t\\ts = s.replace(\"01\", \"10\")\\n\\t\\t\\tcount += 1\\n\\t\\treturn count\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466135,
                "title": "java-solution-2-3-ms",
                "content": "1. Any **\"1\"** needs to pass all **\"0\"** before it. -> Count the number of **\"0\"**\\n2. **00 ... 00 111**\\n* Suppose first **\"1\"** need **m** steps to pass all **\"0\"** before it.\\n* Second **\"1\"** need **m+1** steps\\n* Third **\"1\"** need **m+2** steps\\n* Summary: count steps of previous **\"1\"** + 1\\n3. **00 ... 00 1 00 ... 00 1**\\n* Suppose the number of **\"0\"** between **\"1\"** s are **n** and first **\"1\"** need **m** steps\\n* If there is a X, X >= n and X < m, String s becomes **00 ... 00 11 00 ... 00** after X steps and Y is the remaining steps for first **\"1\"** to pass all **\"0\"**\\n* The remaining steps of second **\"1\"** is Y+1 -> the total steps of second **\"1\"** is X+Y+1 = m+1\\n* If X does not exist, count zeros before it because first **\"1\"** won\\'t impact second **\"1\"**\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int zero = 0;\\n        int step = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') zero++;\\n            else if (zero > 0) step = Math.max(step+1, zero);\\n        }\\n        return step;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int zero = 0;\\n        int step = 0;\\n        for (int i = 0; i < s.length(); i++) {\\n            if (s.charAt(i) == \\'0\\') zero++;\\n            else if (zero > 0) step = Math.max(step+1, zero);\\n        }\\n        return step;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459556,
                "title": "easy-to-understand-c-simple",
                "content": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        \\n        int c=0;\\n        int z;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            z=s.find(\"01\");\\n            if(s[0]==\\'0\\' && s[1]==\\'1\\')\\n            {\\n                z=1;\\n            }\\n            if(z>0)\\n            {\\n                 for(int j=0;j<s.size()-1;j++)\\n                 {\\n                     if(s[j]==\\'0\\' && s[j+1]==\\'1\\')\\n                     {\\n                            s[j]=\\'1\\';\\n                           s[j+1]=\\'0\\';\\n                           j++;\\n                     }\\n                 }\\n              \\n            }\\n            else\\n            {\\n                break;\\n            }\\n            c++;\\n           \\n        }\\n       return c;   \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        \\n        int c=0;\\n        int z;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            z=s.find(\"01\");\\n            if(s[0]==\\'0\\' && s[1]==\\'1\\')\\n            {\\n                z=1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2459235,
                "title": "java-bruteforce-approach",
                "content": "\\t private static int secondsToRemoveOccurrences(String s) {\\n        int count =0;\\n        for (int i = 0; i <s.length() ; i++) {\\n            if(s.contains(\"01\")){\\n             s = new String(s.replaceAll(\"01\",\"10\"));\\n                count++;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        return count;\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "\\t private static int secondsToRemoveOccurrences(String s) {\\n        int count =0;\\n        for (int i = 0; i <s.length() ; i++) {\\n            if(s.contains(\"01\")){\\n             s = new String(s.replaceAll(\"01\",\"10\"));\\n                count++;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n        return count;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2458555,
                "title": "c-brute-force-solution-74-ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        \\n        int res=0;\\n        while(true)\\n      { \\n              int i=0,j=1;\\n            int n=s.size();\\n            int cnt=0; // to count the number of \"01\" occured in string\\n            while(j<n){\\n                    if(s[i]==\\'0\\'&&s[j]==\\'1\\'){\\n                        swap(s[i],s[j]);\\n                        cnt++;\\n                        i+=2; // we have to jump to next pair of i,j ;\\n                        j+=2;\\n                        continue;\\n                    }\\n                      i++;\\n                      j++; \\n            }\\n             if(cnt==0)return res;\\n            res++;\\n      } \\n        return 0;\\n        \\n    }\\n};\\n```\\n\\nplease upvote if post is helpful for you.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        \\n        int res=0;\\n        while(true)\\n      { \\n              int i=0,j=1;\\n            int n=s.size();\\n            int cnt=0; // to count the number of \"01\" occured in string\\n            while(j<n){\\n                    if(s[i]==\\'0\\'&&s[j]==\\'1\\'){\\n                        swap(s[i],s[j]);\\n                        cnt++;\\n                        i+=2; // we have to jump to next pair of i,j ;\\n                        j+=2;\\n                        continue;\\n                    }\\n                      i++;\\n                      j++; \\n            }\\n             if(cnt==0)return res;\\n            res++;\\n      } \\n        return 0;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458298,
                "title": "java-easy-approach-less-space-complexity",
                "content": "It is a very easy approach just, we have to do one thing that if \"01\" is present in the string, then replace it with \"10\" untill all \"01\" is vanished. \\n\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\")){\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return  count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\")){\\n            s=s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return  count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458069,
                "title": "o-n-time-o-1-space-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), zero = 0, ans = 0;\\n        \\n        for(int i = 0;i < n;++i)\\n        {\\n            if(s[i] == \\'0\\')\\n                ++zero;\\n            else if(zero)\\n                ans = max(ans + 1, zero);\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size(), zero = 0, ans = 0;\\n        \\n        for(int i = 0;i < n;++i)\\n        {\\n            if(s[i] == \\'0\\')\\n                ++zero;\\n            else if(zero)\\n                ans = max(ans + 1, zero);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2458003,
                "title": "java-ac-solution-60-faster",
                "content": "\\n\\t \\n\\t class Solution {\\n      public int secondsToRemoveOccurrences(String s) {\\n        \\n        char ch[] = s.toCharArray();\\n        boolean change = false;\\n        int c=0;\\n        // 1 1 1 1 0 0 0\\n        while(true)\\n        {\\n             for(int i=0;i<ch.length-1;){\\n            \\n            if(ch[i]==\\'0\\' && ch[i+1]==\\'1\\'){\\n                ch[i]=(char)(49);\\n                ch[i+1]=(char)(48);\\n                i+=2;\\n                change = true;\\n                // System.out.println(1);\\n                continue;\\n            } \\n            i++;\\n        }\\n            if(change==true)\\n            {\\n              c++;\\n              change = false;\\n            }\\n            else if(change == false){\\n                break;\\n            }\\n            \\n            \\n        }\\n        return c;\\n        \\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n      public int secondsToRemoveOccurrences(String s) {\\n        \\n        char ch[] = s.toCharArray();\\n        boolean change = false;\\n        int c=0;\\n        // 1 1 1 1 0 0 0\\n        while(true)\\n        {\\n             for(int i=0;i<ch.length-1;){\\n            \\n            if(ch[i]==\\'0\\' && ch[i+1]==\\'1\\'){\\n                ch[i]=(char)(49);\\n                ch[i+1]=(char)(48);\\n                i+=2;\\n                change = true;\\n                // System.out.println(1);\\n                continue;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2457683,
                "title": "python3-for-beiginners",
                "content": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c=0\\n        while \\'01\\' in s:\\n            s=s.replace(\\'01\\',\\'10\\')\\n            c+=1\\n        return c\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c=0\\n        while \\'01\\' in s:\\n            s=s.replace(\\'01\\',\\'10\\')\\n            c+=1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456194,
                "title": "python-o-n",
                "content": "finally the string will become \"11111...00000\", when encoutner a `\"1\"` we try to move it to the final position `final_pos`, it might be delayed when there are multiple `\"1\"`s stick together, bc you have to wait for the closest `\"0\"` to come, delay can be mitigated by an appearance of a `\"0\"`.\\n```\\ndef secondsToRemoveOccurrences(self, s: str) -> int:\\n        res = final_pos = delay = 0\\n        for i,v in enumerate(s):\\n            if v==\"1\":\\n                if i>final_pos:\\n                    res = max(res, i-final_pos+delay)\\n                    delay+=1\\n                final_pos+=1\\n            elif delay:\\n                delay-=1\\n        return res",
                "solutionTags": [],
                "code": "finally the string will become \"11111...00000\", when encoutner a `\"1\"` we try to move it to the final position `final_pos`, it might be delayed when there are multiple `\"1\"`s stick together, bc you have to wait for the closest `\"0\"` to come, delay can be mitigated by an appearance of a `\"0\"`.\\n```\\ndef secondsToRemoveOccurrences(self, s: str) -> int:\\n        res = final_pos = delay = 0\\n        for i,v in enumerate(s):\\n            if v==\"1\":\\n                if i>final_pos:\\n                    res = max(res, i-final_pos+delay)\\n                    delay+=1\\n                final_pos+=1\\n            elif delay:\\n                delay-=1\\n        return res",
                "codeTag": "C++"
            },
            {
                "id": 2456038,
                "title": "javascript-brute-force",
                "content": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nfunction secondsToRemoveOccurrences(s) {\\n  const arr = s.split(\\'\\'),\\n    n = s.length\\n  let count = 0\\n  while (true) {\\n    let allSorted = true\\n    for (let i = n - 2; i >= 0; i--) {\\n      if (arr[i] === \\'0\\' && arr[i + 1] === \\'1\\') {\\n        allSorted = false\\n        const temp = arr[i + 1]\\n        arr[i + 1] = arr[i]\\n        arr[i] = temp\\n        i--\\n      }\\n    }\\n    if (allSorted) break\\n    count++\\n  }\\n  return count\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @return {number}\\n */\\nfunction secondsToRemoveOccurrences(s) {\\n  const arr = s.split(\\'\\'),\\n    n = s.length\\n  let count = 0\\n  while (true) {\\n    let allSorted = true\\n    for (let i = n - 2; i >= 0; i--) {\\n      if (arr[i] === \\'0\\' && arr[i + 1] === \\'1\\') {\\n        allSorted = false\\n        const temp = arr[i + 1]\\n        arr[i + 1] = arr[i]\\n        arr[i] = temp\\n        i--\\n      }\\n    }\\n    if (allSorted) break\\n    count++\\n  }\\n  return count\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455948,
                "title": "simple-rust-solution-explained-2ms-o-n-time-o-1-mem",
                "content": "Firstly, we need to understand that in this problem we need to find how many steps will it take the rightmost one to travel all the way to the left. \\n\\nImagine input `00001`: one needs to travel to the left as many steps as there are zeroes before it. If there are some ones in the very beginning they won\\'t make a difference: `11100001`, so we ignore all the ones before the first zero. \\n\\nThen the question is what happens if there are two ones in a row: `000011`. Second one is blocked on the very first step, but then it can travel in parallel with the first one. So, it will always be 1 step slower than the previous one. Note, that it still needs to travel as many steps as there are zeroes before it + maybe get blocked by other ones. \\n\\nIf there are few blocks of ones interchanged with zeroes it doesn\\'t really change anything. If our last one catches up with a block of ones (`011.111.001 -> 110.111.100 -> 111.110.100` - dots just for visibility) it will need at least 1 more second than the previous one, but not less than number of zeroes (ex. `011.111.000000000000000001`).\\n\\n\\n```rust\\nuse std::cmp;\\nimpl Solution {\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 {\\n        let mut zeroes=0;\\n        let mut started = false; \\n        let mut last=0;\\n        for c in s.chars(){\\n            if c==\\'1\\'{\\n                if started {\\n                    last = cmp::max(last+1, zeroes);\\n                }else{\\n                    continue;\\n                }\\n            }else{\\n                if !started {\\n                    started = true\\n                }   \\n                zeroes+=1;\\n            }\\n        }\\n        return last;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```rust\\nuse std::cmp;\\nimpl Solution {\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 {\\n        let mut zeroes=0;\\n        let mut started = false; \\n        let mut last=0;\\n        for c in s.chars(){\\n            if c==\\'1\\'{\\n                if started {\\n                    last = cmp::max(last+1, zeroes);\\n                }else{\\n                    continue;\\n                }\\n            }else{\\n                if !started {\\n                    started = true\\n                }   \\n                zeroes+=1;\\n            }\\n        }\\n        return last;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455367,
                "title": "java-simple-solution-clean-code-easy-approach",
                "content": "```\\nclass Solution {\\n            public int secondsToRemoveOccurrences(String s) {\\n                StringBuilder sb=new StringBuilder(s);\\n                int ans=0;\\n                while(sb.indexOf(\"01\")!=-1){\\n                    ans++;\\n                    int i=0;\\n                    while(i<sb.length()-1){\\n                        if(sb.charAt(i)==\\'0\\' && sb.charAt(i+1)==\\'1\\') {\\n                            sb.setCharAt(i, \\'1\\');\\n                            sb.setCharAt(i + 1, \\'0\\');\\n                            i = i + 2;\\n                        }\\n                        else{\\n                            i++;\\n                        }\\n                    }\\n                }return ans;\\n            }\\n        }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n            public int secondsToRemoveOccurrences(String s) {\\n                StringBuilder sb=new StringBuilder(s);\\n                int ans=0;\\n                while(sb.indexOf(\"01\")!=-1){\\n                    ans++;\\n                    int i=0;\\n                    while(i<sb.length()-1){\\n                        if(sb.charAt(i)==\\'0\\' && sb.charAt(i+1)==\\'1\\') {\\n                            sb.setCharAt(i, \\'1\\');\\n                            sb.setCharAt(i + 1, \\'0\\');\\n                            i = i + 2;\\n                        }\\n                        else{\\n                            i++;\\n                        }\\n                    }\\n                }return ans;\\n            }\\n        }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455308,
                "title": "cpp-java-python-dp-brute-force-tc-0-n-2-o-n-sc-o-n-o-1",
                "content": "**Please Upvote, If you like this solutions.**\\n\\n```\\n// Brute-Force - CPP\\n// Time - O(N*2) \\n// Space - O(1)\\n\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n       int cnt = 0; bool flag = true;\\n        while(flag){\\n            flag = false;\\n            \\n            for(int i = 0; i < s.size()-1; ++i){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    swap(s[i],s[i+1]);\\n                    flag = true;\\n                    ++i;\\n                }     \\n            }\\n            \\n            cnt += flag;\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\n```\\n// DP - CP\\n// Time - O(N)\\n// Space - O(1)\\n\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int zeros = 0, seconds = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            zeros += s[i] == \\'0\\' ? 1 : 0;\\n            if (s[i] == \\'1\\' && zeros > 0)\\n                seconds = max(seconds + 1, zeros);\\n        }\\n        return seconds; \\n    }\\n};\\n```\\n\\n```\\n// Java Solution\\n// TIme - O(N)\\n// Space - O(1) \\n\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int seconds = 0;\\n        while (s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++seconds;\\n        }\\n        return seconds;\\n    }\\n}\\n```\\n```\\n# Python \\n# Time - O(N)\\n# Space - O(1)\\n\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        waitingTime = 0\\n        cntZeros = 0\\n        lastOcc = s.rfind(\\'1\\')\\n    \\n        for i in range(lastOcc + 1):\\n\\n            if i > 0 and s[i] == \\'1\\' and s[i - 1] == \\'1\\' and cntZeros > 0:\\n                waitingTime += 1\\n    \\n            if i > 0 and s[i] == \\'0\\' and s[i - 1] == \\'0\\' and waitingTime > 0:\\n                waitingTime -= 1\\n            \\n            if s[i] == \\'0\\':\\n                cntZeros += 1\\n                \\n        return cntZeros + waitingTime\\n\\t\\t\\n```\\n\\n**Thank you...**\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\n// Brute-Force - CPP\\n// Time - O(N*2) \\n// Space - O(1)\\n\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n       int cnt = 0; bool flag = true;\\n        while(flag){\\n            flag = false;\\n            \\n            for(int i = 0; i < s.size()-1; ++i){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    swap(s[i],s[i+1]);\\n                    flag = true;\\n                    ++i;\\n                }     \\n            }\\n            \\n            cnt += flag;\\n        }\\n        return cnt;\\n    }\\n};\\n```\n```\\n// DP - CP\\n// Time - O(N)\\n// Space - O(1)\\n\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int zeros = 0, seconds = 0;\\n        for (int i = 0; i < s.size(); ++i) {\\n            zeros += s[i] == \\'0\\' ? 1 : 0;\\n            if (s[i] == \\'1\\' && zeros > 0)\\n                seconds = max(seconds + 1, zeros);\\n        }\\n        return seconds; \\n    }\\n};\\n```\n```\\n// Java Solution\\n// TIme - O(N)\\n// Space - O(1) \\n\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int seconds = 0;\\n        while (s.indexOf(\"01\") >= 0) {\\n            s = s.replace(\"01\", \"10\");\\n            ++seconds;\\n        }\\n        return seconds;\\n    }\\n}\\n```\n```\\n# Python \\n# Time - O(N)\\n# Space - O(1)\\n\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        waitingTime = 0\\n        cntZeros = 0\\n        lastOcc = s.rfind(\\'1\\')\\n    \\n        for i in range(lastOcc + 1):\\n\\n            if i > 0 and s[i] == \\'1\\' and s[i - 1] == \\'1\\' and cntZeros > 0:\\n                waitingTime += 1\\n    \\n            if i > 0 and s[i] == \\'0\\' and s[i - 1] == \\'0\\' and waitingTime > 0:\\n                waitingTime -= 1\\n            \\n            if s[i] == \\'0\\':\\n                cntZeros += 1\\n                \\n        return cntZeros + waitingTime\\n\\t\\t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455044,
                "title": "c-solution-using-two-loops",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string &s) {\\n        int res = 0, n = s.size();\\n        for (int i = 0; i < n; i++) {\\n            bool flag = false;\\n            for (int j = 0; j < n - 1; j++) {\\n                if (s[j] == \\'0\\' && s[j + 1] == \\'1\\') {\\n                    flag = true;\\n                    swap(s[j], s[j + 1]);\\n                    j++;\\n                }\\n            }\\n            if (flag) res++;\\n            else break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string &s) {\\n        int res = 0, n = s.size();\\n        for (int i = 0; i < n; i++) {\\n            bool flag = false;\\n            for (int j = 0; j < n - 1; j++) {\\n                if (s[j] == \\'0\\' && s[j + 1] == \\'1\\') {\\n                    flag = true;\\n                    swap(s[j], s[j + 1]);\\n                    j++;\\n                }\\n            }\\n            if (flag) res++;\\n            else break;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454872,
                "title": "c-easy-solution-by-swaping",
                "content": "**C++ Code:**\\n\\n```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.length();\\n        int time = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n             bool happen = false;\\n            for(int j=0;j<n-1;)\\n            {\\n                if(s[j]==\\'0\\'&& s[j+1]==\\'1\\'){\\n                    swap(s[j],s[j+1]);\\n                    j = j+2;\\n                    happen = true;\\n                }\\n                else j++;\\n            }\\n            if(happen)\\n            time ++;\\n            else break;\\n        }\\n        return time;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(string s) {\\n        int n = s.length();\\n        int time = 0;\\n        for(int i=0;i<n;i++)\\n        {\\n             bool happen = false;\\n            for(int j=0;j<n-1;)\\n            {\\n                if(s[j]==\\'0\\'&& s[j+1]==\\'1\\'){\\n                    swap(s[j],s[j+1]);\\n                    j = j+2;\\n                    happen = true;\\n                }\\n                else j++;\\n            }\\n            if(happen)\\n            time ++;\\n            else break;\\n        }\\n        return time;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454742,
                "title": "easy-c-code",
                "content": "class Solution {\\npublic:\\n\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt = 0;\\n        bool flag = false;\\n        while(flag == false) {\\n            flag = true;\\n            for(int i = 0; i < s.size(); ) {\\n                if(i + 1 < s.size() and s[i] == \\'0\\' and s[i + 1] == \\'1\\') {\\n                    if(flag) {\\n                        cnt++;\\n                        flag = false;\\n                    }\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i+=2;\\n                }\\n                else i++;\\n            }      \\n        }\\n        return cnt;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt = 0;\\n        bool flag = false;\\n        while(flag == false) {\\n            flag = true;\\n            for(int i = 0; i < s.size(); ) {\\n                if(i + 1 < s.size() and s[i] == \\'0\\' and s[i + 1] == \\'1\\') {\\n                    if(flag) {\\n                        cnt++;\\n                        flag = false;\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2454731,
                "title": "java-easy-understanding-o-n-2",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        //int flag=1;\\n        int seconds=0;\\n        String curr= s;\\n        while(true){\\n            StringBuilder newString= new StringBuilder();\\n            int zeroOneFlag=0;\\n            for(int i=0;i<curr.length()-1;i++){\\n                if(curr.charAt(i)==\\'0\\' && curr.charAt(i+1)==\\'1\\'){\\n                    newString.append(\"10\");\\n                    i++;\\n                    zeroOneFlag=1;\\n                    if(i+1==curr.length()-1){\\n                        newString.append(curr.charAt(i+1));\\n                    }\\n                }\\n                else{\\n                    newString.append(curr.charAt(i));\\n                    if(i+1==curr.length()-1){\\n                        newString.append(curr.charAt(i+1));\\n                    }\\n                }\\n            }\\n            if(zeroOneFlag==0){\\n                break;\\n            }\\n            seconds++;\\n            //System.out.println(curr);\\n            curr= newString.toString();\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        //int flag=1;\\n        int seconds=0;\\n        String curr= s;\\n        while(true){\\n            StringBuilder newString= new StringBuilder();\\n            int zeroOneFlag=0;\\n            for(int i=0;i<curr.length()-1;i++){\\n                if(curr.charAt(i)==\\'0\\' && curr.charAt(i+1)==\\'1\\'){\\n                    newString.append(\"10\");\\n                    i++;\\n                    zeroOneFlag=1;\\n                    if(i+1==curr.length()-1){\\n                        newString.append(curr.charAt(i+1));\\n                    }\\n                }\\n                else{\\n                    newString.append(curr.charAt(i));\\n                    if(i+1==curr.length()-1){\\n                        newString.append(curr.charAt(i+1));\\n                    }\\n                }\\n            }\\n            if(zeroOneFlag==0){\\n                break;\\n            }\\n            seconds++;\\n            //System.out.println(curr);\\n            curr= newString.toString();\\n        }\\n        return seconds;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454695,
                "title": "best-java-solution-easy",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\")){\\n            s=s.replaceAll(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(s.contains(\"01\")){\\n            s=s.replaceAll(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454658,
                "title": "c-easy-beginner",
                "content": "\\'\\'\\'\\n\\n\\tint size=s.length();\\n        int arr[size];\\n        for(int i=0;i<size;i++)\\n        {\\n            arr[i]=s[i]-48;\\n        }\\n        \\n        int ones=0;\\n        for (int i=0;i<size;i++)\\n        {\\n            if(arr[i]==1) ones++;\\n        }\\n        int ans=0;\\n        int k=0;\\n        int s1=0;\\n        while(k==0)\\n        {\\n            for (int i=1;i<size;i++)\\n            {\\n                if (arr[i]==1 && arr[i-1]==0)\\n                {\\n                    int temp=arr[i];\\n                    arr[i]=arr[i-1];\\n                    arr[i-1]=temp;   \\n                    i++;\\n                    s1++;\\n                }   \\n            }\\n            if (s1==0) return ans;\\n            ans++;\\n            int a=0;\\n            int b=0;\\n            for (int i=0;i<size;i++)\\n            {\\n                if (arr[i]==1) a++;\\n                else\\n                {\\n                    b=max(b,a);\\n                    a=0;\\n                }\\n            }\\n            if (b==ones)\\n            {\\n                k=1;\\n            }\\n        }\\n        return ans;\\n\\t\\'\\'\\'",
                "solutionTags": [],
                "code": "\\'\\'\\'\\n\\n\\tint size=s.length();\\n        int arr[size];\\n        for(int i=0;i<size;i++)\\n        {\\n            arr[i]=s[i]-48;\\n        }\\n        \\n        int ones=0;\\n        for (int i=0;i<size;i++)\\n        {\\n            if(arr[i]==1) ones++;\\n        }\\n        int ans=0;\\n        int k=0;\\n        int s1=0;\\n        while(k==0)\\n        {\\n            for (int i=1;i<size;i++)\\n            {\\n                if (arr[i]==1 && arr[i-1]==0)\\n                {\\n                    int temp=arr[i];\\n                    arr[i]=arr[i-1];\\n                    arr[i-1]=temp;   \\n                    i++;\\n                    s1++;\\n                }   \\n            }\\n            if (s1==0) return ans;\\n            ans++;\\n            int a=0;\\n            int b=0;\\n            for (int i=0;i<size;i++)\\n            {\\n                if (arr[i]==1) a++;\\n                else\\n                {\\n                    b=max(b,a);\\n                    a=0;\\n                }\\n            }\\n            if (b==ones)\\n            {\\n                k=1;\\n            }\\n        }\\n        return ans;\\n\\t\\'\\'\\'",
                "codeTag": "Unknown"
            },
            {
                "id": 2454548,
                "title": "rust-solution",
                "content": "~~~\\nimpl Solution {\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 {\\n        let mut s = s.chars().collect::<Vec<char>>();\\n        let mut finished = false;\\n        let mut ret = 0;\\n        \\n        while finished == false {\\n            finished = true;\\n            let mut i = 0;\\n            \\n            while i < s.len() - 1 {\\n                if s[i] == \\'0\\' && s[i + 1] == \\'1\\' {\\n                    s.swap(i, i + 1);\\n                    i += 2;\\n                    finished = false;\\n                } else { \\n                    i += 1; \\n                }\\n            }\\n            \\n            if finished == false { ret += 1; }\\n        }\\n        \\n        ret\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust"
                ],
                "code": "~~~\\nimpl Solution {\\n    pub fn seconds_to_remove_occurrences(s: String) -> i32 {\\n        let mut s = s.chars().collect::<Vec<char>>();\\n        let mut finished = false;\\n        let mut ret = 0;\\n        \\n        while finished == false {\\n            finished = true;\\n            let mut i = 0;\\n            \\n            while i < s.len() - 1 {\\n                if s[i] == \\'0\\' && s[i + 1] == \\'1\\' {\\n                    s.swap(i, i + 1);\\n                    i += 2;\\n                    finished = false;\\n                } else { \\n                    i += 1; \\n                }\\n            }\\n            \\n            if finished == false { ret += 1; }\\n        }\\n        \\n        ret\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2454486,
                "title": "easy-and-concise-java-solution",
                "content": "```\\n    public int secondsToRemoveOccurrences(String s) {\\n        int sc = 0;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (s.contains(\"01\")) {\\n                s = s.replace(\"01\", \"10\");\\n                sc++;\\n            }\\n        }\\n        return sc;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\n    public int secondsToRemoveOccurrences(String s) {\\n        int sc = 0;\\n        for (int i = 0; i < s.length() - 1; i++) {\\n            if (s.contains(\"01\")) {\\n                s = s.replace(\"01\", \"10\");\\n                sc++;\\n            }\\n        }\\n        return sc;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454464,
                "title": "easy-solution",
                "content": "```\\nint secondsToRemoveOccurrences(string s) {\\n        \\n       int count = 0, check = 1;\\n        \\n       while(check) {\\n           \\n           \\n            check = 0;\\n           \\n            for (int i = 0; i < s.size() - 1; i++) {\\n            \\n                if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                \\n                    swap(s[i], s[i + 1]);\\n                \\n                    i++;\\n                \\n                    check = 1;\\n                }\\n            }\\n           \\n            count += check;\\n    \\n        }\\n        \\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(string s) {\\n        \\n       int count = 0, check = 1;\\n        \\n       while(check) {\\n           \\n           \\n            check = 0;\\n           \\n            for (int i = 0; i < s.size() - 1; i++) {\\n            \\n                if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                \\n                    swap(s[i], s[i + 1]);\\n                \\n                    i++;\\n                \\n                    check = 1;\\n                }\\n            }\\n           \\n            count += check;\\n    \\n        }\\n        \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454438,
                "title": "java-easy-solution",
                "content": "```\\n  public int secondsToRemoveOccurrences(String s) {\\n        char[] c=s.toCharArray();\\n        int res=0;\\n        while(s.contains(\"01\")){\\n            for(int i=0;i<c.length-1;i++)\\n                if(c[i]==\\'0\\'&&c[i+1]==\\'1\\'){\\n                    char temp=c[i];\\n                    c[i]=c[i+1];\\n                    c[i+1]=temp;\\n                    i++;\\n                }\\n            s=String.valueOf(c);\\n            c=s.toCharArray();\\n            res++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n  public int secondsToRemoveOccurrences(String s) {\\n        char[] c=s.toCharArray();\\n        int res=0;\\n        while(s.contains(\"01\")){\\n            for(int i=0;i<c.length-1;i++)\\n                if(c[i]==\\'0\\'&&c[i+1]==\\'1\\'){\\n                    char temp=c[i];\\n                    c[i]=c[i+1];\\n                    c[i+1]=temp;\\n                    i++;\\n                }\\n            s=String.valueOf(c);\\n            c=s.toCharArray();\\n            res++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454393,
                "title": "c",
                "content": "```\\n   public int SecondsToRemoveOccurrences(string s)\\n        {\\n            var count = 0;\\n            while (s.Contains(\"01\"))\\n            {\\n                var answer = new char[s.Length];\\n                for (int j = 0; j < s.Length; j++)\\n                {\\n                    answer[j] = s[j];\\n                }\\n                int i = 0;\\n                while (i < answer.Length - 1)\\n                {\\n                    if (s[i].ToString() + s[i + 1].ToString() == \"01\")\\n                    {\\n                        answer[i] = \\'1\\';\\n                        answer[i + 1] = \\'0\\';\\n                        i += 2;\\n                    }\\n                    else\\n                    {\\n                        i++;\\n                    }\\n                }\\n                count++;\\n                s = new string(answer);\\n            }\\n            return count;\\n        }",
                "solutionTags": [],
                "code": "```\\n   public int SecondsToRemoveOccurrences(string s)\\n        {\\n            var count = 0;\\n            while (s.Contains(\"01\"))\\n            {\\n                var answer = new char[s.Length];\\n                for (int j = 0; j < s.Length; j++)\\n                {\\n                    answer[j] = s[j];\\n                }\\n                int i = 0;\\n                while (i < answer.Length - 1)\\n                {\\n                    if (s[i].ToString() + s[i + 1].ToString() == \"01\")\\n                    {\\n                        answer[i] = \\'1\\';\\n                        answer[i + 1] = \\'0\\';\\n                        i += 2;\\n                    }\\n                    else\\n                    {\\n                        i++;\\n                    }\\n                }\\n                count++;\\n                s = new string(answer);\\n            }\\n            return count;\\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2454316,
                "title": "c-easy-and-concise",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        bool zeroOne = false;\\n        int cnt = 0;\\n        while(true)\\n        {\\n            zeroOne = false;\\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' &&  s[i+1] == \\'1\\'){\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i++;\\n                    zeroOne = true;\\n                }\\n            }\\n            \\n            if(zeroOne == false)\\n                break;\\n            \\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        bool zeroOne = false;\\n        int cnt = 0;\\n        while(true)\\n        {\\n            zeroOne = false;\\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' &&  s[i+1] == \\'1\\'){\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i++;\\n                    zeroOne = true;\\n                }\\n            }\\n            \\n            if(zeroOne == false)\\n                break;\\n            \\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454295,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int sec = 0;\\n        int n = s.length();\\n        boolean changes = true;\\n        while(changes)\\n        {\\n            boolean flag = false;\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(s.charAt(i)==\\'0\\' && s.charAt(i+1)==\\'1\\')\\n                {\\n                    sec++;\\n                    flag = true;\\n                    s = s.replace(\"01\",\"10\");\\n                    break;\\n                }\\n            }\\n            if(!flag)\\n                changes = false;\\n        }\\n        return sec;\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int sec = 0;\\n        int n = s.length();\\n        boolean changes = true;\\n        while(changes)\\n        {\\n            boolean flag = false;\\n            for(int i=0;i<n-1;i++)\\n            {\\n                if(s.charAt(i)==\\'0\\' && s.charAt(i+1)==\\'1\\')\\n                {\\n                    sec++;\\n                    flag = true;\\n                    s = s.replace(\"01\",\"10\");\\n                    break;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2454293,
                "title": "cpp-easy",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        queue<int> q;\\n        int count =0 ;\\n        \\n        for(int i=0; i<s.size()-1; i++){\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\')\\n                // mpp[s[i]] =true ;\\n                q.push(i) ;\\n        }\\n        \\n        while(!q.empty()){\\n            count++ ;\\n            int size = q.size() ;\\n            \\n            for(int i=0; i<size; i++){\\n                int ind = q.front() ;\\n                q.pop() ;\\n               \\n                s[ind] = \\'1\\' ;\\n                s[ind+1] = \\'0\\' ;\\n            }\\n            \\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\')\\n                    q.push(i) ;\\n            }\\n        }\\n        \\n        return count ;\\n    }\\n};\\n```\\n\\n\\nSimilar to Rotting oranges \\n\\n**Please Upvote!!**",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        queue<int> q;\\n        int count =0 ;\\n        \\n        for(int i=0; i<s.size()-1; i++){\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\')\\n                // mpp[s[i]] =true ;\\n                q.push(i) ;\\n        }\\n        \\n        while(!q.empty()){\\n            count++ ;\\n            int size = q.size() ;\\n            \\n            for(int i=0; i<size; i++){\\n                int ind = q.front() ;\\n                q.pop() ;\\n               \\n                s[ind] = \\'1\\' ;\\n                s[ind+1] = \\'0\\' ;\\n            }\\n            \\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\')\\n                    q.push(i) ;\\n            }\\n        }\\n        \\n        return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454190,
                "title": "intutive-solution-using-stack-easy-to-understand",
                "content": "```\\nfunction isValid(s){\\n    for(let i=1;i<s.length;i++){\\n        if(s[i]==\"1\" && s[i-1]==\"0\") return false;\\n    }\\n    return true;\\n}\\n\\nvar secondsToRemoveOccurrences = function(s) {\\n    let stack=[];\\n   \\n    let operations=0;\\n    \\n    while(!isValid(s)){\\n         stack.push(s[0]);\\n        for(let i=1;i<s.length;i++){\\n            if(stack.length && s[i]==\"1\" && s[i-1]==\"0\"){\\n                stack.pop();\\n                stack.push(\"1\");\\n                stack.push(\"0\");\\n            }else{\\n                stack.push(s[i]);\\n            }\\n        }\\n        \\n        let newTemp=\"\";\\n        \\n        for(let i=0;i<stack.length;i++) newTemp+=stack[i];\\n        s=newTemp;\\n        operations++;\\n        stack=[];\\n    }\\n    return operations;\\n};\\n```",
                "solutionTags": [
                    "Stack"
                ],
                "code": "```\\nfunction isValid(s){\\n    for(let i=1;i<s.length;i++){\\n        if(s[i]==\"1\" && s[i-1]==\"0\") return false;\\n    }\\n    return true;\\n}\\n\\nvar secondsToRemoveOccurrences = function(s) {\\n    let stack=[];\\n   \\n    let operations=0;\\n    \\n    while(!isValid(s)){\\n         stack.push(s[0]);\\n        for(let i=1;i<s.length;i++){\\n            if(stack.length && s[i]==\"1\" && s[i-1]==\"0\"){\\n                stack.pop();\\n                stack.push(\"1\");\\n                stack.push(\"0\");\\n            }else{\\n                stack.push(s[i]);\\n            }\\n        }\\n        \\n        let newTemp=\"\";\\n        \\n        for(let i=0;i<stack.length;i++) newTemp+=stack[i];\\n        s=newTemp;\\n        operations++;\\n        stack=[];\\n    }\\n    return operations;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454180,
                "title": "easy-short-efficient-clean-code",
                "content": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        ll sz = s.length(), res = 0;\\n        while (true) {\\n            bool fl = true;\\n            for (ll i = 1;i < sz;++i) {\\n                if (s[i] == \\'1\\' && s[i - 1] == \\'0\\') {\\n                    s[i] = \\'0\\';\\n                    s[i - 1] = \\'1\\';\\n                    ++i;\\n                    fl = false;\\n                }\\n            }\\n            if (fl) {\\n                break;\\n            }\\n            else {\\n                ++res;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    typedef long long ll;\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        ll sz = s.length(), res = 0;\\n        while (true) {\\n            bool fl = true;\\n            for (ll i = 1;i < sz;++i) {\\n                if (s[i] == \\'1\\' && s[i - 1] == \\'0\\') {\\n                    s[i] = \\'0\\';\\n                    s[i - 1] = \\'1\\';\\n                    ++i;\\n                    fl = false;\\n                }\\n            }\\n            if (fl) {\\n                break;\\n            }\\n            else {\\n                ++res;\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4056868,
                "title": "the-real-bruteforce-solution-self-explanatory-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int one = 0, zero = 0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \\'0\\') zero++;\\n            else one++;\\n        }\\n        \\n        string str = \"\";   \\n        for(int i=0; i<one; i++){\\n            str+=\\'1\\';\\n        }\\n        \\n        for(int i=0; i<zero; i++){\\n            str+=\\'0\\';\\n        }\\n        \\n        int count = 0;\\n        while(s!=str){\\n            count++;\\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    swap(s[i], s[i+1]);\\n                    i++;\\n                }\\n            }\\n            \\n            // cout<<s<<endl;\\n        }\\n        \\n        // cout<<s<<endl;\\n        return count;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int one = 0, zero = 0;\\n        for(int i=0; i<s.size(); i++){\\n            if(s[i] == \\'0\\') zero++;\\n            else one++;\\n        }\\n        \\n        string str = \"\";   \\n        for(int i=0; i<one; i++){\\n            str+=\\'1\\';\\n        }\\n        \\n        for(int i=0; i<zero; i++){\\n            str+=\\'0\\';\\n        }\\n        \\n        int count = 0;\\n        while(s!=str){\\n            count++;\\n            for(int i=0; i<s.size()-1; i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    swap(s[i], s[i+1]);\\n                    i++;\\n                }\\n            }\\n            \\n            // cout<<s<<endl;\\n        }\\n        \\n        // cout<<s<<endl;\\n        return count;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4032305,
                "title": "go-dp-80-faster-100-less-space",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$ \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfunc maxInt(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc secondsToRemoveOccurrences(s string) int {\\n\\n\\tout := 0\\n\\tzeros := 0\\n\\n\\tfor _, v := range s {\\n\\t\\tif string(v) == \"0\" {\\n\\t\\t\\tzeros++\\n\\t\\t} else if zeros > 0 {\\n\\t\\t\\tout = maxInt(out+1, zeros)\\n\\t\\t}\\n\\t}\\n\\n\\treturn out\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "String",
                    "Dynamic Programming",
                    "Simulation"
                ],
                "code": "```\\nfunc maxInt(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n\\nfunc secondsToRemoveOccurrences(s string) int {\\n\\n\\tout := 0\\n\\tzeros := 0\\n\\n\\tfor _, v := range s {\\n\\t\\tif string(v) == \"0\" {\\n\\t\\t\\tzeros++\\n\\t\\t} else if zeros > 0 {\\n\\t\\t\\tout = maxInt(out+1, zeros)\\n\\t\\t}\\n\\t}\\n\\n\\treturn out\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4028005,
                "title": "time-needed-to-rearrange-a-binary-string",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int[] arr = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            arr[i] = Integer.valueOf(s.substring(i,i+1));\\n        }\\n        int count=0;\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                count++;\\n            }\\n            else if(count>0)\\n            ans = Math.max(ans+1,count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int[] arr = new int[s.length()];\\n        for(int i=0;i<s.length();i++)\\n        {\\n            arr[i] = Integer.valueOf(s.substring(i,i+1));\\n        }\\n        int count=0;\\n        int ans=0;\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(arr[i]==0)\\n            {\\n                count++;\\n            }\\n            else if(count>0)\\n            ans = Math.max(ans+1,count);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3966171,
                "title": "c-simple-beginner-friendly-do-upvote-if-the-solution-helped-u",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int sec=0;\\n        for (int i =0;i<s.length();i++){\\n            bool flag = false;\\n            for (int j=0;j<s.length()-1;j++){\\n                if ( s[j] == \\'0\\'  && s[j+1] == \\'1\\')\\n                {\\n                    s[j] = \\'1\\';\\n                    s[j+1] = \\'0\\';\\n                    flag = true;\\n                    j++;\\n                }\\n            }\\n            if ( flag ) sec++;\\n        }\\n        return sec;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int sec=0;\\n        for (int i =0;i<s.length();i++){\\n            bool flag = false;\\n            for (int j=0;j<s.length()-1;j++){\\n                if ( s[j] == \\'0\\'  && s[j+1] == \\'1\\')\\n                {\\n                    s[j] = \\'1\\';\\n                    s[j+1] = \\'0\\';\\n                    flag = true;\\n                    j++;\\n                }\\n            }\\n            if ( flag ) sec++;\\n        }\\n        return sec;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923545,
                "title": "java-optimized-solution-bubble-sort",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char arr[]=s.toCharArray();\\n        int n=arr.length;\\n        int count=0;\\n        for(count=0;count<n-1;count++){\\n            boolean swap=false;\\n            for(int j=0;j<n-1;j++){\\n                if(arr[j]==\\'0\\' && arr[j+1]==\\'1\\'){\\n                    arr[j]=\\'1\\';\\n                    arr[j+1]=\\'0\\';\\n                    swap=true;\\n                    j++;\\n                }\\n                \\n            }\\n           \\n            if(swap==false)break;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char arr[]=s.toCharArray();\\n        int n=arr.length;\\n        int count=0;\\n        for(count=0;count<n-1;count++){\\n            boolean swap=false;\\n            for(int j=0;j<n-1;j++){\\n                if(arr[j]==\\'0\\' && arr[j+1]==\\'1\\'){\\n                    arr[j]=\\'1\\';\\n                    arr[j+1]=\\'0\\';\\n                    swap=true;\\n                    j++;\\n                }\\n                \\n            }\\n           \\n            if(swap==false)break;\\n        }\\n        return count;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3909426,
                "title": "easy-bruteforce",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt =0;\\n        int n = s.length();\\n        bool flag=true;\\n        while(flag){\\n            flag =false;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    flag = true;\\n                    swap(s[i],s[i+1]);\\n                    i+=1;\\n                }\\n            }\\n            if(flag){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int cnt =0;\\n        int n = s.length();\\n        bool flag=true;\\n        while(flag){\\n            flag =false;\\n            for(int i=0;i<n-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    flag = true;\\n                    swap(s[i],s[i+1]);\\n                    i+=1;\\n                }\\n            }\\n            if(flag){\\n                cnt++;\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3906406,
                "title": "java-solution",
                "content": "# Complexity\\n- Time complexity:$$O(n^2)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        Map<Character,Integer> hm=new HashMap<>();\\n        for(char c:s.toCharArray()) hm.put(c,hm.getOrDefault(c,0)+1);\\n        StringBuilder res=new StringBuilder();\\n        int op=0;\\n        for(int i=0;hm.containsKey(\\'1\\') && i<hm.get(\\'1\\');i++) res.append(\\'1\\');\\n        for(int i=0;hm.containsKey(\\'0\\') && i<hm.get(\\'0\\');i++) res.append(\\'0\\');\\n        return helper(s.toCharArray(),res.toString(),0);\\n    }\\n    int helper(char[] arr,String s,int op){\\n        if(s.equals(new String(arr))){\\n            return op;\\n        }\\n        op++;\\n        for(int i=0;i+1<arr.length;i++){\\n            if(arr[i]==\\'0\\' && arr[i+1]==\\'1\\'){\\n                arr=swap(i,i+1,arr);\\n                i++;\\n            }\\n        }\\n        return helper(arr,s,op);\\n    }\\n    char[] swap(int i,int j,char[] arr){\\n        char t=arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=t;\\n        return arr;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        Map<Character,Integer> hm=new HashMap<>();\\n        for(char c:s.toCharArray()) hm.put(c,hm.getOrDefault(c,0)+1);\\n        StringBuilder res=new StringBuilder();\\n        int op=0;\\n        for(int i=0;hm.containsKey(\\'1\\') && i<hm.get(\\'1\\');i++) res.append(\\'1\\');\\n        for(int i=0;hm.containsKey(\\'0\\') && i<hm.get(\\'0\\');i++) res.append(\\'0\\');\\n        return helper(s.toCharArray(),res.toString(),0);\\n    }\\n    int helper(char[] arr,String s,int op){\\n        if(s.equals(new String(arr))){\\n            return op;\\n        }\\n        op++;\\n        for(int i=0;i+1<arr.length;i++){\\n            if(arr[i]==\\'0\\' && arr[i+1]==\\'1\\'){\\n                arr=swap(i,i+1,arr);\\n                i++;\\n            }\\n        }\\n        return helper(arr,s,op);\\n    }\\n    char[] swap(int i,int j,char[] arr){\\n        char t=arr[i];\\n        arr[i]=arr[j];\\n        arr[j]=t;\\n        return arr;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3853046,
                "title": "worst-solution-ever-but-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        int n = s.size();\\n        int i=0;\\n        while(i<n-1){\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\'){\\n                return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n    void solve(string s , int& ans){\\n        if(check(s)){\\n            return;\\n        }\\n\\n        ans++;\\n        \\n        for(int i=0 ; i<s.size()-1 ; i++){\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\'){\\n                swap(s[i],s[i+1]);\\n                i++;\\n            }\\n        }\\n        solve(s,ans);\\n\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        solve(s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool check(string s){\\n        int n = s.size();\\n        int i=0;\\n        while(i<n-1){\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\'){\\n                return false;\\n            }\\n            i++;\\n        }\\n        return true;\\n    }\\n    void solve(string s , int& ans){\\n        if(check(s)){\\n            return;\\n        }\\n\\n        ans++;\\n        \\n        for(int i=0 ; i<s.size()-1 ; i++){\\n            if(s[i]==\\'0\\' and s[i+1]==\\'1\\'){\\n                swap(s[i],s[i+1]);\\n                i++;\\n            }\\n        }\\n        solve(s,ans);\\n\\n    }\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        solve(s,ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3845360,
                "title": "1-nested-loop-to-speed-up-and-in-place-replacing-to-reduce-memory-usage",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        if (s == null) return 0;\\n        int t = s.length();\\n        if (t < 2) return 0;\\n        char[] ch_array = s.toCharArray();\\n\\n        int count = 0;\\n        // for (int i = 0 ; i < t ; i++) {\\n        //     if (s.contains(\"01\")) {\\n        //         s = s.replace(\"01\", \"10\");\\n        //         count++;\\n        //     }\\n        //     else break;\\n        // }\\n        boolean found = false;\\n        for (int i = 0 ; i < t ; i++) {\\n            for (int j = 0 ; j < t - 1 ; j++) {\\n                if (ch_array[j] == \\'0\\' && ch_array[j+1] == \\'1\\') {\\n                    ch_array[j] = \\'1\\';\\n                    ch_array[j+1] = \\'0\\';\\n                    j += 1;\\n                    found = true;\\n                }\\n            }\\n            if (found) {\\n                count += 1;\\n                found = false;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        if (s == null) return 0;\\n        int t = s.length();\\n        if (t < 2) return 0;\\n        char[] ch_array = s.toCharArray();\\n\\n        int count = 0;\\n        // for (int i = 0 ; i < t ; i++) {\\n        //     if (s.contains(\"01\")) {\\n        //         s = s.replace(\"01\", \"10\");\\n        //         count++;\\n        //     }\\n        //     else break;\\n        // }\\n        boolean found = false;\\n        for (int i = 0 ; i < t ; i++) {\\n            for (int j = 0 ; j < t - 1 ; j++) {\\n                if (ch_array[j] == \\'0\\' && ch_array[j+1] == \\'1\\') {\\n                    ch_array[j] = \\'1\\';\\n                    ch_array[j+1] = \\'0\\';\\n                    j += 1;\\n                    found = true;\\n                }\\n            }\\n            if (found) {\\n                count += 1;\\n                found = false;\\n            }\\n            else {\\n                break;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3812224,
                "title": "brute-force-c-o-n-2-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nPerform the replacement process and count number of iterations.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nUse a sliding window to keep track of whether a \"01\" sequence exists and replace it if so, continue until no further \"01\" sequence exists.\\n# Complexity\\n- Time complexity: O(n^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(std::string & s) {\\n        int num_seconds = 0;\\n        bool seq_found = true;\\n        bool replacement_occured = false;\\n        \\n        while(seq_found){\\n                replacement_occured = false;\\n                // loop through and replace all occurences\\n                for(int i = 0; i < s.length() - 1; i++){\\n                    if(s.at(i) == \\'0\\' && s.at(i+1) == \\'1\\'){\\n                        s[i] = \\'1\\';\\n                        s[i+1] = \\'0\\';\\n                        replacement_occured = true;\\n                        i++; // advance ptr to prevent overlap\\n                    }\\n                }\\n                if(replacement_occured){\\n                    num_seconds++;\\n                }else{\\n                    seq_found = false;\\n                }            \\n        }\\n        \\n        \\n        return num_seconds;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(std::string & s) {\\n        int num_seconds = 0;\\n        bool seq_found = true;\\n        bool replacement_occured = false;\\n        \\n        while(seq_found){\\n                replacement_occured = false;\\n                // loop through and replace all occurences\\n                for(int i = 0; i < s.length() - 1; i++){\\n                    if(s.at(i) == \\'0\\' && s.at(i+1) == \\'1\\'){\\n                        s[i] = \\'1\\';\\n                        s[i+1] = \\'0\\';\\n                        replacement_occured = true;\\n                        i++; // advance ptr to prevent overlap\\n                    }\\n                }\\n                if(replacement_occured){\\n                    num_seconds++;\\n                }else{\\n                    seq_found = false;\\n                }            \\n        }\\n        \\n        \\n        return num_seconds;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3628857,
                "title": "time-needed-to-rearrange-a-binary-string",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        return time(s,0);\\n    }\\n    public static int time(String s,int count) {\\n        //base case\\n        if(!s.contains(\"01\"))\\n        {\\n            return count;\\n        }\\n        return time(s.replace(\"01\", \"10\"),count+1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        return time(s,0);\\n    }\\n    public static int time(String s,int count) {\\n        //base case\\n        if(!s.contains(\"01\"))\\n        {\\n            return count;\\n        }\\n        return time(s.replace(\"01\", \"10\"),count+1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3565584,
                "title": "ruby-w-reduce",
                "content": "\\n```ruby\\n# @param {String} s\\n# @return {Integer}\\ndef seconds_to_remove_occurrences(s)\\n  s.each_char.reduce([0, 0]) {|(num_zeros, num_rounds), char|\\n    if char == \"0\"\\n      num_zeros += 1\\n    elsif num_zeros > 0\\n      num_rounds = [num_rounds + 1, num_zeros].max\\n    end\\n    [num_zeros, num_rounds]\\n  }[1]\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```ruby\\n# @param {String} s\\n# @return {Integer}\\ndef seconds_to_remove_occurrences(s)\\n  s.each_char.reduce([0, 0]) {|(num_zeros, num_rounds), char|\\n    if char == \"0\"\\n      num_zeros += 1\\n    elsif num_zeros > 0\\n      num_rounds = [num_rounds + 1, num_zeros].max\\n    end\\n    [num_zeros, num_rounds]\\n  }[1]\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3540886,
                "title": "easy-in-java-brute-force-approach",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int c=0;\\n        while(s.contains(\"01\"))\\n        {\\n            String b=s.replace(\"01\",\"10\");\\n            s=b;\\n            c++;\\n            \\n        }\\n        return c;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int c=0;\\n        while(s.contains(\"01\"))\\n        {\\n            String b=s.replace(\"01\",\"10\");\\n            s=b;\\n            c++;\\n            \\n        }\\n        return c;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538129,
                "title": "java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        boolean flag = false;\\n\\n        StringBuilder sb = new StringBuilder(s);\\n\\n        for (int i = 0; i < sb.length() - 1;) {\\n            if (sb.charAt(i) == \\'0\\' && sb.charAt(i + 1) == \\'1\\') {\\n                flag = true;\\n                swap(sb, i, i + 1);\\n                i += 2;\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        if (!flag)\\n            return 0;\\n\\n        return 1 + secondsToRemoveOccurrences(sb.toString());\\n    }\\n\\n    private void swap(StringBuilder sb, int i, int j) {\\n        char temp = sb.charAt(i);\\n        sb.setCharAt(i, sb.charAt(j));\\n        sb.setCharAt(j, temp);\\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        boolean flag = false;\\n\\n        StringBuilder sb = new StringBuilder(s);\\n\\n        for (int i = 0; i < sb.length() - 1;) {\\n            if (sb.charAt(i) == \\'0\\' && sb.charAt(i + 1) == \\'1\\') {\\n                flag = true;\\n                swap(sb, i, i + 1);\\n                i += 2;\\n            } else {\\n                i++;\\n            }\\n        }\\n\\n        if (!flag)\\n            return 0;\\n\\n        return 1 + secondsToRemoveOccurrences(sb.toString());\\n    }\\n\\n    private void swap(StringBuilder sb, int i, int j) {\\n        char temp = sb.charAt(i);\\n        sb.setCharAt(i, sb.charAt(j));\\n        sb.setCharAt(j, temp);\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490329,
                "title": "solve-the-problem-in-typescript-it-s-very-inefficient-from-the-looks-of-it",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nThe intuition behind this algorithm is to use a recursive function to iterate over the string and replace all occurrences of \"01\" with \"10\". The recursive function starts by checking if the current character is less than the next character. If it is, then the recursive function replaces the current character and the next character with \"10\". The recursive function then recursively calls itself with the new string. The algorithm continues to recursively call itself until the string no longer contains any occurrences of \"01\".\\n\\nThe intuition behind this algorithm is that it is more efficient to replace all occurrences of \"01\" in one step than to do it one at a time. By using a recursive function, we can avoid having to do the same work over and over again.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\nThe approach of this algorithm is to recursively iterate over the string and replace all occurrences of \"01\" with \"10\". The algorithm starts by calling the count() function with the original string. The count() function iterates over the string, and for each character, it checks if the next character is less than it. If the next character is less than it, then the count() function replaces the current character and the next character with \"10\". The count() function then recursively calls itself with the new string. The algorithm continues to recursively call itself until the string no longer contains any occurrences of \"01\". The number of steps taken by the algorithm is the number of times the count() function is called.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\nThe time complexity of the algorithm is $$O(n)$$ where n is the length of the string, because it takes linear time to iterate over the string and replace all occurrences of \"01\" with \"10\".\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThe space complexity of this algorithm is $$O(1)$$  because it only uses constant space to store the current string and the number of steps taken\\n\\n# Code\\n```\\nfunction secondsToRemoveOccurrences(s: string): number {\\n  let cnt = -1;\\n\\n  function count(s: string): number {\\n    cnt++;\\n    let str = s;\\n    let isValid = true;\\n    for (let i = 0; i < s.length; i++) {\\n      if (i < s.length - 1 && s[i] < s[i + 1]) {\\n        isValid = false;\\n        str = str.slice(0, i) + \"10\" + str.slice(i + 2);\\n      }\\n    }\\n    return isValid ? cnt : count(str);\\n  }\\n\\n  return count(s);\\n};\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction secondsToRemoveOccurrences(s: string): number {\\n  let cnt = -1;\\n\\n  function count(s: string): number {\\n    cnt++;\\n    let str = s;\\n    let isValid = true;\\n    for (let i = 0; i < s.length; i++) {\\n      if (i < s.length - 1 && s[i] < s[i + 1]) {\\n        isValid = false;\\n        str = str.slice(0, i) + \"10\" + str.slice(i + 2);\\n      }\\n    }\\n    return isValid ? cnt : count(str);\\n  }\\n\\n  return count(s);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3489805,
                "title": "recursion-for-fun",
                "content": "\\n```\\nfunc secondsToRemoveOccurrences(s string) int {\\n\\tif !strings.Contains(s, \"01\") {\\n\\t\\treturn 0\\t\\n\\t}\\n\\ts = strings.ReplaceAll(s, \"01\", \"10\")\\n\\treturn 1 + secondsToRemoveOccurrences(s)\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc secondsToRemoveOccurrences(s string) int {\\n\\tif !strings.Contains(s, \"01\") {\\n\\t\\treturn 0\\t\\n\\t}\\n\\ts = strings.ReplaceAll(s, \"01\", \"10\")\\n\\treturn 1 + secondsToRemoveOccurrences(s)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3486712,
                "title": "just-replace-01-with-10-until-end",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse while loop and str.replace 01 with 10 until no any 01 in str any more\\nand count how many loop executed \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nevery time search and replace will take n**2 time\\nand there are count time in loop so total time:**O(n**2*count)**\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n)** as long as s\\n\\n# Code\\n```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n=0\\n        while True:\\n            ss=s.replace(\\'01\\',\\'10\\')\\n            if ss==s:break\\n            n,s=n+1,ss\\n        return n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n=0\\n        while True:\\n            ss=s.replace(\\'01\\',\\'10\\')\\n            if ss==s:break\\n            n,s=n+1,ss\\n        return n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3486711,
                "title": "just-replace-01-with-10-until-end",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nuse while loop and str.replace 01 with 10 until no any 01 in str any more\\nand count how many loop executed \\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nevery time search and replace will take n**2 time\\nand there are count time in loop so total time:**O(n**2*count)**\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n**O(n)** as long as s\\n\\n# Code\\n```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n=0\\n        while True:\\n            ss=s.replace(\\'01\\',\\'10\\')\\n            if ss==s:break\\n            n,s=n+1,ss\\n        return n\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        n=0\\n        while True:\\n            ss=s.replace(\\'01\\',\\'10\\')\\n            if ss==s:break\\n            n,s=n+1,ss\\n        return n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482087,
                "title": "o-n-time-o-1-space-c-concise-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int i = 0;\\n        while(i < n && s[i] == \\'1\\') i++;\\n        \\n        int cnt = 0, prev = 0;\\n        for(; i < n; i++){\\n            if(s[i] == \\'0\\') cnt++;\\n            else prev = max(prev+1, cnt);\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size();\\n        int i = 0;\\n        while(i < n && s[i] == \\'1\\') i++;\\n        \\n        int cnt = 0, prev = 0;\\n        for(; i < n; i++){\\n            if(s[i] == \\'0\\') cnt++;\\n            else prev = max(prev+1, cnt);\\n        }\\n        return prev;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3457443,
                "title": "easy-brute-force-and-sliding-window",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nDone it Using brute force and simple sliding window with Every pass\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        start = 0\\n        n=[i for i in s]\\n        count = 0\\n        C = Counter(s)\\n        ones = C[\"1\"]\\n        dummy = [\"1\" for i in range(ones)]\\n        while n[:ones] != dummy:\\n            start = 0\\n            while start<len(n)-1:\\n                if n[start] == \"0\" and n[start+1] == \"1\":\\n                        n[start], n[start+1] = \"1\",\"0\"\\n                        start += 2\\n                else:\\n                    start+=1\\n            count+=1\\n            # print(n)\\n        return count\\n\\n                \\n\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution(object):\\n    def secondsToRemoveOccurrences(self, s):\\n        \"\"\"\\n        :type s: str\\n        :rtype: int\\n        \"\"\"\\n        start = 0\\n        n=[i for i in s]\\n        count = 0\\n        C = Counter(s)\\n        ones = C[\"1\"]\\n        dummy = [\"1\" for i in range(ones)]\\n        while n[:ones] != dummy:\\n            start = 0\\n            while start<len(n)-1:\\n                if n[start] == \"0\" and n[start+1] == \"1\":\\n                        n[start], n[start+1] = \"1\",\"0\"\\n                        start += 2\\n                else:\\n                    start+=1\\n            count+=1\\n            # print(n)\\n        return count\\n\\n                \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3414865,
                "title": "java-solution-brute-force-approach-dp-solution",
                "content": "### Complexity\\n- Time complexity: $$O(n^2)$$\\n<!-- Add your time complexity here, e.g.  -->\\n\\n- Space complexity: $$O(n^2)$$ $$replace() method takes O(n) for each replace $$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n### Brute-Force Code\\n```\\nclass Solution {\\n    private int i;\\n    private int j;\\n    private boolean checkString(String s){\\n        while(i < s.length() && s.charAt(i) == \\'1\\') i++;\\n        while(j >= 0 && s.charAt(j) == \\'0\\') j--;\\n\\n        return !(i-1 == j);\\n    }\\n    public int secondsToRemoveOccurrences(String s) {\\n        i = 0; j = s.length()-1;\\n        int count = 0;\\n        if(s.length() == 1) return 0;\\n        while(checkString(s)){\\n            count++;\\n            s = s.replace(\"01\",\"10\");\\n        }\\n        return count;\\n    }\\n}\\n```\\n\\n### DP Code\\n\\n## \\uD83E\\uDEE1 Inspired by @[votrubac](https://leetcode.com/votrubac/)\\n## [code Link](https://leetcode.com/problems/time-needed-to-rearrange-a-binary-string/solutions/2454262/dp-vs-brute-force/?orderBy=most_votes)\\n\\n##### complexity :\\n- Time Compexity : $$O(n)$$\\n- Space Compexity : $$O(1)$$\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int second = 0;\\n        int n = s.length();\\n\\n        int zero = 0;\\n        for(int i=0; i<n; i++){\\n            zero += s.charAt(i) == \\'0\\' ? 1 : 0;\\n            if(s.charAt(i) == \\'1\\' && zero > 0){\\n                second = Math.max(second+1,zero);\\n            }\\n        }\\n        return second;\\n    }\\n}\\n```\\n\\n# Happy Coding \\uD83D\\uDC96",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private int i;\\n    private int j;\\n    private boolean checkString(String s){\\n        while(i < s.length() && s.charAt(i) == \\'1\\') i++;\\n        while(j >= 0 && s.charAt(j) == \\'0\\') j--;\\n\\n        return !(i-1 == j);\\n    }\\n    public int secondsToRemoveOccurrences(String s) {\\n        i = 0; j = s.length()-1;\\n        int count = 0;\\n        if(s.length() == 1) return 0;\\n        while(checkString(s)){\\n            count++;\\n            s = s.replace(\"01\",\"10\");\\n        }\\n        return count;\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int second = 0;\\n        int n = s.length();\\n\\n        int zero = 0;\\n        for(int i=0; i<n; i++){\\n            zero += s.charAt(i) == \\'0\\' ? 1 : 0;\\n            if(s.charAt(i) == \\'1\\' && zero > 0){\\n                second = Math.max(second+1,zero);\\n            }\\n        }\\n        return second;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3413225,
                "title": "easy-python3-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c = 0\\n        while(\"01\" in s):\\n            s = s.replace(\"01\", \"10\")\\n            c += 1\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        c = 0\\n        while(\"01\" in s):\\n            s = s.replace(\"01\", \"10\")\\n            c += 1\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3375961,
                "title": "c-easy-simple-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count1 = count(s.begin(),s.end(),\\'1\\');\\n        int count0 = count(s.begin(),s.end(),\\'0\\');\\n        string st = \"\";\\n        while(count1--) st += \\'1\\';\\n        while(count0--) st += \\'0\\';\\n        int count = 0;\\n        while(st != s){\\n            count++;\\n            for(int i = 0;i<s.length();i++){\\n                if(s.substr(i,2) == \"01\"){ \\n                    s.replace(i,2,\"10\");\\n                    i++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count1 = count(s.begin(),s.end(),\\'1\\');\\n        int count0 = count(s.begin(),s.end(),\\'0\\');\\n        string st = \"\";\\n        while(count1--) st += \\'1\\';\\n        while(count0--) st += \\'0\\';\\n        int count = 0;\\n        while(st != s){\\n            count++;\\n            for(int i = 0;i<s.length();i++){\\n                if(s.substr(i,2) == \"01\"){ \\n                    s.replace(i,2,\"10\");\\n                    i++;\\n                }\\n            }\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3374059,
                "title": "python-o-n-bit-manipulation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nJust like the brute force approach but using bit manipulation instead of transforming the string.\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        x = int(\\'0b\\' + s, 2)\\n        nums = [int(l) for l in s]\\n        n = len(nums)\\n        mask = (1 << n) - 1\\n\\n        # def transform(x):\\n        #     i = 0\\n        #     while i < n - 1:\\n        #         j = i + 1\\n        #         a = x[i]\\n        #         b = x[j]\\n        #         if a == 0 and b == 1:\\n        #             x[i] = 1\\n        #             x[j] = 0\\n        #             i += 1\\n        #         i += 1\\n        #     return x\\n\\n        def fast_transform(x):\\n            zero = ~x & mask\\n            next_one = (x << 1) & mask\\n            starting_ixs = zero & next_one & mask\\n            inv = ~(starting_ixs >> 1) & mask\\n            foo = (x | starting_ixs) & mask\\n            res = (foo & inv) & mask\\n            return res\\n\\n        ones = 0\\n        for l in s:\\n            if l == \\'1\\':\\n                ones += 1\\n        zeros = n - ones\\n        final = [1] * ones + [0] * zeros\\n        s_fin = \\'\\'.join([str(x) for x in final])\\n        y = int(\\'0b\\' + s_fin, 2)\\n\\n        res = 0\\n        while x != y:\\n            x = fast_transform(x)\\n            res += 1\\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Bit Manipulation",
                    "Bitmask"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        x = int(\\'0b\\' + s, 2)\\n        nums = [int(l) for l in s]\\n        n = len(nums)\\n        mask = (1 << n) - 1\\n\\n        # def transform(x):\\n        #     i = 0\\n        #     while i < n - 1:\\n        #         j = i + 1\\n        #         a = x[i]\\n        #         b = x[j]\\n        #         if a == 0 and b == 1:\\n        #             x[i] = 1\\n        #             x[j] = 0\\n        #             i += 1\\n        #         i += 1\\n        #     return x\\n\\n        def fast_transform(x):\\n            zero = ~x & mask\\n            next_one = (x << 1) & mask\\n            starting_ixs = zero & next_one & mask\\n            inv = ~(starting_ixs >> 1) & mask\\n            foo = (x | starting_ixs) & mask\\n            res = (foo & inv) & mask\\n            return res\\n\\n        ones = 0\\n        for l in s:\\n            if l == \\'1\\':\\n                ones += 1\\n        zeros = n - ones\\n        final = [1] * ones + [0] * zeros\\n        s_fin = \\'\\'.join([str(x) for x in final])\\n        y = int(\\'0b\\' + s_fin, 2)\\n\\n        res = 0\\n        while x != y:\\n            x = fast_transform(x)\\n            res += 1\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3359385,
                "title": "java-solution-time-complexity-o-n-space-complexity-o-1",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n  - O(n)\\n\\n- Space complexity:\\n  - O(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int zero = 0, time = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n\\n            if (ch == \\'0\\') zero++;\\n            if (ch == \\'1\\' && zero > 0)\\n                time = Math.max(time + 1, zero);\\n        }\\n\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int zero = 0, time = 0;\\n\\n        for (int i = 0; i < s.length(); i++) {\\n            char ch = s.charAt(i);\\n\\n            if (ch == \\'0\\') zero++;\\n            if (ch == \\'1\\' && zero > 0)\\n                time = Math.max(time + 1, zero);\\n        }\\n\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3303295,
                "title": "here-comes-the-brute-force-c",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n\\n    \\n\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        int count=0;\\n\\n        while(s.find(\"01\")!=string::npos){\\n            count++;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n        } \\n        return count;\\n       \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    \\n\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        int count=0;\\n\\n        while(s.find(\"01\")!=string::npos){\\n            count++;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n        } \\n        return count;\\n       \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3283278,
                "title": "c-easy-approach",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.length();\\n            int count=0,ans=0;\\n            for(int i=0;i<n;i++){\\n                            if(s[i]==\\'0\\' and i+1<n and  s[i+1]==\\'1\\'){\\n                                    s[i]=\\'1\\';\\n                                    s[i+1]=\\'0\\';\\n                                    i++;\\n                                    count++;\\n                            }\\n                            \\n                    }\\n            while(count>0){\\n                    count=0;\\n                    for(int i=0;i<n;i++){\\n                            if(s[i]==\\'0\\' and i+1<n and  s[i+1]==\\'1\\'){\\n                                    s[i]=\\'1\\';\\n                                    s[i+1]=\\'0\\';\\n                                    i++;\\n                                    count++;\\n                            }\\n                            \\n                    }\\n                    ans++;\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n=s.length();\\n            int count=0,ans=0;\\n            for(int i=0;i<n;i++){\\n                            if(s[i]==\\'0\\' and i+1<n and  s[i+1]==\\'1\\'){\\n                                    s[i]=\\'1\\';\\n                                    s[i+1]=\\'0\\';\\n                                    i++;\\n                                    count++;\\n                            }\\n                            \\n                    }\\n            while(count>0){\\n                    count=0;\\n                    for(int i=0;i<n;i++){\\n                            if(s[i]==\\'0\\' and i+1<n and  s[i+1]==\\'1\\'){\\n                                    s[i]=\\'1\\';\\n                                    s[i+1]=\\'0\\';\\n                                    i++;\\n                                    count++;\\n                            }\\n                            \\n                    }\\n                    ans++;\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3219765,
                "title": "simulation-python3-solution-o-n-2-time",
                "content": "```\\nclass Solution:\\n    \\n    \\n    def remove(self, s: List[int]) -> int:\\n        \\n        to_remove = []\\n        i = 0\\n        \\n        while i < len(s)-1:\\n            if s[i] == 0 and s[i+1] == 1:\\n                to_remove.append(i)\\n                i += 2\\n            else:\\n                i += 1\\n                \\n        for i in to_remove:\\n            s[i] = 1\\n            s[i+1] = 0\\n            \\n        return len(to_remove)\\n    \\n    \\n    # O(n^2) time,\\n    # O(n) space,\\n    # Approach: simulation, \\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        s = [int(ch) for ch in s]\\n        time = 0\\n        \\n        while self.remove(s) > 0:\\n            time += 1\\n            \\n        return time\\n```",
                "solutionTags": [
                    "Python3",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    \\n    \\n    def remove(self, s: List[int]) -> int:\\n        \\n        to_remove = []\\n        i = 0\\n        \\n        while i < len(s)-1:\\n            if s[i] == 0 and s[i+1] == 1:\\n                to_remove.append(i)\\n                i += 2\\n            else:\\n                i += 1\\n                \\n        for i in to_remove:\\n            s[i] = 1\\n            s[i+1] = 0\\n            \\n        return len(to_remove)\\n    \\n    \\n    # O(n^2) time,\\n    # O(n) space,\\n    # Approach: simulation, \\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        s = [int(ch) for ch in s]\\n        time = 0\\n        \\n        while self.remove(s) > 0:\\n            time += 1\\n            \\n        return time\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3206965,
                "title": "acc-java-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int cnt=0;\\n        \\n        char[] arr = s.toCharArray();\\n        while(true){\\n            int i=0,j=1;\\n            boolean flag=false;\\n             while(j<arr.length)\\n             {\\n                 if(arr[i]==\\'0\\' && arr[j]==\\'1\\')\\n                    flag=true;\\n                i++;j++;\\n             }\\n            if(!flag)\\n                break;\\n            cnt++;\\n            i=0;j=1;\\n            while(j<arr.length)\\n            {\\n                if(arr[i]==\\'0\\' && arr[j]==\\'1\\')\\n                {\\n                    arr[i]=\\'1\\'; arr[j]=\\'0\\';\\n                    i++;\\n                    j++;\\n                }\\n                    i++;j++;\\n            }\\n                       \\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int cnt=0;\\n        \\n        char[] arr = s.toCharArray();\\n        while(true){\\n            int i=0,j=1;\\n            boolean flag=false;\\n             while(j<arr.length)\\n             {\\n                 if(arr[i]==\\'0\\' && arr[j]==\\'1\\')\\n                    flag=true;\\n                i++;j++;\\n             }\\n            if(!flag)\\n                break;\\n            cnt++;\\n            i=0;j=1;\\n            while(j<arr.length)\\n            {\\n                if(arr[i]==\\'0\\' && arr[j]==\\'1\\')\\n                {\\n                    arr[i]=\\'1\\'; arr[j]=\\'0\\';\\n                    i++;\\n                    j++;\\n                }\\n                    i++;j++;\\n            }\\n                       \\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3203109,
                "title": "java-brute-force-clear-explanations",
                "content": "# Approach\\n1. While there are replaces to be made, traverse the char[] chars of String from 0 to n and replace all 01 with 10. \\nAfter each loop, if changes have been made, increment the steps, break otherwise.\\n2. Return the number of steps.\\n\\n# Complexity\\n- Time complexity:$$O(n * n - worst-case)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] chrs = s.toCharArray();\\n        boolean swapped = true;\\n        int steps = 0;\\n        while(swapped) {\\n            swapped = false;\\n            for (int i = 0; i < s.length() - 1; i++) {       \\n                if (chrs[i] == \\'0\\' && chrs[i+1] == \\'1\\') {\\n                    chrs[i] = \\'1\\';\\n                    chrs[i+1] = \\'0\\';\\n                    i++;\\n                    swapped = true;\\n                }\\n            }\\n            if(swapped) {\\n                steps++;\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] chrs = s.toCharArray();\\n        boolean swapped = true;\\n        int steps = 0;\\n        while(swapped) {\\n            swapped = false;\\n            for (int i = 0; i < s.length() - 1; i++) {       \\n                if (chrs[i] == \\'0\\' && chrs[i+1] == \\'1\\') {\\n                    chrs[i] = \\'1\\';\\n                    chrs[i+1] = \\'0\\';\\n                    i++;\\n                    swapped = true;\\n                }\\n            }\\n            if(swapped) {\\n                steps++;\\n            }\\n        }\\n        return steps;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3196527,
                "title": "easy-solution-c",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size() , count = 0 , flag = 0 ;\\n        while(1)\\n        {\\n            flag = 0 ;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    s[i] = \\'1\\' ;\\n                    s[i+1] = \\'0\\' ;\\n                    flag = 1 ;\\n                    i++ ;\\n                }\\n            }\\n            if(flag==0){\\n                break ;\\n            }\\n            count++ ;\\n        }\\n        return count ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int n = s.size() , count = 0 , flag = 0 ;\\n        while(1)\\n        {\\n            flag = 0 ;\\n            for(int i=0;i<n;i++)\\n            {\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    s[i] = \\'1\\' ;\\n                    s[i+1] = \\'0\\' ;\\n                    flag = 1 ;\\n                    i++ ;\\n                }\\n            }\\n            if(flag==0){\\n                break ;\\n            }\\n            count++ ;\\n        }\\n        return count ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3194877,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n*n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] ch =s.toCharArray();\\n        int count=0;\\n        for(int i=0; i<s.length();i++){\\n            boolean check=true;\\n            int j=0;\\n            while(j<s.length()-1){\\n                if(ch[j]==\\'0\\' && ch[j+1]==\\'1\\'){\\n                    check=false;\\n                    swapped(ch,j,j+1);\\n                    j=j+2;\\n                }else{\\n                    j++;\\n                }\\n            }\\n            if(check==false)count++;\\n            if(check==true) return count;\\n        \\n        }\\n        return count;\\n    }\\n    private void swapped(char[] ch,int i, int j){\\n        char temp=ch[i];\\n        ch[i]=ch[j];\\n        ch[j]=temp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] ch =s.toCharArray();\\n        int count=0;\\n        for(int i=0; i<s.length();i++){\\n            boolean check=true;\\n            int j=0;\\n            while(j<s.length()-1){\\n                if(ch[j]==\\'0\\' && ch[j+1]==\\'1\\'){\\n                    check=false;\\n                    swapped(ch,j,j+1);\\n                    j=j+2;\\n                }else{\\n                    j++;\\n                }\\n            }\\n            if(check==false)count++;\\n            if(check==true) return count;\\n        \\n        }\\n        return count;\\n    }\\n    private void swapped(char[] ch,int i, int j){\\n        char temp=ch[i];\\n        ch[i]=ch[j];\\n        ch[j]=temp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3187791,
                "title": "worst-solution-for-java-aasheesh-63th-day",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n![UP vote ki bhik.jpeg](https://assets.leetcode.com/users/images/25b0befb-f6d4-46b1-baa8-c0a53ef3f36d_1676440598.5032725.jpeg)\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count = 0;\\n        while (s.contains(\"01\")){\\n            s = s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count = 0;\\n        while (s.contains(\"01\")){\\n            s = s.replace(\"01\",\"10\");\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3166454,
                "title": "easy-python-dp-n-time-complexity",
                "content": "Each \"1\" has a predetermined slot. What will the time be to get a 1 to its slot? \\n\\nBest case is if there is no other \"1\" blocking it in front, then it can move along without delay. Assume j is its predetermined slot, then simply i-j will be the time. \\n\\nWhat if there are \"1\"s in front of it? What if there are multiple delays of blocking \"1\"s. You only have to care about the prev \"1\". This is because it\\'s delay will also take into account the other previous \"1\"s blocking it. So how long to wait? Just +1 because once the prev 1 move, each turn the previous 1 and the current 1 can move simultaneously. \\n\\n\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        \\n        nearestOneTime=0\\n        j=0\\n        \\n        \\n        for i in range(len(s)):\\n            if s[i]==\"1\":\\n                if i!=j:\\n                    nearestOneTime=max(nearestOneTime+1,i-j)\\n                j+=1\\n        \\n        return nearestOneTime",
                "solutionTags": [],
                "code": "Each \"1\" has a predetermined slot. What will the time be to get a 1 to its slot? \\n\\nBest case is if there is no other \"1\" blocking it in front, then it can move along without delay. Assume j is its predetermined slot, then simply i-j will be the time. \\n\\nWhat if there are \"1\"s in front of it? What if there are multiple delays of blocking \"1\"s. You only have to care about the prev \"1\". This is because it\\'s delay will also take into account the other previous \"1\"s blocking it. So how long to wait? Just +1 because once the prev 1 move, each turn the previous 1 and the current 1 can move simultaneously. \\n\\n\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        \\n        nearestOneTime=0\\n        j=0\\n        \\n        \\n        for i in range(len(s)):\\n            if s[i]==\"1\":\\n                if i!=j:\\n                    nearestOneTime=max(nearestOneTime+1,i-j)\\n                j+=1\\n        \\n        return nearestOneTime",
                "codeTag": "Java"
            },
            {
                "id": 3159238,
                "title": "super-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int time=0;\\n        int f=1;\\n        int n=s.size();\\n        while(f)\\n        {\\n            int flag=0;\\n            for(int x=0; x<n-1; x++)\\n            {\\n                if(s[x]==\\'0\\' && s[x+1]==\\'1\\')\\n                {\\n                    s[x]=\\'1\\';\\n                    s[x+1]=\\'0\\';\\n                    x++;\\n                    flag=1;\\n                }\\n            }\\n            if(flag) time++;\\n            else f=0;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int time=0;\\n        int f=1;\\n        int n=s.size();\\n        while(f)\\n        {\\n            int flag=0;\\n            for(int x=0; x<n-1; x++)\\n            {\\n                if(s[x]==\\'0\\' && s[x+1]==\\'1\\')\\n                {\\n                    s[x]=\\'1\\';\\n                    s[x+1]=\\'0\\';\\n                    x++;\\n                    flag=1;\\n                }\\n            }\\n            if(flag) time++;\\n            else f=0;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3137643,
                "title": "c-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int res=0,c=1;\\n        while(c==1)\\n        {\\n            c=0;\\n            int i=0;\\n            string s1 = s;  //take a copy of string \\n            while(i<s.size()-1)\\n            {\\n                \\n                if(s[i]==\\'0\\' and s[i+1]==\\'1\\')\\n                {\\n                    swap(s1[i],s1[i+1]);\\n                    c=1;\\n                }\\n                i++;\\n            }\\n            s = s1;\\n            res += c;\\n            //cout<<s<<endl;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int res=0,c=1;\\n        while(c==1)\\n        {\\n            c=0;\\n            int i=0;\\n            string s1 = s;  //take a copy of string \\n            while(i<s.size()-1)\\n            {\\n                \\n                if(s[i]==\\'0\\' and s[i+1]==\\'1\\')\\n                {\\n                    swap(s1[i],s1[i+1]);\\n                    c=1;\\n                }\\n                i++;\\n            }\\n            s = s1;\\n            res += c;\\n            //cout<<s<<endl;\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3122250,
                "title": "easy-brute-force-solution-in-cpp",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n^2)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        if(s.size() == 1) \\n            return 0;\\n\\n        int ans = 0;\\n        int flag = 0;\\n\\n        while(true) {\\n            flag = 0;\\n            for(int i=0; i<s.size()-1; i++) {\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\') {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    flag = 1;\\n                    i++;\\n                } \\n            }\\n            if(flag == 0) break;\\n            else ans++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n\\n        if(s.size() == 1) \\n            return 0;\\n\\n        int ans = 0;\\n        int flag = 0;\\n\\n        while(true) {\\n            flag = 0;\\n            for(int i=0; i<s.size()-1; i++) {\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\') {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    flag = 1;\\n                    i++;\\n                } \\n            }\\n            if(flag == 0) break;\\n            else ans++;\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104832,
                "title": "c-easy-simple-solution",
                "content": "# Dont forget to give it upvote if you like the solution\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans=0 , n =s.size();\\n\\n        while( true){\\n            bool fl=true;\\n            for( int i =1 ; i< n ; i++){\\n                if( s[i-1]==\\'0\\' and s[i]==\\'1\\'){\\n                    swap(s[i-1], s[i]);\\n                    i++;\\n                    fl=false;   \\n                }\\n            }\\n             if( !fl)ans++;\\n             if( fl)break;\\n        }\\n        return ans; \\n    }\\n};\\n```\\n\\n![you-upvote-me.webp](https://assets.leetcode.com/users/images/55fd002e-b472-4a22-ac71-3205b8775a2e_1674813108.8949456.webp)\\n\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans=0 , n =s.size();\\n\\n        while( true){\\n            bool fl=true;\\n            for( int i =1 ; i< n ; i++){\\n                if( s[i-1]==\\'0\\' and s[i]==\\'1\\'){\\n                    swap(s[i-1], s[i]);\\n                    i++;\\n                    fl=false;   \\n                }\\n            }\\n             if( !fl)ans++;\\n             if( fl)break;\\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094520,
                "title": "simple-cpp-datta-bayo",
                "content": "Simple BrutForce Solution nothing tough go throgh one dry run you will get it buddy. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n         if(s.size()==1 or (s.size()==2 && s[0]==\\'1\\' && s[1]==\\'0\\'))\\n            return 0;\\n        if(s.size()==2 && s[0]==\\'0\\' && s[1]==\\'1\\')\\n            return 1;\\n        bool check=true;\\n        for(int i=s.length()-2;i>=0;i--)\\n        {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\'&&ch2==\\'1\\') {\\n                check = true;\\n                break;\\n            }\\n            else check=false;\\n\\n        }\\n        int occr_remv=0;\\n        while(check)\\n        {\\n             for(int i=s.length()-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i--;\\n                }\\n            }\\n             for(int i=s.length()-2;i>=0;i--)\\n           {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\'&&ch2==\\'1\\') {\\n                check = true;\\n                break;\\n            }\\n            else check=false;\\n\\n            }\\n            occr_remv++;\\n        }\\n        return occr_remv;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n         if(s.size()==1 or (s.size()==2 && s[0]==\\'1\\' && s[1]==\\'0\\'))\\n            return 0;\\n        if(s.size()==2 && s[0]==\\'0\\' && s[1]==\\'1\\')\\n            return 1;\\n        bool check=true;\\n        for(int i=s.length()-2;i>=0;i--)\\n        {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\'&&ch2==\\'1\\') {\\n                check = true;\\n                break;\\n            }\\n            else check=false;\\n\\n        }\\n        int occr_remv=0;\\n        while(check)\\n        {\\n             for(int i=s.length()-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i--;\\n                }\\n            }\\n             for(int i=s.length()-2;i>=0;i--)\\n           {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\'&&ch2==\\'1\\') {\\n                check = true;\\n                break;\\n            }\\n            else check=false;\\n\\n            }\\n            occr_remv++;\\n        }\\n        return occr_remv;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3086280,
                "title": "concise-java-solution-using-inbuilt-function",
                "content": "\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(true){\\n            int idx=s.indexOf(\"01\");\\n            if(idx==-1)break;\\n            else{\\n                s=s.replaceAll(\"01\",\"10\");\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String",
                    "String Matching"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count=0;\\n        while(true){\\n            int idx=s.indexOf(\"01\");\\n            if(idx==-1)break;\\n            else{\\n                s=s.replaceAll(\"01\",\"10\");\\n                count++;\\n            }\\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3057262,
                "title": "c-solution",
                "content": "```\\nint secondsToRemoveOccurrences(char * s){\\n    int i, len = strlen(s), flag = 1, times = 0;\\n\\n    if (len == 1)\\n        return 0;\\n\\n    while (flag) {\\n        flag = 0;\\n        for (i = 0; i < len - 1; i++) {\\n            if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                flag = 1;\\n                char temp = s[i];\\n                s[i] = s[i + 1];\\n                s[i + 1] = temp;\\n                i++;\\n            }\\n        }\\n\\n        times++;\\n    }\\n\\n    return times - 1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint secondsToRemoveOccurrences(char * s){\\n    int i, len = strlen(s), flag = 1, times = 0;\\n\\n    if (len == 1)\\n        return 0;\\n\\n    while (flag) {\\n        flag = 0;\\n        for (i = 0; i < len - 1; i++) {\\n            if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                flag = 1;\\n                char temp = s[i];\\n                s[i] = s[i + 1];\\n                s[i + 1] = temp;\\n                i++;\\n            }\\n        }\\n\\n        times++;\\n    }\\n\\n    return times - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3040964,
                "title": "hindi-version-c-easy-approach",
                "content": "The post is in hindi because there are very less post written in HINDI language.\\n\\n# Approach\\nSimply har baar string mein last se traverse karke check karenge ki kya \\'01\\' present hai agar present hai toh replacements karne honge warna number of seconds ko return kardenge. Code mein comments ke through explain kiya hai ek baar read karo and dry run karo saath mein ek case lekar.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N*N) because worst case 01111 hoga is par dry run karo toh tumhe pata chalega ki string ke through N times jaana padega 0 last position par le jaane ke liye\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        // Pehle if condition mein 2 cases ko dekh rahe hai : \\n        // Case-1 : agar string ki length 1 hai toh number of seconds 0 honge\\n        // Case-2 : agar string ki length 2 hai toh hume ye check karna hoga ki 0th index par 1 hoga and 1th postion par 0 hoga toh number of seconds 0 honge warna number of seconds 1 honge\\n        if(s.size()==1 or (s.size()==2 && s[0]==\\'1\\' && s[1]==\\'0\\'))\\n            return 0;\\n        if(s.size()==2 && s[0]==\\'0\\' && s[1]==\\'1\\')\\n            return 1;\\n        int n = s.size();\\n        bool flag = true;\\n        int count = 0;\\n        // last se traverse karke ye check karenge ki kya koyi index aesa hai jispar \\'0\\' hai and next index par \\'1\\' hai and agar aesa nahi hai toh number of seconds 0 honge because replace karna hi nahi hoga\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\' && ch2==\\'1\\')\\n            {\\n                flag = true;\\n                break;\\n            }\\n            else\\n            {\\n                flag = false;\\n            }\\n        }\\n        // agar string mein \\'01\\' hai toh replace karne ki try karenge and replace karnege jahan bhi \\'01\\' milega and swap kardenge\\n        while(flag)\\n        {\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i--;\\n                }\\n            }\\n            // string ko traverse karke ke swap karne ke baad phirse check karenge agar \\'01\\' hai phirse toh replace karne jaana padega warna loop se break hojaayenge\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                else\\n                {\\n                    flag = false;\\n                }\\n            }\\n            // pure string ke through traverse karne ke baad hi ek second count hoga because 1 baar string ke through traverse karke replacement karne mein 1 second keh rahe hai\\n            ++count;\\n        }\\n        return count;\\n    }\\n};\\n```\\n\\n\\nAgar approach samajh aayi ho and kuch help mili ho toh please upvote karna!!!",
                "solutionTags": [
                    "C++",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        // Pehle if condition mein 2 cases ko dekh rahe hai : \\n        // Case-1 : agar string ki length 1 hai toh number of seconds 0 honge\\n        // Case-2 : agar string ki length 2 hai toh hume ye check karna hoga ki 0th index par 1 hoga and 1th postion par 0 hoga toh number of seconds 0 honge warna number of seconds 1 honge\\n        if(s.size()==1 or (s.size()==2 && s[0]==\\'1\\' && s[1]==\\'0\\'))\\n            return 0;\\n        if(s.size()==2 && s[0]==\\'0\\' && s[1]==\\'1\\')\\n            return 1;\\n        int n = s.size();\\n        bool flag = true;\\n        int count = 0;\\n        // last se traverse karke ye check karenge ki kya koyi index aesa hai jispar \\'0\\' hai and next index par \\'1\\' hai and agar aesa nahi hai toh number of seconds 0 honge because replace karna hi nahi hoga\\n        for(int i=n-2;i>=0;i--)\\n        {\\n            char ch1 = s[i];\\n            char ch2 = s[i+1];\\n            if(ch1==\\'0\\' && ch2==\\'1\\')\\n            {\\n                flag = true;\\n                break;\\n            }\\n            else\\n            {\\n                flag = false;\\n            }\\n        }\\n        // agar string mein \\'01\\' hai toh replace karne ki try karenge and replace karnege jahan bhi \\'01\\' milega and swap kardenge\\n        while(flag)\\n        {\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    s[i] = \\'1\\';\\n                    s[i+1] = \\'0\\';\\n                    i--;\\n                }\\n            }\\n            // string ko traverse karke ke swap karne ke baad phirse check karenge agar \\'01\\' hai phirse toh replace karne jaana padega warna loop se break hojaayenge\\n            for(int i=n-2;i>=0;i--)\\n            {\\n                char ch1 = s[i];\\n                char ch2 = s[i+1];\\n                if(ch1==\\'0\\' && ch2==\\'1\\')\\n                {\\n                    flag = true;\\n                    break;\\n                }\\n                else\\n                {\\n                    flag = false;\\n                }\\n            }\\n            // pure string ke through traverse karne ke baad hi ek second count hoga because 1 baar string ke through traverse karke replacement karne mein 1 second keh rahe hai\\n            ++count;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3025011,
                "title": "string-replace-easy-java-solution",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        String temp=s.replace(\"01\",\"10\");\\n        if(temp.compareTo(s)==0) return 0;\\n        int cnt=0;\\n        while(temp.compareTo(s)!=0){\\n            s=temp;\\n            temp=s.replace(\"01\",\"10\");\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        String temp=s.replace(\"01\",\"10\");\\n        if(temp.compareTo(s)==0) return 0;\\n        int cnt=0;\\n        while(temp.compareTo(s)!=0){\\n            s=temp;\\n            temp=s.replace(\"01\",\"10\");\\n            cnt++;\\n        }\\n        return cnt;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3015272,
                "title": "easy-to-understand-python-o-n-time-o-1-space",
                "content": "```\\n    def secondsToRemoveOccurrences(self, s):\\n        \\n        p = \\'01\\'\\n        c = 0\\n        \\n        if p not in s: return 0\\n        else:\\n            while p in s:\\n                s = s.replace(p, \\'10\\')\\n                c += 1\\n        \\n            return c\\n```\\nRuntime: 52.17%\\nMemory: 45.65%",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def secondsToRemoveOccurrences(self, s):\\n        \\n        p = \\'01\\'\\n        c = 0\\n        \\n        if p not in s: return 0\\n        else:\\n            while p in s:\\n                s = s.replace(p, \\'10\\')\\n                c += 1\\n        \\n            return c\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2976460,
                "title": "simple-java",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n\\n        int count=0;\\n       while(s.indexOf(\"01\")>-1){\\n            s=s.replaceAll(\"01\",\"10\");\\n            count++; \\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n\\n        int count=0;\\n       while(s.indexOf(\"01\")>-1){\\n            s=s.replaceAll(\"01\",\"10\");\\n            count++; \\n        }\\n        \\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2925364,
                "title": "recursive-scala-solution",
                "content": "\\n```\\nobject Solution {\\n    def secondsToRemoveOccurrences(s: String): Int = {\\n        def loop(s: String, acc: Int): Int = s match {\\n            case s if s.sliding(2).count(_.contains(\"01\")) == 0 => acc\\n            case _                                              => loop(s.replace(\"01\", \"10\"), acc + 1)\\n        }\\n\\n        loop(s, 0)\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def secondsToRemoveOccurrences(s: String): Int = {\\n        def loop(s: String, acc: Int): Int = s match {\\n            case s if s.sliding(2).count(_.contains(\"01\")) == 0 => acc\\n            case _                                              => loop(s.replace(\"01\", \"10\"), acc + 1)\\n        }\\n\\n        loop(s, 0)\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2911314,
                "title": "c-easy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0, n = s.length();\\n        while (true) {\\n            bool b = false;\\n            for (int i = 0; i < n - 1; ++i) {\\n                if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                    s[i++] = \\'1\\';\\n                    s[i] = \\'0\\';\\n                    b = true;\\n                }\\n            }\\n\\n            if (!b) {\\n                break;\\n            }\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0, n = s.length();\\n        while (true) {\\n            bool b = false;\\n            for (int i = 0; i < n - 1; ++i) {\\n                if (s[i] == \\'0\\' && s[i + 1] == \\'1\\') {\\n                    s[i++] = \\'1\\';\\n                    s[i] = \\'0\\';\\n                    b = true;\\n                }\\n            }\\n\\n            if (!b) {\\n                break;\\n            }\\n            ++ans;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2903199,
                "title": "dart-implementation-o-n-time-o-1-space",
                "content": "# Intuition\\nSimple observation - every second we move \"1\" to the left whenever there is a \"0\" on the left side. If not and there are continues \"11111\" - the rightmost \"1\" waits number of seconds equal to the length of the \"train of 1\" till at least one zero comes on the left and we can start moving it. \\nSo for every \"1\" we can calculate two variables - number of 0-s to swap with and number of 1-s to wait for. Solution if the max( 0-s + 1-s) :-)\\n\\n\\n\\n# Approach\\nAt first we can clean the input string from the leading \"1\"s and tailing \"0\"\\'s since they do not affect result.\\n\\nThen iterate through the remaining string and calculate two variables mentioned above- zero - number of zeros up to the index i, and dup - number of continues \"11111\" to wait for (increased whenever we meet \"11\" and decreased whenever we meet \"00\"). \\n\\n# Complexity\\n- Time complexity:\\nO(N)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n\\nclass Solution {\\n  int secondsToRemoveOccurrences(String s) {\\n    int rem1 = s.indexOf(\\'0\\');\\n    int rem0 = s.codeUnits.lastIndexOf(\"1\".codeUnitAt(0));\\n    if (rem1 == -1 || rem0 == -1 || rem0 == rem1 - 1) return 0;\\n    s = s.substring(rem1, rem0 + 1);\\n\\n    int N = s.length;\\n    int zero = 0;\\n    int dup = 0;\\n    zero = s[0] == \\'0\\' ? 1 : 0;\\n\\n    int res = 0;\\n    for (int i = 1; i < N; i++) {\\n      int dupDelta = 0;\\n      if (s[i] == \\'1\\' && s[i - 1] == \\'1\\')\\n        dupDelta = 1;\\n      else if (s[i] == \\'0\\' && s[i - 1] == \\'0\\') dupDelta = -1;\\n\\n      zero = zero + (s[i] == \\'0\\' ? 1 : 0);\\n      dup = max(0, dup + dupDelta);\\n      res = max(res, zero + dup);\\n    }\\n\\n    return res;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Dart"
                ],
                "code": "```\\n\\nclass Solution {\\n  int secondsToRemoveOccurrences(String s) {\\n    int rem1 = s.indexOf(\\'0\\');\\n    int rem0 = s.codeUnits.lastIndexOf(\"1\".codeUnitAt(0));\\n    if (rem1 == -1 || rem0 == -1 || rem0 == rem1 - 1) return 0;\\n    s = s.substring(rem1, rem0 + 1);\\n\\n    int N = s.length;\\n    int zero = 0;\\n    int dup = 0;\\n    zero = s[0] == \\'0\\' ? 1 : 0;\\n\\n    int res = 0;\\n    for (int i = 1; i < N; i++) {\\n      int dupDelta = 0;\\n      if (s[i] == \\'1\\' && s[i - 1] == \\'1\\')\\n        dupDelta = 1;\\n      else if (s[i] == \\'0\\' && s[i - 1] == \\'0\\') dupDelta = -1;\\n\\n      zero = zero + (s[i] == \\'0\\' ? 1 : 0);\\n      dup = max(0, dup + dupDelta);\\n      res = max(res, zero + dup);\\n    }\\n\\n    return res;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2902460,
                "title": "simple-solution",
                "content": "# Approach\\nRepeat replacing all `\"01\"` with `\"10\"` until all is done. Count and return the times that this process is executed \\n\\n# Code\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        seconds = 0\\n        while \\'01\\' in s:\\n            seconds += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n        \\n        return seconds\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        seconds = 0\\n        while \\'01\\' in s:\\n            seconds += 1\\n            s = s.replace(\\'01\\', \\'10\\')\\n        \\n        return seconds\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2889075,
                "title": "no-string-replace-o-n-time-o-1-space-solution",
                "content": "# Intuition\\nTook me a while and a few iterations to get here. If current 1 encounters or gets blocked the previous 1, then the answer is one more than the previous one. Whether or not current 1 encounters a previous 1 depends on the number of 0s before it.\\n\\n# Approach\\nSimple for loop that keeps track of num0s and previous ans to compute the current answer.\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int num0s = 0, ans = 0;\\n        for (char ch : s) {\\n            if (ch == \\'0\\') {\\n                num0s++;\\n                continue;\\n            }\\n            // ignore the 1s if there are no 0s.\\n            if (num0s == 0) continue;\\n            ans = max(ans + 1, num0s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int num0s = 0, ans = 0;\\n        for (char ch : s) {\\n            if (ch == \\'0\\') {\\n                num0s++;\\n                continue;\\n            }\\n            // ignore the 1s if there are no 0s.\\n            if (num0s == 0) continue;\\n            ans = max(ans + 1, num0s);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2876822,
                "title": "easy-and-clean-solution-using-simple-approach",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        boolean changed = true;\\n        char [] ch = s.toCharArray();\\n        int count = 0;\\n        while(changed)\\n        {\\n            changed = false;\\n            for(int i = 0; i < ch.length-1;i++)\\n            {\\n                if(ch[i] == \\'0\\' && ch[i+1] == \\'1\\')\\n                {\\n                    ch[i] = \\'1\\';\\n                    ch[i+1] = \\'0\\';\\n                    changed = true;\\n                    i++;\\n                }\\n            }\\n            if(changed)\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        boolean changed = true;\\n        char [] ch = s.toCharArray();\\n        int count = 0;\\n        while(changed)\\n        {\\n            changed = false;\\n            for(int i = 0; i < ch.length-1;i++)\\n            {\\n                if(ch[i] == \\'0\\' && ch[i+1] == \\'1\\')\\n                {\\n                    ch[i] = \\'1\\';\\n                    ch[i+1] = \\'0\\';\\n                    changed = true;\\n                    i++;\\n                }\\n            }\\n            if(changed)\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2869692,
                "title": "c-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int zero=0,second=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            zero+=(s[i]==\\'0\\');\\n            if(s[i]==\\'1\\'&&zero)\\n            {\\n                second=max(second+1,zero);\\n            }\\n        }\\n        return second;\\n        \\n    }\\n};\\n//if you like the solution plz upvote.",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int zero=0,second=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            zero+=(s[i]==\\'0\\');\\n            if(s[i]==\\'1\\'&&zero)\\n            {\\n                second=max(second+1,zero);\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2858463,
                "title": "o-n-time-o-1-space",
                "content": "# Intuition\\nBased on the description, I realized that the result would always be of the form 111...111000...000. Therefore, I just tried a few examples until I got the pattern and condensed it into a dp solution. Here are 3 examples that I tried that helped me:\\n\\nConsider \"10001\". In this case, it takes the number of zeros\\' seconds, 3 shifts of the 1 to the left to get to \"11000\"\\n\\nNext, consider \"10011\". In this case, we need 2 seconds for the zeros and an additional second for the 1 on the far right. Visually, it looks like this (with a \"wait\" second for the farthest right 1):\\n    10011 -> (\"furthest right waits 1 second\") 10101 -> 11010 -> 11100\\n\\nLastly, consider \"1100011101\". If we just do the arduous work, we can see it takes 6 seconds:\\n    1100011101 -> 1100101110 -> 1101010110 -> 1110101010 -> 1111010100 -> 1111101000 -> 1111110000\\nBreaking it down at each step, as we encounter a 0, that adds one second to the solution, however, each subsequent 1 could potentially add an additional second to the solution depending on the number of zeros we have encountered thus far. Taking the max of each suffices.\\n\\nLastly, our corner cases to explain the if statement in my code: 11111, 111000\\nThe problem states that s[i] is either \\'0\\' or \\'1\\', but doesn\\'t state there have to be both. In either case, the same if statement catches both. Namely, we don\\'t encounter any 0\\'s before 1\\'s, hence the result is 0.\\n\\n# Approach\\n```\\n1. Loop through each character in s\\n2. Increment our total zeros found\\n3. If we reach a 1, and have encountered at least a single 0, update our result to be the max(result+1, zeros)\\n```\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$ where $$n$$ is the length of $$s$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\npublic class Solution {\\n    public int SecondsToRemoveOccurrences(string s) {\\n        if (string.IsNullOrWhiteSpace(s)) {\\n            return 0;\\n        }\\n\\n        int result = 0;\\n        int zeros = 0;\\n        foreach (char c in s) {\\n            zeros += c == \\'0\\' ? 1 : 0;\\n            if (c == \\'1\\' && zeros > 0) {\\n                result = Math.Max(result+1, zeros);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Dynamic Programming"
                ],
                "code": "```\\n1. Loop through each character in s\\n2. Increment our total zeros found\\n3. If we reach a 1, and have encountered at least a single 0, update our result to be the max(result+1, zeros)\\n```\n```\\npublic class Solution {\\n    public int SecondsToRemoveOccurrences(string s) {\\n        if (string.IsNullOrWhiteSpace(s)) {\\n            return 0;\\n        }\\n\\n        int result = 0;\\n        int zeros = 0;\\n        foreach (char c in s) {\\n            zeros += c == \\'0\\' ? 1 : 0;\\n            if (c == \\'1\\' && zeros > 0) {\\n                result = Math.Max(result+1, zeros);\\n            }\\n        }\\n        \\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2857310,
                "title": "easy-to-understand-python-solution-5-lines",
                "content": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        \\n            \\'\\'\\'\\n            while 01 exists in the string, perform some operation\\n            \\n            \\'\\'\\'\\n            count = 0\\n            while s.find(\\'01\\') != -1:\\n                count += 1 \\n                s = s.replace(\"01\", \"10\")\\n            return count\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        \\n            \\'\\'\\'\\n            while 01 exists in the string, perform some operation\\n            \\n            \\'\\'\\'\\n            count = 0\\n            while s.find(\\'01\\') != -1:\\n                count += 1 \\n                s = s.replace(\"01\", \"10\")\\n            return count\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2854756,
                "title": "video-walkthrough-three-line-solution-python-o-n",
                "content": "[Click Here For Video Walkthrough](https://youtu.be/c9FPc5GNROI)\\n```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        zeros, seconds = 0, 0\\n        for c in s:\\n            if c ==  \\'0\\': zeros += 1\\n            elif zeros: seconds = max(1 + seconds, zeros)\\n        return seconds\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        zeros, seconds = 0, 0\\n        for c in s:\\n            if c ==  \\'0\\': zeros += 1\\n            elif zeros: seconds = max(1 + seconds, zeros)\\n        return seconds\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2851409,
                "title": "python3-intelligent-tracking-of-0s",
                "content": "```\\nfrom collections import deque\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        boundary = len(s)\\n        arr = list(s)\\n        ts=0\\n        zeros = deque()\\n        for idx,num in enumerate(arr):\\n\\t\\t\\t#if this is 01 keep track of this index\\n            if num==\\'0\\' and idx+1<boundary and arr[idx+1]==\\'1\\':\\n                zeros.append(idx)\\n                \\n        iterations = len(zeros)\\n        while zeros:\\n            iterations = len(zeros)\\n            ts+=1\\n            for _ in range(iterations):\\n                first = zeros.popleft()\\n                arr[first], arr[first+1] = arr[first+1], arr[first]\\n\\t\\t\\t\\t#if theres a 01 in front after the swap keep track of first+1\\n                if first+2<boundary and arr[first+2]==\\'1\\':\\n                    zeros.append(first+1)\\n\\t\\t\\t\\t#if there\\'s a 0 behind after the swap keep track of that zero\\n                if first-1>=0 and arr[first-1]==\\'0\\':\\n                    zeros.append(first-1)\\n\\n        return ts\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import deque\\nclass Solution:\\n    def secondsToRemoveOccurrences(self, s: str) -> int:\\n        boundary = len(s)\\n        arr = list(s)\\n        ts=0\\n        zeros = deque()\\n        for idx,num in enumerate(arr):\\n\\t\\t\\t#if this is 01 keep track of this index\\n            if num==\\'0\\' and idx+1<boundary and arr[idx+1]==\\'1\\':\\n                zeros.append(idx)\\n                \\n        iterations = len(zeros)\\n        while zeros:\\n            iterations = len(zeros)\\n            ts+=1\\n            for _ in range(iterations):\\n                first = zeros.popleft()\\n                arr[first], arr[first+1] = arr[first+1], arr[first]\\n\\t\\t\\t\\t#if theres a 01 in front after the swap keep track of first+1\\n                if first+2<boundary and arr[first+2]==\\'1\\':\\n                    zeros.append(first+1)\\n\\t\\t\\t\\t#if there\\'s a 0 behind after the swap keep track of that zero\\n                if first-1>=0 and arr[first-1]==\\'0\\':\\n                    zeros.append(first-1)\\n\\n        return ts\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2850116,
                "title": "here-is-javascript-solution",
                "content": "```\\n\\n```var secondsToRemoveOccurrences = function(s) {\\n    let count=0\\n\\n  while(s.indexOf(\"01\")!=-1)\\n    {\\n        ar=s.split(\"\")\\n        for(let i=0;i<ar.length;i++)\\n            {\\n                if(ar[i]==\"0\" && ar[i+1]==\"1\" )\\n                    {\\n                        ar[i]=\"1\"\\n                        ar[i+1]=\"0\"\\n                        i++\\n                    }\\n            }\\n      \\n      s=ar.join(\"\")\\n      count++\\n   }\\n    return count\\n    \\n};",
                "solutionTags": [],
                "code": "```\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2848029,
                "title": "easiest-java-solution-java",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s)\\n    {\\n        StringBuilder sb=new StringBuilder(s);\\n        int k=1;\\n        int count=0;\\n        while(sb.indexOf(\"01\")!=-1)\\n        {\\n            for(int i=sb.indexOf(\"01\");i<sb.length()-1;i+=k)\\n            {\\n                if(sb.charAt(i)==\\'0\\' && sb.charAt(i+1)==\\'1\\')\\n                {\\n                    sb.setCharAt(i,\\'1\\');\\n                    sb.setCharAt(i+1,\\'0\\');\\n                    k=2;\\n                }\\n                else\\n                {\\n                    k=1;\\n                }\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s)\\n    {\\n        StringBuilder sb=new StringBuilder(s);\\n        int k=1;\\n        int count=0;\\n        while(sb.indexOf(\"01\")!=-1)\\n        {\\n            for(int i=sb.indexOf(\"01\");i<sb.length()-1;i+=k)\\n            {\\n                if(sb.charAt(i)==\\'0\\' && sb.charAt(i+1)==\\'1\\')\\n                {\\n                    sb.setCharAt(i,\\'1\\');\\n                    sb.setCharAt(i+1,\\'0\\');\\n                    k=2;\\n                }\\n                else\\n                {\\n                    k=1;\\n                }\\n            }\\n            count++;\\n        }\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2837892,
                "title": "simple-well-explained-c-solution",
                "content": "- After completely swapping all the \\'01\\' to \\'10\\', at the end we will get a sorted string in such a way that all the 1\\'s will come before all the 0\\'s. Eg. if a string is \"10111000\" it will become \"11110000\" at the end.\\n- So we will make a temporary string equal to the string we will obtain at the end and run a loop until our original string becomes equal to that string.\\n- Then in each iteration of while loop we will maintain the indices of the 0\\'s who have 1 as the next element and swap them all at once and increment the time needed by 1.\\n- Doing so will give us the answer. \\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        string temp = s;\\n        sort(temp.begin(),temp.end());\\n        reverse(temp.begin(),temp.end());\\n        while(s!=temp){\\n            vector<int> v;\\n            for(int i = 0;i<s.length()-1;i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    v.push_back(i);\\n                }\\n            }\\n            for(int i = 0;i<v.size();i++){\\n                swap(s[v[i]],s[v[i]+1]);\\n            }\\n            ans++;\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int ans = 0;\\n        string temp = s;\\n        sort(temp.begin(),temp.end());\\n        reverse(temp.begin(),temp.end());\\n        while(s!=temp){\\n            vector<int> v;\\n            for(int i = 0;i<s.length()-1;i++){\\n                if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                    v.push_back(i);\\n                }\\n            }\\n            for(int i = 0;i<v.size();i++){\\n                swap(s[v[i]],s[v[i]+1]);\\n            }\\n            ans++;\\n        }\\n         return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2805690,
                "title": "brute-force-recursion-2-solutions",
                "content": "### **Brute Force Easy One Two While**\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int res=0;\\n        while(1)\\n        {\\n            int k=0,i=0;\\n            while(i<s.size())\\n            {\\n                if(s[i]==\\'0\\'&&s[i+1]==\\'1\\')\\n                {\\n                    swap(s[i],s[i+1]);\\n                    k++;\\n                    i+=2;\\n                }\\n                else\\n                    i++;\\n            }\\n            if(k==0)return res;\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n#### **Recursion Easy Solution Function calling**\\n```\\nclass Solution \\n{\\npublic:\\n    int solvethis(string s,int res)\\n    {\\n        int i=0,k=0;\\n        while(i<s.size())\\n        {\\n            if(s[i]==\\'0\\'&&s[i+1]==\\'1\\')\\n            {\\n                swap(s[i],s[i+1]);\\n                k++;\\n                i+=2;\\n            }\\n            else i++;\\n        }\\n        if(k==0)return res;\\n        return solvethis(s,res+1);\\n    }\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int res=0;\\n        return solvethis(s,res);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int res=0;\\n        while(1)\\n        {\\n            int k=0,i=0;\\n            while(i<s.size())\\n            {\\n                if(s[i]==\\'0\\'&&s[i+1]==\\'1\\')\\n                {\\n                    swap(s[i],s[i+1]);\\n                    k++;\\n                    i+=2;\\n                }\\n                else\\n                    i++;\\n            }\\n            if(k==0)return res;\\n            res++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```\\nclass Solution \\n{\\npublic:\\n    int solvethis(string s,int res)\\n    {\\n        int i=0,k=0;\\n        while(i<s.size())\\n        {\\n            if(s[i]==\\'0\\'&&s[i+1]==\\'1\\')\\n            {\\n                swap(s[i],s[i+1]);\\n                k++;\\n                i+=2;\\n            }\\n            else i++;\\n        }\\n        if(k==0)return res;\\n        return solvethis(s,res+1);\\n    }\\n    int secondsToRemoveOccurrences(string s) \\n    {\\n        int res=0;\\n        return solvethis(s,res);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2794996,
                "title": "normal-solution-for-javascript",
                "content": "var secondsToRemoveOccurrences = function (s) {\\n  let res = 0;\\n  while (s.includes(\\'01\\')) {\\n    const arrs = s.split(\\'\\');\\n    for (let i = 0; i < arrs.length; i++) {\\n      if (arrs[i + 1] && arrs[i] === \\'0\\' && arrs[i + 1] === \\'1\\') {\\n        arrs[i] = \\'1\\';\\n        arrs[i + 1] = \\'0\\';\\n        i++;\\n      }\\n    }\\n    s = arrs.join(\\'\\');\\n    res++;\\n  }\\n  return res\\n};",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "var secondsToRemoveOccurrences = function (s) {\\n  let res = 0;\\n  while (s.includes(\\'01\\')) {\\n    const arrs = s.split(\\'\\');\\n    for (let i = 0; i < arrs.length; i++) {\\n      if (arrs[i + 1] && arrs[i] === \\'0\\' && arrs[i + 1] === \\'1\\') {\\n        arrs[i] = \\'1\\';\\n        arrs[i + 1] = \\'0\\';\\n        i++;\\n      }\\n    }\\n    s = arrs.join(\\'\\');\\n    res++;\\n  }\\n  return res\\n};",
                "codeTag": "Unknown"
            },
            {
                "id": 2764667,
                "title": "c-o-n-simple-and-intuitive-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int lz = 0; //zeros to left\\n        int wt = 0; // additional wait time for one\\n        int ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == \\'0\\') {\\n                wt = max(0, wt - 1);\\n                ++lz;\\n            }\\n            else {\\n                if(lz == 0)\\n                    continue;\\n                ans = max(ans, lz + wt);\\n                ++wt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int lz = 0; //zeros to left\\n        int wt = 0; // additional wait time for one\\n        int ans = 0;\\n        int n = s.size();\\n        for(int i = 0; i<n; i++) {\\n            if(s[i] == \\'0\\') {\\n                wt = max(0, wt - 1);\\n                ++lz;\\n            }\\n            else {\\n                if(lz == 0)\\n                    continue;\\n                ans = max(ans, lz + wt);\\n                ++wt;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2749641,
                "title": "dp-bruteforce",
                "content": "*\\'\\'\\'\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n       int n = s.length();\\n        int flag= 0;\\n        for(int i = 0; i<n-1; i++){\\n            string str =\"\";\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                flag = 1;\\n                swap(s[i], s[i+1]);\\n                 i++;\\n            }\\n            \\n        }\\n         if(flag == 0) return 0;\\n        return 1 + secondsToRemoveOccurrences(s);\\n    }\\n};\\n\\'\\'\\'*",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "class Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n       int n = s.length();\\n        int flag= 0;\\n        for(int i = 0; i<n-1; i++){\\n            string str =\"\";\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                flag = 1;\\n                swap(s[i], s[i+1]);\\n                 i++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2749273,
                "title": "javascript-dp-vs-brute",
                "content": "```\\n// BruteForce TLE\\nvar secondsToRemoveOccurrences = function(s) {\\n    let count = 0;\\n    \\n    while (s.indexOf(\\'01\\') != -1) {\\n      s.replaceAll(\\'01\\', \\'10\\');\\n      count++;\\n    }\\n    \\n    return count;\\n};\\n\\n// DP\\nvar secondsToRemoveOccurrences = function(s) {\\n  let zeroes = 0;\\n  let count = 0;\\n  \\n  for (let i = 0; i < s.length; i++) {\\n    zeroes += s[i] === \\'0\\' ? 1 : 0;\\n    \\n    if (s[i] === \\'1\\' && zeroes) {\\n      count = Math.max(count + 1, zeroes);\\n    }\\n  }\\n  \\n  return count;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n// BruteForce TLE\\nvar secondsToRemoveOccurrences = function(s) {\\n    let count = 0;\\n    \\n    while (s.indexOf(\\'01\\') != -1) {\\n      s.replaceAll(\\'01\\', \\'10\\');\\n      count++;\\n    }\\n    \\n    return count;\\n};\\n\\n// DP\\nvar secondsToRemoveOccurrences = function(s) {\\n  let zeroes = 0;\\n  let count = 0;\\n  \\n  for (let i = 0; i < s.length; i++) {\\n    zeroes += s[i] === \\'0\\' ? 1 : 0;\\n    \\n    if (s[i] === \\'1\\' && zeroes) {\\n      count = Math.max(count + 1, zeroes);\\n    }\\n  }\\n  \\n  return count;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2745988,
                "title": "javascript-easy-approach-100-faster-beginners-friendly",
                "content": "```\\nconst secondsToRemoveOccurrences = (s) => {\\n    let count = 0;\\n    while(s.indexOf(\"01\")!=-1)\\n    {\\n        s = s.replaceAll(\"01\",\"10\");\\n        count++;\\n    }\\n    return count;\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python",
                    "C",
                    "JavaScript",
                    "String"
                ],
                "code": "```\\nconst secondsToRemoveOccurrences = (s) => {\\n    let count = 0;\\n    while(s.indexOf(\"01\")!=-1)\\n    {\\n        s = s.replaceAll(\"01\",\"10\");\\n        count++;\\n    }\\n    return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2738487,
                "title": "easy-brute-force-java-soln",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N^2)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count = 0 ;\\n        String current = s;\\n        while(true){\\n            boolean hasZeroOne = false;\\n            for(int i = 0; i < s.length(); i++){\\n                if(i < s.length() - 1 && s.charAt(i) == \\'0\\' &&  s.charAt(i + 1) == \\'1\\'){\\n                    hasZeroOne = true;\\n                    current = swap(current, i, i + 1);\\n                }\\n            }\\n            s = current;\\n            if(hasZeroOne){\\n                count++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n    private String swap(String str, int i, int j){\\n        StringBuilder sb = new StringBuilder(str);\\n        sb.setCharAt(i, str.charAt(j));\\n        sb.setCharAt(j, str.charAt(i));\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        int count = 0 ;\\n        String current = s;\\n        while(true){\\n            boolean hasZeroOne = false;\\n            for(int i = 0; i < s.length(); i++){\\n                if(i < s.length() - 1 && s.charAt(i) == \\'0\\' &&  s.charAt(i + 1) == \\'1\\'){\\n                    hasZeroOne = true;\\n                    current = swap(current, i, i + 1);\\n                }\\n            }\\n            s = current;\\n            if(hasZeroOne){\\n                count++;\\n            } else {\\n                break;\\n            }\\n        }\\n        return count;\\n    }\\n    private String swap(String str, int i, int j){\\n        StringBuilder sb = new StringBuilder(str);\\n        sb.setCharAt(i, str.charAt(j));\\n        sb.setCharAt(j, str.charAt(i));\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2735369,
                "title": "c",
                "content": "```\\nvoid swap(char* a, char* b){\\n    char temp; \\n    temp  = *a;\\n    *a = *b;\\n    *b = temp;\\n}\\n\\nint secondsToRemoveOccurrences(char * s){\\n    int n = strlen(s);\\n    int* stack = malloc(n * sizeof(int));\\n    int idx = 0;\\n    int step = 0;\\n    while(1){\\n        idx = 0;\\n        for(int i = 0; i < n-1; i++){\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                stack[idx] = i;\\n                idx++;\\n            }\\n        }\\n        if(idx == 0)\\n            break;\\n        else{\\n            step++;\\n            for(int i = 0; i < idx; i++){\\n                swap(&s[stack[i]], &s[stack[i]+1]);\\n            }\\n        }\\n    }\\n    return step;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid swap(char* a, char* b){\\n    char temp; \\n    temp  = *a;\\n    *a = *b;\\n    *b = temp;\\n}\\n\\nint secondsToRemoveOccurrences(char * s){\\n    int n = strlen(s);\\n    int* stack = malloc(n * sizeof(int));\\n    int idx = 0;\\n    int step = 0;\\n    while(1){\\n        idx = 0;\\n        for(int i = 0; i < n-1; i++){\\n            if(s[i] == \\'0\\' && s[i+1] == \\'1\\'){\\n                stack[idx] = i;\\n                idx++;\\n            }\\n        }\\n        if(idx == 0)\\n            break;\\n        else{\\n            step++;\\n            for(int i = 0; i < idx; i++){\\n                swap(&s[stack[i]], &s[stack[i]+1]);\\n            }\\n        }\\n    }\\n    return step;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2728807,
                "title": "python-simple-maths",
                "content": "\\n    def secondsToRemoveOccurrences(self, s):\\n        count = 0\\n        \\n        while \"01\" in s:\\n            count += 1\\n            s = s.replace(\"01\",\"10\")\\n            \\n        return count\\n",
                "solutionTags": [],
                "code": "\\n    def secondsToRemoveOccurrences(self, s):\\n        count = 0\\n        \\n        while \"01\" in s:\\n            count += 1\\n            s = s.replace(\"01\",\"10\")\\n            \\n        return count\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2719115,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count =0;\\n        \\n        while(true){\\n            bool found =false;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    found = true;\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n            if(found) count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count =0;\\n        \\n        while(true){\\n            bool found =false;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    found = true;\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n            if(found) count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2719113,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count =0;\\n        \\n        while(true){\\n            bool found =false;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    found = true;\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n            if(found) count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int secondsToRemoveOccurrences(string s) {\\n        int count =0;\\n        \\n        while(true){\\n            bool found =false;\\n            for(int i=0;i<s.size()-1;i++){\\n                if(s[i]==\\'0\\' && s[i+1]==\\'1\\'){\\n                    found = true;\\n                    swap(s[i],s[i+1]);\\n                    i++;\\n                }\\n            }\\n            if(found) count++;\\n            else break;\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2709322,
                "title": "easy-solution-java-simple-approach-no-dp",
                "content": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] charArray = s.toCharArray();\\n        int count = 0;\\n        int swap = 1;\\n        while(swap == 1){\\n            swap = 0;\\n            count++;\\n            for(int i=0; i<charArray.length-1; i++){\\n                if(charArray[i] == \\'0\\' && charArray[i+1] == \\'1\\'){\\n                    charArray[i] = \\'1\\';\\n                    charArray[i+1] = \\'0\\';\\n                    i++;\\n                    swap = 1;\\n                }\\n            }\\n            \\n        }\\n        return (count-1);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int secondsToRemoveOccurrences(String s) {\\n        char[] charArray = s.toCharArray();\\n        int count = 0;\\n        int swap = 1;\\n        while(swap == 1){\\n            swap = 0;\\n            count++;\\n            for(int i=0; i<charArray.length-1; i++){\\n                if(charArray[i] == \\'0\\' && charArray[i+1] == \\'1\\'){\\n                    charArray[i] = \\'1\\';\\n                    charArray[i+1] = \\'0\\';\\n                    i++;\\n                    swap = 1;\\n                }\\n            }\\n            \\n        }\\n        return (count-1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2692721,
                "title": "c-solution",
                "content": "```\\n\\n int secondsToRemoveOccurrences(string s) {\\n      int n=s.size();int ans=0;\\n        int need=1;\\n        while(need)\\n        {\\n            need=0;                              \\n            int i=1;\\n            while(i<n)\\n            {\\n                if(s[i-1]==\\'0\\'&& s[i]==\\'1\\'){        //if condition satisfies \\n                    swap(s[i-1],s[i]);                         // then we have to swap\\n                    need=1;                           // if we swap the elements then may be it forms another pair of \"01\" so we turn need to \\'1\\'\\n                    i+=2;\\n                }   \\n                else i++;\\n            }\\n            ans+=need;                        // add all need to ans because it tells us that how many time our condition satisfy\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [
                    "String"
                ],
                "code": "```\\n\\n int secondsToRemoveOccurrences(string s) {\\n      int n=s.size();int ans=0;\\n        int need=1;\\n        while(need)\\n        {\\n            need=0;                              \\n            int i=1;\\n            while(i<n)\\n            {\\n                if(s[i-1]==\\'0\\'&& s[i]==\\'1\\'){        //if condition satisfies \\n                    swap(s[i-1],s[i]);                         // then we have to swap\\n                    need=1;                           // if we swap the elements then may be it forms another pair of \"01\" so we turn need to \\'1\\'\\n                    i+=2;\\n                }   \\n                else i++;\\n            }\\n            ans+=need;                        // add all need to ans because it tells us that how many time our condition satisfy\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1709830,
                "content": [
                    {
                        "username": "pokerboy_leet",
                        "content": "I Thought there might be any logic i missed but its simply a brute force approach..  : )"
                    },
                    {
                        "username": "adibahmed5004",
                        "content": "Does string.replace works in O(n) time ? any idea?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "You don\\'t want to use that. Str. replace makes some internal copies of the original string, and traverses it few times. It\\'s better to simply use char[] and traverse the char[] yourself, replacing 01 to 10. "
                    }
                ]
            },
            {
                "id": 1751017,
                "content": [
                    {
                        "username": "pokerboy_leet",
                        "content": "I Thought there might be any logic i missed but its simply a brute force approach..  : )"
                    },
                    {
                        "username": "adibahmed5004",
                        "content": "Does string.replace works in O(n) time ? any idea?"
                    },
                    {
                        "username": "StefanelStan",
                        "content": "You don\\'t want to use that. Str. replace makes some internal copies of the original string, and traverses it few times. It\\'s better to simply use char[] and traverse the char[] yourself, replacing 01 to 10. "
                    }
                ]
            }
        ]
    },
    {
        "title": "Shifting Letters II",
        "question_content": "<p>You are given a string <code>s</code> of lowercase English letters and a 2D integer array <code>shifts</code> where <code>shifts[i] = [start<sub>i</sub>, end<sub>i</sub>, direction<sub>i</sub>]</code>. For every <code>i</code>, <strong>shift</strong> the characters in <code>s</code> from the index <code>start<sub>i</sub></code> to the index <code>end<sub>i</sub></code> (<strong>inclusive</strong>) forward if <code>direction<sub>i</sub> = 1</code>, or shift the characters backward if <code>direction<sub>i</sub> = 0</code>.</p>\n\n<p>Shifting a character <strong>forward</strong> means replacing it with the <strong>next</strong> letter in the alphabet (wrapping around so that <code>&#39;z&#39;</code> becomes <code>&#39;a&#39;</code>). Similarly, shifting a character <strong>backward</strong> means replacing it with the <strong>previous</strong> letter in the alphabet (wrapping around so that <code>&#39;a&#39;</code> becomes <code>&#39;z&#39;</code>).</p>\n\n<p>Return <em>the final string after all such shifts to </em><code>s</code><em> are applied</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;abc&quot;, shifts = [[0,1,0],[1,2,1],[0,2,1]]\n<strong>Output:</strong> &quot;ace&quot;\n<strong>Explanation:</strong> Firstly, shift the characters from index 0 to index 1 backward. Now s = &quot;zac&quot;.\nSecondly, shift the characters from index 1 to index 2 forward. Now s = &quot;zbd&quot;.\nFinally, shift the characters from index 0 to index 2 forward. Now s = &quot;ace&quot;.</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> s = &quot;dztz&quot;, shifts = [[0,0,0],[1,1,1]]\n<strong>Output:</strong> &quot;catz&quot;\n<strong>Explanation:</strong> Firstly, shift the characters from index 0 to index 0 backward. Now s = &quot;cztz&quot;.\nFinally, shift the characters from index 1 to index 1 forward. Now s = &quot;catz&quot;.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= s.length, shifts.length &lt;= 5 * 10<sup>4</sup></code></li>\n\t<li><code>shifts[i].length == 3</code></li>\n\t<li><code>0 &lt;= start<sub>i</sub> &lt;= end<sub>i</sub> &lt; s.length</code></li>\n\t<li><code>0 &lt;= direction<sub>i</sub> &lt;= 1</code></li>\n\t<li><code>s</code> consists of lowercase English letters.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2454167,
                "title": "line-sweep-with-explanation",
                "content": "**Explanation:-**\\n\\n1. ```Lets say we are given [1,10000] and [2,10000] intervals and we are supposed to increase the  count of values between  1 to 10000 and 2 to 10000 by 1.```\\n2. So how you will do?\\n3. ```Brute force is to iterate over each interval and increase each position count that is appearing in intervals.```\\n4. Can we do better?\\n5. ```Lets create a array from index 0 to 1e5.```\\n6. ```Now iterate over each interval.Eg.:-```\\n7.  ```[1,10000]:- increase the counter at pos 1 and decrease at 10001.Same for other intervals.```\\n8. ``` Now do prefix sum.```\\n9.  This will incerase each position value in linear time.\\n10. In question when we do forward shift then we have to increase the count from position left to right.\\n11.So i will do line[left]++ and line[right+1]--.\\n12. For backward shift we want to decrease the value so\\n13. So i will do line[left]-- and line[right+1]++.\\nI hope you can do question now.\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& sh) {\\n        long sz=s.size();\\n        vector<long>line(sz+1,0);\\n        for(auto & i:sh){\\n            // forward shift so do +1\\n            if(i[2]==1){\\n                line[i[0]]++;\\n                line[i[1]+1]--;\\n            }\\n            //backward shift so do -1\\n            else{\\n                line[i[0]]--;\\n                line[i[1]+1]++;                \\n            }\\n        }\\n        for(int i=1;i<=sz;i++)\\n            line[i]+=line[i-1];\\n        for(int i=0;i<sz;i++){\\n\\t\\t// line[i] is how many times i have to increase or decrease the s[i] char.So i am adding it and taking modulo\\n\\t\\t\\tint increaseBy=(s[i]-\\'a\\'+line[i])%26;\\n\\t\\t// this is to make -ve module +ve. \\n\\t\\t\\tincreaseBy=(increaseBy+26)%26;\\n\\t\\t\\ts[i]=\\'a\\'+increaseBy;\\n        }\\n        return s;      \\n    }\\n};\\n```\\nDo **UPVOTE** if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```Lets say we are given [1,10000] and [2,10000] intervals and we are supposed to increase the  count of values between  1 to 10000 and 2 to 10000 by 1.```\n```Brute force is to iterate over each interval and increase each position count that is appearing in intervals.```\n```Lets create a array from index 0 to 1e5.```\n```Now iterate over each interval.Eg.:-```\n```[1,10000]:- increase the counter at pos 1 and decrease at 10001.Same for other intervals.```\n``` Now do prefix sum.```\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& sh) {\\n        long sz=s.size();\\n        vector<long>line(sz+1,0);\\n        for(auto & i:sh){\\n            // forward shift so do +1\\n            if(i[2]==1){\\n                line[i[0]]++;\\n                line[i[1]+1]--;\\n            }\\n            //backward shift so do -1\\n            else{\\n                line[i[0]]--;\\n                line[i[1]+1]++;                \\n            }\\n        }\\n        for(int i=1;i<=sz;i++)\\n            line[i]+=line[i-1];\\n        for(int i=0;i<sz;i++){\\n\\t\\t// line[i] is how many times i have to increase or decrease the s[i] char.So i am adding it and taking modulo\\n\\t\\t\\tint increaseBy=(s[i]-\\'a\\'+line[i])%26;\\n\\t\\t// this is to make -ve module +ve. \\n\\t\\t\\tincreaseBy=(increaseBy+26)%26;\\n\\t\\t\\ts[i]=\\'a\\'+increaseBy;\\n        }\\n        return s;      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454158,
                "title": "fenwick-tree-vs-line-sweep",
                "content": "First, we accumulate all shifts. To do that efficiently, we can use a Fenwick Tree or Line Sweep.\\n\\n#### Line Sweep\\nWe add shifts to the beginning and end of each interval. Then, we use a line sweep technique to accumulate shifts for each position in `s`.\\n\\n**C++**\\n```cpp\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n    int line[50001] = {};\\n    for (auto &shift : shifts) {\\n        line[shift[0]] += shift[2] ? 1 : -1;\\n        line[shift[1] + 1] += shift[2] ? -1 : 1;\\n    }\\n    for (int i = 0, val = 0; i < s.size(); ++i) {\\n        val = (val + line[i]) % 26;\\n        s[i] = \\'a\\' + (26 + (s[i] - \\'a\\') + val) % 26;\\n    }\\n    return s;\\n}\\n```\\n#### Fenwick Tree\\nFenwick Tree provides is a mutable prefix sum functionality - we can increment all elements in a range, and get a sum of that range in O(log n).\\n\\n**C++**\\n```cpp\\nconstexpr int static n = 50000;\\nint bt[n + 1] = {};\\nint prefix_sum(int i)\\n{\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n    for (auto &shift : shifts) {\\n        add(shift[0], shift[2] == 1 ? 1 : -1);\\n        add(shift[1] + 1, shift[2] == 1 ? -1 : 1);\\n    }\\n    for (int i = 0; i < s.size(); ++i)\\n        s[i] = \\'a\\' + (26 + (s[i] - \\'a\\') + prefix_sum(i) % 26) % 26;\\n    return s;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n    int line[50001] = {};\\n    for (auto &shift : shifts) {\\n        line[shift[0]] += shift[2] ? 1 : -1;\\n        line[shift[1] + 1] += shift[2] ? -1 : 1;\\n    }\\n    for (int i = 0, val = 0; i < s.size(); ++i) {\\n        val = (val + line[i]) % 26;\\n        s[i] = \\'a\\' + (26 + (s[i] - \\'a\\') + val) % 26;\\n    }\\n    return s;\\n}\\n```\n```cpp\\nconstexpr int static n = 50000;\\nint bt[n + 1] = {};\\nint prefix_sum(int i)\\n{\\n    int sum = 0;\\n    for (i = i + 1; i > 0; i -= i & (-i))\\n        sum += bt[i];\\n    return sum;\\n}\\nvoid add(int i, int val)\\n{\\n    for (i = i + 1; i <= n; i += i & (-i))\\n        bt[i] += val;\\n}\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n    for (auto &shift : shifts) {\\n        add(shift[0], shift[2] == 1 ? 1 : -1);\\n        add(shift[1] + 1, shift[2] == 1 ? -1 : 1);\\n    }\\n    for (int i = 0; i < s.size(); ++i)\\n        s[i] = \\'a\\' + (26 + (s[i] - \\'a\\') + prefix_sum(i) % 26) % 26;\\n    return s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454324,
                "title": "prefix-sum-range-update-o-n-java-6-ms-100",
                "content": "```\\n  public String shiftingLetters(String s, int[][] shifts) {\\n        char[] ch = s.toCharArray();\\n        int[] count = new int[s.length()+1];\\n        \\n        for(int[] shift : shifts){\\n            int value = shift[2] == 1 ? 1 : -1;\\n            count[shift[0]] += value;\\n            count[shift[1] + 1] -= value;\\n        }\\n        \\n        int sum = 0;\\n        for(int i = 0; i < count.length - 1; i++){\\n            sum += count[i];\\n            int newChar = ((ch[i] - \\'a\\') + sum) % 26;\\n            if(newChar < 0) newChar+= 26;\\n            ch[i] =  (char)(\\'a\\' + newChar);\\n        }\\n        \\n        return String.valueOf(ch);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n  public String shiftingLetters(String s, int[][] shifts) {\\n        char[] ch = s.toCharArray();\\n        int[] count = new int[s.length()+1];\\n        \\n        for(int[] shift : shifts){\\n            int value = shift[2] == 1 ? 1 : -1;\\n            count[shift[0]] += value;\\n            count[shift[1] + 1] -= value;\\n        }\\n        \\n        int sum = 0;\\n        for(int i = 0; i < count.length - 1; i++){\\n            sum += count[i];\\n            int newChar = ((ch[i] - \\'a\\') + sum) % 26;\\n            if(newChar < 0) newChar+= 26;\\n            ch[i] =  (char)(\\'a\\' + newChar);\\n        }\\n        \\n        return String.valueOf(ch);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454359,
                "title": "prefix-sum-c-simple-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size(),sum=0;\\n        vector <int> v(n+1,0);\\n        \\n        for(int i=0;i<shifts.size();i++){\\n            int l=shifts[i][0];\\n            int r=shifts[i][1];\\n            if(shifts[i][2]==0){\\n                v[l]--;\\n                v[r+1]++;\\n            }\\n            else{\\n                v[l]++;\\n                v[r+1]--;\\n            }\\n        }\\n    \\n        for(int i=0;i<n;i++){\\n            sum+=v[i];\\n            int k=sum%26;\\n            int p=(s[i]-\\'a\\'+k+26)%26;\\n            s[i]=char(\\'a\\'+p);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size(),sum=0;\\n        vector <int> v(n+1,0);\\n        \\n        for(int i=0;i<shifts.size();i++){\\n            int l=shifts[i][0];\\n            int r=shifts[i][1];\\n            if(shifts[i][2]==0){\\n                v[l]--;\\n                v[r+1]++;\\n            }\\n            else{\\n                v[l]++;\\n                v[r+1]--;\\n            }\\n        }\\n    \\n        for(int i=0;i<n;i++){\\n            sum+=v[i];\\n            int k=sum%26;\\n            int p=(s[i]-\\'a\\'+k+26)%26;\\n            s[i]=char(\\'a\\'+p);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454404,
                "title": "python-cumulative-sum-easy-solution",
                "content": "In this problem, we should be doing the exact same thing as in the first part of this problem (shifting letters) but there is an extra complexity of finding the final changes for each of the letters. \\n\\nA brute force approach would be to iterate through all of the letters that need to be changed for each shift in array shifts (e.g., from 0 to 2 in forward direction). However, this adds extra complexity if we have large ranges of letters that need to be changed. This is why we should be using a cumulative sum approach here. \\n\\nFor example, instead of iterating through the range, we can add a +1 if we are moving forward in the beginning of the range and -1 in the end of the range to make sure we are no longer applying the change. The same thing goes for the backward direction with the -1 at the beginning and +1 at the end.\\n\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        cum_shifts = [0 for _ in range(len(s)+1)]\\n        \\n        for st, end, d in shifts:\\n            if d == 0:\\n                cum_shifts[st] -= 1\\n                cum_shifts[end+1] += 1\\n            else:\\n                cum_shifts[st] += 1\\n                cum_shifts[end+1] -= 1\\n        \\n        cum_sum = 0\\n        for i in range(len(s)):\\n            cum_sum += cum_shifts[i]\\n            \\n            new_code = (((ord(s[i]) + cum_sum) - 97) % 26) + 97\\n            s = s[:i] + chr(new_code) + s[i+1:]\\n        \\n        return s\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        cum_shifts = [0 for _ in range(len(s)+1)]\\n        \\n        for st, end, d in shifts:\\n            if d == 0:\\n                cum_shifts[st] -= 1\\n                cum_shifts[end+1] += 1\\n            else:\\n                cum_shifts[st] += 1\\n                cum_shifts[end+1] -= 1\\n        \\n        cum_sum = 0\\n        for i in range(len(s)):\\n            cum_sum += cum_shifts[i]\\n            \\n            new_code = (((ord(s[i]) + cum_sum) - 97) % 26) + 97\\n            s = s[:i] + chr(new_code) + s[i+1:]\\n        \\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454310,
                "title": "c-o-n-scanline-algorithm",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach**:\\n1. using \\'Scanline Algorithm\\' to keep track of how a particular shift is affecting a range \\n2. reference video: https://www.youtube.com/watch?v=lFBpH_Mt_LI\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        vector<int> dir(n+1,0);\\n        for(int k=0;k<shifts.size();k++){\\n            int i = shifts[k][0], j=shifts[k][1], move = (shifts[k][2] == 0 ? -1:1);\\n            dir[i] += move, dir[j+1] -= move;\\n        }\\n        \\n        for(int i=1;i<n+1;i++) dir[i] += dir[i-1]; // cummulative effect of all shifts on each index \\n        \\n        for(int i=0;i<n;i++){\\n            int idx = (s[i]-\\'a\\' + dir[i])%26;\\n            if(idx<0) idx += 26;\\n            char new_ch = (char)(idx + \\'a\\');\\n            s[i] = new_ch;\\n        }\\n        return s;\\n    }\\n}; \\n```\\n\\n**Do UPVOTE if it helps :)**",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        vector<int> dir(n+1,0);\\n        for(int k=0;k<shifts.size();k++){\\n            int i = shifts[k][0], j=shifts[k][1], move = (shifts[k][2] == 0 ? -1:1);\\n            dir[i] += move, dir[j+1] -= move;\\n        }\\n        \\n        for(int i=1;i<n+1;i++) dir[i] += dir[i-1]; // cummulative effect of all shifts on each index \\n        \\n        for(int i=0;i<n;i++){\\n            int idx = (s[i]-\\'a\\' + dir[i])%26;\\n            if(idx<0) idx += 26;\\n            char new_ch = (char)(idx + \\'a\\');\\n            s[i] = new_ch;\\n        }\\n        return s;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485135,
                "title": "c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n  \\n// charecter shifting function\\n    char shift(char a, int n){\\n        int i = a - \\'a\\';\\n        i = (i+n)%26;\\n        \\n        //negative case\\n        if(i<0)\\n            i = i+26;\\n        \\n        return \\'a\\' + i;\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n = s.size();\\n        vector<int> presum(n+1,0);\\n        \\n        for(auto x: shifts){\\n            \\n            if(x[2]==0){\\n                presum[x[0]]--;;\\n                presum[x[1]+1]++;\\n            }\\n            else{\\n                presum[x[0]]++;;\\n                presum[x[1]+1]--;\\n            }            \\n        }\\n        \\n        for(int i = 1; i<presum.size();i++)\\n            presum[i]+=presum[i-1];        \\n        \\n        string ans = \"\";\\n        for(int i =0; i<n; i++)\\n            ans+= shift(s[i],presum[i]);\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n  \\n// charecter shifting function\\n    char shift(char a, int n){\\n        int i = a - \\'a\\';\\n        i = (i+n)%26;\\n        \\n        //negative case\\n        if(i<0)\\n            i = i+26;\\n        \\n        return \\'a\\' + i;\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n = s.size();\\n        vector<int> presum(n+1,0);\\n        \\n        for(auto x: shifts){\\n            \\n            if(x[2]==0){\\n                presum[x[0]]--;;\\n                presum[x[1]+1]++;\\n            }\\n            else{\\n                presum[x[0]]++;;\\n                presum[x[1]+1]--;\\n            }            \\n        }\\n        \\n        for(int i = 1; i<presum.size();i++)\\n            presum[i]+=presum[i-1];        \\n        \\n        string ans = \"\";\\n        for(int i =0; i<n; i++)\\n            ans+= shift(s[i],presum[i]);\\n        \\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465791,
                "title": "python3-8-lines-letter-indexing-w-explanation-t-m-100-60",
                "content": "```\\nclass Solution:         # Here\\'s the plan:\\n                        #   1) 1a: Initiate an array offsets with length len(s)+1. \\n                        #      1b: Iterate through shifts and collect the endpts and the direction\\n                        #          of each shift. (Note that 2*(0)-1 = -1 and 2*(1)-1 = 1.)\\n                        #      1c: Accumulate the elements in offsets to determine the cummulative\\n                        #          offset for each char in s\\n                        # \\n                        #   2) 2a: Write the letter index (1-26) of each char of s to a list chNums. \\n                        #      2b: Add to each letter index its corresponding offset and determine \\n                        #          its new letter index by applying %26.\\n                        #      2c: Return the result string from chNums. \\n\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n\\n        offsets = [0]*(n+1)                                     # <-- 1a\\n\\t\\t\\n        for start, end, direction in shifts:                    # <-- 1b\\n            offsets[start]+= 2*direction-1\\n            offsets[end+1]-= 2*direction-1\\n\\t\\t\\t\\n        offsets = accumulate(offsets)                           # <-- 1c\\n\\n        chNums = (ord(ch)-97 for ch in s)                       # <-- 2a\\n\\t\\t\\n        chNums = ((chNum + offset)%26 for chNum,                # <-- 2b\\n                   offset in zip(chNums, offsets))\\n\\n        return \\'\\'.join(chr(chNum+97) for chNum in chNums)       # <-- 2c",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:         # Here\\'s the plan:\\n                        #   1) 1a: Initiate an array offsets with length len(s)+1. \\n                        #      1b: Iterate through shifts and collect the endpts and the direction\\n                        #          of each shift. (Note that 2*(0)-1 = -1 and 2*(1)-1 = 1.)\\n                        #      1c: Accumulate the elements in offsets to determine the cummulative\\n                        #          offset for each char in s\\n                        # \\n                        #   2) 2a: Write the letter index (1-26) of each char of s to a list chNums. \\n                        #      2b: Add to each letter index its corresponding offset and determine \\n                        #          its new letter index by applying %26.\\n                        #      2c: Return the result string from chNums. \\n\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n\\n        offsets = [0]*(n+1)                                     # <-- 1a\\n\\t\\t\\n        for start, end, direction in shifts:                    # <-- 1b\\n            offsets[start]+= 2*direction-1\\n            offsets[end+1]-= 2*direction-1\\n\\t\\t\\t\\n        offsets = accumulate(offsets)                           # <-- 1c\\n\\n        chNums = (ord(ch)-97 for ch in s)                       # <-- 2a\\n\\t\\t\\n        chNums = ((chNum + offset)%26 for chNum,                # <-- 2b\\n                   offset in zip(chNums, offsets))\\n\\n        return \\'\\'.join(chr(chNum+97) for chNum in chNums)       # <-- 2c",
                "codeTag": "Java"
            },
            {
                "id": 2454172,
                "title": "range-update-java",
                "content": "\\n    class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n=s.length();\\n        int arr[]=new int[n];\\n        int diff[]=new int[n+1];\\n        //doing it for update\\n        for(int i=0;i<n;i++){\\n            arr[i]=s.charAt(i)-\\'a\\';\\n        }\\n        //creating the diff array for l-r range update\\n        diff[0]=arr[0];\\n        for(int i=1;i<n;i++){\\n            diff[i]=arr[i]-arr[i-1];\\n        }\\n        for(int p[]:shifts){\\n            int u=p[0];\\n            int v=p[1];\\n            int w=p[2];\\n            //doing the range update\\n            if(w==0){\\n                diff[u]+=(-1);\\n                diff[v+1]-=(-1);\\n            }\\n            else{\\n                diff[u]+=1;\\n                diff[v+1]-=1;\\n            }\\n        }\\n        //updating the array \\n        for(int i=0;i<n;i++){\\n            if(i==0)\\n                arr[i]=diff[i];\\n            else\\n                arr[i]=diff[i]+arr[i-1];  \\n        }\\n        String str=\"\";\\n        for(int i=0;i<n;i++){\\n            //handling the negative value of arr[i]\\n            if(arr[i]<0){\\n                int c=1;\\n                while(Math.abs(arr[i])>(26*c)){\\n                    c++;\\n                }\\n                int temp=26*c;\\n                arr[i]+=temp;\\n            }\\n            //converting into string\\n            str+=(char)((arr[i]%26)+97);\\n        }\\n        return str;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n=s.length();\\n        int arr[]=new int[n];\\n        int diff[]=new int[n+1];\\n        //doing it for update\\n        for(int i=0;i<n;i++){\\n            arr[i]=s.charAt(i)-\\'a\\';\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2454260,
                "title": "prefix-sum",
                "content": "**Please Upvote If you got it : )**\\nWe will use prefix sum concept in this problem:\\n\\nWe will perform total three passes:\\n1) In first pass we traverse shifts vector: we will put value in vector,\\n      if(shifts[i][2]==1), then do +=1 at shifts[i][0] index & -=1 at shifts[i][0]+1 index of vector(prefixsum)\\n      else ,do -=1 at shifts[i][0] index & +=1 at shifts[i][0]+1 index of vector(prefixsum)\\n\\n2) In second pass we traverse vector and do prefixsum to find displacement of character at index i\\n\\n3) In third pass we traverse string and shift the character ((s[i]-\\'a\\')+vec[i])%26 places from \\'a\\'\\n   \\n\\n**Time Complexity: 3xO(n)\\nSpaceComplexity: O(n)**\\n\\n**Code:**\\n```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> vec(n+1,0);\\n        // to fill vec\\n        for(auto &v: shifts){\\n            if(v[2]==1){\\n                vec[v[0]]+=1;\\n                vec[v[1]+1]-=1;\\n            } else{\\n                vec[v[0]]-=1;\\n                vec[v[1]+1]+=1;\\n            }\\n        }\\n        // prefix sum\\n        for(int i=1;i<=n;++i){\\n            vec[i]+=vec[i-1];\\n        }\\n        // shift character\\n        for(int i=0;i<n;++i){\\n            int val=((s[i]-\\'a\\')+vec[i])%26;\\n            if(val<0) val+=26;\\n            s[i]=\\'a\\'+val;\\n        }\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> vec(n+1,0);\\n        // to fill vec\\n        for(auto &v: shifts){\\n            if(v[2]==1){\\n                vec[v[0]]+=1;\\n                vec[v[1]+1]-=1;\\n            } else{\\n                vec[v[0]]-=1;\\n                vec[v[1]+1]+=1;\\n            }\\n        }\\n        // prefix sum\\n        for(int i=1;i<=n;++i){\\n            vec[i]+=vec[i-1];\\n        }\\n        // shift character\\n        for(int i=0;i<n;++i){\\n            int val=((s[i]-\\'a\\')+vec[i])%26;\\n            if(val<0) val+=26;\\n            s[i]=\\'a\\'+val;\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455331,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>&q) {\\n        int n=s.size();\\n        vector<int>dp(n+1,0);\\n        for(auto it:q)\\n        {\\n            if(it[2]==0)\\n            {\\n                dp[it[0]]-=1;\\n                dp[it[1]+1]+=1;\\n            }\\n            else\\n            {\\n                dp[it[0]]+=1;\\n                dp[it[1]+1]-=1;\\n            }\\n            dp[it[0]]=(dp[it[0]]+26)%26;\\n            dp[it[1]]=(dp[it[1]]+26)%26;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i)\\n            {\\n                dp[i]+=dp[i-1];\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=(dp[i]+(s[i]-\\'a\\')+26)%26;\\n            s[i]=(sum+\\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>&q) {\\n        int n=s.size();\\n        vector<int>dp(n+1,0);\\n        for(auto it:q)\\n        {\\n            if(it[2]==0)\\n            {\\n                dp[it[0]]-=1;\\n                dp[it[1]+1]+=1;\\n            }\\n            else\\n            {\\n                dp[it[0]]+=1;\\n                dp[it[1]+1]-=1;\\n            }\\n            dp[it[0]]=(dp[it[0]]+26)%26;\\n            dp[it[1]]=(dp[it[1]]+26)%26;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            if(i)\\n            {\\n                dp[i]+=dp[i-1];\\n            }\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int sum=(dp[i]+(s[i]-\\'a\\')+26)%26;\\n            s[i]=(sum+\\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456336,
                "title": "c-difference-array-solution-100-time-305ms-100-space-92mb",
                "content": "This is a problem we might be tempted to solve with a brute force approach, directly changing the characters in place at each step, but a quick look at the constraints might make us desist quickly: we might get potentially `50000` `shifts` covering the whole size of `s`, which is of the same size, for a grand total of `250M` operations, which is definitely not the cheapest we can get.\\n\\nStoring the changes might be much more convenient, but again we need to think how - having an array of `s.size()` elements we update all the time would hardly be an improvement.\\n\\nGladly this problem seems to be a handbook case for the usage of a difference array!\\n\\nThe core idea of this data structure is that if we receive a change of `x` across all the values from `a` to `b` (included), we are going to do so just by writing `x` at index `a` and `-x` at index `b + 1` (cancelling the effect of the first change on `a`).\\n\\nWhen we go and read through the difference array, we will keep a running count of what changes we encountered, giving us a measure of how they are affecting the current cell. A pretty good solution when we are going to face several changes across potentially very large intervals and when we need to read the final result only once (so we can accept a linear complexity for this!).\\n\\nLet\\'s go for some quick example, for `\"abcdefgh\"`:\\n\\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t0\\t0\\t0\\t0\\t0\\t0\\t0\\t // initial values in the difference array\\n```\\n\\nThen we decide to increase by `1` all the values from `1` to `5` , so that we will have:\\n\\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t0\\t0  -1\\t0\\t // values after the first change\\n```\\n\\nNow we decide to increase by `1` all the values from `4` to `6` , so that we will have:\\n\\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t1\\t0  -1  -1\\t // values after the second change\\n```\\n\\nNext we decrease by `1` all the values from `2` to `3` , so that we will have:\\n\\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t0\\t2\\t0  -1  -1\\t // values after the third change; notice index 4 now with a value of 2 from the previous two operations\\n```\\n\\nFinally we increase by `1` all the values from `3` to `5` , so that we will have:\\n\\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t1\\t2\\t0  -2  -1\\t // values after the fourth change; notice index 7 now with a value of -2 from the first and last operations\\n```\\n\\nNow, going with a running sun as we parse our difference array, we will find that each character will have to do the following shifts:\\n\\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1   0\\t1\\t3\\t0   1   0\\t // shifts for each character\\n```\\n\\nThe remaining part of the problem is just how to handle when a character gets shifted past `\\'a\\'` or `\\'z\\'`, but that is rather trivial compared to the rest.\\n\\nNow, to put our thoughts into code, we will start declaring a few support variables, as usual:\\n* `len` will store the size of `s`;\\n* `diffArray` is where we will store our indexes, creating it with a length of `len + 1` to avoid extra logic on the `-x` mark when applied to the last cell - saving us `shifts.size()` conditional statements for the cost of a couple of bytes;\\n* `dir` will be a support variable for when we iterate `shifts`.\\n\\nWe will then set all the cells of `diffArray` to `0`, but for the last one (as we said, we do not really care and we will never really use it, just as a placeholder).\\n\\nLooping though each `shift` in `shifts`, we will:\\n* set `dir` to be `1` if `shift[2]` is also `1`, `-1` otherwise, as specified in the specs;\\n* increase our starting point `diffArray[shift[0]]` by `dir`;\\n* decrease our ending point `diffArray[shift[1] + 1]` by `dir`.\\n\\nWith `diffArray` fully populated, we can now work on `s` and, with our ongoing sum `c` initialised to `0` and for each position `i` in it, we will:\\n* set `c` to increase by `diffArray[i]` (I saw some solutions doing this with a separate pass, but since we only need to do this once, no point in storing the values and writing them down updating `diffArray` in place);\\n*  set `pos` to the value in which we would pick a character in an ideal `\"abcdefghijklmnopqrstuvwxyz\"` string, with the value equal to the original (`s[i]`), minus `\\'a\\'` (to turn it into a value in the `0 - 25` range), plus `c` (so, the final shift for this specific cell);\\n*  we will add `26` to `pos` as long as it is `< 0` to make sure it is within range;\\n*  we will subtract `26` to `pos` as long as it is `> 25` to make sure it is within range - notice that this way our solution has only one expensive modulo operation per character \\uD83C\\uDFC6 ;\\n*  finally, we will set back the value in `s[i]` to be equal to `pos` (our adjusted `0 - 25` final value), plus `\\'a\\'` (to make sure it is again a valid lowercase ASCII character).\\n\\nOnce done, we can just `return` `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        // support variables\\n        int len = s.size(), diffArray[len + 1], dir;\\n        // populating diffArray\\n        memset(diffArray, 0, len * sizeof(int));\\n        for (auto &shift: shifts) {\\n            dir = shift[2] ? 1 : -1;\\n            diffArray[shift[0]] += dir;\\n            diffArray[shift[1] + 1] -= dir;\\n        }\\n        // populating res\\n        for (int i = 0, c = 0, pos; i < len; i++) {\\n            c += diffArray[i];\\n            pos = s[i] - \\'a\\' + c % 26;\\n            while (pos < 0) pos += 26;\\n            while (pos > 25) pos -= 26;\\n            s[i] = pos += \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "String"
                ],
                "code": "```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t0\\t0\\t0\\t0\\t0\\t0\\t0\\t // initial values in the difference array\\n```\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t0\\t0  -1\\t0\\t // values after the first change\\n```\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t1\\t0  -1  -1\\t // values after the second change\\n```\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t0\\t2\\t0  -1  -1\\t // values after the third change; notice index 4 now with a value of 2 from the previous two operations\\n```\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t1\\t2\\t0  -2  -1\\t // values after the fourth change; notice index 7 now with a value of -2 from the first and last operations\\n```\n```cpp\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1   0\\t1\\t3\\t0   1   0\\t // shifts for each character\\n```\n```cpp\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        // support variables\\n        int len = s.size(), diffArray[len + 1], dir;\\n        // populating diffArray\\n        memset(diffArray, 0, len * sizeof(int));\\n        for (auto &shift: shifts) {\\n            dir = shift[2] ? 1 : -1;\\n            diffArray[shift[0]] += dir;\\n            diffArray[shift[1] + 1] -= dir;\\n        }\\n        // populating res\\n        for (int i = 0, c = 0, pos; i < len; i++) {\\n            c += diffArray[i];\\n            pos = s[i] - \\'a\\' + c % 26;\\n            while (pos < 0) pos += 26;\\n            while (pos > 25) pos -= 26;\\n            s[i] = pos += \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454210,
                "title": "c-solution-using-prefix-array",
                "content": "```\\n class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<long long int>temp(s.length());\\n        long long int start;\\n        long long int end;\\n        long int direction;\\n        for(long long int i=0;i<shifts.size();i++){\\n            start=shifts[i][0];\\n            end=shifts[i][1];\\n            direction=shifts[i][2];\\n            int add;\\n            if(direction==0)\\n                add=-1;\\n            else\\n                add=1;\\n            temp[start]=temp[start]+add;\\n            if(end!=s.length()-1){\\n                temp[end+1]=temp[end+1]-add;\\n            }\\n        }\\n      \\n        for(long long int i=1;i<s.size();i++)\\n        {\\n           temp[i]=temp[i]+temp[i-1];\\n        }\\n        for(long long int i=0;i<s.size();i++)\\n        {\\n            s[i]=(s[i]+(temp[i]%26)-\\'a\\'+26)%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<long long int>temp(s.length());\\n        long long int start;\\n        long long int end;\\n        long int direction;\\n        for(long long int i=0;i<shifts.size();i++){\\n            start=shifts[i][0];\\n            end=shifts[i][1];\\n            direction=shifts[i][2];\\n            int add;\\n            if(direction==0)\\n                add=-1;\\n            else\\n                add=1;\\n            temp[start]=temp[start]+add;\\n            if(end!=s.length()-1){\\n                temp[end+1]=temp[end+1]-add;\\n            }\\n        }\\n      \\n        for(long long int i=1;i<s.size();i++)\\n        {\\n           temp[i]=temp[i]+temp[i-1];\\n        }\\n        for(long long int i=0;i<s.size();i++)\\n        {\\n            s[i]=(s[i]+(temp[i]%26)-\\'a\\'+26)%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454194,
                "title": "segment-tree-o-nlog-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> seg;\\n\\n    void upd(int l, int r, int v, int x, int lx, int rx) {\\n        if(lx > r or rx < l) return;\\n        if(lx >= l and rx <= r) {\\n            seg[x] += v;\\n            return;\\n        }\\n        int mid = (lx + rx) / 2;\\n        upd(l, r, v, 2 * x + 1, lx, mid);\\n        upd(l, r, v, 2 * x + 2, mid + 1, rx);\\n    }\\n\\n    int query(int i, int x, int lx, int rx) {\\n        if(lx == rx) return seg[x];\\n\\n        int mid = (lx + rx) / 2;\\n\\n        if(i <= mid)\\n            return seg[x] + query(i, 2 * x + 1, lx, mid);\\n\\n        return seg[x] + query(i, 2 * x + 2, mid + 1, rx);\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        long x = 1;\\n        while(x <= s.length()) x <<= 1;\\n        seg.resize(2 * x, 0);\\n        \\n        for(int i = 0; i < shifts.size(); ++i) {\\n            int l = shifts[i][0], r = shifts[i][1], dir;\\n            if(shifts[i][2] == 0) dir = -1;\\n            else dir = 1;\\n            \\n            //add 1 to the segment if direction is 1 else add -1 to the segment\\n            upd(l, r, dir, 0, 0, x - 1); //O(log(n))\\n        }\\n        \\n        for(int i = 0; i < s.length(); ++i) {\\n            // get the total changes made to the particular character\\n            int shift = query(i, 0, 0, x - 1);\\n            int dir = (shift > 0) ? 1 : -1; // direction of the shift\\n            shift = abs(shift) % 26; \\n            // after doing 26 shifts we come back at the same position \\n            //so instead of moving the character linearly get the exact location by modulo\\n            \\n            shift *= dir;\\n            int cur = s[i] - \\'a\\'; // current position\\n            cur = (cur + shift + 26) % 26; // new position\\n            s[i] = char(cur + \\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> seg;\\n\\n    void upd(int l, int r, int v, int x, int lx, int rx) {\\n        if(lx > r or rx < l) return;\\n        if(lx >= l and rx <= r) {\\n            seg[x] += v;\\n            return;\\n        }\\n        int mid = (lx + rx) / 2;\\n        upd(l, r, v, 2 * x + 1, lx, mid);\\n        upd(l, r, v, 2 * x + 2, mid + 1, rx);\\n    }\\n\\n    int query(int i, int x, int lx, int rx) {\\n        if(lx == rx) return seg[x];\\n\\n        int mid = (lx + rx) / 2;\\n\\n        if(i <= mid)\\n            return seg[x] + query(i, 2 * x + 1, lx, mid);\\n\\n        return seg[x] + query(i, 2 * x + 2, mid + 1, rx);\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        long x = 1;\\n        while(x <= s.length()) x <<= 1;\\n        seg.resize(2 * x, 0);\\n        \\n        for(int i = 0; i < shifts.size(); ++i) {\\n            int l = shifts[i][0], r = shifts[i][1], dir;\\n            if(shifts[i][2] == 0) dir = -1;\\n            else dir = 1;\\n            \\n            //add 1 to the segment if direction is 1 else add -1 to the segment\\n            upd(l, r, dir, 0, 0, x - 1); //O(log(n))\\n        }\\n        \\n        for(int i = 0; i < s.length(); ++i) {\\n            // get the total changes made to the particular character\\n            int shift = query(i, 0, 0, x - 1);\\n            int dir = (shift > 0) ? 1 : -1; // direction of the shift\\n            shift = abs(shift) % 26; \\n            // after doing 26 shifts we come back at the same position \\n            //so instead of moving the character linearly get the exact location by modulo\\n            \\n            shift *= dir;\\n            int cur = s[i] - \\'a\\'; // current position\\n            cur = (cur + shift + 26) % 26; // new position\\n            s[i] = char(cur + \\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3494034,
                "title": "python-3-sweep-line-difference-array",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        d = [0 for _ in range(n + 1)]\\n        for start, end, direction in shifts:\\n            dir = 1 if direction else -1\\n            d[start] += dir\\n            d[end + 1] -= dir\\n        \\n        res = []\\n        for i in range(n):\\n            if i != 0: \\n                d[i] += d[i - 1]\\n            new_chr_ascii = (ord(s[i]) - ord(\"a\") + d[i]) % 26 + ord(\"a\")\\n            res.append(chr(new_chr_ascii))\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        d = [0 for _ in range(n + 1)]\\n        for start, end, direction in shifts:\\n            dir = 1 if direction else -1\\n            d[start] += dir\\n            d[end + 1] -= dir\\n        \\n        res = []\\n        for i in range(n):\\n            if i != 0: \\n                d[i] += d[i - 1]\\n            new_chr_ascii = (ord(s[i]) - ord(\"a\") + d[i]) % 26 + ord(\"a\")\\n            res.append(chr(new_chr_ascii))\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454995,
                "title": "prefix-sum-and-range-query-python-explanation-o-n",
                "content": "**Explanation**\\nFor a given shift i.e., start, end, direction, we need to shift all ```s[i]``` where ```start<=i<=end```. In other words, we shift ```s[i]``` beginning from ```i=start``` and stop the shifting operation at ```i=end+1```.\\n\\nSo, we create an array ```pos``` that stores the shift operations by marking ```pos[start]``` and ```pos[end+1]```\\n* for ```shift = [start, end, forward_shift]```\\n ```pos[start] += 1```\\n ```pos[end+1] -= 1```\\n \\n* for ```shift = [start, end, backward_shift]```\\n```pos[start] -= 1```\\n```pos[end+1] += 1```\\n\\n\\n**Example**\\n**Given**, ```shifts = [[0,1,0],[1,2,1],[0,2,1]]```\\n**Initially**, ```pos = [0, 0, 0 ,0]```\\n* After accounting  for ```shift=[0, 1, 0]```,  ``` pos = [-1, 0, 1, 0]```\\n* After accounting  for ```shift=[1,2,1]```,  ``` pos =[-1, 1, 1, -1]```\\n* After accounting  for ```shift=[0,2,1]```,  ``` pos = [0, 1, 1, -2]```\\n**Finally**, ```pos = [0, 1, 1, -2]```\\n\\nThe **net shift** of ```s[i]``` = prefix sum of ```pos[i]``` = ```pos[0]+pos[1]+pos[2]+....+pos[i]```\\n\\n\\n**Note:** The ```len(pos)=len(s)+1``` as we mark ```pos[end+1]``` to denote the end of a shift operation.\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        pos = [0 for i in range(len(s)+1)] # to store the shift value\\n        for start, end, direction in shifts:\\n            if direction: # increase all chars in s[start:end+1] by 1\\n                pos[start] += 1  # marks the position from which increment starts\\n                pos[end+1] -= 1 # marks the position where the increment stops\\n            else: # decrease all chars in s[start:end+1] by 1\\n                pos[start] -= 1 # marks the position where decrement starts\\n                pos[end+1] += 1 # marks the position where the decrement stops\\n        cur = 0 # for index i, cur = the net increase or decrease of s[i]\\n\\t\\tres = \"\"\\n        for i in range(len(s)):\\n            cur += pos[i]\\n            res += chr((cur+ord(s[i])-97)%26 + 97)\\n        return res\\n```\\n\\n**Time Complexity** = **O(n)**, where n=s.length or shifts.length\\n**Space Complexity** = **O(n)**, where n = s.length",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```s[i]```\n```start<=i<=end```\n```s[i]```\n```i=start```\n```i=end+1```\n```pos```\n```pos[start]```\n```pos[end+1]```\n```shift = [start, end, forward_shift]```\n```pos[start] += 1```\n```pos[end+1] -= 1```\n```shift = [start, end, backward_shift]```\n```pos[start] -= 1```\n```pos[end+1] += 1```\n```shifts = [[0,1,0],[1,2,1],[0,2,1]]```\n```pos = [0, 0, 0 ,0]```\n```shift=[0, 1, 0]```\n``` pos = [-1, 0, 1, 0]```\n```shift=[1,2,1]```\n``` pos =[-1, 1, 1, -1]```\n```shift=[0,2,1]```\n``` pos = [0, 1, 1, -2]```\n```pos = [0, 1, 1, -2]```\n```s[i]```\n```pos[i]```\n```pos[0]+pos[1]+pos[2]+....+pos[i]```\n```len(pos)=len(s)+1```\n```pos[end+1]```\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        pos = [0 for i in range(len(s)+1)] # to store the shift value\\n        for start, end, direction in shifts:\\n            if direction: # increase all chars in s[start:end+1] by 1\\n                pos[start] += 1  # marks the position from which increment starts\\n                pos[end+1] -= 1 # marks the position where the increment stops\\n            else: # decrease all chars in s[start:end+1] by 1\\n                pos[start] -= 1 # marks the position where decrement starts\\n                pos[end+1] += 1 # marks the position where the decrement stops\\n        cur = 0 # for index i, cur = the net increase or decrease of s[i]\\n\\t\\tres = \"\"\\n        for i in range(len(s)):\\n            cur += pos[i]\\n            res += chr((cur+ord(s[i])-97)%26 + 97)\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475078,
                "title": "easy-understanding-prefix-sum-approach-detailed-aprroach-o-n-c-faster",
                "content": "In Brute force approach , we are traversing left to right and performing operation for each ith shift. So, to optimise the brute force approach , Instead of iterating through the range, we can add a +1 if we are moving forward in the beginning of the range and -1 in the end of the range to make sure we are no longer applying the change. The same thing goes for the backward direction with the -1 at the beginning and +1 at the end.\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        vector<int> offsets(n+1);\\n        \\n        for (auto i : shifts) {\\n            int direction = i[2];\\n            \\n            offsets[i[0]] += (direction == 1)? 1: -1;\\n            offsets[i[1]+1] -= (direction == 1)? 1: -1;\\n        }\\n        \\n        int prefix = 0;\\n        string result = \"\";\\n        \\n        for (int j = 0; j < n; j ++) {\\n            prefix += offsets[j];\\n            while (prefix < 0) prefix += 26;\\n            \\n            int ch = (s[j] - \\'a\\' + prefix) % 26;\\n            result += (char)(\\'a\\' + ch);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        vector<int> offsets(n+1);\\n        \\n        for (auto i : shifts) {\\n            int direction = i[2];\\n            \\n            offsets[i[0]] += (direction == 1)? 1: -1;\\n            offsets[i[1]+1] -= (direction == 1)? 1: -1;\\n        }\\n        \\n        int prefix = 0;\\n        string result = \"\";\\n        \\n        for (int j = 0; j < n; j ++) {\\n            prefix += offsets[j];\\n            while (prefix < 0) prefix += 26;\\n            \\n            int ch = (s[j] - \\'a\\' + prefix) % 26;\\n            result += (char)(\\'a\\' + ch);\\n        }\\n        \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463201,
                "title": "shifting-letters-2-prefix-sum-method",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n        int n=s.size();\\n        vector <int> precalc(n+1);\\n        \\n        for(int i=0; i<shifts.size(); i++)\\n        {\\n            if(shifts[i][2]==0)\\n            {\\n                precalc[shifts[i][0]]--;\\n                precalc[shifts[i][1]+1]++;\\n            }\\n            else\\n            {\\n                precalc[shifts[i][0]]++;\\n                precalc[shifts[i][1]+1]--;\\n            }\\n        }\\n        \\n        for(int i=1; i<=n; i++)\\n        {\\n            precalc[i-1]=precalc[i-1]%26;\\n            precalc[i]=precalc[i]+precalc[i-1];\\n            precalc[i]=precalc[i]%26;\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int t=s[i]-\\'a\\';\\n            t=t+precalc[i];\\n            if(t>25)\\n                t=t%26;\\n            else if(t<0)\\n                t=26+t;\\n            s[i]=t+\\'a\\';\\n        }\\n        \\n        return s;\\n    }\\n};\\n```\\nNow try doing: https://leetcode.com/problems/describe-the-painting/discuss/2463197/Just-like-Shifting-Letters-2.-Prefix-Sum-Trick.-Commented-Code",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n        int n=s.size();\\n        vector <int> precalc(n+1);\\n        \\n        for(int i=0; i<shifts.size(); i++)\\n        {\\n            if(shifts[i][2]==0)\\n            {\\n                precalc[shifts[i][0]]--;\\n                precalc[shifts[i][1]+1]++;\\n            }\\n            else\\n            {\\n                precalc[shifts[i][0]]++;\\n                precalc[shifts[i][1]+1]--;\\n            }\\n        }\\n        \\n        for(int i=1; i<=n; i++)\\n        {\\n            precalc[i-1]=precalc[i-1]%26;\\n            precalc[i]=precalc[i]+precalc[i-1];\\n            precalc[i]=precalc[i]%26;\\n        }\\n        \\n        for(int i=0; i<n; i++)\\n        {\\n            int t=s[i]-\\'a\\';\\n            t=t+precalc[i];\\n            if(t>25)\\n                t=t%26;\\n            else if(t<0)\\n                t=26+t;\\n            s[i]=t+\\'a\\';\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458572,
                "title": "segment-tree-lazy-propagation-o-n-log-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    void  update(vector < long long > &segtree, vector < long long > &lazy, long long ind, long long low, long long high, long long l , long long r, long long val){\\n        \\n        if(lazy[ind] != 0){\\n            \\n            segtree[ind] += (high - low + 1) * lazy[ind];\\n            if(low != high){\\n                lazy[2 * ind + 1] += lazy[ind];\\n                lazy[2 * ind + 2] += lazy[ind];\\n            }\\n            lazy[ind] = 0;\\n        }\\n        \\n        if(r < low || l > high || low > high) return;\\n        \\n        if(low >= l && high <= r){\\n            segtree[ind] += (high - low + 1) * val;\\n            if(low != high){\\n                lazy[2 * ind + 1] += val;\\n                lazy[2 * ind + 2] += val;\\n            }\\n            \\n            return;\\n        }\\n        \\n        int mid = low + (high  - low) / 2;\\n        \\n        update(segtree, lazy , 2 * ind + 1, low, mid, l , r, val);\\n        update(segtree, lazy , 2 * ind + 2, mid + 1, high, l , r, val);\\n        segtree[ind] = segtree[2 * ind + 1] + segtree[2 * ind + 2];\\n    \\n    }\\n    \\n    long long get(vector < long long > &segtree, vector < long long > &lazy, long long ind, long long low, long long high, long long l , long long r, long long val){\\n        \\n        if(lazy[ind] != 0){\\n            \\n            segtree[ind] += (high - low + 1) * lazy[ind];\\n            if(low != high){\\n                lazy[2 * ind + 1] += lazy[ind];\\n                lazy[2 * ind + 2] += lazy[ind];\\n            }\\n            lazy[ind] = 0;\\n        }\\n        \\n        if(r < low || l > high || low > high) return 0;\\n        \\n        if(low >= l && high <= r){\\n        \\n            return segtree[ind];\\n            \\n        }\\n        \\n        int mid = low + (high  - low) / 2;\\n        \\n        return get(segtree, lazy , 2 * ind + 1, low, mid, l , r, val) + \\n        get(segtree, lazy , 2 * ind + 2, mid + 1, high, l , r, val);\\n        \\n        \\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n = s.size();\\n        \\n        vector < long long > segtree(4 * n,0);\\n        vector < long long > lazy(4 * n,0);\\n        \\n        for(int i = 0; i < shifts.size(); i++){\\n            long long val = shifts[i][2] == 1 ? 1 : -1;\\n            \\n            update(segtree,lazy,0,0, n - 1, shifts[i][0],shifts[i][1],val);\\n        \\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            long long x = get(segtree,lazy,0,0, n - 1,i,i,0);\\n            \\n            long long y = s[i] - \\'a\\';\\n            \\n            long long z = y + x;\\n            \\n            if(z < 0 ) {\\n              z = -z;\\n              z = (z % 26);\\n              if(z != 0)\\n                z = -z + 26; \\n                \\n            }\\n            else z = z % 26;\\n            \\n            s[i] = (char)(z + 97);\\n            \\n                \\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void  update(vector < long long > &segtree, vector < long long > &lazy, long long ind, long long low, long long high, long long l , long long r, long long val){\\n        \\n        if(lazy[ind] != 0){\\n            \\n            segtree[ind] += (high - low + 1) * lazy[ind];\\n            if(low != high){\\n                lazy[2 * ind + 1] += lazy[ind];\\n                lazy[2 * ind + 2] += lazy[ind];\\n            }\\n            lazy[ind] = 0;\\n        }\\n        \\n        if(r < low || l > high || low > high) return;\\n        \\n        if(low >= l && high <= r){\\n            segtree[ind] += (high - low + 1) * val;\\n            if(low != high){\\n                lazy[2 * ind + 1] += val;\\n                lazy[2 * ind + 2] += val;\\n            }\\n            \\n            return;\\n        }\\n        \\n        int mid = low + (high  - low) / 2;\\n        \\n        update(segtree, lazy , 2 * ind + 1, low, mid, l , r, val);\\n        update(segtree, lazy , 2 * ind + 2, mid + 1, high, l , r, val);\\n        segtree[ind] = segtree[2 * ind + 1] + segtree[2 * ind + 2];\\n    \\n    }\\n    \\n    long long get(vector < long long > &segtree, vector < long long > &lazy, long long ind, long long low, long long high, long long l , long long r, long long val){\\n        \\n        if(lazy[ind] != 0){\\n            \\n            segtree[ind] += (high - low + 1) * lazy[ind];\\n            if(low != high){\\n                lazy[2 * ind + 1] += lazy[ind];\\n                lazy[2 * ind + 2] += lazy[ind];\\n            }\\n            lazy[ind] = 0;\\n        }\\n        \\n        if(r < low || l > high || low > high) return 0;\\n        \\n        if(low >= l && high <= r){\\n        \\n            return segtree[ind];\\n            \\n        }\\n        \\n        int mid = low + (high  - low) / 2;\\n        \\n        return get(segtree, lazy , 2 * ind + 1, low, mid, l , r, val) + \\n        get(segtree, lazy , 2 * ind + 2, mid + 1, high, l , r, val);\\n        \\n        \\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n = s.size();\\n        \\n        vector < long long > segtree(4 * n,0);\\n        vector < long long > lazy(4 * n,0);\\n        \\n        for(int i = 0; i < shifts.size(); i++){\\n            long long val = shifts[i][2] == 1 ? 1 : -1;\\n            \\n            update(segtree,lazy,0,0, n - 1, shifts[i][0],shifts[i][1],val);\\n        \\n        }\\n        \\n        for(int i = 0; i < n; i++){\\n            \\n            long long x = get(segtree,lazy,0,0, n - 1,i,i,0);\\n            \\n            long long y = s[i] - \\'a\\';\\n            \\n            long long z = y + x;\\n            \\n            if(z < 0 ) {\\n              z = -z;\\n              z = (z % 26);\\n              if(z != 0)\\n                z = -z + 26; \\n                \\n            }\\n            else z = z % 26;\\n            \\n            s[i] = (char)(z + 97);\\n            \\n                \\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455055,
                "title": "easiest-solution-practice-this-type-of-question-becoming-common",
                "content": "Comment for explanation:-\\nIf you find it helpful upvote\\n\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> sum(n+1, 0);\\n        for(int i = 0; i<shifts.size(); i++){\\n            int x = shifts[i][0], y = shifts[i][1]+1;\\n            int dir = shifts[i][2];\\n            if(dir == 1){\\n                sum[x] +=1;\\n                sum[y] -= 1;\\n            }\\n            else{\\n                sum[x] -=1;\\n                sum[y] +=1;\\n            }\\n        }\\n        for(int i = 1; i<=n; i++){\\n            sum[i] += sum[i-1];\\n        }\\n        for(int i = 0; i<n; i++){\\n            int a = sum[i];\\n            if(a<0){\\n                int b = abs(a)%26;\\n                a = s[i]-\\'a\\'+26-b;\\n                s[i] = \\'a\\'+a%26;\\n            }   \\n            else{\\n                a += s[i]-\\'a\\';\\n                s[i] = \\'a\\' + a%26;\\n            }\\n        }\\n        return s;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> sum(n+1, 0);\\n        for(int i = 0; i<shifts.size(); i++){\\n            int x = shifts[i][0], y = shifts[i][1]+1;\\n            int dir = shifts[i][2];\\n            if(dir == 1){\\n                sum[x] +=1;\\n                sum[y] -= 1;\\n            }\\n            else{\\n                sum[x] -=1;\\n                sum[y] +=1;\\n            }\\n        }\\n        for(int i = 1; i<=n; i++){\\n            sum[i] += sum[i-1];\\n        }\\n        for(int i = 0; i<n; i++){\\n            int a = sum[i];\\n            if(a<0){\\n                int b = abs(a)%26;\\n                a = s[i]-\\'a\\'+26-b;\\n                s[i] = \\'a\\'+a%26;\\n            }   \\n            else{\\n                a += s[i]-\\'a\\';\\n                s[i] = \\'a\\' + a%26;\\n            }\\n        }\\n        return s;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454949,
                "title": "java-ez-2-understand",
                "content": "for more details refer 2\\nhttps://iq.opengenus.org/multiple-array-range-increments-linear-time/\\n```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char arr[]=s.toCharArray();\\n        int n=s.length();\\n        int diff[]=new int[n+1];\\n        for(int shift[]:shifts){\\n            int a=shift[0];\\n            int b=shift[1];\\n            int d=shift[2]==1?1:-1;\\n            diff[a]+=d;\\n            diff[b+1]-=d;\\n        }\\n        diff[0]%=26;\\n        for(int i=1;i<n+1;i++){\\n            diff[i]+=diff[i-1];\\n            diff[i]%=26;\\n        }\\n        for(int i=0;i<n;i++){\\n            int ind=arr[i]+diff[i];\\n            if(ind<97)\\n                ind+=26;\\n            if(ind>122)\\n                ind-=26;\\n            arr[i]=(char)ind;\\n        }\\n        return new String(arr);\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char arr[]=s.toCharArray();\\n        int n=s.length();\\n        int diff[]=new int[n+1];\\n        for(int shift[]:shifts){\\n            int a=shift[0];\\n            int b=shift[1];\\n            int d=shift[2]==1?1:-1;\\n            diff[a]+=d;\\n            diff[b+1]-=d;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2454760,
                "title": "c-line-sweep-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& ranges) {\\n        unordered_map<char, int> mp;\\n        string abcd = \"abcdefghijklmnopqrstuvwxyz\";\\n        for(int i=0;i<26;i++){\\n            mp[i] = abcd[i];\\n        }\\n        int seen[50001] = {0};\\n        for(auto r : ranges) {\\n            int dir = r[2] ? 1:-1;\\n            seen[r[0]]+=dir; seen[r[1] + 1]-=dir;\\n        }\\n           \\n        for(int i = 0, prev=0; i < 50001; i++){\\n            seen[i] += prev;\\n            prev = seen[i];\\n        }\\n        for(int i=0;i<s.size();i++){\\n            int temp = s[i] - \\'a\\';\\n            temp = (temp + (seen[i]%26) + 26)%26;\\n            s[i] = mp[temp];\\n        }\\n     \\n        return s;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& ranges) {\\n        unordered_map<char, int> mp;\\n        string abcd = \"abcdefghijklmnopqrstuvwxyz\";\\n        for(int i=0;i<26;i++){\\n            mp[i] = abcd[i];\\n        }\\n        int seen[50001] = {0};\\n        for(auto r : ranges) {\\n            int dir = r[2] ? 1:-1;\\n            seen[r[0]]+=dir; seen[r[1] + 1]-=dir;\\n        }\\n           \\n        for(int i = 0, prev=0; i < 50001; i++){\\n            seen[i] += prev;\\n            prev = seen[i];\\n        }\\n        for(int i=0;i<s.size();i++){\\n            int temp = s[i] - \\'a\\';\\n            temp = (temp + (seen[i]%26) + 26)%26;\\n            s[i] = mp[temp];\\n        }\\n     \\n        return s;\\n    }\\n};\\n\\n// if you liked the solution then please upvote it so that it can reach to more people \\n// If you have any doubt or want to discuss any thing related to solution please leave a comment, so that all of the viewers can discuss it\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454332,
                "title": "python-shifts",
                "content": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def shift(self, c, k):\\n        return chr(ord(\\'a\\') + (26 + ord(c) - ord(\\'a\\') + k) % 26)\\n    \\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        freq = defaultdict(int)\\n        for l, r, d in shifts:\\n            d = 2 * d - 1\\n            freq[l] += d\\n            freq[r + 1] -= d\\n        for i in range(1, n + 1):\\n            freq[i] += freq[i - 1]\\n        return \"\".join([self.shift(s[i], freq[i]) for i in range(n)])\\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def shift(self, c, k):\\n        return chr(ord(\\'a\\') + (26 + ord(c) - ord(\\'a\\') + k) % 26)\\n    \\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        freq = defaultdict(int)\\n        for l, r, d in shifts:\\n            d = 2 * d - 1\\n            freq[l] += d\\n            freq[r + 1] -= d\\n        for i in range(1, n + 1):\\n            freq[i] += freq[i - 1]\\n        return \"\".join([self.shift(s[i], freq[i]) for i in range(n)])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291122,
                "title": "easy-prefix-sum-approach-two-approach",
                "content": "**INTUITION :**\\nWe have to increase/decrease every character by one if lying in the given range.\\n\\n# **First Approach (NAIVE TLE) :**\\nThe naive approach would be for evey shift[i] run a loop from shift[i][0] to shift[i][1] and increment or decrement depending upon shift[i][2].\\nThis is a possible solution but give TLE as per the given constraints.\\n\\n**CODE** *(TLE)*\\n```\\nchar shiftBack(char ch)  //Shift Forword\\n    {\\n        if(ch==\\'a\\')\\n            return \\'z\\';\\n        return char(int(ch) - 1);\\n    }\\n    \\n    char shiftFor(char ch)\\n    {\\n        if(ch==\\'z\\')\\n            return \\'a\\';\\n        return char(int(ch) + 1);\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        for(auto ele:shifts)\\n        {\\n            int from = ele[0];\\n            int to = ele[1];\\n            int dir = ele[2];\\n            if(dir==0)\\n            {\\n                for(int i=from;i<=to;i++)\\n                {\\n                    s[i]=shiftBack(s[i]);\\n                }\\n            }\\n            else\\n            {\\n                for(int i=from;i<=to;i++)\\n                {\\n                    s[i]=shiftFor(s[i]);\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n```\\n\\n# **Second Approach (Accepted Sol.)**\\n\\nHere in this Approach we are going to use is ***PREFIX SUM***.\\ncreate a vector of integers (say v) assigh 0 to it,\\nFor every shift   \\n*if shift[i][0] is 1*:\\n* \\tIncrease v[shift[i][0]] by 1 and if shift[i][0]+1 is within the range then decrese v[shift[i][0]+1] by 1\\n\\nif shift[i][0] is 0:\\n* \\tdecrease v[shift[i][0]] by 1 and if shift[i][0]+1 is within the range then increase v[shift[i][0]+1] by 1\\n\\n**Then calculate prefix sum in a differnet array (say psum) of v and for every index increment the character at that index by psum[i].**\\n\\n**CODE**(Accepted Sol.)\\n```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int>v(s.length(),0);\\n        \\n        for(auto ele:shifts)\\n        {\\n            int from = ele[0];\\n            int to = ele[1];\\n            int dir = ele[2];\\n            if(dir==0)\\n            {\\n                v[from]--;\\n                if(to+1<v.size())\\n                {\\n                    v[to+1]++;\\n                }\\n            }\\n            else\\n            {\\n                v[from]++;\\n                if(to+1<v.size())\\n                {\\n                    v[to+1]--;\\n                }\\n            }\\n        }\\n        vector<int>psum(v.size(),0);\\n        psum[0]=v[0];\\n        for(int i=1;i<v.size();i++)\\n        {\\n            psum[i]=v[i]+psum[i-1];\\n        }\\n        \\n        for(int i=0;i<psum.size();i++)\\n        {\\n            char res;\\n            int ele = psum[i];\\n            int n=s[i];\\n            ele=ele%26;\\n            if(ele>=0)\\n            {\\n                res = char( (n%97 + ele)%26 + 97);\\n            }\\n            else\\n            {\\n                ele = 26-abs(ele);\\n                res = char( (n%97 + ele)%26 + 97);\\n            }\\n            s[i]=res;\\n        }\\n        return s;\\n    }\\n```\\n\\n***TC: O(N)\\nSC: O(N)***\\n\\n![image](https://assets.leetcode.com/users/images/f25f5a63-0b86-48b9-958a-0e189cadd307_1678691732.0941956.jpeg)\\n\\n\\n\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nchar shiftBack(char ch)  //Shift Forword\\n    {\\n        if(ch==\\'a\\')\\n            return \\'z\\';\\n        return char(int(ch) - 1);\\n    }\\n    \\n    char shiftFor(char ch)\\n    {\\n        if(ch==\\'z\\')\\n            return \\'a\\';\\n        return char(int(ch) + 1);\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        for(auto ele:shifts)\\n        {\\n            int from = ele[0];\\n            int to = ele[1];\\n            int dir = ele[2];\\n            if(dir==0)\\n            {\\n                for(int i=from;i<=to;i++)\\n                {\\n                    s[i]=shiftBack(s[i]);\\n                }\\n            }\\n            else\\n            {\\n                for(int i=from;i<=to;i++)\\n                {\\n                    s[i]=shiftFor(s[i]);\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n```\n```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int>v(s.length(),0);\\n        \\n        for(auto ele:shifts)\\n        {\\n            int from = ele[0];\\n            int to = ele[1];\\n            int dir = ele[2];\\n            if(dir==0)\\n            {\\n                v[from]--;\\n                if(to+1<v.size())\\n                {\\n                    v[to+1]++;\\n                }\\n            }\\n            else\\n            {\\n                v[from]++;\\n                if(to+1<v.size())\\n                {\\n                    v[to+1]--;\\n                }\\n            }\\n        }\\n        vector<int>psum(v.size(),0);\\n        psum[0]=v[0];\\n        for(int i=1;i<v.size();i++)\\n        {\\n            psum[i]=v[i]+psum[i-1];\\n        }\\n        \\n        for(int i=0;i<psum.size();i++)\\n        {\\n            char res;\\n            int ele = psum[i];\\n            int n=s[i];\\n            ele=ele%26;\\n            if(ele>=0)\\n            {\\n                res = char( (n%97 + ele)%26 + 97);\\n            }\\n            else\\n            {\\n                ele = 26-abs(ele);\\n                res = char( (n%97 + ele)%26 + 97);\\n            }\\n            s[i]=res;\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3163358,
                "title": "prefix-sum-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        vector<int>v1(n+1);\\n        for(auto it:shifts){\\n            int from=it[0],to=it[1],move=it[2];\\n            if(move==0){\\n                v1[from]-=1;v1[to+1]+=1;\\n            }else{\\n                v1[from]+=1;v1[to+1]-=1;\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            v1[i]+=v1[i-1];\\n        }\\n        string ans;\\n        for(int i=0;i<n;i++){\\n            int a=s[i]-\\'a\\';\\n            if(a+v1[i]>=0){\\n                ans.push_back(\\'a\\'+((a+v1[i])%26));\\n            }else{\\n                if((a+v1[i])%26==0){\\n                    ans.push_back(\\'a\\'+((a+v1[i])%26));\\n                }\\n                else{ans.push_back(\\'a\\'+((a+v1[i])%26)+26);}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        vector<int>v1(n+1);\\n        for(auto it:shifts){\\n            int from=it[0],to=it[1],move=it[2];\\n            if(move==0){\\n                v1[from]-=1;v1[to+1]+=1;\\n            }else{\\n                v1[from]+=1;v1[to+1]-=1;\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            v1[i]+=v1[i-1];\\n        }\\n        string ans;\\n        for(int i=0;i<n;i++){\\n            int a=s[i]-\\'a\\';\\n            if(a+v1[i]>=0){\\n                ans.push_back(\\'a\\'+((a+v1[i])%26));\\n            }else{\\n                if((a+v1[i])%26==0){\\n                    ans.push_back(\\'a\\'+((a+v1[i])%26));\\n                }\\n                else{ans.push_back(\\'a\\'+((a+v1[i])%26)+26);}\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2816587,
                "title": "java-entire-thought-process-working-explained-commented",
                "content": "**I\\'m damn sure, If you read then you\\'ll learn some new insights**\\n**Must read in order to learn, Clean Code at the end of commented one otherwise**\\n\\n```\\n/*\\n    Learning Factor\\n    ---------------\\n        + Whenever you encountered such a question in which interval(s) is involved/\\n            something similar to that/can be converted a problem into the interval\\n            type problem.\\n                - and the operations(addition in a range/updation by value/subtraction\\n                by value/something similar kind) is/are needs to be done in \\n                for each interval and then at the end we\\'ve to return the final\\n                state of something(updated array/updated string/final updated sums).\\n                \\n                - to know whether two/more line segments are intersection or NOT/\\n                    overlapping to each other(how-many parallel events are going on)\\n                    \\n                for such above type of requirement(s), you MUST use this technique\\n                or at least you should go for it.\\n                \\n     \\n     NOTE: Instead doing the given operation(s) for each interval naively, accumulate\\n            the operation(s)(count of type operations) for each number by \\n            considering all the given intervals and perform the operation(s) exactly \\n            once to accumulated number of times.\\n     \\n    \\n    Let\\'s how it works\\n    ------------------\\n        \\n        Let\\'s say we\\'ve an array of size n, intially filled with zeros.\\n        Your goal is to increament each indices in b/w [start, end] (inclusive)\\n        by 1 for each given list of intervals & return the final state of the array.\\n        \\n        arr = [0, 0, 0, 0, 0, 0, 0], intervals = [[3, 4], [0, 4], [1, 2]]\\n        \\n        \\n        Let\\'s update the given array naively for interval [3, 4]\\n        -------------- -------------- -------------- ------------------ \\n        \\n        arr = [0, 0, 0, 1, 1, 0, 0], \\n            \\n           number -> increament_count(accumulated operation count)\\n                3 -> 1\\n                4 -> 1\\n        \\n        \\n       for interval [0, 4]\\n       -------------------- \\n        \\n        arr = [1, 1, 1, 2, 2, 0, 0], \\n            \\n           number -> increament_count(accumulated operation count)\\n                0 -> 1\\n                1 -> 1\\n                2 -> 1\\n                3 -> 2\\n                4 -> 2\\n        \\n       for interval [1, 22\\n       -------------------- \\n        \\n        arr = [1, 2, 2, 2, 2, 0, 0], \\n        \\n        Table:\\n        ------\\n            \\n           number -> increament_count(accumulated operation count)\\n                0 -> 1\\n                1 -> 2\\n                2 -> 2\\n                3 -> 2\\n                4 -> 2\\n        \\n       \\n       Time Complexity of Naive approach: O(interval_cnt * len(arr))\\n                                            + in the worst case, [start, end]\\n                                                can always be [0, len(arr) - 1]\\n       \\n       NOTE: If we look at the table carefully, we\\'ll found that each value\\n                corresponding to an index \\'i\\' is nothing but telling that\\n                how many in total index \\'i\\' is updated/increamented.\\n        \\n              If we somehow able to know that count for each index \\'i\\' then we can\\n              go to that index and assign the count at once. Instead going to \\'i\\'\\n              for each interval and updating it.\\n                    + this will improve our time complexity drastically.\\n      \\n      Now, let\\'s see the same result by our technique\\n      -----------------------------------------------\\n      \\n        arr = [0, 0, 0, 0, 0, 0, 0], intervals = [[3, 4], [0, 4], [1, 2]]\\n        \\n        \\n        For interval [3, 4]\\n        --------------------\\n        \\n        naive = [0, 0, 0, 1, 1, 0, 0]\\n        \\n        table = [0, 0, 0, 1, 0, -1, 0, 0] --> created (len(arr) + 1) size, omittable\\n                          ^      ^\\n                          |      |\\n                        +1 here  -1 here\\n                    at index \\'3\\'  at index \\'4 + 1 = 5\\'\\n            \\n        if we do prefix sum of \\'talbe\\' array then we would get:\\n        \\n        psum = [0, 0, 0, 1, 1, 0, 0, 0]   --> exact same as \\'naive\\' one\\n        \\n        NOTE: Adding +1 to an ith index in table array will contribute +1 to\\n                all the way starting from \\'i\\'th index to up-until the end \\'n\\'.\\n                \\n                See this for what I\\'ve said above:\\n                \\n                adding +1 to index \\'3\\'\\n                =====================\\n                                  \\n                                  1  1  1  1  1\\n                talbe = [0, 0, 0, 0, 0, 0, 0, 0]\\n                                  \\n                adding -1 to index \\'(4 + 1)\\'\\n                =====================\\n                                  \\n                                  1  1  1  1  1     -> contribution of +1\\n                                       -1 -1 -1     -> contibution of -1\\n                table = [0, 0, 0, 0, 0, 0, 0, 0]\\n                \\n                \\n                when we take the prefix sum of above talbe array:\\n                                    \\n                                  1  1  1  1  1     \\n                                       -1 -1 -1    \\n                table = [0, 0, 0, 1, 1, 0, 0, 0]\\n                                  +--+  +-----+\\n                                    ^      ^\\n                                    |      |\\n                                    |      |\\n                                    |  this part (1 + (-1) = 0) gets zero/cancelled out.\\n                                    |    \\n                           only changes made into our\\n                           required interval [3, 4]\\n                           \\n             NOTE: Subtracted -1 at index (R + 1) for given interval [L, R] (inclusive)\\n                    and added +1 at index (L).\\n                    \\n                    why not R? because \\'R\\' is inclusive. Otherwise, subtracting at (R)\\n                    is OK.\\n                    \\n                    **** Think why at (R + 1)? you know the reason. ****\\n       \\n       Similarly after we\\'ve done +1 & -1 for each interval accordingly, take the prefix\\n        sum of the table array. At the end each number corresponding to an index \\'i\\'\\n        is nothing but total number(accumulated operation count) for that index \\'i\\'.\\n       \\n*/\\n```\\n\\n```\\nImplementation\\n```\\n\\n```\\nclass Solution {\\n    \\n    private static final char[] alphabet;\\n    static {\\n        alphabet = new char[26];\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch += 1) {\\n            alphabet[ch - \\'a\\'] = ch;\\n        }\\n    }\\n    \\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n = s.length();\\n        // +1 to avoid extra check when (R + 1) is out of bound of array index.\\n        // To provide more meaningful meaning, I\\'m using 2 arrays. -> can be done in\\n        // single array as well.\\n        // forwardShift[i] -> tells total how many times the character at \\'ith\\'\\n        // index in the given string \\'s\\' is shifted in forward direction. Similar goes\\n        // to backwardShift.\\n        int[] forwardShift = new int[n + 1];\\n        int[] backwardShift = new int[n + 1];\\n        \\n        for(int i = 0; i < shifts.length; i += 1) {\\n            final int L = shifts[i][0], R = shifts[i][1], DIR = shifts[i][2];\\n            if(DIR == 1) {\\n                forwardShift[L] += 1;\\n                forwardShift[R + 1] -= 1;\\n            } else {\\n                // Updation also gets reversed when direction gets reversed.\\n                backwardShift[L] -= 1;\\n                backwardShift[R + 1] += 1;\\n            }\\n        }\\n        \\n        // building prefix sums\\n        for(int i = 1; i <= n; i += 1) {\\n            forwardShift[i] += forwardShift[i - 1];\\n            backwardShift[i] += backwardShift[i - 1];\\n        }\\n        \\n        StringBuilder shiftedFinalString = new StringBuilder();\\n        \\n        for(int i = 0; i < n; i += 1) {\\n            int totalShiftCount = forwardShift[i] + backwardShift[i];\\n            \\n            // You know the reason why?? we\\'re doing (cnt % 26 + 26) when cnt < 0\\n            if(totalShiftCount < 0) totalShiftCount = totalShiftCount % 26 + 26;\\n            int alphaPosition = s.charAt(i) - \\'a\\';\\n            \\n            // Shifting operation is performing Here (alphaPosition + totalShiftCount)\\n            char newShiftedChar = alphabet[(alphaPosition + totalShiftCount) % 26];\\n            shiftedFinalString.append(newShiftedChar);\\n        }\\n       \\n        return shiftedFinalString.toString();\\n    }\\n}\\n```\\n\\n\\n```\\nClean Code\\n```\\n\\n```\\nclass Solution {\\n    \\n    private static final char[] alphabet;\\n    static {\\n        alphabet = new char[26];\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch += 1) {\\n            alphabet[ch - \\'a\\'] = ch;\\n        }\\n    }\\n    \\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n = s.length();\\n        int[] forwardShift = new int[n + 1];\\n        int[] backwardShift = new int[n + 1];\\n        \\n        for(int i = 0; i < shifts.length; i += 1) {\\n            final int L = shifts[i][0], R = shifts[i][1], DIR = shifts[i][2];\\n            if(DIR == 1) {\\n                forwardShift[L] += 1;\\n                forwardShift[R + 1] -= 1;\\n            } else {\\n                backwardShift[L] -= 1;\\n                backwardShift[R + 1] += 1;\\n            }\\n        }\\n        \\n        for(int i = 1; i <= n; i += 1) {\\n            forwardShift[i] += forwardShift[i - 1];\\n            backwardShift[i] += backwardShift[i - 1];\\n        }\\n        \\n        StringBuilder shiftedFinalString = new StringBuilder();\\n        for(int i = 0; i < n; i += 1) {\\n            int totalShiftCount = forwardShift[i] + backwardShift[i];\\n            if(totalShiftCount < 0) \\n                totalShiftCount = totalShiftCount % 26 + 26;\\n            \\n            int alphaPosition = s.charAt(i) - \\'a\\';\\n            char newShiftedChar = alphabet[(alphaPosition + totalShiftCount) % 26];\\n            shiftedFinalString.append(newShiftedChar);\\n        }\\n       \\n        return shiftedFinalString.toString();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n    Learning Factor\\n    ---------------\\n        + Whenever you encountered such a question in which interval(s) is involved/\\n            something similar to that/can be converted a problem into the interval\\n            type problem.\\n                - and the operations(addition in a range/updation by value/subtraction\\n                by value/something similar kind) is/are needs to be done in \\n                for each interval and then at the end we\\'ve to return the final\\n                state of something(updated array/updated string/final updated sums).\\n                \\n                - to know whether two/more line segments are intersection or NOT/\\n                    overlapping to each other(how-many parallel events are going on)\\n                    \\n                for such above type of requirement(s), you MUST use this technique\\n                or at least you should go for it.\\n                \\n     \\n     NOTE: Instead doing the given operation(s) for each interval naively, accumulate\\n            the operation(s)(count of type operations) for each number by \\n            considering all the given intervals and perform the operation(s) exactly \\n            once to accumulated number of times.\\n     \\n    \\n    Let\\'s how it works\\n    ------------------\\n        \\n        Let\\'s say we\\'ve an array of size n, intially filled with zeros.\\n        Your goal is to increament each indices in b/w [start, end] (inclusive)\\n        by 1 for each given list of intervals & return the final state of the array.\\n        \\n        arr = [0, 0, 0, 0, 0, 0, 0], intervals = [[3, 4], [0, 4], [1, 2]]\\n        \\n        \\n        Let\\'s update the given array naively for interval [3, 4]\\n        -------------- -------------- -------------- ------------------ \\n        \\n        arr = [0, 0, 0, 1, 1, 0, 0], \\n            \\n           number -> increament_count(accumulated operation count)\\n                3 -> 1\\n                4 -> 1\\n        \\n        \\n       for interval [0, 4]\\n       -------------------- \\n        \\n        arr = [1, 1, 1, 2, 2, 0, 0], \\n            \\n           number -> increament_count(accumulated operation count)\\n                0 -> 1\\n                1 -> 1\\n                2 -> 1\\n                3 -> 2\\n                4 -> 2\\n        \\n       for interval [1, 22\\n       -------------------- \\n        \\n        arr = [1, 2, 2, 2, 2, 0, 0], \\n        \\n        Table:\\n        ------\\n            \\n           number -> increament_count(accumulated operation count)\\n                0 -> 1\\n                1 -> 2\\n                2 -> 2\\n                3 -> 2\\n                4 -> 2\\n        \\n       \\n       Time Complexity of Naive approach: O(interval_cnt * len(arr))\\n                                            + in the worst case, [start, end]\\n                                                can always be [0, len(arr) - 1]\\n       \\n       NOTE: If we look at the table carefully, we\\'ll found that each value\\n                corresponding to an index \\'i\\' is nothing but telling that\\n                how many in total index \\'i\\' is updated/increamented.\\n        \\n              If we somehow able to know that count for each index \\'i\\' then we can\\n              go to that index and assign the count at once. Instead going to \\'i\\'\\n              for each interval and updating it.\\n                    + this will improve our time complexity drastically.\\n      \\n      Now, let\\'s see the same result by our technique\\n      -----------------------------------------------\\n      \\n        arr = [0, 0, 0, 0, 0, 0, 0], intervals = [[3, 4], [0, 4], [1, 2]]\\n        \\n        \\n        For interval [3, 4]\\n        --------------------\\n        \\n        naive = [0, 0, 0, 1, 1, 0, 0]\\n        \\n        table = [0, 0, 0, 1, 0, -1, 0, 0] --> created (len(arr) + 1) size, omittable\\n                          ^      ^\\n                          |      |\\n                        +1 here  -1 here\\n                    at index \\'3\\'  at index \\'4 + 1 = 5\\'\\n            \\n        if we do prefix sum of \\'talbe\\' array then we would get:\\n        \\n        psum = [0, 0, 0, 1, 1, 0, 0, 0]   --> exact same as \\'naive\\' one\\n        \\n        NOTE: Adding +1 to an ith index in table array will contribute +1 to\\n                all the way starting from \\'i\\'th index to up-until the end \\'n\\'.\\n                \\n                See this for what I\\'ve said above:\\n                \\n                adding +1 to index \\'3\\'\\n                =====================\\n                                  \\n                                  1  1  1  1  1\\n                talbe = [0, 0, 0, 0, 0, 0, 0, 0]\\n                                  \\n                adding -1 to index \\'(4 + 1)\\'\\n                =====================\\n                                  \\n                                  1  1  1  1  1     -> contribution of +1\\n                                       -1 -1 -1     -> contibution of -1\\n                table = [0, 0, 0, 0, 0, 0, 0, 0]\\n                \\n                \\n                when we take the prefix sum of above talbe array:\\n                                    \\n                                  1  1  1  1  1     \\n                                       -1 -1 -1    \\n                table = [0, 0, 0, 1, 1, 0, 0, 0]\\n                                  +--+  +-----+\\n                                    ^      ^\\n                                    |      |\\n                                    |      |\\n                                    |  this part (1 + (-1) = 0) gets zero/cancelled out.\\n                                    |    \\n                           only changes made into our\\n                           required interval [3, 4]\\n                           \\n             NOTE: Subtracted -1 at index (R + 1) for given interval [L, R] (inclusive)\\n                    and added +1 at index (L).\\n                    \\n                    why not R? because \\'R\\' is inclusive. Otherwise, subtracting at (R)\\n                    is OK.\\n                    \\n                    **** Think why at (R + 1)? you know the reason. ****\\n       \\n       Similarly after we\\'ve done +1 & -1 for each interval accordingly, take the prefix\\n        sum of the table array. At the end each number corresponding to an index \\'i\\'\\n        is nothing but total number(accumulated operation count) for that index \\'i\\'.\\n       \\n*/\\n```\n```\\nImplementation\\n```\n```\\nclass Solution {\\n    \\n    private static final char[] alphabet;\\n    static {\\n        alphabet = new char[26];\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch += 1) {\\n            alphabet[ch - \\'a\\'] = ch;\\n        }\\n    }\\n    \\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n = s.length();\\n        // +1 to avoid extra check when (R + 1) is out of bound of array index.\\n        // To provide more meaningful meaning, I\\'m using 2 arrays. -> can be done in\\n        // single array as well.\\n        // forwardShift[i] -> tells total how many times the character at \\'ith\\'\\n        // index in the given string \\'s\\' is shifted in forward direction. Similar goes\\n        // to backwardShift.\\n        int[] forwardShift = new int[n + 1];\\n        int[] backwardShift = new int[n + 1];\\n        \\n        for(int i = 0; i < shifts.length; i += 1) {\\n            final int L = shifts[i][0], R = shifts[i][1], DIR = shifts[i][2];\\n            if(DIR == 1) {\\n                forwardShift[L] += 1;\\n                forwardShift[R + 1] -= 1;\\n            } else {\\n                // Updation also gets reversed when direction gets reversed.\\n                backwardShift[L] -= 1;\\n                backwardShift[R + 1] += 1;\\n            }\\n        }\\n        \\n        // building prefix sums\\n        for(int i = 1; i <= n; i += 1) {\\n            forwardShift[i] += forwardShift[i - 1];\\n            backwardShift[i] += backwardShift[i - 1];\\n        }\\n        \\n        StringBuilder shiftedFinalString = new StringBuilder();\\n        \\n        for(int i = 0; i < n; i += 1) {\\n            int totalShiftCount = forwardShift[i] + backwardShift[i];\\n            \\n            // You know the reason why?? we\\'re doing (cnt % 26 + 26) when cnt < 0\\n            if(totalShiftCount < 0) totalShiftCount = totalShiftCount % 26 + 26;\\n            int alphaPosition = s.charAt(i) - \\'a\\';\\n            \\n            // Shifting operation is performing Here (alphaPosition + totalShiftCount)\\n            char newShiftedChar = alphabet[(alphaPosition + totalShiftCount) % 26];\\n            shiftedFinalString.append(newShiftedChar);\\n        }\\n       \\n        return shiftedFinalString.toString();\\n    }\\n}\\n```\n```\\nClean Code\\n```\n```\\nclass Solution {\\n    \\n    private static final char[] alphabet;\\n    static {\\n        alphabet = new char[26];\\n        for(char ch = \\'a\\'; ch <= \\'z\\'; ch += 1) {\\n            alphabet[ch - \\'a\\'] = ch;\\n        }\\n    }\\n    \\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n = s.length();\\n        int[] forwardShift = new int[n + 1];\\n        int[] backwardShift = new int[n + 1];\\n        \\n        for(int i = 0; i < shifts.length; i += 1) {\\n            final int L = shifts[i][0], R = shifts[i][1], DIR = shifts[i][2];\\n            if(DIR == 1) {\\n                forwardShift[L] += 1;\\n                forwardShift[R + 1] -= 1;\\n            } else {\\n                backwardShift[L] -= 1;\\n                backwardShift[R + 1] += 1;\\n            }\\n        }\\n        \\n        for(int i = 1; i <= n; i += 1) {\\n            forwardShift[i] += forwardShift[i - 1];\\n            backwardShift[i] += backwardShift[i - 1];\\n        }\\n        \\n        StringBuilder shiftedFinalString = new StringBuilder();\\n        for(int i = 0; i < n; i += 1) {\\n            int totalShiftCount = forwardShift[i] + backwardShift[i];\\n            if(totalShiftCount < 0) \\n                totalShiftCount = totalShiftCount % 26 + 26;\\n            \\n            int alphaPosition = s.charAt(i) - \\'a\\';\\n            char newShiftedChar = alphabet[(alphaPosition + totalShiftCount) % 26];\\n            shiftedFinalString.append(newShiftedChar);\\n        }\\n       \\n        return shiftedFinalString.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630531,
                "title": "c-easy-to-understand-step-by-step",
                "content": "```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int len=s.length();\\n        vector<int> dir(len+1, 0);\\n        for(auto &shift: shifts){\\n            int start=shift[0], end=shift[1], job=(shift[2]==1)?1:-1;\\n            if(job==1)\\n                dir[start]++, dir[end+1]--;\\n            else\\n                dir[start]--, dir[end+1]++;\\n        }\\n        long long job=0;\\n        for(int i=0; i<len; i++){\\n            job+=dir[i];\\n            s[i]=((s[i]-\\'a\\')+job+260000000LL)%26+\\'a\\';\\n        }\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int len=s.length();\\n        vector<int> dir(len+1, 0);\\n        for(auto &shift: shifts){\\n            int start=shift[0], end=shift[1], job=(shift[2]==1)?1:-1;\\n            if(job==1)\\n                dir[start]++, dir[end+1]--;\\n            else\\n                dir[start]--, dir[end+1]++;\\n        }\\n        long long job=0;\\n        for(int i=0; i<len; i++){\\n            job+=dir[i];\\n            s[i]=((s[i]-\\'a\\')+job+260000000LL)%26+\\'a\\';\\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2519438,
                "title": "python3-o-n-solution",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n      grid = [0]*(len(s)+1)\\n      \\n      for start, end, flag in shifts:\\n        if flag:\\n          grid[start] += 1\\n          grid[end+1] -= 1\\n        else:\\n          grid[start] -= 1\\n          grid[end+1] += 1\\n          \\n      start = grid[0]\\n      \\n      for i in range(1, len(grid)):\\n        start += grid[i]\\n        grid[i] = (start % 26)\\n        \\n      res = []\\n      \\n      for i in range(len(s)):\\n        res.append(chr((ord(s[i]) - 97 + grid[i]) % 26 + 97))\\n        \\n      return \\'\\'.join(res)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n      grid = [0]*(len(s)+1)\\n      \\n      for start, end, flag in shifts:\\n        if flag:\\n          grid[start] += 1\\n          grid[end+1] -= 1\\n        else:\\n          grid[start] -= 1\\n          grid[end+1] += 1\\n          \\n      start = grid[0]\\n      \\n      for i in range(1, len(grid)):\\n        start += grid[i]\\n        grid[i] = (start % 26)\\n        \\n      res = []\\n      \\n      for i in range(len(s)):\\n        res.append(chr((ord(s[i]) - 97 + grid[i]) % 26 + 97))\\n        \\n      return \\'\\'.join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2493593,
                "title": "c-line-sweep-technique",
                "content": "```\\nclass Solution {\\npublic:\\n    map<char,int> mpp ;\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        for(char ch = \\'a\\' ; ch <= \\'z\\' ; ++ch ) mpp[ch - \\'a\\'] = ch ;\\n        vector<int> sweepForward(s.size() + 1) , sweepBackward(s.size() + 1) ;\\n        \\n        for(auto &x : shifts){\\n            int i = x[0] , j = x[1] , dir = x[2] ;\\n            if(dir){\\n                //move Forward\\n                sweepForward[i] += 1 ;\\n                sweepForward[j + 1] -= 1 ;\\n            }else{\\n                //move Backwards\\n                sweepBackward[i] += 1 ;\\n                sweepBackward[j + 1] -= 1 ;\\n            }\\n        }\\n        \\n        //find prefix sum of both the arrays ;\\n        for(int i = 1 ; i <= s.size() ; ++i) sweepBackward[i] += sweepBackward[i - 1] ,sweepForward[i] += sweepForward[i - 1] ;\\n        \\n        \\n        for(int i = 0 ; i < s.size() ; ++i ){\\n            int travel = sweepForward[i] - sweepBackward[i] ;\\n            travel %= 26 ;\\n            if(travel > 0){\\n                int temp = (s[i] - \\'a\\') + travel ;\\n                s[i] = mpp[temp % 26] ;\\n            }else{\\n                travel *= -1 ;\\n                int temp = abs(26 + (s[i] - \\'a\\') - travel) ;\\n                s[i] = mpp[temp % 26] ;\\n            }\\n            \\n        }\\n        \\n        return s ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    map<char,int> mpp ;\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        for(char ch = \\'a\\' ; ch <= \\'z\\' ; ++ch ) mpp[ch - \\'a\\'] = ch ;\\n        vector<int> sweepForward(s.size() + 1) , sweepBackward(s.size() + 1) ;\\n        \\n        for(auto &x : shifts){\\n            int i = x[0] , j = x[1] , dir = x[2] ;\\n            if(dir){\\n                //move Forward\\n                sweepForward[i] += 1 ;\\n                sweepForward[j + 1] -= 1 ;\\n            }else{\\n                //move Backwards\\n                sweepBackward[i] += 1 ;\\n                sweepBackward[j + 1] -= 1 ;\\n            }\\n        }\\n        \\n        //find prefix sum of both the arrays ;\\n        for(int i = 1 ; i <= s.size() ; ++i) sweepBackward[i] += sweepBackward[i - 1] ,sweepForward[i] += sweepForward[i - 1] ;\\n        \\n        \\n        for(int i = 0 ; i < s.size() ; ++i ){\\n            int travel = sweepForward[i] - sweepBackward[i] ;\\n            travel %= 26 ;\\n            if(travel > 0){\\n                int temp = (s[i] - \\'a\\') + travel ;\\n                s[i] = mpp[temp % 26] ;\\n            }else{\\n                travel *= -1 ;\\n                int temp = abs(26 + (s[i] - \\'a\\') - travel) ;\\n                s[i] = mpp[temp % 26] ;\\n            }\\n            \\n        }\\n        \\n        return s ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2492482,
                "title": "python-3-prefix-sum-explanation",
                "content": "### Explanation\\n- Use prefix sum to avoid extra calculations on overlapped ranges\\n- The key is, for each shift\\n\\t- Accumulate the direction at the beginning of this shift (-1 for left, 1 for right)\\n\\t- Accumulate the inversed direction at the index after the end of this shift (1 for left, -1 for right). This is to cancel out the effect from the shift starting from the beginning index\\n\\t- For example (first example from the problem description):\\n\\t\\t- `s = \"abc\", shifts = [[0,1,0],[1,2,1],[0,2,1]]`\\n\\t\\t```\\n\\t\\tindex   : 0  1  2\\n\\t\\tshift #1:-1  *  1  -> starting from index 0, shift to left, at index 2, negate the left shift since no shift needed starting from here\\n\\t\\tshift #2: x  1  *  -> starting from index 1, shift to right, to the end\\n\\t\\tshift #3: 1  *  *  -> starting from index 0, shift to right, to the end\\n\\t\\t\\n\\t\\tx: meaning empty 0\\n\\t\\t*: meaning same as previous, but can be considered as 0 with prefix sum\\n\\t\\t```\\n\\t\\t- Then we need to accumulate shifts for each index, and do a prefix sum for the next index\\n\\t\\t```\\n\\t\\tindex   : 0  1  2\\n\\t\\tshift #1:-1  *  1  \\n\\t\\tshift #2: x  1  *  \\n\\t\\tshift #3: 1  *  *  \\n\\t\\t\\n\\t\\tsum for each column (we used a `Counter` for this calculation below)\\n\\t\\tindex 0: -1 + 1 = 0\\n\\t\\tindex 1: 0 + 1 = 1 # 0 is the result from the previous calculation (prefix sum)\\n\\t\\tindex 2: 1 + 1 = 2 # first 1 is the result from the previous calculation (prefix sum)\\n\\t\\t```\\n\\t\\t- Now we know, for `s = \"abc\"`:\\n\\t\\t\\t- No shift is needed for index 0, we get `a` \\n\\t\\t\\t- 1 right shift is needed for index 1, we get `c`\\n\\t\\t\\t- 2 right shifts are needed for index 2, we get `e`\\n\\t\\t\\t- The result is `ace`\\n- Time: `O(n), n = len(s)`\\n### Implementation\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        d = collections.Counter()\\n        for st, e, right in shifts:\\n            d[st] += 1 if right else -1         # Mark at the beginning to indicate everything after it need to be shifted\\n            if e+1 < n:                         # Mark (inversely) at the index after the end, to negate the unnecessary shifts\\n                d[e+1] += -1 if right else 1\\n        prefix = [0]                            # Initialize the prefix array\\n        ans = \\'\\'\\n        for i in range(n):                      # Use prefix sum style to accumulate all shifts needed, which were carried over from the previous index\\n            cur = prefix[-1] + d[i]\\n            prefix.append(cur)\\n            ans += string.ascii_lowercase[(ord(s[i]) - ord(\\'a\\') + cur) % 26]\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\n\\t\\tindex   : 0  1  2\\n\\t\\tshift #1:-1  *  1  -> starting from index 0, shift to left, at index 2, negate the left shift since no shift needed starting from here\\n\\t\\tshift #2: x  1  *  -> starting from index 1, shift to right, to the end\\n\\t\\tshift #3: 1  *  *  -> starting from index 0, shift to right, to the end\\n\\t\\t\\n\\t\\tx: meaning empty 0\\n\\t\\t*: meaning same as previous, but can be considered as 0 with prefix sum\\n\\t\\t```\n```\\n\\t\\tindex   : 0  1  2\\n\\t\\tshift #1:-1  *  1  \\n\\t\\tshift #2: x  1  *  \\n\\t\\tshift #3: 1  *  *  \\n\\t\\t\\n\\t\\tsum for each column (we used a `Counter` for this calculation below)\\n\\t\\tindex 0: -1 + 1 = 0\\n\\t\\tindex 1: 0 + 1 = 1 # 0 is the result from the previous calculation (prefix sum)\\n\\t\\tindex 2: 1 + 1 = 2 # first 1 is the result from the previous calculation (prefix sum)\\n\\t\\t```\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        d = collections.Counter()\\n        for st, e, right in shifts:\\n            d[st] += 1 if right else -1         # Mark at the beginning to indicate everything after it need to be shifted\\n            if e+1 < n:                         # Mark (inversely) at the index after the end, to negate the unnecessary shifts\\n                d[e+1] += -1 if right else 1\\n        prefix = [0]                            # Initialize the prefix array\\n        ans = \\'\\'\\n        for i in range(n):                      # Use prefix sum style to accumulate all shifts needed, which were carried over from the previous index\\n            cur = prefix[-1] + d[i]\\n            prefix.append(cur)\\n            ans += string.ascii_lowercase[(ord(s[i]) - ord(\\'a\\') + cur) % 26]\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479823,
                "title": "python-brute-force-to-optimised-detailed-explanation",
                "content": "First of all, this problem is an extension of [848. Shifting Letters](https://leetcode.com/problems/shifting-letters/)\\n\\nIf you have not solved that, I recommand you to look into that first.\\nhttps://leetcode.com/problems/shifting-letters/discuss/2479524/Python-Shift-by-sum\\n\\nCan we convert this problem to 848 by updating shifts to store shift value at each index?\\n\\nBrute force way is to loop through all the shifts and range start to end and update the shift value for each index in hashmap - O(N2)\\n\\n```\\n# Brute Force- TLE\\nhashmap = {i: 0 for i in range(len(s))}\\nfor start, end, direction in shifts:\\n\\tfor i in range(start, end + 1):\\n\\t\\tif direction == 1:\\n\\t\\t\\thashmap[i] += 1\\n\\t\\telse:\\n\\t\\t\\thashmap[i] -= 1\\n\\n```\\n***Can we improve this?***\\n\\nLets taken an example\\nWe have to increase value of index [0, 5] by 1\\nOne way is to loop from 0 to 5 and increase each index by 1 - **O(N)**\\n\\nOther way to to increase index 0 by 1 and then apply prefix sum\\n[1, 0, 0, 0, 0]\\nprefix[1] = prefix[0] + prefix[1] => 1 + 0 = 1\\nprefix[2] = prefix[1] + prefix[2] => 1 + 0 = 1\\n.......\\nwe will get [1, 1, 1, 1, 1] - **O(1)**\\n\\n```\\n\\n\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        prefix = [0] * (len(s) + 1)\\n        for start, end, direction in shifts:\\n            if direction == 1:\\n                prefix[start] += 1\\n                prefix[end + 1] -= 1\\n            else:\\n                prefix[start] -= 1\\n                prefix[end + 1] += 1\\n        \\n        res = []\\n        for i, c in enumerate(s):\\n            shift = prefix[i]\\n            res.append(chr(((ord(c) - 97 + shift) % 26) + 97))\\n            prefix[i + 1] += prefix[i]\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\n# Brute Force- TLE\\nhashmap = {i: 0 for i in range(len(s))}\\nfor start, end, direction in shifts:\\n\\tfor i in range(start, end + 1):\\n\\t\\tif direction == 1:\\n\\t\\t\\thashmap[i] += 1\\n\\t\\telse:\\n\\t\\t\\thashmap[i] -= 1\\n\\n```\n```\\n\\n\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        prefix = [0] * (len(s) + 1)\\n        for start, end, direction in shifts:\\n            if direction == 1:\\n                prefix[start] += 1\\n                prefix[end + 1] -= 1\\n            else:\\n                prefix[start] -= 1\\n                prefix[end + 1] += 1\\n        \\n        res = []\\n        for i, c in enumerate(s):\\n            shift = prefix[i]\\n            res.append(chr(((ord(c) - 97 + shift) % 26) + 97))\\n            prefix[i + 1] += prefix[i]\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2474340,
                "title": "python-3-100-in-time-100-in-space",
                "content": "Consider an array of size 11 intialized with zeros.\\n**[0,0,0,0,0,0,0,0,0,0,  0]**   **<-** array\\n**[0,1,2,3,4,5,6,7,8,9,10]**   **<-** index\\nNow if you want to repeatedly increase count in a range then you can use prefix sum.\\nAssume you want to increase the count from range [1,6],[1,7],[1,8] then simply increase the count at start and decrease the count at end+1 i.e,\\nthe modified array after first query [1,6] would be as \\n**[0,1,0,0,0,0,0,-1,0,0,0]**\\nnow perform prefix sum then the result would be as\\n**[0,1,1,1,1,1,1,0,0,0,0]**\\nthis result is equivalent to iterating from start to end and increasing the count.\\nsimilary look at second query which is [1,7]\\nso the modified array would be\\n**[0,2,0,0,0,0,0,-1,-1,0,0]**\\nso after prefix sum we would have \\n**[0,2,2,2,2,2,2,1,0,0,0]** . so after performing all the shifts we do the final prefix sum and shift the string\\n## Code:-\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        ans = [0]*(len(s)+1)\\n        for i,j,k in shifts:\\n            if k:\\n                ans[i]+=1\\n                ans[j+1]-=1\\n            else:\\n                ans[i]-=1\\n                ans[j+1]+=1\\n        for i in range(1,len(ans)):\\n            ans[i]+=ans[i-1]\\n        del ans[-1]\\n        result = \\'\\'\\n        index=0\\n        for i in ans:\\n            temp = i%26\\n            temp1 = ord(s[index])\\n            sums = temp+temp1\\n            if sums>122:\\n                result+=chr(sums-26)\\n            else:\\n                result+=chr(sums)\\n            index+=1\\n        return result\\n\\n```\\n![image](https://assets.leetcode.com/users/images/a9da71f2-070f-4351-89e9-bc13f01957c9_1661360163.5349534.png)\\n",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        ans = [0]*(len(s)+1)\\n        for i,j,k in shifts:\\n            if k:\\n                ans[i]+=1\\n                ans[j+1]-=1\\n            else:\\n                ans[i]-=1\\n                ans[j+1]+=1\\n        for i in range(1,len(ans)):\\n            ans[i]+=ans[i-1]\\n        del ans[-1]\\n        result = \\'\\'\\n        index=0\\n        for i in ans:\\n            temp = i%26\\n            temp1 = ord(s[index])\\n            sums = temp+temp1\\n            if sums>122:\\n                result+=chr(sums-26)\\n            else:\\n                result+=chr(sums)\\n            index+=1\\n        return result\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472389,
                "title": "c-prefix-sum-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        int m=shifts.size();\\n        \\n        vector<int> arr(n+1,0);\\n        \\n        for(int i=0;i<m;i++){\\n            if(shifts[i][2]==1)\\n            {\\n                arr[shifts[i][0]]++;\\n                arr[shifts[i][1]+1]--;\\n            }\\n            else\\n            {\\n                arr[shifts[i][0]]--;\\n                arr[shifts[i][1]+1]++;\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            arr[i]+=arr[i-1];\\n        }\\n        for(int i=0;i<n;i++){\\n            arr[i]=arr[i]%26;\\n            if(arr[i]<0){\\n                arr[i]=arr[i]+26;\\n            }\\n            s[i]=char(int(arr[i]+s[i]-97)%26+97);\\n        }\\n        return s;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        int m=shifts.size();\\n        \\n        vector<int> arr(n+1,0);\\n        \\n        for(int i=0;i<m;i++){\\n            if(shifts[i][2]==1)\\n            {\\n                arr[shifts[i][0]]++;\\n                arr[shifts[i][1]+1]--;\\n            }\\n            else\\n            {\\n                arr[shifts[i][0]]--;\\n                arr[shifts[i][1]+1]++;\\n            }\\n        }\\n        \\n        for(int i=1;i<=n;i++){\\n            arr[i]+=arr[i-1];\\n        }\\n        for(int i=0;i<n;i++){\\n            arr[i]=arr[i]%26;\\n            if(arr[i]<0){\\n                arr[i]=arr[i]+26;\\n            }\\n            s[i]=char(int(arr[i]+s[i]-97)%26+97);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469075,
                "title": "prefix-sum-easy-clean-code-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int mod=26;\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> v(s.size()+1,0);\\n        int n=shifts.size();\\n        for(auto it: shifts){\\n            if(it[2]==0){\\n                v[it[0]]--;\\n                v[it[1]+1]++;\\n            }\\n            else{\\n                v[it[0]]++;\\n                v[it[1]+1]--;\\n            }\\n        }\\n        for(int i=1;i<v.size();i++){\\n            v[i]+=v[i-1];\\n        }\\n        for(int i=0;i<s.size();i++){\\n            v[i]%=26;\\n            s[i]=(s[i]-\\'a\\'+v[i]+26)%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```\\nTC=O(N)\\nSC=O(N)\\n**Please upvote if you liked my solution :)**",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int mod=26;\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> v(s.size()+1,0);\\n        int n=shifts.size();\\n        for(auto it: shifts){\\n            if(it[2]==0){\\n                v[it[0]]--;\\n                v[it[1]+1]++;\\n            }\\n            else{\\n                v[it[0]]++;\\n                v[it[1]+1]--;\\n            }\\n        }\\n        for(int i=1;i<v.size();i++){\\n            v[i]+=v[i-1];\\n        }\\n        for(int i=0;i<s.size();i++){\\n            v[i]%=26;\\n            s[i]=(s[i]-\\'a\\'+v[i]+26)%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462692,
                "title": "100-00-of-c-based-on-scanline-algo-prefix-sum-optimise-tc",
                "content": "This is a problem we might be tempted to solve with a brute force approach, directly changing the characters in place at each step, but a quick look at the constraints might make us desist quickly: we might get potentially 50000 shifts covering the whole size of s, which is of the same size, for a grand total of 250M operations, which is definitely not the cheapest we can get.\\n\\nStoring the changes might be much more convenient, but again we need to think how - having an array of s.size() elements we update all the time would hardly be an improvement.\\n\\nGladly this problem seems to be a handbook case for the usage of a difference array!\\n\\nThe core idea of this data structure is that if we receive a change of x across all the values from a to b (included), we are going to do so just by writing x at index a and -x at index b + 1 (cancelling the effect of the first change on a).\\n\\nWhen we go and read through the difference array, we will keep a running count of what changes we encountered, giving us a measure of how they are affecting the current cell. A pretty good solution when we are going to face several changes across potentially very large intervals and when we need to read the final result only once (so we can accept a linear complexity for this!).\\n\\nLet\\'s go for some quick example, for \"abcdefgh\":\\n\\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t0\\t0\\t0\\t0\\t0\\t0\\t0\\t // initial values in the difference array\\n```\\nThen we decide to increase by 1 all the values from 1 to 5 , so that we will have:\\n\\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t0\\t0  -1\\t0\\t // values after the first change\\n```\\nNow we decide to increase by 1 all the values from 4 to 6 , so that we will have:\\n\\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t1\\t0  -1  -1\\t // values after the second change\\n```\\nNext we decrease by 1 all the values from 2 to 3 , so that we will have:\\n\\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t0\\t2\\t0  -1  -1\\t // values after the third change; notice index 4 now with a value of 2 from the previous two operations\\n```\\nFinally we increase by 1 all the values from 3 to 5 , so that we will have:\\n\\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t1\\t2\\t0  -2  -1\\t // values after the fourth change; notice index 7 now with a value of -2 from the first and last operations\\n```\\nNow, going with a running sun as we parse our difference array, we will find that each character will have to do the following shifts:\\n\\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1   0\\t1\\t3\\t0   1   0\\t // shifts for each character\\n```\\nThe remaining part of the problem is just how to handle when a character gets shifted past \\'a\\' or \\'z\\', but that is rather trivial compared to the rest.\\n\\nNow, to put our thoughts into code, we will start declaring a few support variables, as usual:\\n\\nlen will store the size of s;\\ndiffArray is where we will store our indexes, creating it with a length of len + 1 to avoid extra logic on the -x mark when applied to the last cell - saving us shifts.size() conditional statements for the cost of a couple of bytes;\\ndir will be a support variable for when we iterate shifts.\\nWe will then set all the cells of diffArray to 0, but for the last one (as we said, we do not really care and we will never really use it, just as a placeholder).\\n\\nLooping though each shift in shifts, we will:\\n\\nset dir to be 1 if shift[2] is also 1, -1 otherwise, as specified in the specs;\\nincrease our starting point diffArray[shift[0]] by dir;\\ndecrease our ending point diffArray[shift[1] + 1] by dir.\\nWith diffArray fully populated, we can now work on s and, with our ongoing sum c initialised to 0 and for each position i in it, we will:\\n\\nset c to increase by diffArray[i] (I saw some solutions doing this with a separate pass, but since we only need to do this once, no point in storing the values and writing them down updating diffArray in place);\\nset pos to the value in which we would pick a character in an ideal \"abcdefghijklmnopqrstuvwxyz\" string, with the value equal to the original (s[i]), minus \\'a\\' (to turn it into a value in the 0 - 25 range), plus c (so, the final shift for this specific cell);\\nwe will add 26 to pos as long as it is < 0 to make sure it is within range;\\nwe will subtract 26 to pos as long as it is > 25 to make sure it is within range - notice that this way our solution has only one expensive modulo operation per character \\uD83C\\uDFC6 ;\\nfinally, we will set back the value in s[i] to be equal to pos (our adjusted 0 - 25 final value), plus \\'a\\' (to make sure it is again a valid lowercase ASCII character).\\nOnce done, we can just return res :)\\n\\n\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& sh) {\\n        \\n        int n = s.size();\\n        int m = sh.size();\\n        vector<int> dup(n+1 , 0);\\n        for(auto &i : sh){\\n            if(i[2]==1){\\n                dup[i[0]]++;\\n                dup[i[1]+1]--;\\n            }\\n            else{\\n                dup[i[0]]--;\\n                dup[i[1]+1]++;\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            dup[i]+=dup[i-1];\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int inc = (s[i]-\\'a\\'+dup[i])%26;\\n            inc=(inc+26)%26;\\n            s[i]=\\'a\\'+inc;\\n        }\\n\\n        return s;\\n    }\\n};\\n```\\n\\n# **Please Upvote if you found this helpful **",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t0\\t0\\t0\\t0\\t0\\t0\\t0\\t // initial values in the difference array\\n```\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t0\\t0  -1\\t0\\t // values after the first change\\n```\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1\\t0\\t0\\t1\\t0  -1  -1\\t // values after the second change\\n```\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t0\\t2\\t0  -1  -1\\t // values after the third change; notice index 4 now with a value of 2 from the previous two operations\\n```\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1  -1\\t1\\t2\\t0  -2  -1\\t // values after the fourth change; notice index 7 now with a value of -2 from the first and last operations\\n```\n```\\na\\tb\\tc\\td\\te\\tf\\tg\\th\\t // cells of the string\\t\\n0\\t1   0\\t1\\t3\\t0   1   0\\t // shifts for each character\\n```\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& sh) {\\n        \\n        int n = s.size();\\n        int m = sh.size();\\n        vector<int> dup(n+1 , 0);\\n        for(auto &i : sh){\\n            if(i[2]==1){\\n                dup[i[0]]++;\\n                dup[i[1]+1]--;\\n            }\\n            else{\\n                dup[i[0]]--;\\n                dup[i[1]+1]++;\\n            }\\n        }\\n        for(int i=1;i<n+1;i++){\\n            dup[i]+=dup[i-1];\\n        }\\n\\n        for(int i=0;i<n;i++){\\n            int inc = (s[i]-\\'a\\'+dup[i])%26;\\n            inc=(inc+26)%26;\\n            s[i]=\\'a\\'+inc;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459170,
                "title": "leetcode-the-hard-way-line-sweep",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> line(n + 1, 0);\\n        // standard line sweep\\n        for (auto& s : shifts) {\\n            int start = s[0],\\n                end   = s[1],\\n            direction = s[2];\\n            line[start] += direction ? 1 : -1;\\n            line[end + 1] += direction ? -1 : 1;\\n        }\\n        // calculate the prefix sum\\n        partial_sum(line.begin(), line.end(), line.begin());\\n        // for each character\\n        for (int i = 0; i < n; i++) {\\n            // we calculate the new index value\\n            int v = (s[i] - \\'a\\' + line[i]) % 26;\\n            // v can be negative if it is shifting backward\\n            // in this case, we need to turn it back to positive\\n            if (v < 0) v = (v % 26 + 26) % 26;\\n            // in place update character at position i \\n            s[i] = \\'a\\' + v;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> line(n + 1, 0);\\n        // standard line sweep\\n        for (auto& s : shifts) {\\n            int start = s[0],\\n                end   = s[1],\\n            direction = s[2];\\n            line[start] += direction ? 1 : -1;\\n            line[end + 1] += direction ? -1 : 1;\\n        }\\n        // calculate the prefix sum\\n        partial_sum(line.begin(), line.end(), line.begin());\\n        // for each character\\n        for (int i = 0; i < n; i++) {\\n            // we calculate the new index value\\n            int v = (s[i] - \\'a\\' + line[i]) % 26;\\n            // v can be negative if it is shifting backward\\n            // in this case, we need to turn it back to positive\\n            if (v < 0) v = (v % 26 + 26) % 26;\\n            // in place update character at position i \\n            s[i] = \\'a\\' + v;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459015,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using Prefix Sum***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string str, vector<vector<int>>& shifts) {\\n        \\n        int n = str.size();\\n        \\n        // count[i] will store the no. of times of increment or decrement of for str[i]\\n        \\n        vector<int> count(n + 1, 0);\\n        \\n        for(int i = 0; i < shifts.size(); i++)\\n        {\\n            int left = shifts[i][0];\\n            \\n            int right = shifts[i][1];\\n            \\n            int sign = shifts[i][2];\\n            \\n            if(sign == 1)\\n            {\\n                count[left]++;\\n                \\n                count[right + 1]--;\\n            }\\n            else\\n            {\\n                count[left]--;\\n                \\n                count[right + 1]++;\\n            }\\n        }\\n        \\n        // find prefix sum\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            count[i] += count[i - 1];\\n        }\\n        \\n        // shift the characters of str\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int increment = (str[i] - \\'a\\' + count[i]) % 26;\\n            \\n            // if increment becomes negative, then make it positive\\n            \\n            if(increment < 0)\\n            {\\n                increment = (increment + 26) % 26;\\n            }\\n            \\n            // update str[i]\\n            \\n            str[i] = \\'a\\' + increment;\\n        }\\n        \\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string str, vector<vector<int>>& shifts) {\\n        \\n        int n = str.size();\\n        \\n        // count[i] will store the no. of times of increment or decrement of for str[i]\\n        \\n        vector<int> count(n + 1, 0);\\n        \\n        for(int i = 0; i < shifts.size(); i++)\\n        {\\n            int left = shifts[i][0];\\n            \\n            int right = shifts[i][1];\\n            \\n            int sign = shifts[i][2];\\n            \\n            if(sign == 1)\\n            {\\n                count[left]++;\\n                \\n                count[right + 1]--;\\n            }\\n            else\\n            {\\n                count[left]--;\\n                \\n                count[right + 1]++;\\n            }\\n        }\\n        \\n        // find prefix sum\\n        \\n        for(int i = 1; i < n; i++)\\n        {\\n            count[i] += count[i - 1];\\n        }\\n        \\n        // shift the characters of str\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            int increment = (str[i] - \\'a\\' + count[i]) % 26;\\n            \\n            // if increment becomes negative, then make it positive\\n            \\n            if(increment < 0)\\n            {\\n                increment = (increment + 26) % 26;\\n            }\\n            \\n            // update str[i]\\n            \\n            str[i] = \\'a\\' + increment;\\n        }\\n        \\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454934,
                "title": "simple-o-n-c-prefix-sum",
                "content": "```\\nclass Solution {\\n    char getRotateChar(int f, int b, char c) {\\n        if (f==b) return c;\\n        if (f<b) {\\n            b=b-f;\\n            b%=26;\\n            for(int i=0;i<b;i++) {\\n                c--;\\n                if (c==\\'a\\'-1) c=\\'z\\';\\n            }\\n            return c;\\n        }\\n        else {\\n            f=f-b;\\n            f%=26;\\n            for(int i=0;i<f;i++) {\\n                c++;\\n                if (c==\\'z\\'+1) c=\\'a\\';\\n            }\\n            return c;\\n        }\\n    }\\n    \\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> F(n+1, 0);\\n        vector<int> B(n+1, 0);\\n        for(int i=0;i<shifts.size();i++) {\\n            if (shifts[i][2]==1) {\\n                F[shifts[i][0]]++;\\n                F[shifts[i][1]+1]--;\\n            }\\n            else {\\n                B[shifts[i][0]]++;\\n                B[shifts[i][1]+1]--;\\n            }\\n        }\\n        int f=0,b=0;\\n        for(int i=0;i<n;i++) {\\n            f+=F[i];\\n            b+=B[i];\\n            s[i]=getRotateChar(f,b,s[i]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    char getRotateChar(int f, int b, char c) {\\n        if (f==b) return c;\\n        if (f<b) {\\n            b=b-f;\\n            b%=26;\\n            for(int i=0;i<b;i++) {\\n                c--;\\n                if (c==\\'a\\'-1) c=\\'z\\';\\n            }\\n            return c;\\n        }\\n        else {\\n            f=f-b;\\n            f%=26;\\n            for(int i=0;i<f;i++) {\\n                c++;\\n                if (c==\\'z\\'+1) c=\\'a\\';\\n            }\\n            return c;\\n        }\\n    }\\n    \\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> F(n+1, 0);\\n        vector<int> B(n+1, 0);\\n        for(int i=0;i<shifts.size();i++) {\\n            if (shifts[i][2]==1) {\\n                F[shifts[i][0]]++;\\n                F[shifts[i][1]+1]--;\\n            }\\n            else {\\n                B[shifts[i][0]]++;\\n                B[shifts[i][1]+1]--;\\n            }\\n        }\\n        int f=0,b=0;\\n        for(int i=0;i<n;i++) {\\n            f+=F[i];\\n            b+=B[i];\\n            s[i]=getRotateChar(f,b,s[i]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454901,
                "title": "c-o-n-time-using-prefixsum",
                "content": "**C++ Code:**\\n\\n```\\n string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = shifts.size();\\n        int len = s.length();\\n        vector<int>arr(len,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                arr[shifts[i][1]]++;\\n                if(shifts[i][0]>0)\\n                arr[shifts[i][0]-1]--;\\n            }\\n            else{\\n                arr[shifts[i][1]]--; \\n                if(shifts[i][0]>0)\\n                arr[shifts[i][0]-1]++;\\n            }\\n        }\\n        for(int i=len-2;i>=0;i--)\\n            arr[i] += arr[i+1];\\n      for(int i=0;i<len;i++)\\n      {\\n          int temp = s[i]-\\'a\\'+arr[i];\\n          while(temp<0) temp += 26;\\n          s[i] = \\'a\\'+(temp)%26;\\n      }\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\n string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = shifts.size();\\n        int len = s.length();\\n        vector<int>arr(len,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                arr[shifts[i][1]]++;\\n                if(shifts[i][0]>0)\\n                arr[shifts[i][0]-1]--;\\n            }\\n            else{\\n                arr[shifts[i][1]]--; \\n                if(shifts[i][0]>0)\\n                arr[shifts[i][0]-1]++;\\n            }\\n        }\\n        for(int i=len-2;i>=0;i--)\\n            arr[i] += arr[i+1];\\n      for(int i=0;i<len;i++)\\n      {\\n          int temp = s[i]-\\'a\\'+arr[i];\\n          while(temp<0) temp += 26;\\n          s[i] = \\'a\\'+(temp)%26;\\n      }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454536,
                "title": "doubt-why-to-use-after-v",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& a) {\\n        int n=s.size(),m=a.size();\\n        vector<int> v(n);\\n        for(int i=0;i<m;i++)\\n        {\\n            if(a[i][2]==0)  //backwrd\\n            {\\n                    v[a[i][0]]--;\\n                if(a[i][1]<n-1)\\n                    v[a[i][1]+1]++;\\n            }\\n            else\\n            {\\n                v[a[i][0]]++;\\n                if(a[i][1]<n-1)\\n                    v[a[i][1]+1]--;\\n            }\\n        }\\n        for(int i=1;i<n;i++)\\n            v[i]+=v[i-1];\\n        for(int i=0;i<n;i++)\\n        {\\n            s[i]=( (s[i]-\\'a\\')+26+v[i]%26)%26+\\'a\\'; \\n        }\\n        return s;\\n    }\\n};\\n```\\n why is it giving WRONG ANSWER when i am not writing %26 in  s[i]=( (s[i]-\\'a\\')+26+v[i]%26)%26+\\'a\\';\\n \\n i.e why s[i]=( (s[i]-\\'a\\')+26+v[i])%26+\\'a\\'; is giving WRONG ANSWER?",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& a) {\\n        int n=s.size(),m=a.size();\\n        vector<int> v(n);\\n        for(int i=0;i<m;i++)\\n        {\\n            if(a[i][2]==0)  //backwrd\\n            {\\n                    v[a[i][0]]--;\\n                if(a[i][1]<n-1)\\n                    v[a[i][1]+1]++;\\n            }\\n            else\\n            {\\n                v[a[i][0]]++;\\n                if(a[i][1]<n-1)\\n                    v[a[i][1]+1]--;\\n            }\\n        }\\n        for(int i=1;i<n;i++)\\n            v[i]+=v[i-1];\\n        for(int i=0;i<n;i++)\\n        {\\n            s[i]=( (s[i]-\\'a\\')+26+v[i]%26)%26+\\'a\\'; \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454326,
                "title": "javascript-generate-a-operation-map-to-reduce-running-time",
                "content": "> Runtime: 9369 ms, faster than 100.00% of JavaScript online submissions for Shifting Letters II.\\nMemory Usage: 70.4 MB, less than 100.00% of JavaScript online submissions for Shifting Letters II.\\n\\n```js\\n/**\\n * @param {string} s\\n * @param {number[][]} shifts\\n * @return {string}\\n */\\nvar shiftingLetters = function(s, shifts) {\\n    const cb = Array(s.length).fill(0);\\n    shifts.forEach(([s,e,d]) => {\\n        for(let i=s;i<=e;i++) {\\n            cb[i] += (d===0 ? -1 : 1)\\n        }\\n    })\\n    const arr = s.split(\\'\\');\\n    cb.forEach((e,i) => {\\n        let newCharCode = arr[i].charCodeAt() + e;\\n        while (newCharCode < 97) {\\n            newCharCode+=26\\n        }\\n        while (newCharCode > 122) {\\n            newCharCode-=26\\n        }\\n        arr[i] = String.fromCharCode(newCharCode)\\n    })\\n    return arr.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * @param {string} s\\n * @param {number[][]} shifts\\n * @return {string}\\n */\\nvar shiftingLetters = function(s, shifts) {\\n    const cb = Array(s.length).fill(0);\\n    shifts.forEach(([s,e,d]) => {\\n        for(let i=s;i<=e;i++) {\\n            cb[i] += (d===0 ? -1 : 1)\\n        }\\n    })\\n    const arr = s.split(\\'\\');\\n    cb.forEach((e,i) => {\\n        let newCharCode = arr[i].charCodeAt() + e;\\n        while (newCharCode < 97) {\\n            newCharCode+=26\\n        }\\n        while (newCharCode > 122) {\\n            newCharCode-=26\\n        }\\n        arr[i] = String.fromCharCode(newCharCode)\\n    })\\n    return arr.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454274,
                "title": "very-stupid-segment-tree-solution-c",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>seg;\\n    vector<int>lz;\\n    void build(vector<int>&v,int l,int r,int idx){\\n        if(l==r){\\n            seg[idx]=v[l];\\n            return;\\n        }\\n        int m=l+(r-l)/2;\\n        build(v,l,m,2*idx+1);\\n        build(v,m+1,r,2*idx+2);\\n        seg[idx]=max(seg[2*idx+1],seg[2*idx+2]);\\n        seg[idx]=(26+seg[idx])%26;\\n    }\\n    void update(int l,int r,int idx,int ql,int qr,int v){\\n        if(lz[idx]!=0){\\n            seg[idx]+=lz[idx];\\n            seg[idx]=(26+seg[idx])%26;\\n            if(l!=r){\\n                lz[2*idx+1]+=lz[idx];\\n                lz[2*idx+2]+=lz[idx];\\n            }\\n            lz[idx]=0;\\n        }\\n        if(r<ql||l>qr)return;\\n        if(l>=ql&&r<=qr){\\n            seg[idx]+=v;\\n            seg[idx]=(26+seg[idx])%26;\\n            if(l!=r){\\n                 lz[2*idx+1]+=v;\\n                lz[2*idx+2]+=v;\\n            }\\n            return;\\n        }\\n        int m=l+(r-l)/2;\\n        update(l,m,2*idx+1,ql,qr,v);\\n        update(m+1,r,2*idx+2,ql,qr,v);\\n        seg[idx]=max(seg[2*idx+1],seg[2*idx+2]);\\n        seg[idx]=(26+seg[idx])%26;\\n        \\n    }\\n    int query(int l,int r,int idx,int k){\\n         if(lz[idx]!=0){\\n            seg[idx]+=lz[idx];\\n             seg[idx]=(26+seg[idx])%26;\\n            if(l!=r){\\n                lz[2*idx+1]+=lz[idx];\\n                lz[2*idx+2]+=lz[idx];\\n            }\\n            lz[idx]=0;\\n        }\\n        if(l==r){\\n            if(l==k)return seg[idx];\\n        }\\n        if(r<k||l>k)return 0;\\n        int m=l+(r-l)/2;\\n       return query(l,m,2*idx+1,k)+ query(m+1,r,2*idx+2,k);\\n    }\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int>v(s.size());\\n        seg=vector<int>(4*s.size()+1,-1e9);\\n        lz=vector<int>(4*s.size()+1,0);\\n        \\n        for(int i=0;i<s.size();i++) v[i]=s[i]-\\'a\\';\\n           \\n        build(v,0,v.size()-1,0);\\n        for(auto t:shifts){\\n            int k=1;\\n            if(t[2]==0)k=-1;\\n            update(0,v.size()-1,0,t[0],t[1],k);\\n            //cout<<query(0,v.size()-1,0,t[0])<<\" \";\\n        }\\n        string a=\"\";\\n        for(int i=0;i<v.size();i++){\\n            int k=query(0,v.size()-1,0,i);\\n            k=(26+k)%26;\\n            a+=(\\'a\\'+k);\\n        }\\n        //cout<<\"\\\\n\";\\n        return a;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>seg;\\n    vector<int>lz;\\n    void build(vector<int>&v,int l,int r,int idx){\\n        if(l==r){\\n            seg[idx]=v[l];\\n            return;\\n        }\\n        int m=l+(r-l)/2;\\n        build(v,l,m,2*idx+1);\\n        build(v,m+1,r,2*idx+2);\\n        seg[idx]=max(seg[2*idx+1],seg[2*idx+2]);\\n        seg[idx]=(26+seg[idx])%26;\\n    }\\n    void update(int l,int r,int idx,int ql,int qr,int v){\\n        if(lz[idx]!=0){\\n            seg[idx]+=lz[idx];\\n            seg[idx]=(26+seg[idx])%26;\\n            if(l!=r){\\n                lz[2*idx+1]+=lz[idx];\\n                lz[2*idx+2]+=lz[idx];\\n            }\\n            lz[idx]=0;\\n        }\\n        if(r<ql||l>qr)return;\\n        if(l>=ql&&r<=qr){\\n            seg[idx]+=v;\\n            seg[idx]=(26+seg[idx])%26;\\n            if(l!=r){\\n                 lz[2*idx+1]+=v;\\n                lz[2*idx+2]+=v;\\n            }\\n            return;\\n        }\\n        int m=l+(r-l)/2;\\n        update(l,m,2*idx+1,ql,qr,v);\\n        update(m+1,r,2*idx+2,ql,qr,v);\\n        seg[idx]=max(seg[2*idx+1],seg[2*idx+2]);\\n        seg[idx]=(26+seg[idx])%26;\\n        \\n    }\\n    int query(int l,int r,int idx,int k){\\n         if(lz[idx]!=0){\\n            seg[idx]+=lz[idx];\\n             seg[idx]=(26+seg[idx])%26;\\n            if(l!=r){\\n                lz[2*idx+1]+=lz[idx];\\n                lz[2*idx+2]+=lz[idx];\\n            }\\n            lz[idx]=0;\\n        }\\n        if(l==r){\\n            if(l==k)return seg[idx];\\n        }\\n        if(r<k||l>k)return 0;\\n        int m=l+(r-l)/2;\\n       return query(l,m,2*idx+1,k)+ query(m+1,r,2*idx+2,k);\\n    }\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int>v(s.size());\\n        seg=vector<int>(4*s.size()+1,-1e9);\\n        lz=vector<int>(4*s.size()+1,0);\\n        \\n        for(int i=0;i<s.size();i++) v[i]=s[i]-\\'a\\';\\n           \\n        build(v,0,v.size()-1,0);\\n        for(auto t:shifts){\\n            int k=1;\\n            if(t[2]==0)k=-1;\\n            update(0,v.size()-1,0,t[0],t[1],k);\\n            //cout<<query(0,v.size()-1,0,t[0])<<\" \";\\n        }\\n        string a=\"\";\\n        for(int i=0;i<v.size();i++){\\n            int k=query(0,v.size()-1,0,i);\\n            k=(26+k)%26;\\n            a+=(\\'a\\'+k);\\n        }\\n        //cout<<\"\\\\n\";\\n        return a;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2454215,
                "title": "python3-line-sweep",
                "content": "Please pull this git [commit](https://github.com/gaosanyong/leetcode/commit/e999ea07dc2ea2e8b7aad97696f67a3b965e496d) for solutions of biweekly 85. \\n\\n**Intuition**\\nThis is a typical line sweeping problem. While looping through `shifts`, we break [start, end, direction] into two paris and put them on a line of ops \\n\\n```\\n[start, 2direction-1]\\n[end+1, -2direction+1]\\n```\\nIn addition, I use a linear transformation to scale {0, 1} direction to {1, -1} for later calculations. I sort the ops and process the amount of shift via a prefix sum. At index i, I\\'d sum all shifts up to this point and apply the shift to the character. \\n**Caveat** Python modulo automatically gives positive value which nicely suits the requirement of this problem. For other languages (e.g. C++), you might need to manually offset it by another 26 to avoid negative values. \\n\\n**Analysis**\\nTime complexity `O(NlogN)`\\nSpace complexity `O(N)`\\n\\n```\\nclass Solution: \\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        ops = []\\n        for start, end, direction in shifts: \\n            direction = 2*direction-1\\n            ops.append((start, direction))\\n            ops.append((end+1, -direction))\\n        ops.sort()\\n        ans = []\\n        prefix = ii = 0 \\n        for i, ch in enumerate(s): \\n            while ii < len(ops) and ops[ii][0] == i: \\n                prefix += ops[ii][1]\\n                ii += 1\\n            ans.append(chr((ord(ch)-97+prefix)%26+97))\\n        return \\'\\'.join(ans)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n[start, 2direction-1]\\n[end+1, -2direction+1]\\n```\n```\\nclass Solution: \\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        ops = []\\n        for start, end, direction in shifts: \\n            direction = 2*direction-1\\n            ops.append((start, direction))\\n            ops.append((end+1, -direction))\\n        ops.sort()\\n        ans = []\\n        prefix = ii = 0 \\n        for i, ch in enumerate(s): \\n            while ii < len(ops) and ops[ii][0] == i: \\n                prefix += ops[ii][1]\\n                ii += 1\\n            ans.append(chr((ord(ch)-97+prefix)%26+97))\\n        return \\'\\'.join(ans)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3390639,
                "title": "java-100-faster-100-beats",
                "content": "# Code\\n```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char[] ch = s.toCharArray();\\n        int[] count = new int[s.length()+1];\\n\\n        for(int[] shift : shifts){\\n            int value = shift[2] == 1 ? 1 : -1;\\n            count[shift[0]] += value;\\n            count[shift[1] + 1] -= value;\\n        }\\n\\n        int sum = 0;\\n        for(int i = 0; i < count.length - 1; i++){\\n            sum += count[i];\\n            int newChar = ((ch[i] - \\'a\\') + sum) % 26;\\n            if(newChar < 0) newChar+= 26;\\n            ch[i] =  (char)(\\'a\\' + newChar);\\n        }\\n\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char[] ch = s.toCharArray();\\n        int[] count = new int[s.length()+1];\\n\\n        for(int[] shift : shifts){\\n            int value = shift[2] == 1 ? 1 : -1;\\n            count[shift[0]] += value;\\n            count[shift[1] + 1] -= value;\\n        }\\n\\n        int sum = 0;\\n        for(int i = 0; i < count.length - 1; i++){\\n            sum += count[i];\\n            int newChar = ((ch[i] - \\'a\\') + sum) % 26;\\n            if(newChar < 0) newChar+= 26;\\n            ch[i] =  (char)(\\'a\\' + newChar);\\n        }\\n\\n        return String.valueOf(ch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3263580,
                "title": "prefix-sum-easy-to-understand",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    const int mod = 26;\\n    string shiftingLetters(string s, vector<vector<int>>& arr) \\n    {\\n         //getting the max end value from the arr \\n         int maxval = INT_MIN;\\n         for(int i=0;i<arr.size();i++)\\n         {\\n             maxval = max(maxval,arr[i][1]);\\n         }\\n\\n         //making the prefix array \\n         vector<long long int>prefix(maxval+7,0);\\n\\n         //processing the queries\\n         for(int i=0;i<arr.size();i++)\\n         {\\n             int start = arr[i][0];\\n             int end = arr[i][1];\\n             int val = arr[i][2];\\n             bool flag = false;\\n\\n             if(val == 1) flag = true;  //true means forward shifting\\n             else if(val == 0) flag = false;  //false means backward shifting\\n\\n             if(flag == true)    //this means for this query we need forward shifting\\n             {\\n                 prefix[start]   += 1;\\n                 prefix[end+1]   -= 1;\\n             } \\n             else if(flag == false)\\n             {\\n                 prefix[start]   -= 1;\\n                 prefix[end+1]   +=1;\\n             }\\n         }\\n         for(int i=0;i<prefix.size();i++)\\n         {\\n             if(i == 0) continue;\\n           \\n             prefix[i] = prefix[i] + prefix[i-1];\\n         }\\n        //  for(int i=0;i<prefix.size();i++)\\n        //  {\\n        //      cout<<prefix[i]<<\" \";\\n        //  }\\n         for(int i=0;i<s.length();i++)\\n         {\\n             // cout<<\"i = \"<<i<<endl;\\n              char prv_ch = s[i];\\n\\n              if(prefix[i] >= 0)\\n              {\\n                   long long int val = (prv_ch - \\'a\\');\\n                   \\n                   //forward shifting\\n                   val = ((val%mod) + (prefix[i]%mod))%mod;\\n\\n                   char new_ch = \\'a\\' + val;\\n\\n                   s[i] = new_ch;\\n\\n              }\\n              else if(prefix[i] < 0)\\n              {\\n                   long long int val = (prv_ch - \\'a\\');\\n\\n                   //backward shifting\\n                   val = ((val%mod) - (abs(prefix[i])%mod) + mod)%mod;\\n\\n                   char new_ch = \\'a\\' + val;\\n\\n                   s[i] = new_ch;\\n              }\\n         }\\n         return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    const int mod = 26;\\n    string shiftingLetters(string s, vector<vector<int>>& arr) \\n    {\\n         //getting the max end value from the arr \\n         int maxval = INT_MIN;\\n         for(int i=0;i<arr.size();i++)\\n         {\\n             maxval = max(maxval,arr[i][1]);\\n         }\\n\\n         //making the prefix array \\n         vector<long long int>prefix(maxval+7,0);\\n\\n         //processing the queries\\n         for(int i=0;i<arr.size();i++)\\n         {\\n             int start = arr[i][0];\\n             int end = arr[i][1];\\n             int val = arr[i][2];\\n             bool flag = false;\\n\\n             if(val == 1) flag = true;  //true means forward shifting\\n             else if(val == 0) flag = false;  //false means backward shifting\\n\\n             if(flag == true)    //this means for this query we need forward shifting\\n             {\\n                 prefix[start]   += 1;\\n                 prefix[end+1]   -= 1;\\n             } \\n             else if(flag == false)\\n             {\\n                 prefix[start]   -= 1;\\n                 prefix[end+1]   +=1;\\n             }\\n         }\\n         for(int i=0;i<prefix.size();i++)\\n         {\\n             if(i == 0) continue;\\n           \\n             prefix[i] = prefix[i] + prefix[i-1];\\n         }\\n        //  for(int i=0;i<prefix.size();i++)\\n        //  {\\n        //      cout<<prefix[i]<<\" \";\\n        //  }\\n         for(int i=0;i<s.length();i++)\\n         {\\n             // cout<<\"i = \"<<i<<endl;\\n              char prv_ch = s[i];\\n\\n              if(prefix[i] >= 0)\\n              {\\n                   long long int val = (prv_ch - \\'a\\');\\n                   \\n                   //forward shifting\\n                   val = ((val%mod) + (prefix[i]%mod))%mod;\\n\\n                   char new_ch = \\'a\\' + val;\\n\\n                   s[i] = new_ch;\\n\\n              }\\n              else if(prefix[i] < 0)\\n              {\\n                   long long int val = (prv_ch - \\'a\\');\\n\\n                   //backward shifting\\n                   val = ((val%mod) - (abs(prefix[i])%mod) + mod)%mod;\\n\\n                   char new_ch = \\'a\\' + val;\\n\\n                   s[i] = new_ch;\\n              }\\n         }\\n         return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3160790,
                "title": "beats-91-prefix-sum-similar-to-range-addition",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \"\"\"\\n        we can apply similar concept of range addition problem to solve this\\n        problem as well\\n        \"\"\"\\n        prefix_array = [0] * (len(s)+1)\\n        for start, end, direction in shifts:\\n            counter = 1 if direction == 1 else -1\\n            prefix_array[start]+=counter\\n            prefix_array[end+1]-=counter\\n\\n        for i in range(1, len(prefix_array)):\\n            prefix_array[i]+=prefix_array[i-1]\\n\\n        result = \"\"\\n        for i in range(len(s)):\\n            new_val = (ord(s[i]) + prefix_array[i]%26)\\n            if 97 <= new_val <= 122:\\n                result+=chr(new_val)\\n            elif new_val > 122:\\n                result+=chr(new_val%123 + 97)\\n            else:\\n                result+=chr(new_val+26)\\n        return result\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \"\"\"\\n        we can apply similar concept of range addition problem to solve this\\n        problem as well\\n        \"\"\"\\n        prefix_array = [0] * (len(s)+1)\\n        for start, end, direction in shifts:\\n            counter = 1 if direction == 1 else -1\\n            prefix_array[start]+=counter\\n            prefix_array[end+1]-=counter\\n\\n        for i in range(1, len(prefix_array)):\\n            prefix_array[i]+=prefix_array[i-1]\\n\\n        result = \"\"\\n        for i in range(len(s)):\\n            new_val = (ord(s[i]) + prefix_array[i]%26)\\n            if 97 <= new_val <= 122:\\n                result+=chr(new_val)\\n            elif new_val > 122:\\n                result+=chr(new_val%123 + 97)\\n            else:\\n                result+=chr(new_val+26)\\n        return result\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3046286,
                "title": "c-o-n-solution",
                "content": "# Approach\\n-Prefix Sum\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int sh=shifts.size(),l=s.size();\\n\\n        vector<int> tshift(l+1,0);\\n        for(int i=0;i<sh;i++){\\n            tshift[shifts[i][0]]+=shifts[i][2]?1:-1;\\n            tshift[shifts[i][1]+1]-=shifts[i][2]?1:-1;\\n        }\\n        string ans;\\n        for(int i=0;i<l;i++){\\n            tshift[i]%=26;\\n            int st=(int(s[i])-97)+(tshift[i]);\\n            ans+=((26+st)%26)+97;\\n            tshift[i+1]+=tshift[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int sh=shifts.size(),l=s.size();\\n\\n        vector<int> tshift(l+1,0);\\n        for(int i=0;i<sh;i++){\\n            tshift[shifts[i][0]]+=shifts[i][2]?1:-1;\\n            tshift[shifts[i][1]+1]-=shifts[i][2]?1:-1;\\n        }\\n        string ans;\\n        for(int i=0;i<l;i++){\\n            tshift[i]%=26;\\n            int st=(int(s[i])-97)+(tshift[i]);\\n            ans+=((26+st)%26)+97;\\n            tshift[i+1]+=tshift[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2718990,
                "title": "c-o-n-time-complexity",
                "content": "# Intuition\\nAs problem is related to segments, first thought was to use segment tree. But we have to increment each character, complexity will be n^2 to update segment tree. Then prefix sum will work as shown in approach below.\\n\\n# Approach \\nFor example consider string of length 10.\\nIf we have to update string as [2,5,1].\\nWhat we can do here is, we can increment each character from 2nd position till last. But to reduce updation after 5 at position we will derement it by 1;\\n\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& sf) {\\n        int n = s.size();\\n        vector<int>pf(n+1,0);\\n        for(int i=0;i<sf.size();i++){\\n            if(sf[i][2]==0){\\n                pf[sf[i][0]] -= 1;\\n                pf[sf[i][1]+1] += 1;\\n            }else{\\n                pf[sf[i][0]] += 1;\\n                pf[sf[i][1]+1] -= 1;\\n            }\\n        }\\n\\n        int cur = 0;\\n        for(int i=0;i<n;i++){\\n            \\n            cur += pf[i];\\n\\n            cur %= 26;\\n\\n            if(cur<0)\\n                cur += 26;\\n\\n            int b =  s[i]+cur;\\n\\n            if(b>122)\\n                b = b-26;\\n\\n            s[i] = b;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& sf) {\\n        int n = s.size();\\n        vector<int>pf(n+1,0);\\n        for(int i=0;i<sf.size();i++){\\n            if(sf[i][2]==0){\\n                pf[sf[i][0]] -= 1;\\n                pf[sf[i][1]+1] += 1;\\n            }else{\\n                pf[sf[i][0]] += 1;\\n                pf[sf[i][1]+1] -= 1;\\n            }\\n        }\\n\\n        int cur = 0;\\n        for(int i=0;i<n;i++){\\n            \\n            cur += pf[i];\\n\\n            cur %= 26;\\n\\n            if(cur<0)\\n                cur += 26;\\n\\n            int b =  s[i]+cur;\\n\\n            if(b>122)\\n                b = b-26;\\n\\n            s[i] = b;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2597481,
                "title": "segment-tree-template-including-lazy-coolest-segment-tree-problem",
                "content": "**Segment Tree : Sum Template**\\n`Applications:`\\n1. Find sum in particular range.\\n2. Point Update.\\n3. Range Update\\n\\n```\\n// TC: O(NlogN);\\n// SC: (4*N) ~ O(N);\\n// Segement Trees : Implementation : Find the sum in particular range.\\n\\n// Query : TC: O(logN) for single query & O(NlogN) for n Queries\\n// Working fine : )\\nclass Segment\\n{\\n    vector<int> segmentTree, lazy;\\n    int n;\\npublic:\\n    Segment(vector<int> &arr){\\n        this->n = arr.size();\\n\\n        segmentTree.resize(4 * n + 1);\\n        lazy.resize(4 * n + 1, 0);\\n        buildSegmentTree(arr, 0, 0, n - 1);\\n    }\\n\\n    void buildSegmentTree(vector<int> &arr, int ind, int left, int right){\\n        if(left == right){\\n            segmentTree[ind] = arr[left];\\n            return;\\n        }\\n\\n        int mid = left + (right - left) / 2;\\n\\n        buildSegmentTree(arr, 2 * ind + 1, left, mid);\\n        buildSegmentTree(arr, 2 * ind + 2, mid + 1, right);\\n\\n        segmentTree[ind] = segmentTree[2 * ind + 1] + segmentTree[2 * ind + 2];\\n    }\\n    \\n    int sumBro(int ind, int left, int right, int l, int r){\\n        // Case 1 : IF current_segment comes under range...\\n        if (left >= l && right <= r){\\n            return segmentTree[ind];\\n        }\\n\\n        // Case 2 : If current_segement doesn\\'t comes in range.... :then we return 0 as answer to not pick current segment\\n        if (r < left || right < l)\\n            return 0;\\n\\n        // Case 3 : If current_segement comes partitally...\\n        int mid = left + (right - left) / 2;\\n        \\n        int leftSum = sumBro(2 * ind + 1, left, mid, l, r);\\n        int rightSum = sumBro(2 * ind + 2, mid + 1, right, l, r);\\n\\n        return leftSum + rightSum;\\n    }\\n    int getSum(int l, int r){ return sumBro(0, 0, n-1, l, r); }\\n\\n    \\n    void pointUpdate(int ind, int left, int right, int index, int value){\\n        // Doing Actual update at leaf node.\\n        if(left == right){\\n            segmentTree[ind] += value;\\n            return ;\\n        }\\n\\n        int mid = (left + right)/2;\\n\\n        // If index comes into left part, then we will update only left part and update complete component after if-else & vice versa\\n        if(index <= mid) pointUpdate(2*ind+1, left, mid, index, value);\\n        else pointUpdate(2*ind+2, mid+1, right, index, value);\\n\\n        segmentTree[ind] = segmentTree[2*ind+1] + segmentTree[2*ind+2];\\n    }\\n    void pointUpdateBro(int index, int value){ pointUpdate(0, 0, n-1, index, value); }\\n\\n    void lazyUpdate(int ind, int left, int right, int l, int r, int value){\\n        // We always do : pending updates first, then actual update.\\n        if(lazy[ind] != 0){\\n            segmentTree[ind] += (right-left+1) * lazy[ind];\\n\\n            // Propagating lazy updates if current node is having childrens...\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            } \\n\\n            // we done updating, so make current lazy_updates = 0\\n            lazy[ind] = 0;\\n        }\\n\\n        // Case 1 : If current range comes outside...\\n        if(right < l || r < left) return ;\\n\\n        // Case 2 : If current range comes inside... \\n        if(left >= l && right <= r){\\n            segmentTree[ind] += (right-left+1) * value;\\n\\n            if(left != right){\\n                lazy[2*ind+1] += value;\\n                lazy[2*ind+2] += value;\\n            }\\n            return ;\\n        }\\n\\n        // Case 3: Partial Overlap\\n        int mid = left + (right-left)/2;\\n\\n        lazyUpdate(2 * ind + 1, left, mid, l, r, value);\\n        lazyUpdate(2 * ind + 2, mid+1, right, l, r, value);\\n\\n        segmentTree[ind] = segmentTree[2 * ind + 1] + segmentTree[2 * ind + 2];\\n    }\\n    void lazyUpdateBro(int l, int r, int value){ lazyUpdate(0, 0, n-1, l, r, value); }\\n\\n    int querySumLazy(int ind, int left, int right, int l, int r){\\n        // Executing pending updates at first.\\n        if(lazy[ind]){\\n            segmentTree[ind] += (right - left + 1) * lazy[ind];\\n            \\n            // If current node is not leaf node, then we have to propagate updates to childrens.\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            }\\n            \\n            // We, are done updating : )\\n            lazy[ind] = 0;\\n        }\\n\\n        // Case 1: If range is completely outside...\\n        if(r < left || right < l || left > right) return 0;\\n\\n        // Case 2: If range is completely inside...\\n        if(left >= l && right <= r) return segmentTree[ind];\\n\\n        // Case 3: If range is partially inside or partially outside...\\n        int mid = (right + left)/2;\\n        \\n        int leftSide = querySumLazy(2*ind+1, left, mid, l, r);\\n        int rightSide = querySumLazy(2*ind+2, mid+1, right, l, r);\\n        \\n        return leftSide + rightSide;\\n    }\\n    int getSumLazy(int l, int r) { return querySumLazy(0, 0, n- 1, l, r); }\\n\\n    void printSegmentTree(){\\n        for(int i : segmentTree) cout<<i<<\" \"; \\n        cout<<endl;\\n    }\\n\\n    int printSegmentTreeSum(){\\n        return segmentTree[0];\\n    }\\n};\\n```\\n\\n**Approach : Straighforward Range update in Segment Tree**\\n\\n```\\n#define ll long long\\nclass Segment{\\n    int n;\\n    vector<ll> segmentTree, lazy;\\npublic:\\n    Segment(int n){\\n        this->n = n;\\n        \\n        segmentTree.resize(4 * n, 0);\\n        lazy.resize(4 * n, 0);\\n    }\\n    \\n    void rangeUpdate(int ind, int left, int right, int l, int r, int value){\\n        // Executing pending updates at first.\\n        if(lazy[ind] != 0){\\n            segmentTree[ind] += (right - left + 1) * lazy[ind]; \\n            \\n            // If current node is not leaf, node means we have to propagate lazy updates to its childrens.\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            }\\n            \\n            // We have done all pending updates.\\n            lazy[ind] = 0;\\n        }\\n        \\n        // Case 1 : If current segment is out of range.\\n        if(right < l || r < left) return ;\\n        \\n        // Case 2 : If current segment completely lies in range.\\n        if(l <= left && right <= r){\\n            segmentTree[ind] += (right - left + 1) * (value);\\n            \\n            if(left != right){\\n                lazy[2*ind+1] += value;\\n                lazy[2*ind+2] += value;\\n            }\\n            return ;\\n        }\\n        \\n        // Case 3 : If current segment lies partially.\\n        int mid = left + (right-left)/2;\\n        \\n        rangeUpdate(2 * ind + 1, left, mid, l, r, value);\\n        rangeUpdate(2 * ind + 2, mid + 1, right, l, r, value);\\n        \\n        segmentTree[ind] = segmentTree[2 * ind + 1] + segmentTree[2 * ind + 2];\\n    }\\n    \\n    void rangeUpdateQuery(int l, int r, int value){\\n        rangeUpdate(0, 0, n-1, l, r, value);\\n    }\\n    \\n    int querySumLazy(int ind, int left, int right, int l, int r){\\n        // Executing pending updates at first.\\n        if(lazy[ind]){\\n            segmentTree[ind] += (right - left + 1) * lazy[ind];\\n            \\n            // If current node is not leaf node, then we have to propagate updates to childrens.\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            }\\n            \\n            // We, are done updating : )\\n            lazy[ind] = 0;\\n        }\\n\\n        // Case 1 : If range is completely outside...\\n        if(r < left || right < l) return 0;\\n\\n        // Case 2 : If range is completely inside...\\n        if(left >= l && right <= r) return segmentTree[ind];\\n\\n        // Case 3 : If range is partially inside or partially outside...\\n        int mid = (right + left)/2;\\n        \\n        int leftSide = querySumLazy(2*ind+1, left, mid, l, r);\\n        int rightSide = querySumLazy(2*ind+2, mid+1, right, l, r);\\n        \\n        return leftSide + rightSide;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {        \\n        Segment sT(s.size());\\n\\n        // Doing Range Update in Segement trees \\n        for(auto &shift : shifts){\\n            sT.rangeUpdateQuery(shift[0], shift[1], shift[2] ? 1 : -1);\\n        }\\n        \\n        \\n        for(int i = 0; i < s.size(); i++){\\n            // Fetching element updates which need to be done on current character...\\n            int element = (sT.querySumLazy(0, 0, s.size()-1, i,i) + s[i] - \\'a\\');    \\n            \\n            // If after adding update, if our character goes negative-outside-region of our lowercase range [a....z]\\n            // Then we need to subtract the nodes difference from the end...\\n            if(((element%26) + \\'a\\') < 97) s[i] = (char)(123 + (element%26));\\n            \\n            // Otherwise, if current element is in lowercase range, we will add it into answer...\\n            else s[i] = (char)((element%26) + \\'a\\');\\n        }\\n\\n        return s;\\n    }\\n};\\n```\\n\\n**Doubts, Queries & Better Approaches are most welcome\\uD83C\\uDF3B**",
                "solutionTags": [],
                "code": "```\\n// TC: O(NlogN);\\n// SC: (4*N) ~ O(N);\\n// Segement Trees : Implementation : Find the sum in particular range.\\n\\n// Query : TC: O(logN) for single query & O(NlogN) for n Queries\\n// Working fine : )\\nclass Segment\\n{\\n    vector<int> segmentTree, lazy;\\n    int n;\\npublic:\\n    Segment(vector<int> &arr){\\n        this->n = arr.size();\\n\\n        segmentTree.resize(4 * n + 1);\\n        lazy.resize(4 * n + 1, 0);\\n        buildSegmentTree(arr, 0, 0, n - 1);\\n    }\\n\\n    void buildSegmentTree(vector<int> &arr, int ind, int left, int right){\\n        if(left == right){\\n            segmentTree[ind] = arr[left];\\n            return;\\n        }\\n\\n        int mid = left + (right - left) / 2;\\n\\n        buildSegmentTree(arr, 2 * ind + 1, left, mid);\\n        buildSegmentTree(arr, 2 * ind + 2, mid + 1, right);\\n\\n        segmentTree[ind] = segmentTree[2 * ind + 1] + segmentTree[2 * ind + 2];\\n    }\\n    \\n    int sumBro(int ind, int left, int right, int l, int r){\\n        // Case 1 : IF current_segment comes under range...\\n        if (left >= l && right <= r){\\n            return segmentTree[ind];\\n        }\\n\\n        // Case 2 : If current_segement doesn\\'t comes in range.... :then we return 0 as answer to not pick current segment\\n        if (r < left || right < l)\\n            return 0;\\n\\n        // Case 3 : If current_segement comes partitally...\\n        int mid = left + (right - left) / 2;\\n        \\n        int leftSum = sumBro(2 * ind + 1, left, mid, l, r);\\n        int rightSum = sumBro(2 * ind + 2, mid + 1, right, l, r);\\n\\n        return leftSum + rightSum;\\n    }\\n    int getSum(int l, int r){ return sumBro(0, 0, n-1, l, r); }\\n\\n    \\n    void pointUpdate(int ind, int left, int right, int index, int value){\\n        // Doing Actual update at leaf node.\\n        if(left == right){\\n            segmentTree[ind] += value;\\n            return ;\\n        }\\n\\n        int mid = (left + right)/2;\\n\\n        // If index comes into left part, then we will update only left part and update complete component after if-else & vice versa\\n        if(index <= mid) pointUpdate(2*ind+1, left, mid, index, value);\\n        else pointUpdate(2*ind+2, mid+1, right, index, value);\\n\\n        segmentTree[ind] = segmentTree[2*ind+1] + segmentTree[2*ind+2];\\n    }\\n    void pointUpdateBro(int index, int value){ pointUpdate(0, 0, n-1, index, value); }\\n\\n    void lazyUpdate(int ind, int left, int right, int l, int r, int value){\\n        // We always do : pending updates first, then actual update.\\n        if(lazy[ind] != 0){\\n            segmentTree[ind] += (right-left+1) * lazy[ind];\\n\\n            // Propagating lazy updates if current node is having childrens...\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            } \\n\\n            // we done updating, so make current lazy_updates = 0\\n            lazy[ind] = 0;\\n        }\\n\\n        // Case 1 : If current range comes outside...\\n        if(right < l || r < left) return ;\\n\\n        // Case 2 : If current range comes inside... \\n        if(left >= l && right <= r){\\n            segmentTree[ind] += (right-left+1) * value;\\n\\n            if(left != right){\\n                lazy[2*ind+1] += value;\\n                lazy[2*ind+2] += value;\\n            }\\n            return ;\\n        }\\n\\n        // Case 3: Partial Overlap\\n        int mid = left + (right-left)/2;\\n\\n        lazyUpdate(2 * ind + 1, left, mid, l, r, value);\\n        lazyUpdate(2 * ind + 2, mid+1, right, l, r, value);\\n\\n        segmentTree[ind] = segmentTree[2 * ind + 1] + segmentTree[2 * ind + 2];\\n    }\\n    void lazyUpdateBro(int l, int r, int value){ lazyUpdate(0, 0, n-1, l, r, value); }\\n\\n    int querySumLazy(int ind, int left, int right, int l, int r){\\n        // Executing pending updates at first.\\n        if(lazy[ind]){\\n            segmentTree[ind] += (right - left + 1) * lazy[ind];\\n            \\n            // If current node is not leaf node, then we have to propagate updates to childrens.\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            }\\n            \\n            // We, are done updating : )\\n            lazy[ind] = 0;\\n        }\\n\\n        // Case 1: If range is completely outside...\\n        if(r < left || right < l || left > right) return 0;\\n\\n        // Case 2: If range is completely inside...\\n        if(left >= l && right <= r) return segmentTree[ind];\\n\\n        // Case 3: If range is partially inside or partially outside...\\n        int mid = (right + left)/2;\\n        \\n        int leftSide = querySumLazy(2*ind+1, left, mid, l, r);\\n        int rightSide = querySumLazy(2*ind+2, mid+1, right, l, r);\\n        \\n        return leftSide + rightSide;\\n    }\\n    int getSumLazy(int l, int r) { return querySumLazy(0, 0, n- 1, l, r); }\\n\\n    void printSegmentTree(){\\n        for(int i : segmentTree) cout<<i<<\" \"; \\n        cout<<endl;\\n    }\\n\\n    int printSegmentTreeSum(){\\n        return segmentTree[0];\\n    }\\n};\\n```\n```\\n#define ll long long\\nclass Segment{\\n    int n;\\n    vector<ll> segmentTree, lazy;\\npublic:\\n    Segment(int n){\\n        this->n = n;\\n        \\n        segmentTree.resize(4 * n, 0);\\n        lazy.resize(4 * n, 0);\\n    }\\n    \\n    void rangeUpdate(int ind, int left, int right, int l, int r, int value){\\n        // Executing pending updates at first.\\n        if(lazy[ind] != 0){\\n            segmentTree[ind] += (right - left + 1) * lazy[ind]; \\n            \\n            // If current node is not leaf, node means we have to propagate lazy updates to its childrens.\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            }\\n            \\n            // We have done all pending updates.\\n            lazy[ind] = 0;\\n        }\\n        \\n        // Case 1 : If current segment is out of range.\\n        if(right < l || r < left) return ;\\n        \\n        // Case 2 : If current segment completely lies in range.\\n        if(l <= left && right <= r){\\n            segmentTree[ind] += (right - left + 1) * (value);\\n            \\n            if(left != right){\\n                lazy[2*ind+1] += value;\\n                lazy[2*ind+2] += value;\\n            }\\n            return ;\\n        }\\n        \\n        // Case 3 : If current segment lies partially.\\n        int mid = left + (right-left)/2;\\n        \\n        rangeUpdate(2 * ind + 1, left, mid, l, r, value);\\n        rangeUpdate(2 * ind + 2, mid + 1, right, l, r, value);\\n        \\n        segmentTree[ind] = segmentTree[2 * ind + 1] + segmentTree[2 * ind + 2];\\n    }\\n    \\n    void rangeUpdateQuery(int l, int r, int value){\\n        rangeUpdate(0, 0, n-1, l, r, value);\\n    }\\n    \\n    int querySumLazy(int ind, int left, int right, int l, int r){\\n        // Executing pending updates at first.\\n        if(lazy[ind]){\\n            segmentTree[ind] += (right - left + 1) * lazy[ind];\\n            \\n            // If current node is not leaf node, then we have to propagate updates to childrens.\\n            if(left != right){\\n                lazy[2*ind+1] += lazy[ind];\\n                lazy[2*ind+2] += lazy[ind];\\n            }\\n            \\n            // We, are done updating : )\\n            lazy[ind] = 0;\\n        }\\n\\n        // Case 1 : If range is completely outside...\\n        if(r < left || right < l) return 0;\\n\\n        // Case 2 : If range is completely inside...\\n        if(left >= l && right <= r) return segmentTree[ind];\\n\\n        // Case 3 : If range is partially inside or partially outside...\\n        int mid = (right + left)/2;\\n        \\n        int leftSide = querySumLazy(2*ind+1, left, mid, l, r);\\n        int rightSide = querySumLazy(2*ind+2, mid+1, right, l, r);\\n        \\n        return leftSide + rightSide;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {        \\n        Segment sT(s.size());\\n\\n        // Doing Range Update in Segement trees \\n        for(auto &shift : shifts){\\n            sT.rangeUpdateQuery(shift[0], shift[1], shift[2] ? 1 : -1);\\n        }\\n        \\n        \\n        for(int i = 0; i < s.size(); i++){\\n            // Fetching element updates which need to be done on current character...\\n            int element = (sT.querySumLazy(0, 0, s.size()-1, i,i) + s[i] - \\'a\\');    \\n            \\n            // If after adding update, if our character goes negative-outside-region of our lowercase range [a....z]\\n            // Then we need to subtract the nodes difference from the end...\\n            if(((element%26) + \\'a\\') < 97) s[i] = (char)(123 + (element%26));\\n            \\n            // Otherwise, if current element is in lowercase range, we will add it into answer...\\n            else s[i] = (char)((element%26) + \\'a\\');\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2543352,
                "title": "c-line-sweep-easy",
                "content": "```\\nclass Solution {\\n  public:\\n    string shiftingLetters(string s, vector < vector < int >> & shifts) {\\n      sort(shifts.begin(), shifts.end());\\n      int n = s.length();\\n      // to store the cummulative sum \\n      vector < int > line(n + 1, 0);\\n      for (int i = 0; i < shifts.size(); i++) {\\n        auto shift = shifts[i];\\n        // setting the starting point\\n        if (shift[2]) {\\n          line[shift[0]] += 1;\\n        }\\n         else {\\n          line[shift[0]] -= 1;\\n        }\\n        // setting the ending point\\n        if (shift[1] < n - 1) {\\n          if (shift[2]) {\\n            line[shift[1] + 1] -= 1;\\n          } else {\\n            line[shift[1] + 1] += 1;\\n          }\\n        }\\n      }\\n      for (int i = 1; i < n; i++) {\\n        line[i] += line[i - 1];\\n      }\\n      for (int i = 0; i < n; i++) {\\n        if (line[i] == 0) continue;\\n        line[i] %= 26;\\n        s[i] = (s[i] - \\'a\\' + line[i] + 26) % 26 + \\'a\\';\\n      }\\n      return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n  public:\\n    string shiftingLetters(string s, vector < vector < int >> & shifts) {\\n      sort(shifts.begin(), shifts.end());\\n      int n = s.length();\\n      // to store the cummulative sum \\n      vector < int > line(n + 1, 0);\\n      for (int i = 0; i < shifts.size(); i++) {\\n        auto shift = shifts[i];\\n        // setting the starting point\\n        if (shift[2]) {\\n          line[shift[0]] += 1;\\n        }\\n         else {\\n          line[shift[0]] -= 1;\\n        }\\n        // setting the ending point\\n        if (shift[1] < n - 1) {\\n          if (shift[2]) {\\n            line[shift[1] + 1] -= 1;\\n          } else {\\n            line[shift[1] + 1] += 1;\\n          }\\n        }\\n      }\\n      for (int i = 1; i < n; i++) {\\n        line[i] += line[i - 1];\\n      }\\n      for (int i = 0; i < n; i++) {\\n        if (line[i] == 0) continue;\\n        line[i] %= 26;\\n        s[i] = (s[i] - \\'a\\' + line[i] + 26) % 26 + \\'a\\';\\n      }\\n      return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512848,
                "title": "98-faster-concise-t-c-o-n-explained",
                "content": "**PLS UPVOTE IF you like the SOLUTION!!!**\\n**IDEA:-**\\nWE HAVE THREE PARTS FOR THIS QUESTION \\n**1. LINE SWEEP**\\n we use this technique because its efficient as compared to increase a given range by 1 by visiting each and every element.\\n In this technique to achieve the same we mark only the first index of the range suppose increment by 1 (if direction is forward) and decrement the (last index+1 ) by 1.\\n Now move to the next step.\\n**2. PREFIX SUM**\\n\\tNow after using the technique you just have to take the prefix sum and you will notice that we have achieved the same thing and this method is very efficient as it runs in O(N) runtime as compared to earlier O(N^2) which will give TLE in this question.\\n**3. SHIFTING LETTERS**\\nwe use the statement provided in the code to shift the letters.\\n\\n**T.C:-** O(N)  **S.C:-** O(N)\\n\\t\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        vector<int>vec(s.length(),0);\\n        //FOR LINE SWEEP\\n        for(int i{0};i<shifts.size();++i){\\n            if(shifts[i][2]==0){\\n                vec.at(shifts[i][0])--;\\n                if(shifts[i][1]+1<vec.size()){\\n                    vec.at(shifts[i][1]+1)++;\\n                }\\n            }else{\\n                vec.at(shifts[i][0])++;\\n                if(shifts[i][1]+1<vec.size()){\\n                    vec.at(shifts[i][1]+1)--;\\n                }\\n            }\\n        }\\n        //FOR PREFIX SUM\\n        for(int i{1};i<vec.size();++i){\\n            vec.at(i)=vec.at(i)+vec.at(i-1);\\n        }\\n        //FOR SHIFTING LETTERS\\n        for(int i{0};i<vec.size();++i){\\n            s[i]=\\'a\\'+ (26+(s[i]-\\'a\\')+vec.at(i)%26)%26;   \\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        vector<int>vec(s.length(),0);\\n        //FOR LINE SWEEP\\n        for(int i{0};i<shifts.size();++i){\\n            if(shifts[i][2]==0){\\n                vec.at(shifts[i][0])--;\\n                if(shifts[i][1]+1<vec.size()){\\n                    vec.at(shifts[i][1]+1)++;\\n                }\\n            }else{\\n                vec.at(shifts[i][0])++;\\n                if(shifts[i][1]+1<vec.size()){\\n                    vec.at(shifts[i][1]+1)--;\\n                }\\n            }\\n        }\\n        //FOR PREFIX SUM\\n        for(int i{1};i<vec.size();++i){\\n            vec.at(i)=vec.at(i)+vec.at(i-1);\\n        }\\n        //FOR SHIFTING LETTERS\\n        for(int i{0};i<vec.size();++i){\\n            s[i]=\\'a\\'+ (26+(s[i]-\\'a\\')+vec.at(i)%26)%26;   \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496267,
                "title": "python3-line-sweep-o-n-simple",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \\n        def helper(char,val):\\n            return chr(ord(\\'a\\')+(ord(char)-ord(\\'a\\')+val%26)%26)\\n        \\n        n=len(s)\\n        arr=[0 for _ in range(n)]\\n        for start,e,d in shifts:\\n            arr[start]+=1 if d else -1\\n            if e+1<n: arr[e+1]-=1 if d else -1\\n        for i in range(1,n):\\n            arr[i]+=arr[i-1]\\n        for i in range(n):\\n            arr[i]=helper(s[i],arr[i])\\n        return \\'\\'.join(arr)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \\n        def helper(char,val):\\n            return chr(ord(\\'a\\')+(ord(char)-ord(\\'a\\')+val%26)%26)\\n        \\n        n=len(s)\\n        arr=[0 for _ in range(n)]\\n        for start,e,d in shifts:\\n            arr[start]+=1 if d else -1\\n            if e+1<n: arr[e+1]-=1 if d else -1\\n        for i in range(1,n):\\n            arr[i]+=arr[i-1]\\n        for i in range(n):\\n            arr[i]=helper(s[i],arr[i])\\n        return \\'\\'.join(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485096,
                "title": "scanline-algorithm",
                "content": "\\n\\n\\n\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        // Scanline Algorithm\\n        vector<int> prefix(n);\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            (shifts[i][2]==1)?prefix[shifts[i][0]]+=1 : prefix[shifts[i][0]]-=1;\\n            if(shifts[i][1] + 1<n) (shifts[i][2]==1)?prefix[shifts[i][1] + 1]-=1 : prefix[shifts[i][1]+1]+=1;\\n        }\\n        \\n        for(int i=1;i<n;i++)\\n        {\\n            prefix[i]+=prefix[i-1];    // prefix sum  // to calculate how many times a particular index is changed\\n        }\\n        \\n        for(int i=0;i<s.size();i++)\\n        {\\n            prefix[i]%=26;    // to keep offset within 26 as a-z are 26\\n            \\n            if(int(s[i])+prefix[i] < 97) \\n            {\\n                s[i] = char(int(s[i])+prefix[i]+26); // ascii value of a-z are from 97 to 122;\\n            }\\n            else if(int(s[i])+prefix[i]>122)\\n            {\\n                s[i] = char(int(s[i])+prefix[i]-26);\\n            }\\n            else\\n            {\\n                s[i] = char(int(s[i])+prefix[i]);\\n            }\\n        }\\n        return s;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        // Scanline Algorithm\\n        vector<int> prefix(n);\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            (shifts[i][2]==1)?prefix[shifts[i][0]]+=1 : prefix[shifts[i][0]]-=1;\\n            if(shifts[i][1] + 1<n) (shifts[i][2]==1)?prefix[shifts[i][1] + 1]-=1 : prefix[shifts[i][1]+1]+=1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2485017,
                "title": "easy-c-faster-then-80-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=shifts.size();\\n        vector<int>dp(s.size(),0);\\n        for(int i=0;i<n;i++){\\n            if(shifts[i][2]==0){\\n                dp[shifts[i][0]]-=1;\\n                if(shifts[i][1]<s.size()-1){\\n                    dp[shifts[i][1]+1]+=1;\\n                }\\n               }\\n            else{\\n                 dp[shifts[i][0]]+=1;\\n                if(shifts[i][1]<s.size()-1){\\n                    dp[shifts[i][1]+1]-=1;\\n                }\\n\\t\\t\\t}\\n        }\\n        for(int i=1;i<s.size();i++){\\n            dp[i]=dp[i-1]+dp[i];   //Saving no of movement required \\n        }\\n\\t\\t//some aptitude maths \\n        for(int i=0;i<s.size();i++){\\n            dp[i]=dp[i]%26;\\n            if(dp[i]+s[i]>\\'z\\'){\\n                char indx=dp[i]+s[i]-\\'z\\';\\n                s[i]=\\'a\\'+indx-1;\\n            }\\n            else if (dp[i]+s[i]<\\'a\\'){\\n                s[i]=s[i]+(26+dp[i]);\\n            }\\n            else\\n                s[i]=s[i]+dp[i];  \\n        }\\n        return s;\\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=shifts.size();\\n        vector<int>dp(s.size(),0);\\n        for(int i=0;i<n;i++){\\n            if(shifts[i][2]==0){\\n                dp[shifts[i][0]]-=1;\\n                if(shifts[i][1]<s.size()-1){\\n                    dp[shifts[i][1]+1]+=1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2476492,
                "title": "best-easiest-solution-in-c",
                "content": "***Please Upvote if U liked my solution***\\n\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n\\t\\n        int size=s.size();\\n        vector<int> vec(size+1);\\n        for(auto it:shifts){\\n            int start=it[0],end=it[1],dir=it[2];\\n            if(dir==1){\\n                vec[start]+=1;\\n                vec[end+1]+=-1;\\n            }\\n            else{\\n                vec[start]+=-1;\\n                vec[end+1]+=1;\\n            }\\n        }\\n        int prefixSum=0;\\n        for(int i=0;i<size;i++){\\n            prefixSum+=vec[i];\\n            while(prefixSum<0)\\n                prefixSum+=26;\\n            s[i]=(char)(\\'a\\'+(((s[i]-\\'a\\')+prefixSum)%26));\\n        }   \\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n\\t\\n        int size=s.size();\\n        vector<int> vec(size+1);\\n        for(auto it:shifts){\\n            int start=it[0],end=it[1],dir=it[2];\\n            if(dir==1){\\n                vec[start]+=1;\\n                vec[end+1]+=-1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2476153,
                "title": "java-range-caching",
                "content": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        // shifts[i] = [starti, endi, directioni]\\n        char[] ch = s.toCharArray();\\n        int n = s.length();\\n        int[] count = new int[s.length()+1];\\n        for(int[] shift : shifts){\\n            int starti = shift[0];\\n            int endi = shift[1];\\n            int directioni = shift[2];\\n            if(directioni == 1){\\n                count[starti] = count[starti] + 1;\\n                count[endi + 1] = count[endi + 1] - 1;\\n            }\\n            else{\\n                count[starti] = count[starti] - 1;\\n                count[endi + 1] = count[endi + 1] + 1;\\n            }\\n        }\\n        \\n        int temp = 0;\\n        for(int i = 0; i < count.length -1; i++){\\n            temp = temp + count[i];\\n            int newChar = ((ch[i] - \\'a\\') + temp) % 26;\\n            newChar = newChar < 0 ? newChar + 26 : newChar;\\n            ch[i] = (char)(\\'a\\' + newChar);\\n        }\\n        return String.valueOf(ch);\\n    }       \\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        // shifts[i] = [starti, endi, directioni]\\n        char[] ch = s.toCharArray();\\n        int n = s.length();\\n        int[] count = new int[s.length()+1];\\n        for(int[] shift : shifts){\\n            int starti = shift[0];\\n            int endi = shift[1];\\n            int directioni = shift[2];\\n            if(directioni == 1){\\n                count[starti] = count[starti] + 1;\\n                count[endi + 1] = count[endi + 1] - 1;\\n            }\\n            else{\\n                count[starti] = count[starti] - 1;\\n                count[endi + 1] = count[endi + 1] + 1;\\n            }\\n        }\\n        \\n        int temp = 0;\\n        for(int i = 0; i < count.length -1; i++){\\n            temp = temp + count[i];\\n            int newChar = ((ch[i] - \\'a\\') + temp) % 26;\\n            newChar = newChar < 0 ? newChar + 26 : newChar;\\n            ch[i] = (char)(\\'a\\' + newChar);\\n        }\\n        return String.valueOf(ch);\\n    }       \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472774,
                "title": "python3-line-sweep-method-with-hashmap",
                "content": "Note that for one who doesn\\'t know about line sweep technique, there will be a test case with enormous length giving TLE.\\n\\nFor knowing what character will become after shifting **n** position forward, we can use a list to achieve that purpose.\\nAs there will be only lower letter, we can assign \"a\" ~ \"z\" to a list of length 26.\\nFor instance, to know what character will be given after shifting \"a\" 3 times forward, the answer will be :\\n**lettermap[ ( ord(\"a\") - 97 + 3 ) % 26 ]** = \"d\"\\n\\nNext is to determine how to shift each character efficiently. It will be time-consuming if one goes to all characters between start and end of an interval then do the same to all intervals. \\nBy applying line sweep, the time complexity could be reduced substantially to linear time.\\n\\nTo see the idea of line sweep : \\n![image](https://assets.leetcode.com/users/images/1babae20-e732-41c5-9d33-c24ec3806bd1_1661335019.4304667.png)\\n\\nAfter iterating all shifting intervals and keep track of the shift offset starting at specific index,\\nwe can get the number of shifts starting at each index then use this information to perform character shifting.\\n\\n![image](https://assets.leetcode.com/users/images/0f4c25f2-6cd0-4b55-870e-e281a04ca38f_1661336267.0428574.png)\\n\\n\\n```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        # As in Python string is immutable, so need to convert it into character list.\\n        arr = list(s)\\n        n = len(arr)\\n        \\n        # Since there are only lowercase letter, we can use a list to serve the need for referring shifting character.\\n        maplist = [chr(i) for i in range(97, 123)]\\n        shiftmap = defaultdict(int)\\n        \\n        # shiftmap[i] = d means all characters from ith index to the end of the string\\n        # need to be shifted forward d times (if d < 0, shift backward.)\\n        # For each interval, we only need to use start and (end + 1) index.\\n        for start, end, direct in shifts:\\n            d = 1 if direct == 1 else -1\\n            shiftmap[start] += d\\n            if end + 1 < n: # we only care about index < length of s\\n                shiftmap[end + 1] -= d\\n        \\n        # Iterate each index and check its shift offset from the map\\n        # update the offset continuously then find the character after shifting the accumulated offset.\\n        offset = 0\\n        for i in range(n):\\n            if shiftmap[i] != 0:\\n                offset += shiftmap[i]\\n            arr[i] = maplist[(ord(arr[i]) - 97 + offset) % 26]\\n        \\n        return \"\".join(arr)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import defaultdict\\n\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        # As in Python string is immutable, so need to convert it into character list.\\n        arr = list(s)\\n        n = len(arr)\\n        \\n        # Since there are only lowercase letter, we can use a list to serve the need for referring shifting character.\\n        maplist = [chr(i) for i in range(97, 123)]\\n        shiftmap = defaultdict(int)\\n        \\n        # shiftmap[i] = d means all characters from ith index to the end of the string\\n        # need to be shifted forward d times (if d < 0, shift backward.)\\n        # For each interval, we only need to use start and (end + 1) index.\\n        for start, end, direct in shifts:\\n            d = 1 if direct == 1 else -1\\n            shiftmap[start] += d\\n            if end + 1 < n: # we only care about index < length of s\\n                shiftmap[end + 1] -= d\\n        \\n        # Iterate each index and check its shift offset from the map\\n        # update the offset continuously then find the character after shifting the accumulated offset.\\n        offset = 0\\n        for i in range(n):\\n            if shiftmap[i] != 0:\\n                offset += shiftmap[i]\\n            arr[i] = maplist[(ord(arr[i]) - 97 + offset) % 26]\\n        \\n        return \"\".join(arr)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467047,
                "title": "very-easy-explanation-brute-force-prefix-sum-optimized",
                "content": "* **Brute Force ( Time Limit Exceed )**\\n\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        for(auto it:shifts){\\n            int l=it[0];\\n            int r=it[1];\\n            int dir=it[2];\\n            if(dir==1){\\n                for(int i=l;i<=r;i++)\\n                {\\n                    if(s[i]==\\'z\\') s[i]=\\'a\\';\\n                    else s[i]+=1;\\n                }\\n            }\\n            else{\\n                 for(int i=l;i<=r;i++)\\n                {\\n                    if(s[i]==\\'a\\') s[i]=\\'z\\';\\n                    else s[i]-=1;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\\n*  **Prefix Sum ( Optimized )**\\n\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int>offset(n+1,0);\\n        for(auto it:shifts){\\n            int l=it[0];\\n            int r=it[1];\\n            int dir=it[2];\\n            if(dir==0){                // go backward by -1\\n               offset[l]+=-1;\\n               offset[r+1]+=1;\\n            }\\n            else{                   // go forward by +1\\n              offset[l]+=1;\\n              offset[r+1]+=-1;\\n            }\\n        }\\n        int prefix=0;\\n        for(int i=0;i<n;i++){\\n            prefix+=offset[i];\\n            while(prefix<0) prefix+=26;    // to cycle in \\'a\\'(97) to \\'z\\'(122) (negative remainder thrm)\\n            int ch=(s[i]-\\'a\\'+prefix)%26;  // jb tk 26 ke range me na a jaye tb tk prefix+=26 krte rho\\n            s[i]=char(\\'a\\'+ch);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        for(auto it:shifts){\\n            int l=it[0];\\n            int r=it[1];\\n            int dir=it[2];\\n            if(dir==1){\\n                for(int i=l;i<=r;i++)\\n                {\\n                    if(s[i]==\\'z\\') s[i]=\\'a\\';\\n                    else s[i]+=1;\\n                }\\n            }\\n            else{\\n                 for(int i=l;i<=r;i++)\\n                {\\n                    if(s[i]==\\'a\\') s[i]=\\'z\\';\\n                    else s[i]-=1;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int>offset(n+1,0);\\n        for(auto it:shifts){\\n            int l=it[0];\\n            int r=it[1];\\n            int dir=it[2];\\n            if(dir==0){                // go backward by -1\\n               offset[l]+=-1;\\n               offset[r+1]+=1;\\n            }\\n            else{                   // go forward by +1\\n              offset[l]+=1;\\n              offset[r+1]+=-1;\\n            }\\n        }\\n        int prefix=0;\\n        for(int i=0;i<n;i++){\\n            prefix+=offset[i];\\n            while(prefix<0) prefix+=26;    // to cycle in \\'a\\'(97) to \\'z\\'(122) (negative remainder thrm)\\n            int ch=(s[i]-\\'a\\'+prefix)%26;  // jb tk 26 ke range me na a jaye tb tk prefix+=26 krte rho\\n            s[i]=char(\\'a\\'+ch);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460326,
                "title": "rust-linear-solution-almost-all-contest-front-runners-use",
                "content": "\\n~~~\\nimpl Solution {\\n    pub fn shifting_letters(s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let n = s.len();\\n        let mut data = vec![0; n + 1];\\n        \\n        for shift in shifts {\\n            let amt = if shift[2] == 1 { 1 } else { -1 };\\n            data[s[0] as usize] += amt;\\n            data[s[1] as usize + 1] -= amt;\\n        }\\n        \\n        for i in 0..n {\\n            if i > 0 { data[i] = data[i] + data[i - 1]; }\\n            data[i] %= 26;\\n            if data[i] < 0 { data[i] += 26; }\\n        }\\n        \\n        let mut s = s.chars().collect::<Vec<char>>();\\n        for i in 0..n {\\n            s[i] = (\\'a\\' as u8 + (s[i] as u8 - \\'a\\' as u8 + data[i] as u8) % 26) as char;\\n        }\\n        \\n        s.iter().collect()\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust"
                ],
                "code": "\\n~~~\\nimpl Solution {\\n    pub fn shifting_letters(s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let n = s.len();\\n        let mut data = vec![0; n + 1];\\n        \\n        for shift in shifts {\\n            let amt = if shift[2] == 1 { 1 } else { -1 };\\n            data[s[0] as usize] += amt;\\n            data[s[1] as usize + 1] -= amt;\\n        }\\n        \\n        for i in 0..n {\\n            if i > 0 { data[i] = data[i] + data[i - 1]; }\\n            data[i] %= 26;\\n            if data[i] < 0 { data[i] += 26; }\\n        }\\n        \\n        let mut s = s.chars().collect::<Vec<char>>();\\n        for i in 0..n {\\n            s[i] = (\\'a\\' as u8 + (s[i] as u8 - \\'a\\' as u8 + data[i] as u8) % 26) as char;\\n        }\\n        \\n        s.iter().collect()\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2458908,
                "title": "square-root-decompostion",
                "content": "Hello Friends,\\nThis question can be easily done by prefix-sum array but here I want to give an approach of sqaure root decomposition. First of all learning sqaure root decomposition is an way to solve range queries question. Generally this has time complexity of sqrt(n)*n;\\nl=shifts[i][0];\\nr=shifts[i][1];\\n\\nPrerequiste : Sqaure Root Decomposition \\n\\nAll the questions of SQRTD has a common structure so learning only question will push you to solve this one.\\nFor practicing you can solve \\nhttps://www.spoj.com/problems/RMQSQ/\\n\\nAfter this you will get this without any explaination.\\n\\n\\'\\'\\'\\n\\n\\t class Solution {\\n    \\n     public:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n=s.size();\\n        int blk=sqrt(n);\\n        int siz=ceil(n*1.0/blk);\\n        vector<int> f(siz,0);\\n        vector<int> arr(n,0);\\n        \\n        for(auto x: shifts){\\n            \\n            int l=x[0];\\n            int r=x[1];\\n            int add=x[2]==1?1:-1;\\n            int lb=l/blk;\\n            int rb=r/blk;\\n            if(lb==rb){\\n                for(int i=l;i<=r;i++){\\n                    arr[i]+=add;\\n                }\\n            }\\n            else{\\n                \\n                for(int i=l;i<blk*(lb+1);i++){\\n                    arr[i]+=add;\\n                }\\n              \\n                for(int i=lb+1;i<rb;i++){\\n                    f[i]+=add;\\n                }\\n                \\n                for(int i=blk*rb;i<=r;i++){\\n                    arr[i]+=add;\\n                }\\n             \\n            }\\n           \\n            \\n        }\\n        \\n        \\n       \\n        \\n     \\n       \\n        for(int i=0;i<n;i++){\\n           \\n            int change=arr[i]+f[i/blk];\\n            int k=change%26;\\n            int p1=(s[i]-\\'a\\'+k+26)%26;\\n            s[i]=char(\\'a\\'+p1);\\n            \\n        }\\n        \\n        return s;\\n    }\\n    };\\n\\'\\'\\'\\nTC ==> O(N*SQRT(N))\\nSC==> O(N)",
                "solutionTags": [],
                "code": "class Solution {\\n    \\n     public:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n=s.size();\\n        int blk=sqrt(n);\\n        int siz=ceil(n*1.0/blk);\\n        vector<int> f(siz,0);\\n        vector<int> arr(n,0);\\n        \\n        for(auto x: shifts){\\n            \\n            int l=x[0];\\n            int r=x[1];\\n            int add=x[2]==1?1:-1;\\n            int lb=l/blk;\\n            int rb=r/blk;\\n            if(lb==rb){\\n                for(int i=l;i<=r;i++){\\n                    arr[i]+=add;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2458369,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\npublic class Solution {\\n\\n    public String shiftingLetters(String input, int[][] shifts) {\\n        final int ALPHABET_SIZE = 26;\\n        int[] totalShifts = new int[input.length() + 1];\\n\\n        for (int[] shift : shifts) {\\n            int change = (shift[2] == 1) ? 1 : -1;\\n            totalShifts[shift[0]] += change;\\n            totalShifts[shift[1] + 1] -= change;\\n        }\\n\\n        char[] shiftedLetters = input.toCharArray();\\n        for (int i = 0; i < input.length(); ++i) {\\n            int currentShift = (shiftedLetters[i] - \\'a\\' + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                               % ALPHABET_SIZE;\\n            shiftedLetters[i] = (char) (currentShift + \\'a\\');\\n            totalShifts[i + 1] += totalShifts[i];\\n        }\\n\\n        return String.valueOf(shiftedLetters);\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {string} input\\n * @param {number[][]} shifts\\n * @return {string}\\n */\\nvar shiftingLetters = function (input, shifts) {\\n    const  ALPHABET_SIZE = 26;\\n    const ASCII_SMALL_CASE_A = 97;\\n    const totalShifts = new Array(input.length + 1).fill(0);\\n\\n    for (let shift of shifts) {\\n        const change = (shift[2] === 1) ? 1 : -1;\\n        totalShifts[shift[0]] += change;\\n        totalShifts[shift[1] + 1] -= change;\\n    }\\n\\n    let shiftedLetters = input.split(\\'\\');\\n    for (let i = 0; i < input.length; ++i) {\\n        const currentShift = (input.codePointAt(i) - ASCII_SMALL_CASE_A + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                             % ALPHABET_SIZE;\\n        shiftedLetters[i] = String.fromCodePoint(currentShift + ASCII_SMALL_CASE_A);\\n        totalShifts[i + 1] += totalShifts[i];\\n    }\\n\\n    return shiftedLetters.join(\\'\\');\\n};\\n```\\n**C++**\\n```\\n#include <string>\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\n    \\npublic:\\n    string shiftingLetters(string input, vector<vector<int>>& shifts) {\\n        const int ALPHABET_SIZE = 26;\\n        vector<int> totalShifts(input.length() + 1);\\n\\n        for (const auto& shift : shifts) {\\n            int change = (shift[2] == 1) ? 1 : -1;\\n            totalShifts[shift[0]] += change;\\n            totalShifts[shift[1] + 1] -= change;\\n        }\\n\\n        for (int i = 0; i < input.length(); ++i) {\\n            int currentShift = (input[i] - \\'a\\' + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                               % ALPHABET_SIZE;\\n            input[i] = (char) (currentShift + \\'a\\');\\n            totalShifts[i + 1] += totalShifts[i];\\n        }\\n\\n        return input;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\npublic class Solution {\\n\\n    public String shiftingLetters(String input, int[][] shifts) {\\n        final int ALPHABET_SIZE = 26;\\n        int[] totalShifts = new int[input.length() + 1];\\n\\n        for (int[] shift : shifts) {\\n            int change = (shift[2] == 1) ? 1 : -1;\\n            totalShifts[shift[0]] += change;\\n            totalShifts[shift[1] + 1] -= change;\\n        }\\n\\n        char[] shiftedLetters = input.toCharArray();\\n        for (int i = 0; i < input.length(); ++i) {\\n            int currentShift = (shiftedLetters[i] - \\'a\\' + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                               % ALPHABET_SIZE;\\n            shiftedLetters[i] = (char) (currentShift + \\'a\\');\\n            totalShifts[i + 1] += totalShifts[i];\\n        }\\n\\n        return String.valueOf(shiftedLetters);\\n    }\\n}\\n```\n```\\n/**\\n * @param {string} input\\n * @param {number[][]} shifts\\n * @return {string}\\n */\\nvar shiftingLetters = function (input, shifts) {\\n    const  ALPHABET_SIZE = 26;\\n    const ASCII_SMALL_CASE_A = 97;\\n    const totalShifts = new Array(input.length + 1).fill(0);\\n\\n    for (let shift of shifts) {\\n        const change = (shift[2] === 1) ? 1 : -1;\\n        totalShifts[shift[0]] += change;\\n        totalShifts[shift[1] + 1] -= change;\\n    }\\n\\n    let shiftedLetters = input.split(\\'\\');\\n    for (let i = 0; i < input.length; ++i) {\\n        const currentShift = (input.codePointAt(i) - ASCII_SMALL_CASE_A + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                             % ALPHABET_SIZE;\\n        shiftedLetters[i] = String.fromCodePoint(currentShift + ASCII_SMALL_CASE_A);\\n        totalShifts[i + 1] += totalShifts[i];\\n    }\\n\\n    return shiftedLetters.join(\\'\\');\\n};\\n```\n```\\n#include <string>\\n#include <vector>\\nusing namespace std;\\n\\nclass Solution {\\n    \\npublic:\\n    string shiftingLetters(string input, vector<vector<int>>& shifts) {\\n        const int ALPHABET_SIZE = 26;\\n        vector<int> totalShifts(input.length() + 1);\\n\\n        for (const auto& shift : shifts) {\\n            int change = (shift[2] == 1) ? 1 : -1;\\n            totalShifts[shift[0]] += change;\\n            totalShifts[shift[1] + 1] -= change;\\n        }\\n\\n        for (int i = 0; i < input.length(); ++i) {\\n            int currentShift = (input[i] - \\'a\\' + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                               % ALPHABET_SIZE;\\n            input[i] = (char) (currentShift + \\'a\\');\\n            totalShifts[i + 1] += totalShifts[i];\\n        }\\n\\n        return input;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2457263,
                "title": "prefix-sum",
                "content": "```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> v(n+1, 0);\\n        for(int i=0; i<shifts.size(); i++){\\n            int st = shifts[i][0];\\n            int end = shifts[i][1]+1;\\n            int dir = shifts[i][2];\\n            if(dir==1){\\n                v[st]++;\\n                v[end]--;\\n            }else{\\n                v[st]--;\\n                v[end]++;\\n            }\\n        }\\n        \\n        v[0] = v[0]%26;\\n        for(int i=1; i<n; i++){\\n            v[i]+= v[i-1];\\n            v[i] = v[i]%26;\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            int curr = s[i]-\\'a\\';\\n            int shift = curr+v[i];\\n            if(v[i]>0){\\n                if(shift>=26){\\n                    shift%=26;\\n                }\\n                s[i] = (char)\\'a\\'+shift;\\n            }else if(v[i]<0){\\n                if(shift<0){\\n                    shift+=26;\\n                }\\n                s[i] = (char)\\'a\\'+shift;\\n            }\\n        }\\n        return s;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> v(n+1, 0);\\n        for(int i=0; i<shifts.size(); i++){\\n            int st = shifts[i][0];\\n            int end = shifts[i][1]+1;\\n            int dir = shifts[i][2];\\n            if(dir==1){\\n                v[st]++;\\n                v[end]--;\\n            }else{\\n                v[st]--;\\n                v[end]++;\\n            }\\n        }\\n        \\n        v[0] = v[0]%26;\\n        for(int i=1; i<n; i++){\\n            v[i]+= v[i-1];\\n            v[i] = v[i]%26;\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            int curr = s[i]-\\'a\\';\\n            int shift = curr+v[i];\\n            if(v[i]>0){\\n                if(shift>=26){\\n                    shift%=26;\\n                }\\n                s[i] = (char)\\'a\\'+shift;\\n            }else if(v[i]<0){\\n                if(shift<0){\\n                    shift+=26;\\n                }\\n                s[i] = (char)\\'a\\'+shift;\\n            }\\n        }\\n        return s;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2456450,
                "title": "beats-100-c-solution-explained",
                "content": "```\\nclass Solution {\\npublic:\\n    /* LOGIC:\\n    + Instead of storing the count of number of times a character is changing \\n    using hash table, \\n    + Make an array for indexes of string s then mark those indexes where \\n    the count of number of times a char changing according to given\\n    shifts\\'s starting and ending index.\\n    + And use a count variable to find that a number of times a particular\\n    char changed in the string s by changing the count variable using array\\n    on the go.\\n    \\n    e.g\\n    For, s = \"abc\", shifts = [[0,1,0],[1,2,1],[0,2,1]]\\n    // initially, markArray = [0, 0, 0, 0] (means every char in s changed 0 times, taking the markArray size = n+1 for simplicity purpose)\\n    for idx = 0 in shifts:\\n    markArray = [-1, 0, +1, 0] \\n    for idx = 1 in shifts:\\n    markArray = [-1, 0+(1), +1, 0+(-1)]\\n    for idx = 2 in shifts:\\n    markArray = [-1+(+1), +1, +1, -1+(-1)]\\n    \\n    final markArray = [0, 1, 1, 2]\\n    which means,\\n    cnt = 0 // initially\\n    for i = 0:\\n    cnt += markArray[0] => cnt = 0\\n    s[0] not changed, ie \\'a\\' => \\'a\\'\\n    for i = 1:\\n    cnt += markArray[1] => cnt = 1\\n    s[1] incremented by cnt=1, ie \\'b\\' => \\'c\\'\\n    for i = 2:\\n    cnt += markArray[1] => cnt = 2\\n    s[2] incremented by cnt=2, ie \\'c\\' => \\'e\\'\\n    \\n    output=>\\'ace\\'\\n    */\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        vector<long long> shiftcnt (n+1, 0);\\n        for (int i=0; i<shifts.size(); i++) {\\n            if (shifts[i][2]==1) {\\n                shiftcnt[shifts[i][0]] += 1;\\n                shiftcnt[shifts[i][1]+1] -= 1; \\n            }\\n            else {\\n                shiftcnt[shifts[i][0]] -= 1;\\n                shiftcnt[shifts[i][1]+1] += 1; \\n            }\\n        }\\n        \\n        string chrs = \"abcdefghijklmnopqrstuvwxyz\";\\n        \\n        long long cnt = 0;\\n        for (int i=0; i<n; i++) {\\n            cnt += shiftcnt[i];\\n            int nshift = cnt%26;\\n            int c_idx = s[i]-\\'a\\';\\n            if (nshift>=0) {\\n                if (c_idx+nshift<=25) {\\n                    s[i] = chrs[c_idx+nshift];\\n                } else {\\n                    s[i] = chrs[c_idx+nshift-26];\\n                }\\n            }\\n            else {\\n                if (c_idx+nshift>=0) {\\n                    s[i] = chrs[c_idx+nshift];\\n                } else {\\n                    s[i] = chrs[26+c_idx+nshift];\\n                }\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    /* LOGIC:\\n    + Instead of storing the count of number of times a character is changing \\n    using hash table, \\n    + Make an array for indexes of string s then mark those indexes where \\n    the count of number of times a char changing according to given\\n    shifts\\'s starting and ending index.\\n    + And use a count variable to find that a number of times a particular\\n    char changed in the string s by changing the count variable using array\\n    on the go.\\n    \\n    e.g\\n    For, s = \"abc\", shifts = [[0,1,0],[1,2,1],[0,2,1]]\\n    // initially, markArray = [0, 0, 0, 0] (means every char in s changed 0 times, taking the markArray size = n+1 for simplicity purpose)\\n    for idx = 0 in shifts:\\n    markArray = [-1, 0, +1, 0] \\n    for idx = 1 in shifts:\\n    markArray = [-1, 0+(1), +1, 0+(-1)]\\n    for idx = 2 in shifts:\\n    markArray = [-1+(+1), +1, +1, -1+(-1)]\\n    \\n    final markArray = [0, 1, 1, 2]\\n    which means,\\n    cnt = 0 // initially\\n    for i = 0:\\n    cnt += markArray[0] => cnt = 0\\n    s[0] not changed, ie \\'a\\' => \\'a\\'\\n    for i = 1:\\n    cnt += markArray[1] => cnt = 1\\n    s[1] incremented by cnt=1, ie \\'b\\' => \\'c\\'\\n    for i = 2:\\n    cnt += markArray[1] => cnt = 2\\n    s[2] incremented by cnt=2, ie \\'c\\' => \\'e\\'\\n    \\n    output=>\\'ace\\'\\n    */\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        vector<long long> shiftcnt (n+1, 0);\\n        for (int i=0; i<shifts.size(); i++) {\\n            if (shifts[i][2]==1) {\\n                shiftcnt[shifts[i][0]] += 1;\\n                shiftcnt[shifts[i][1]+1] -= 1; \\n            }\\n            else {\\n                shiftcnt[shifts[i][0]] -= 1;\\n                shiftcnt[shifts[i][1]+1] += 1; \\n            }\\n        }\\n        \\n        string chrs = \"abcdefghijklmnopqrstuvwxyz\";\\n        \\n        long long cnt = 0;\\n        for (int i=0; i<n; i++) {\\n            cnt += shiftcnt[i];\\n            int nshift = cnt%26;\\n            int c_idx = s[i]-\\'a\\';\\n            if (nshift>=0) {\\n                if (c_idx+nshift<=25) {\\n                    s[i] = chrs[c_idx+nshift];\\n                } else {\\n                    s[i] = chrs[c_idx+nshift-26];\\n                }\\n            }\\n            else {\\n                if (c_idx+nshift>=0) {\\n                    s[i] = chrs[c_idx+nshift];\\n                } else {\\n                    s[i] = chrs[26+c_idx+nshift];\\n                }\\n            }\\n        }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456011,
                "title": "2-python-solutions-with-explanation-bruteforce-linesweep",
                "content": "\\t**BRUTE-FORCE SOLUTION** (GIVING TLE)\\n\\tclass Solution:\\n\\t\\tdef shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\ttoshift = defaultdict(int)\\n\\n\\t\\t\\tfor i in shifts:\\n\\t\\t\\t\\tif i[2] == 0:\\n\\t\\t\\t\\t\\tc = -1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tc = 1\\n\\t\\t\\t\\tfor j in range(i[0], i[1] + 1):\\n\\t\\t\\t\\t\\ttoshift[j] += c\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tl = list(s)\\n\\t\\t\\tfor i in range(len(l)):\\n\\t\\t\\t\\tif toshift[i]>0:\\n\\t\\t\\t\\t\\tacc= ord(l[i]) + (toshift[i]%26)\\n\\t\\t\\t\\t\\tif (acc) > 122:\\n\\t\\t\\t\\t\\t\\tacc = 96 + (acc-122)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tacc= ord(l[i]) - (abs(toshift[i])%26)\\n\\t\\t\\t\\t\\tif (acc) < 97:\\n\\t\\t\\t\\t\\t\\tacc = 123 - (97 - acc)\\n\\t\\t\\t\\tl[i] = chr(acc)\\n\\n\\t\\t\\treturn(\\'\\'.join(l))\\n\\t\\n\\t**OPTIMIZED SOLUTION**: (*LINE SWEEPING*)\\n\\t\\n\\tclass Solution:\\n\\t\\tdef shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\ttoshift = [0]*(len(s) +1)\\n\\t\\t\\t\\n\\t\\t\\t#marking start and end points only for start and end points of each shift \\n\\t\\t\\tfor i in shifts:\\n\\t\\t\\t\\tif i[2] == 1:\\n\\t\\t\\t\\t\\ttoshift[i[0]] += 1\\n\\t\\t\\t\\t\\ttoshift[i[1]+1] -= 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ttoshift[i[0]] -= 1\\n\\t\\t\\t\\t\\ttoshift[i[1]+1] += 1\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tfor j in range(1, len(s)):                  #calculating prefixSum\\n\\t\\t\\t\\t\\ttoshift[j] += toshift[j-1]\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tl = list(s)                                 #converting in list for doing modification\\n\\t\\t\\tfor i in range(len(l)):\\n\\t\\t\\t\\tif toshift[i]>0:                        #for forward\\n\\t\\t\\t\\t\\tacc= ord(l[i]) + (toshift[i]%26)    #doing modulo by 26 because we have 26 alphabets and if suppose we to shift alphabet by 43 ie(43 % 26 = 1) so we will shift by 1 \\n\\t\\t\\t\\t\\tif (acc) > 122:\\n\\t\\t\\t\\t\\t\\tacc = 96 + (acc-122)            #if range exceeds then first subtract by 122 then add it in 96 (if still you did\\'nt get intution of it try doing dry run of it on some test cases)\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\telse:                                   #for backward\\n\\t\\t\\t\\t\\tacc= ord(l[i]) - (abs(toshift[i])%26)\\n\\t\\t\\t\\t\\tif (acc) < 97:\\n\\t\\t\\t\\t\\t\\tacc = 123 - (97 - acc)\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tl[i] = chr(acc)                         #finally updating that character\\n\\n\\t\\t\\treturn(\\'\\'.join(l))\\n\\t\\t\\t\\nDo **UPVOTE** :)\\n\\n**COMPLEXITY :**  O(N) time and O(N) space",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "\\t**BRUTE-FORCE SOLUTION** (GIVING TLE)\\n\\tclass Solution:\\n\\t\\tdef shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\ttoshift = defaultdict(int)\\n\\n\\t\\t\\tfor i in shifts:\\n\\t\\t\\t\\tif i[2] == 0:\\n\\t\\t\\t\\t\\tc = -1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tc = 1\\n\\t\\t\\t\\tfor j in range(i[0], i[1] + 1):\\n\\t\\t\\t\\t\\ttoshift[j] += c\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tl = list(s)\\n\\t\\t\\tfor i in range(len(l)):\\n\\t\\t\\t\\tif toshift[i]>0:\\n\\t\\t\\t\\t\\tacc= ord(l[i]) + (toshift[i]%26)\\n\\t\\t\\t\\t\\tif (acc) > 122:\\n\\t\\t\\t\\t\\t\\tacc = 96 + (acc-122)\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tacc= ord(l[i]) - (abs(toshift[i])%26)\\n\\t\\t\\t\\t\\tif (acc) < 97:\\n\\t\\t\\t\\t\\t\\tacc = 123 - (97 - acc)\\n\\t\\t\\t\\tl[i] = chr(acc)\\n\\n\\t\\t\\treturn(\\'\\'.join(l))\\n\\t\\n\\t**OPTIMIZED SOLUTION**: (*LINE SWEEPING*)\\n\\t\\n\\tclass Solution:\\n\\t\\tdef shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\ttoshift = [0]*(len(s) +1)\\n\\t\\t\\t\\n\\t\\t\\t#marking start and end points only for start and end points of each shift \\n\\t\\t\\tfor i in shifts:\\n\\t\\t\\t\\tif i[2] == 1:\\n\\t\\t\\t\\t\\ttoshift[i[0]] += 1\\n\\t\\t\\t\\t\\ttoshift[i[1]+1] -= 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\ttoshift[i[0]] -= 1\\n\\t\\t\\t\\t\\ttoshift[i[1]+1] += 1\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tfor j in range(1, len(s)):                  #calculating prefixSum\\n\\t\\t\\t\\t\\ttoshift[j] += toshift[j-1]\\n\\t\\t\\t\\t\\t\\n\\t\\t\\tl = list(s)                                 #converting in list for doing modification\\n\\t\\t\\tfor i in range(len(l)):\\n\\t\\t\\t\\tif toshift[i]>0:                        #for forward\\n\\t\\t\\t\\t\\tacc= ord(l[i]) + (toshift[i]%26)    #doing modulo by 26 because we have 26 alphabets and if suppose we to shift alphabet by 43 ie(43 % 26 = 1) so we will shift by 1 \\n\\t\\t\\t\\t\\tif (acc) > 122:\\n\\t\\t\\t\\t\\t\\tacc = 96 + (acc-122)            #if range exceeds then first subtract by 122 then add it in 96 (if still you did\\'nt get intution of it try doing dry run of it on some test cases)\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\telse:                                   #for backward\\n\\t\\t\\t\\t\\tacc= ord(l[i]) - (abs(toshift[i])%26)\\n\\t\\t\\t\\t\\tif (acc) < 97:\\n\\t\\t\\t\\t\\t\\tacc = 123 - (97 - acc)\\n\\t\\t\\t\\t\\t\\t\\n\\t\\t\\t\\tl[i] = chr(acc)                         #finally updating that character\\n\\n\\t\\t\\treturn(\\'\\'.join(l))\\n\\t\\t\\t\\nDo **UPVOTE** :)\\n\\n**COMPLEXITY :**  O(N) time and O(N) space",
                "codeTag": "Java"
            },
            {
                "id": 2455458,
                "title": "java-solution-prefix-sum",
                "content": "```java \\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int[] a = new int[s.length()+1];\\n        \\n        for(int[] shift: shifts)\\n        {\\n            fill(a,shift[0],shift[1],shift[2]);\\n        }\\n        StringBuffer sb = new StringBuffer();\\n        for(int i=0;i<s.length();i++)\\n        {\\n            if(i>0)\\n                a[i]+=a[i-1];\\n            a[i]%=26;\\n            if(s.charAt(i)+a[i]<97)\\n                sb.append((char)(s.charAt(i)+26+a[i]));\\n            else if(s.charAt(i)+a[i]>122)\\n                sb.append((char)(s.charAt(i)-26+a[i]));\\n            else\\n                sb.append((char)(s.charAt(i)+a[i]));\\n        }\\n        return sb.toString();\\n    }\\n    \\n    private void fill(int[] a,int start,int end, int shift)\\n    {\\n        if(shift==0){\\n        a[start]--;\\n        a[end+1]++;\\n        }\\n        else{\\n        a[start]++;\\n        a[end+1]--;\\n        }   \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int[] a = new int[s.length()+1];\\n        \\n        for(int[] shift: shifts)\\n        {\\n            fill(a,shift[0],shift[1],shift[2]);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2455351,
                "title": "c-easy-to-understand-using-prefix-array-with-explanation",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> pref(s.size()+1,0);\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            int z=shifts[i][2],l=shifts[i][0],r=shifts[i][1];\\n            if(z==0) // suppose given string of size 4 so initially pref array 0,0,0,0,0, and given range from (1,3)\\n            {\\n                pref[l]-=1; // for -1 case 0 -1 0 0 1 \\n                pref[r+1]+=1;\\n            }\\n            else\\n            {\\n                pref[l]+=1; // for the +1 case 0 1 0 0 -1  \\n                pref[r+1]-=1;\\n            }\\n        }\\n        for(int i=1;i<pref.size();i++)\\n        {\\n              pref[i]+=pref[i-1]; // calculating pref sum and we see that for +1 case 0 1 1 1 0  and for -1 case 0 -1 -1 -1 0 \\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(pref[i]<0) // if pref[i]<0 \\n            {\\n                int z=abs(pref[i]); // taking absolute value and converting it into multiple of z if modulo 0 then taking direct value by division or +1 in case not divisible\\n                if(z%26==0) \\n                z=z/26;\\n                else\\n                z=z/26+1;\\n                s[i]=(s[i]-\\'a\\'+pref[i]+z*26)%26+\\'a\\';\\n            }\\n            else\\n                s[i]=(s[i]-\\'a\\'+pref[i])%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```\\n**Please Upvote if you like it**",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> pref(s.size()+1,0);\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            int z=shifts[i][2],l=shifts[i][0],r=shifts[i][1];\\n            if(z==0) // suppose given string of size 4 so initially pref array 0,0,0,0,0, and given range from (1,3)\\n            {\\n                pref[l]-=1; // for -1 case 0 -1 0 0 1 \\n                pref[r+1]+=1;\\n            }\\n            else\\n            {\\n                pref[l]+=1; // for the +1 case 0 1 0 0 -1  \\n                pref[r+1]-=1;\\n            }\\n        }\\n        for(int i=1;i<pref.size();i++)\\n        {\\n              pref[i]+=pref[i-1]; // calculating pref sum and we see that for +1 case 0 1 1 1 0  and for -1 case 0 -1 -1 -1 0 \\n        }\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(pref[i]<0) // if pref[i]<0 \\n            {\\n                int z=abs(pref[i]); // taking absolute value and converting it into multiple of z if modulo 0 then taking direct value by division or +1 in case not divisible\\n                if(z%26==0) \\n                z=z/26;\\n                else\\n                z=z/26+1;\\n                s[i]=(s[i]-\\'a\\'+pref[i]+z*26)%26+\\'a\\';\\n            }\\n            else\\n                s[i]=(s[i]-\\'a\\'+pref[i])%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454931,
                "title": "c-easy-and-simple-solution-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int>v(n+1,0);\\n        for(int i=0;i<shifts.size();i++){\\n            if(shifts[i][2]==0){\\n                v[shifts[i][0]]--;\\n                v[shifts[i][1] + 1]++;\\n            }\\n            else{\\n                 v[shifts[i][0]]++;\\n                v[shifts[i][1] + 1]--;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            v[i]=v[i]+v[i-1];\\n        }\\n        for(int i=0;i<n;i++){\\n            if(v[i]>=0){\\n                int a=v[i]%26;\\n                int b=(s[i]-\\'a\\'+a)%26;\\n                s[i]=\\'a\\'+b;\\n            } \\n            else{\\n                int a=(-1*v[i])%26;\\n                int b=(s[i]-\\'a\\'-a);\\n                if(b<0){\\n                    b=26+b;\\n                    s[i]=\\'a\\'+b;\\n                }\\n                else{\\n                    s[i]=\\'a\\'+b;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int>v(n+1,0);\\n        for(int i=0;i<shifts.size();i++){\\n            if(shifts[i][2]==0){\\n                v[shifts[i][0]]--;\\n                v[shifts[i][1] + 1]++;\\n            }\\n            else{\\n                 v[shifts[i][0]]++;\\n                v[shifts[i][1] + 1]--;\\n            }\\n        }\\n        for(int i=1;i<n;i++){\\n            v[i]=v[i]+v[i-1];\\n        }\\n        for(int i=0;i<n;i++){\\n            if(v[i]>=0){\\n                int a=v[i]%26;\\n                int b=(s[i]-\\'a\\'+a)%26;\\n                s[i]=\\'a\\'+b;\\n            } \\n            else{\\n                int a=(-1*v[i])%26;\\n                int b=(s[i]-\\'a\\'-a);\\n                if(b<0){\\n                    b=26+b;\\n                    s[i]=\\'a\\'+b;\\n                }\\n                else{\\n                    s[i]=\\'a\\'+b;\\n                }\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454745,
                "title": "easy-c-code-prefix-sum",
                "content": "class Solution {\\npublic:\\n\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> v(s.size() + 2, 0);\\n\\n        for (auto &it : shifts) {\\n            int l = it[0], r = it[1], d = it[2];\\n\\n            if (d == 0) {\\n                v[l]--;\\n                v[r + 1]++;\\n            }\\n            else {\\n                v[l]++;\\n                v[r + 1]--;\\n            }\\n        }\\n\\n        for (int i = 1; i < s.size(); i++) {\\n            v[i] = v[i] + v[i - 1];\\n        }\\n        \\n        for(auto i = 0; i < s.size(); i++) {\\n            \\n            int ans = ((s[i] - \\'a\\') + v[i]) % 26;\\n            s[i] = \\'a\\' + (ans + 26)%26;\\n        }\\n\\n        return s;\\n    }\\n};",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "class Solution {\\npublic:\\n\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> v(s.size() + 2, 0);\\n\\n        for (auto &it : shifts) {\\n            int l = it[0], r = it[1], d = it[2];\\n\\n            if (d == 0) {\\n                v[l]--;\\n                v[r + 1]++;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2454607,
                "title": "using-1-1-trick-prefix-sum-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> f(n);\\n        \\n        for(vector<int> a : shifts){\\n            if(a[2] == 0){\\n                f[a[0]] -= 1;\\n                if(a[1] + 1 < n) f[a[1] + 1] += 1;\\n            }\\n            else{\\n                f[a[0]] += 1;\\n                if(a[1] + 1 < n) f[a[1] + 1] -= 1;\\n            }\\n        }\\n        \\n        for(int i=1; i<n; i++){\\n            f[i] += f[i-1];\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(f[i] < 0){\\n                f[i] *= -1;\\n                f[i] %= 26;\\n                f[i] = 26 - f[i];\\n            }\\n            else{\\n                f[i] %= 26;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            s[i] = ((s[i] - \\'a\\' + f[i]) % 26 + \\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> f(n);\\n        \\n        for(vector<int> a : shifts){\\n            if(a[2] == 0){\\n                f[a[0]] -= 1;\\n                if(a[1] + 1 < n) f[a[1] + 1] += 1;\\n            }\\n            else{\\n                f[a[0]] += 1;\\n                if(a[1] + 1 < n) f[a[1] + 1] -= 1;\\n            }\\n        }\\n        \\n        for(int i=1; i<n; i++){\\n            f[i] += f[i-1];\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            if(f[i] < 0){\\n                f[i] *= -1;\\n                f[i] %= 26;\\n                f[i] = 26 - f[i];\\n            }\\n            else{\\n                f[i] %= 26;\\n            }\\n        }\\n        \\n        for(int i=0; i<n; i++){\\n            s[i] = ((s[i] - \\'a\\' + f[i]) % 26 + \\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454592,
                "title": "c-solution",
                "content": "```\\npublic class Solution {\\n    public string ShiftingLetters(string s, int[][] shifts) {\\n        const int n = 26;\\n        var diffs = new int[s.Length + 1];\\n\\n        foreach (var shift in shifts)\\n            if (shift[2] == 0) {\\n                diffs[shift[0]]--;\\n                diffs[shift[1] + 1]++;\\n            }\\n            else {\\n                diffs[shift[0]]++;\\n                diffs[shift[1] + 1]--;\\n            }\\n\\n        var arr = s.ToCharArray();\\n        var diff = 0;\\n\\n        for (var i = 0; i < s.Length; i++) {\\n            diff += diffs[i];\\n            arr[i] = (char)(\\'a\\' + ((arr[i] + diff - \\'a\\') % n + n) % n);\\n        }\\n\\n        return new string(arr);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public string ShiftingLetters(string s, int[][] shifts) {\\n        const int n = 26;\\n        var diffs = new int[s.Length + 1];\\n\\n        foreach (var shift in shifts)\\n            if (shift[2] == 0) {\\n                diffs[shift[0]]--;\\n                diffs[shift[1] + 1]++;\\n            }\\n            else {\\n                diffs[shift[0]]++;\\n                diffs[shift[1] + 1]--;\\n            }\\n\\n        var arr = s.ToCharArray();\\n        var diff = 0;\\n\\n        for (var i = 0; i < s.Length; i++) {\\n            diff += diffs[i];\\n            arr[i] = (char)(\\'a\\' + ((arr[i] + diff - \\'a\\') % n + n) % n);\\n        }\\n\\n        return new string(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454585,
                "title": "python-solution",
                "content": "\\tclass Solution:\\n\\t\\tdef shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\tres = [0] * (len(s) + 1)\\n\\t\\t\\tfor start, end, direction in shifts:\\n\\t\\t\\t\\tif direction == 0:\\n\\t\\t\\t\\t\\tres[start] -= 1\\n\\t\\t\\t\\t\\tres[end + 1] += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres[start] += 1\\n\\t\\t\\t\\t\\tres[end + 1] -= 1\\n\\t\\t\\tfor i in range(1, len(res)):\\n\\t\\t\\t\\tres[i] += res[i - 1]\\n\\t\\t\\tfor i, c in enumerate(s):\\n\\t\\t\\t\\tres[i] = chr(ord(\"a\") + (ord(c) - ord(\"a\") + res[i] + 26) % 26)\\n\\t\\t\\treturn \"\".join(res[:-1])",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n\\t\\t\\tres = [0] * (len(s) + 1)\\n\\t\\t\\tfor start, end, direction in shifts:\\n\\t\\t\\t\\tif direction == 0:\\n\\t\\t\\t\\t\\tres[start] -= 1\\n\\t\\t\\t\\t\\tres[end + 1] += 1\\n\\t\\t\\t\\telse:\\n\\t\\t\\t\\t\\tres[start] += 1\\n\\t\\t\\t\\t\\tres[end + 1] -= 1\\n\\t\\t\\tfor i in range(1, len(res)):\\n\\t\\t\\t\\tres[i] += res[i - 1]\\n\\t\\t\\tfor i, c in enumerate(s):\\n\\t\\t\\t\\tres[i] = chr(ord(\"a\") + (ord(c) - ord(\"a\") + res[i] + 26) % 26)\\n\\t\\t\\treturn \"\".join(res[:-1])",
                "codeTag": "Java"
            },
            {
                "id": 2454506,
                "title": "python3-sum-changes-per-element",
                "content": "**Biweekly Contest 85 Submission**\\n\\n**Sum Changes per Element**\\n1. Get the sum of the changes to each character in ```s``` given the intervals in ```shifts``` (linearly with a prefix sum array ```dp```).\\n2. Apply the changes from ```dp``` per character in ```s``` and return the result.\\n\\n**Code**\\n```Python3 []\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        dp = [0]*(n + 1)\\n        res = \"\"\\n        \\n        #Get changes\\n        for u, v, w in shifts:\\n            if w:\\n                dp[u] += 1\\n                dp[v + 1] -= 1\\n            else:\\n                dp[u] -= 1\\n                dp[v + 1] += 1\\n                    \\n        #Prefix sum\\n        for idx in range(1, n):\\n            dp[idx] += dp[idx - 1]\\n        \\n        #Apply changes\\n        for idx in range(n):\\n            res += chr((ord(s[idx]) - ord(\\'a\\') + dp[idx]) % 26 + ord(\\'a\\'))\\n        \\n        return res\\n```",
                "solutionTags": [
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```s```\n```shifts```\n```dp```\n```dp```\n```s```\n```Python3 []\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        dp = [0]*(n + 1)\\n        res = \"\"\\n        \\n        #Get changes\\n        for u, v, w in shifts:\\n            if w:\\n                dp[u] += 1\\n                dp[v + 1] -= 1\\n            else:\\n                dp[u] -= 1\\n                dp[v + 1] += 1\\n                    \\n        #Prefix sum\\n        for idx in range(1, n):\\n            dp[idx] += dp[idx - 1]\\n        \\n        #Apply changes\\n        for idx in range(n):\\n            res += chr((ord(s[idx]) - ord(\\'a\\') + dp[idx]) % 26 + ord(\\'a\\'))\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454412,
                "title": "c-partial-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        int arr[n+1];\\n        memset(arr,0,sizeof(arr));\\n        \\n        for(auto shift : shifts){\\n            int l = shift[0];\\n            int r = shift[1];\\n            int dir = shift[2];\\n            \\n            if(dir==1){\\n                arr[l]++;\\n                arr[r+1]--;\\n            }else{\\n                arr[l]--;\\n                arr[r+1]++;\\n            }\\n        }\\n        for(int i = 0 ; i <= n ; i++){\\n            if(i!=0) arr[i] += arr[i-1];\\n            // cout<<arr[i]<<\" \";\\n        }\\n        // cout<<\"\\\\n\";\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            arr[i] = (arr[i] + s[i]-\\'a\\')%(26);\\n            if(arr[i]<0) arr[i] = (arr[i]+26)%26;\\n        }\\n        string ans = \"\";\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            ans += (char)(arr[i]+\\'a\\');\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        int arr[n+1];\\n        memset(arr,0,sizeof(arr));\\n        \\n        for(auto shift : shifts){\\n            int l = shift[0];\\n            int r = shift[1];\\n            int dir = shift[2];\\n            \\n            if(dir==1){\\n                arr[l]++;\\n                arr[r+1]--;\\n            }else{\\n                arr[l]--;\\n                arr[r+1]++;\\n            }\\n        }\\n        for(int i = 0 ; i <= n ; i++){\\n            if(i!=0) arr[i] += arr[i-1];\\n            // cout<<arr[i]<<\" \";\\n        }\\n        // cout<<\"\\\\n\";\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            arr[i] = (arr[i] + s[i]-\\'a\\')%(26);\\n            if(arr[i]<0) arr[i] = (arr[i]+26)%26;\\n        }\\n        string ans = \"\";\\n        \\n        for(int i = 0 ; i < n ; i++){\\n            ans += (char)(arr[i]+\\'a\\');\\n        }\\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2454399,
                "title": "o-n-difference-array",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \\n        def convert(c, ch):\\n            return chr((ord(c.upper()) + ch - 65) % 26 + 65).lower()\\n        \\n        n, l = len(s), list(s)\\n        changes = [0] * (n+1)\\n        \\n        for shift in shifts:\\n            changes[shift[0]] += 1 if shift[2] == 1 else -1\\n            changes[shift[1] + 1] += 1 if shift[2] == 0 else -1\\n            \\n        for i in range(1, n+1):\\n            changes[i] += changes[i-1]\\n            \\n        for i, c in enumerate(l):\\n            l[i] = convert(c, changes[i])\\n            \\n        return \\'\\'.join(l)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \\n        def convert(c, ch):\\n            return chr((ord(c.upper()) + ch - 65) % 26 + 65).lower()\\n        \\n        n, l = len(s), list(s)\\n        changes = [0] * (n+1)\\n        \\n        for shift in shifts:\\n            changes[shift[0]] += 1 if shift[2] == 1 else -1\\n            changes[shift[1] + 1] += 1 if shift[2] == 0 else -1\\n            \\n        for i in range(1, n+1):\\n            changes[i] += changes[i-1]\\n            \\n        for i, c in enumerate(l):\\n            l[i] = convert(c, changes[i])\\n            \\n        return \\'\\'.join(l)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454355,
                "title": "c-range-query-o-n",
                "content": "Upvote If you like the solution\\ncomment down any doubts or suggestions\\nTime : O(n)\\nSpace : O(n)\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> arr(n, 0);\\n        \\n        for(auto it: shifts) {\\n            int curr = 0;\\n            if(!it[2]) curr = -1;\\n            else curr = 1;\\n            \\n            int s = it[0], e = it[1];\\n            arr[s] += curr;\\n            if(e+1 < n) arr[e+1] -= curr;\\n        }\\n        \\n        int cnt = 0;\\n        for(int i=0; i<n; i++) {\\n            cnt += arr[i];\\n            cnt %= 26;\\n            int temp = ((s[i]-\\'a\\') + cnt + 26) % 26;\\n            s[i] = temp + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> arr(n, 0);\\n        \\n        for(auto it: shifts) {\\n            int curr = 0;\\n            if(!it[2]) curr = -1;\\n            else curr = 1;\\n            \\n            int s = it[0], e = it[1];\\n            arr[s] += curr;\\n            if(e+1 < n) arr[e+1] -= curr;\\n        }\\n        \\n        int cnt = 0;\\n        for(int i=0; i<n; i++) {\\n            cnt += arr[i];\\n            cnt %= 26;\\n            int temp = ((s[i]-\\'a\\') + cnt + 26) % 26;\\n            s[i] = temp + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454345,
                "title": "partial-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        long long int arr[s.size()+1];\\n        memset(arr, 0, sizeof(arr));\\n        for(auto it : shifts)\\n        {\\n            long long int l = it[0], r = it[1], dir = it[2];\\n            if(dir)\\n            {\\n                arr[l]+=1;\\n                arr[r+1]+=-1;\\n            }\\n            else \\n            {\\n                arr[l]-=1;\\n                arr[r+1]+=1;\\n            }\\n        }\\n        int s2=0;\\n        for(int i=0;i<s.size()+1;i++)\\n        {\\n            s2+=arr[i];\\n            arr[i]=s2;\\n        }\\n        for(long long int i =0 ; i < s.size(); ++i)\\n        {\\n            if(arr[i]>=0)\\n            {\\n                int shift = arr[i]%26;\\n                int k = (int)s[i];\\n                int t =(k+shift);\\n                if(t > 122)\\n                {\\n                    int c = t-122;\\n                    t=96+c;\\n                }\\n                s[i] = (char)t;\\n            }\\n            if(arr[i] < 0)\\n            {\\n                int shift = abs(arr[i])%26;\\n                int k = (int)s[i];\\n                int t= (k-shift);\\n                if(t<97)\\n                {\\n                    int c = 97-t;\\n                    t = 123-c;\\n                }\\n                s[i] = (char)t;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        long long int arr[s.size()+1];\\n        memset(arr, 0, sizeof(arr));\\n        for(auto it : shifts)\\n        {\\n            long long int l = it[0], r = it[1], dir = it[2];\\n            if(dir)\\n            {\\n                arr[l]+=1;\\n                arr[r+1]+=-1;\\n            }\\n            else \\n            {\\n                arr[l]-=1;\\n                arr[r+1]+=1;\\n            }\\n        }\\n        int s2=0;\\n        for(int i=0;i<s.size()+1;i++)\\n        {\\n            s2+=arr[i];\\n            arr[i]=s2;\\n        }\\n        for(long long int i =0 ; i < s.size(); ++i)\\n        {\\n            if(arr[i]>=0)\\n            {\\n                int shift = arr[i]%26;\\n                int k = (int)s[i];\\n                int t =(k+shift);\\n                if(t > 122)\\n                {\\n                    int c = t-122;\\n                    t=96+c;\\n                }\\n                s[i] = (char)t;\\n            }\\n            if(arr[i] < 0)\\n            {\\n                int shift = abs(arr[i])%26;\\n                int k = (int)s[i];\\n                int t= (k-shift);\\n                if(t<97)\\n                {\\n                    int c = 97-t;\\n                    t = 123-c;\\n                }\\n                s[i] = (char)t;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454343,
                "title": "scala-sorted-shifts-and-simple-recursion",
                "content": "```scala\\ncase class Shift(start: Int, finish: Int, up: Boolean)\\n\\ndef shiftingLetters(s: String, shifts: Array[Array[Int]]): String = {\\n  val shfts = shifts.map {\\n    case Array(start, finish, 0) => Shift(start, finish, false)\\n    case Array(start, finish, 1) => Shift(start, finish, true)\\n    case _ => ???\\n  }\\n  val start = shfts.sortBy(_.start)\\n  val finish = shfts.sortBy(_.finish)\\n  val chars = s.map(_ - \\'a\\').zipWithIndex\\n  goShift(chars.toList, 0, start.toList, finish.toList, List.empty).map(toChar).mkString\\n}\\n\\ndef goShift(chars: List[(Int, Int)], k:  Int, start: List[Shift], finish: List[Shift], acc: List[Int]): List[Int] =\\n  chars match {\\n    case Nil => acc.reverse\\n    case (c, i) :: tail =>\\n      val started = start.takeWhile(_.start <= i).map(s => if(s.up) 1 else -1)\\n      val finished = finish.takeWhile(_.finish < i).map(s => if(s.up) -1 else 1)\\n      val nK = k + started.sum + finished.sum\\n      goShift(tail, nK, start.drop(started.size), finish.drop(finished.size), c + nK :: acc)\\n  }\\n\\ndef toChar(i: Int) = (\\'a\\' + math.floorMod(i, 26)).toChar\\n```",
                "solutionTags": [
                    "Scala",
                    "Recursion"
                ],
                "code": "```scala\\ncase class Shift(start: Int, finish: Int, up: Boolean)\\n\\ndef shiftingLetters(s: String, shifts: Array[Array[Int]]): String = {\\n  val shfts = shifts.map {\\n    case Array(start, finish, 0) => Shift(start, finish, false)\\n    case Array(start, finish, 1) => Shift(start, finish, true)\\n    case _ => ???\\n  }\\n  val start = shfts.sortBy(_.start)\\n  val finish = shfts.sortBy(_.finish)\\n  val chars = s.map(_ - \\'a\\').zipWithIndex\\n  goShift(chars.toList, 0, start.toList, finish.toList, List.empty).map(toChar).mkString\\n}\\n\\ndef goShift(chars: List[(Int, Int)], k:  Int, start: List[Shift], finish: List[Shift], acc: List[Int]): List[Int] =\\n  chars match {\\n    case Nil => acc.reverse\\n    case (c, i) :: tail =>\\n      val started = start.takeWhile(_.start <= i).map(s => if(s.up) 1 else -1)\\n      val finished = finish.takeWhile(_.finish < i).map(s => if(s.up) -1 else 1)\\n      val nK = k + started.sum + finished.sum\\n      goShift(tail, nK, start.drop(started.size), finish.drop(finished.size), c + nK :: acc)\\n  }\\n\\ndef toChar(i: Int) = (\\'a\\' + math.floorMod(i, 26)).toChar\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454322,
                "title": "python-o-n-solution",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        indices = [0 for i in range(len(s)+1)]\\n        for i,j,k in shifts:\\n            if k == 1:\\n                indices[i] += 1\\n                indices[j+1] -= 1\\n            else:\\n                indices[i] += 25\\n                indices[j+1] -= 25\\n        count = 0\\n        alpha = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        pos = {alpha[i]:i for i in range(len(alpha))}\\n        new = \\'\\'\\n        for i in range(len(s)):\\n            count += indices[i]\\n            new+=alpha[(count+pos[s[i]])%26]\\n        return new\\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        indices = [0 for i in range(len(s)+1)]\\n        for i,j,k in shifts:\\n            if k == 1:\\n                indices[i] += 1\\n                indices[j+1] -= 1\\n            else:\\n                indices[i] += 25\\n                indices[j+1] -= 25\\n        count = 0\\n        alpha = \\'abcdefghijklmnopqrstuvwxyz\\'\\n        pos = {alpha[i]:i for i in range(len(alpha))}\\n        new = \\'\\'\\n        for i in range(len(s)):\\n            count += indices[i]\\n            new+=alpha[(count+pos[s[i]])%26]\\n        return new\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454280,
                "title": "segment-tree-lazy-propagation-c",
                "content": "```\\nclass Solution {\\npublic:\\n    // Solution based on Segment Tree and Lazy propagation, I feel this solution is not optimal and can be optimized a lot.\\n    \\n    #define M (beg+end)/2\\n    void pushdown(int pos, int beg, int end,vector<int> &lazy, vector<int> &st)\\n    {\\n        if (lazy[pos] > 0)\\n        {\\n            st[pos] += (end - beg + 1) * lazy[pos];\\n            st[pos]%=26;\\n            if (beg != end)\\n            {\\n                lazy[2 * pos + 1] =(lazy[2 * pos + 1] + lazy[pos])%26;\\n                lazy[2 * pos + 2] =(lazy[2 * pos + 2] + lazy[pos])%26;\\n            }\\n            lazy[pos] = 0;\\n        }\\n    }\\n    \\n    void update(int beg, int end, int ul, int ur, int val, int pos,vector<int> &lazy,vector<int> &st)\\n    {\\n        pushdown(pos, beg, end,lazy,st);\\n        if (ul <= beg && ur >= end)\\n        {\\n            lazy[pos] += val;\\n            lazy[pos]%=26;\\n            pushdown(pos, beg, end,lazy,st);\\n            return;\\n        }\\n        if (ul > end || ur < beg)\\n            return;\\n        update(beg, M, ul, ur, val, 2 * pos + 1,lazy,st);\\n        update(M + 1, end, ul, ur, val, 2 * pos + 2,lazy,st);\\n        st[pos] = st[2 * pos + 1] + st[2 * pos + 2];\\n        st[pos]%=26;\\n    }\\n    \\n    int query(int beg, int end, int ql, int qr, int pos, vector<int> &lazy, vector<int> &st)\\n    {\\n        pushdown(pos, beg, end,lazy,st);\\n        if (ql <= beg && qr >= end)\\n        {\\n            return st[pos];\\n        }\\n        if (ql > end || qr < beg)\\n            return 0;\\n        return (query(beg, M, ql, qr, 2 * pos + 1,lazy,st) + query(M + 1, end, ql, qr, 2 * pos + 2,lazy,st))%26;\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        int m=shifts.size();\\n        vector<int> st(4*n);\\n        vector<int> lazy(4*n);\\n        for(int i=0; i<m; i++) {\\n            if(shifts[i][2]==0){\\n                update(0,n-1,shifts[i][0],shifts[i][1],25,0,lazy,st);\\n            }else{\\n                update(0,n-1,shifts[i][0],shifts[i][1],1,0,lazy,st);\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0; i<n; i++){\\n            // cout<<\"query : \"<<query(0,n-1,i,i,0,lazy,st)<<endl;\\n            ans+=(char(\\'a\\'+((((s[i]-\\'a\\'+query(0,n-1,i,i,0,lazy,st))%26)+26)%26)));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Solution based on Segment Tree and Lazy propagation, I feel this solution is not optimal and can be optimized a lot.\\n    \\n    #define M (beg+end)/2\\n    void pushdown(int pos, int beg, int end,vector<int> &lazy, vector<int> &st)\\n    {\\n        if (lazy[pos] > 0)\\n        {\\n            st[pos] += (end - beg + 1) * lazy[pos];\\n            st[pos]%=26;\\n            if (beg != end)\\n            {\\n                lazy[2 * pos + 1] =(lazy[2 * pos + 1] + lazy[pos])%26;\\n                lazy[2 * pos + 2] =(lazy[2 * pos + 2] + lazy[pos])%26;\\n            }\\n            lazy[pos] = 0;\\n        }\\n    }\\n    \\n    void update(int beg, int end, int ul, int ur, int val, int pos,vector<int> &lazy,vector<int> &st)\\n    {\\n        pushdown(pos, beg, end,lazy,st);\\n        if (ul <= beg && ur >= end)\\n        {\\n            lazy[pos] += val;\\n            lazy[pos]%=26;\\n            pushdown(pos, beg, end,lazy,st);\\n            return;\\n        }\\n        if (ul > end || ur < beg)\\n            return;\\n        update(beg, M, ul, ur, val, 2 * pos + 1,lazy,st);\\n        update(M + 1, end, ul, ur, val, 2 * pos + 2,lazy,st);\\n        st[pos] = st[2 * pos + 1] + st[2 * pos + 2];\\n        st[pos]%=26;\\n    }\\n    \\n    int query(int beg, int end, int ql, int qr, int pos, vector<int> &lazy, vector<int> &st)\\n    {\\n        pushdown(pos, beg, end,lazy,st);\\n        if (ql <= beg && qr >= end)\\n        {\\n            return st[pos];\\n        }\\n        if (ql > end || qr < beg)\\n            return 0;\\n        return (query(beg, M, ql, qr, 2 * pos + 1,lazy,st) + query(M + 1, end, ql, qr, 2 * pos + 2,lazy,st))%26;\\n    }\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        int m=shifts.size();\\n        vector<int> st(4*n);\\n        vector<int> lazy(4*n);\\n        for(int i=0; i<m; i++) {\\n            if(shifts[i][2]==0){\\n                update(0,n-1,shifts[i][0],shifts[i][1],25,0,lazy,st);\\n            }else{\\n                update(0,n-1,shifts[i][0],shifts[i][1],1,0,lazy,st);\\n            }\\n        }\\n        string ans=\"\";\\n        for(int i=0; i<n; i++){\\n            // cout<<\"query : \"<<query(0,n-1,i,i,0,lazy,st)<<endl;\\n            ans+=(char(\\'a\\'+((((s[i]-\\'a\\'+query(0,n-1,i,i,0,lazy,st))%26)+26)%26)));\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2454253,
                "title": "c-o-n-time",
                "content": "```\\n    public string ShiftingLetters(string s, int[][] shifts) \\n    {\\n        int[] change = new int[s.Length + 1];\\n        foreach (int[] shift in shifts)\\n        {\\n            if (shift[2] == 1)\\n            {\\n                change[shift[0]]++;\\n                change[shift[1] + 1]--;\\n            }\\n            else\\n            {\\n                change[shift[0]]--;\\n                change[shift[1] + 1]++;\\n            }\\n        }\\n\\n        StringBuilder sb = new StringBuilder(s);\\n        int pre = 0;\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            pre += change[i];\\n            int numChange = ((sb[i] - \\'a\\' + pre)%26 + 26)%26;\\n            sb[i] = (char)(\\'a\\' + numChange);\\n        }\\n        return sb.ToString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public string ShiftingLetters(string s, int[][] shifts) \\n    {\\n        int[] change = new int[s.Length + 1];\\n        foreach (int[] shift in shifts)\\n        {\\n            if (shift[2] == 1)\\n            {\\n                change[shift[0]]++;\\n                change[shift[1] + 1]--;\\n            }\\n            else\\n            {\\n                change[shift[0]]--;\\n                change[shift[1] + 1]++;\\n            }\\n        }\\n\\n        StringBuilder sb = new StringBuilder(s);\\n        int pre = 0;\\n        for (int i = 0; i < s.Length; i++)\\n        {\\n            pre += change[i];\\n            int numChange = ((sb[i] - \\'a\\' + pre)%26 + 26)%26;\\n            sb[i] = (char)(\\'a\\' + numChange);\\n        }\\n        return sb.ToString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454200,
                "title": "java-solution-o-n-range-sum-update-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int[] ch=new int[s.length()];\\n        for(int[] shift:shifts){\\n            int start=shift[0];\\n            int end=shift[1];\\n            int add=shift[2]==0?-1:1;\\n            ch[start]+=add;\\n            if(end+1<ch.length)\\n                ch[end+1]-=add;\\n        }\\n        int sum=0;\\n        for(int i=0;i<ch.length;i++){\\n            sum+=ch[i];\\n            ch[i]=sum;\\n        }\\n        \\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            int shift=ch[i];\\n            if(shift>=0)\\n                shift=ch[i]%26;\\n            else\\n                shift=ch[i]%26+26;\\n            \\n            if(shift==0)\\n                sb.append(s.charAt(i));\\n            else {\\n                int diff = c + shift;\\n                if (diff < 123)\\n                    sb.append((char) diff);\\n                else\\n                    sb.append((char) (diff - 123 + \\'a\\'));\\n            }\\n\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int[] ch=new int[s.length()];\\n        for(int[] shift:shifts){\\n            int start=shift[0];\\n            int end=shift[1];\\n            int add=shift[2]==0?-1:1;\\n            ch[start]+=add;\\n            if(end+1<ch.length)\\n                ch[end+1]-=add;\\n        }\\n        int sum=0;\\n        for(int i=0;i<ch.length;i++){\\n            sum+=ch[i];\\n            ch[i]=sum;\\n        }\\n        \\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<s.length();i++){\\n            char c=s.charAt(i);\\n            int shift=ch[i];\\n            if(shift>=0)\\n                shift=ch[i]%26;\\n            else\\n                shift=ch[i]%26+26;\\n            \\n            if(shift==0)\\n                sb.append(s.charAt(i));\\n            else {\\n                int diff = c + shift;\\n                if (diff < 123)\\n                    sb.append((char) diff);\\n                else\\n                    sb.append((char) (diff - 123 + \\'a\\'));\\n            }\\n\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086434,
                "title": "cpp-range-sum-o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nstring main=\"abcdefghijklmnopqrstuvwxyz\";\\nstd::map<char,int>char2intmap;\\nstd::map<int,char>int2charmap;\\n\\nchar shiftCharacter(char c, int shiftValue) {\\n    int newidx = char2intmap[c] + shiftValue;\\n    newidx = (newidx % 26 + 26) % 26;\\n    return int2charmap[newidx];\\n}\\n\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\nfor(int i=0;i<main.length();i++)\\n{\\n    char2intmap[main[i]]=i;\\n    int2charmap[i]=main[i];\\n}\\n        vector<int>util;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            util.push_back(0);\\n        }\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                util[shifts[i][0]]+=1;\\n                if(shifts[i][1]+1<s.length())\\n                {\\n                    util[shifts[i][1]+1]-=1;\\n                }\\n            }\\n            else\\n            {\\n                 util[shifts[i][0]]-=1;\\n                if(shifts[i][1]+1<s.length())\\n                {\\n                    util[shifts[i][1]+1]+=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<s.length();i++)\\n        {\\n            util[i]+=util[i-1];\\n        }\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            s[i]=shiftCharacter(s[i],util[i]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nstring main=\"abcdefghijklmnopqrstuvwxyz\";\\nstd::map<char,int>char2intmap;\\nstd::map<int,char>int2charmap;\\n\\nchar shiftCharacter(char c, int shiftValue) {\\n    int newidx = char2intmap[c] + shiftValue;\\n    newidx = (newidx % 26 + 26) % 26;\\n    return int2charmap[newidx];\\n}\\n\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\nfor(int i=0;i<main.length();i++)\\n{\\n    char2intmap[main[i]]=i;\\n    int2charmap[i]=main[i];\\n}\\n        vector<int>util;\\n        for(int i=0;i<s.length();i++)\\n        {\\n            util.push_back(0);\\n        }\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                util[shifts[i][0]]+=1;\\n                if(shifts[i][1]+1<s.length())\\n                {\\n                    util[shifts[i][1]+1]-=1;\\n                }\\n            }\\n            else\\n            {\\n                 util[shifts[i][0]]-=1;\\n                if(shifts[i][1]+1<s.length())\\n                {\\n                    util[shifts[i][1]+1]+=1;\\n                }\\n            }\\n        }\\n        for(int i=1;i<s.length();i++)\\n        {\\n            util[i]+=util[i-1];\\n        }\\n        \\n        for(int i=0;i<s.length();i++)\\n        {\\n            s[i]=shiftCharacter(s[i],util[i]);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3969482,
                "title": "o-n-javascript-typescript-solution-beats-100",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nconst shiftingLetters = (s: string, shifts: number[][]): string => {\\n  const shiftTracker = new Array(s.length + 1).fill(0);\\n\\n  for (const [start, end, direction] of shifts) {\\n    const amount = direction ? 1 : -1;\\n    shiftTracker[start] += amount;\\n    shiftTracker[end + 1] -= amount;\\n  }\\n\\n  let afterShift = \"\";\\n  let toShift = 0;\\n  for (let i = 0; i < s.length; i++) {\\n    toShift += shiftTracker[i];\\n    const letterNum = (s[i].charCodeAt(0) - 97 + toShift) % 26;\\n    afterShift += String.fromCharCode(letterNum + (letterNum < 0 ? 123 : 97));\\n  }\\n\\n  return afterShift;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript"
                ],
                "code": "```\\nconst shiftingLetters = (s: string, shifts: number[][]): string => {\\n  const shiftTracker = new Array(s.length + 1).fill(0);\\n\\n  for (const [start, end, direction] of shifts) {\\n    const amount = direction ? 1 : -1;\\n    shiftTracker[start] += amount;\\n    shiftTracker[end + 1] -= amount;\\n  }\\n\\n  let afterShift = \"\";\\n  let toShift = 0;\\n  for (let i = 0; i < s.length; i++) {\\n    toShift += shiftTracker[i];\\n    const letterNum = (s[i].charCodeAt(0) - 97 + toShift) % 26;\\n    afterShift += String.fromCharCode(letterNum + (letterNum < 0 ? 123 : 97));\\n  }\\n\\n  return afterShift;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3938533,
                "title": "rust-solution-from-interval-tree-to-o-n-solution",
                "content": "# First Intuition\\nWe have to update a range so the first idea can be to use an interval tree that updates ranges (in `O(log(n))`) and gets a single value (also in `O(log(n)`)).\\n\\n# Approach\\nWe construct an interval tree and then update every range from `shifts`.\\n\\n# Notes\\nObviously, when `shifts[i][2]` is `0` we can treat it as `-1` but to avoid if statements (which are typically slower than arithmetic operations) we can multiply it by `2` and then subtract `1`\\n\\nSecondly, to handle wrapping we can simply do `v mod 26` (we count `a` as `0`, `b` as `1`, and so on). Unfortunately when we for example do `-3%26` we get `-3` instead of `23` to fix this we will do `((v%26) + 26)%26` which gives desired results.\\n\\n# Complexity\\n`n` - string length\\n`m` - shifts count\\n- Time complexity: `O(nlog(n) + mlog(n))`\\n  - Constructing tree O(n) - because of creating vector\\n  - Updating tree with every of m shifts in `O(log(n))` so it\\'s `O(mlog(n))`\\n  - Reading every of `n` values in `O(log(n))` and making computation in `O(1)` so it\\'s `O(nlog(n))`\\n- Space complexity: `O(n)`\\n  - Tree has at worst `2*n - 1` elements, so it\\'s `O(n)`\\n\\n# Code\\n```\\nstruct IntervalTree {\\n    data: Vec<i32>,\\n    offset: usize,\\n}\\n\\nimpl IntervalTree {\\n    pub fn new(n: usize) -> Self {\\n        let offset = (2usize).pow((n as f64).log2().ceil() as u32); // Calculating how many elements we need to construct binary tree (element at index 0 is never used, root is at 1)\\n        Self { data: vec![0; offset + n], offset: offset }\\n    }\\n\\n    pub fn update(&mut self, mut p: usize, mut q: usize, c: i32) {\\n        p += self.offset;\\n        q += self.offset;\\n        self.data[p] += c;\\n        if p == q {\\n            return;\\n        }\\n        self.data[q] += c;\\n        let mut is_p_left = p%2 == 0;\\n        let mut is_q_right = q%2 == 1;\\n        p /= 2;\\n        q /= 2;\\n        while p != q {\\n            if is_p_left {\\n                self.data[p*2 + 1] += c;\\n            }\\n            if is_q_right {\\n                self.data[q*2] += c;\\n            }\\n            is_p_left = p%2 == 0;\\n            is_q_right = q%2 == 1;\\n            p /= 2;\\n            q /= 2;\\n        }\\n    }\\n\\n    pub fn get_value(&self, mut i: usize) -> i32 {\\n        i += self.offset;\\n        let mut ans = 0;\\n        while i != 0 {\\n            ans += self.data[i];\\n            i /= 2;\\n        }\\n        ans\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn shifting_letters(mut s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let mut tree = IntervalTree::new(s.len());\\n        for shift in shifts {\\n            tree.update(shift[0] as usize, shift[1] as usize, shift[2] as i32 * 2 - 1);\\n        }\\n        unsafe {    // Code is unsafe because of as_bytes_mut() - but since we are ensured that input is only lowercase english alphabet everything is safe\\n            for (i, char) in s.as_bytes_mut().into_iter().enumerate() {\\n                *char = ((((*char as i32 - 97) + tree.get_value(i))%26 + 26)%26) as u8 + 97;\\n            }\\n        }\\n        s\\n    }\\n}\\n```\\n\\n# Observation\\nAdding any value to every value of any arbitrary range of whole numbers `[beg; end]` is the same as adding it to every value of `[beg; inf)` and subtracting from every value of `(end; inf)`\\n\\n\\n# Approach\\nWe create an `array` in which `array[i]` represents a value that should be added to `[i;inf)` and then we fill it with shifts.\\nFinally, we iterate over the whole string keeping track of the current prefix sum of the `array` and adding it to every element of the string (of course we still have to do some modulo operations).\\n\\nIn other words:\\n``\\ns[i] += prefix_sum_of_array[i]\\n``\\n``\\ns[i] = ((s[i]%26) + 26)%26\\n``\\n\\n# Complexity\\n`n` - string length\\n`m` - shifts count\\n- Time complexity: `O(n + m)`\\n  - Creating `array` `O(n)`\\n  - Filling `array` with every of `m` shifts in `O(1)` each, so it\\'s `O(m)`\\n  - Iterating over every of `n` element of string and applying changes `O(1)`, so it\\'s `O(n)`\\n\\n- Space complexity: `O(n)`\\n  - `array` has `n + 1` elements, so it\\'s `O(n)`\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn shifting_letters(mut s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let mut suffix_add = vec![0; s.len() + 1];\\n        for mut shift in shifts {\\n            shift[2] += shift[2] - 1;   // turning 0 into -1 (and leaving 1 as 1)\\n            suffix_add[shift[0] as usize] += shift[2];  // applying change for [beg;inf)\\n            suffix_add[shift[1] as usize + 1] -= shift[2];  // applying  reversed change for (end; inf)\\n        }\\n        unsafe {    // Code is unsafe because of as_bytes_mut() - but since we are ensured that input is only lowercase english alphabet everything is safe\\n            let s = s.as_bytes_mut();\\n            let mut it = suffix_add.into_iter();    // We create iterator over suffix_add but it would be perfectly fine to use additional variable to keep track of current position\\n            let mut n = it.next().unwrap();                     \\n            for byte in s {                                 // ^... or we can simply enumerate\\n                *byte = ((((*byte as i32 - 97) + n)%26 + 26)%26) as u8 + 97;    // Whole magic :-) (Notes)\\n                n += it.next().unwrap();\\n            }\\n        }\\n        s\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nstruct IntervalTree {\\n    data: Vec<i32>,\\n    offset: usize,\\n}\\n\\nimpl IntervalTree {\\n    pub fn new(n: usize) -> Self {\\n        let offset = (2usize).pow((n as f64).log2().ceil() as u32); // Calculating how many elements we need to construct binary tree (element at index 0 is never used, root is at 1)\\n        Self { data: vec![0; offset + n], offset: offset }\\n    }\\n\\n    pub fn update(&mut self, mut p: usize, mut q: usize, c: i32) {\\n        p += self.offset;\\n        q += self.offset;\\n        self.data[p] += c;\\n        if p == q {\\n            return;\\n        }\\n        self.data[q] += c;\\n        let mut is_p_left = p%2 == 0;\\n        let mut is_q_right = q%2 == 1;\\n        p /= 2;\\n        q /= 2;\\n        while p != q {\\n            if is_p_left {\\n                self.data[p*2 + 1] += c;\\n            }\\n            if is_q_right {\\n                self.data[q*2] += c;\\n            }\\n            is_p_left = p%2 == 0;\\n            is_q_right = q%2 == 1;\\n            p /= 2;\\n            q /= 2;\\n        }\\n    }\\n\\n    pub fn get_value(&self, mut i: usize) -> i32 {\\n        i += self.offset;\\n        let mut ans = 0;\\n        while i != 0 {\\n            ans += self.data[i];\\n            i /= 2;\\n        }\\n        ans\\n    }\\n}\\n\\nimpl Solution {\\n    pub fn shifting_letters(mut s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let mut tree = IntervalTree::new(s.len());\\n        for shift in shifts {\\n            tree.update(shift[0] as usize, shift[1] as usize, shift[2] as i32 * 2 - 1);\\n        }\\n        unsafe {    // Code is unsafe because of as_bytes_mut() - but since we are ensured that input is only lowercase english alphabet everything is safe\\n            for (i, char) in s.as_bytes_mut().into_iter().enumerate() {\\n                *char = ((((*char as i32 - 97) + tree.get_value(i))%26 + 26)%26) as u8 + 97;\\n            }\\n        }\\n        s\\n    }\\n}\\n```\n```\\nimpl Solution {\\n    pub fn shifting_letters(mut s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let mut suffix_add = vec![0; s.len() + 1];\\n        for mut shift in shifts {\\n            shift[2] += shift[2] - 1;   // turning 0 into -1 (and leaving 1 as 1)\\n            suffix_add[shift[0] as usize] += shift[2];  // applying change for [beg;inf)\\n            suffix_add[shift[1] as usize + 1] -= shift[2];  // applying  reversed change for (end; inf)\\n        }\\n        unsafe {    // Code is unsafe because of as_bytes_mut() - but since we are ensured that input is only lowercase english alphabet everything is safe\\n            let s = s.as_bytes_mut();\\n            let mut it = suffix_add.into_iter();    // We create iterator over suffix_add but it would be perfectly fine to use additional variable to keep track of current position\\n            let mut n = it.next().unwrap();                     \\n            for byte in s {                                 // ^... or we can simply enumerate\\n                *byte = ((((*byte as i32 - 97) + n)%26 + 26)%26) as u8 + 97;    // Whole magic :-) (Notes)\\n                n += it.next().unwrap();\\n            }\\n        }\\n        s\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3932589,
                "title": "scaline-algo-prefix-sum",
                "content": "class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        //using scaline algorithm\\n        int n = s.length();\\n        int [] dir = new int[n + 1];\\n        \\n        for(int [] shift : shifts){\\n            int i = shift[0];\\n            int j = shift[1];\\n            int move = (shift[2] == 0 ? -1 : 1);\\n            dir[i] += move;\\n            dir[j + 1] -= move;\\n        }\\n        \\n        //now take the prefix sums\\n        for(int i = 1; i < n + 1; i++){\\n            dir[i] += dir[i - 1];\\n        }\\n        \\n        char [] res = new char[n];\\n        \\n        for(int i = 0; i < n; i++){\\n            int idx = (s.charAt(i) - \\'a\\' + dir[i]) % 26;\\n            if(idx < 0){\\n                idx += 26;\\n            }\\n            \\n           char newCh = (char)(idx + \\'a\\'); \\n            res[i] = newCh;\\n        }\\n        \\n        return new String(res);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        //using scaline algorithm\\n        int n = s.length();\\n        int [] dir = new int[n + 1];\\n        \\n        for(int [] shift : shifts){\\n            int i = shift[0];\\n            int j = shift[1];\\n            int move = (shift[2] == 0 ? -1 : 1);\\n            dir[i] += move;\\n            dir[j + 1] -= move;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3899045,
                "title": "c-clearly-explained-maintaining-ranges",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        // O(s.length() * shifts.length())  Brute Force....\\n        // We can optimmize thiis s.length() part, try and remove this\\n        // Preprocess the shifts...\\n        // arr of length of string + bookeeping in array = [{+|- freq},......]\\n        // +, - signifying forward or backward shifts\\n        // Go through the array uppdating the string ans. \\n        vector<int> bookeeping(s.length() + 1, 0);\\n        for(int i=0;i<shifts.size();i++){\\n          bool isfrwrd = shifts[i][2] == 1 ? true : false;\\n          if(isfrwrd){\\n            bookeeping[shifts[i][0]] += 1;\\n            bookeeping[shifts[i][1] + 1] -= 1; \\n          }else{\\n            bookeeping[shifts[i][0]] -= 1;\\n            bookeeping[shifts[i][1] + 1] += 1; \\n          }\\n        }\\n        int running = 0;\\n        for(int i=0;i<s.length();i++){\\n          int k = bookeeping[i]%26;\\n          running += k;\\n          running %= 26;\\n          int newVar = running + (s[i] - \\'a\\'); // New position of the updated character\\n          newVar = (newVar + 26)%26; // Handle Negatives..... \\n          s[i] = newVar + \\'a\\'; \\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        // O(s.length() * shifts.length())  Brute Force....\\n        // We can optimmize thiis s.length() part, try and remove this\\n        // Preprocess the shifts...\\n        // arr of length of string + bookeeping in array = [{+|- freq},......]\\n        // +, - signifying forward or backward shifts\\n        // Go through the array uppdating the string ans. \\n        vector<int> bookeeping(s.length() + 1, 0);\\n        for(int i=0;i<shifts.size();i++){\\n          bool isfrwrd = shifts[i][2] == 1 ? true : false;\\n          if(isfrwrd){\\n            bookeeping[shifts[i][0]] += 1;\\n            bookeeping[shifts[i][1] + 1] -= 1; \\n          }else{\\n            bookeeping[shifts[i][0]] -= 1;\\n            bookeeping[shifts[i][1] + 1] += 1; \\n          }\\n        }\\n        int running = 0;\\n        for(int i=0;i<s.length();i++){\\n          int k = bookeeping[i]%26;\\n          running += k;\\n          running %= 26;\\n          int newVar = running + (s[i] - \\'a\\'); // New position of the updated character\\n          newVar = (newVar + 26)%26; // Handle Negatives..... \\n          s[i] = newVar + \\'a\\'; \\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3881792,
                "title": "c-simple-sol",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& a)\\n    {\\n        int n=s.size();\\n        vector<int>v(n+1,0);\\n        for(auto &x:a)\\n        {\\n            v[x[0]]+=(x[2]==1)?1:-1;\\n            v[x[1]+1]+=(x[2]==1)?-1:1;\\n            v[x[0]]=(v[x[0]]+26)%26;\\n            v[x[1]+1]=(v[x[1]+1]+26)%26;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            v[i]+=(i>0)?v[i-1]:0;\\n            s[i]=\\'a\\'+((s[i]-\\'a\\')+v[i])%26;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& a)\\n    {\\n        int n=s.size();\\n        vector<int>v(n+1,0);\\n        for(auto &x:a)\\n        {\\n            v[x[0]]+=(x[2]==1)?1:-1;\\n            v[x[1]+1]+=(x[2]==1)?-1:1;\\n            v[x[0]]=(v[x[0]]+26)%26;\\n            v[x[1]+1]=(v[x[1]+1]+26)%26;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            v[i]+=(i>0)?v[i-1]:0;\\n            s[i]=\\'a\\'+((s[i]-\\'a\\')+v[i])%26;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3847262,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n       int n=s.size();\\n       vector<int>temp(n,0);\\n       for (auto it:shifts)\\n       {\\n           if (it[2]==0)\\n           {\\n             temp[it[0]]-=1;\\n             if (it[1]+1<n) temp[it[1]+1]+=1;\\n           }\\n           else\\n           {\\n               temp[it[0]]+=1;\\n             if (it[1]+1<n) temp[it[1]+1]-=1;\\n           }\\n       }\\n       string ans=\"\";\\n       int sum=0;\\n       for (int i=0;i<n;i++)\\n       {\\n           sum+=temp[i];\\n           sum=(sum+26)%26;\\n           int val=((s[i]-\\'a\\')+sum+26)%26;\\n           char ch=\\'a\\'+val;\\n           ans.push_back(ch);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n       int n=s.size();\\n       vector<int>temp(n,0);\\n       for (auto it:shifts)\\n       {\\n           if (it[2]==0)\\n           {\\n             temp[it[0]]-=1;\\n             if (it[1]+1<n) temp[it[1]+1]+=1;\\n           }\\n           else\\n           {\\n               temp[it[0]]+=1;\\n             if (it[1]+1<n) temp[it[1]+1]-=1;\\n           }\\n       }\\n       string ans=\"\";\\n       int sum=0;\\n       for (int i=0;i<n;i++)\\n       {\\n           sum+=temp[i];\\n           sum=(sum+26)%26;\\n           int val=((s[i]-\\'a\\')+sum+26)%26;\\n           char ch=\\'a\\'+val;\\n           ans.push_back(ch);\\n       }\\n       return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3835782,
                "title": "prefix-sum-python-97-in-runtime-98-in-space",
                "content": "# Intuition\\nFor each shift operation, the direct way is to shift all the chars in the range one by one. However, when the range is large, this brute force method is too slow. A better way is to calculated the cumulative shifts for each char first and then shift each char only once. To do this in an efficient way, we need to maintain an array `cnt` with the same length as `s`\\uFF0Cthen for the shift [start,end,direction], we should first transform direction into $\\\\pm 1$\\uFF0Cthen add `direction` to `cnt[start]` and substract it from `cnt[end+1]`. Finally, calculate the cumulative sums of `cnt` and they are just the cumulative shift distance for each char.\\n\\n# Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        base = ord(\"a\")\\n        s_int = [ord(c)-base for c in s]\\n        cnt = [0] * len(s)\\n        for start,end,direction in shifts:\\n            direction = 2*direction - 1\\n            cnt[start] += direction\\n            if end < len(s)-1:\\n                cnt[end+1] -= direction\\n        delta = cnt[0]\\n        s_int[0] = (s_int[0] + delta) % 26\\n        for i in range(1,len(cnt)):\\n            delta = (delta + cnt[i]) % 26\\n            s_int[i] = (s_int[i] + delta) % 26\\n        return \"\".join([chr(i+base) for i in s_int])\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        base = ord(\"a\")\\n        s_int = [ord(c)-base for c in s]\\n        cnt = [0] * len(s)\\n        for start,end,direction in shifts:\\n            direction = 2*direction - 1\\n            cnt[start] += direction\\n            if end < len(s)-1:\\n                cnt[end+1] -= direction\\n        delta = cnt[0]\\n        s_int[0] = (s_int[0] + delta) % 26\\n        for i in range(1,len(cnt)):\\n            delta = (delta + cnt[i]) % 26\\n            s_int[i] = (s_int[i] + delta) % 26\\n        return \"\".join([chr(i+base) for i in s_int])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814493,
                "title": "easiest-difference-array",
                "content": "# Intuition\\nWe can maintain an array which keeps track of the total positive and negative shift of each char in s. But that would take $$O(n\\xB2)$$ complexity. We need to use a difference array to reduce the time complexity. Difference array is kind of the reverse of presum array, and you can do further research on it before attempting this question, it is a classic range-update query algorithm. \\n\\n# Approach\\nWe traverse through shifts and appropriately update our difference array. Then we use a variable sum to gather the presum of this difference array(hint:The presum at each index is the change/shift for that index). Next, we calculate how the char is turned due to the change, and finally we update the characters one by one.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$ we traverse the shifts array and the difference array which is linear complexity.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$ extra space for difference array.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string &s, vector<vector<int>>& shifts) {\\n        int n=s.size(),sum=0,turn;\\n        vector<int> dif(n+1);\\n        for(auto &u:shifts){\\n            if(u[2]&1) dif[u[0]]++,dif[u[1]+1]--; \\n            else   dif[u[0]]-- ,  dif[u[1]+1]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            sum = (sum+dif[i])%26;\\n            turn =s[i]-\\'a\\'+sum+26;\\n            s[i] = \\'a\\' + turn %26;\\n        }\\n        return s;\\n    }\\n};\\n```\\n\\n*__UPVOTE IF EASY__*",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string &s, vector<vector<int>>& shifts) {\\n        int n=s.size(),sum=0,turn;\\n        vector<int> dif(n+1);\\n        for(auto &u:shifts){\\n            if(u[2]&1) dif[u[0]]++,dif[u[1]+1]--; \\n            else   dif[u[0]]-- ,  dif[u[1]+1]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            sum = (sum+dif[i])%26;\\n            turn =s[i]-\\'a\\'+sum+26;\\n            s[i] = \\'a\\' + turn %26;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3778541,
                "title": "c-line-sweep-easy-solution",
                "content": "# Approach\\nStore the contribution of each index using line sweep and then update each character in final string.\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> vec(n+1);\\n        for(auto &i:shifts)\\n        {\\n            int dir = i[2];\\n            if(dir==0)\\n            dir = -1;\\n            vec[i[0]] = (vec[i[0]]+dir+26)%26;\\n            vec[i[1]+1] = (vec[i[1]+1]-dir+26)%26;\\n        }\\n        for(int i=1;i<n+1;i++)\\n        vec[i]+=vec[i-1];\\n        for(int i=0;i<n+1;i++)\\n        vec[i]%=26;\\n        for(int i=0;i<n;i++)\\n        {\\n            s[i] = (((s[i]-\\'a\\')+vec[i])%26)+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Line Sweep",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> vec(n+1);\\n        for(auto &i:shifts)\\n        {\\n            int dir = i[2];\\n            if(dir==0)\\n            dir = -1;\\n            vec[i[0]] = (vec[i[0]]+dir+26)%26;\\n            vec[i[1]+1] = (vec[i[1]+1]-dir+26)%26;\\n        }\\n        for(int i=1;i<n+1;i++)\\n        vec[i]+=vec[i-1];\\n        for(int i=0;i<n+1;i++)\\n        vec[i]%=26;\\n        for(int i=0;i<n;i++)\\n        {\\n            s[i] = (((s[i]-\\'a\\')+vec[i])%26)+\\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3774892,
                "title": "line-sweep-algo",
                "content": "```\\nclass Solution {\\npublic:\\n    char findS(char c,int ct){\\n        int idx = c-\\'a\\';\\n        int pos = (26+idx+ct)%26;\\n        return \\'a\\'+pos;\\n    }\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> vec(n+1,0);\\n        \\n        for(auto it:shifts){\\n            if(it[2]){\\n                vec[it[0]]++;\\n                vec[it[1]+1]--;\\n            }\\n            else{\\n                vec[it[0]]--;\\n                vec[it[1]+1]++;\\n            }\\n        }\\n        \\n        int ct=0;\\n        for(int i=0;i<n;i++){\\n            int dir = vec[i]%26;\\n            ct = (ct + dir) % 26;\\n            char ch = findS(s[i],ct);\\n            s[i] = ch;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    char findS(char c,int ct){\\n        int idx = c-\\'a\\';\\n        int pos = (26+idx+ct)%26;\\n        return \\'a\\'+pos;\\n    }\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> vec(n+1,0);\\n        \\n        for(auto it:shifts){\\n            if(it[2]){\\n                vec[it[0]]++;\\n                vec[it[1]+1]--;\\n            }\\n            else{\\n                vec[it[0]]--;\\n                vec[it[1]+1]++;\\n            }\\n        }\\n        \\n        int ct=0;\\n        for(int i=0;i<n;i++){\\n            int dir = vec[i]%26;\\n            ct = (ct + dir) % 26;\\n            char ch = findS(s[i],ct);\\n            s[i] = ch;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3742530,
                "title": "most-smallest-code-i-bet-you-will-not-understand-last-line-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n        //AUTHOR :: MOHD FAISAL FROM INDIA\\n        int n=s.size(),sum=0;\\n        vector <int> v(n+1,0);\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            if(shifts[i][2]==0)v[shifts[i][0]]--,v[shifts[i][1]+1]++;\\n            else v[shifts[i][0]]++,v[shifts[i][1]+1]--;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            s[i]=char(\\'a\\'+int((s[i]-\\'a\\'+(sum+=v[i])%26+26)%26));\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n        //AUTHOR :: MOHD FAISAL FROM INDIA\\n        int n=s.size(),sum=0;\\n        vector <int> v(n+1,0);\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            if(shifts[i][2]==0)v[shifts[i][0]]--,v[shifts[i][1]+1]++;\\n            else v[shifts[i][0]]++,v[shifts[i][1]+1]--;\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            s[i]=char(\\'a\\'+int((s[i]-\\'a\\'+(sum+=v[i])%26+26)%26));\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3593600,
                "title": "o-n-time-and-space",
                "content": "# Intuition\\nSweep line\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n=len(s)\\n        delta = [0]*(n+1)\\n        for start, end, direction in shifts:\\n            delta[start] += 1 if direction==1 else -1\\n            delta[end+1] -= 1 if direction==1 else -1\\n\\n        res = []\\n        for i in range(n):\\n            if i:delta[i]+=delta[i-1]\\n            res.append(chr((ord(s[i]) - ord(\"a\") + delta[i]) % 26 + ord(\"a\")))\\n        return \"\".join(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n=len(s)\\n        delta = [0]*(n+1)\\n        for start, end, direction in shifts:\\n            delta[start] += 1 if direction==1 else -1\\n            delta[end+1] -= 1 if direction==1 else -1\\n\\n        res = []\\n        for i in range(n):\\n            if i:delta[i]+=delta[i-1]\\n            res.append(chr((ord(s[i]) - ord(\"a\") + delta[i]) % 26 + ord(\"a\")))\\n        return \"\".join(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3567965,
                "title": "prefix-sum-solution-with-explanation-easy-to-understand",
                "content": "# Intuition\\nAt first we see that we have to print the final string after performing all operation so we can perform operation at a time we don\\'t need to perform every time to do this we can use prefix sum technique to store how many time a operation perform in an index\\n\\n# Approach\\nTo solve this problem, we can declare two array one for forwad direction another for backward direction in those array we mark the starting index and ending index of every operation to do this we have to increase the array value in starting index of an operation and decrease the value for ending index then in those array we can do prefix sum after that we just travers every index and see how many time we have to do forward operation and backward we simply perform those operation in that index\\n\\n# Complexity\\n- Time complexity:\\nO(max(string size,shifts size))\\n\\n- Space complexity:\\nO(max(string size,shifts size))\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        int m=shifts.size();\\n        int prefixFor[n+1],prefixBck[n+1];\\n        memset(prefixFor,0,sizeof(prefixFor));\\n        memset(prefixBck,0,sizeof(prefixBck));\\n        for(int i=0;i<m;i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                prefixFor[shifts[i][0]]++;\\n                prefixFor[shifts[i][1]+1]--;\\n            }\\n            else\\n            {\\n                prefixBck[shifts[i][0]]++;\\n                prefixBck[shifts[i][1]+1]--;\\n            }\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            prefixFor[i]+=prefixFor[i-1];\\n            prefixBck[i]+=prefixBck[i-1];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int forwardDir=prefixFor[i]%26,backwardDir=prefixBck[i]%26;\\n            int finall=((s[i]-\\'a\\')+forwardDir-backwardDir+26)%26;\\n            s[i]=(finall+\\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        int m=shifts.size();\\n        int prefixFor[n+1],prefixBck[n+1];\\n        memset(prefixFor,0,sizeof(prefixFor));\\n        memset(prefixBck,0,sizeof(prefixBck));\\n        for(int i=0;i<m;i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                prefixFor[shifts[i][0]]++;\\n                prefixFor[shifts[i][1]+1]--;\\n            }\\n            else\\n            {\\n                prefixBck[shifts[i][0]]++;\\n                prefixBck[shifts[i][1]+1]--;\\n            }\\n        }\\n        for(int i=1;i<=n;i++)\\n        {\\n            prefixFor[i]+=prefixFor[i-1];\\n            prefixBck[i]+=prefixBck[i-1];\\n        }\\n        for(int i=0;i<n;i++)\\n        {\\n            int forwardDir=prefixFor[i]%26,backwardDir=prefixBck[i]%26;\\n            int finall=((s[i]-\\'a\\')+forwardDir-backwardDir+26)%26;\\n            s[i]=(finall+\\'a\\');\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566455,
                "title": "c-prefix-sum-faster-easy-and-clean-code",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& vec) {\\n        int n=s.size();\\n        int ar[n+5];\\n        for(int i=0;i<=n;i++)ar[i]=0;\\n        for(auto x:vec)\\n        {\\n            int a=x[0];\\n            int b=x[1];\\n            int c=x[2];\\n            if(c==0)\\n            {\\n                ar[a]--;\\n                ar[b+1]++;\\n            }\\n            else \\n            {\\n                ar[a]++;\\n                ar[b+1]--;\\n            }\\n        }\\n        for(int i=1;i<n;i++)ar[i]+=ar[i-1];\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=s[i]-\\'a\\';\\n            x=(x+26+(ar[i]%26))%26;\\n            x+=97;\\n            s[i]=char(x);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& vec) {\\n        int n=s.size();\\n        int ar[n+5];\\n        for(int i=0;i<=n;i++)ar[i]=0;\\n        for(auto x:vec)\\n        {\\n            int a=x[0];\\n            int b=x[1];\\n            int c=x[2];\\n            if(c==0)\\n            {\\n                ar[a]--;\\n                ar[b+1]++;\\n            }\\n            else \\n            {\\n                ar[a]++;\\n                ar[b+1]--;\\n            }\\n        }\\n        for(int i=1;i<n;i++)ar[i]+=ar[i-1];\\n        for(int i=0;i<n;i++)\\n        {\\n            int x=s[i]-\\'a\\';\\n            x=(x+26+(ar[i]%26))%26;\\n            x+=97;\\n            s[i]=char(x);\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3553363,
                "title": "rust-diff-array-and-prefix-o-n-solution-100",
                "content": "# Intuition\\n\\nOriginal array is the prefix sum of it\\'s diff array.\\nif you want to update range from [a, b] to some value -\\nupdate diff[a] += val and diff[b + 1] -= val, then build the prefix sum and convert indexes to chars\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn shifting_letters(s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let letters = (\\'a\\'..=\\'z\\').collect::<Vec<_>>();\\n        let s = s.chars().map(|x| x as i32 - \\'a\\' as i32).collect::<Vec<_>>();\\n\\n        let mut diff = vec![s[0]];\\n        for i in 1..s.len() {\\n            diff.push(s[i] - s[i - 1]);\\n        }\\n        let n = diff.len();\\n\\n        for sh in shifts {\\n            let (left, right, val) = (\\n                sh[0] as usize,\\n                sh[1] as usize,\\n                if sh[2] == 0 { -1 } else { 1 },\\n            );\\n            diff[left] += val;\\n            diff[left] %= 26;\\n            if right + 1 < n {\\n                diff[right + 1] -= val;\\n                diff[right] %= 26;\\n            }\\n        }\\n        // converting to prefix sum, e.g. new original array\\n        for i in 1..n {\\n            diff[i] += diff[i - 1] % 26;\\n            diff[i] %= 26;\\n        }\\n        \\n        diff.into_iter()\\n            .map(|x| letters[((x + 26) % 26) as usize])\\n            .collect()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn shifting_letters(s: String, shifts: Vec<Vec<i32>>) -> String {\\n        let letters = (\\'a\\'..=\\'z\\').collect::<Vec<_>>();\\n        let s = s.chars().map(|x| x as i32 - \\'a\\' as i32).collect::<Vec<_>>();\\n\\n        let mut diff = vec![s[0]];\\n        for i in 1..s.len() {\\n            diff.push(s[i] - s[i - 1]);\\n        }\\n        let n = diff.len();\\n\\n        for sh in shifts {\\n            let (left, right, val) = (\\n                sh[0] as usize,\\n                sh[1] as usize,\\n                if sh[2] == 0 { -1 } else { 1 },\\n            );\\n            diff[left] += val;\\n            diff[left] %= 26;\\n            if right + 1 < n {\\n                diff[right + 1] -= val;\\n                diff[right] %= 26;\\n            }\\n        }\\n        // converting to prefix sum, e.g. new original array\\n        for i in 1..n {\\n            diff[i] += diff[i - 1] % 26;\\n            diff[i] %= 26;\\n        }\\n        \\n        diff.into_iter()\\n            .map(|x| letters[((x + 26) % 26) as usize])\\n            .collect()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3538804,
                "title": "segment-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    String str;\\n    int [] tree;\\n    int []moves;\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        tree=new int [s.length()*4];\\n        moves=new int[s.length()-1];\\n        for(int []arr:shifts)\\n            if(arr[2]!=1)\\n                update(0,s.length()-1,0,arr[0],arr[1],-1);\\n            else\\n                update(0,s.length()-1,0,arr[0],arr[1],1);\\n        char [] arr=s.toCharArray();\\n        int range = 26;\\n        for(int i=0; i<s.length();i++){\\n            int value=query(0,s.length()-1,0,i);\\n            int currentOffset = arr[i] - \\'a\\';\\n            int newOffset = (currentOffset + value%26+range) % range;  \\n            arr[i] = (char) (\\'a\\' + newOffset);\\n        }\\n\\n        return String.valueOf(arr);\\n\\n\\n        \\n    }\\n    void update(int leftB, int rightB, int index, int l, int r,int sign)\\n    {\\n        int [] arr=tree;\\n        int mid=(leftB+rightB)/2;\\n        if(l>rightB||leftB>r)\\n            return;\\n        if(l<=leftB&&r>=rightB)\\n            tree[index]+=sign;\\n        else{\\n            update(leftB,mid,index*2+1,l,r,sign);\\n            update(mid+1,rightB,index*2+2,l,r,sign);\\n        }\\n    }\\n    int query(int leftB, int rightB, int ti,int index)\\n    {\\n        int []arr=tree;\\n        int mid=(leftB+rightB)/2;\\n        if(index>rightB||index<leftB)\\n            return 0;\\n        if(leftB==rightB)\\n            return tree[ti];\\n        return tree[ti]+query(leftB,mid,ti*2+1,index)+query(mid+1,rightB,ti*2+2,index);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    String str;\\n    int [] tree;\\n    int []moves;\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        tree=new int [s.length()*4];\\n        moves=new int[s.length()-1];\\n        for(int []arr:shifts)\\n            if(arr[2]!=1)\\n                update(0,s.length()-1,0,arr[0],arr[1],-1);\\n            else\\n                update(0,s.length()-1,0,arr[0],arr[1],1);\\n        char [] arr=s.toCharArray();\\n        int range = 26;\\n        for(int i=0; i<s.length();i++){\\n            int value=query(0,s.length()-1,0,i);\\n            int currentOffset = arr[i] - \\'a\\';\\n            int newOffset = (currentOffset + value%26+range) % range;  \\n            arr[i] = (char) (\\'a\\' + newOffset);\\n        }\\n\\n        return String.valueOf(arr);\\n\\n\\n        \\n    }\\n    void update(int leftB, int rightB, int index, int l, int r,int sign)\\n    {\\n        int [] arr=tree;\\n        int mid=(leftB+rightB)/2;\\n        if(l>rightB||leftB>r)\\n            return;\\n        if(l<=leftB&&r>=rightB)\\n            tree[index]+=sign;\\n        else{\\n            update(leftB,mid,index*2+1,l,r,sign);\\n            update(mid+1,rightB,index*2+2,l,r,sign);\\n        }\\n    }\\n    int query(int leftB, int rightB, int ti,int index)\\n    {\\n        int []arr=tree;\\n        int mid=(leftB+rightB)/2;\\n        if(index>rightB||index<leftB)\\n            return 0;\\n        if(leftB==rightB)\\n            return tree[ti];\\n        return tree[ti]+query(leftB,mid,ti*2+1,index)+query(mid+1,rightB,ti*2+2,index);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3538286,
                "title": "line-sweep-algorithm-solution-c-best-approach-for-this-question",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> line(n+1,0);\\n        for(int i=0;i<shifts.size();i++){\\n            int a = shifts[i][0];\\n            int b = shifts[i][1];\\n            int direction = shifts[i][2];\\n            if(direction == 1){\\n                //move forward\\n                line[a]++;\\n                line[b+1]--;\\n            }\\n            else if(direction == 0){\\n                //move backward\\n                line[a]--;\\n                line[b+1]++;\\n            }\\n        }\\n        string a = \"\";\\n        //line sweep algorithm great \\n        cout<<endl;\\n        int currentsum = 0;\\n        for(int i=0;i<n;i++){\\n            currentsum = currentsum + line[i];\\n            if(currentsum >= 0){\\n            char c = ((s[i]-\\'a\\' + currentsum)%26) + \\'a\\';\\n                a+=c;\\n            }\\n            else if(currentsum < 0){\\n                int ass = s[i]-\\'a\\' + currentsum;\\n                while(ass<0){\\n                    ass+=26;\\n                }\\n                char c = ass + \\'a\\';\\n                a+=c;\\n\\n            }\\n        }\\n        return a;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> line(n+1,0);\\n        for(int i=0;i<shifts.size();i++){\\n            int a = shifts[i][0];\\n            int b = shifts[i][1];\\n            int direction = shifts[i][2];\\n            if(direction == 1){\\n                //move forward\\n                line[a]++;\\n                line[b+1]--;\\n            }\\n            else if(direction == 0){\\n                //move backward\\n                line[a]--;\\n                line[b+1]++;\\n            }\\n        }\\n        string a = \"\";\\n        //line sweep algorithm great \\n        cout<<endl;\\n        int currentsum = 0;\\n        for(int i=0;i<n;i++){\\n            currentsum = currentsum + line[i];\\n            if(currentsum >= 0){\\n            char c = ((s[i]-\\'a\\' + currentsum)%26) + \\'a\\';\\n                a+=c;\\n            }\\n            else if(currentsum < 0){\\n                int ass = s[i]-\\'a\\' + currentsum;\\n                while(ass<0){\\n                    ass+=26;\\n                }\\n                char c = ass + \\'a\\';\\n                a+=c;\\n\\n            }\\n        }\\n        return a;\\n\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3490375,
                "title": "translate-lachezartsk-s-javascript-to-typescript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nI simply translated LachezarTsK\\'s approach from JavaScript to TypeScript.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n\\nThe code first defines a constant called ALPHABET_SIZE which is the number of letters in the alphabet (26). It also defines a constant called ASCII_SMALL_CASE_A which is the ASCII code for the letter \\'a\\' (97).\\n\\nNext, the code defines an array called totalShifts. This array will be used to store the total number of shifts that have been applied to each letter in the input string. The array is initialized to all zeros.\\n\\nThe next loop iterates through the shifts array. The shifts array is an array of arrays. Each inner array contains three elements: the start index, the end index, and the shift amount.\\n\\nFor each inner array, the code adds the shift amount to the totalShifts array at the start index. It then subtracts the shift amount from the totalShifts array at the end index + 1.\\n\\nNext, the code defines an array called shiftedLetters. This array will be used to store the shifted letters of the input string. The array is initialized to be the same as the input string.\\n\\nThe next loop iterates through the shiftedLetters array. For each letter, the code calculates the new position of the letter by adding the total shift for that letter to the original position of the letter. The code then uses the String.fromCodePoint() function to convert the new position to a letter.\\n\\nThe final step is to join the shiftedLetters array together to form a string. The code then returns the string.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThe time complexity is $$O(n)$$. This is because the code iterates through the shifts array once, and the input and shiftedLetters arrays twice. The number of iterations is proportional to the length of the input string.\\n\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\nThe space complexity is $$O(n)$$, where n is the length of the input string. This is because the code only needs to store the input string, the totalShifts array, and the shiftedLetters array. The size of these arrays is proportional to the length of the input string.\\n\\n\\n# Code\\n```\\nfunction shiftingLetters(input: string, shifts: number[][]): string {\\n  const ALPHABET_SIZE = 26;\\n  const ASCII_SMALL_CASE_A = 97;\\n  const totalShifts = new Array(input.length + 1).fill(0);\\n\\n  for (let shift of shifts) {\\n    const change = (shift[2] === 1) ? 1 : -1;\\n    totalShifts[shift[0]] += change;\\n    totalShifts[shift[1] + 1] -= change;\\n  }\\n\\n  let shiftedLetters = input.split(\\'\\');\\n  for (let i = 0; i < input.length; ++i) {\\n    const currentShift = (input.codePointAt(i) - ASCII_SMALL_CASE_A + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                             % ALPHABET_SIZE;\\n    shiftedLetters[i] = String.fromCodePoint(currentShift + ASCII_SMALL_CASE_A);\\n    totalShifts[i + 1] += totalShifts[i];\\n  }\\n\\n  return shiftedLetters.join(\\'\\');\\n}\\n```",
                "solutionTags": [
                    "TypeScript"
                ],
                "code": "```\\nfunction shiftingLetters(input: string, shifts: number[][]): string {\\n  const ALPHABET_SIZE = 26;\\n  const ASCII_SMALL_CASE_A = 97;\\n  const totalShifts = new Array(input.length + 1).fill(0);\\n\\n  for (let shift of shifts) {\\n    const change = (shift[2] === 1) ? 1 : -1;\\n    totalShifts[shift[0]] += change;\\n    totalShifts[shift[1] + 1] -= change;\\n  }\\n\\n  let shiftedLetters = input.split(\\'\\');\\n  for (let i = 0; i < input.length; ++i) {\\n    const currentShift = (input.codePointAt(i) - ASCII_SMALL_CASE_A + totalShifts[i] % ALPHABET_SIZE + ALPHABET_SIZE)\\n                             % ALPHABET_SIZE;\\n    shiftedLetters[i] = String.fromCodePoint(currentShift + ASCII_SMALL_CASE_A);\\n    totalShifts[i + 1] += totalShifts[i];\\n  }\\n\\n  return shiftedLetters.join(\\'\\');\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3457566,
                "title": "prefix-sum-easy-c-solution",
                "content": "# Code\\n```\\nclass Solution \\n{\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n        int n=s.size();\\n        vector<int> v(n+1,0);\\n        for(int x=0; x<shifts.size(); x++)\\n        {\\n            int st=shifts[x][0], en=shifts[x][1], forward=shifts[x][2];\\n            if(forward)\\n            {\\n                v[st]++;\\n                v[en+1]--;\\n            }\\n            else\\n            {\\n                v[st]--;\\n                v[en+1]++;\\n            }\\n        }\\n        v[0]=(v[0]%26+26)%26;\\n        for(int x=1; x<n+1; x++) v[x]=(v[x-1]+v[x]%26+26)%26;\\n        for(auto it: v) cout<<it<<\" \";\\n        cout<<endl;\\n        for(int x=0; x<n; x++)\\n        {\\n            for(int y=1; y<=v[x]; y++)\\n            {\\n                if(s[x]==\\'z\\')\\n                {\\n                    s[x]=\\'a\\';\\n                    continue;\\n                }\\n                s[x]++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n        int n=s.size();\\n        vector<int> v(n+1,0);\\n        for(int x=0; x<shifts.size(); x++)\\n        {\\n            int st=shifts[x][0], en=shifts[x][1], forward=shifts[x][2];\\n            if(forward)\\n            {\\n                v[st]++;\\n                v[en+1]--;\\n            }\\n            else\\n            {\\n                v[st]--;\\n                v[en+1]++;\\n            }\\n        }\\n        v[0]=(v[0]%26+26)%26;\\n        for(int x=1; x<n+1; x++) v[x]=(v[x-1]+v[x]%26+26)%26;\\n        for(auto it: v) cout<<it<<\" \";\\n        cout<<endl;\\n        for(int x=0; x<n; x++)\\n        {\\n            for(int y=1; y<=v[x]; y++)\\n            {\\n                if(s[x]==\\'z\\')\\n                {\\n                    s[x]=\\'a\\';\\n                    continue;\\n                }\\n                s[x]++;\\n            }\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3393419,
                "title": "line-sweep",
                "content": "**time: `O(N+S)`; space: `O(S)`**\\n```\\nstring shiftingLetters(string s, vector<vector<int>>& x)\\n{\\n\\tint d[50001]{};\\n\\tfor(const auto & x : x)\\n\\t\\td[x[0]]+=2*x[2]-1, d[x[1]+1]-=2*x[2]-1;\\n\\n\\tfor(int t{}, i{}; i<size(s); ++i)          \\n\\t\\ts[i]=\\'a\\'+(s[i]+(t+=d[i])+2600000-\\'a\\')%26;\\n\\treturn s;\\n}\\n```\\n**Similar problems:**\\n[2406. Divide Intervals Into Minimum Number of Groups](https://leetcode.com/problems/divide-intervals-into-minimum-number-of-groups/discuss/3393422/line-sweep)\\n[2381. Shifting Letters II](https://leetcode.com/problems/shifting-letters-ii/discuss/3393419/line-sweep)\\n[1943. Describe the Painting](https://leetcode.com/problems/describe-the-painting/discuss/3387661/line-sweep)\\n[253. Meeting Rooms II](https://leetcode.com/problems/meeting-rooms-ii/discuss/2115681/few-solutions)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring shiftingLetters(string s, vector<vector<int>>& x)\\n{\\n\\tint d[50001]{};\\n\\tfor(const auto & x : x)\\n\\t\\td[x[0]]+=2*x[2]-1, d[x[1]+1]-=2*x[2]-1;\\n\\n\\tfor(int t{}, i{}; i<size(s); ++i)          \\n\\t\\ts[i]=\\'a\\'+(s[i]+(t+=d[i])+2600000-\\'a\\')%26;\\n\\treturn s;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3388373,
                "title": "c-accumulate-line-sweep",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> sf(s.size(), 0);\\n        for(int i = 0; i < shifts.size(); i++){\\n            if(shifts[i][2] == 1){\\n                sf[shifts[i][0]]++;\\n                if(shifts[i][1] < s.size()-1)\\n                    sf[shifts[i][1]+1]--;\\n            }\\n            else if(shifts[i][2] == 0){\\n                sf[shifts[i][0]]--;\\n                if(shifts[i][1] < s.size()-1)\\n                    sf[shifts[i][1]+1]++;\\n            }\\n        }\\n        for(int i = 1; i < sf.size(); i++) sf[i] += sf[i-1];\\n        for(int i = 0; i < s.size(); i++){\\n            int val = s[i] - \\'a\\' + sf[i];\\n            while(val < 0) val += 26;\\n            val = val % 26;\\n            s[i] = val + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> sf(s.size(), 0);\\n        for(int i = 0; i < shifts.size(); i++){\\n            if(shifts[i][2] == 1){\\n                sf[shifts[i][0]]++;\\n                if(shifts[i][1] < s.size()-1)\\n                    sf[shifts[i][1]+1]--;\\n            }\\n            else if(shifts[i][2] == 0){\\n                sf[shifts[i][0]]--;\\n                if(shifts[i][1] < s.size()-1)\\n                    sf[shifts[i][1]+1]++;\\n            }\\n        }\\n        for(int i = 1; i < sf.size(); i++) sf[i] += sf[i-1];\\n        for(int i = 0; i < s.size(); i++){\\n            int val = s[i] - \\'a\\' + sf[i];\\n            while(val < 0) val += 26;\\n            val = val % 26;\\n            s[i] = val + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3345046,
                "title": "beats-100-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n          int n=s.size(),sum=0;\\n        vector <int> v(n+1,0);\\n        \\n        for(int i=0;i<shifts.size();i++){\\n            int l=shifts[i][0];\\n            int r=shifts[i][1];\\n            if(shifts[i][2]==0){\\n                v[l]--;\\n                v[r+1]++;\\n            }\\n            else{\\n                v[l]++;\\n                v[r+1]--;\\n            }\\n        }\\n    \\n        for(int i=0;i<n;i++){\\n            sum+=v[i];\\n            int k=sum%26;\\n            int p=(s[i]-\\'a\\'+k+26)%26;\\n            s[i]=char(\\'a\\'+p);\\n        }\\n        return s;\\n\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) \\n    {\\n          int n=s.size(),sum=0;\\n        vector <int> v(n+1,0);\\n        \\n        for(int i=0;i<shifts.size();i++){\\n            int l=shifts[i][0];\\n            int r=shifts[i][1];\\n            if(shifts[i][2]==0){\\n                v[l]--;\\n                v[r+1]++;\\n            }\\n            else{\\n                v[l]++;\\n                v[r+1]--;\\n            }\\n        }\\n    \\n        for(int i=0;i<n;i++){\\n            sum+=v[i];\\n            int k=sum%26;\\n            int p=(s[i]-\\'a\\'+k+26)%26;\\n            s[i]=char(\\'a\\'+p);\\n        }\\n        return s;\\n\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3310229,
                "title": "c-golang-prefix-sum",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        vector<int> prefix(n, 0);\\n        for(vector<int> shift: shifts) {\\n            prefix[shift[0]] += (shift[2] == 1? 1: -1);\\n            if(shift[1] + 1 < n)\\n                prefix[shift[1] + 1] -= (shift[2] == 1? 1: -1);\\n        }\\n        for(int i = 0; i < n; i++) {\\n            prefix[i] = (prefix[i] + (i > 0? prefix[i - 1]: 0)) % 26;\\n            int val = s[i] + prefix[i];\\n            val -= val > \\'z\\'? 26: 0;\\n            val += val < \\'a\\'? 26: 0;\\n            s[i] = val;\\n        }\\n        return s;\\n    }\\n};\\n\\n\\n// Golang\\nfunc shiftingLetters(s string, shifts [][]int) string {\\n    var n int = len(s)\\n    prefix := make([]int, n)\\n    for _, shift := range shifts {\\n        val := -1\\n        if shift[2] == 1 { val = 1 }\\n        prefix[shift[0]] += val\\n        if shift[1] + 1 < n {\\n            prefix[shift[1] + 1] -= val\\n        }\\n    }\\n    prefix[0] %= 26\\n    b := make([]byte, n)\\n    for i := 0; i < n; i++ {\\n        if i > 0 {\\n             prefix[i] = (prefix[i] + prefix[i - 1]) % 26\\n        }\\n        var val int = int(s[i]) + prefix[i]\\n        if val > \\'z\\' {val -= 26}\\n        if val < \\'a\\' {val += 26}\\n        b[i] = byte(val)\\n    }\\n    return string(b)\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Array",
                    "String",
                    "Prefix Sum"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.length();\\n        vector<int> prefix(n, 0);\\n        for(vector<int> shift: shifts) {\\n            prefix[shift[0]] += (shift[2] == 1? 1: -1);\\n            if(shift[1] + 1 < n)\\n                prefix[shift[1] + 1] -= (shift[2] == 1? 1: -1);\\n        }\\n        for(int i = 0; i < n; i++) {\\n            prefix[i] = (prefix[i] + (i > 0? prefix[i - 1]: 0)) % 26;\\n            int val = s[i] + prefix[i];\\n            val -= val > \\'z\\'? 26: 0;\\n            val += val < \\'a\\'? 26: 0;\\n            s[i] = val;\\n        }\\n        return s;\\n    }\\n};\\n\\n\\n// Golang\\nfunc shiftingLetters(s string, shifts [][]int) string {\\n    var n int = len(s)\\n    prefix := make([]int, n)\\n    for _, shift := range shifts {\\n        val := -1\\n        if shift[2] == 1 { val = 1 }\\n        prefix[shift[0]] += val\\n        if shift[1] + 1 < n {\\n            prefix[shift[1] + 1] -= val\\n        }\\n    }\\n    prefix[0] %= 26\\n    b := make([]byte, n)\\n    for i := 0; i < n; i++ {\\n        if i > 0 {\\n             prefix[i] = (prefix[i] + prefix[i - 1]) % 26\\n        }\\n        var val int = int(s[i]) + prefix[i]\\n        if val > \\'z\\' {val -= 26}\\n        if val < \\'a\\' {val += 26}\\n        b[i] = byte(val)\\n    }\\n    return string(b)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3297769,
                "title": "java-concise-linesweep",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int N = s.length();\\n        int[] A = new int[N+1];\\n        for(int[] S : shifts){\\n            if(S[2] == 1){\\n                A[S[0]]++;\\n                A[S[1]+1]--;\\n            }else{\\n                A[S[0]]--;\\n                A[S[1]+1]++;\\n            }\\n        }\\n        \\n        int shift = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<N; i++){\\n            shift += A[i];\\n            int n = (((s.charAt(i) - \\'a\\') + shift) % 26 + 26) % 26;\\n            sb.append((char)(\\'a\\' + n));\\n        }\\n        return sb.toString();\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int N = s.length();\\n        int[] A = new int[N+1];\\n        for(int[] S : shifts){\\n            if(S[2] == 1){\\n                A[S[0]]++;\\n                A[S[1]+1]--;\\n            }else{\\n                A[S[0]]--;\\n                A[S[1]+1]++;\\n            }\\n        }\\n        \\n        int shift = 0;\\n        StringBuilder sb = new StringBuilder();\\n        for(int i=0; i<N; i++){\\n            shift += A[i];\\n            int n = (((s.charAt(i) - \\'a\\') + shift) % 26 + 26) % 26;\\n            sb.append((char)(\\'a\\' + n));\\n        }\\n        return sb.toString();\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3240516,
                "title": "line-sweep-c",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> v(n + 1);\\n\\n        for(auto i : shifts) {\\n            if(i[2]) {\\n                v[i[0]]++;\\n                v[i[1] + 1]--;\\n            }\\n            else {\\n                v[i[0]]--;\\n                v[i[1] + 1]++;\\n            }\\n        }\\n        for(int i=1; i<=n; i++) {\\n            v[i] += v[i - 1];\\n        }\\n        for(int i=0; i<n; i++) {\\n            s[i] = (s[i] - \\'a\\' + v[i] % 26 + 26) % 26 + 97;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Line Sweep"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        vector<int> v(n + 1);\\n\\n        for(auto i : shifts) {\\n            if(i[2]) {\\n                v[i[0]]++;\\n                v[i[1] + 1]--;\\n            }\\n            else {\\n                v[i[0]]--;\\n                v[i[1] + 1]++;\\n            }\\n        }\\n        for(int i=1; i<=n; i++) {\\n            v[i] += v[i - 1];\\n        }\\n        for(int i=0; i<n; i++) {\\n            s[i] = (s[i] - \\'a\\' + v[i] % 26 + 26) % 26 + 97;\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236883,
                "title": "easy-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n\\n       int[] res = new int[s.length()];\\n       for( int[] ch :shifts){\\n           int i=ch[0];\\n           int j=ch[1];\\n           int k=ch[2];\\n           if(k==1){\\n               for(int l=i;l<=j;l++){\\n                   res[l]++;\\n               }\\n           }else{\\n               for(int l=i; l<=j;l++){\\n                   res[l]--;\\n               }\\n           }\\n\\n       }\\n       char[] check=s.toCharArray();\\n       for(int i=0; i<s.length();i++){\\n           int newchar=((s.charAt(i)-\\'a\\')+res[i])%26;\\n           if(newchar<0) newchar+=26;\\n           check[i]=(char)(newchar+\\'a\\');\\n       }\\n       \\n       return String.valueOf(check);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n\\n       int[] res = new int[s.length()];\\n       for( int[] ch :shifts){\\n           int i=ch[0];\\n           int j=ch[1];\\n           int k=ch[2];\\n           if(k==1){\\n               for(int l=i;l<=j;l++){\\n                   res[l]++;\\n               }\\n           }else{\\n               for(int l=i; l<=j;l++){\\n                   res[l]--;\\n               }\\n           }\\n\\n       }\\n       char[] check=s.toCharArray();\\n       for(int i=0; i<s.length();i++){\\n           int newchar=((s.charAt(i)-\\'a\\')+res[i])%26;\\n           if(newchar<0) newchar+=26;\\n           check[i]=(char)(newchar+\\'a\\');\\n       }\\n       \\n       return String.valueOf(check);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3234339,
                "title": "c-o-n-m-simple-prefix-sum-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMove an interval `[l, r]` forward for 1 alphabet is equivalent to a representation of \\n```\\n[0,...,1,0,0,...,0,-1,0,..,0]\\n       ^           ^\\n       l           r+1\\nprefix sum:\\n[0,...,1,1,1,...,1,0 ,0,..,0]\\n```\\nwhere the 1 at entry `l` means every element after index `l` are shifted by 1 char forward. The -1 at `r+1` means we are resetting the element after `r+1` backward for one char.\\n\\nSuch representation is accumulative, meaning we can accumulate all the shifts and then compute the total shift of each element. The representation can also be updated in `O(1)` time for each interval shift.\\n\\nWhen querying the total shift after all the operations at index `i`, it is equivalent to the prefix sum of `0` to `i` in the above array.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrefix Sum\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$O(|shift| + n)$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$O(n)$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        int shift[n+1];\\n        memset(shift, 0, sizeof(shift));\\n        for (auto & v: shifts) {\\n            int d = v[2]?1:-1;\\n            shift[v[0]] += d;\\n            shift[v[1]+1] -= d;\\n        }\\n        int cur = 0;\\n        for (int i = 0; i < n; ++i) {\\n            cur += shift[i];\\n            s[i] = (((s[i]-\\'a\\' + cur) % 26) + 26) % 26 + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Prefix Sum"
                ],
                "code": "```\\n[0,...,1,0,0,...,0,-1,0,..,0]\\n       ^           ^\\n       l           r+1\\nprefix sum:\\n[0,...,1,1,1,...,1,0 ,0,..,0]\\n```\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size();\\n        int shift[n+1];\\n        memset(shift, 0, sizeof(shift));\\n        for (auto & v: shifts) {\\n            int d = v[2]?1:-1;\\n            shift[v[0]] += d;\\n            shift[v[1]+1] -= d;\\n        }\\n        int cur = 0;\\n        for (int i = 0; i < n; ++i) {\\n            cur += shift[i];\\n            s[i] = (((s[i]-\\'a\\' + cur) % 26) + 26) % 26 + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226312,
                "title": "python-2381-shifting-letters-ii-easy-and-neat-python-code",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        temp=[0 for i in range(len(s) + 1)]\\n        \\n        for start, end, state in shifts:\\n            temp[start] += [1, -1][1 - state]\\n            temp[end + 1] -= [1, -1][1 - state]\\n                \\n        total = 0\\n        for i in range(len(temp)):\\n            total += temp[i]\\n            temp[i] = total\\n        \\n        ans=\"\"\\n        for i in range(len(s)):\\n            temp[i]= ((ord(s[i]) - ord(\\'a\\')) + temp[i]) % 26 + ord(\\'a\\')\\n            ans += chr(temp[i])\\n        \\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        temp=[0 for i in range(len(s) + 1)]\\n        \\n        for start, end, state in shifts:\\n            temp[start] += [1, -1][1 - state]\\n            temp[end + 1] -= [1, -1][1 - state]\\n                \\n        total = 0\\n        for i in range(len(temp)):\\n            total += temp[i]\\n            temp[i] = total\\n        \\n        ans=\"\"\\n        for i in range(len(s)):\\n            temp[i]= ((ord(s[i]) - ord(\\'a\\')) + temp[i]) % 26 + ord(\\'a\\')\\n            ans += chr(temp[i])\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3226309,
                "title": "python-prefix-sum-easy-solution",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        string = list(s)\\n        prefix = [0]*(len(s)+1)\\n        \\n        for left, right, direction in shifts:\\n            \\n            if direction == 1:\\n                prefix[left]+=1\\n                prefix[right+1]-=1\\n                \\n            else:\\n                prefix[left]-=1\\n                prefix[right+1]+=1\\n                \\n        prefix = list(accumulate(prefix))\\n        \\n        ans = []\\n        \\n        for i in range(len(prefix)-1):\\n            \\n            res = (((ord(s[i])-97)+prefix[i])%26)+97\\n            ans.append(chr(res))\\n            \\n            \\n        return (\"\".join(ans))\\n            \\n            \\n            \\n                \\n            \\n            \\n            \\n            \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        string = list(s)\\n        prefix = [0]*(len(s)+1)\\n        \\n        for left, right, direction in shifts:\\n            \\n            if direction == 1:\\n                prefix[left]+=1\\n                prefix[right+1]-=1\\n                \\n            else:\\n                prefix[left]-=1\\n                prefix[right+1]+=1\\n                \\n        prefix = list(accumulate(prefix))\\n        \\n        ans = []\\n        \\n        for i in range(len(prefix)-1):\\n            \\n            res = (((ord(s[i])-97)+prefix[i])%26)+97\\n            ans.append(chr(res))\\n            \\n            \\n        return (\"\".join(ans))\\n            \\n            \\n            \\n                \\n            \\n            \\n            \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209927,
                "title": "java-solution-with-prefix-sum-line-sweep",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char[] arr = s.toCharArray();\\n        int count[] = new int[s.length()+1];\\n        for(int i=0;i<shifts.length;i++)\\n        {\\n            int[] shift =shifts[i];\\n            int beg=shift[0],end=shift[1],dir=shift[2];\\n            \\n            int sh = dir==1 ? 1:-1;\\n            count[beg]+=sh;\\n            count[end+1]-=sh;\\n        }\\n\\n        for(int i=1;i<count.length;i++) count[i]+=count[i-1];\\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            //the new character after we add the shift modulo 26\\n            int n = arr[i]+(count[i])%26;\\n            //we make sure it is within \\'a\\' to \\'z\\'\\n            if(n>\\'z\\') n=\\'a\\'+(n-\\'z\\')-1;\\n            if(n<\\'a\\') n=\\'z\\'-(\\'a\\'-n)+1;\\n            arr[i]=(char)(n);\\n        }\\n        \\n        return new String(arr);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char[] arr = s.toCharArray();\\n        int count[] = new int[s.length()+1];\\n        for(int i=0;i<shifts.length;i++)\\n        {\\n            int[] shift =shifts[i];\\n            int beg=shift[0],end=shift[1],dir=shift[2];\\n            \\n            int sh = dir==1 ? 1:-1;\\n            count[beg]+=sh;\\n            count[end+1]-=sh;\\n        }\\n\\n        for(int i=1;i<count.length;i++) count[i]+=count[i-1];\\n        \\n        for(int i=0;i<arr.length;i++)\\n        {\\n            //the new character after we add the shift modulo 26\\n            int n = arr[i]+(count[i])%26;\\n            //we make sure it is within \\'a\\' to \\'z\\'\\n            if(n>\\'z\\') n=\\'a\\'+(n-\\'z\\')-1;\\n            if(n<\\'a\\') n=\\'z\\'-(\\'a\\'-n)+1;\\n            arr[i]=(char)(n);\\n        }\\n        \\n        return new String(arr);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3140384,
                "title": "python-endpoints-trick",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        offsets, cur, ans = [0] * (len(s) + 1), 0, \\'\\'\\n        for start, end, d in shifts:\\n            shift = (-1) ** (1 - d)\\n            offsets[start] += shift\\n            offsets[end + 1] -= shift\\n        for o, c in zip(offsets, s):\\n            cur += o\\n            ans += chr(97 + (ord(c) - 97 + cur) % 26)\\n        return ans\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        offsets, cur, ans = [0] * (len(s) + 1), 0, \\'\\'\\n        for start, end, d in shifts:\\n            shift = (-1) ** (1 - d)\\n            offsets[start] += shift\\n            offsets[end + 1] -= shift\\n        for o, c in zip(offsets, s):\\n            cur += o\\n            ans += chr(97 + (ord(c) - 97 + cur) % 26)\\n        return ans\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3134802,
                "title": "scala-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nobject Solution {\\n    def shiftingLetters(s: String, shifts: Array[Array[Int]]): String = {\\n        val as = shifts.foldLeft(new Array[Int](s.length))((ans, cur) =>{\\n        if(cur(2) == 0)\\n            for(i <- cur(0) to cur(1))\\n                ans(i) = ans(i) - 1\\n        else\\n            for (i <- cur(0) to cur(1))\\n                ans(i) = ans(i) + 1\\n        ans\\n        })\\n        (s zip as).map{case (ch, sh) => (\\'a\\' + (ch - \\'a\\' + 26 + sh % 26) % 26).toChar}.mkString\\n    }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n    def shiftingLetters(s: String, shifts: Array[Array[Int]]): String = {\\n        val as = shifts.foldLeft(new Array[Int](s.length))((ans, cur) =>{\\n        if(cur(2) == 0)\\n            for(i <- cur(0) to cur(1))\\n                ans(i) = ans(i) - 1\\n        else\\n            for (i <- cur(0) to cur(1))\\n                ans(i) = ans(i) + 1\\n        ans\\n        })\\n        (s zip as).map{case (ch, sh) => (\\'a\\' + (ch - \\'a\\' + 26 + sh % 26) % 26).toChar}.mkString\\n    }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3110448,
                "title": "python-o-n-labeling-to-do-prefix-sum",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        chars = \"abcdefghijklmnopqrstuvwxyz\"\\n        index_to_char = {}\\n        for i, c in enumerate(chars):\\n            index_to_char[i] = c\\n\\n        chars = [ord(c) - ord(\"a\") for c in s]\\n        prefix = [0] * len(s)\\n        for start, end, direction in shifts:\\n            prefix[start] += 1 if direction == 1 else -1\\n            if end + 1 < len(prefix):\\n                prefix[end + 1] -= 1 if direction == 1 else -1\\n\\n        for i in range(1, len(prefix)):\\n            prefix[i] += prefix[i-1]\\n\\n        for i in range(len(chars)):\\n            chars[i] = (chars[i] + prefix[i]) % 26\\n\\n        chars = [index_to_char[c] for c in chars]\\n        return \"\".join(chars)\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        chars = \"abcdefghijklmnopqrstuvwxyz\"\\n        index_to_char = {}\\n        for i, c in enumerate(chars):\\n            index_to_char[i] = c\\n\\n        chars = [ord(c) - ord(\"a\") for c in s]\\n        prefix = [0] * len(s)\\n        for start, end, direction in shifts:\\n            prefix[start] += 1 if direction == 1 else -1\\n            if end + 1 < len(prefix):\\n                prefix[end + 1] -= 1 if direction == 1 else -1\\n\\n        for i in range(1, len(prefix)):\\n            prefix[i] += prefix[i-1]\\n\\n        for i in range(len(chars)):\\n            chars[i] = (chars[i] + prefix[i]) % 26\\n\\n        chars = [index_to_char[c] for c in chars]\\n        return \"\".join(chars)\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3084036,
                "title": "c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> dp(s.size()+1, 0);\\n\\n        for(auto& ele: shifts) {\\n            if(ele[2] == 1) {\\n                dp[ele[0]] += 1;\\n                dp[ele[1]+1]-=1;\\n            }else {\\n                dp[ele[0]] -= 1;\\n                dp[ele[1]+1] += 1;\\n            }\\n        }\\n\\n\\n        for(int i=0;i<s.size();i++) {\\n            char c = s[i];\\n            if(i>0) {\\n                dp[i] += dp[i-1];\\n            }\\n\\n            int move = dp[i]%26;\\n            if(move < 0) {\\n                move += 26;\\n            }\\n\\n            if(c + move > \\'z\\') {\\n                c = char(c + move - 26);\\n            }else {\\n                c = char(c + move);\\n            }\\n\\n            s[i] = c;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> dp(s.size()+1, 0);\\n\\n        for(auto& ele: shifts) {\\n            if(ele[2] == 1) {\\n                dp[ele[0]] += 1;\\n                dp[ele[1]+1]-=1;\\n            }else {\\n                dp[ele[0]] -= 1;\\n                dp[ele[1]+1] += 1;\\n            }\\n        }\\n\\n\\n        for(int i=0;i<s.size();i++) {\\n            char c = s[i];\\n            if(i>0) {\\n                dp[i] += dp[i-1];\\n            }\\n\\n            int move = dp[i]%26;\\n            if(move < 0) {\\n                move += 26;\\n            }\\n\\n            if(c + move > \\'z\\') {\\n                c = char(c + move - 26);\\n            }else {\\n                c = char(c + move);\\n            }\\n\\n            s[i] = c;\\n        }\\n\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079200,
                "title": "java-line-sweep-time-o-n-space-o-n",
                "content": "# Code\\n```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n = s.length();\\n        char[] sch = s.toCharArray();\\n        int[] line = new int[n + 1];\\n        for (int[] shift : shifts) {\\n            if (shift[2] == 1) {\\n                line[shift[0]] = line[shift[0]] + 1;\\n                line[shift[1] + 1] = line[shift[1] + 1] - 1;\\n            } else {\\n                line[shift[0]] = line[shift[0]] - 1;\\n                line[shift[1] + 1] = line[shift[1] + 1] + 1;\\n            }\\n        }\\n        int moves = 0;\\n        for (int i = 0; i < n; i++) {\\n            moves += line[i];\\n            int move = (sch[i] - \\'a\\' + moves) % 26;\\n            if (move < 0) {\\n                move += 26;\\n            }\\n            sch[i] = (char)(\\'a\\' + move);\\n        }\\n        return new String(sch);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n = s.length();\\n        char[] sch = s.toCharArray();\\n        int[] line = new int[n + 1];\\n        for (int[] shift : shifts) {\\n            if (shift[2] == 1) {\\n                line[shift[0]] = line[shift[0]] + 1;\\n                line[shift[1] + 1] = line[shift[1] + 1] - 1;\\n            } else {\\n                line[shift[0]] = line[shift[0]] - 1;\\n                line[shift[1] + 1] = line[shift[1] + 1] + 1;\\n            }\\n        }\\n        int moves = 0;\\n        for (int i = 0; i < n; i++) {\\n            moves += line[i];\\n            int move = (sch[i] - \\'a\\' + moves) % 26;\\n            if (move < 0) {\\n                move += 26;\\n            }\\n            sch[i] = (char)(\\'a\\' + move);\\n        }\\n        return new String(sch);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3062613,
                "title": "c-easy-fast",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shift) {\\n        \\n        int n=s.length();\\n        vector<int> freq(n,0);\\n        for(int i=0;i<shift.size();i++)\\n        {\\n            if(shift[i][2]==0)\\n            {\\n                freq[shift[i][0]]--;\\n                if(shift[i][1]<n-1)\\n                {\\n                    freq[shift[i][1]+1]++;\\n                }\\n            }\\n            \\n            if(shift[i][2]==1)\\n            {\\n                freq[shift[i][0]]++;\\n                if(shift[i][1]<n-1)\\n                {\\n                    freq[shift[i][1]+1]--;\\n                }\\n            }    \\n        }\\n        \\n        for(int i=1;i<n;i++)\\n            freq[i]=freq[i-1]+freq[i];\\n        \\n        for(int i=0;i<n;i++)\\n        cout<<freq[i]<<\" \";\\n\\n        for(int i=0;i<n;i++){\\n        int idx = (s[i]-\\'a\\' + freq[i])%26;\\n        if(idx<0) idx += 26;\\n        char new_ch = (char)(idx + \\'a\\');\\n        s[i] = new_ch;\\n    }\\n        \\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shift) {\\n        \\n        int n=s.length();\\n        vector<int> freq(n,0);\\n        for(int i=0;i<shift.size();i++)\\n        {\\n            if(shift[i][2]==0)\\n            {\\n                freq[shift[i][0]]--;\\n                if(shift[i][1]<n-1)\\n                {\\n                    freq[shift[i][1]+1]++;\\n                }\\n            }\\n            \\n            if(shift[i][2]==1)\\n            {\\n                freq[shift[i][0]]++;\\n                if(shift[i][1]<n-1)\\n                {\\n                    freq[shift[i][1]+1]--;\\n                }\\n            }    \\n        }\\n        \\n        for(int i=1;i<n;i++)\\n            freq[i]=freq[i-1]+freq[i];\\n        \\n        for(int i=0;i<n;i++)\\n        cout<<freq[i]<<\" \";\\n\\n        for(int i=0;i<n;i++){\\n        int idx = (s[i]-\\'a\\' + freq[i])%26;\\n        if(idx<0) idx += 26;\\n        char new_ch = (char)(idx + \\'a\\');\\n        s[i] = new_ch;\\n    }\\n        \\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3030017,
                "title": "easy-java-solution",
                "content": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        HashMap<Integer,Character> map = new HashMap();\\n        int val = 0;\\n        for(char ch = \\'a\\' ; ch <= \\'z\\'; ch++) {\\n            map.put(val++,ch);\\n        }\\n        int[] arr = new int[s.length()+1];\\n        int index = 0;        \\n        for(int i = 0; i < shifts.length; i++) {\\n            int add = -1;\\n            if(shifts[i][2] == 1)\\n                add = 1;\\n            arr[shifts[i][0]]+=add;\\n            arr[shifts[i][1]+1]-=add;\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        for(int i = 0; i < s.length();i++) {\\n            if(i != 0)\\n                arr[i]+=arr[i-1];\\n            val = s.charAt(i)-\\'a\\'+arr[i];\\n            while(val < 0)\\n                val+=26;\\n            val%=26;\\n            sb.append(map.get(val));\\n        }\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        HashMap<Integer,Character> map = new HashMap();\\n        int val = 0;\\n        for(char ch = \\'a\\' ; ch <= \\'z\\'; ch++) {\\n            map.put(val++,ch);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2966735,
                "title": "c-simple-line-sweep-prefix-sum-o-n-o-n",
                "content": "# Intuition : Intervals are given and we have to modify the values in the intervals\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach: Prefix Sum\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n = s.length();\\n        vector<int> prefixSum(n, 0);\\n\\n        for(auto shift : shifts) {\\n            int val = shift[2] == 1 ? 1 : -1;\\n            prefixSum[shift[0]] = prefixSum[shift[0]] + val;\\n            if(shift[1] + 1 < n)\\n                prefixSum[shift[1]+1] = prefixSum[shift[1]+1] - val;\\n        }\\n\\n        //calculatePrefixSum\\n        for(int i = 1; i < n; i++) {\\n            prefixSum[i] = prefixSum[i] + prefixSum[i-1];\\n        }\\n\\n        for(int i = 0; i < n; i++) {\\n            int dax = (s[i]-\\'a\\');\\n            int val = ((((dax + prefixSum[i] + 26) % 26) + 26)) % 26;\\n            s[i] = \\'a\\' + val;\\n        }\\n\\n        return s;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int n = s.length();\\n        vector<int> prefixSum(n, 0);\\n\\n        for(auto shift : shifts) {\\n            int val = shift[2] == 1 ? 1 : -1;\\n            prefixSum[shift[0]] = prefixSum[shift[0]] + val;\\n            if(shift[1] + 1 < n)\\n                prefixSum[shift[1]+1] = prefixSum[shift[1]+1] - val;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2949488,
                "title": "beats-95-python-solution-prefixsum-technique",
                "content": "\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \"\"\"\\n        We need to find a way to generate an array that will contain the steps that should be taken for\\n        each index of s.\\n\\n        Approach (Prefix Sum):\\n        create an array called steps\\n        Loop through shifts array and increment the upper bound index of shift in steps(steps[upperbound]) by either -1 or 1 (decrementing or incrementing). Also increment or decrement the value at steps[lowerbound - 1]\\n\\n        Finally, loop through steps in reverse order and compute the prefix sum array.\\n\\n        \"\"\"\\n\\n        steps = [0]*len(s) \\n        for l, u, d in shifts:\\n            if d == 1:\\n                steps[u] += 1\\n                if l - 1 >= 0:\\n                    steps[l - 1] -= 1\\n            else:\\n                steps[u] -= 1\\n                if l - 1 >= 0:\\n                    steps[l - 1] += 1\\n\\n        # Compute Prefix sum array in reverse order\\n        for i in range(len(steps) - 2, -1, -1):\\n            steps[i] = steps[i] + steps[i + 1]\\n\\n        res = []\\n        for i in range(len(s)):\\n            shifted_letter = chr(97 + (ord(s[i]) + steps[i] - 97)%26)\\n            res.append(shifted_letter)\\n\\n        return  \"\".join(res)\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \"\"\"\\n        We need to find a way to generate an array that will contain the steps that should be taken for\\n        each index of s.\\n\\n        Approach (Prefix Sum):\\n        create an array called steps\\n        Loop through shifts array and increment the upper bound index of shift in steps(steps[upperbound]) by either -1 or 1 (decrementing or incrementing). Also increment or decrement the value at steps[lowerbound - 1]\\n\\n        Finally, loop through steps in reverse order and compute the prefix sum array.\\n\\n        \"\"\"\\n\\n        steps = [0]*len(s) \\n        for l, u, d in shifts:\\n            if d == 1:\\n                steps[u] += 1\\n                if l - 1 >= 0:\\n                    steps[l - 1] -= 1\\n            else:\\n                steps[u] -= 1\\n                if l - 1 >= 0:\\n                    steps[l - 1] += 1\\n\\n        # Compute Prefix sum array in reverse order\\n        for i in range(len(steps) - 2, -1, -1):\\n            steps[i] = steps[i] + steps[i + 1]\\n\\n        res = []\\n        for i in range(len(s)):\\n            shifted_letter = chr(97 + (ord(s[i]) + steps[i] - 97)%26)\\n            res.append(shifted_letter)\\n\\n        return  \"\".join(res)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2926396,
                "title": "python-clean-solution-with-explanation",
                "content": "This problem is basically the same as https://leetcode.com/problems/maximum-population-year/. I use the same approach:\\n1. Count the number of shifts occurring at each index\\n2. Scan the string from left to right, keeping track of the cumulative shift amount\\n\\nInstead of using 4 arrays to track the shifts, I could use a single array where the `ith` element indicates how much shift to add before processing the `ith` character. This would be more concise, but with the same asymptotic time complexity and less readability.\\n```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        forward_starts = [0]*len(s)\\n        forward_ends = [0]*len(s)\\n        back_starts = [0]*len(s)\\n        back_ends = [0]*len(s)\\n\\n        for shift in shifts:\\n            start, end, direction = shift\\n            if direction == 1:\\n                forward_starts[start] += 1\\n                forward_ends[end] += 1\\n            else:\\n                back_starts[start] += 1\\n                back_ends[end] += 1\\n\\n        res = []\\n        shift_amount = 0\\n        for i, ch in enumerate(s):\\n            shift_amount += forward_starts[i]\\n            shift_amount -= back_starts[i]\\n            \\n            res.append(self.shift_letter(ch, shift_amount))\\n\\n            shift_amount -= forward_ends[i]\\n            shift_amount += back_ends[i]\\n\\n        return \"\".join(res)\\n    \\n    def shift_letter(self, letter, amount):\\n        letter_index = ord(letter) - ord(\"a\")\\n        new_letter_index = (letter_index + amount) % 26\\n        return chr(new_letter_index + ord(\"a\"))\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        forward_starts = [0]*len(s)\\n        forward_ends = [0]*len(s)\\n        back_starts = [0]*len(s)\\n        back_ends = [0]*len(s)\\n\\n        for shift in shifts:\\n            start, end, direction = shift\\n            if direction == 1:\\n                forward_starts[start] += 1\\n                forward_ends[end] += 1\\n            else:\\n                back_starts[start] += 1\\n                back_ends[end] += 1\\n\\n        res = []\\n        shift_amount = 0\\n        for i, ch in enumerate(s):\\n            shift_amount += forward_starts[i]\\n            shift_amount -= back_starts[i]\\n            \\n            res.append(self.shift_letter(ch, shift_amount))\\n\\n            shift_amount -= forward_ends[i]\\n            shift_amount += back_ends[i]\\n\\n        return \"\".join(res)\\n    \\n    def shift_letter(self, letter, amount):\\n        letter_index = ord(letter) - ord(\"a\")\\n        new_letter_index = (letter_index + amount) % 26\\n        return chr(new_letter_index + ord(\"a\"))\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2907010,
                "title": "line-sweep-algo-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    static bool cmp(vector<ll>&v1,vector<ll>&v2){\\n        if(v1[0]==v2[0]){\\n            return v1[1]>v2[1];\\n        }\\n        return v1[0]<v2[0];\\n    }\\n\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        ll current=0,index=0,mayank=0;\\n        vector<vector<ll>>container;\\n        string answer=s;\\n        for(auto &x:shifts){\\n            container.push_back({x[0],1,(x[2]==1)?1:-1});\\n            container.push_back({x[1],-1,(x[2]==1)?1:-1});\\n        }\\n        ll n=s.length();\\n        sort(container.begin(),container.end(),cmp);\\n        while(mayank<n){\\n            ll now=mayank;\\n            while(index<container.size() && container[index][0]==now && container[index][1]==1){\\n                current+=container[index][2];\\n                index++;\\n            }\\n            bool condition=(current<0?true:false);\\n            current=abs(current)%26;\\n            if(condition){\\n                current=-current;\\n            }\\n            for(ll i=0;i<abs(current);i++){\\n                if(current>0){\\n                    answer[mayank]++;\\n                    if(answer[mayank]>\\'z\\'){\\n                        answer[mayank]=\\'a\\';\\n                    }\\n                }\\n                else{\\n                    answer[mayank]--;\\n                    if(answer[mayank]<\\'a\\'){\\n                        answer[mayank]=\\'z\\';\\n                    }\\n                }\\n            }\\n            while(index<container.size() && container[index][0]==now && container[index][1]==-1){\\n                current-=container[index][2];\\n                index++;\\n            }\\n            mayank++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n\\n    static bool cmp(vector<ll>&v1,vector<ll>&v2){\\n        if(v1[0]==v2[0]){\\n            return v1[1]>v2[1];\\n        }\\n        return v1[0]<v2[0];\\n    }\\n\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        ll current=0,index=0,mayank=0;\\n        vector<vector<ll>>container;\\n        string answer=s;\\n        for(auto &x:shifts){\\n            container.push_back({x[0],1,(x[2]==1)?1:-1});\\n            container.push_back({x[1],-1,(x[2]==1)?1:-1});\\n        }\\n        ll n=s.length();\\n        sort(container.begin(),container.end(),cmp);\\n        while(mayank<n){\\n            ll now=mayank;\\n            while(index<container.size() && container[index][0]==now && container[index][1]==1){\\n                current+=container[index][2];\\n                index++;\\n            }\\n            bool condition=(current<0?true:false);\\n            current=abs(current)%26;\\n            if(condition){\\n                current=-current;\\n            }\\n            for(ll i=0;i<abs(current);i++){\\n                if(current>0){\\n                    answer[mayank]++;\\n                    if(answer[mayank]>\\'z\\'){\\n                        answer[mayank]=\\'a\\';\\n                    }\\n                }\\n                else{\\n                    answer[mayank]--;\\n                    if(answer[mayank]<\\'a\\'){\\n                        answer[mayank]=\\'z\\';\\n                    }\\n                }\\n            }\\n            while(index<container.size() && container[index][0]==now && container[index][1]==-1){\\n                current-=container[index][2];\\n                index++;\\n            }\\n            mayank++;\\n        }\\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2891766,
                "title": "python-simple-sweep-line-algorithm",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def shiftingLetters(self, s, shifts):\\n        dict1, res = defaultdict(int), []\\n\\n        for i,j,k in shifts:\\n            if k == 0:\\n                dict1[i] -= 1\\n                dict1[j+1] += 1\\n            else:\\n                dict1[i] += 1\\n                dict1[j+1] -= 1\\n\\n        total = 0\\n\\n        for i in range(len(s)):\\n            total += dict1[i]\\n            res.append(total)\\n\\n        str1 = \"\"\\n\\n        for i in range(len(s)):\\n            str1 += chr(((ord(s[i]) - 97) + res[i])%26 + 97)\\n\\n        return str1\\n\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s, shifts):\\n        dict1, res = defaultdict(int), []\\n\\n        for i,j,k in shifts:\\n            if k == 0:\\n                dict1[i] -= 1\\n                dict1[j+1] += 1\\n            else:\\n                dict1[i] += 1\\n                dict1[j+1] -= 1\\n\\n        total = 0\\n\\n        for i in range(len(s)):\\n            total += dict1[i]\\n            res.append(total)\\n\\n        str1 = \"\"\\n\\n        for i in range(len(s)):\\n            str1 += chr(((ord(s[i]) - 97) + res[i])%26 + 97)\\n\\n        return str1\\n\\n\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2872407,
                "title": "simple-prefix-sum-logic",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& a) {\\n        int n=s.length();\\n        vector<int> cnt(n+2,0);\\n        \\n        for(auto v:a){\\n            int c=-1;\\n            if(v[2])\\n                c=1;\\n            cnt[v[0]]+=c;\\n            cnt[v[1]+1]-=c;\\n        }\\n        \\n        cnt[0]=(cnt[0]%26+26)%26;\\n        string t;\\n        t.push_back(\\'a\\'+(s[0]-\\'a\\'+cnt[0])%26);\\n        \\n        for(int i=1;i<n;i++){\\n            cnt[i]=((cnt[i]+cnt[i-1])%26+26)%26;\\n            t.push_back(\\'a\\'+(s[i]-\\'a\\'+cnt[i])%26);\\n        }\\n        \\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& a) {\\n        int n=s.length();\\n        vector<int> cnt(n+2,0);\\n        \\n        for(auto v:a){\\n            int c=-1;\\n            if(v[2])\\n                c=1;\\n            cnt[v[0]]+=c;\\n            cnt[v[1]+1]-=c;\\n        }\\n        \\n        cnt[0]=(cnt[0]%26+26)%26;\\n        string t;\\n        t.push_back(\\'a\\'+(s[0]-\\'a\\'+cnt[0])%26);\\n        \\n        for(int i=1;i<n;i++){\\n            cnt[i]=((cnt[i]+cnt[i-1])%26+26)%26;\\n            t.push_back(\\'a\\'+(s[i]-\\'a\\'+cnt[i])%26);\\n        }\\n        \\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2862852,
                "title": "c",
                "content": "```\\nchar * shiftingLetters(char * s, int** shifts, int shiftsSize, int* shiftsColSize){\\n    int n = strlen(s);\\n    int* prefixSum = calloc( (n + 1) , sizeof(int));\\n    prefixSum[n] = 0;\\n    for(int i = 0; i < shiftsSize; i++){\\n        if(shifts[i][2] == 1 ){\\n            prefixSum[shifts[i][0]]++;\\n            prefixSum[shifts[i][1] + 1]--;\\n        }\\n        else{\\n            prefixSum[shifts[i][0]]--;\\n            prefixSum[shifts[i][1] + 1]++;\\n        }\\n    }\\n    for(int i= 1; i < n; i++){\\n        prefixSum[i] += prefixSum[i-1]; \\n    }\\n    char* ans = malloc((n+1) * sizeof(char));\\n    ans[n] = \\'\\\\0\\';\\n    for(int i = 0; i < n; i++){\\n        prefixSum[i] += s[i] - \\'a\\';\\n        if(prefixSum[i] >= 0){\\n            prefixSum[i] %= 26;\\n        }\\n        else{\\n            prefixSum[i] = (prefixSum[i]%26 + 26) %26;\\n        }\\n        ans[i] = \\'a\\' + prefixSum[i] ;\\n    }\\n    free(prefixSum);\\n    return ans;   \\n}\\n```",
                "solutionTags": [],
                "code": "```\\nchar * shiftingLetters(char * s, int** shifts, int shiftsSize, int* shiftsColSize){\\n    int n = strlen(s);\\n    int* prefixSum = calloc( (n + 1) , sizeof(int));\\n    prefixSum[n] = 0;\\n    for(int i = 0; i < shiftsSize; i++){\\n        if(shifts[i][2] == 1 ){\\n            prefixSum[shifts[i][0]]++;\\n            prefixSum[shifts[i][1] + 1]--;\\n        }\\n        else{\\n            prefixSum[shifts[i][0]]--;\\n            prefixSum[shifts[i][1] + 1]++;\\n        }\\n    }\\n    for(int i= 1; i < n; i++){\\n        prefixSum[i] += prefixSum[i-1]; \\n    }\\n    char* ans = malloc((n+1) * sizeof(char));\\n    ans[n] = \\'\\\\0\\';\\n    for(int i = 0; i < n; i++){\\n        prefixSum[i] += s[i] - \\'a\\';\\n        if(prefixSum[i] >= 0){\\n            prefixSum[i] %= 26;\\n        }\\n        else{\\n            prefixSum[i] = (prefixSum[i]%26 + 26) %26;\\n        }\\n        ans[i] = \\'a\\' + prefixSum[i] ;\\n    }\\n    free(prefixSum);\\n    return ans;   \\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2834226,
                "title": "javascript-intuitive",
                "content": "```\\nvar shiftingLetters = function(s, shifts) {\\n    const n = s.length, countShifts = Array(n).fill(0);\\n\\n    for (const [start, end, dir] of shifts) {\\n        let mathSign = dir ? 1 : -1;\\n        for (let i = start; i<=end; i++) {\\n            countShifts[i] += mathSign;\\n        }\\n    }\\n    s = s.split(\\'\\');\\n\\n    for (let i = 0; i<n; i++) {\\n        let val = s[i].charCodeAt()-97 + countShifts[i];\\n        if (val < 0) {\\n            val = 26 + (val%26);\\n        } \\n        if (val > 25) {\\n            val%=26;\\n        }\\n        if (val < 0) console.log(s[i], countShifts[i])\\n        s[i] = String.fromCharCode(val+97);\\n    }\\n\\n    return s.join(\\'\\');\\n};\\n\\n\\n\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar shiftingLetters = function(s, shifts) {\\n    const n = s.length, countShifts = Array(n).fill(0);\\n\\n    for (const [start, end, dir] of shifts) {\\n        let mathSign = dir ? 1 : -1;\\n        for (let i = start; i<=end; i++) {\\n            countShifts[i] += mathSign;\\n        }\\n    }\\n    s = s.split(\\'\\');\\n\\n    for (let i = 0; i<n; i++) {\\n        let val = s[i].charCodeAt()-97 + countShifts[i];\\n        if (val < 0) {\\n            val = 26 + (val%26);\\n        } \\n        if (val > 25) {\\n            val%=26;\\n        }\\n        if (val < 0) console.log(s[i], countShifts[i])\\n        s[i] = String.fromCharCode(val+97);\\n    }\\n\\n    return s.join(\\'\\');\\n};\\n\\n\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2828211,
                "title": "python3-using-cumulative-sum",
                "content": "class Solution:\\n\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        direction = [-1,1]\\n        cumSum = [0]*(1+n)\\n        ordA = ord(\\'a\\')\\n        \\n        for l,r,d in shifts:\\n            di = direction[d]\\n            cumSum[l]+=di\\n            cumSum[r+1]-=di\\n            \\n        for i in range(1,n):\\n            cumSum[i]+=cumSum[i-1]    \\n            \\n        sList = list(s)\\n        for i in range(n):\\n            curr = (ord(s[i])-ordA+cumSum[i])%26\\n            sList[i] = chr(ordA+curr)\\n            \\n        return \\'\\'.join(sList)",
                "solutionTags": [],
                "code": "class Solution:\\n\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        direction = [-1,1]\\n        cumSum = [0]*(1+n)\\n        ordA = ord(\\'a\\')\\n        \\n        for l,r,d in shifts:\\n            di = direction[d]\\n            cumSum[l]+=di\\n            cumSum[r+1]-=di\\n            \\n        for i in range(1,n):\\n            cumSum[i]+=cumSum[i-1]    \\n            \\n        sList = list(s)\\n        for i in range(n):\\n            curr = (ord(s[i])-ordA+cumSum[i])%26\\n            sList[i] = chr(ordA+curr)\\n            \\n        return \\'\\'.join(sList)",
                "codeTag": "Java"
            },
            {
                "id": 2798405,
                "title": "javascript-cumulative-sum-efficient-easy-to-understand-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nCreate an array to find all the shifts using cumulative sum approach, this way TC will be O(n) otherwise it\\'ll be O(n**2)\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {string} s\\n * @param {number[][]} shifts\\n * @return {string}\\n */\\nvar shiftingLetters = function (s, shifts) {\\n\\tconst arr = new Array(s.length).fill(0);\\n\\tfor (const [start, end, direction] of shifts) {\\n\\t\\tif (direction === 0) {\\n\\t\\t\\tarr[start] -= 1;\\n\\t\\t\\tend !== arr.length - 1 && (arr[end + 1] += 1)\\n\\t\\t} else {\\n\\t\\t\\tarr[start] += 1;\\n\\t\\t\\tend !== arr.length - 1 && (arr[end + 1] -= 1)\\n\\t\\t}\\n\\t}\\n\\n\\tfor (let i = 1; i < arr.length; i++) arr[i] += arr[i - 1]\\n\\n\\tlet res = \\'\\'\\n\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\tconst code = s[i].charCodeAt() + arr[i];\\n\\n\\t\\tif (code < 97) {\\n\\t\\t\\tlet diff = (97 - code) % 26;\\n            // to handle negative and zero\\n\\t\\t\\tif (diff <= 0) diff += 26\\n\\t\\t\\tres += String.fromCharCode(123 - diff);\\n\\t\\t}\\n\\t\\telse if (code > 122) {\\n\\t\\t\\tlet diff = (code - 122) % 26;\\n\\t\\t\\tif (diff <= 0) diff += 26\\n\\t\\t\\tres += String.fromCharCode(96 + diff);\\n\\t\\t}\\n\\t\\telse res += String.fromCharCode(code)\\n\\t}\\n\\t\\n\\treturn res;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} s\\n * @param {number[][]} shifts\\n * @return {string}\\n */\\nvar shiftingLetters = function (s, shifts) {\\n\\tconst arr = new Array(s.length).fill(0);\\n\\tfor (const [start, end, direction] of shifts) {\\n\\t\\tif (direction === 0) {\\n\\t\\t\\tarr[start] -= 1;\\n\\t\\t\\tend !== arr.length - 1 && (arr[end + 1] += 1)\\n\\t\\t} else {\\n\\t\\t\\tarr[start] += 1;\\n\\t\\t\\tend !== arr.length - 1 && (arr[end + 1] -= 1)\\n\\t\\t}\\n\\t}\\n\\n\\tfor (let i = 1; i < arr.length; i++) arr[i] += arr[i - 1]\\n\\n\\tlet res = \\'\\'\\n\\tfor (let i = 0; i < arr.length; i++) {\\n\\t\\tconst code = s[i].charCodeAt() + arr[i];\\n\\n\\t\\tif (code < 97) {\\n\\t\\t\\tlet diff = (97 - code) % 26;\\n            // to handle negative and zero\\n\\t\\t\\tif (diff <= 0) diff += 26\\n\\t\\t\\tres += String.fromCharCode(123 - diff);\\n\\t\\t}\\n\\t\\telse if (code > 122) {\\n\\t\\t\\tlet diff = (code - 122) % 26;\\n\\t\\t\\tif (diff <= 0) diff += 26\\n\\t\\t\\tres += String.fromCharCode(96 + diff);\\n\\t\\t}\\n\\t\\telse res += String.fromCharCode(code)\\n\\t}\\n\\t\\n\\treturn res;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2774832,
                "title": "c-10-line",
                "content": "```\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size(), x = 0;\\n        vector<int> vshif(n+1);\\n        for(auto& v:shifts) {\\n            if(v[2] == 1) vshif[v[0]]++, vshif[v[1]+1]--;\\n            else vshif[v[0]]--, vshif[v[1]+1]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            x += vshif[i];\\n            s[i] = \\'a\\' + (s[i] - \\'a\\' + x + 2600000) % 26;\\n        }\\n        return s;\\n    }",
                "solutionTags": [],
                "code": "```\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n = s.size(), x = 0;\\n        vector<int> vshif(n+1);\\n        for(auto& v:shifts) {\\n            if(v[2] == 1) vshif[v[0]]++, vshif[v[1]+1]--;\\n            else vshif[v[0]]--, vshif[v[1]+1]++;\\n        }\\n        for(int i=0;i<n;i++){\\n            x += vshif[i];\\n            s[i] = \\'a\\' + (s[i] - \\'a\\' + x + 2600000) % 26;\\n        }\\n        return s;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2768330,
                "title": "c-prefix-o-mn",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int size1=s.size(), size2=shifts.size();\\n        \\n        vector<int> prefix(size1+1);\\n        \\n        for(int i=0; i<size2; i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                prefix[shifts[i][0]]++;\\n                prefix[shifts[i][1]+1]--;\\n            }\\n            else\\n            {\\n                prefix[shifts[i][0]]--;\\n                prefix[shifts[i][1]+1]++;\\n            }\\n        }\\n        \\n        string ans=s;\\n        \\n        int offset=0;\\n        \\n        for(int i=0; i<size1; i++)\\n        {\\n            offset+=prefix[i];\\n            ans[i]=\\'a\\'+(ans[i]-\\'a\\'+offset%26+26)%26;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        \\n        int size1=s.size(), size2=shifts.size();\\n        \\n        vector<int> prefix(size1+1);\\n        \\n        for(int i=0; i<size2; i++)\\n        {\\n            if(shifts[i][2]==1)\\n            {\\n                prefix[shifts[i][0]]++;\\n                prefix[shifts[i][1]+1]--;\\n            }\\n            else\\n            {\\n                prefix[shifts[i][0]]--;\\n                prefix[shifts[i][1]+1]++;\\n            }\\n        }\\n        \\n        string ans=s;\\n        \\n        int offset=0;\\n        \\n        for(int i=0; i<size1; i++)\\n        {\\n            offset+=prefix[i];\\n            ans[i]=\\'a\\'+(ans[i]-\\'a\\'+offset%26+26)%26;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2764071,
                "title": "python-3-line-sweep-o-n-o-n",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        totalShifts = [0] * (n + 1)\\n        for start, end, direction in shifts:\\n            if not direction:\\n                direction = -1\\n            totalShifts[start] += direction\\n            totalShifts[end + 1] -= direction\\n        \\n        for i in range(1, n):\\n            totalShifts[i] += totalShifts[i - 1]\\n        \\n        res = []\\n        for c, totalShift in zip(s, totalShifts):\\n            res.append(chr((ord(c) - 97 + totalShift) % 26 + 97))\\n        return \\'\\'.join(res)",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        n = len(s)\\n        totalShifts = [0] * (n + 1)\\n        for start, end, direction in shifts:\\n            if not direction:\\n                direction = -1\\n            totalShifts[start] += direction\\n            totalShifts[end + 1] -= direction\\n        \\n        for i in range(1, n):\\n            totalShifts[i] += totalShifts[i - 1]\\n        \\n        res = []\\n        for c, totalShift in zip(s, totalShifts):\\n            res.append(chr((ord(c) - 97 + totalShift) % 26 + 97))\\n        return \\'\\'.join(res)",
                "codeTag": "Java"
            },
            {
                "id": 2753031,
                "title": "golang-move-solution",
                "content": "```go\\nfunc shiftingLetters(s string, shifts [][]int) string {\\n\\tshiftRecorder := make([]int, len(s)+1)\\n\\tfor _, shift := range shifts {\\n\\t\\tif shift[2] == 1 {\\n\\t\\t\\tshiftRecorder[shift[0]]++\\n\\t\\t\\tshiftRecorder[shift[1]+1]--\\n\\t\\t} else {\\n\\t\\t\\tshiftRecorder[shift[0]]--\\n\\t\\t\\tshiftRecorder[shift[1]+1]++\\n\\t\\t}\\n\\t}\\n\\tbb := bytes.Buffer{}\\n\\tmove := 0\\n\\tfor i, c := range s {\\n\\t\\tmove += shiftRecorder[i]\\n\\t\\tif move < 0 {\\n\\t\\t\\tmove = (26 - (-move)%26) % 26\\n\\t\\t}\\n\\t\\tmove %= 26\\n\\t\\tnc := c + rune(move)\\n\\t\\tif nc > \\'z\\' {\\n\\t\\t\\tnc -= 26\\n\\t\\t}\\n\\t\\tbb.WriteRune(nc)\\n\\t}\\n\\treturn bb.String()\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```go\\nfunc shiftingLetters(s string, shifts [][]int) string {\\n\\tshiftRecorder := make([]int, len(s)+1)\\n\\tfor _, shift := range shifts {\\n\\t\\tif shift[2] == 1 {\\n\\t\\t\\tshiftRecorder[shift[0]]++\\n\\t\\t\\tshiftRecorder[shift[1]+1]--\\n\\t\\t} else {\\n\\t\\t\\tshiftRecorder[shift[0]]--\\n\\t\\t\\tshiftRecorder[shift[1]+1]++\\n\\t\\t}\\n\\t}\\n\\tbb := bytes.Buffer{}\\n\\tmove := 0\\n\\tfor i, c := range s {\\n\\t\\tmove += shiftRecorder[i]\\n\\t\\tif move < 0 {\\n\\t\\t\\tmove = (26 - (-move)%26) % 26\\n\\t\\t}\\n\\t\\tmove %= 26\\n\\t\\tnc := c + rune(move)\\n\\t\\tif nc > \\'z\\' {\\n\\t\\t\\tnc -= 26\\n\\t\\t}\\n\\t\\tbb.WriteRune(nc)\\n\\t}\\n\\treturn bb.String()\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2752763,
                "title": "python-prefix-sum-solution-o-n-time",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        sz, sm, prefix, s = len(s), 0, [0] * (len(s) + 1), list(s)\\n        for shift in shifts:\\n            left, right = shift[0], shift[1]\\n            if shift[2] == 0:\\n                prefix[left] -= 1\\n                prefix[right + 1] += 1\\n            else:\\n                prefix[left] += 1\\n                prefix[right + 1] -= 1\\n        for i in range(sz):\\n            sm += prefix[i]\\n            amountOfShift = (ord(s[i]) - ord(\\'a\\') + (sm % 26) + 26) % 26\\n            s[i] = chr(ord(\\'a\\') + amountOfShift)\\n        return \\'\\'.join(s)\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        sz, sm, prefix, s = len(s), 0, [0] * (len(s) + 1), list(s)\\n        for shift in shifts:\\n            left, right = shift[0], shift[1]\\n            if shift[2] == 0:\\n                prefix[left] -= 1\\n                prefix[right + 1] += 1\\n            else:\\n                prefix[left] += 1\\n                prefix[right + 1] -= 1\\n        for i in range(sz):\\n            sm += prefix[i]\\n            amountOfShift = (ord(s[i]) - ord(\\'a\\') + (sm % 26) + 26) % 26\\n            s[i] = chr(ord(\\'a\\') + amountOfShift)\\n        return \\'\\'.join(s)\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2732749,
                "title": "ruby-solution",
                "content": "```ruby\\n# @param {String} s\\n# @param {Integer[][]} shifts\\n# @return {String}\\ndef shifting_letters(s, shifts)\\n  arr = Array.new( s.length + 1, 0 )\\n  \\n  shifts.each do |start_index, end_index, step|\\n    arr[ start_index ] += step * 2 - 1\\n    arr[ end_index + 1] -= step * 2 - 1\\n  end\\n\\n  change = 0\\n  s.each_char.with_index do |char, index|\\n    change += arr[index]\\n    s[index] = ((char.ord - 97 + change) % 26 + 97).chr\\n  end\\n  \\nend\\n```",
                "solutionTags": [],
                "code": "```ruby\\n# @param {String} s\\n# @param {Integer[][]} shifts\\n# @return {String}\\ndef shifting_letters(s, shifts)\\n  arr = Array.new( s.length + 1, 0 )\\n  \\n  shifts.each do |start_index, end_index, step|\\n    arr[ start_index ] += step * 2 - 1\\n    arr[ end_index + 1] -= step * 2 - 1\\n  end\\n\\n  change = 0\\n  s.each_char.with_index do |char, index|\\n    change += arr[index]\\n    s[index] = ((char.ord - 97 + change) % 26 + 97).chr\\n  end\\n  \\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2668723,
                "title": "python3-line-sweep",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        sz=len(s)\\n        freq=[0 for i in range(sz+1)]\\n        for a,b,c in shifts:\\n            if c==1:\\n                freq[a]+=1\\n                freq[b+1]-=1\\n            else:\\n                freq[a]-=1\\n                freq[b+1]+=1\\n        for i in range(sz+1):\\n            freq[i]=freq[i-1]+freq[i] if i>=1 else freq[i]\\n        s=list(s)\\n        for i in range(sz):\\n            s[i]=chr(((ord(s[i])+freq[i]-97)%26)+97)\\n        return \"\".join(s)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        sz=len(s)\\n        freq=[0 for i in range(sz+1)]\\n        for a,b,c in shifts:\\n            if c==1:\\n                freq[a]+=1\\n                freq[b+1]-=1\\n            else:\\n                freq[a]-=1\\n                freq[b+1]+=1\\n        for i in range(sz+1):\\n            freq[i]=freq[i-1]+freq[i] if i>=1 else freq[i]\\n        s=list(s)\\n        for i in range(sz):\\n            s[i]=chr(((ord(s[i])+freq[i]-97)%26)+97)\\n        return \"\".join(s)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2668634,
                "title": "c-prefix-sum-simple",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tvector<int> preSum(n+1,0);\\n\\t\\t\\tfor(auto it : shifts){\\n\\t\\t\\t\\tint st = it[0] , e = it[1];\\n\\t\\t\\t\\tint d = it[2];\\n\\t\\t\\t\\tif(d) {\\n\\t\\t\\t\\t\\tpreSum[st] += 1;\\n\\t\\t\\t\\t\\tpreSum[e+1] += (-1);\\n\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\tpreSum[st] += (-1);\\n\\t\\t\\t\\t\\tpreSum[e+1] += 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tint sum = 0;\\n\\t\\t\\tfor(int i = 0 ; i < n ; i++){\\n\\t\\t\\t\\tsum += preSum[i];\\n\\t\\t\\t\\tint val = (s[i] - \\'a\\' + sum%26 + 26) % 26;\\n\\t\\t\\t\\ts[i] = \\'a\\' + val;\\n\\t\\t\\t}\\n\\t\\t\\treturn s;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tstring shiftingLetters(string s, vector<vector<int>>& shifts) {\\n\\t\\t\\tint n = s.size();\\n\\t\\t\\tvector<int> preSum(n+1,0);\\n\\t\\t\\tfor(auto it : shifts){\\n\\t\\t\\t\\tint st = it[0] , e = it[1];\\n\\t\\t\\t\\tint d = it[2];\\n\\t\\t\\t\\tif(d) {\\n\\t\\t\\t\\t\\tpreSum[st] += 1;\\n\\t\\t\\t\\t\\tpreSum[e+1] += (-1);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2642136,
                "title": "easy-js-solution-with-diagram",
                "content": "**Approach 1**: O(n ^2)\\n\\n```\\nvar shiftingLetters = function(s, shifts) {\\n\\tlet n = s.length;\\n    let pfx = new Array(n).fill(0);\\n    \\n    for(let i = 0; i < shifts.length; i++) {\\n        let [start, end, dir] = shifts[i];\\n        \\n        for(let j = start; j <= end; j++) {\\n            \\n            if(dir === 1) {\\n                pfx[j] += 1;\\n            } else {\\n                pfx[j] -= 1;\\n            }\\n            \\n        }\\n    }\\n    \\n    let str = \"\";\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let t = s[i].charCodeAt(0) - 97;\\n        let tsign = t + pfx[i] < 0 ? 26 + (t + pfx[i]) % 26: t + pfx[i];\\n        let code = 97 + tsign % 26;\\n        let ch = String.fromCharCode(code);\\n        str += ch;\\n    }\\n    \\n    return str;\\n}\\n```\\n\\n**Approach 2**: O(n)\\n```\\nvar shiftingLetters = function(s, shifts) {\\n\\tlet n = s.length;\\n    let pfx = new Array(n + 1).fill(0);\\n    \\n    for(let i = 0; i < shifts.length; i++) {\\n        let [start, end, dir] = shifts[i];\\n        \\n        if(dir === 1) {\\n            pfx[start] += 1;\\n            pfx[end + 1] -= 1; \\n        } else {\\n            pfx[start] -= 1;\\n            pfx[end + 1] += 1;\\n        }\\n        \\n    }\\n    \\n    for(let i = 1; i < pfx.length; i++) {\\n        pfx[i] += pfx[i - 1];\\n    }\\n    \\n    let str = \"\";\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let t = s[i].charCodeAt(0) - 97;\\n        let tsign = t + pfx[i] < 0 ? 26 + (t + pfx[i]) % 26: t + pfx[i];\\n        let code = 97 + tsign % 26;\\n        let ch = String.fromCharCode(code);\\n        str += ch;\\n    }\\n    \\n    return str;\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/4727f50b-c129-4be0-8a66-30f44ba6c508_1664537717.8534641.png)\\n",
                "solutionTags": [
                    "JavaScript",
                    "Prefix Sum"
                ],
                "code": "```\\nvar shiftingLetters = function(s, shifts) {\\n\\tlet n = s.length;\\n    let pfx = new Array(n).fill(0);\\n    \\n    for(let i = 0; i < shifts.length; i++) {\\n        let [start, end, dir] = shifts[i];\\n        \\n        for(let j = start; j <= end; j++) {\\n            \\n            if(dir === 1) {\\n                pfx[j] += 1;\\n            } else {\\n                pfx[j] -= 1;\\n            }\\n            \\n        }\\n    }\\n    \\n    let str = \"\";\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let t = s[i].charCodeAt(0) - 97;\\n        let tsign = t + pfx[i] < 0 ? 26 + (t + pfx[i]) % 26: t + pfx[i];\\n        let code = 97 + tsign % 26;\\n        let ch = String.fromCharCode(code);\\n        str += ch;\\n    }\\n    \\n    return str;\\n}\\n```\n```\\nvar shiftingLetters = function(s, shifts) {\\n\\tlet n = s.length;\\n    let pfx = new Array(n + 1).fill(0);\\n    \\n    for(let i = 0; i < shifts.length; i++) {\\n        let [start, end, dir] = shifts[i];\\n        \\n        if(dir === 1) {\\n            pfx[start] += 1;\\n            pfx[end + 1] -= 1; \\n        } else {\\n            pfx[start] -= 1;\\n            pfx[end + 1] += 1;\\n        }\\n        \\n    }\\n    \\n    for(let i = 1; i < pfx.length; i++) {\\n        pfx[i] += pfx[i - 1];\\n    }\\n    \\n    let str = \"\";\\n    \\n    for(let i = 0; i < s.length; i++) {\\n        let t = s[i].charCodeAt(0) - 97;\\n        let tsign = t + pfx[i] < 0 ? 26 + (t + pfx[i]) % 26: t + pfx[i];\\n        let code = 97 + tsign % 26;\\n        let ch = String.fromCharCode(code);\\n        str += ch;\\n    }\\n    \\n    return str;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2605876,
                "title": "java-prefix-sum",
                "content": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char[] sol = s.toCharArray();\\n        int[] pref = new int[s.length()+1];\\n        for(int[] shift : shifts){\\n            int value = shift[2] == 1 ? 1 : -1;\\n            pref[shift[0]] += value;\\n            pref[shift[1] + 1] -= value;\\n        }\\n        int sum = 0;\\n        for(int i=0;i<pref.length-1;i++){\\n            sum += pref[i];\\n            int n = ((sol[i]-\\'a\\')+sum) % 26;\\n            if(n<0) n += 26;\\n            sol[i] =  (char)(\\'a\\'+n);\\n        }\\n        return String.valueOf(sol);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        char[] sol = s.toCharArray();\\n        int[] pref = new int[s.length()+1];\\n        for(int[] shift : shifts){\\n            int value = shift[2] == 1 ? 1 : -1;\\n            pref[shift[0]] += value;\\n            pref[shift[1] + 1] -= value;\\n        }\\n        int sum = 0;\\n        for(int i=0;i<pref.length-1;i++){\\n            sum += pref[i];\\n            int n = ((sol[i]-\\'a\\')+sum) % 26;\\n            if(n<0) n += 26;\\n            sol[i] =  (char)(\\'a\\'+n);\\n        }\\n        return String.valueOf(sol);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2596771,
                "title": "python-cumulative-shift-deltas",
                "content": "```\\nclass Solution:\\n    def shiftingLetters(self, st: str, shifts: List[List[int]]) -> str:\\n        \\n        deltas = [0] * (len(st) + 1)\\n        # deltas = dict()\\n        for s, e, d in shifts:\\n            d = (d << 1) - 1\\n            deltas[s] += d\\n            deltas[e + 1] -= d\\n\\n        \\n        shifted = []\\n        cur_shift = 0\\n        for delta, letter in zip(deltas, st):\\n            cur_shift += delta\\n            if cur_shift != 0:\\n                letter = chr(97 + (ord(letter) - 97 + cur_shift) % 26)\\n            shifted.append(letter)\\n                \\n        return \"\".join(shifted)\\n            \\n        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def shiftingLetters(self, st: str, shifts: List[List[int]]) -> str:\\n        \\n        deltas = [0] * (len(st) + 1)\\n        # deltas = dict()\\n        for s, e, d in shifts:\\n            d = (d << 1) - 1\\n            deltas[s] += d\\n            deltas[e + 1] -= d\\n\\n        \\n        shifted = []\\n        cur_shift = 0\\n        for delta, letter in zip(deltas, st):\\n            cur_shift += delta\\n            if cur_shift != 0:\\n                letter = chr(97 + (ord(letter) - 97 + cur_shift) % 26)\\n            shifted.append(letter)\\n                \\n        return \"\".join(shifted)\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572585,
                "title": "prefix-sum-ascii",
                "content": "class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int size = shifts.size();\\n        int n= s.size();\\n        vector<int> v(n+1,0);\\n        for(int i=0;i<size;i++){\\n          int start = shifts[i][0];\\n          int end = shifts[i][1];\\n          int direction = shifts[i][2];\\n          if(direction == 1){\\n            v[start] +=  1;\\n           v[end+1] += -1; \\n          }\\n          else{\\n            v[start] +=-1;\\n            v[end+1] +=1;\\n          }\\n        }\\n        for(int i=1;i<n;i++){\\n          v[i]+=v[i-1];\\n        }\\n        for(int i=0;i<n;i++){\\n          v[i] = v[i]%26;\\n        }\\n        for(int i=0;i<n;i++){\\n          int x = s[i]-\\'a\\';\\n          v[i]+=x;\\n          v[i] = v[i]%26;\\n            if(v[i]<0){\\n            v[i]= 26+v[i];\\n          }\\n          cout<<v[i]<<\" \";\\n        }\\n        string res = \"\";\\n        for(int i=0;i<n;i++){\\n          res+=v[i]+\\'a\\';\\n        }\\n\\n        return res;\\n    }\\n};",
                "solutionTags": [
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int size = shifts.size();\\n        int n= s.size();\\n        vector<int> v(n+1,0);\\n        for(int i=0;i<size;i++){\\n          int start = shifts[i][0];\\n          int end = shifts[i][1];\\n          int direction = shifts[i][2];\\n          if(direction == 1){\\n            v[start] +=  1;\\n           v[end+1] += -1; \\n          }",
                "codeTag": "Java"
            },
            {
                "id": 2559073,
                "title": "c-line-sweep-solution",
                "content": "```\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int len=s.length();\\n        vector<int> dir(len+1, 0);\\n        for(auto &shift: shifts){\\n            int start=shift[0], end=shift[1], job=(shift[2]==1)?1:-1;\\n            if(job==1)\\n                dir[start]++, dir[end+1]--;\\n            else\\n                dir[start]--, dir[end+1]++;\\n        }\\n        long long job=0;\\n        for(int i=0; i<len; i++){\\n            job+=dir[i];\\n            s[i]=((s[i]-\\'a\\')+job+260000000LL)%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int len=s.length();\\n        vector<int> dir(len+1, 0);\\n        for(auto &shift: shifts){\\n            int start=shift[0], end=shift[1], job=(shift[2]==1)?1:-1;\\n            if(job==1)\\n                dir[start]++, dir[end+1]--;\\n            else\\n                dir[start]--, dir[end+1]++;\\n        }\\n        long long job=0;\\n        for(int i=0; i<len; i++){\\n            job+=dir[i];\\n            s[i]=((s[i]-\\'a\\')+job+260000000LL)%26+\\'a\\';\\n        }\\n        return s;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2525964,
                "title": "c-segment-tree-solution",
                "content": "```\\nint64_t e_group_op = 0;\\n\\nstruct treeNode {\\n    treeNode() : s(0), g(e_group_op), num(1) {}\\n\\ttreeNode (int64_t val, int64_t g_val=e_group_op, int n=1) : s(val), g(g_val), num(n) {}\\n    int64_t s, g;\\n    int num;\\n};\\n\\ntreeNode e_op = {0, e_group_op, 0};\\n\\n\\nvoid group_op(treeNode& x, int64_t val) {\\n    // x.g += val;\\n    // x.s += val * x.num;\\n    // ----------------------------------\\n    // if (x.g < val) x.s = x.g = val;\\n    // ----------------------------------\\n    x.g += val;\\n    x.s = x.g;\\n}\\n\\ntreeNode main_tree_op(const treeNode& x, const treeNode& y) {\\n    return treeNode(x.s + y.s, e_group_op, x.num + y.num);\\n    // ------------------------------------------------------\\n    // return treeNode(max(x.s, y.s));\\n}\\n\\n\\nclass segmentTree {\\nprivate:\\n    bool rightInclude;\\n\\n    int upper_power2(int x) {\\n        int power2 = 1;\\n        while (power2 < x) {\\n            power2 *= 2;\\n        }\\n        return power2;\\n    }\\n\\n    int n, N;\\n\\npublic:\\n    vector<treeNode> tree;\\n    segmentTree() {}\\n    segmentTree(vector<int>& arr, bool rightInclusive=false, bool initialize=true) {\\n        rightInclude = rightInclusive;\\n        n = arr.size();\\n        N = 2 * upper_power2(n) - 1;\\n        tree.assign(N, e_op);\\n        if (initialize) {\\n            for (int i = 0; i < n; ++i) {\\n                tree[N / 2 + i] = arr[i];\\n            }\\n            for (int x = N - 1; x > 1; x -= 2) {\\n                tree[(x - 1) / 2] = main_tree_op(tree[x], tree[x - 1]);\\n            }            \\n        }\\n    }\\n\\n    void propagate(int x, int lx, int rx) {\\n        if (rx - lx == 1 || tree[x].g == e_group_op) return;\\n        group_op(tree[2 * x + 1], tree[x].g);\\n        group_op(tree[2 * x + 2], tree[x].g);\\n        tree[x].g = e_group_op;\\n    }\\n\\n    void set(int i, int64_t v, int x=0, int lx=0, int rx=-1) {\\n        if (rx == -1) rx = N / 2 + 1;            \\n        propagate(x, lx, rx);\\n        if (rx - lx == 1) {\\n            tree[x].s = v;\\n            return;\\n        }\\n        int m = (rx + lx) / 2;\\n        if (i < m) {\\n            set(i, v, 2 * x + 1, lx, m);\\n        } else {\\n            set(i, v, 2 * x + 2, m, rx);\\n        }\\n        tree[x] = main_tree_op(tree[2 * x + 1], tree[2 * x + 2]);\\n    }\\n\\n    int64_t query(int l, int r, int x=0, int lx=0, int rx=-1) {\\n        if (rx == -1) {\\n            rx = N / 2 + 1;\\n            if (rightInclude) r += 1;\\n        }\\n\\n        propagate(x, lx, rx);\\n\\n        if (lx >= r || l >= rx) return e_op.s;\\n        if (lx >= l && rx <= r) return tree[x].s;\\n        int m = (rx + lx) / 2;\\n        int64_t ans_l = query(l, r, 2 * x + 1, lx, m);\\n        int64_t ans_r = query(l, r, 2 * x + 2, m, rx);\\n        return main_tree_op(ans_l, ans_r).s;\\n    }\\n\\n    void group_change(int l, int r, int64_t group_val, int x=0, int lx=0, int rx=-1) {\\n        if (rx == -1) {\\n            rx = N / 2 + 1;\\n            if (rightInclude) r += 1;\\n        }\\n\\n        propagate(x, lx, rx);\\n\\n        if (lx >= r || l >= rx) return;\\n        if (lx >= l && rx <= r) {\\n            group_op(tree[x], group_val);\\n            return;\\n        }\\n        int m = (rx + lx) / 2;\\n        group_change(l, r, group_val, 2 * x + 1, lx, m);\\n        group_change(l, r, group_val, 2 * x + 2, m, rx);\\n        tree[x] = main_tree_op(tree[2 * x + 1], tree[2 * x + 2]);\\n    }\\n    \\n    void print() {\\n        for (int i = 0; i < tree.size(); ++i) {\\n            cout << \"\\\\\"\" << tree[i].s << \"|\" << tree[i].g << \"\\\\\"\" << \", \";\\n        }\\n        cout << endl;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    segmentTree st;\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> tmp(s.size());\\n        st = segmentTree(tmp, true, false);\\n        int dir;\\n        for (int i = 0; i < shifts.size(); ++i) {\\n            dir = (shifts[i][2] == 0) ? -1 : 1;\\n            st.group_change(shifts[i][0], shifts[i][1], dir);\\n        }\\n        for (int i = 0; i < s.size(); ++i) {\\n            s[i] = (((s[i] - \\'a\\' + st.query(i, i)) % 26) + 26) % 26 + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nint64_t e_group_op = 0;\\n\\nstruct treeNode {\\n    treeNode() : s(0), g(e_group_op), num(1) {}\\n\\ttreeNode (int64_t val, int64_t g_val=e_group_op, int n=1) : s(val), g(g_val), num(n) {}\\n    int64_t s, g;\\n    int num;\\n};\\n\\ntreeNode e_op = {0, e_group_op, 0};\\n\\n\\nvoid group_op(treeNode& x, int64_t val) {\\n    // x.g += val;\\n    // x.s += val * x.num;\\n    // ----------------------------------\\n    // if (x.g < val) x.s = x.g = val;\\n    // ----------------------------------\\n    x.g += val;\\n    x.s = x.g;\\n}\\n\\ntreeNode main_tree_op(const treeNode& x, const treeNode& y) {\\n    return treeNode(x.s + y.s, e_group_op, x.num + y.num);\\n    // ------------------------------------------------------\\n    // return treeNode(max(x.s, y.s));\\n}\\n\\n\\nclass segmentTree {\\nprivate:\\n    bool rightInclude;\\n\\n    int upper_power2(int x) {\\n        int power2 = 1;\\n        while (power2 < x) {\\n            power2 *= 2;\\n        }\\n        return power2;\\n    }\\n\\n    int n, N;\\n\\npublic:\\n    vector<treeNode> tree;\\n    segmentTree() {}\\n    segmentTree(vector<int>& arr, bool rightInclusive=false, bool initialize=true) {\\n        rightInclude = rightInclusive;\\n        n = arr.size();\\n        N = 2 * upper_power2(n) - 1;\\n        tree.assign(N, e_op);\\n        if (initialize) {\\n            for (int i = 0; i < n; ++i) {\\n                tree[N / 2 + i] = arr[i];\\n            }\\n            for (int x = N - 1; x > 1; x -= 2) {\\n                tree[(x - 1) / 2] = main_tree_op(tree[x], tree[x - 1]);\\n            }            \\n        }\\n    }\\n\\n    void propagate(int x, int lx, int rx) {\\n        if (rx - lx == 1 || tree[x].g == e_group_op) return;\\n        group_op(tree[2 * x + 1], tree[x].g);\\n        group_op(tree[2 * x + 2], tree[x].g);\\n        tree[x].g = e_group_op;\\n    }\\n\\n    void set(int i, int64_t v, int x=0, int lx=0, int rx=-1) {\\n        if (rx == -1) rx = N / 2 + 1;            \\n        propagate(x, lx, rx);\\n        if (rx - lx == 1) {\\n            tree[x].s = v;\\n            return;\\n        }\\n        int m = (rx + lx) / 2;\\n        if (i < m) {\\n            set(i, v, 2 * x + 1, lx, m);\\n        } else {\\n            set(i, v, 2 * x + 2, m, rx);\\n        }\\n        tree[x] = main_tree_op(tree[2 * x + 1], tree[2 * x + 2]);\\n    }\\n\\n    int64_t query(int l, int r, int x=0, int lx=0, int rx=-1) {\\n        if (rx == -1) {\\n            rx = N / 2 + 1;\\n            if (rightInclude) r += 1;\\n        }\\n\\n        propagate(x, lx, rx);\\n\\n        if (lx >= r || l >= rx) return e_op.s;\\n        if (lx >= l && rx <= r) return tree[x].s;\\n        int m = (rx + lx) / 2;\\n        int64_t ans_l = query(l, r, 2 * x + 1, lx, m);\\n        int64_t ans_r = query(l, r, 2 * x + 2, m, rx);\\n        return main_tree_op(ans_l, ans_r).s;\\n    }\\n\\n    void group_change(int l, int r, int64_t group_val, int x=0, int lx=0, int rx=-1) {\\n        if (rx == -1) {\\n            rx = N / 2 + 1;\\n            if (rightInclude) r += 1;\\n        }\\n\\n        propagate(x, lx, rx);\\n\\n        if (lx >= r || l >= rx) return;\\n        if (lx >= l && rx <= r) {\\n            group_op(tree[x], group_val);\\n            return;\\n        }\\n        int m = (rx + lx) / 2;\\n        group_change(l, r, group_val, 2 * x + 1, lx, m);\\n        group_change(l, r, group_val, 2 * x + 2, m, rx);\\n        tree[x] = main_tree_op(tree[2 * x + 1], tree[2 * x + 2]);\\n    }\\n    \\n    void print() {\\n        for (int i = 0; i < tree.size(); ++i) {\\n            cout << \"\\\\\"\" << tree[i].s << \"|\" << tree[i].g << \"\\\\\"\" << \", \";\\n        }\\n        cout << endl;\\n    }\\n};\\n\\n\\nclass Solution {\\npublic:\\n    segmentTree st;\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> tmp(s.size());\\n        st = segmentTree(tmp, true, false);\\n        int dir;\\n        for (int i = 0; i < shifts.size(); ++i) {\\n            dir = (shifts[i][2] == 0) ? -1 : 1;\\n            st.group_change(shifts[i][0], shifts[i][1], dir);\\n        }\\n        for (int i = 0; i < s.size(); ++i) {\\n            s[i] = (((s[i] - \\'a\\' + st.query(i, i)) % 26) + 26) % 26 + \\'a\\';\\n        }\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2514522,
                "title": "c-easy-solution-line-sweep-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<pair<int,int>>v(s.size()+1);\\n        //{no_of_zeroes,no_of_ones}\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            if(shifts[i][2]==0)\\n            {\\n                v[shifts[i][0]].first++;\\n                v[shifts[i][1]+1].first--;\\n            }\\n            else\\n            {\\n                v[shifts[i][0]].second++;\\n                v[shifts[i][1]+1].second--;\\n            }\\n        }\\n        string ans;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            v[i].first+=v[i-1].first;\\n            v[i].second+=v[i-1].second;\\n        }\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            int y = s[i]-\\'a\\';\\n            int u = (v[i].first)%26;\\n            char t = 0;\\n            if(u>y)\\n            {\\n                int ko = u-y;\\n                int mk = 26-ko;\\n                t=\\'a\\'+mk;\\n            }\\n            else\\n            {\\n                int lo = y-u;\\n                t=\\'a\\'+lo;\\n            }\\n            int ji = ((t-\\'a\\')+v[i].second)%26;\\n            char ll = ji+\\'a\\';\\n            ans.push_back(ll);\\n        }\\n        for(int i=ans.size();i<s.size();i++)\\n        {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<pair<int,int>>v(s.size()+1);\\n        //{no_of_zeroes,no_of_ones}\\n        for(int i=0;i<shifts.size();i++)\\n        {\\n            if(shifts[i][2]==0)\\n            {\\n                v[shifts[i][0]].first++;\\n                v[shifts[i][1]+1].first--;\\n            }\\n            else\\n            {\\n                v[shifts[i][0]].second++;\\n                v[shifts[i][1]+1].second--;\\n            }\\n        }\\n        string ans;\\n        for(int i=1;i<v.size();i++)\\n        {\\n            v[i].first+=v[i-1].first;\\n            v[i].second+=v[i-1].second;\\n        }\\n        for(int i=0;i<v.size()-1;i++)\\n        {\\n            int y = s[i]-\\'a\\';\\n            int u = (v[i].first)%26;\\n            char t = 0;\\n            if(u>y)\\n            {\\n                int ko = u-y;\\n                int mk = 26-ko;\\n                t=\\'a\\'+mk;\\n            }\\n            else\\n            {\\n                int lo = y-u;\\n                t=\\'a\\'+lo;\\n            }\\n            int ji = ((t-\\'a\\')+v[i].second)%26;\\n            char ll = ji+\\'a\\';\\n            ans.push_back(ll);\\n        }\\n        for(int i=ans.size();i<s.size();i++)\\n        {\\n            ans.push_back(s[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513237,
                "title": "o-n-time-o-n-space-clear-explanation-also-1943-1854-1094-1109",
                "content": "![image](https://assets.leetcode.com/users/images/91060c43-2af3-4c4d-a4ca-e18b8ec12e2d_1662024192.9286475.png)\\n\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \"\"\" O(N)TS \"\"\"\\n        line = collections.Counter()\\n        [line.update({a: 1, b + 1: -1}) if c else line.update({a: -1, b + 1: 1}) for a, b, c in shifts]\\n        acc = list(itertools.accumulate([line[i] for i in range(len(s))]))\\n        ans = (chr((ord(c) - 97 + i) % 26 + 97) for c, i in zip(s, acc))\\n        return \\'\\'.join(ans)",
                "solutionTags": [],
                "code": "![image](https://assets.leetcode.com/users/images/91060c43-2af3-4c4d-a4ca-e18b8ec12e2d_1662024192.9286475.png)\\n\\n    def shiftingLetters(self, s: str, shifts: List[List[int]]) -> str:\\n        \"\"\" O(N)TS \"\"\"\\n        line = collections.Counter()\\n        [line.update({a: 1, b + 1: -1}) if c else line.update({a: -1, b + 1: 1}) for a, b, c in shifts]\\n        acc = list(itertools.accumulate([line[i] for i in range(len(s))]))\\n        ans = (chr((ord(c) - 97 + i) % 26 + 97) for c, i in zip(s, acc))\\n        return \\'\\'.join(ans)",
                "codeTag": "Python3"
            },
            {
                "id": 2495789,
                "title": "c",
                "content": "**Bucket**\\nSimilar to: https://leetcode.com/problems/meeting-rooms-ii/discuss/2135429/four-cpp-methods (First Method and follow up)\\n```\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> bucket(s.size() + 1, 0);\\n        for (auto& it: shifts){\\n            if (it[2] == 1){\\n                bucket[it[0]] ++;\\n                bucket[it[1] + 1] --;\\n            }else{\\n                bucket[it[0]] --;\\n                bucket[it[1] + 1] ++;\\n            }\\n        }\\n        \\n        int accumulate = 0;\\n        string ans = \"\";\\n        for (int i = 0; i < s.size(); ++ i){\\n            accumulate += bucket[i];\\n            \\n            int temp = (accumulate % 26 + 26) % 26;\\n            if (temp > \\'z\\' - s[i]){\\n                ans += \\'a\\' + temp - \\'z\\' + s[i] - 1;\\n            }else{\\n                ans += s[i] + temp;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        vector<int> bucket(s.size() + 1, 0);\\n        for (auto& it: shifts){\\n            if (it[2] == 1){\\n                bucket[it[0]] ++;\\n                bucket[it[1] + 1] --;\\n            }else{\\n                bucket[it[0]] --;\\n                bucket[it[1] + 1] ++;\\n            }\\n        }\\n        \\n        int accumulate = 0;\\n        string ans = \"\";\\n        for (int i = 0; i < s.size(); ++ i){\\n            accumulate += bucket[i];\\n            \\n            int temp = (accumulate % 26 + 26) % 26;\\n            if (temp > \\'z\\' - s[i]){\\n                ans += \\'a\\' + temp - \\'z\\' + s[i] - 1;\\n            }else{\\n                ans += s[i] + temp;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2495654,
                "title": "very-easy-java-solution-using-prefixsum",
                "content": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n=s.length();\\n        int[] preSum=new int[n+1];\\n        for(int[] shift: shifts){\\n            int start=shift[0];\\n            int end=shift[1];\\n            int dir=shift[2];\\n            if(dir==0){\\n                preSum[start]--;\\n                preSum[end+1]++;\\n            }\\n            else{\\n                preSum[start]++;\\n                preSum[end+1]--;\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            preSum[i]+=preSum[i-1];\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<n;i++){\\n            char ch=s.charAt(i);\\n            int shift=preSum[i];\\n            ch=(char)(((ch-\\'a\\'+shift)%26+26)%26+\\'a\\');\\n            sb.append(ch);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    public String shiftingLetters(String s, int[][] shifts) {\\n        int n=s.length();\\n        int[] preSum=new int[n+1];\\n        for(int[] shift: shifts){\\n            int start=shift[0];\\n            int end=shift[1];\\n            int dir=shift[2];\\n            if(dir==0){\\n                preSum[start]--;\\n                preSum[end+1]++;\\n            }\\n            else{\\n                preSum[start]++;\\n                preSum[end+1]--;\\n            }\\n        }\\n        for(int i=1;i<=n;i++){\\n            preSum[i]+=preSum[i-1];\\n        }\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<n;i++){\\n            char ch=s.charAt(i);\\n            int shift=preSum[i];\\n            ch=(char)(((ch-\\'a\\'+shift)%26+26)%26+\\'a\\');\\n            sb.append(ch);\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490446,
                "title": "c-prefix-sum",
                "content": "```\\n  string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        vector<int>v(n+1,0);\\n        \\n        for(int i=0;i<shifts.size();i++){\\n            int a=shifts[i][0];\\n            int b=shifts[i][1];\\n            int c=shifts[i][2];\\n            \\n            if(c==0){\\n                v[a]--;\\n                v[b+1]++;\\n            }else{\\n                v[a]++;\\n                v[b+1]--;\\n            }\\n        }\\n        \\n        \\n        \\n        for(int i=1;i<v.size();i++){\\n            v[i]=v[i]+v[i-1];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            \\n            \\n            int ind= s[i]-\\'a\\';\\n            ind=(ind+v[i])%26;\\n            \\n            if(ind<0){\\n                ind=ind+26;\\n            }\\n            char nextChar = \\'a\\'+ind;\\n            s[i]=nextChar;\\n            \\n        \\n            \\n        }\\n        return s;\\n        \\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n  string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.length();\\n        vector<int>v(n+1,0);\\n        \\n        for(int i=0;i<shifts.size();i++){\\n            int a=shifts[i][0];\\n            int b=shifts[i][1];\\n            int c=shifts[i][2];\\n            \\n            if(c==0){\\n                v[a]--;\\n                v[b+1]++;\\n            }else{\\n                v[a]++;\\n                v[b+1]--;\\n            }\\n        }\\n        \\n        \\n        \\n        for(int i=1;i<v.size();i++){\\n            v[i]=v[i]+v[i-1];\\n        }\\n        \\n        for(int i=0;i<n;i++){\\n            \\n            \\n            \\n            int ind= s[i]-\\'a\\';\\n            ind=(ind+v[i])%26;\\n            \\n            if(ind<0){\\n                ind=ind+26;\\n            }\\n            char nextChar = \\'a\\'+ind;\\n            s[i]=nextChar;\\n            \\n        \\n            \\n        }\\n        return s;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2489403,
                "title": "c-easy-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> v(n, 0);//for storing from which index to which index forward or backward operation takes place\\n        for(int i=0;i<shifts.size();i++){\\n            if(shifts[i][2]){\\n                //forward operation\\n                if(shifts[i][1]+1<n){\\n                    v[shifts[i][1]+1]-=1;\\n                }\\n                v[shifts[i][0]] += 1;\\n            }\\n            else{\\n                //backward operation\\n                if(shifts[i][1]+1<n){\\n                    v[shifts[i][1]+1]+=1;\\n                }\\n                v[shifts[i][0]] -= 1;\\n            }\\n        }\\n        //summing up everything to we will know what operation to do and howmany times we should do\\n        int num=v[0];\\n        for(int i=1;i<n;i++){\\n            v[i] += v[i-1];\\n        }\\n        //converting the character\\n        for (int j = 0; j < s.size(); j++) {\\n\\t\\t\\tint num = s[j] - \\'a\\';\\n\\t\\t\\tnum += v[j];\\n            num %= 26;\\n            num += 26;\\n\\t\\t\\tnum %= 26;\\n\\t\\t\\ts[j] = \\'a\\' + num;\\n\\t\\t}\\n        return s;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        int n=s.size();\\n        vector<int> v(n, 0);//for storing from which index to which index forward or backward operation takes place\\n        for(int i=0;i<shifts.size();i++){\\n            if(shifts[i][2]){\\n                //forward operation\\n                if(shifts[i][1]+1<n){\\n                    v[shifts[i][1]+1]-=1;\\n                }\\n                v[shifts[i][0]] += 1;\\n            }\\n            else{\\n                //backward operation\\n                if(shifts[i][1]+1<n){\\n                    v[shifts[i][1]+1]+=1;\\n                }\\n                v[shifts[i][0]] -= 1;\\n            }\\n        }\\n        //summing up everything to we will know what operation to do and howmany times we should do\\n        int num=v[0];\\n        for(int i=1;i<n;i++){\\n            v[i] += v[i-1];\\n        }\\n        //converting the character\\n        for (int j = 0; j < s.size(); j++) {\\n\\t\\t\\tint num = s[j] - \\'a\\';\\n\\t\\t\\tnum += v[j];\\n            num %= 26;\\n            num += 26;\\n\\t\\t\\tnum %= 26;\\n\\t\\t\\ts[j] = \\'a\\' + num;\\n\\t\\t}\\n        return s;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2489120,
                "title": "c-recursive-solution-simple-bruteforce-o-n-2",
                "content": "```\\n\\nclass Solution {\\n    int traversal=0;\\n     int veci=0;\\n       \\npublic:\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        // AlphaBet Pushed\\n        vector<char> alpha;\\n        alpha.push_back(\\'z\\');\\n        for(char i=\\'a\\';i<=\\'z\\';i++){\\n            alpha.push_back(i);\\n        }\\n        alpha.push_back(\\'a\\');\\n        \\n        //Base case\\n        int row = shifts.size();\\n         if(veci==row){\\n             return s;\\n         }\\n        //rec case\\n            for(int i=shifts[veci][0];i<=shifts[veci][1];i++){\\n                  int idx = find(alpha.begin()+1,alpha.end()-1,s[i])-alpha.begin();\\n                  if(shifts[veci][2]==0){\\n                     s[i]= alpha[idx-1] ;\\n                  }\\n                  else if(shifts[veci][2]==1){\\n                      s[i]= alpha[idx+1] ;\\n                  } \\n            }\\n            veci++;\\n        return  shiftingLetters(s,shifts) ;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Recursion"
                ],
                "code": "```\\n\\nclass Solution {\\n    int traversal=0;\\n     int veci=0;\\n       \\npublic:\\n    \\n    string shiftingLetters(string s, vector<vector<int>>& shifts) {\\n        // AlphaBet Pushed\\n        vector<char> alpha;\\n        alpha.push_back(\\'z\\');\\n        for(char i=\\'a\\';i<=\\'z\\';i++){\\n            alpha.push_back(i);\\n        }\\n        alpha.push_back(\\'a\\');\\n        \\n        //Base case\\n        int row = shifts.size();\\n         if(veci==row){\\n             return s;\\n         }\\n        //rec case\\n            for(int i=shifts[veci][0];i<=shifts[veci][1];i++){\\n                  int idx = find(alpha.begin()+1,alpha.end()-1,s[i])-alpha.begin();\\n                  if(shifts[veci][2]==0){\\n                     s[i]= alpha[idx-1] ;\\n                  }\\n                  else if(shifts[veci][2]==1){\\n                      s[i]= alpha[idx+1] ;\\n                  } \\n            }\\n            veci++;\\n        return  shiftingLetters(s,shifts) ;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2029012,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "Tips: line sweep:\\n- for left:  add -1 at index shift[0] and +1 at index shift[1] +1 (and reverse for right direction).\\n- traverse each index and apply prefix sum shift for each character."
                    },
                    {
                        "username": "Ashmit_S21017465",
                        "content": "A hint : \\nTry one of the Prefix sum techniques used for range : Line Sweep or Fenwick Tree"
                    },
                    {
                        "username": "Ashmit_S21017465",
                        "content": "The test cases given here do not justify the detailed problem as to what the question is expecting. Kindly look into this Leetcode and try to add one or two more detailed test cases."
                    }
                ]
            },
            {
                "id": 1925903,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "Tips: line sweep:\\n- for left:  add -1 at index shift[0] and +1 at index shift[1] +1 (and reverse for right direction).\\n- traverse each index and apply prefix sum shift for each character."
                    },
                    {
                        "username": "Ashmit_S21017465",
                        "content": "A hint : \\nTry one of the Prefix sum techniques used for range : Line Sweep or Fenwick Tree"
                    },
                    {
                        "username": "Ashmit_S21017465",
                        "content": "The test cases given here do not justify the detailed problem as to what the question is expecting. Kindly look into this Leetcode and try to add one or two more detailed test cases."
                    }
                ]
            },
            {
                "id": 1925899,
                "content": [
                    {
                        "username": "StefanelStan",
                        "content": "Tips: line sweep:\\n- for left:  add -1 at index shift[0] and +1 at index shift[1] +1 (and reverse for right direction).\\n- traverse each index and apply prefix sum shift for each character."
                    },
                    {
                        "username": "Ashmit_S21017465",
                        "content": "A hint : \\nTry one of the Prefix sum techniques used for range : Line Sweep or Fenwick Tree"
                    },
                    {
                        "username": "Ashmit_S21017465",
                        "content": "The test cases given here do not justify the detailed problem as to what the question is expecting. Kindly look into this Leetcode and try to add one or two more detailed test cases."
                    }
                ]
            }
        ]
    },
    {
        "title": "Maximum Segment Sum After Removals",
        "question_content": "<p>You are given two <strong>0-indexed</strong> integer arrays <code>nums</code> and <code>removeQueries</code>, both of length <code>n</code>. For the <code>i<sup>th</sup></code> query, the element in <code>nums</code> at the index <code>removeQueries[i]</code> is removed, splitting <code>nums</code> into different segments.</p>\n\n<p>A <strong>segment</strong> is a contiguous sequence of <strong>positive</strong> integers in <code>nums</code>. A <strong>segment sum</strong> is the sum of every element in a segment.</p>\n\n<p>Return<em> an integer array </em><code>answer</code><em>, of length </em><code>n</code><em>, where </em><code>answer[i]</code><em> is the <strong>maximum</strong> segment sum after applying the </em><code>i<sup>th</sup></code> <em>removal.</em></p>\n\n<p><strong>Note:</strong> The same index will <strong>not</strong> be removed more than once.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]\n<strong>Output:</strong> [14,7,2,2,0]\n<strong>Explanation:</strong> Using 0 to indicate a removed element, the answer is as follows:\nQuery 1: Remove the 0th element, nums becomes [0,2,5,6,1] and the maximum segment sum is 14 for segment [2,5,6,1].\nQuery 2: Remove the 3rd element, nums becomes [0,2,5,0,1] and the maximum segment sum is 7 for segment [2,5].\nQuery 3: Remove the 2nd element, nums becomes [0,2,0,0,1] and the maximum segment sum is 2 for segment [2]. \nQuery 4: Remove the 4th element, nums becomes [0,2,0,0,0] and the maximum segment sum is 2 for segment [2]. \nQuery 5: Remove the 1st element, nums becomes [0,0,0,0,0] and the maximum segment sum is 0, since there are no segments.\nFinally, we return [14,7,2,2,0].</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> nums = [3,2,11,1], removeQueries = [3,2,1,0]\n<strong>Output:</strong> [16,5,3,0]\n<strong>Explanation:</strong> Using 0 to indicate a removed element, the answer is as follows:\nQuery 1: Remove the 3rd element, nums becomes [3,2,11,0] and the maximum segment sum is 16 for segment [3,2,11].\nQuery 2: Remove the 2nd element, nums becomes [3,2,0,0] and the maximum segment sum is 5 for segment [3,2].\nQuery 3: Remove the 1st element, nums becomes [3,0,0,0] and the maximum segment sum is 3 for segment [3].\nQuery 4: Remove the 0th element, nums becomes [0,0,0,0] and the maximum segment sum is 0, since there are no segments.\nFinally, we return [16,5,3,0].\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == nums.length == removeQueries.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 10<sup>5</sup></code></li>\n\t<li><code>1 &lt;= nums[i] &lt;= 10<sup>9</sup></code></li>\n\t<li><code>0 &lt;= removeQueries[i] &lt; n</code></li>\n\t<li>All the values of <code>removeQueries</code> are <strong>unique</strong>.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2454208,
                "title": "reverse-union-find",
                "content": "In the end, we remove all elements from the array (`nums.length == removeQueries.length`). \\n    \\nSo, we can start from no segments, add elements in the reverse (of the removal) order, and create/merge segments.\\n    \\nAs we add an element, it can either:\\n- create a new segment (e.g. `__, [7], __`)\\n- join an existing segment on the left (e.g. `5, 6, [7], __`)\\n- join an existing segment on the right (e.g. `__, [7], 8, 9`)\\n- merge existing segments on the left and right into one (e.g. `5, 6, [7], 8, 9`)\\n    \\n**Union-Find**\\nWe initialize the `ds` array with `INT_MAX`, so we can check if we an element on the left (or right) has been inserted.\\n\\nAs we insert an element `j`, we set `ds[j]` to `nums[j]` (negated). Then, we check if an element on the left/right has been inserted, and do a merge if it has. \\n\\nA non-negative value is an index of the set \"parent\". A negative value is the negated sum of all elements in the set.\\n    \\n**C++**\\n```cpp\\nint find(int i, vector<long long>& ds) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds[i], ds);\\n}\\nvoid merge(int s1, int s2, vector<long long>& ds) {\\n    int p1 = find(s1, ds), p2 = find(s2, ds);\\n    ds[p2] += ds[p1];\\n    ds[p1] = p2;\\n}\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq) {\\n    vector<long long> res(nums.size()), ds(nums.size(), INT_MAX);\\n    for (int i = rq.size() - 1; i > 0; --i) {\\n        int j = rq[i];\\n        ds[j] = -nums[j];\\n        if (j > 0 && ds[j - 1] != INT_MAX)\\n            merge(j, j - 1, ds);\\n        if (j < nums.size() - 1 && ds[j + 1] != INT_MAX)\\n            merge(j, j + 1, ds);\\n        res[i - 1] = max(res[i], -ds[find(j, ds)]);\\n    }\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```cpp\\nint find(int i, vector<long long>& ds) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds[i], ds);\\n}\\nvoid merge(int s1, int s2, vector<long long>& ds) {\\n    int p1 = find(s1, ds), p2 = find(s2, ds);\\n    ds[p2] += ds[p1];\\n    ds[p1] = p2;\\n}\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq) {\\n    vector<long long> res(nums.size()), ds(nums.size(), INT_MAX);\\n    for (int i = rq.size() - 1; i > 0; --i) {\\n        int j = rq[i];\\n        ds[j] = -nums[j];\\n        if (j > 0 && ds[j - 1] != INT_MAX)\\n            merge(j, j - 1, ds);\\n        if (j < nums.size() - 1 && ds[j + 1] != INT_MAX)\\n            merge(j, j + 1, ds);\\n        res[i - 1] = max(res[i], -ds[find(j, ds)]);\\n    }\\n    return res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454192,
                "title": "c-sets-prefix-sum-solution-approach-code",
                "content": "**Approach:**\\n\\n- Store current segments in form of intervals in a set. \\n- Have another multiset to store sums of all the current intervals or segments.\\n- For each query find the interval in which the query[i] belongs and split that interval into 2 segments.\\n- Erase the previous segment sum from multiset and the previous interval from set and insert new sum and new    intervals.\\n- For faster calculation of segment sum, have a prefix sum array.\\n\\n```\\n/*\\n *  Space Complexity: O(N)\\n *\\tTime Complexity: O(N + QlogQ),  \\n *  where, Q = count of remove queries, N = length of nums array.\\n */\\n\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        multiset<long long> s;\\n        s.insert(0);\\n        set<pair<int, int>> in;\\n        vector<long long> pre(n, nums[0]);\\n        for(int i = 1; i < n; i++) pre[i] = pre[i - 1] + nums[i];\\n        \\n        in.insert({0, n - 1});\\n        \\n        s.insert(pre[n - 1]);\\n        \\n        vector<long long> ans;\\n        for(auto p : removeQueries) {\\n            auto it = in.upper_bound({p, 2e9});\\n            it--;\\n            \\n            long long L = (p ? pre[p - 1] : 0) - (it -> first ? pre[it -> first - 1] : 0);\\n            long long R = pre[it -> second] - pre[p];\\n            long long T = pre[it -> second] - (it -> first ? pre[it -> first - 1] : 0);\\n            \\n            s.erase(s.find(T));\\n            if(it -> first <= p - 1) {\\n                in.insert({it -> first, p - 1});\\n                s.insert(L);\\n            }\\n            if(it -> second >= p + 1) {\\n                in.insert({p + 1, it -> second});\\n                s.insert(R);\\n            }\\n            \\n            in.erase(it);\\n            ans.push_back(*s.rbegin());\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\n\\n**Do Upvote if you liked the solution :).**",
                "solutionTags": [],
                "code": "```\\n/*\\n *  Space Complexity: O(N)\\n *\\tTime Complexity: O(N + QlogQ),  \\n *  where, Q = count of remove queries, N = length of nums array.\\n */\\n\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        multiset<long long> s;\\n        s.insert(0);\\n        set<pair<int, int>> in;\\n        vector<long long> pre(n, nums[0]);\\n        for(int i = 1; i < n; i++) pre[i] = pre[i - 1] + nums[i];\\n        \\n        in.insert({0, n - 1});\\n        \\n        s.insert(pre[n - 1]);\\n        \\n        vector<long long> ans;\\n        for(auto p : removeQueries) {\\n            auto it = in.upper_bound({p, 2e9});\\n            it--;\\n            \\n            long long L = (p ? pre[p - 1] : 0) - (it -> first ? pre[it -> first - 1] : 0);\\n            long long R = pre[it -> second] - pre[p];\\n            long long T = pre[it -> second] - (it -> first ? pre[it -> first - 1] : 0);\\n            \\n            s.erase(s.find(T));\\n            if(it -> first <= p - 1) {\\n                in.insert({it -> first, p - 1});\\n                s.insert(L);\\n            }\\n            if(it -> second >= p + 1) {\\n                in.insert({p + 1, it -> second});\\n                s.insert(R);\\n            }\\n            \\n            in.erase(it);\\n            ans.push_back(*s.rbegin());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454397,
                "title": "do-it-backwards-o-n",
                "content": "For nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1], the reverse process will be \\nadd 1 : [0, 2, 0 ,0 ,0]\\nadd 4 : [0, 2, 0 ,0 ,1]\\nadd 2 : [0, 2, 5 ,0 ,1]\\nadd 3 : [0, 2, 5, 6, 1]\\nadd 0 : [1, 2, 5, 6, 1]\\n\\nWhen an index q is added, extend the contiguous sequence by finding if q+1 or q-1 exists, and also record the value of the maximum segment sum. For example, before adding the 3rd element, there are two contiguous sequences, [2, 5] and [1], and we can extend it to a length 4 sequence after the 3rd element is added.\\n```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        mp, cur, res = {}, 0, []\\n        for q in reversed(removeQueries[1:]):\\n            mp[q] = (nums[q], 1)\\n            rv, rLen = mp.get(q+1, (0, 0))\\n            lv, lLen = mp.get(q-1, (0, 0))\\n                \\n            total = nums[q] + rv + lv\\n            mp[q+rLen] = (total, lLen + rLen + 1)\\n            mp[q-lLen] = (total, lLen + rLen + 1)\\n        \\n            cur = max(cur, total)\\n            res.append(cur)\\n            \\n        return res[::-1] + [0]\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        mp, cur, res = {}, 0, []\\n        for q in reversed(removeQueries[1:]):\\n            mp[q] = (nums[q], 1)\\n            rv, rLen = mp.get(q+1, (0, 0))\\n            lv, lLen = mp.get(q-1, (0, 0))\\n                \\n            total = nums[q] + rv + lv\\n            mp[q+rLen] = (total, lLen + rLen + 1)\\n            mp[q-lLen] = (total, lLen + rLen + 1)\\n        \\n            cur = max(cur, total)\\n            res.append(cur)\\n            \\n        return res[::-1] + [0]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461035,
                "title": "python-reverse-union-find-clean-concise",
                "content": "**Idea**\\n- At the end, we remove all elements in `nums` array.\\n- Instead of doing forward, we can do it back-ward\\n- Let grab an example for easy to understand:\\n```\\nnums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]\\n```\\n- 4th query, we remove `1th` element, the state before it: `_, 2, _, _, _` (add node `1th` to our UnionFind)\\n- 3th query, we remove `4th` element, the state before it: `_, 2, _, _, 1` (add node `4th` to our UnionFind)\\n- 2th query, we remove `2th` element, the state before it: `_, 2, 5, _, 1` (add node `2th` to our UnionFind, merge node `2th` with node `1th`)\\n- 1th query, we remove `3th` element, the state before it: `_, 2, 5, 6, 1` (add node `3th` to our UnionFind, merge node `3th` with node `2th` and node `3th` with node `4th`)\\n- 0th query, we remove `0th` element, the state before it: `1, 2, 5, 6, 1` (add node `0th` to our UnionFind, merge node `0th` with node `1th`)\\n\\n\\n```python\\nclass UnionFind:\\n    def __init__(self):\\n        self.parent = {}\\n        self.sum = {}\\n        self.maxSumSegment = 0\\n        \\n    def addAndMergeAdjSegment(self, u, value):\\n        self.parent[u] = u\\n        self.sum[u] = value\\n        self.maxSumSegment = max(self.maxSumSegment, value)\\n        if u-1 in self.parent:\\n            self.union(u, u-1)\\n        if u+1 in self.parent:\\n            self.union(u, u+1)\\n        \\n    def find(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u] = self.find(self.parent[u])  # Path compression\\n        return self.parent[u]\\n    \\n    def union(self, u, v):\\n        pu = self.find(u)\\n        pv = self.find(v)\\n        if pu == pv: return\\n        self.sum[pu] += self.sum[pv]\\n        self.parent[pv] = pu\\n        self.maxSumSegment = max(self.maxSumSegment, self.sum[pu])\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        uf = UnionFind()\\n        \\n        ans = [0] * n\\n        for i in range(n-1, -1, -1):\\n            ans[i] = uf.maxSumSegment\\n            q = removeQueries[i]\\n            uf.addAndMergeAdjSegment(q, nums[q])\\n        return ans\\n```\\nComplexity:\\n- Time: `O(NlogN)`, where `N` is length of `nums` array\\n\\t- Each operation `union`, `find` cost `O(logN)` since we do path compression only.\\n- Space: `O(N)`",
                "solutionTags": [],
                "code": "```\\nnums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]\\n```\n```python\\nclass UnionFind:\\n    def __init__(self):\\n        self.parent = {}\\n        self.sum = {}\\n        self.maxSumSegment = 0\\n        \\n    def addAndMergeAdjSegment(self, u, value):\\n        self.parent[u] = u\\n        self.sum[u] = value\\n        self.maxSumSegment = max(self.maxSumSegment, value)\\n        if u-1 in self.parent:\\n            self.union(u, u-1)\\n        if u+1 in self.parent:\\n            self.union(u, u+1)\\n        \\n    def find(self, u):\\n        if u != self.parent[u]:\\n            self.parent[u] = self.find(self.parent[u])  # Path compression\\n        return self.parent[u]\\n    \\n    def union(self, u, v):\\n        pu = self.find(u)\\n        pv = self.find(v)\\n        if pu == pv: return\\n        self.sum[pu] += self.sum[pv]\\n        self.parent[pv] = pu\\n        self.maxSumSegment = max(self.maxSumSegment, self.sum[pu])\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        uf = UnionFind()\\n        \\n        ans = [0] * n\\n        for i in range(n-1, -1, -1):\\n            ans[i] = uf.maxSumSegment\\n            q = removeQueries[i]\\n            uf.addAndMergeAdjSegment(q, nums[q])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454227,
                "title": "java-no-need-of-segment-tree-set-priority-queue",
                "content": "**APPROACH is little bit tricky try to dry run this code , you will get the idea behind it**\\n\\nfirst i used the ,priority Queue that will store the interval data\\ni.e., start index, end index, and sum of interval \\nand sort them on the base of decreasing sum,\\n\\nTreeSet, that will store the partitions , means queries value\\n\\nThen i do prefic evaluation, means \\nsuppose query type is 1, \\nthen i do arr[st]++ and arr[en+1]--;\\nwhere st and en is the starting and ending index of query \\n\\n**IMPORTANT PART BEGIN FROM HERE** \\n\\nfor every query i will , check the upper bound and lower bound ,\\nand add in my prioriy queue to 2 range\\n1st lowerbound to current query value\\n2nd current query value to upperbound \\nsame like the i split the query\\n\\nthen i run the while loop until i get the valid range(partition)\\nmeans range ,in which there is no parition between them\\n\\n```\\npublic long[] maximumSegmentSum(int[] nums, int[] quer) {       \\n        int n=nums.length;\\n        PriorityQueue<long []> pq=new PriorityQueue<>((long a[],long b[])->(a[2]<=b[2])?1:-1);  \\n        TreeSet<Integer> set=new TreeSet<>();\\n        long arr[]=new long[n],ans[]=new long[n];\\n        set.add(-1);\\n        set.add(n);\\n        for(int i=0;i<n;i++){\\n            arr[i]=nums[i];\\n            if(i!=0) arr[i]+=arr[i-1];\\n        }\\n        pq.add(new long[]{0,n-1,arr[n-1]});\\n        for(int i=0;i<n;i++){\\n            int num=quer[i];\\n            set.add(quer[i]);\\n            int a=set.lower(num), b=set.higher(num);\\n            if((a+1)<num){\\n                pq.add(new long[]{(long)a+1,(long)num-1,arr[num-1]-(long)((a==-1)?0:arr[a])});\\n            }\\n            if((num+1)<b){\\n                pq.add(new long[]{(long)num+1,(long)b-1,arr[b-1]-arr[num]});\\n            } \\n            while(!pq.isEmpty()){\\n                long ab[]=pq.peek();\\n                int s=(int) ab[0],e=(int) ab[1];\\n\\n                if(set.higher(s-1)>e){\\n                    ans[i]=pq.peek()[2];\\n                    break;\\n                }\\n                else pq.remove();\\n            }\\n        }\\n        return ans;\\n    }\\n```\\n\\t\\n**Please Upvote The Post\\nHappy Coding :)**",
                "solutionTags": [],
                "code": "```\\npublic long[] maximumSegmentSum(int[] nums, int[] quer) {       \\n        int n=nums.length;\\n        PriorityQueue<long []> pq=new PriorityQueue<>((long a[],long b[])->(a[2]<=b[2])?1:-1);  \\n        TreeSet<Integer> set=new TreeSet<>();\\n        long arr[]=new long[n],ans[]=new long[n];\\n        set.add(-1);\\n        set.add(n);\\n        for(int i=0;i<n;i++){\\n            arr[i]=nums[i];\\n            if(i!=0) arr[i]+=arr[i-1];\\n        }\\n        pq.add(new long[]{0,n-1,arr[n-1]});\\n        for(int i=0;i<n;i++){\\n            int num=quer[i];\\n            set.add(quer[i]);\\n            int a=set.lower(num), b=set.higher(num);\\n            if((a+1)<num){\\n                pq.add(new long[]{(long)a+1,(long)num-1,arr[num-1]-(long)((a==-1)?0:arr[a])});\\n            }\\n            if((num+1)<b){\\n                pq.add(new long[]{(long)num+1,(long)b-1,arr[b-1]-arr[num]});\\n            } \\n            while(!pq.isEmpty()){\\n                long ab[]=pq.peek();\\n                int s=(int) ab[0],e=(int) ab[1];\\n\\n                if(set.higher(s-1)>e){\\n                    ans[i]=pq.peek()[2];\\n                    break;\\n                }\\n                else pq.remove();\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454165,
                "title": "c-prefix-sum-multiset-nlogn",
                "content": "Steps for each Query:\\n\\n1. For current index (cur), find left removed index (L) and right removed index (R)\\n2. Delete current segment sum,   pre[R-1] - pre[L]\\n3. Insert left segment sum,   pre[cur-1] - pre[L]\\n4. Insert right segment sum,  pre[R-1] - pre[cur]\\n5. Take the maximum from all sums\\n\\n```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& remove) {\\n        int n = nums.size();\\n        vector<ll> pre(n,0);\\n\\n        pre[0] = nums[0];\\n        for(int i = 1; i < n; i++){\\n            pre[i] += pre[i-1] + nums[i];        // create prefix sum\\n        }\\n\\n        set<int> ind;         // ind will store removed index\\n        ind.insert(-1);\\n        ind.insert(n);\\n\\n        vector<ll> ans(n,0);\\n        multiset<ll> mp;     // mp will store sum of all segments \\n        mp.insert(pre[n-1]);\\n\\n        for(int i = 0; i < n; i++){\\n\\t\\t\\tint cur = remove[i];\\n\\n            auto it = ind.lower_bound(cur);\\n            int r = *it;                         // right removed index\\n            int l = *(prev(it));                 // left removed index\\n            \\n            ll cur_sum = pre[r-1] - ( l == -1 ? 0 : pre[l] );\\n            mp.erase(mp.find(cur_sum));                 // remove current segment sum\\n\\n            ll left_sum = ( cur == 0 ? 0 : pre[cur-1] ) - (l == -1? 0 : pre[l] );\\n            ll right_sum = (r == 0 ? 0 : pre[r-1]) - pre[cur];\\n\\n            mp.insert(left_sum);                // insert left segment sum\\n            mp.insert(right_sum);               // insert right segment sum\\n\\n            ind.insert(cur);\\n            ans[i] = *(mp.rbegin());           // take the maximum\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    #define ll long long\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& remove) {\\n        int n = nums.size();\\n        vector<ll> pre(n,0);\\n\\n        pre[0] = nums[0];\\n        for(int i = 1; i < n; i++){\\n            pre[i] += pre[i-1] + nums[i];        // create prefix sum\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2454787,
                "title": "python-maintaining-segments-with-sortedlist",
                "content": "We will maintain our segments and their sums using `SortedList` library. \\n\\nAdding a segment and removing a segment are cleanly implemented in `add, remove` functions. Thus we just need to go through each query, remove segment containing `removeQueries[i]` index, and then add two new created segments back. \\n\\n```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        n, ps, ans = len(nums), [0], []\\n        segments, sums = SortedList(), SortedList([0])\\n\\n        # compute prefix sums\\n        for k in nums:\\n            ps.append(ps[-1] + k)\\n\\n        # adding a segment with (left, right) borders and its sum\\n        def add(l, r):\\n            if l > r: return\\n            segments.add((l, r))\\n            sums.add(ps[r + 1] - ps[l])\\n\\n        # removing a segment\\n        def remove(l, r):\\n            segments.remove((l, r))\\n            sums.remove(ps[r + 1] - ps[l])\\n\\n        # initial segment with borders (0, n - 1)\\n        add(0, n - 1)\\n\\n        for i in removeQueries:\\n            # get index of an interval containing `i`\\n            ind = segments.bisect_left((i + 1, -1)) - 1\\n            left, right = segments[ind]\\n\\n            # remove, then add two new segments\\n            remove(left, right)\\n            add(left, i - 1)\\n            add(i + 1, right)\\n\\n            ans.append(sums[-1])\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nfrom sortedcontainers import SortedList\\n\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        n, ps, ans = len(nums), [0], []\\n        segments, sums = SortedList(), SortedList([0])\\n\\n        # compute prefix sums\\n        for k in nums:\\n            ps.append(ps[-1] + k)\\n\\n        # adding a segment with (left, right) borders and its sum\\n        def add(l, r):\\n            if l > r: return\\n            segments.add((l, r))\\n            sums.add(ps[r + 1] - ps[l])\\n\\n        # removing a segment\\n        def remove(l, r):\\n            segments.remove((l, r))\\n            sums.remove(ps[r + 1] - ps[l])\\n\\n        # initial segment with borders (0, n - 1)\\n        add(0, n - 1)\\n\\n        for i in removeQueries:\\n            # get index of an interval containing `i`\\n            ind = segments.bisect_left((i + 1, -1)) - 1\\n            left, right = segments[ind]\\n\\n            # remove, then add two new segments\\n            remove(left, right)\\n            add(left, i - 1)\\n            add(i + 1, right)\\n\\n            ans.append(sums[-1])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454166,
                "title": "c-explained-solution-using-set-and-multiset-time-o-nlogn-space-o-n",
                "content": "**Approach -**\\n\\nStep 1 - Make a prefix sum array for getting the sum in O(1) (Constant time)\\nStep 2 - Declare a set of pair for storing all segments and a multiset for storing the sum of all segments\\nStep 3 - Insert starting segment i.e. {0,n-1} and starting sum i.e. sum of all elements in set and multiset respectively\\nStep 4 - traverse removeQueries array from 0 to n-2 ( last maximum sum is always 0 so no need to traverse till n-1)\\n\\ti)  Find that segment in a set of segments in which removeQueries[i] present.\\n\\tii) Remove that segment and sum elements of that segment\\n\\tiii) Insert a new segment in the set which is come after breaking the previous segment\\n\\tiv) Find the sum of new segments and add them to multiset\\n\\tv) Find max sum in multiset and store in the answer\\n\\nQ - > Why we used multiset?\\n\\nAns -> Let\\'s understand using one example \\n\\n**One Example -** \\n\\nArr - [1,2,3,4,5] , Remove - [3,0,4,2,1]\\n\\nprefixSum ->  [1,3,6,10,15]\\nSet - > {{0,4}}\\nMultiset -> {15}\\n\\nFor -> Remove[0]\\nSet -> {{0,2},{4,4}}\\nMultiset -> {5,6}\\nAns -> {6}\\n\\nFor -> Remove[1]\\nSet -> {{1,2},{4,4}}\\nMultiset -> {5,5}       -> **Here, if we use a set then we can not store multiple value of the same type**\\nAns -> {6,5}\\n\\nFor -> Remove[2]\\nSet -> {{1,2}}\\nMultiset -> {5}\\nAns -> {6,5,5}\\n\\nFor -> Remove[3]\\nSet -> {{1,1}}\\nMultiset -> {2}\\nAns -> {6,5,5,2}\\n\\nFor -> Remove[4]\\nSet -> {}\\nMultiset -> {}\\nAns -> {6,5,5,2,0}\\n\\n**Output -> {6,5,5,2,0}**\\n\\n\\n**Code**\\n\\n```\\n#define ll long long\\n\\nclass Solution {\\n    \\n    ll find_sum(int start,int end,vector<ll> &sum)\\n    {\\n        if(start==0)\\n            return sum[end];\\n        return sum[end]-sum[start-1];\\n    }\\n    \\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& a, vector<int>& t) {\\n        \\n        int n = a.size();\\n        ll br,val1,val2,val,res;\\n        \\n        set<pair<int,int>> seg ;\\n        multiset<ll> value;\\n        pair<int,int> p;\\n        \\n        vector<ll> prefixSum(n),ans;\\n        prefixSum[0] = a[0];\\n        for(int i=1;i<n;i++)\\n            prefixSum[i] = a[i]+prefixSum[i-1];\\n       \\n        seg.insert({0,n-1});\\n        value.insert(prefixSum[n-1]);\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            val1=-1,val2=-1;\\n            br = t[i];\\n            auto it = seg.lower_bound({br,br});\\n            if(it==seg.end()) it--;\\n            if(it->first>br) it--;\\n            p = *it;\\n            val = find_sum(p.first,p.second,prefixSum);\\n            seg.erase(it);\\n            auto ik = value.lower_bound(val);\\n            value.erase(ik);\\n            if(p.first==br){\\n                seg.insert({br+1,p.second});\\n                val1 = find_sum(br+1,p.second,prefixSum);\\n            }\\n            else if(p.second==br){\\n                seg.insert({p.first,br-1});\\n                val2 = find_sum(p.first,br-1,prefixSum);\\n            }\\n            else{\\n                seg.insert({p.first,br-1});\\n                seg.insert({br+1,p.second});\\n                val1 = find_sum(p.first,br-1,prefixSum);\\n                val2 = find_sum(br+1,p.second,prefixSum);\\n            }\\n            if(val1!=-1) value.insert(val1);\\n            if(val2!=-1) value.insert(val2);\\n            auto last = value.end();\\n            last--;\\n            res = *last;\\n            ans.push_back(res);\\n        }\\n        \\n        ans.push_back(0);\\n        return ans;\\n        \\n    }\\n};\\n```\\n\\n\\n**Time Complexity - O(NlogN) \\nSpace Complexity - O(N)**\\nN is length of given array\\n\\n**Upvote if you like it!**\\n",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\n\\nclass Solution {\\n    \\n    ll find_sum(int start,int end,vector<ll> &sum)\\n    {\\n        if(start==0)\\n            return sum[end];\\n        return sum[end]-sum[start-1];\\n    }\\n    \\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& a, vector<int>& t) {\\n        \\n        int n = a.size();\\n        ll br,val1,val2,val,res;\\n        \\n        set<pair<int,int>> seg ;\\n        multiset<ll> value;\\n        pair<int,int> p;\\n        \\n        vector<ll> prefixSum(n),ans;\\n        prefixSum[0] = a[0];\\n        for(int i=1;i<n;i++)\\n            prefixSum[i] = a[i]+prefixSum[i-1];\\n       \\n        seg.insert({0,n-1});\\n        value.insert(prefixSum[n-1]);\\n        \\n        for(int i=0;i<n-1;i++)\\n        {\\n            val1=-1,val2=-1;\\n            br = t[i];\\n            auto it = seg.lower_bound({br,br});\\n            if(it==seg.end()) it--;\\n            if(it->first>br) it--;\\n            p = *it;\\n            val = find_sum(p.first,p.second,prefixSum);\\n            seg.erase(it);\\n            auto ik = value.lower_bound(val);\\n            value.erase(ik);\\n            if(p.first==br){\\n                seg.insert({br+1,p.second});\\n                val1 = find_sum(br+1,p.second,prefixSum);\\n            }\\n            else if(p.second==br){\\n                seg.insert({p.first,br-1});\\n                val2 = find_sum(p.first,br-1,prefixSum);\\n            }\\n            else{\\n                seg.insert({p.first,br-1});\\n                seg.insert({br+1,p.second});\\n                val1 = find_sum(p.first,br-1,prefixSum);\\n                val2 = find_sum(br+1,p.second,prefixSum);\\n            }\\n            if(val1!=-1) value.insert(val1);\\n            if(val2!=-1) value.insert(val2);\\n            auto last = value.end();\\n            last--;\\n            res = *last;\\n            ans.push_back(res);\\n        }\\n        \\n        ans.push_back(0);\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454472,
                "title": "treemap-o-nlogn-java",
                "content": "* Get range in which current index to be remove is lying.\\n* Remove that range from map and that range\\'s sum from sums map.\\n* Split that range into two halves, leftRange and rightRange respectively.\\n* If leftRange and rightRange is valid to be put on map then calculate sum from prefix computation and put both in range map and sum in sums map.\\n```\\nclass Solution {\\n\\n    public long[] maximumSegmentSum(int[] nums, int[] q) {\\n        long[] ans = new long[q.length];\\n        TreeMap<Long, long[]> map = new TreeMap<>(); // rangeStart,[rangeEnd,rangeSum]\\n        long pref[] = new long[nums.length];\\n        pref[0] = (long) nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            pref[i] = pref[i - 1];\\n            pref[i] += (long) nums[i];\\n        }\\n        TreeMap<Long, Integer> sums = new TreeMap<>();\\n        sums.put(pref[nums.length - 1], 1);\\n        map.put(0l, new long[] { nums.length - 1, pref[nums.length - 1] });\\n        for (int i = 0; i < q.length; i++) {\\n            Long x = map.floorKey((long) q[i]);\\n            if (x == null) {\\n                if (!sums.isEmpty()) ans[i] = sums.lastKey();\\n                continue;\\n            }\\n            long range[] = { x, map.get(x)[0] };\\n            sums.put(map.get(x)[1], sums.get(map.get(x)[1]) - 1);\\n            if (sums.get(map.get(x)[1]) == 0) sums.remove(map.get(x)[1]);\\n            map.remove(x);\\n\\n            long leftSum = -1, rightSum = -1;\\n            long leftRange[] = { range[0], q[i] - 1 };\\n            long rightRange[] = { q[i] + 1, range[1] };\\n\\n            if (leftRange[0] >= 0 && leftRange[1] >= 0 && (leftRange[1] - leftRange[0] + 1) >= 1) {\\n                leftSum = pref[(int) leftRange[1]] - (leftRange[0] - 1 >= 0 ? pref[(int) (leftRange[0] - 1)] : 0);\\n                sums.put(leftSum, sums.getOrDefault(leftSum, 0) + 1);\\n                map.put(leftRange[0], new long[] { leftRange[1], leftSum });\\n            }\\n            if (rightRange[0] >= 0 && rightRange[1] >= 0 && (rightRange[1] - rightRange[0] + 1) >= 1) {\\n                rightSum = pref[(int) rightRange[1]] - (rightRange[0] - 1 >= 0 ? pref[(int) (rightRange[0] - 1)] : 0);\\n                sums.put(rightSum, sums.getOrDefault(rightSum, 0) + 1);\\n                map.put(rightRange[0], new long[] { rightRange[1], rightSum });\\n            }\\n            if (!sums.isEmpty()) ans[i] = sums.lastKey();\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n\\n    public long[] maximumSegmentSum(int[] nums, int[] q) {\\n        long[] ans = new long[q.length];\\n        TreeMap<Long, long[]> map = new TreeMap<>(); // rangeStart,[rangeEnd,rangeSum]\\n        long pref[] = new long[nums.length];\\n        pref[0] = (long) nums[0];\\n        for (int i = 1; i < nums.length; i++) {\\n            pref[i] = pref[i - 1];\\n            pref[i] += (long) nums[i];\\n        }\\n        TreeMap<Long, Integer> sums = new TreeMap<>();\\n        sums.put(pref[nums.length - 1], 1);\\n        map.put(0l, new long[] { nums.length - 1, pref[nums.length - 1] });\\n        for (int i = 0; i < q.length; i++) {\\n            Long x = map.floorKey((long) q[i]);\\n            if (x == null) {\\n                if (!sums.isEmpty()) ans[i] = sums.lastKey();\\n                continue;\\n            }\\n            long range[] = { x, map.get(x)[0] };\\n            sums.put(map.get(x)[1], sums.get(map.get(x)[1]) - 1);\\n            if (sums.get(map.get(x)[1]) == 0) sums.remove(map.get(x)[1]);\\n            map.remove(x);\\n\\n            long leftSum = -1, rightSum = -1;\\n            long leftRange[] = { range[0], q[i] - 1 };\\n            long rightRange[] = { q[i] + 1, range[1] };\\n\\n            if (leftRange[0] >= 0 && leftRange[1] >= 0 && (leftRange[1] - leftRange[0] + 1) >= 1) {\\n                leftSum = pref[(int) leftRange[1]] - (leftRange[0] - 1 >= 0 ? pref[(int) (leftRange[0] - 1)] : 0);\\n                sums.put(leftSum, sums.getOrDefault(leftSum, 0) + 1);\\n                map.put(leftRange[0], new long[] { leftRange[1], leftSum });\\n            }\\n            if (rightRange[0] >= 0 && rightRange[1] >= 0 && (rightRange[1] - rightRange[0] + 1) >= 1) {\\n                rightSum = pref[(int) rightRange[1]] - (rightRange[0] - 1 >= 0 ? pref[(int) (rightRange[0] - 1)] : 0);\\n                sums.put(rightSum, sums.getOrDefault(rightSum, 0) + 1);\\n                map.put(rightRange[0], new long[] { rightRange[1], rightSum });\\n            }\\n            if (!sums.isEmpty()) ans[i] = sums.lastKey();\\n        }\\n        return ans;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454234,
                "title": "python3-priority-queue",
                "content": "Please pull this git [commit](https://github.com/gaosanyong/leetcode/commit/e999ea07dc2ea2e8b7aad97696f67a3b965e496d) for solutions of biweekly 85. \\n\\n**Intuition**\\nHere, I use \\n1) a ordered set to store the points where `nums` are divided; \\n2) a hash table mapping from left boundary to right boundary to validate if a triplet is still effective;\\n3) a priority queue to the triplet of <range sum, left boundary, right boundary>.\\n\\nAt each query, I add the point to the set of dividers, adjust the mapping of its left and right boundary points, and add the new two pieces to the priority queue. While finding current maximum from the priority queue, I first validate if the triplet is still in effect by checking if the left boundary matches the right boundary in the hash table. If not, I discard the top element until a valid triplet. \\n\\n**Analysis**\\nTime complexity `O(NlogN)`\\nSpace complexity `O(N)`\\n```\\nclass Solution: \\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        sl = SortedList([-1, n])\\n        prefix = list(accumulate(nums, initial=0))\\n        mp = {-1 : n}\\n        pq = [(-prefix[-1], -1, n)]\\n        \\n        ans = []\\n        for q in removeQueries: \\n            sl.add(q)\\n            i = sl.bisect_left(q)\\n            lo = sl[i-1]\\n            hi = sl[i+1]\\n            mp[lo] = q\\n            mp[q] = hi \\n            heappush(pq, (-(prefix[q]-prefix[lo+1]), lo, q))\\n            heappush(pq, (-(prefix[hi]-prefix[q+1]), q, hi))\\n            \\n            while mp[pq[0][1]] != pq[0][2]: heappop(pq)\\n            ans.append(-pq[0][0])\\n        return ans \\n```\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution: \\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        sl = SortedList([-1, n])\\n        prefix = list(accumulate(nums, initial=0))\\n        mp = {-1 : n}\\n        pq = [(-prefix[-1], -1, n)]\\n        \\n        ans = []\\n        for q in removeQueries: \\n            sl.add(q)\\n            i = sl.bisect_left(q)\\n            lo = sl[i-1]\\n            hi = sl[i+1]\\n            mp[lo] = q\\n            mp[q] = hi \\n            heappush(pq, (-(prefix[q]-prefix[lo+1]), lo, q))\\n            heappush(pq, (-(prefix[hi]-prefix[q+1]), q, hi))\\n            \\n            while mp[pq[0][1]] != pq[0][2]: heappop(pq)\\n            ans.append(-pq[0][0])\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3066942,
                "title": "java-6ms-o-n-time-space-arrays-only",
                "content": "# Intuition \\n<!-- Describe your first thoughts on how to solve this problem. --> Instead of removing elements one by one from the complete set, iterate backwards through removeQueries and start building the segments element by element. \\n \\n# Approach \\nFor each element that is either the start or end of a segment, record two things:\\n - The other end of the segment ```other[]```\\n - The sum of the segment ```sums[]```\\n\\nWhenever a new element is added, it will create a new segment:\\n- If the recorded sum of the element on the left is nonzero, the left end of our new segment will be ```other[left]```\\n- Otherwise, the left end will be the added element\\n- Use the same method to find the right end of the new segment\\n- The sum of the new segment will be ```sums[left] + sums[right] + (the value of the added element)```\\n- Compare that sum with a running max to keep track of the sum of the largest segment\\n\\n# Complexity \\n- Time complexity: $$O(n)$$  \\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        long[] sums = new long[nums.length+2];\\n        int[] other = new int[nums.length+2];\\n\\n        long max = 0;\\n        long[] ans = new long[removeQueries.length];\\n        for (int i = removeQueries.length-1; i > -1; --i) {\\n            int now = removeQueries[i];\\n            int left = sums[now] == 0 ? now+1 : other[now];\\n            int right = sums[now+2] == 0 ? now+1 : other[now+2];\\n            other[left] = right;\\n            other[right] = left;\\n\\n            long sum = sums[left]+sums[right]+nums[now];\\n            sums[left] = sums[right] = sum;\\n\\n            ans[i] = max;\\n            max = Math.max(max, sum);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```other[]```\n```sums[]```\n```other[left]```\n```sums[left] + sums[right] + (the value of the added element)```\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        long[] sums = new long[nums.length+2];\\n        int[] other = new int[nums.length+2];\\n\\n        long max = 0;\\n        long[] ans = new long[removeQueries.length];\\n        for (int i = removeQueries.length-1; i > -1; --i) {\\n            int now = removeQueries[i];\\n            int left = sums[now] == 0 ? now+1 : other[now];\\n            int right = sums[now+2] == 0 ? now+1 : other[now+2];\\n            other[left] = right;\\n            other[right] = left;\\n\\n            long sum = sums[left]+sums[right]+nums[now];\\n            sums[left] = sums[right] = sum;\\n\\n            ans[i] = max;\\n            max = Math.max(max, sum);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455461,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int n;\\n    long long max_val=0;\\n    vector<long long>parent,sum;\\n    int find(int x)\\n    {\\n        if(x==parent[x])\\n        {\\n            return x;\\n        }\\n        return parent[x]=find(parent[x]);\\n    }\\n    void merge(int x,int y)\\n    {\\n        x=find(x);\\n        y=find(y);\\n        if(x==y)\\n        {\\n            return ;\\n        }\\n        sum[x]+=sum[y];\\n        max_val=max(max_val,sum[x]);\\n        parent[y]=x;\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& r)\\n    {\\n        n=nums.size();\\n        parent.resize(n+10);\\n        sum.resize(n+10);\\n        for(int i=0;i<n;i++)\\n        {\\n            sum[i]=nums[i];\\n            parent[i]=i;\\n        }\\n        vector<int>vis(n+1,0);\\n        vector<long long>ans(n,0);\\n         max_val=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            ans[i]=max_val;\\n            int index=r[i];\\n            vis[index]=1;\\n            max_val=max(max_val,1ll*nums[index]);\\n            if(index+1<n&&vis[index+1])\\n            {\\n                merge(index,index+1);\\n            }\\n            if(index-1>=0&&vis[index-1])\\n            {\\n                merge(index,index-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    long long max_val=0;\\n    vector<long long>parent,sum;\\n    int find(int x)\\n    {\\n        if(x==parent[x])\\n        {\\n            return x;\\n        }\\n        return parent[x]=find(parent[x]);\\n    }\\n    void merge(int x,int y)\\n    {\\n        x=find(x);\\n        y=find(y);\\n        if(x==y)\\n        {\\n            return ;\\n        }\\n        sum[x]+=sum[y];\\n        max_val=max(max_val,sum[x]);\\n        parent[y]=x;\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& r)\\n    {\\n        n=nums.size();\\n        parent.resize(n+10);\\n        sum.resize(n+10);\\n        for(int i=0;i<n;i++)\\n        {\\n            sum[i]=nums[i];\\n            parent[i]=i;\\n        }\\n        vector<int>vis(n+1,0);\\n        vector<long long>ans(n,0);\\n         max_val=0;\\n        for(int i=n-1;i>=0;i--)\\n        {\\n            ans[i]=max_val;\\n            int index=r[i];\\n            vis[index]=1;\\n            max_val=max(max_val,1ll*nums[index]);\\n            if(index+1<n&&vis[index+1])\\n            {\\n                merge(index,index+1);\\n            }\\n            if(index-1>=0&&vis[index-1])\\n            {\\n                merge(index,index-1);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454219,
                "title": "c-o-nlogn-solution-with-explanation-illustration-using-set",
                "content": "We use an `O(logN)` container (segmentSums) to store the sums of the current segments in the array.\\nAfter every time we remove an index, we remove the sum of the old segment and insert the\\nsums of the two new ones.\\n\\nWe also keep track of all the removed indices in another `O(logN)` container (removedIndices) that\\nwill allow us to get the bounds of a segment in `O(logN)`.\\n\\nThe algorithm goes like this:\\n- find which segment this removeQueries[i] belongs to.\\n- remove the sum of elements of this segment from the segmentSums container.\\n- add the 2 sums of the 2 new segments to the container.\\n- the answer at this index will be the biggest sum in the segmentSums container.\\n- add the removed index to the removedIndices container.\\n\\n\\n#### Example:\\n```\\n[1,2,5,6,1] [0,3,2,4,1]\\nWe start with the containers like this:\\n    segmentSums     removedIndices        segments\\n      [  15  ]        [ -1   5 ]         1-2-5-6-1\\n\\n1) remove the item at index 0\\n    segmentSums     removedIndices        segments\\n      [  14  ]        [ -1 0 5 ]           2-5-6-1\\n\\n2) remove the item at index 3\\n    segmentSums     removedIndices        segments\\n      [  7  ]        [ -1 0 3 5 ]          2-5   1\\n      [  1  ]\\n\\n3) remove the item at index 2\\n    segmentSums     removedIndices        segments\\n      [  2  ]       [ -1 0 2 3 5 ]         2     1\\n      [  1  ]\\n\\n4) remove the item at index 4\\n    segmentSums     removedIndices        segments\\n      [  2  ]       [ -1 0 2 3 4 5 ]       2\\n      [  1  ]\\n\\n5) remove the item at index 1\\n    segmentSums     removedIndices        segments\\n      [     ]      [ -1 0 1 2 3 4 5 ]\\n```\\nThe answer becomes the top elements at each step which is [15, 14, 7, 2, 2, 0]\\n\\n\\n### Complexity\\nTime: `O(logN)`\\nSpace: `O(N)`\\n\\n\\n#### C++ Code\\n\\n```c++\\nclass Solution {\\n public:\\n  vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n    int n = nums.size();\\n    // Use a multiset to store all the sums of the segments after each operation\\n    // The multiset will have the biggest sum at the begin iterator\\n    std::multiset<long long, std::greater<long long>> segmentSums;\\n\\n    // store all the removed indices in this set.\\n    // It will help use find which segment a point belongs to\\n    set<int> removedIndices{-1, n};\\n\\n    // calculate the prefix sum for the array\\n    vector<long long> res(n), prefix(n);\\n    prefix[0] = nums[0];\\n    for (int i = 1; i < n; i++) prefix[i] = prefix[i - 1] + nums[i];\\n\\n    // start the segmentsSum with the sum of all elements in the array\\n    segmentSums.insert(prefix.back());\\n\\n    for (int i = 0; i < n; i++) {\\n      // get the bounds of the segment that this item belongs to\\n      auto after = removedIndices.lower_bound(removeQueries[i]);\\n      auto before = prev(after);\\n\\n      // get the sum of the old segment and remove it from the multiset\\n      auto sum = prefix[*after - 1] - (*before < 0 ? 0 : prefix[*before]);\\n      segmentSums.erase(segmentSums.find(sum));\\n\\n      // insert the sums of the 2 broken segments in the multiset\\n      segmentSums.insert(prefix[*after - 1] - prefix[removeQueries[i]]);\\n      if (removeQueries[i] - 1 >= 0)\\n        segmentSums.insert(prefix[removeQueries[i] - 1] - (*before < 0 ? 0 : prefix[*before]));\\n\\n      // added the current removed query index to the set of removed indices\\n      removedIndices.insert(removeQueries[i]);\\n\\n      // update the result with the biggest value in the segmentSums\\n      res[i] = *segmentSums.begin();\\n    }\\n\\n    return res;\\n  }\\n};\\n```\\n\\n**Upvote if you find it helpful :)**",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n[1,2,5,6,1] [0,3,2,4,1]\\nWe start with the containers like this:\\n    segmentSums     removedIndices        segments\\n      [  15  ]        [ -1   5 ]         1-2-5-6-1\\n\\n1) remove the item at index 0\\n    segmentSums     removedIndices        segments\\n      [  14  ]        [ -1 0 5 ]           2-5-6-1\\n\\n2) remove the item at index 3\\n    segmentSums     removedIndices        segments\\n      [  7  ]        [ -1 0 3 5 ]          2-5   1\\n      [  1  ]\\n\\n3) remove the item at index 2\\n    segmentSums     removedIndices        segments\\n      [  2  ]       [ -1 0 2 3 5 ]         2     1\\n      [  1  ]\\n\\n4) remove the item at index 4\\n    segmentSums     removedIndices        segments\\n      [  2  ]       [ -1 0 2 3 4 5 ]       2\\n      [  1  ]\\n\\n5) remove the item at index 1\\n    segmentSums     removedIndices        segments\\n      [     ]      [ -1 0 1 2 3 4 5 ]\\n```\n```c++\\nclass Solution {\\n public:\\n  vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n    int n = nums.size();\\n    // Use a multiset to store all the sums of the segments after each operation\\n    // The multiset will have the biggest sum at the begin iterator\\n    std::multiset<long long, std::greater<long long>> segmentSums;\\n\\n    // store all the removed indices in this set.\\n    // It will help use find which segment a point belongs to\\n    set<int> removedIndices{-1, n};\\n\\n    // calculate the prefix sum for the array\\n    vector<long long> res(n), prefix(n);\\n    prefix[0] = nums[0];\\n    for (int i = 1; i < n; i++) prefix[i] = prefix[i - 1] + nums[i];\\n\\n    // start the segmentsSum with the sum of all elements in the array\\n    segmentSums.insert(prefix.back());\\n\\n    for (int i = 0; i < n; i++) {\\n      // get the bounds of the segment that this item belongs to\\n      auto after = removedIndices.lower_bound(removeQueries[i]);\\n      auto before = prev(after);\\n\\n      // get the sum of the old segment and remove it from the multiset\\n      auto sum = prefix[*after - 1] - (*before < 0 ? 0 : prefix[*before]);\\n      segmentSums.erase(segmentSums.find(sum));\\n\\n      // insert the sums of the 2 broken segments in the multiset\\n      segmentSums.insert(prefix[*after - 1] - prefix[removeQueries[i]]);\\n      if (removeQueries[i] - 1 >= 0)\\n        segmentSums.insert(prefix[removeQueries[i] - 1] - (*before < 0 ? 0 : prefix[*before]));\\n\\n      // added the current removed query index to the set of removed indices\\n      removedIndices.insert(removeQueries[i]);\\n\\n      // update the result with the biggest value in the segmentSums\\n      res[i] = *segmentSums.begin();\\n    }\\n\\n    return res;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454218,
                "title": "dsu",
                "content": "```\\n#define ll long long\\nstruct DSU {\\n    vector<ll> par, lev, sum;\\n    \\n    //sum -> to store the sum of a segment\\n    //currently every index represent a segment\\n    \\n    DSU(int n, vector<int> &ar) {\\n        par.resize(n, 0);\\n        lev.resize(n, 1);\\n        sum.resize(n);\\n        for(int i = 0; i < n; ++i) sum[i] = ar[i];\\n        iota(par.begin(), par.end(), 0);\\n    }\\n    \\n    int fset(int v) {\\n        return v == par[v] ? v : par[v] = fset(par[v]);\\n    }\\n    \\n    void uset(int u, int v) {\\n        u = fset(u), v = fset(v);\\n        if(u != v) {\\n            if(lev[u] < lev[v]) swap(u, v);\\n            par[v] = u;\\n            sum[u] += sum[v]; // if two segments are merged the sum increases\\n        }\\n    }\\n    \\n    ll getSum(int v) {\\n        return sum[fset(v)]; // the total sum of the segment would be stored in the parent node\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& v) {\\n        int n = nums.size();\\n        DSU dsu(n, nums);\\n        \\n        vector<ll> res(n, 0), cur(n, 0);\\n        ll mx = 0;\\n        \\n        //work your way towards the back\\n        for(int i = v.size() - 1; ~i; --i) {\\n            res[i] = mx; // place the current maximum\\n            \\n            cur[v[i]] = nums[v[i]]; //place the value\\n            \\n            if(v[i] + 1 < n and cur[v[i] + 1] != 0) dsu.uset(v[i], v[i] + 1); \\n            // if the value at right index is not zero so the current index can be merged with the right segment\\n            \\n            if(v[i] - 1 >= 0 and cur[v[i] - 1] != 0) dsu.uset(v[i], v[i] - 1);\\n            // if the value at left index is not zero so the current index can be merged with the left segment\\n            \\n            mx = max(mx, dsu.getSum(v[i])); //after merging get the sum of the current segment formed placing the v[i]th element\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nstruct DSU {\\n    vector<ll> par, lev, sum;\\n    \\n    //sum -> to store the sum of a segment\\n    //currently every index represent a segment\\n    \\n    DSU(int n, vector<int> &ar) {\\n        par.resize(n, 0);\\n        lev.resize(n, 1);\\n        sum.resize(n);\\n        for(int i = 0; i < n; ++i) sum[i] = ar[i];\\n        iota(par.begin(), par.end(), 0);\\n    }\\n    \\n    int fset(int v) {\\n        return v == par[v] ? v : par[v] = fset(par[v]);\\n    }\\n    \\n    void uset(int u, int v) {\\n        u = fset(u), v = fset(v);\\n        if(u != v) {\\n            if(lev[u] < lev[v]) swap(u, v);\\n            par[v] = u;\\n            sum[u] += sum[v]; // if two segments are merged the sum increases\\n        }\\n    }\\n    \\n    ll getSum(int v) {\\n        return sum[fset(v)]; // the total sum of the segment would be stored in the parent node\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& v) {\\n        int n = nums.size();\\n        DSU dsu(n, nums);\\n        \\n        vector<ll> res(n, 0), cur(n, 0);\\n        ll mx = 0;\\n        \\n        //work your way towards the back\\n        for(int i = v.size() - 1; ~i; --i) {\\n            res[i] = mx; // place the current maximum\\n            \\n            cur[v[i]] = nums[v[i]]; //place the value\\n            \\n            if(v[i] + 1 < n and cur[v[i] + 1] != 0) dsu.uset(v[i], v[i] + 1); \\n            // if the value at right index is not zero so the current index can be merged with the right segment\\n            \\n            if(v[i] - 1 >= 0 and cur[v[i] - 1] != 0) dsu.uset(v[i], v[i] - 1);\\n            // if the value at left index is not zero so the current index can be merged with the left segment\\n            \\n            mx = max(mx, dsu.getSum(v[i])); //after merging get the sum of the current segment formed placing the v[i]th element\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465271,
                "title": "very-easy-to-understand-java-only-treemap-used-o-nlogn",
                "content": "** Approach:** Using simple logic of storing the ranges and splitting them as solving the query.\\nIntially, we will be having whole array as are range (0, n-1). Now as we solve queries, say remove index x or set index x value as 0, we will split our range into (0, x -1) and (x + 1, n). Also, we will remove our previous range as it is of no use.\\nThere can be cases in that, suppose we need to remove x and there is range (x, x), then we will simple remove it and not adding anything back (refer code below)\\n\\nNow, to get the maximum sum of all the possible ranges, we will use another treemap, which will store sum to its frequency (frequency because multiple ranges can have same sum). And we can fetch maximum sum at any point in O(1) by simple getting last element of treemap.\\n\\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        long[] result = new long[n]; // array to store answer\\n        long[] prefixSum = new long[n+1]; // array to store prefixSum of nums\\n\\n        // calculating prefixSum\\n        for(int i = 0; i < n; i++){\\n            prefixSum[i+1] = prefixSum[i] + nums[i];\\n        }\\n\\n        // TreeMap to store ranges to its sum mapping\\n        TreeMap<int[], Long> ranges = new TreeMap<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return o1[0] - o2[0];\\n            }\\n        });\\n        \\n        // initially it will have whole array range\\n        ranges.put(new int[]{0, n - 1}, prefixSum[n]);\\n\\n        // TreeMap to store all the possible sums of range we encounter while solving queries, we are storing frequencies because \\n        // multiple range can have same sum.\\n        TreeMap<Long, Integer> sums = new TreeMap<>();\\n        // initialise it with sum of all array.\\n        sums.put(prefixSum[n], 1);\\n\\n        // Iterating on queries\\n        for(int i = 0; i < n; i++){\\n            int node = removeQueries[i]; // index to be removed or set to zero.\\n\\n            // finding range which will split when node index is removed or set 0.\\n            int[] rangeToBeRemoved = ranges.floorKey(new int[]{node});\\n            Long sum = ranges.get(rangeToBeRemoved); // finding its sum\\n\\n            // removing/ reducing sum from sums Map because we are splitting that range, so it is no more valid\\n            int f = sums.get(sum);\\n            if(f == 1) sums.remove(sum);\\n            else sums.put(sum, f - 1);\\n\\n            // removing that range\\n            ranges.remove(rangeToBeRemoved);\\n            \\n            int l = rangeToBeRemoved[0];\\n            int r = rangeToBeRemoved[1];\\n            long newSum = 0;\\n\\n            // Splitting range and store back new ranges form along with its sum.\\n            if (l == node && r != node) {\\n                newSum = prefixSum[r + 1] - prefixSum[l + 1];\\n                ranges.put(new int[]{l+1, r}, newSum);\\n                sums.put(newSum, sums.getOrDefault(newSum, 0) + 1);\\n            } else if (r == node && l != node) {\\n                newSum = prefixSum[r] - prefixSum[l];\\n                ranges.put(new int[]{l, r - 1}, newSum);\\n                sums.put(newSum, sums.getOrDefault(newSum, 0) + 1);\\n\\n            } else if(node > l && node < r){\\n                newSum = prefixSum[node] - prefixSum[l];\\n                ranges.put(new int[]{l, node - 1}, newSum);\\n                sums.put(newSum, sums.getOrDefault(newSum, 0) + 1);\\n\\n                newSum = prefixSum[r+1] - prefixSum[node + 1];\\n                ranges.put(new int[]{node + 1, r}, newSum);\\n                sums.put(newSum, sums.getOrDefault(newSum, 0) + 1);\\n            }\\n\\n\\n            if(sums.size() != 0)\\n                result[i] = sums.lastKey();\\n            else\\n                result[i] = 0;\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        long[] result = new long[n]; // array to store answer\\n        long[] prefixSum = new long[n+1]; // array to store prefixSum of nums\\n\\n        // calculating prefixSum\\n        for(int i = 0; i < n; i++){\\n            prefixSum[i+1] = prefixSum[i] + nums[i];\\n        }\\n\\n        // TreeMap to store ranges to its sum mapping\\n        TreeMap<int[], Long> ranges = new TreeMap<>(new Comparator<int[]>() {\\n            @Override\\n            public int compare(int[] o1, int[] o2) {\\n                return o1[0] - o2[0];\\n            }\\n        });\\n        \\n        // initially it will have whole array range\\n        ranges.put(new int[]{0, n - 1}, prefixSum[n]);\\n\\n        // TreeMap to store all the possible sums of range we encounter while solving queries, we are storing frequencies because \\n        // multiple range can have same sum.\\n        TreeMap<Long, Integer> sums = new TreeMap<>();\\n        // initialise it with sum of all array.\\n        sums.put(prefixSum[n], 1);\\n\\n        // Iterating on queries\\n        for(int i = 0; i < n; i++){\\n            int node = removeQueries[i]; // index to be removed or set to zero.\\n\\n            // finding range which will split when node index is removed or set 0.\\n            int[] rangeToBeRemoved = ranges.floorKey(new int[]{node});\\n            Long sum = ranges.get(rangeToBeRemoved); // finding its sum\\n\\n            // removing/ reducing sum from sums Map because we are splitting that range, so it is no more valid\\n            int f = sums.get(sum);\\n            if(f == 1) sums.remove(sum);\\n            else sums.put(sum, f - 1);\\n\\n            // removing that range\\n            ranges.remove(rangeToBeRemoved);\\n            \\n            int l = rangeToBeRemoved[0];\\n            int r = rangeToBeRemoved[1];\\n            long newSum = 0;\\n\\n            // Splitting range and store back new ranges form along with its sum.\\n            if (l == node && r != node) {\\n                newSum = prefixSum[r + 1] - prefixSum[l + 1];\\n                ranges.put(new int[]{l+1, r}, newSum);\\n                sums.put(newSum, sums.getOrDefault(newSum, 0) + 1);\\n            } else if (r == node && l != node) {\\n                newSum = prefixSum[r] - prefixSum[l];\\n                ranges.put(new int[]{l, r - 1}, newSum);\\n                sums.put(newSum, sums.getOrDefault(newSum, 0) + 1);\\n\\n            } else if(node > l && node < r){\\n                newSum = prefixSum[node] - prefixSum[l];\\n                ranges.put(new int[]{l, node - 1}, newSum);\\n                sums.put(newSum, sums.getOrDefault(newSum, 0) + 1);\\n\\n                newSum = prefixSum[r+1] - prefixSum[node + 1];\\n                ranges.put(new int[]{node + 1, r}, newSum);\\n                sums.put(newSum, sums.getOrDefault(newSum, 0) + 1);\\n            }\\n\\n\\n            if(sums.size() != 0)\\n                result[i] = sums.lastKey();\\n            else\\n                result[i] = 0;\\n\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458197,
                "title": "using-multiset-binary-search-o-n-logn",
                "content": "```\\n// Ishwar Govind\\n#define ll long long int\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        vector<ll> pre(n+1,0);\\n        multiset<ll> sums;\\n        map<int,pair<int,int>> next;\\n        for(int i=0;i<n;i++){\\n            pre[i+1] = pre[i]+nums[i];\\n        }\\n        sums.insert(pre[n]);\\n        next[n-1] = {0,n-1};\\n        vector<ll> ans;\\n        for(int i=0;i<removeQueries.size();i++){\\n            int idx = removeQueries[i];\\n            auto tmp = *next.lower_bound(idx);\\n            pair<int,int> pp = next[tmp.first];\\n            if(pp.first==idx){\\n                next.erase(pp.second);\\n                next[pp.second] = {idx+1,pp.second};\\n                auto it = sums.find(pre[pp.second+1]-pre[pp.first]);\\n                sums.erase(it);\\n                sums.insert(pre[pp.second+1]-pre[idx+1]);\\n            }\\n            else if(pp.second==idx){\\n                next.erase(pp.second);\\n                next[idx-1] = {pp.first,idx-1};;\\n                auto it = sums.find(pre[pp.second+1]-pre[pp.first]);\\n                sums.erase(it);\\n                sums.insert(pre[idx]-pre[pp.first]);\\n            }\\n            else{\\n                next.erase(pp.second);\\n                next[idx-1] = {pp.first,idx-1};\\n                next[pp.second] = {idx+1,pp.second};\\n                auto it = sums.find(pre[pp.second+1]-pre[pp.first]);\\n                sums.erase(it);\\n                sums.insert(pre[pp.second+1]-pre[idx+1]);\\n                sums.insert(pre[idx]-pre[pp.first]);\\n            }\\n            ans.push_back(*sums.rbegin());\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\n// Ishwar Govind\\n#define ll long long int\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        vector<ll> pre(n+1,0);\\n        multiset<ll> sums;\\n        map<int,pair<int,int>> next;\\n        for(int i=0;i<n;i++){\\n            pre[i+1] = pre[i]+nums[i];\\n        }\\n        sums.insert(pre[n]);\\n        next[n-1] = {0,n-1};\\n        vector<ll> ans;\\n        for(int i=0;i<removeQueries.size();i++){\\n            int idx = removeQueries[i];\\n            auto tmp = *next.lower_bound(idx);\\n            pair<int,int> pp = next[tmp.first];\\n            if(pp.first==idx){\\n                next.erase(pp.second);\\n                next[pp.second] = {idx+1,pp.second};\\n                auto it = sums.find(pre[pp.second+1]-pre[pp.first]);\\n                sums.erase(it);\\n                sums.insert(pre[pp.second+1]-pre[idx+1]);\\n            }\\n            else if(pp.second==idx){\\n                next.erase(pp.second);\\n                next[idx-1] = {pp.first,idx-1};;\\n                auto it = sums.find(pre[pp.second+1]-pre[pp.first]);\\n                sums.erase(it);\\n                sums.insert(pre[idx]-pre[pp.first]);\\n            }\\n            else{\\n                next.erase(pp.second);\\n                next[idx-1] = {pp.first,idx-1};\\n                next[pp.second] = {idx+1,pp.second};\\n                auto it = sums.find(pre[pp.second+1]-pre[pp.first]);\\n                sums.erase(it);\\n                sums.insert(pre[pp.second+1]-pre[idx+1]);\\n                sums.insert(pre[idx]-pre[pp.first]);\\n            }\\n            ans.push_back(*sums.rbegin());\\n        }\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455506,
                "title": "java-union-find",
                "content": "Start from the last query and build the array.\\nCheck for every index whether its left or right index was processed previously. If so, merge their chains and add their sum to the representative of the chain. Otherwise, the index cannot be part of a chain, so we make a new set/chain for it.\\n\\n```\\n    static long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length; \\n        DisjointSet d = new DisjointSet();\\n        long [] result = new long [n];\\n        \\n        for(int i = n - 1; i > 0; i--){\\n            int curIndex = removeQueries[i];\\n            d.makeSet(curIndex, nums[curIndex]);\\n            d.merge(curIndex, curIndex-1);\\n            d.merge(curIndex, curIndex + 1);\\n            result[i-1] = Math.max(result[i], d.find(curIndex).value);\\n        }\\n        return result;\\n    }\\n    \\n    public static class Node{\\n        int data, rank;\\n        long value;\\n        Node parent;\\n        public Node(int data, long value){\\n            this.data = data;\\n            this.value = value;\\n\\n        }\\n    }\\n    \\n    public static class DisjointSet{\\n        Map<Integer, Node> map = new HashMap<>();\\n        public void makeSet(int data, long value){\\n            Node node = new Node(data, value);\\n            node.parent = node;\\n            map.put(data, node);\\n        }\\n        \\n        public Node find(int x){\\n            if(map.get(x) == null) return null;\\n            if(map.get(x) == map.get(x).parent) return map.get(x);\\n            return map.get(x).parent = find(map.get(x).parent.data);\\n        }\\n        \\n        public void merge(int x, int y){\\n            Node parentX = find(x), parentY = find(y);\\n            if(parentY == null || parentY.data == parentX.data) return;\\n            parentY.parent = parentX;\\n            parentX.value += parentY.value;\\n        }\\n    }\\n```\\n\\n\\n**Merging by rank for optimization:**\\n```\\n public void merge(int x, int y){\\n\\t\\tNode parentX = find(x), parentY = find(y);\\n\\t\\tif(parentY == null || parentY.data == parentX.data) return;\\n\\t\\tif(parentX.rank > parentY.rank){\\n\\t\\t\\tparentY.parent = parentX;\\n\\t\\t\\tparentX.value += parentY.value;\\n\\t\\t}\\n\\t\\telse if(parentY.rank > parentX.rank){\\n\\t\\t\\tparentX.parent = parentY;\\n\\t\\t\\tparentY.value += parentX.value;\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tparentY.parent = parentX;\\n\\t\\t\\tparentX.value += parentY.value;\\n\\t\\t\\tparentX.rank++;\\n\\t\\t}\\n\\t}\\n```",
                "solutionTags": [],
                "code": "```\\n    static long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length; \\n        DisjointSet d = new DisjointSet();\\n        long [] result = new long [n];\\n        \\n        for(int i = n - 1; i > 0; i--){\\n            int curIndex = removeQueries[i];\\n            d.makeSet(curIndex, nums[curIndex]);\\n            d.merge(curIndex, curIndex-1);\\n            d.merge(curIndex, curIndex + 1);\\n            result[i-1] = Math.max(result[i], d.find(curIndex).value);\\n        }\\n        return result;\\n    }\\n    \\n    public static class Node{\\n        int data, rank;\\n        long value;\\n        Node parent;\\n        public Node(int data, long value){\\n            this.data = data;\\n            this.value = value;\\n\\n        }\\n    }\\n    \\n    public static class DisjointSet{\\n        Map<Integer, Node> map = new HashMap<>();\\n        public void makeSet(int data, long value){\\n            Node node = new Node(data, value);\\n            node.parent = node;\\n            map.put(data, node);\\n        }\\n        \\n        public Node find(int x){\\n            if(map.get(x) == null) return null;\\n            if(map.get(x) == map.get(x).parent) return map.get(x);\\n            return map.get(x).parent = find(map.get(x).parent.data);\\n        }\\n        \\n        public void merge(int x, int y){\\n            Node parentX = find(x), parentY = find(y);\\n            if(parentY == null || parentY.data == parentX.data) return;\\n            parentY.parent = parentX;\\n            parentX.value += parentY.value;\\n        }\\n    }\\n```\n```\\n public void merge(int x, int y){\\n\\t\\tNode parentX = find(x), parentY = find(y);\\n\\t\\tif(parentY == null || parentY.data == parentX.data) return;\\n\\t\\tif(parentX.rank > parentY.rank){\\n\\t\\t\\tparentY.parent = parentX;\\n\\t\\t\\tparentX.value += parentY.value;\\n\\t\\t}\\n\\t\\telse if(parentY.rank > parentX.rank){\\n\\t\\t\\tparentX.parent = parentY;\\n\\t\\t\\tparentY.value += parentX.value;\\n\\t\\t}\\n\\t\\telse{\\n\\t\\t\\tparentY.parent = parentX;\\n\\t\\t\\tparentX.value += parentY.value;\\n\\t\\t\\tparentX.rank++;\\n\\t\\t}\\n\\t}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467671,
                "title": "c-prefix-sum-sets-easy-solution-beginner-friendly",
                "content": "```\\ntypedef long long int ll;\\n\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        int q = removeQueries.size();\\n        \\n        vector<ll> prefix(n+1);\\n        for(int j = 1;j <= n;j++)\\n        {\\n            prefix[j] = prefix[j-1]+nums[j-1];\\n        }\\n        \\n        multiset<ll> all;\\n        all.insert(prefix[n]);\\n        all.insert(0);\\n        \\n        set<int> removed;\\n        vector<ll> result;\\n        \\n        for(auto i: removeQueries){\\n            i++;\\n            \\n            auto nxt_itr = removed.upper_bound(i);\\n            int last_ind = n;\\n            if(nxt_itr != removed.end()) last_ind = *nxt_itr - 1;\\n            \\n            int start_ind = 1;\\n            if(nxt_itr != removed.begin()){\\n                --nxt_itr;\\n                start_ind = *nxt_itr + 1;\\n            }\\n            \\n            ll range_sum = prefix[last_ind] - prefix[start_ind-1];\\n            all.erase(all.find(range_sum));\\n            \\n            //[start_ind, i-1]\\n            if(i-1 >= start_ind)all.insert(prefix[i-1] - prefix[start_ind-1]);\\n            \\n            //[i+1,last_ind]\\n            if(last_ind >= i+1)all.insert(prefix[last_ind]-prefix[i]);\\n            \\n            result.push_back(*all.rbegin());\\n            removed.insert(i);\\n        }\\n      return result;\\n    }\\n};\\n```\\n**Please upvote if it was helpful for you, thank you!**",
                "solutionTags": [
                    "C",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\ntypedef long long int ll;\\n\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        int q = removeQueries.size();\\n        \\n        vector<ll> prefix(n+1);\\n        for(int j = 1;j <= n;j++)\\n        {\\n            prefix[j] = prefix[j-1]+nums[j-1];\\n        }\\n        \\n        multiset<ll> all;\\n        all.insert(prefix[n]);\\n        all.insert(0);\\n        \\n        set<int> removed;\\n        vector<ll> result;\\n        \\n        for(auto i: removeQueries){\\n            i++;\\n            \\n            auto nxt_itr = removed.upper_bound(i);\\n            int last_ind = n;\\n            if(nxt_itr != removed.end()) last_ind = *nxt_itr - 1;\\n            \\n            int start_ind = 1;\\n            if(nxt_itr != removed.begin()){\\n                --nxt_itr;\\n                start_ind = *nxt_itr + 1;\\n            }\\n            \\n            ll range_sum = prefix[last_ind] - prefix[start_ind-1];\\n            all.erase(all.find(range_sum));\\n            \\n            //[start_ind, i-1]\\n            if(i-1 >= start_ind)all.insert(prefix[i-1] - prefix[start_ind-1]);\\n            \\n            //[i+1,last_ind]\\n            if(last_ind >= i+1)all.insert(prefix[last_ind]-prefix[i]);\\n            \\n            result.push_back(*all.rbegin());\\n            removed.insert(i);\\n        }\\n      return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2559660,
                "title": "python-5-lines-o-n-with-explanation",
                "content": "# Explanation\\nLet\\'s remind ourselves of the problem constraints.\\n\\n1. n == nums.length == removeQueries.length\\n2. 1 <= n <= 10^5\\n3. 1 <= nums[i] <= 10^9\\n4. 0 <= removeQueries[i] < n\\n5. All the values of removeQueries are unique.\\n\\nBecause of constraints 1, 4, and 5, it is guaraunteed that all indices of nums will be in removeQueries. This means that the last value of the answer will always be zero because all values will be removed and all that remains is the null segment.\\n\\nWe can exploit this to simplify the problem by building our segments backwards, visiting each element we wish to introduce to our existing segments from the reverse of the removeQueries array. \\n\\nVisiting the segments backwards is simpler because of constraint 3, which guarauntees that the nums array only contains positive integers. This means that each time we add or extend our segments, the value of the maximum segment can only increase or stay the same. Therefore, we won\\'t need to worry about maintaining a heap to keep track of the largest segments and invalidating segments that no longer exist, we can just use an integer to keep track of what the largest segment ever was and use the maximum of that or the segment we just added to as our largest segment for the next iteration.\\n\\nWe do this by keeping track of existing segments in a dictionary `seg`, which is initialized as an empty dictionary and will be used to map the edges of segments to a tuple containing 1) the index of the opposite edge of the segment and 2) the size of the segment. \\n\\nFor each new element we\\'re introducing, we grab segments to the left and right of index `q` if they exist, using default segments `(q, 0)` if they do not which represents a side of the new segment that extends no further and adds no additional value, and then assign both the left and right sides to the tuple with their compliment index and the sum.\\n\\nFinally, we reverse the output to get the answer to the original question.\\n# Code\\n## 10 lines (prettier)\\n```python\\n        ans, seg, top = [], {}, 0\\n        for q in reversed(removeQueries):\\n            ans.append(top)\\n            l = seg.get(q-1, (q, 0))\\n            r = seg.get(q+1, (q, 0))\\n            s = nums[q] + l[1] + r[1]\\n            seg[l[0]] = (r[0], s)\\n            seg[r[0]] = (l[0], s)\\n            top = max(s, top)\\n        return ans[::-1]\\n```\\n\\n## 8 lines (a little crowded)\\n```python\\n        ans, seg, top = [], {}, 0\\n        for q in reversed(removeQueries):\\n            ans.append(top)\\n            l, r = seg.get(q-1, (q, 0)), seg.get(q+1, (q, 0))\\n            s = nums[q] + l[1] + r[1]\\n            seg[l[0]], seg[r[0]] = (r[0], s), (l[0], s)\\n            top = max(s, top)\\n        return ans[::-1]\\n```\\n\\n## 7 lines\\n\\nA bit more contrived but just uses ans[-1] to track the top element. Has to slice off the first element of removeQueries to prevent an additional iteration.\\n\\n```python\\n        ans, seg = [0], {}\\n        for q in reversed(removeQueries[1:]):\\n            l, r = seg.get(q-1, (q, 0)), seg.get(q+1, (q, 0))\\n            s = nums[q] + l[1] + r[1]\\n            seg[l[0]], seg[r[0]] = (r[0], s), (l[0], s)\\n            ans.append(max(s, ans[-1]))\\n        return ans[::-1]\\n```\\n\\n## 6 lines\\nYou could also shave off another line by using ans[-1] to track `s`, which requires you to then accumulate the results at the end using `itertools.accumulate` before reversing them.\\n\\n```python\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        ans, seg = [0], {}\\n        for q in reversed(removeQueries[1:]):\\n            (li, ls), (ri, rs) = seg.get(q-1, (q, 0)), seg.get(q+1, (q, 0))\\n            ans.append(s := nums[q] + ls + rs)\\n            seg[li], seg[ri] = (ri, s), (li, s)\\n        return [*accumulate(ans, max)][::-1]\\n```\\n\\n## 5 lines\\n\\nGetting code-golfy, but by further abusing walrus operators you can get this down to 5 lines. Spaces removed and all variables renamed to be length 1 in the code golfing spirit.\\n\\n```python\\n        a,c=[0],{}\\n        for q in reversed(removeQueries[1:]):\\n            a.append(s:=nums[q]+(l:=c.get(q-1,(q, 0)))[1]+(r:=c.get(q+1,(q, 0)))[1])\\n            c[l[0]],c[r[0]]=(r[0],s),(l[0],s)\\n        return [*accumulate(a, max)][::-1]\\n```",
                "solutionTags": [],
                "code": "```python\\n        ans, seg, top = [], {}, 0\\n        for q in reversed(removeQueries):\\n            ans.append(top)\\n            l = seg.get(q-1, (q, 0))\\n            r = seg.get(q+1, (q, 0))\\n            s = nums[q] + l[1] + r[1]\\n            seg[l[0]] = (r[0], s)\\n            seg[r[0]] = (l[0], s)\\n            top = max(s, top)\\n        return ans[::-1]\\n```\n```python\\n        ans, seg, top = [], {}, 0\\n        for q in reversed(removeQueries):\\n            ans.append(top)\\n            l, r = seg.get(q-1, (q, 0)), seg.get(q+1, (q, 0))\\n            s = nums[q] + l[1] + r[1]\\n            seg[l[0]], seg[r[0]] = (r[0], s), (l[0], s)\\n            top = max(s, top)\\n        return ans[::-1]\\n```\n```python\\n        ans, seg = [0], {}\\n        for q in reversed(removeQueries[1:]):\\n            l, r = seg.get(q-1, (q, 0)), seg.get(q+1, (q, 0))\\n            s = nums[q] + l[1] + r[1]\\n            seg[l[0]], seg[r[0]] = (r[0], s), (l[0], s)\\n            ans.append(max(s, ans[-1]))\\n        return ans[::-1]\\n```\n```python\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        ans, seg = [0], {}\\n        for q in reversed(removeQueries[1:]):\\n            (li, ls), (ri, rs) = seg.get(q-1, (q, 0)), seg.get(q+1, (q, 0))\\n            ans.append(s := nums[q] + ls + rs)\\n            seg[li], seg[ri] = (ri, s), (li, s)\\n        return [*accumulate(ans, max)][::-1]\\n```\n```python\\n        a,c=[0],{}\\n        for q in reversed(removeQueries[1:]):\\n            a.append(s:=nums[q]+(l:=c.get(q-1,(q, 0)))[1]+(r:=c.get(q+1,(q, 0)))[1])\\n            c[l[0]],c[r[0]]=(r[0],s),(l[0],s)\\n        return [*accumulate(a, max)][::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498714,
                "title": "python3-reverse-dsu",
                "content": "```\\nclass UnionFind :\\n    def __init__(self):\\n        self.parent = {}\\n        self.maxsum = 0\\n        self.sum = {}\\n        \\n    def find(self,x):\\n        if x!=self.parent[x]:\\n            self.parent[x]=self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self,x,y):\\n        px = self.find(x)\\n        py = self.find(y)\\n        if px==py :\\n            return\\n        self.sum[px]+=self.sum[py]\\n        self.parent[py]=px\\n        self.maxsum = max(self.maxsum,self.sum[px])\\n    \\n    def mergesegment(self,u,value):\\n        self.parent[u]=u\\n        self.maxsum = max(self.maxsum,value)\\n        self.sum[u]=value\\n        if u-1 in self.parent :\\n            self.union(u-1,u)\\n        if u+1 in self.parent :\\n            self.union(u+1,u)\\n        \\nclass Solution:\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        uf = UnionFind()\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n-1,-1,-1):\\n            ans[i] = uf.maxsum\\n            q = removeQueries[i]\\n            uf.mergesegment(q,nums[q])\\n        return ans\\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass UnionFind :\\n    def __init__(self):\\n        self.parent = {}\\n        self.maxsum = 0\\n        self.sum = {}\\n        \\n    def find(self,x):\\n        if x!=self.parent[x]:\\n            self.parent[x]=self.find(self.parent[x])\\n        return self.parent[x]\\n    \\n    def union(self,x,y):\\n        px = self.find(x)\\n        py = self.find(y)\\n        if px==py :\\n            return\\n        self.sum[px]+=self.sum[py]\\n        self.parent[py]=px\\n        self.maxsum = max(self.maxsum,self.sum[px])\\n    \\n    def mergesegment(self,u,value):\\n        self.parent[u]=u\\n        self.maxsum = max(self.maxsum,value)\\n        self.sum[u]=value\\n        if u-1 in self.parent :\\n            self.union(u-1,u)\\n        if u+1 in self.parent :\\n            self.union(u+1,u)\\n        \\nclass Solution:\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        uf = UnionFind()\\n        n = len(nums)\\n        ans = [0]*n\\n        for i in range(n-1,-1,-1):\\n            ans[i] = uf.maxsum\\n            q = removeQueries[i]\\n            uf.mergesegment(q,nums[q])\\n        return ans\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475116,
                "title": "java-2-ways-union-find-and-segment-tree",
                "content": "Approach 1: Union Find (24ms)\\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        long[] ans = new long[n];\\n        UnionFind uf = new UnionFind(n, nums);\\n        \\n        for (int i=n-1; i>0; i--) {\\n            int cur = removeQueries[i];\\n            uf.add(cur, nums[cur]);\\n            \\n            if (cur > 0 && uf.getSum(cur-1) > 0)\\n                uf.union(cur, cur - 1);\\n            if (cur < n-1 && uf.getSum(cur+1) > 0)\\n                uf.union(cur, cur + 1);\\n            \\n            int root = uf.find(cur);\\n            ans[i-1] = Math.max(uf.getSum(root), ans[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\nclass UnionFind {\\n    private int[] root;\\n    private int[] rank;\\n    private long[] sum;\\n\\n    public UnionFind(int size, int[] arr) {\\n        root = new int[size];\\n        rank = new int[size];\\n        sum = new long[size];\\n        \\n        for (int i = 0; i < size; i++) {\\n            root[i] = i;\\n            rank[i] = 1; \\n        }\\n    }\\n\\n    public int find(int x) {\\n        if (x == root[x]) {\\n            return x;\\n        }\\n        return root[x] = find(root[x]);\\n    }\\n\\n    public void union(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        \\n        if (rootX != rootY) {\\n            if (rank[rootX] > rank[rootY]) {\\n                root[rootY] = rootX;\\n                sum[rootX] += sum[rootY];\\n            } else if (rank[rootX] < rank[rootY]) {\\n                root[rootX] = rootY;\\n                sum[rootY] += sum[rootX];\\n            } else {\\n                root[rootY] = rootX;\\n                rank[rootX] += 1;\\n                sum[rootX] += sum[rootY];\\n            }\\n        }\\n    }\\n    \\n    public void add(int idx, int val) {\\n        sum[idx] += val;\\n    }\\n    \\n    public long getSum(int idx) {\\n        return sum[idx];\\n    }\\n}\\n```\\n\\nApproach 2: Segment Tree (199 ms)\\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        long[] ans = new long[n];\\n        SegmentTreeNode st = new SegmentTreeNode(0, n-1);\\n        \\n        for (int i=0; i<n; i++) {\\n            st.update(i, nums[i]);\\n        }\\n\\n        for (int i=0; i<n-1; i++) {\\n            ans[i] = st.update(removeQueries[i], -nums[removeQueries[i]]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\nclass SegmentTreeNode {\\n    SegmentTreeNode left, right;\\n    long max, leftSum, rightSum;\\n    int lo, hi;\\n    boolean isDivided;\\n    \\n    public SegmentTreeNode(int lo, int hi) {\\n        this.lo = lo;\\n        this.hi = hi;\\n    }\\n    \\n    public int getMid() {\\n        return lo + (hi - lo)/2;\\n    }\\n    \\n    public SegmentTreeNode getLeft() {\\n        if (left == null)\\n            left = new SegmentTreeNode(lo, getMid());\\n        return left;\\n    }\\n    \\n    public SegmentTreeNode getRight() {\\n        if (right == null)\\n            right = new SegmentTreeNode(getMid()+1, hi);\\n        return right;\\n    }\\n    \\n    public long update(int pos, int val) {\\n        if (lo > pos || hi < pos)\\n            return 0;\\n        \\n        if (pos == lo && pos == hi) {\\n            leftSum += val;\\n            rightSum += val;\\n            max += val;\\n            if (max == 0)\\n                isDivided = true;\\n            return max;\\n        }\\n        \\n        getLeft().update(pos, val);\\n        getRight().update(pos, val);\\n        \\n        leftSum = left.isDivided ? left.leftSum : left.leftSum + right.leftSum;\\n        rightSum = right.isDivided ? right.rightSum : right.rightSum + left.rightSum;\\n        max = Math.max(Math.max(left.max, right.max), left.rightSum + right.leftSum);\\n        isDivided = left.isDivided || right.isDivided;\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        long[] ans = new long[n];\\n        UnionFind uf = new UnionFind(n, nums);\\n        \\n        for (int i=n-1; i>0; i--) {\\n            int cur = removeQueries[i];\\n            uf.add(cur, nums[cur]);\\n            \\n            if (cur > 0 && uf.getSum(cur-1) > 0)\\n                uf.union(cur, cur - 1);\\n            if (cur < n-1 && uf.getSum(cur+1) > 0)\\n                uf.union(cur, cur + 1);\\n            \\n            int root = uf.find(cur);\\n            ans[i-1] = Math.max(uf.getSum(root), ans[i]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\nclass UnionFind {\\n    private int[] root;\\n    private int[] rank;\\n    private long[] sum;\\n\\n    public UnionFind(int size, int[] arr) {\\n        root = new int[size];\\n        rank = new int[size];\\n        sum = new long[size];\\n        \\n        for (int i = 0; i < size; i++) {\\n            root[i] = i;\\n            rank[i] = 1; \\n        }\\n    }\\n\\n    public int find(int x) {\\n        if (x == root[x]) {\\n            return x;\\n        }\\n        return root[x] = find(root[x]);\\n    }\\n\\n    public void union(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        \\n        if (rootX != rootY) {\\n            if (rank[rootX] > rank[rootY]) {\\n                root[rootY] = rootX;\\n                sum[rootX] += sum[rootY];\\n            } else if (rank[rootX] < rank[rootY]) {\\n                root[rootX] = rootY;\\n                sum[rootY] += sum[rootX];\\n            } else {\\n                root[rootY] = rootX;\\n                rank[rootX] += 1;\\n                sum[rootX] += sum[rootY];\\n            }\\n        }\\n    }\\n    \\n    public void add(int idx, int val) {\\n        sum[idx] += val;\\n    }\\n    \\n    public long getSum(int idx) {\\n        return sum[idx];\\n    }\\n}\\n```\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        long[] ans = new long[n];\\n        SegmentTreeNode st = new SegmentTreeNode(0, n-1);\\n        \\n        for (int i=0; i<n; i++) {\\n            st.update(i, nums[i]);\\n        }\\n\\n        for (int i=0; i<n-1; i++) {\\n            ans[i] = st.update(removeQueries[i], -nums[removeQueries[i]]);\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\nclass SegmentTreeNode {\\n    SegmentTreeNode left, right;\\n    long max, leftSum, rightSum;\\n    int lo, hi;\\n    boolean isDivided;\\n    \\n    public SegmentTreeNode(int lo, int hi) {\\n        this.lo = lo;\\n        this.hi = hi;\\n    }\\n    \\n    public int getMid() {\\n        return lo + (hi - lo)/2;\\n    }\\n    \\n    public SegmentTreeNode getLeft() {\\n        if (left == null)\\n            left = new SegmentTreeNode(lo, getMid());\\n        return left;\\n    }\\n    \\n    public SegmentTreeNode getRight() {\\n        if (right == null)\\n            right = new SegmentTreeNode(getMid()+1, hi);\\n        return right;\\n    }\\n    \\n    public long update(int pos, int val) {\\n        if (lo > pos || hi < pos)\\n            return 0;\\n        \\n        if (pos == lo && pos == hi) {\\n            leftSum += val;\\n            rightSum += val;\\n            max += val;\\n            if (max == 0)\\n                isDivided = true;\\n            return max;\\n        }\\n        \\n        getLeft().update(pos, val);\\n        getRight().update(pos, val);\\n        \\n        leftSum = left.isDivided ? left.leftSum : left.leftSum + right.leftSum;\\n        rightSum = right.isDivided ? right.rightSum : right.rightSum + left.rightSum;\\n        max = Math.max(Math.max(left.max, right.max), left.rightSum + right.leftSum);\\n        isDivided = left.isDivided || right.isDivided;\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462641,
                "title": "java-using-multiset-and-treeset-o-n-log-n",
                "content": "```\\nclass Solution {\\n    class Pair {\\n        int start, end;\\n        Pair(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n        }\\n    }\\n    class MultiSet {\\n        TreeMap<Long, Integer> freq;\\n    \\n        MultiSet() {\\n            freq = new TreeMap<>();\\n        }\\n    \\n        void add(long x) {\\n            freq.put(x, freq.getOrDefault(x, 0) + 1);\\n        }\\n    \\n        boolean remove(long x) {\\n            Integer f = freq.get(x);\\n            if (f == null)\\n                return false;\\n            else if (f == 1) {\\n                freq.remove(x);\\n            } else {\\n                freq.put(x, f - 1);\\n            }\\n            return true;\\n        }\\n        Long getMax() {\\n            if(freq.size() == 0) return 0L;\\n            return freq.lastKey();\\n        }\\n    }\\n    public long[] maximumSegmentSum(int[] arr, int[] removeQueries) {\\n        long[] pre = new long[arr.length + 1];  // pefix sum to query subarray sum in O(1)\\n        for(int i = 0; i < arr.length; i++) pre[i+1] = pre[i] + arr[i];\\n        TreeSet<Pair> set = new TreeSet<>((a, b) -> a.start - b.start);  // order by start of range\\n        MultiSet sums = new MultiSet();\\n        set.add(new Pair(0, arr.length-1));   // initaially one segment of full range\\n        sums.add(pre[arr.length] - pre[0]);   // add the sum of the full ranged segment to MultiSet sums\\n        long[] ans = new long[removeQueries.length];\\n        for(int i = 0; i < removeQueries.length; i++) {\\n            Pair p = set.floor(new Pair(removeQueries[i], removeQueries[i])); // find range that contains removeQueries[i]\\n            set.remove(p);  // remove the range from set\\n            sums.remove(pre[p.end+1] - pre[p.start]);  // remove the corresponding sum from sums\\n\\t\\t\\t// split the range into two ranges (if non empty)\\n\\t\\t\\t// range with smaller start\\n            if(p.start <= removeQueries[i]-1) {\\n                Pair p1 = new Pair(p.start, removeQueries[i] - 1);\\n                set.add(p1); // add the pair for range with smaller start\\n                sums.add(pre[p1.end + 1] - pre[p1.start]);  // add corresponding sum\\n            }\\n\\t\\t\\t// remaining range\\n            if(removeQueries[i]+1 <= p.end) {\\n                Pair p2 = new Pair(removeQueries[i] + 1, p.end);\\n                set.add(p2); // add the pair with remaining range\\n                sums.add(pre[p2.end + 1] - pre[p2.start]); // add corresponding range\\n            }\\n            ans[i] = sums.getMax()==null?0L:sums.getMax(); // get max or 0 if empty from the MultiSet\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    class Pair {\\n        int start, end;\\n        Pair(int start, int end) {\\n            this.start = start;\\n            this.end = end;\\n        }\\n    }\\n    class MultiSet {\\n        TreeMap<Long, Integer> freq;\\n    \\n        MultiSet() {\\n            freq = new TreeMap<>();\\n        }\\n    \\n        void add(long x) {\\n            freq.put(x, freq.getOrDefault(x, 0) + 1);\\n        }\\n    \\n        boolean remove(long x) {\\n            Integer f = freq.get(x);\\n            if (f == null)\\n                return false;\\n            else if (f == 1) {\\n                freq.remove(x);\\n            } else {\\n                freq.put(x, f - 1);\\n            }\\n            return true;\\n        }\\n        Long getMax() {\\n            if(freq.size() == 0) return 0L;\\n            return freq.lastKey();\\n        }\\n    }\\n    public long[] maximumSegmentSum(int[] arr, int[] removeQueries) {\\n        long[] pre = new long[arr.length + 1];  // pefix sum to query subarray sum in O(1)\\n        for(int i = 0; i < arr.length; i++) pre[i+1] = pre[i] + arr[i];\\n        TreeSet<Pair> set = new TreeSet<>((a, b) -> a.start - b.start);  // order by start of range\\n        MultiSet sums = new MultiSet();\\n        set.add(new Pair(0, arr.length-1));   // initaially one segment of full range\\n        sums.add(pre[arr.length] - pre[0]);   // add the sum of the full ranged segment to MultiSet sums\\n        long[] ans = new long[removeQueries.length];\\n        for(int i = 0; i < removeQueries.length; i++) {\\n            Pair p = set.floor(new Pair(removeQueries[i], removeQueries[i])); // find range that contains removeQueries[i]\\n            set.remove(p);  // remove the range from set\\n            sums.remove(pre[p.end+1] - pre[p.start]);  // remove the corresponding sum from sums\\n\\t\\t\\t// split the range into two ranges (if non empty)\\n\\t\\t\\t// range with smaller start\\n            if(p.start <= removeQueries[i]-1) {\\n                Pair p1 = new Pair(p.start, removeQueries[i] - 1);\\n                set.add(p1); // add the pair for range with smaller start\\n                sums.add(pre[p1.end + 1] - pre[p1.start]);  // add corresponding sum\\n            }\\n\\t\\t\\t// remaining range\\n            if(removeQueries[i]+1 <= p.end) {\\n                Pair p2 = new Pair(removeQueries[i] + 1, p.end);\\n                set.add(p2); // add the pair with remaining range\\n                sums.add(pre[p2.end + 1] - pre[p2.start]); // add corresponding range\\n            }\\n            ans[i] = sums.getMax()==null?0L:sums.getMax(); // get max or 0 if empty from the MultiSet\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456252,
                "title": "java-segment-tree",
                "content": "```\\nclass Solution {\\n\\t// once we have defined our segment tree node logic (see below), the implementation of the core algorithm is trivial:\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n= nums.length, k= removeQueries.length;\\n        SegmentTree st= new SegmentTree(nums);\\n        long[] ans= new long[k];\\n        for(int i=0; i<k; i++){\\n            st.setZero(removeQueries[i]);\\n            ans[i]= st.rangeQuery(0, n-1).maxSum;\\n        }\\n        return ans;\\n    }\\n\\n    static class SegmentTree {\\n        int n;      // size of the original array\\n        int[] A;    // original array\\n        Node[] st;  // segment tree array\\n\\n        public SegmentTree(int[] nums){\\n            this.A= nums;\\n            this.n= nums.length;\\n            this.st= new Node[4*n];\\n            build(1, 0, n-1);   // build recursively top-down (p==1 index of the tree root (top) node)\\n        }\\n    \\n        public Node rangeQuery(int i, int j){\\n            return rangeQuery(1, 0, n-1, i, j);      // traverse segment tree from the root\\n        }\\n    \\n        public void setZero(int i){   // set single element\\'s value to zero\\n            update(1, 0, n-1, i, i, 0);\\n        }\\n\\n\\t  // node contains the minimum information required for segment tree to calculate a max subarray sum (that doesn\\'t contain zeros) \\n\\t  // and allow for bottom-up merging of that information\\n        static class Node{         \\n            boolean hasZero;       // true if contains some deleted elements\\n            long maxSum;           // max sum of subarray with no zeros\\n            long lSum;             // sum from left to first zero\\n            long rSum;             // sum from right to first zero\\n    \\n            Node(long val){\\n                this.hasZero= val==0;\\n                this.maxSum= this.lSum= this.rSum= val;\\n            }\\n    \\n            Node(boolean hasZero, long maxSum, long lSum, long rSum){\\n                this.hasZero= hasZero;\\n                this.maxSum= maxSum;\\n                this.lSum= lSum;\\n                this.rSum= rSum;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// node merging logic to calculate the max subarray sum (not containing zeros)\\n\\t\\t\\tstatic Node merge(Node l, Node r){\\n                if(l==null) return r;\\n                if(r==null) return l;\\n                if(!l.hasZero && !r.hasZero) return new Node(l.maxSum+r.maxSum);\\n                return new Node(true, \\n                    Math.max(l.rSum+r.lSum, Math.max(l.maxSum, r.maxSum)),\\n                    l.hasZero ? l.lSum : l.maxSum+r.lSum,\\n                    r.hasZero ? r.rSum : r.maxSum+l.rSum\\n                );\\n            }  \\t\\n        }\\n\\t\\t\\n\\t\\t// boilerplate, reusable implementation of segment tree operations follows\\n        void build(int p, int L, int R){\\n            if(L==R){\\n                st[p]= new Node(A[L]);\\n            }else{\\n                int m= (L+R)/2, lp= (p<<1), rp= lp+1;\\n                build(lp, L, m);\\n                build(rp, m+1, R);\\n                st[p]= Node.merge(st[lp], st[rp]); \\n            }\\n        }        \\n        \\n        void update(int p, int L, int R, int i, int j, int val){\\n            if(i>j) return;\\n            if((L>=i) && (R<=j)){\\n                st[p]= new Node(A[i]= val);\\n            }else{\\n                int m= (L+R)/2, lp= p*2, rp= lp+1;\\n                update(lp, L, m, i, Math.min(m,j), val);\\n                update(rp, m+1, R, Math.max(i,m+1), j, val);\\n                st[p]= Node.merge(st[lp], st[rp]);\\n            }\\n        }\\n\\n        Node rangeQuery(int p, int L, int R, int i, int j){\\n            if(i>j) return null;\\n            if((L>=i) && (R<=j)) return st[p];        // found the segment\\n            int m= (L+R)/2, lp= p*2, rp= lp+1;\\n            return Node.merge(rangeQuery(lp, L, m, i, Math.min(m,j)),\\n                              rangeQuery(rp, m+1, R, Math.max(i, m+1), j));\\n        }\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n\\t// once we have defined our segment tree node logic (see below), the implementation of the core algorithm is trivial:\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n= nums.length, k= removeQueries.length;\\n        SegmentTree st= new SegmentTree(nums);\\n        long[] ans= new long[k];\\n        for(int i=0; i<k; i++){\\n            st.setZero(removeQueries[i]);\\n            ans[i]= st.rangeQuery(0, n-1).maxSum;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2454867,
                "title": "bit-multiset-o-n-log-n-c-solution-that-succeeds",
                "content": "```\\nclass Solution {\\n    long long getSum(vector<long long>& BITree, int index) {\\n        long long sum = 0;\\n        index++;\\n        while (index>0) {\\n            sum += BITree[index];\\n            index -= index & (-index);\\n        }\\n        return sum;\\n    }\\n    \\n    long long getSum(vector<long long>& BITree, int l, int r) {\\n        return getSum(BITree, r) - getSum(BITree, l - 1);\\n    }\\n    \\n    void updateBIT(vector<long long>& BITree, int n, int index, long long val) {\\n        index++;\\n        while (index <= n) {\\n            BITree[index] += val;\\n            index += index & (-index);\\n        }\\n    }\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        multiset<long long> pq;\\n        set<long long> query;\\n        vector<long long> result;\\n        \\n        // Constructs BIT\\n        int n=nums.size();\\n        vector<long long> BITree(n+1, 0);\\n        for (int i=0; i<n; i++)\\n            updateBIT(BITree, n, i, nums[i]);\\n        \\n        for(int i=0;i<removeQueries.size();i++) {\\n            long long l=0;\\n            if (!query.empty()) {\\n                auto it = query.lower_bound(removeQueries[i]);\\n                if (it!=query.begin()) {\\n                    it--;\\n                    l = (*it);\\n                }\\n            }\\n            \\n            long long r=n-1;\\n            if (!query.empty()) {\\n                auto it = query.upper_bound(removeQueries[i]);\\n                if (it!=query.end()) r = (*it);\\n            }\\n            \\n            long long leftSum = (removeQueries[i]>0) ? getSum(BITree, l, removeQueries[i]-1) : 0;\\n            long long rightSum = (removeQueries[i]!=n-1) ? getSum(BITree, removeQueries[i]+1, r) : 0;\\n            \\n            if (pq.size()!=0) pq.erase(pq.find(leftSum+rightSum+nums[removeQueries[i]]));\\n            \\n            updateBIT(BITree, n, removeQueries[i], -nums[removeQueries[i]]);\\n            nums[removeQueries[i]]=0;\\n            \\n            pq.insert(leftSum);\\n            pq.insert(rightSum);\\n            result.push_back(*pq.rbegin());\\n            query.insert(removeQueries[i]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\n    long long getSum(vector<long long>& BITree, int index) {\\n        long long sum = 0;\\n        index++;\\n        while (index>0) {\\n            sum += BITree[index];\\n            index -= index & (-index);\\n        }\\n        return sum;\\n    }\\n    \\n    long long getSum(vector<long long>& BITree, int l, int r) {\\n        return getSum(BITree, r) - getSum(BITree, l - 1);\\n    }\\n    \\n    void updateBIT(vector<long long>& BITree, int n, int index, long long val) {\\n        index++;\\n        while (index <= n) {\\n            BITree[index] += val;\\n            index += index & (-index);\\n        }\\n    }\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        multiset<long long> pq;\\n        set<long long> query;\\n        vector<long long> result;\\n        \\n        // Constructs BIT\\n        int n=nums.size();\\n        vector<long long> BITree(n+1, 0);\\n        for (int i=0; i<n; i++)\\n            updateBIT(BITree, n, i, nums[i]);\\n        \\n        for(int i=0;i<removeQueries.size();i++) {\\n            long long l=0;\\n            if (!query.empty()) {\\n                auto it = query.lower_bound(removeQueries[i]);\\n                if (it!=query.begin()) {\\n                    it--;\\n                    l = (*it);\\n                }\\n            }\\n            \\n            long long r=n-1;\\n            if (!query.empty()) {\\n                auto it = query.upper_bound(removeQueries[i]);\\n                if (it!=query.end()) r = (*it);\\n            }\\n            \\n            long long leftSum = (removeQueries[i]>0) ? getSum(BITree, l, removeQueries[i]-1) : 0;\\n            long long rightSum = (removeQueries[i]!=n-1) ? getSum(BITree, removeQueries[i]+1, r) : 0;\\n            \\n            if (pq.size()!=0) pq.erase(pq.find(leftSum+rightSum+nums[removeQueries[i]]));\\n            \\n            updateBIT(BITree, n, removeQueries[i], -nums[removeQueries[i]]);\\n            nums[removeQueries[i]]=0;\\n            \\n            pq.insert(leftSum);\\n            pq.insert(rightSum);\\n            result.push_back(*pq.rbegin());\\n            query.insert(removeQueries[i]);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454489,
                "title": "python-time-complexity-o-n-solution-reverse-process-and-merge-non-zero-interval",
                "content": "Don\\'t process forward like example, reverse it!\\n![image](https://assets.leetcode.com/users/images/fc85b128-f27a-4f71-9124-26e2c0f36a6b_1661012644.627654.png)\\n\\n```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        \\n        n = len(nums)\\n        newNums = [0] * n\\n        \\n        # can use to merge segment sum\\n        # leftJoin is to merge right block\\n        # rightJoin is to merge left block\\n        leftJoin, rightJoin = {}, {}\\n            \\n        res = [0]\\n        nowMax = 0\\n        for i in removeQueries[::-1][:-1]:\\n            newNums[i] = nums[i]\\n            nowSum = newNums[i]\\n            leftB = rightB = i\\n            \\n            # if right block not zero, merge it!\\n            if i + 1 in leftJoin:\\n                nowSum += leftJoin[i + 1][0]\\n                rightB = leftJoin[i + 1][2]\\n                \\n            # if left block not zero, merge it!\\n            if i - 1 in rightJoin:\\n                nowSum += rightJoin[i - 1][0]\\n                leftB = rightJoin[i - 1][1]\\n                \\n            # creat new block to next merge\\n            # leftJoin and rightJoin have 3 values [nowSum, leftBound, rightBound]\\n            leftJoin[leftB] = (nowSum, leftB, rightB)\\n            rightJoin[rightB] = (nowSum, leftB, rightB)\\n            nowMax = max(nowMax, nowSum)\\n            res.append(nowMax)\\n            \\n        return res[::-1]\\n                                     \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        \\n        n = len(nums)\\n        newNums = [0] * n\\n        \\n        # can use to merge segment sum\\n        # leftJoin is to merge right block\\n        # rightJoin is to merge left block\\n        leftJoin, rightJoin = {}, {}\\n            \\n        res = [0]\\n        nowMax = 0\\n        for i in removeQueries[::-1][:-1]:\\n            newNums[i] = nums[i]\\n            nowSum = newNums[i]\\n            leftB = rightB = i\\n            \\n            # if right block not zero, merge it!\\n            if i + 1 in leftJoin:\\n                nowSum += leftJoin[i + 1][0]\\n                rightB = leftJoin[i + 1][2]\\n                \\n            # if left block not zero, merge it!\\n            if i - 1 in rightJoin:\\n                nowSum += rightJoin[i - 1][0]\\n                leftB = rightJoin[i - 1][1]\\n                \\n            # creat new block to next merge\\n            # leftJoin and rightJoin have 3 values [nowSum, leftBound, rightBound]\\n            leftJoin[leftB] = (nowSum, leftB, rightB)\\n            rightJoin[rightB] = (nowSum, leftB, rightB)\\n            nowMax = max(nowMax, nowSum)\\n            res.append(nowMax)\\n            \\n        return res[::-1]\\n                                     \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454186,
                "title": "dsu-c",
                "content": "**Explanation:-**\\n1. We will traverse from last and use DSU to join segments\\n2.   rank[idx] will contain sum of elements rooted at idx\\n\\n```\\nclass DSU {\\n public:\\n  vector<long> p, rank;\\n  long maxi = 0;\\n  DSU(vector<int>& nums) {\\n    int sz = nums.size();\\n    for (auto& i : nums) rank.push_back(i);\\n    p.resize(sz, 0);\\n    iota(begin(p), end(p), 0);\\n  }\\n  int find(int node) {\\n    if (p[node] == node) return node;\\n    return p[node] = find(p[node]);\\n  }\\n  void join(int x, int y) {\\n    if (x == y) {\\n      maxi = max(maxi, rank[x]);\\n      return;\\n    }\\n    int p1 = find(x), p2 = find(y);\\n    if (rank[p2] > rank[p1]) swap(p2, p1);\\n    p[p2] = p1;\\n    rank[p1] += rank[p2];\\n    maxi = max(maxi, rank[p1]);\\n  }\\n  long getMax() { return maxi; }\\n};\\nclass Solution {\\n public:\\n  vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rem) {\\n    int sz = nums.size();\\n    vector<long long> ans(sz, 0);\\n    DSU obj(nums);\\n    vector<bool> seen(sz, false);\\n    for (int i = sz - 2; i >= 0; i--) {\\n      int idx = rem[i + 1];\\n        // seen [idx] =true means we have added this element into DSU\\n      seen[idx] = true;\\n      obj.join(idx, idx);\\n        // check left and right for unions\\n      if (idx - 1 >= 0 && seen[idx - 1])\\n          obj.join(idx, idx - 1);\\n      if (idx + 1 < sz && seen[idx + 1])\\n          obj.join(idx, idx + 1);\\n      ans[i] = obj.getMax();\\n    }\\n    return ans;\\n  }\\n};\\n```\\nDo **UPVOTE** IF IT HELPS :)",
                "solutionTags": [],
                "code": "```\\nclass DSU {\\n public:\\n  vector<long> p, rank;\\n  long maxi = 0;\\n  DSU(vector<int>& nums) {\\n    int sz = nums.size();\\n    for (auto& i : nums) rank.push_back(i);\\n    p.resize(sz, 0);\\n    iota(begin(p), end(p), 0);\\n  }\\n  int find(int node) {\\n    if (p[node] == node) return node;\\n    return p[node] = find(p[node]);\\n  }\\n  void join(int x, int y) {\\n    if (x == y) {\\n      maxi = max(maxi, rank[x]);\\n      return;\\n    }\\n    int p1 = find(x), p2 = find(y);\\n    if (rank[p2] > rank[p1]) swap(p2, p1);\\n    p[p2] = p1;\\n    rank[p1] += rank[p2];\\n    maxi = max(maxi, rank[p1]);\\n  }\\n  long getMax() { return maxi; }\\n};\\nclass Solution {\\n public:\\n  vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rem) {\\n    int sz = nums.size();\\n    vector<long long> ans(sz, 0);\\n    DSU obj(nums);\\n    vector<bool> seen(sz, false);\\n    for (int i = sz - 2; i >= 0; i--) {\\n      int idx = rem[i + 1];\\n        // seen [idx] =true means we have added this element into DSU\\n      seen[idx] = true;\\n      obj.join(idx, idx);\\n        // check left and right for unions\\n      if (idx - 1 >= 0 && seen[idx - 1])\\n          obj.join(idx, idx - 1);\\n      if (idx + 1 < sz && seen[idx + 1])\\n          obj.join(idx, idx + 1);\\n      ans[i] = obj.getMax();\\n    }\\n    return ans;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630539,
                "title": "c-easy-to-understand-step-by-step",
                "content": "```\\n#include <vector>\\nusing namespace std;\\n\\nclass UnionFind {\\n    \\npublic:\\n    vector<int> parent;\\n    vector<long long> rank;\\n\\n    UnionFind(size_t sizeInput) {\\n        parent.resize(sizeInput);\\n        iota(parent.begin(), parent.end(), 0);\\n        rank.resize(sizeInput);\\n    }\\n\\n    int findParent(int index) {\\n        if (parent[index] != index) {\\n            parent[index] = findParent(parent[index]);\\n        }\\n        return parent[index];\\n    }\\n\\n    void joinByRank(int indexOne, int indexTwo) {\\n        if (rank[indexOne] >= rank[indexTwo]) {\\n            rank[indexOne] += rank[indexTwo];\\n            parent[indexTwo] = indexOne;\\n        } else {\\n            rank[indexTwo] += rank[indexOne];\\n            parent[indexOne] = indexTwo;\\n        }\\n    }\\n};\\n\\nclass Solution {\\n    \\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        UnionFind unionFind(nums.size());\\n        vector<long long> maxSegmentSum(nums.size());\\n        long currentMax = 0;\\n        \\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            int query = removeQueries[i];\\n            maxSegmentSum[i] = currentMax;\\n            unionFind.rank[query] = nums[query];\\n\\n            if (query - 1 >= 0 && unionFind.rank[query - 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query - 1), unionFind.findParent(query));\\n            }\\n            if (query + 1 < nums.size() && unionFind.rank[query + 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query + 1), unionFind.findParent(query));\\n            }\\n            currentMax = currentMax > unionFind.rank[unionFind.findParent(query)] ?\\n                         currentMax : unionFind.rank[unionFind.findParent(query)];\\n        }\\n        return maxSegmentSum;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n    \\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        UnionFind unionFind(nums.size());\\n        vector<long long> maxSegmentSum(nums.size());\\n        long currentMax = 0;\\n        \\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            int query = removeQueries[i];\\n            maxSegmentSum[i] = currentMax;\\n            unionFind.rank[query] = nums[query];\\n\\n            if (query - 1 >= 0 && unionFind.rank[query - 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query - 1), unionFind.findParent(query));\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2503048,
                "title": "reverse-order",
                "content": "\\nIn this problem we keep dividing the segments till no segment remain.\\nThe largest sum will be identified at each step. No segement will increase, so we will never worry about larger after we have known the largest at any step.\\nThe easy thing is when the largest one is not touched.\\nThe trouble is when the largest one is splitted into small one, we will search the new one. \\nTo hold a sorted list of the segments will be costful. \\n\\nFortunately we know all the steps at the beginning. That mean we can reverse the process. In another word, we merge the segments instead of split them.\\nTo do so, we will always update the largest sum by compare the new one with previous largest one. That means no search is necessary.\\n\\nBased on this we could have tons of ways to record current segments. Hash map, linked list, array are all OK to do that.\\nConsider the effectiveness, array could gives better efficacy in time but worse in memory. Linked list could same some memroy but it will be too expensive to locate proper segment.\\n\\nIn the problem 10^5 let us feel free to choose array.\\n\\nSo what are the necessaary information we will hold during the process?\\n1 the segment information  (include sum, left, right)\\n2 the neighbor relationship \\n\\nTo make more sepcific, let\\'s see what is happening during a merge.\\nI would use [] to identify a segment, and () to identify number that has not been merged in any segment. I will use q as the current one to process merge.\\ncase 1: both left and right neighbor the (q) are segment. ( this is the most important one, as all other cases could be considered as this one with some special values)\\n [start1....end1]    (q)  [start....end2]  \\n after merge \\n [start1....end2]\\n the new sum = sum of left + value of q + sum of right\\n So it is clear that, remember the start, end and sum of the segment is most valueable.\\n[start, end, sum] will be the good structure for a segment.\\nuse list will be so nice in python. Tuple is also a good choose, But I have good reason explained below to pick list. \\n\\nWhere we will we store this information? Or how should the segment information be organized to allow quicker access?\\nList is the best to locate a perticular one when we know its position.\\nFurther more, at each time we are access a segment information, we indeed is trying to merge it with its neighbor. Eighther left neighbor or right one.\\nSo we will store the information in its both bounds. Aside the boundary item, other item will be useless. Though they were. So we will not maintain the lastest information in non-boundary items.\\nIt will looks like this\\n[ [start1, end1, sum1].....[start1, end1, sum1], [start2, end2, sum2] .....  ]\\nIn fact one more information is very important, the status of the position. Is it part of a segment or not.\\nBefore I make the decision, I have tried to just store that as well. \\n[ [start1, end1, sum1, is segment].....[start1, end1, sum1, is segment], [,,,, is not segment], [start2, end2, sum2] .....  ]\\nAny way, we still need to look at other cases that not both nieghbors are segment \\n\\n3 types of cases like these\\n(q2)    (q1)  [start....end2]  \\n [start1....end1]    (q1)  (q2)\\n (q2)   (q1)  (q3)\\n\\nand sepeciallly there are cases when q1 is first item  and the cases q1 is the last one\\n (q1)  [start....end2]  \\n  (q1)  (q2) \\n [start....end2]  (q1)   \\n (q2)  (q1)   \\n \\n It will be easy to just check the q and q-1 and q-2 to know the category it falls into on each step.\\n But that is costfull.\\n In stead, we will have enough tricky to pretent there is only one category.\\n Befire I do all tricky, I write down the pesudo\\n \\n ```\\n left position = left position of left neighbor\\n right position = .right position of right neighbor\\n sum = sum of left + value on merging position + sum of right\\n ```\\n \\n Now it will be clear that, I will need to pretend unmerge neighbor as a empty segment, and also there is a left neighbor on the first item, and as while the last item has a right neighbor.\\n \\n For the left of 0, we already have a very common tricky(feature) that -1 is regard as the last index of an array, so I just simplely add two items at the end of the list. One as the right of last, one as the left or the first.\\n \\n How about the non segment neighbors? While we look closely to the pseudo again\\n  ```\\n  left position = left position of left neighbor \\n  ```\\n  what is the value we expected when there is no left neighbor? \\n  It is the position of q, the current merging item.\\n  How about let the non segment neighbor has a left position like this? \\n  No problem, because no other places will use that value before it has been merged into a segment,\\n  Vice versa for the right beighbor.\\n  \\n so that is clear that I prefer initial all the item as \\n  [q + 1, q - 1, 0]\\n  which means all non segmented item is a segment start from its right and end to its left, that really means EMPTY \\n  Till now it is clear that I will not need a value to state whethere the item is in segment or not. it is juse an EMPTY segment with a ZERO sum.\\n  \\n  With this tricky I get rid of any condition check in the loop. That is almost allways be a sign of efficacy.\\n \\nA NOTE:\\nI have tried to use length of the segment, that also works and not harder to understand, but that make more add and sub operations. It finally is slower than this one. \\nAlso I have tried multiple arraies. Like left: []  right :[] sum:[] . they are proved as slow as while.\\n\\nI would like to consider this is the best solution if we do not concern about memory. Becuase there is no IF. Somehow there is ONE IF hiding insided the max(). and one IF hiding inside [-1] while I would like to say there  is no unnecesary IF.\\n\\n```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:  \\n        b = [[_i + 1, _i - 1, 0] for _i in range(len(nums)) ]  + [[len(nums) - 1, len(nums) - 1, 0], [0, 0, 0]]  # blocks, reverse the schedule of them. turn the problem from \\'divid\\' to \\'union\\' # the last tow items are prepared for the bounds, one for index L, one for index -1, with this tricky items, we will regard the bound items as same as other items\\n        \\n        def u(q):\\n\\t\\t\\t# find out new new left\\n            l = b[q - 1][0]\\n\\t\\t\\t# find out new new right\\n            r = b[q + 1][1]\\n\\t\\t\\t# mark the new left on the new right\\n            b[r][0] = l\\n\\t\\t\\t# do nothing abecause the new right has the same right with the old one\\n\\t\\t\\t# mark the new right on the new left\\n            b[l][1] = r\\n\\t\\t\\t# do nothing because the new left has the same left with the old one\\n\\t\\t\\t# assign new sum on boundary\\n            b[l][2] = b[r][2] = s = nums[q] + b[l][2] + b[r][2] \\n\\t\\t\\t# return new sum \\n            return s \\n        v = 0\\n        res = []\\n        for q in removeQueries[::-1]:\\n\\t\\t\\t# record current max sum as result\\n            res.append(v)\\n            # get new sum of the merged one \\n\\t\\t\\t# and caculate new max sum\\n            v = max(v, u(q))\\n\\t\\t# reverse the result because we have processed in the reversed order\\n        return list(res[::-1])\\n```\\n\\nThe code before optimized. This one is slower. But it clear shows different situations when merge. More understandable without tricky.\\n\\n```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:  \\n        class M: # hold the max sum, as the max will never shrink, no need to worry about it turning smaller\\n            v = 0\\n\\n        def s(x):\\n            M.v = max(M.v, x)\\n        \\n        L_1 = len(nums) - 1# length of numbers minus 1\\n        b = [[_i, _i, _n, False] for _i, _n in enumerate(nums) ]  + [[L_1, L_1, 0, False], [0, 0, 0, False]]  # blocks, reverse the schedule of them. turn the problem from \\'divid\\' to \\'union\\' # the last tow items are prepared for the bounds, one for index L, one for index -1, with this tricky items, we will regard the bound items as same as other items\\n        \\n        def u(q):                 \\n            l,r,s,_ = b[q]\\n            if b[q - 1][3]:\\n                l = b[q - 1][0]\\n                s += b[q - 1][2]\\n            if b[q + 1][3]:\\n                r = b[q + 1][1]\\n                s += b[q + 1][2]\\n            b[l][1] = r\\n            b[r][0] = l\\n            b[l][2] = b[r][2] = s\\n            b[l][3] = b[r][3] = True  \\n            return s \\n        res = []\\n        for q in removeQueries[::-1]:\\n            # get current largest sum\\n            res.append(M.v)\\n            s(u(q))\\n        return list(res[::-1])\\n        \\n        \\n        \\n         \\n```",
                "solutionTags": [],
                "code": "```\\n left position = left position of left neighbor\\n right position = .right position of right neighbor\\n sum = sum of left + value on merging position + sum of right\\n ```\n```\\n  left position = left position of left neighbor \\n  ```\n```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:  \\n        b = [[_i + 1, _i - 1, 0] for _i in range(len(nums)) ]  + [[len(nums) - 1, len(nums) - 1, 0], [0, 0, 0]]  # blocks, reverse the schedule of them. turn the problem from \\'divid\\' to \\'union\\' # the last tow items are prepared for the bounds, one for index L, one for index -1, with this tricky items, we will regard the bound items as same as other items\\n        \\n        def u(q):\\n\\t\\t\\t# find out new new left\\n            l = b[q - 1][0]\\n\\t\\t\\t# find out new new right\\n            r = b[q + 1][1]\\n\\t\\t\\t# mark the new left on the new right\\n            b[r][0] = l\\n\\t\\t\\t# do nothing abecause the new right has the same right with the old one\\n\\t\\t\\t# mark the new right on the new left\\n            b[l][1] = r\\n\\t\\t\\t# do nothing because the new left has the same left with the old one\\n\\t\\t\\t# assign new sum on boundary\\n            b[l][2] = b[r][2] = s = nums[q] + b[l][2] + b[r][2] \\n\\t\\t\\t# return new sum \\n            return s \\n        v = 0\\n        res = []\\n        for q in removeQueries[::-1]:\\n\\t\\t\\t# record current max sum as result\\n            res.append(v)\\n            # get new sum of the merged one \\n\\t\\t\\t# and caculate new max sum\\n            v = max(v, u(q))\\n\\t\\t# reverse the result because we have processed in the reversed order\\n        return list(res[::-1])\\n```\n```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:  \\n        class M: # hold the max sum, as the max will never shrink, no need to worry about it turning smaller\\n            v = 0\\n\\n        def s(x):\\n            M.v = max(M.v, x)\\n        \\n        L_1 = len(nums) - 1# length of numbers minus 1\\n        b = [[_i, _i, _n, False] for _i, _n in enumerate(nums) ]  + [[L_1, L_1, 0, False], [0, 0, 0, False]]  # blocks, reverse the schedule of them. turn the problem from \\'divid\\' to \\'union\\' # the last tow items are prepared for the bounds, one for index L, one for index -1, with this tricky items, we will regard the bound items as same as other items\\n        \\n        def u(q):                 \\n            l,r,s,_ = b[q]\\n            if b[q - 1][3]:\\n                l = b[q - 1][0]\\n                s += b[q - 1][2]\\n            if b[q + 1][3]:\\n                r = b[q + 1][1]\\n                s += b[q + 1][2]\\n            b[l][1] = r\\n            b[r][0] = l\\n            b[l][2] = b[r][2] = s\\n            b[l][3] = b[r][3] = True  \\n            return s \\n        res = []\\n        for q in removeQueries[::-1]:\\n            # get current largest sum\\n            res.append(M.v)\\n            s(u(q))\\n        return list(res[::-1])\\n        \\n        \\n        \\n         \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482092,
                "title": "well-commented-clear-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    using ll = long long;\\n    \\n    ll findSum(int start, int end, vector<ll> &prefixSum) {\\n        if (start == 0) return prefixSum[end];\\n        return prefixSum[end] - prefixSum[start-1];\\n    }\\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        vector<long long> prefixSum(n,nums[0]);\\n        prefixSum[0] = nums[0];\\n        \\n        // compute prefix Sum\\n        for (int i = 1; i < n; i ++)\\n            prefixSum[i] = prefixSum[i-1] + nums[i];\\n        \\n        set<pair<int,int>> segSet;\\n        multiset<ll> sumSet; // multi set as duplicate set sum possible\\n        \\n        \\n        // first Segment is full one as there are all non zero numbers\\n        segSet.insert({0,n-1}); // inserting full segment\\n        sumSet.insert(prefixSum[n-1]); \\n        \\n        vector<ll> result;\\n        // last entry will always resturn 0 so only traverse till n-1\\n        for (int i = 0; i < n-1; i++) {\\n            int rIndex = removeQueries[i];\\n            \\n            // check with set this rIndex belongs to\\n            auto it = segSet.upper_bound({rIndex,rIndex});\\n            \\n            //if this is now at end of the list ie no upper bound found\\n            if (it == segSet.end()) \\n                it--;\\n            else // else check if the landed is not part of the upper boundsegment \\n                if (it->first > rIndex) it--;\\n            \\n            // Now we found the exact set\\n            // now compute the acutal reduction\\n            auto p = *it;\\n            ll value = findSum(p.first,p.second,prefixSum);\\n            // remove this set from the segement list as it will be splitted now\\n            segSet.erase(it);\\n            \\n            //remove the sum of erased segment from set\\n            auto valueIt = sumSet.lower_bound(value);\\n            sumSet.erase(valueIt);\\n            \\n            ll value1 = -1;\\n            ll value2 = -1;\\n            \\n            // if removed index is starting the current set\\n            if (p.first == rIndex) {\\n                segSet.insert({rIndex+1,p.second});\\n                value1 = findSum(rIndex+1,p.second,prefixSum);\\n                \\n            } else if (p.second == rIndex) { \\n                // if removed index is ending the current set\\n                segSet.insert({p.first,rIndex-1});\\n                value2 = findSum(p.first,rIndex-1,prefixSum);\\n                \\n            } else {\\n                // if removed element is middle and splitting the set\\n                segSet.insert({p.first,rIndex-1});\\n                value1 = findSum(p.first,rIndex-1,prefixSum);\\n                segSet.insert({rIndex+1,p.second});\\n                value2 = findSum(rIndex+1,p.second,prefixSum);\\n                \\n            }\\n            \\n            // Insert new found segment set sum\\n            if (value1 != -1) sumSet.insert(value1);\\n            if (value2 != -1) sumSet.insert(value2);\\n            \\n            // append the last element of the sorted set which is current maxiumm\\n            // after new sets has been inserted.\\n            result.push_back(*sumSet.rbegin());\\n        }\\n        \\n        // End result is always 0\\n        result.push_back(0);\\n        return result;\\n    }\\n    \\n\\t```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    using ll = long long;\\n    \\n    ll findSum(int start, int end, vector<ll> &prefixSum) {\\n        if (start == 0) return prefixSum[end];\\n        return prefixSum[end] - prefixSum[start-1];\\n    }\\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        vector<long long> prefixSum(n,nums[0]);\\n        prefixSum[0] = nums[0];\\n        \\n        // compute prefix Sum\\n        for (int i = 1; i < n; i ++)\\n            prefixSum[i] = prefixSum[i-1] + nums[i];\\n        \\n        set<pair<int,int>> segSet;\\n        multiset<ll> sumSet; // multi set as duplicate set sum possible\\n        \\n        \\n        // first Segment is full one as there are all non zero numbers\\n        segSet.insert({0,n-1}); // inserting full segment\\n        sumSet.insert(prefixSum[n-1]); \\n        \\n        vector<ll> result;\\n        // last entry will always resturn 0 so only traverse till n-1\\n        for (int i = 0; i < n-1; i++) {\\n            int rIndex = removeQueries[i];\\n            \\n            // check with set this rIndex belongs to\\n            auto it = segSet.upper_bound({rIndex,rIndex});\\n            \\n            //if this is now at end of the list ie no upper bound found\\n            if (it == segSet.end()) \\n                it--;\\n            else // else check if the landed is not part of the upper boundsegment \\n                if (it->first > rIndex) it--;\\n            \\n            // Now we found the exact set\\n            // now compute the acutal reduction\\n            auto p = *it;\\n            ll value = findSum(p.first,p.second,prefixSum);\\n            // remove this set from the segement list as it will be splitted now\\n            segSet.erase(it);\\n            \\n            //remove the sum of erased segment from set\\n            auto valueIt = sumSet.lower_bound(value);\\n            sumSet.erase(valueIt);\\n            \\n            ll value1 = -1;\\n            ll value2 = -1;\\n            \\n            // if removed index is starting the current set\\n            if (p.first == rIndex) {\\n                segSet.insert({rIndex+1,p.second});\\n                value1 = findSum(rIndex+1,p.second,prefixSum);\\n                \\n            } else if (p.second == rIndex) { \\n                // if removed index is ending the current set\\n                segSet.insert({p.first,rIndex-1});\\n                value2 = findSum(p.first,rIndex-1,prefixSum);\\n                \\n            } else {\\n                // if removed element is middle and splitting the set\\n                segSet.insert({p.first,rIndex-1});\\n                value1 = findSum(p.first,rIndex-1,prefixSum);\\n                segSet.insert({rIndex+1,p.second});\\n                value2 = findSum(rIndex+1,p.second,prefixSum);\\n                \\n            }\\n            \\n            // Insert new found segment set sum\\n            if (value1 != -1) sumSet.insert(value1);\\n            if (value2 != -1) sumSet.insert(value2);\\n            \\n            // append the last element of the sorted set which is current maxiumm\\n            // after new sets has been inserted.\\n            result.push_back(*sumSet.rbegin());\\n        }\\n        \\n        // End result is always 0\\n        result.push_back(0);\\n        return result;\\n    }\\n    \\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 2476435,
                "title": "c-segment-tree-clean-code",
                "content": "This is simply how we find maximal sum segment in an array using Segment tree with slight modification. Since we want the original segment into be divided into parts, We update the division boundary by a large negative value so that this element will never be included in maximal sum segment.\\n\\n```\\n#define ll long long\\nstruct item{\\n      ll sum,pre,suf,seg;\\n};\\n \\nstruct sgmt{\\n  ll n;\\n  vector<item> st;\\n    item NEUTRAL_ELEMENT = {0,0,0,0};\\n    item single(ll v)\\n    {\\n            item ret;\\n            ret.sum = v;\\n            ret.pre = max(0ll,v);\\n            ret.suf = max(0ll,v);\\n            ret.seg = max(0ll,v);\\n            return ret;\\n    }\\n    sgmt(int _n){                                                 //update\\n            n = _n;           \\n            st.resize(4*n,NEUTRAL_ELEMENT);                    \\n    }\\n \\n    item merge(item a,item b)                                     //update \\n    {\\n           item res;\\n           res.pre = max(a.pre,a.sum + b.pre);\\n           res.suf = max(b.suf,b.sum + a.suf);\\n           res.seg = max(max(a.seg,b.seg),a.suf + b.pre);\\n           res.sum = a.sum + b.sum;\\n           return res;\\n    }\\n    \\n    void build(int si, int ei, int node, vector<ll>&v){\\n        if(si==ei){\\n            st[node] = single(v[si]);                              //check\\n            return;\\n        }\\n        int mid = (si+ei)/2;\\n        build(si,mid,node*2+1,v);\\n        build(mid+1,ei,node*2+2,v);\\n        st[node] = merge(st[node*2+1],st[node*2+2]);\\n    }\\n \\n    item query(int si,int ei,int node, int l, int r){\\n        if(r<si or l>ei) return NEUTRAL_ELEMENT;\\n        if(l<=si and r>=ei) return st[node];\\n        int mid = (si+ei)/2;\\n        item q1 = query(si,mid,node*2+1,l,r);\\n        item q2 = query(mid+1,ei,node*2+2,l,r);\\n        return merge(q1,q2);\\n    }\\n    \\n    void update(int si, int ei,int node,int idx, ll val){\\n        if(si==ei){\\n            st[node]= single(val);                                    //update the value\\n            return;\\n        }\\n        int mid = (si+ei)/2;\\n        if(idx<=mid) {\\n            update(si,mid,node*2+1,idx,val);\\n        }\\n        else{\\n            update(mid+1,ei,node*2+2,idx,val);\\n        }\\n        st[node] = merge(st[node*2+1],st[node*2+2]);\\n    }\\n    item query(ll l, ll r){\\n      return query(0,n-1,0,l,r);                                 //print whatever required\\n      \\n    }\\n    void build(vector<ll>&v){\\n        \\n        build(0,n-1,0,v);\\n    }\\n    void update(ll idx,ll val){\\n        update(0,n-1,0,idx,val);\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nu, vector<int>& re) {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n     sgmt s(nu.size());\\n        vector<ll> nums(nu.begin(),nu.end());\\n        s.build(nums);\\n        vector<ll> ans;\\n        for(int i = 0;i<re.size();i++){\\n            s.update(re[i],-1e14+1e13);\\n            ans.push_back(s.query(0,nu.size()).seg);\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n#define ll long long\\nstruct item{\\n      ll sum,pre,suf,seg;\\n};\\n \\nstruct sgmt{\\n  ll n;\\n  vector<item> st;\\n    item NEUTRAL_ELEMENT = {0,0,0,0};\\n    item single(ll v)\\n    {\\n            item ret;\\n            ret.sum = v;\\n            ret.pre = max(0ll,v);\\n            ret.suf = max(0ll,v);\\n            ret.seg = max(0ll,v);\\n            return ret;\\n    }\\n    sgmt(int _n){                                                 //update\\n            n = _n;           \\n            st.resize(4*n,NEUTRAL_ELEMENT);                    \\n    }\\n \\n    item merge(item a,item b)                                     //update \\n    {\\n           item res;\\n           res.pre = max(a.pre,a.sum + b.pre);\\n           res.suf = max(b.suf,b.sum + a.suf);\\n           res.seg = max(max(a.seg,b.seg),a.suf + b.pre);\\n           res.sum = a.sum + b.sum;\\n           return res;\\n    }\\n    \\n    void build(int si, int ei, int node, vector<ll>&v){\\n        if(si==ei){\\n            st[node] = single(v[si]);                              //check\\n            return;\\n        }\\n        int mid = (si+ei)/2;\\n        build(si,mid,node*2+1,v);\\n        build(mid+1,ei,node*2+2,v);\\n        st[node] = merge(st[node*2+1],st[node*2+2]);\\n    }\\n \\n    item query(int si,int ei,int node, int l, int r){\\n        if(r<si or l>ei) return NEUTRAL_ELEMENT;\\n        if(l<=si and r>=ei) return st[node];\\n        int mid = (si+ei)/2;\\n        item q1 = query(si,mid,node*2+1,l,r);\\n        item q2 = query(mid+1,ei,node*2+2,l,r);\\n        return merge(q1,q2);\\n    }\\n    \\n    void update(int si, int ei,int node,int idx, ll val){\\n        if(si==ei){\\n            st[node]= single(val);                                    //update the value\\n            return;\\n        }\\n        int mid = (si+ei)/2;\\n        if(idx<=mid) {\\n            update(si,mid,node*2+1,idx,val);\\n        }\\n        else{\\n            update(mid+1,ei,node*2+2,idx,val);\\n        }\\n        st[node] = merge(st[node*2+1],st[node*2+2]);\\n    }\\n    item query(ll l, ll r){\\n      return query(0,n-1,0,l,r);                                 //print whatever required\\n      \\n    }\\n    void build(vector<ll>&v){\\n        \\n        build(0,n-1,0,v);\\n    }\\n    void update(ll idx,ll val){\\n        update(0,n-1,0,idx,val);\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nu, vector<int>& re) {\\n        ios_base::sync_with_stdio(0);\\n        cin.tie(0);\\n        cout.tie(0);\\n     sgmt s(nu.size());\\n        vector<ll> nums(nu.begin(),nu.end());\\n        s.build(nums);\\n        vector<ll> ans;\\n        for(int i = 0;i<re.size();i++){\\n            s.update(re[i],-1e14+1e13);\\n            ans.push_back(s.query(0,nu.size()).seg);\\n        }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2475939,
                "title": "python-3-union-find",
                "content": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        res = [0] * n\\n        parent = [i for i in range(n)]\\n        rank = [0] * n\\n        sums = [0] * n\\n        \\n        def union(i, j):\\n            i, j = find(i), find(j)\\n            if rank[i] < rank[j]:\\n                i, j = j, i       \\n            parent[j] = i\\n            rank[i] += rank[j]\\n            sums[i] += sums[j]\\n        \\n        def find(i):\\n            while i != parent[i]:\\n                parent[i] = i = parent[parent[i]]\\n            return i\\n        \\n        for i in range(n - 1, 0, -1):\\n            j = removeQueries[i]\\n            sums[j] = nums[j]\\n            if j and sums[j - 1]:\\n                union(j, j - 1)\\n            if j != n - 1 and sums[j + 1]:\\n                union(j, j + 1)\\n            res[i - 1] = max(res[i], sums[find(j)])\\n        \\n        return res\\n",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        res = [0] * n\\n        parent = [i for i in range(n)]\\n        rank = [0] * n\\n        sums = [0] * n\\n        \\n        def union(i, j):\\n            i, j = find(i), find(j)\\n            if rank[i] < rank[j]:\\n                i, j = j, i       \\n            parent[j] = i\\n            rank[i] += rank[j]\\n            sums[i] += sums[j]\\n        \\n        def find(i):\\n            while i != parent[i]:\\n                parent[i] = i = parent[parent[i]]\\n            return i\\n        \\n        for i in range(n - 1, 0, -1):\\n            j = removeQueries[i]\\n            sums[j] = nums[j]\\n            if j and sums[j - 1]:\\n                union(j, j - 1)\\n            if j != n - 1 and sums[j + 1]:\\n                union(j, j + 1)\\n            res[i - 1] = max(res[i], sums[find(j)])\\n        \\n        return res\\n",
                "codeTag": "Java"
            },
            {
                "id": 2468394,
                "title": "c-sets-multiset-prefix-sum-code",
                "content": "Please find the solution to the problem below : )\\nIt was more like caring of indexes. So used prefix array of size greater than size of nums, such that not to cause confusion while finding sums between segments. \\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& remQ) {\\n        int n = nums.size();\\n        vector<long long> prefSum(n+2, 0), ans;\\n        for(int i = 0; i < n;i++){\\n            prefSum[i+1] += prefSum[i] + nums[i];\\n        }\\n        set<int> s;\\n        multiset<long long> ms; // for storing max segment sum\\n        ms.insert(prefSum[n]);\\n        s.insert(0); \\n        s.insert(n+1);\\n        for(int i =0 ; i < remQ.size(); i++){\\n            long long curInd = remQ[i];\\n            curInd++;\\n            long long left = s.lower_bound(curInd) != s.begin() ? *(prev(s.lower_bound(curInd))) : *s.begin();\\n            long long right = s.lower_bound(curInd) != s.end() ? *s.lower_bound(curInd) : *s.rbegin();\\n            long long curSum = prefSum[right-1] - prefSum[left];\\n            long long leftSum = prefSum[curInd-1] - prefSum[left];\\n            long long rightSum = prefSum[right-1] - prefSum[curInd];\\n\\t\\t\\tms.erase(ms.find(curSum));\\n            ms.insert(leftSum);\\n            ms.insert(rightSum);\\n            s.insert(curInd);\\n            ans.push_back(*ms.rbegin());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& remQ) {\\n        int n = nums.size();\\n        vector<long long> prefSum(n+2, 0), ans;\\n        for(int i = 0; i < n;i++){\\n            prefSum[i+1] += prefSum[i] + nums[i];\\n        }\\n        set<int> s;\\n        multiset<long long> ms; // for storing max segment sum\\n        ms.insert(prefSum[n]);\\n        s.insert(0); \\n        s.insert(n+1);\\n        for(int i =0 ; i < remQ.size(); i++){\\n            long long curInd = remQ[i];\\n            curInd++;\\n            long long left = s.lower_bound(curInd) != s.begin() ? *(prev(s.lower_bound(curInd))) : *s.begin();\\n            long long right = s.lower_bound(curInd) != s.end() ? *s.lower_bound(curInd) : *s.rbegin();\\n            long long curSum = prefSum[right-1] - prefSum[left];\\n            long long leftSum = prefSum[curInd-1] - prefSum[left];\\n            long long rightSum = prefSum[right-1] - prefSum[curInd];\\n\\t\\t\\tms.erase(ms.find(curSum));\\n            ms.insert(leftSum);\\n            ms.insert(rightSum);\\n            s.insert(curInd);\\n            ans.push_back(*ms.rbegin());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468095,
                "title": "python-2-solution-o-n-union-find-and-o-nlogn-sorteddict",
                "content": "(1)\\n```\\nclass Uni:\\n    def __init__(self, n):\\n        self.rep = list(range(n))\\n        self.val = [0] * n\\n    \\n    def find(self, x):\\n        if self.rep[x] != x: self.rep[x] = self.find(self.rep[x])\\n        return self.rep[x]\\n\\n    def merge(self, x, y):\\n        x, y = self.find(x), self.find(y)\\n        if x != y:\\n            x, y = min(x, y), max(x, y)\\n            self.rep[y] = x\\n            self.val[x] += self.val[y]\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        ans, uni, curmax = [], Uni(n), 0\\n        for idx in removeQueries[::-1]:\\n            ans.append(curmax)\\n            uni.val[idx] = nums[idx]\\n            if idx > 0 and uni.val[idx - 1]: uni.merge(idx - 1, idx)\\n            if idx + 1 < n and uni.val[idx + 1]: uni.merge(idx + 1, idx)\\n            curmax = max(curmax, uni.val[uni.find(idx)])\\n        return ans[::-1]\\n```\\n(2)\\n```\\nfrom sortedcontainers import SortedDict\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        presum =[0] * (n + 1)\\n        for i in range(n): presum[i + 1] = presum[i] + nums[i]\\n        rng2v, v2rng = SortedDict({(0, n - 1): presum[n]}), SortedDict({presum[n] : {(0, n - 1)}})\\n        ans = []\\n        for idx in removeQueries:\\n            pos = min(rng2v.bisect_left((idx, idx)), len(rng2v) - 1)\\n            if not (rng2v.iloc[pos][0] <= idx <= rng2v.iloc[pos][1]): pos -= 1\\n            (left, right), val = rng2v.popitem(pos)\\n            v2rng[val].remove((left, right))\\n            if not v2rng[val]: v2rng.pop(val)\\n            if left < idx:\\n                lv = presum[idx] - presum[left]\\n                rng2v[(left, idx - 1)] = lv\\n                if lv not in v2rng: v2rng[lv] = set()\\n                v2rng[lv].add((left, idx - 1))\\n            if idx < right:\\n                rv = presum[right + 1] - presum[idx + 1]\\n                rng2v[(idx + 1, right)] = rv\\n                if rv not in v2rng: v2rng[rv] = set()\\n                v2rng[rv].add((idx + 1, right))\\n            ans.append(v2rng.iloc[-1] if v2rng else 0)\\n        return ans\\n```",
                "solutionTags": [],
                "code": "```\\nclass Uni:\\n    def __init__(self, n):\\n        self.rep = list(range(n))\\n        self.val = [0] * n\\n    \\n    def find(self, x):\\n        if self.rep[x] != x: self.rep[x] = self.find(self.rep[x])\\n        return self.rep[x]\\n\\n    def merge(self, x, y):\\n        x, y = self.find(x), self.find(y)\\n        if x != y:\\n            x, y = min(x, y), max(x, y)\\n            self.rep[y] = x\\n            self.val[x] += self.val[y]\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        ans, uni, curmax = [], Uni(n), 0\\n        for idx in removeQueries[::-1]:\\n            ans.append(curmax)\\n            uni.val[idx] = nums[idx]\\n            if idx > 0 and uni.val[idx - 1]: uni.merge(idx - 1, idx)\\n            if idx + 1 < n and uni.val[idx + 1]: uni.merge(idx + 1, idx)\\n            curmax = max(curmax, uni.val[uni.find(idx)])\\n        return ans[::-1]\\n```\n```\\nfrom sortedcontainers import SortedDict\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        presum =[0] * (n + 1)\\n        for i in range(n): presum[i + 1] = presum[i] + nums[i]\\n        rng2v, v2rng = SortedDict({(0, n - 1): presum[n]}), SortedDict({presum[n] : {(0, n - 1)}})\\n        ans = []\\n        for idx in removeQueries:\\n            pos = min(rng2v.bisect_left((idx, idx)), len(rng2v) - 1)\\n            if not (rng2v.iloc[pos][0] <= idx <= rng2v.iloc[pos][1]): pos -= 1\\n            (left, right), val = rng2v.popitem(pos)\\n            v2rng[val].remove((left, right))\\n            if not v2rng[val]: v2rng.pop(val)\\n            if left < idx:\\n                lv = presum[idx] - presum[left]\\n                rng2v[(left, idx - 1)] = lv\\n                if lv not in v2rng: v2rng[lv] = set()\\n                v2rng[lv].add((left, idx - 1))\\n            if idx < right:\\n                rv = presum[right + 1] - presum[idx + 1]\\n                rng2v[(idx + 1, right)] = rv\\n                if rv not in v2rng: v2rng[rv] = set()\\n                v2rng[rv].add((idx + 1, right))\\n            ans.append(v2rng.iloc[-1] if v2rng else 0)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2464837,
                "title": "golang-union-find",
                "content": "```\\nfunc maximumSegmentSum(nums []int, removeQueries []int) []int64 {\\n\\tN := len(nums)\\n\\n    // array for Union Find DS\\n\\tdata := make([]int, N)\\n\\tfor i := 0; i < N; i++ {\\n\\t\\tdata[i] = -1\\n\\t}\\n    // array for result\\n\\tres := make([]int64, N)\\n\\t// array for segments sizes\\n    segs := make([]int, N)\\n\\n    // current size of biggest segment\\n\\tmaxSeg := 0\\n\\n    // starting from end\\n\\tfor i := N - 1; i >= 0; i-- {\\n\\t\\tquery := removeQueries[i]\\n        // initial segment size\\n\\t\\tsegs[query] = nums[query]\\n        \\n\\t\\tdata[query] = query\\n        \\n        // check if we can join our segment from left side\\n\\t\\tif query > 0 {\\n\\t\\t\\tl := data[query-1]\\n\\t\\t\\tif l >= 0 {\\n\\t\\t\\t\\tleftSeg := find(data, query-1)\\n\\t\\t\\t\\tdata[leftSeg] = query // union\\n\\t\\t\\t\\tsegs[query] += segs[leftSeg] // increase segment\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n        // check if we can join our segment from right side\\n\\t\\tif query < N-1 {\\n\\t\\t\\tr := data[query+1]\\n\\t\\t\\tif r >= 0 {\\n\\t\\t\\t\\trightSeg := find(data, query+1)\\n\\t\\t\\t\\tdata[rightSeg] = query // union\\n\\t\\t\\t\\tsegs[query] += segs[rightSeg] // increase segment\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\tres[i] = int64(maxSeg)\\n        \\n        // increase max segment if possible\\n\\t\\tmaxSeg = max(maxSeg, segs[query])\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc find(data []int, pos int) int {\\n\\tfor data[pos] != pos {\\n\\t\\tpos = data[pos]\\n\\t}\\n\\treturn pos\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Union Find"
                ],
                "code": "```\\nfunc maximumSegmentSum(nums []int, removeQueries []int) []int64 {\\n\\tN := len(nums)\\n\\n    // array for Union Find DS\\n\\tdata := make([]int, N)\\n\\tfor i := 0; i < N; i++ {\\n\\t\\tdata[i] = -1\\n\\t}\\n    // array for result\\n\\tres := make([]int64, N)\\n\\t// array for segments sizes\\n    segs := make([]int, N)\\n\\n    // current size of biggest segment\\n\\tmaxSeg := 0\\n\\n    // starting from end\\n\\tfor i := N - 1; i >= 0; i-- {\\n\\t\\tquery := removeQueries[i]\\n        // initial segment size\\n\\t\\tsegs[query] = nums[query]\\n        \\n\\t\\tdata[query] = query\\n        \\n        // check if we can join our segment from left side\\n\\t\\tif query > 0 {\\n\\t\\t\\tl := data[query-1]\\n\\t\\t\\tif l >= 0 {\\n\\t\\t\\t\\tleftSeg := find(data, query-1)\\n\\t\\t\\t\\tdata[leftSeg] = query // union\\n\\t\\t\\t\\tsegs[query] += segs[leftSeg] // increase segment\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n        // check if we can join our segment from right side\\n\\t\\tif query < N-1 {\\n\\t\\t\\tr := data[query+1]\\n\\t\\t\\tif r >= 0 {\\n\\t\\t\\t\\trightSeg := find(data, query+1)\\n\\t\\t\\t\\tdata[rightSeg] = query // union\\n\\t\\t\\t\\tsegs[query] += segs[rightSeg] // increase segment\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\tres[i] = int64(maxSeg)\\n        \\n        // increase max segment if possible\\n\\t\\tmaxSeg = max(maxSeg, segs[query])\\n\\t}\\n\\n\\treturn res\\n}\\n\\nfunc find(data []int, pos int) int {\\n\\tfor data[pos] != pos {\\n\\t\\tpos = data[pos]\\n\\t}\\n\\treturn pos\\n}\\n\\nfunc max(a, b int) int {\\n\\tif a > b {\\n\\t\\treturn a\\n\\t}\\n\\treturn b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2464491,
                "title": "javascript-union-find",
                "content": "Inspired by [hiepit\\'s Python solution](https://leetcode.com/problems/maximum-segment-sum-after-removals/discuss/2461035/Python-Reverse-Union-Find-Clean-and-Concise)\\n```\\nclass UnionFind {\\n    constructor() {\\n        this.par = new Map()\\n        this.segmentSums = new Map()\\n        this.max = 0\\n    }\\n    \\n    addNumAndMergeSegments(i, num) {\\n        this.par[i] = i\\n        this.segmentSums[i] = num\\n        this.max = Math.max(this.max, num)\\n        if (i-1 in this.par)\\n            this.union(i, i-1)\\n        if (i+1 in this.par)\\n            this.union(i, i+1)\\n    }\\n    \\n    find(x) {\\n        return x == this.par[x] ? x : this.find(this.par[x])\\n    }\\n    \\n    union(x, y) {\\n        const xPar = this.find(x)\\n        const yPar = this.find(y)\\n        if (xPar == yPar) return\\n        this.segmentSums[xPar] += this.segmentSums[yPar]\\n        this.par[yPar] = this.par[xPar]\\n        this.max = Math.max(this.max, this.segmentSums[xPar])\\n    }\\n    \\n}\\n\\nconst maximumSegmentSum = (nums, removeQueries) => {\\n    const N = nums.length\\n    const uf = new UnionFind()\\n    const ans = new Array(N)\\n    \\n    for (let i = N-1; i >= 0; i--) {\\n        ans[i] = uf.max\\n        const numsIdx = removeQueries[i]\\n        uf.addNumAndMergeSegments(numsIdx, nums[numsIdx])\\n    }\\n    \\n    return ans\\n}",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "Inspired by [hiepit\\'s Python solution](https://leetcode.com/problems/maximum-segment-sum-after-removals/discuss/2461035/Python-Reverse-Union-Find-Clean-and-Concise)\\n```\\nclass UnionFind {\\n    constructor() {\\n        this.par = new Map()\\n        this.segmentSums = new Map()\\n        this.max = 0\\n    }\\n    \\n    addNumAndMergeSegments(i, num) {\\n        this.par[i] = i\\n        this.segmentSums[i] = num\\n        this.max = Math.max(this.max, num)\\n        if (i-1 in this.par)\\n            this.union(i, i-1)\\n        if (i+1 in this.par)\\n            this.union(i, i+1)\\n    }\\n    \\n    find(x) {\\n        return x == this.par[x] ? x : this.find(this.par[x])\\n    }\\n    \\n    union(x, y) {\\n        const xPar = this.find(x)\\n        const yPar = this.find(y)\\n        if (xPar == yPar) return\\n        this.segmentSums[xPar] += this.segmentSums[yPar]\\n        this.par[yPar] = this.par[xPar]\\n        this.max = Math.max(this.max, this.segmentSums[xPar])\\n    }\\n    \\n}\\n\\nconst maximumSegmentSum = (nums, removeQueries) => {\\n    const N = nums.length\\n    const uf = new UnionFind()\\n    const ans = new Array(N)\\n    \\n    for (let i = N-1; i >= 0; i--) {\\n        ans[i] = uf.max\\n        const numsIdx = removeQueries[i]\\n        uf.addNumAndMergeSegments(numsIdx, nums[numsIdx])\\n    }\\n    \\n    return ans\\n}",
                "codeTag": "Java"
            },
            {
                "id": 2464170,
                "title": "reverse-union-find-o-n-python",
                "content": "Instead of removing each element , create the original array by adding elements in the reverse order of removing elements.\\n```\\nclass Solution(object):\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type removeQueries: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        def findParent(i):\\n            cur=i\\n            while parent[cur]!=cur:\\n                cur=parent[cur]\\n            parent[i]=cur\\n            return cur\\n        \\n        def union(u,v):\\n            uParent=findParent(u)\\n            vParent=findParent(v)\\n            if rank[uParent]<rank[vParent]:\\n                parent[uParent]=vParent\\n                segmentSum[vParent]+=segmentSum[uParent]\\n            elif rank[uParent]>rank[vParent]:\\n                parent[vParent]=uParent\\n                segmentSum[uParent]+=segmentSum[vParent]\\n            else:\\n                parent[vParent]=uParent\\n                rank[uParent]+=1\\n                segmentSum[uParent]+=segmentSum[vParent]\\n\\t\\t\\t\\t\\n        n=len(nums)\\n        parent=[i for i in range(n)]\\n        # store sum of segment having element at index i as parent\\n        segmentSum=[0]*n\\n        rank=[0]*n\\n        ans=[0]*n\\n        maxSegmentSum=0\\n        for j in range(n-1,-1,-1):\\n            # index of element to add\\n            idx=removeQueries[j]\\n            # creat a new segment with single element at idx\\n            segmentSum[idx]=nums[idx]\\n            if idx>0 and segmentSum[idx-1]>0:\\n                # element at index idx-1 has been added already so merge \\n                union(idx,idx-1)\\n            if idx<n-1 and segmentSum[idx+1]>0:\\n                # element at index idx+1 has been added already so merge \\n                union(idx,idx+1)\\n            ans[j]=maxSegmentSum\\n            maxSegmentSum=max(maxSegmentSum,segmentSum[findParent(idx)])\\n        return ans\\n```\\nTime complexity - O(N) (since Union By Rank and Path Compression reduce time complexity of union(u,v) and findParent(i) to constant)\\nSpace complexity - O(N)",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution(object):\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        \"\"\"\\n        :type nums: List[int]\\n        :type removeQueries: List[int]\\n        :rtype: List[int]\\n        \"\"\"\\n        \\n        def findParent(i):\\n            cur=i\\n            while parent[cur]!=cur:\\n                cur=parent[cur]\\n            parent[i]=cur\\n            return cur\\n        \\n        def union(u,v):\\n            uParent=findParent(u)\\n            vParent=findParent(v)\\n            if rank[uParent]<rank[vParent]:\\n                parent[uParent]=vParent\\n                segmentSum[vParent]+=segmentSum[uParent]\\n            elif rank[uParent]>rank[vParent]:\\n                parent[vParent]=uParent\\n                segmentSum[uParent]+=segmentSum[vParent]\\n            else:\\n                parent[vParent]=uParent\\n                rank[uParent]+=1\\n                segmentSum[uParent]+=segmentSum[vParent]\\n\\t\\t\\t\\t\\n        n=len(nums)\\n        parent=[i for i in range(n)]\\n        # store sum of segment having element at index i as parent\\n        segmentSum=[0]*n\\n        rank=[0]*n\\n        ans=[0]*n\\n        maxSegmentSum=0\\n        for j in range(n-1,-1,-1):\\n            # index of element to add\\n            idx=removeQueries[j]\\n            # creat a new segment with single element at idx\\n            segmentSum[idx]=nums[idx]\\n            if idx>0 and segmentSum[idx-1]>0:\\n                # element at index idx-1 has been added already so merge \\n                union(idx,idx-1)\\n            if idx<n-1 and segmentSum[idx+1]>0:\\n                # element at index idx+1 has been added already so merge \\n                union(idx,idx+1)\\n            ans[j]=maxSegmentSum\\n            maxSegmentSum=max(maxSegmentSum,segmentSum[findParent(idx)])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456815,
                "title": "c-union-find-traverse-query-from-backwards",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int find(ll i,vector<ll> &par){\\n        if(par[i]==i) return i;\\n        return par[i]=find(par[i],par);\\n    }\\n    void merge(ll a,ll b,vector<ll> &par,vector<ll> &rank){\\n        a=find(a,par);\\n        b=find(b,par);\\n        if(a==b) return;\\n        if(rank[a]>=rank[b]){\\n            rank[a]+=rank[b];\\n            par[b]=a;\\n        }else{\\n            rank[b]+=rank[a];\\n            par[a]=b;\\n        }return;\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& v, vector<int>& q) {\\n        map<ll,ll> m;\\n        int n=v.size();\\n        vector<ll> ans;\\n        reverse(q.begin(),q.end());\\n        ans.push_back(0);\\n        if(n==1) return ans;\\n        ans.push_back(v[q[0]]);\\n        m[q[0]]++;\\n        vector<ll> par(n),rank(n,0);\\n        for(int i=0;i<n;i++){\\n            par[i]=i;\\n            rank[i]=v[i];\\n        }\\n        ll maxi=v[q[0]];\\n        for(int i=1;i<n-1;i++){\\n            ll a=q[i];\\n            if(m.find(a-1)!=m.end()){\\n                merge(a-1,a,par,rank);\\n                ll p=find(a,par);\\n                maxi=max({maxi,rank[p]});\\n            }\\n            if(m.find(a+1)!=m.end()){\\n                merge(a+1,a,par,rank);\\n                ll p=find(a,par);\\n                maxi=max({maxi,rank[p]});\\n            }\\n            m[a]++;\\n            maxi=max(maxi,(ll)v[q[i]]);\\n            ans.push_back(maxi);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};``\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    int find(ll i,vector<ll> &par){\\n        if(par[i]==i) return i;\\n        return par[i]=find(par[i],par);\\n    }\\n    void merge(ll a,ll b,vector<ll> &par,vector<ll> &rank){\\n        a=find(a,par);\\n        b=find(b,par);\\n        if(a==b) return;\\n        if(rank[a]>=rank[b]){\\n            rank[a]+=rank[b];\\n            par[b]=a;\\n        }else{\\n            rank[b]+=rank[a];\\n            par[a]=b;\\n        }return;\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& v, vector<int>& q) {\\n        map<ll,ll> m;\\n        int n=v.size();\\n        vector<ll> ans;\\n        reverse(q.begin(),q.end());\\n        ans.push_back(0);\\n        if(n==1) return ans;\\n        ans.push_back(v[q[0]]);\\n        m[q[0]]++;\\n        vector<ll> par(n),rank(n,0);\\n        for(int i=0;i<n;i++){\\n            par[i]=i;\\n            rank[i]=v[i];\\n        }\\n        ll maxi=v[q[0]];\\n        for(int i=1;i<n-1;i++){\\n            ll a=q[i];\\n            if(m.find(a-1)!=m.end()){\\n                merge(a-1,a,par,rank);\\n                ll p=find(a,par);\\n                maxi=max({maxi,rank[p]});\\n            }\\n            if(m.find(a+1)!=m.end()){\\n                merge(a+1,a,par,rank);\\n                ll p=find(a,par);\\n                maxi=max({maxi,rank[p]});\\n            }\\n            m[a]++;\\n            maxi=max(maxi,(ll)v[q[i]]);\\n            ans.push_back(maxi);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n        \\n    }\\n};``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456030,
                "title": "java-treeset-treemap-o-nlogn",
                "content": "\\n\\n**Observations:**\\n1. Removing a number at index `i` from `nums` essentially partitions `nums` into two intervals -- the numbers before `i` and the numbers after `i`;\\n\\t- e.g., nums = [0,1,2,3,4,5,6,7,8]: removing `3` will result into two intervals: `[0,1,2]` and `[4,5,6,7,8]`\\n2. Since we have multiple removing operations, each removing operation will `erase` one of the existing intervals and create two new sub-intervals;\\n\\t- e.g., intervals = `[[0,1,2], [4,5,6,7,8]]`, and after removing `6` the intervals becomes `[[0,1,2],[4,5],[7,8]]`\\n3. Each index can belong to ***exactly one*** interval.\\n\\n**With these observations, we can simulate the question step by step:**\\n1. Keep track of the *boundary indices* of the `intervals` after each removal operation. \\n\\t- Initially, there should be only one interval: `[[0, n - 1]]`;\\n\\t- After removing idx `3`, the intervals will become `[[0, 2], [4, n - 1]]`\\n2. For each removal operation that to remove the num at index `i`, identify the interval, `[start, end]`, to which `i` belongs (there could be exactly one interval it belongs to);\\n3. Erase the interval `[start, end]` from `intervals`, and insert two new intervals: `[start, i -1]` and `[i + 1, end]`;\\n4. find the maximum ***range sum*** among all the `intervals` we have so far.\\n\\t- i.e., we need to find the maximum range sum amoung the intervals `[[0, a], [a + 1, b], ...., [c + 1, start - 1], [start, i - 1], [i + 1, end], [end + 1, ...], ..., [z + 1, end]]`\\n\\n\\n**Use proper algorithms and data structures to implement the simulation**:\\n1. In simulation step 2, we need to find a way to identify the interval that the current removing index, `i`, belongs to. If removing `i` is the first operation, then clearly, the interval `i` belongs to is `[0, n -1]`. On the other hand, if removing `i` is not the first operation, then the interval `i` belongs to really depends on the indices those previous operations remove. <br/>\\n**Formally, we need a way to find an index pair, `(lower, upper)`, so that `lower` is the  largest  index < i that has been removed, while `upper` is the smallest  index > i that has been removed. The interval [lower + 1,upper - 1] is then the interval that `i` belongs to**. <br/>\\nBy storing all previously-removed indices in a **TreeSet**, we can use O(logN) time to find `lower` and `upper`, respectively.\\n2. With the use of `TreeSet`, we don\\'t need to store all the intervals as specified in simulation step 3. Rather, **the intervals are the gap between every two consecutive indices in the `TreeSet`.**\\n3. Though we don\\'t need to store the actual intervals, we still need to store the range sum for all intervals and get the maximum range sum, as specified in simulation step 4. When creating a new interval, we calculate, and it\\'s range sum; When erasing an existing interval, we discard it\\'s range sum. <br/> \\nThe key is, **we don\\'t need to know the mapping between an interval and it\\'s range-sum, or vice versa**. We only want to know the *values* of the range sum, to calculate the maximum value accordingly. Also, **we will always create an interval before erasing it at some later point**. <br/>\\nNow things are clear. Our requirements are: \\n\\t- Add a range sum val when a new interval is created  -- clearly, the vals might be duplicated\\n\\t- Remove a range sum val when an existing interval is erased\\n\\t- Get maximum range sum val<br/>\\n\\n\\tBy storing all previously-created intervals\\' range sum in the `TreeMap`, we can use O(logN) time to perform all three operations above.\\n4. Don\\'t forget the corner cases:\\n- When identifying the interval that `i` belongs to, what if there is no previously-removed index, `start`, which is smaller than `i`?\\n- Similarly, when identifying the interval that `i` belongs to, what if there is no previously-removed index, `end`, which is larger than `i`?\\n- Can `start == i` or `i == end`? \\n- How about `start + 1 == i` or `i == end - 1`?<br/>\\n\\tI will leave these questions open :-) Ask yourself before jumping to my code! <br/><br/><br/><br/><br/><br/><br/><br/><br/><br/>\\n\\t\\n\\t\\n**Code**\\n\\n```java\\nclass Solution {\\n  \\n  public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n    long[] prefixSum = getPrefixSum(nums);\\n    \\n    TreeSet<Integer> removed = new TreeSet<>();\\n    TreeMap<Long, Integer> rangeSumCnts = new TreeMap<>();\\n    rangeSumCnts.put(getRangeSumInclusive(prefixSum, 0, nums.length - 1), 1);\\n    \\n    long[] res = new long[removeQueries.length];\\n    for (int i = 0; i < removeQueries.length - 1; i++) {\\n      int idx = removeQueries[i];\\n      \\n      Integer lowerBound = getLowerBound(removed, idx);\\n      Integer upperBound = getUpperBound(removed, idx);\\n\\n      updateRangeSum(rangeSumCnts, prefixSum, nums.length, lowerBound, upperBound, idx);\\n      res[i] = getMax(rangeSumCnts);\\n      \\n      removed.add(idx);\\n    }\\n    \\n    return res;\\n  }\\n  \\n  private long[] getPrefixSum(int[] nums) {\\n    long[] prefixSum = new long[nums.length + 1];\\n    for (int i = 1; i <= nums.length; i++) {\\n      prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n    }\\n    return prefixSum;\\n  }\\n  \\n  private Integer getLowerBound(TreeSet<Integer> removed, int idx) {\\n    return removed.floor(idx);\\n  }\\n  \\n  private Integer getUpperBound(TreeSet<Integer> removed, int idx) {\\n    return removed.ceiling(idx);\\n  }\\n  \\n  private void updateRangeSum(TreeMap<Long, Integer> rangeSumCnts, long[] prefixSum, int n, Integer lowerBound, Integer upperBound, int idx) {\\n    if (lowerBound == null) {\\n      lowerBound = -1;\\n    }\\n    if (upperBound == null) {\\n      upperBound = n;\\n    }\\n    // assert: rangeSum[lowerBound + 1 : upperBound - 1] must have been recored in the rangeSumCnts\\n    removeRangeSum(rangeSumCnts, getRangeSumInclusive(prefixSum, lowerBound + 1, upperBound - 1));\\n    \\n    if (idx - 1 >= lowerBound + 1) {\\n      addRangeSum(rangeSumCnts, getRangeSumInclusive(prefixSum, lowerBound + 1, idx - 1));  \\n    }\\n    if (idx + 1 <= upperBound - 1) {\\n      addRangeSum(rangeSumCnts, getRangeSumInclusive(prefixSum, idx + 1, upperBound - 1));  \\n    }\\n  } \\n  \\n  private void removeRangeSum(TreeMap<Long, Integer> rangeSumCnts, long rangeSum) {\\n    rangeSumCnts.put(rangeSum, rangeSumCnts.get(rangeSum) - 1);\\n    if (rangeSumCnts.get(rangeSum) == 0) {\\n      rangeSumCnts.remove(rangeSum);\\n    }\\n  }\\n  \\n  private void addRangeSum(TreeMap<Long, Integer> rangeSumCnts, long rangeSum) {\\n    rangeSumCnts.put(rangeSum, rangeSumCnts.getOrDefault(rangeSum, 0) + 1);\\n  }\\n  \\n  private long getMax(TreeMap<Long, Integer> rangeSumCnts) {\\n    return rangeSumCnts.lastKey();\\n  }\\n  \\n  private long getRangeSumInclusive(long[] prefixSum, int i, int j) {\\n    return prefixSum[j + 1] - prefixSum[i];\\n  }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```java\\nclass Solution {\\n  \\n  public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n    long[] prefixSum = getPrefixSum(nums);\\n    \\n    TreeSet<Integer> removed = new TreeSet<>();\\n    TreeMap<Long, Integer> rangeSumCnts = new TreeMap<>();\\n    rangeSumCnts.put(getRangeSumInclusive(prefixSum, 0, nums.length - 1), 1);\\n    \\n    long[] res = new long[removeQueries.length];\\n    for (int i = 0; i < removeQueries.length - 1; i++) {\\n      int idx = removeQueries[i];\\n      \\n      Integer lowerBound = getLowerBound(removed, idx);\\n      Integer upperBound = getUpperBound(removed, idx);\\n\\n      updateRangeSum(rangeSumCnts, prefixSum, nums.length, lowerBound, upperBound, idx);\\n      res[i] = getMax(rangeSumCnts);\\n      \\n      removed.add(idx);\\n    }\\n    \\n    return res;\\n  }\\n  \\n  private long[] getPrefixSum(int[] nums) {\\n    long[] prefixSum = new long[nums.length + 1];\\n    for (int i = 1; i <= nums.length; i++) {\\n      prefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n    }\\n    return prefixSum;\\n  }\\n  \\n  private Integer getLowerBound(TreeSet<Integer> removed, int idx) {\\n    return removed.floor(idx);\\n  }\\n  \\n  private Integer getUpperBound(TreeSet<Integer> removed, int idx) {\\n    return removed.ceiling(idx);\\n  }\\n  \\n  private void updateRangeSum(TreeMap<Long, Integer> rangeSumCnts, long[] prefixSum, int n, Integer lowerBound, Integer upperBound, int idx) {\\n    if (lowerBound == null) {\\n      lowerBound = -1;\\n    }\\n    if (upperBound == null) {\\n      upperBound = n;\\n    }\\n    // assert: rangeSum[lowerBound + 1 : upperBound - 1] must have been recored in the rangeSumCnts\\n    removeRangeSum(rangeSumCnts, getRangeSumInclusive(prefixSum, lowerBound + 1, upperBound - 1));\\n    \\n    if (idx - 1 >= lowerBound + 1) {\\n      addRangeSum(rangeSumCnts, getRangeSumInclusive(prefixSum, lowerBound + 1, idx - 1));  \\n    }\\n    if (idx + 1 <= upperBound - 1) {\\n      addRangeSum(rangeSumCnts, getRangeSumInclusive(prefixSum, idx + 1, upperBound - 1));  \\n    }\\n  } \\n  \\n  private void removeRangeSum(TreeMap<Long, Integer> rangeSumCnts, long rangeSum) {\\n    rangeSumCnts.put(rangeSum, rangeSumCnts.get(rangeSum) - 1);\\n    if (rangeSumCnts.get(rangeSum) == 0) {\\n      rangeSumCnts.remove(rangeSum);\\n    }\\n  }\\n  \\n  private void addRangeSum(TreeMap<Long, Integer> rangeSumCnts, long rangeSum) {\\n    rangeSumCnts.put(rangeSum, rangeSumCnts.getOrDefault(rangeSum, 0) + 1);\\n  }\\n  \\n  private long getMax(TreeMap<Long, Integer> rangeSumCnts) {\\n    return rangeSumCnts.lastKey();\\n  }\\n  \\n  private long getRangeSumInclusive(long[] prefixSum, int i, int j) {\\n    return prefixSum[j + 1] - prefixSum[i];\\n  }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455758,
                "title": "python-3-prefix-sum-heap",
                "content": "```\\n    \\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        acc = [0]\\n        # prefix sum\\n        for num in nums:\\n            acc.append(acc[-1] + num)\\n        \\n        # current max sum with boundries\\n        q = [(-sum(nums), 0, n - 1)]\\n        # removed index\\n        rm_idx = []\\n        \\n        \\n        ans = []\\n        for idx in removeQueries:\\n            bisect.insort(rm_idx, idx)\\n            while q:\\n                _, s, e = q[0]\\n                loc = bisect.bisect_left(rm_idx, s)\\n                idx = rm_idx[min(loc, len(rm_idx) - 1)]\\n                # if removed index fall between the boundry of largest sum\\n                if idx > e or idx < s: break\\n                heappop(q)\\n                if s < idx:\\n                    heappush(q, (-(acc[idx] - acc[s]), s, idx - 1))\\n                if e > idx:\\n                    heappush(q, (-(acc[e + 1] - acc[idx + 1]), idx + 1, e))\\n            if q:\\n                ans.append(-q[0][0])\\n            else:\\n                ans.append(0)\\n            \\n        \\n        return ans",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Heap (Priority Queue)",
                    "Prefix Sum"
                ],
                "code": "```\\n    \\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        acc = [0]\\n        # prefix sum\\n        for num in nums:\\n            acc.append(acc[-1] + num)\\n        \\n        # current max sum with boundries\\n        q = [(-sum(nums), 0, n - 1)]\\n        # removed index\\n        rm_idx = []\\n        \\n        \\n        ans = []\\n        for idx in removeQueries:\\n            bisect.insort(rm_idx, idx)\\n            while q:\\n                _, s, e = q[0]\\n                loc = bisect.bisect_left(rm_idx, s)\\n                idx = rm_idx[min(loc, len(rm_idx) - 1)]\\n                # if removed index fall between the boundry of largest sum\\n                if idx > e or idx < s: break\\n                heappop(q)\\n                if s < idx:\\n                    heappush(q, (-(acc[idx] - acc[s]), s, idx - 1))\\n                if e > idx:\\n                    heappush(q, (-(acc[e + 1] - acc[idx + 1]), idx + 1, e))\\n            if q:\\n                ans.append(-q[0][0])\\n            else:\\n                ans.append(0)\\n            \\n        \\n        return ans",
                "codeTag": "Java"
            },
            {
                "id": 2455644,
                "title": "revere-union-find-java-explaination",
                "content": "Considering array as a graph, in which we have edge from i to i + 1 for 0 <= i < n - 1.\\n\\nGiven: After performing all queries we will be left with all the nodes destroyed. So, we can consider while moving from left to right we are breaking one edge and disconnecting the graph.\\nSo, if we move from right to left, we are connecting one edge and if the edge connects two unconnected components, it will connect the components and add thier sums. And the connected components which has maximum sum will be the answer for that query.\\n\\nWe can use Union Find to solve the query by connecting the components at each query.\\n\\nInput: nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]\\nIf we traverse removeQueries from right to left.\\n[] ans: 0\\n[1(2)] ans: 2\\n[1(2)]  [4(1)] ans: 2\\n[1(2)--2(5)]  [4(1)] ans: 7\\n[1(2)--2(5)--3(6)--4(1)] ans: 14\\nWe don\\'t need to perform the left most query.\\n\\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        DSU dsu = new DSU(n);\\n        long[] ans = new long[n];\\n        for(int i = n - 1; i > 0; i--) {\\n            ans[i - 1] = dsu.add(removeQueries[i], nums[removeQueries[i]]);\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass DSU {\\n    int[] roots;\\n    long[] sums;\\n    int[] heights;\\n    int n;\\n    long msf;\\n    \\n    DSU(int n) {\\n        this.n = n;\\n        roots = new int[n];\\n        sums = new long[n];\\n        heights = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            roots[i] = i;\\n            heights[i] = 1;\\n        }\\n        msf = 0;\\n    }\\n    \\n    public long add(int i, int val) {\\n        sums[i] = ln(val);\\n        if(i - 1 >= 0 && sums[i - 1] > 0) connect(i, i - 1);\\n        if(i + 1 < n && sums[i + 1] > 0) connect(i, i + 1);\\n        msf = Math.max(msf, sums[i]);\\n        return msf;\\n    }\\n    \\n    private int root(int u) {\\n        if(roots[u] != u) {\\n            roots[u] = root(roots[u]);\\n        }\\n        return roots[u];\\n    }\\n    \\n    private void connect(int u, int v) {\\n        int rU = root(u);\\n        int rV = root(v);\\n        if(rU == rV) return;\\n        int hU = heights[rU];\\n        int hV = heights[rV];\\n        \\n        if(hU <= hV) {\\n            roots[rU] = rV;\\n            if(hU == hV) heights[rV]++;\\n            sums[rV] += sums[rU];\\n            msf = Math.max(msf, sums[rV]);\\n            return;\\n        }\\n        roots[rV] = rU;\\n        sums[rU] += sums[rV];\\n        msf = Math.max(msf, sums[rU]);\\n    }\\n    \\n    private long ln(int val) { return Long.valueOf(val); }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        DSU dsu = new DSU(n);\\n        long[] ans = new long[n];\\n        for(int i = n - 1; i > 0; i--) {\\n            ans[i - 1] = dsu.add(removeQueries[i], nums[removeQueries[i]]);\\n        }\\n        return ans;\\n    }\\n}\\n\\nclass DSU {\\n    int[] roots;\\n    long[] sums;\\n    int[] heights;\\n    int n;\\n    long msf;\\n    \\n    DSU(int n) {\\n        this.n = n;\\n        roots = new int[n];\\n        sums = new long[n];\\n        heights = new int[n];\\n        for(int i = 0; i < n; i++) {\\n            roots[i] = i;\\n            heights[i] = 1;\\n        }\\n        msf = 0;\\n    }\\n    \\n    public long add(int i, int val) {\\n        sums[i] = ln(val);\\n        if(i - 1 >= 0 && sums[i - 1] > 0) connect(i, i - 1);\\n        if(i + 1 < n && sums[i + 1] > 0) connect(i, i + 1);\\n        msf = Math.max(msf, sums[i]);\\n        return msf;\\n    }\\n    \\n    private int root(int u) {\\n        if(roots[u] != u) {\\n            roots[u] = root(roots[u]);\\n        }\\n        return roots[u];\\n    }\\n    \\n    private void connect(int u, int v) {\\n        int rU = root(u);\\n        int rV = root(v);\\n        if(rU == rV) return;\\n        int hU = heights[rU];\\n        int hV = heights[rV];\\n        \\n        if(hU <= hV) {\\n            roots[rU] = rV;\\n            if(hU == hV) heights[rV]++;\\n            sums[rV] += sums[rU];\\n            msf = Math.max(msf, sums[rV]);\\n            return;\\n        }\\n        roots[rV] = rU;\\n        sums[rU] += sums[rV];\\n        msf = Math.max(msf, sums[rU]);\\n    }\\n    \\n    private long ln(int val) { return Long.valueOf(val); }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455632,
                "title": "c-uinon-find",
                "content": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll par[100005];\\n    ll sz[100005];\\n    ll find(int x){\\n        if(x<0) return x;\\n        if(par[x]==x) return x;\\n        return par[x]=find(par[x]);\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        priority_queue<ll>pq;\\n        vector<ll>ans;\\n        for(int i=0;i<=nums.size();i++) par[i]=i,sz[i]=0;\\n        pq.push(0);\\n        for(int i=q.size()-1;i>=0;i--){\\n            int idx=q[i];\\n            ll curmax=pq.top();\\n           ///cout<<curmax<<\" \";\\n            ans.push_back(curmax);\\n            ll left=find(idx-1);\\n            ll right=find(idx+1);\\n            ll cur=find(idx);\\n            sz[cur]=nums[cur];\\n            ///cout<<idx<<endl;\\n            //cout<<sz[cur]<<\" \"<<endl;\\n            if(left!=-1 and sz[left]>0){\\n                sz[cur]+=sz[left];\\n                par[left]=cur;\\n            }\\n            if(sz[right]>0){\\n                sz[cur]+=sz[right];\\n                par[right]=cur;\\n            }\\n           // cout<<cur<<\" \";\\n            \\n            pq.push(sz[cur]);\\n        }\\n        reverse(ans.begin(),ans.end());\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    #define ll long long\\n    ll par[100005];\\n    ll sz[100005];\\n    ll find(int x){\\n        if(x<0) return x;\\n        if(par[x]==x) return x;\\n        return par[x]=find(par[x]);\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        priority_queue<ll>pq;\\n        vector<ll>ans;\\n        for(int i=0;i<=nums.size();i++) par[i]=i,sz[i]=0;\\n        pq.push(0);\\n        for(int i=q.size()-1;i>=0;i--){\\n            int idx=q[i];\\n            ll curmax=pq.top();\\n           ///cout<<curmax<<\" \";\\n            ans.push_back(curmax);\\n            ll left=find(idx-1);\\n            ll right=find(idx+1);\\n            ll cur=find(idx);\\n            sz[cur]=nums[cur];\\n            ///cout<<idx<<endl;\\n            //cout<<sz[cur]<<\" \"<<endl;\\n            if(left!=-1 and sz[left]>0){\\n                sz[cur]+=sz[left];\\n                par[left]=cur;\\n            }\\n            if(sz[right]>0){\\n                sz[cur]+=sz[right];\\n                par[right]=cur;\\n            }\\n           // cout<<cur<<\" \";\\n            \\n            pq.push(sz[cur]);\\n        }\\n        reverse(ans.begin(),ans.end());\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2454993,
                "title": "simple-java-solution-with-explanation-reverse-union-find-with-prefix-sum",
                "content": "**Approach:**\\n1. Compute the prefix sum for the input array.\\n2. We start processing deletions from right to left i.e. from the last deletion to first deletion (in the reverse order of sequence of events).\\n3. For every deletion, look to the immediate left element and the immediate right element.\\n4. If the immediate neighbours are marked as occupied (or in other words, the immediate neighbours are deleted after the current element), then the immediate neighbours will contain the left end and right end of the newly formed segment.\\n5. Also make sure to update the left end value for the right end index of the segment and the right end value for the left end index of the segment.\\n6. In between values need not be updated as their neighbours have been occupied and they will not be referenced in future.\\n7. Use the left end and right end of the current segment along with the prefix sum array to get the current segment sum.\\n8. Compare with max segment sum and update the answer array.\\n\\n**Dry Run with Sample:**\\n```\\nInput:\\n[1,2,5,6,1]\\n[0,3,2,4,1]\\n\\nPrint Format:  \\n- left end array\\n- right end array\\n- max segment sum (segment left end - segment right end)\\n\\n// Before the index 1 was deleted - [0,3,2,4,(1)]\\n0\\t1\\t0\\t0\\t0\\t\\n0\\t1\\t0\\t0\\t0\\t\\n2 (1 - 1)\\n\\n// Before the index 4 was deleted - [0,3,2,(4),1]\\n0\\t1\\t0\\t0\\t4\\t\\n0\\t1\\t0\\t0\\t4\\t\\n2 (1 - 1)\\n\\n// Before the index 2 was deleted - [0,3,(2),4,1]\\n0\\t1\\t1\\t0\\t4\\t\\n0\\t2\\t2\\t0\\t4\\t\\n7 (1 - 2)\\n\\n// Before the index 3 was deleted - [0,(3),2,4,1]\\n0\\t1\\t1\\t1\\t1\\t\\n0\\t4\\t2\\t4\\t4\\t\\n14 (1 - 4)\\n\\n// Before the index 0 was deleted - [(0),3,2,4,1]\\n0\\t1\\t1\\t1\\t0\\t\\n4\\t4\\t2\\t4\\t4\\t\\n15 (0 - 4)\\n```\\n**Solution:**\\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        // Compute the prefix sum for the input array\\n        long[] prefixSum = new long[nums.length + 1];\\n        for (int i = 0; i < nums.length; i++) {\\n            prefixSum[i+1] = prefixSum[i] + nums[i];\\n        }\\n\\n        long currentMax = 0;\\n        int[] leftEnd = new int[nums.length];\\n        int[] rightEnd = new int[nums.length];\\n        long[] ans = new long[removeQueries.length];\\n\\t\\t// We can eliminate this extra space by modifying the input array and marking visited elements as -1, but it\\'s not a good practise\\n\\t\\tboolean[] isOccupied = new boolean[nums.length]; \\n        \\n        // We start processing deletions from right to left i.e. from the last deletion to first deletion\\n        for (int i = removeQueries.length - 1; i >= 0; i--) {\\n            ans[i] = currentMax;\\n            \\n            int index = removeQueries[i];\\n            isOccupied[index] = true;\\n            \\n            // Inspiration from Union Find - find left end and right end\\n            rightEnd[index] = index;\\n            if (index < nums.length - 1 && isOccupied[index + 1] == true) {\\n                rightEnd[index] = rightEnd[index + 1]; \\n            }\\n            \\n            leftEnd[index] = index;\\n            if (index > 0 && isOccupied[index - 1] == true) {\\n                leftEnd[index] = leftEnd[index - 1];\\n            }\\n            \\n            // Get current segment sum using left end and right end of current segment on the prefix sum array\\n            int leftIndex = leftEnd[index];\\n            int rightIndex = rightEnd[index];\\n            long currSegmentSum = prefixSum[rightIndex + 1] - prefixSum[leftIndex];\\n            currentMax = Math.max(currentMax, currSegmentSum);\\n            \\n            // Also update the right end index for the left end value and the left end index for the right end value\\n            rightEnd[leftIndex] = rightIndex;\\n            leftEnd[rightIndex] = leftIndex;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find",
                    "Prefix Sum"
                ],
                "code": "```\\nInput:\\n[1,2,5,6,1]\\n[0,3,2,4,1]\\n\\nPrint Format:  \\n- left end array\\n- right end array\\n- max segment sum (segment left end - segment right end)\\n\\n// Before the index 1 was deleted - [0,3,2,4,(1)]\\n0\\t1\\t0\\t0\\t0\\t\\n0\\t1\\t0\\t0\\t0\\t\\n2 (1 - 1)\\n\\n// Before the index 4 was deleted - [0,3,2,(4),1]\\n0\\t1\\t0\\t0\\t4\\t\\n0\\t1\\t0\\t0\\t4\\t\\n2 (1 - 1)\\n\\n// Before the index 2 was deleted - [0,3,(2),4,1]\\n0\\t1\\t1\\t0\\t4\\t\\n0\\t2\\t2\\t0\\t4\\t\\n7 (1 - 2)\\n\\n// Before the index 3 was deleted - [0,(3),2,4,1]\\n0\\t1\\t1\\t1\\t1\\t\\n0\\t4\\t2\\t4\\t4\\t\\n14 (1 - 4)\\n\\n// Before the index 0 was deleted - [(0),3,2,4,1]\\n0\\t1\\t1\\t1\\t0\\t\\n4\\t4\\t2\\t4\\t4\\t\\n15 (0 - 4)\\n```\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        // Compute the prefix sum for the input array\\n        long[] prefixSum = new long[nums.length + 1];\\n        for (int i = 0; i < nums.length; i++) {\\n            prefixSum[i+1] = prefixSum[i] + nums[i];\\n        }\\n\\n        long currentMax = 0;\\n        int[] leftEnd = new int[nums.length];\\n        int[] rightEnd = new int[nums.length];\\n        long[] ans = new long[removeQueries.length];\\n\\t\\t// We can eliminate this extra space by modifying the input array and marking visited elements as -1, but it\\'s not a good practise\\n\\t\\tboolean[] isOccupied = new boolean[nums.length]; \\n        \\n        // We start processing deletions from right to left i.e. from the last deletion to first deletion\\n        for (int i = removeQueries.length - 1; i >= 0; i--) {\\n            ans[i] = currentMax;\\n            \\n            int index = removeQueries[i];\\n            isOccupied[index] = true;\\n            \\n            // Inspiration from Union Find - find left end and right end\\n            rightEnd[index] = index;\\n            if (index < nums.length - 1 && isOccupied[index + 1] == true) {\\n                rightEnd[index] = rightEnd[index + 1]; \\n            }\\n            \\n            leftEnd[index] = index;\\n            if (index > 0 && isOccupied[index - 1] == true) {\\n                leftEnd[index] = leftEnd[index - 1];\\n            }\\n            \\n            // Get current segment sum using left end and right end of current segment on the prefix sum array\\n            int leftIndex = leftEnd[index];\\n            int rightIndex = rightEnd[index];\\n            long currSegmentSum = prefixSum[rightIndex + 1] - prefixSum[leftIndex];\\n            currentMax = Math.max(currentMax, currSegmentSum);\\n            \\n            // Also update the right end index for the left end value and the left end index for the right end value\\n            rightEnd[leftIndex] = rightIndex;\\n            leftEnd[rightIndex] = leftIndex;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454850,
                "title": "java-clean-simple-union-find",
                "content": "```\\nclass Solution {\\n    class Node {\\n        Node root;\\n        long total;\\n\\n        Node(long val) {\\n            total = val;\\n        }\\n\\n        Node GetRoot() {\\n            if (root == null)\\n                return this;\\n            return root.GetRoot();\\n        }\\n    }\\n\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        long[] result = new long[nums.length];\\n        Node[] map = new Node[nums.length];\\n        long max = 0;\\n\\n        for (int i = removeQueries.length - 1; i >= 1; i--) {\\n            int current = removeQueries[i];\\n            map[current] = new Node(nums[current]);\\n\\n            if (current > 0 && map[current - 1] != null) { // connect left\\n                Node root = map[current].GetRoot();\\n                Node newRoot = map[current - 1].GetRoot();\\n                root.total += newRoot.total;\\n                newRoot.root = root;\\n            }\\n\\n            if (current < nums.length - 1 && map[current + 1] != null) { // connect right\\n                Node root = map[current].GetRoot();\\n                Node newRoot = map[current + 1].GetRoot();\\n                root.total += newRoot.total;\\n                newRoot.root = root;\\n            }\\n\\n            max = Math.max(max, map[current].total);\\n            result[i - 1] = max;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    class Node {\\n        Node root;\\n        long total;\\n\\n        Node(long val) {\\n            total = val;\\n        }\\n\\n        Node GetRoot() {\\n            if (root == null)\\n                return this;\\n            return root.GetRoot();\\n        }\\n    }\\n\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        long[] result = new long[nums.length];\\n        Node[] map = new Node[nums.length];\\n        long max = 0;\\n\\n        for (int i = removeQueries.length - 1; i >= 1; i--) {\\n            int current = removeQueries[i];\\n            map[current] = new Node(nums[current]);\\n\\n            if (current > 0 && map[current - 1] != null) { // connect left\\n                Node root = map[current].GetRoot();\\n                Node newRoot = map[current - 1].GetRoot();\\n                root.total += newRoot.total;\\n                newRoot.root = root;\\n            }\\n\\n            if (current < nums.length - 1 && map[current + 1] != null) { // connect right\\n                Node root = map[current].GetRoot();\\n                Node newRoot = map[current + 1].GetRoot();\\n                root.total += newRoot.total;\\n                newRoot.root = root;\\n            }\\n\\n            max = Math.max(max, map[current].total);\\n            result[i - 1] = max;\\n        }\\n\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454603,
                "title": "segment-tree-similar-to-cses-problem",
                "content": "Cses problem:https://cses.fi/problemset/task/1190/\\n```class Solution {\\npublic:\\n    \\n    #define ll long long\\n    struct Node{\\n\\tll s;\\n\\tll pre;\\n\\tll suf;\\n\\tll re;\\n};\\n\\nvector<Node> st;\\nvector<ll> a;\\nint n,q;\\n\\nvoid buildTree(int v,int tl, int tr){\\n\\tif (tl==tr){\\n\\t\\tst[v].s=st[v].pre=st[v].suf=st[v].re=a[tl];\\n\\t\\treturn;\\n\\t}\\n\\tll mid = (tl+tr)>>1LL;\\n\\tbuildTree(v*2,tl,mid);\\n\\tbuildTree(v*2+1,mid+1,tr);\\n\\tst[v].s=st[v*2].s+st[v*2+1].s;\\n\\tst[v].pre=max(st[v*2].pre,st[v*2].s+st[v*2+1].pre);\\n\\tst[v].suf=max(st[v*2+1].suf,st[v*2+1].s+st[v*2].suf);\\n\\tst[v].re=max(max(st[v*2].re,st[v*2+1].re),st[v*2].suf+st[v*2+1].pre);\\n}\\n\\nvoid update(ll v,ll tl, ll tr,ll pos,ll val){\\n\\tif (tl==tr){\\n\\t\\tst[v].s=st[v].pre=st[v].suf=st[v].re=val;\\n\\t}\\n\\telse {\\n\\t\\tll mid =(tl+tr)>>1LL;\\n\\t\\tif (pos<=mid) update(v*2,tl,mid,pos,val);\\n\\t\\telse update(v*2+1,mid+1,tr,pos,val);\\n\\t\\tst[v].s=st[v*2].s+st[v*2+1].s;\\n\\t\\tst[v].pre=max(st[v*2].pre,st[v*2].s+st[v*2+1].pre);\\n\\t\\tst[v].suf=max(st[v*2+1].suf,st[v*2+1].s+st[v*2].suf);\\n\\t\\tst[v].re=max(max(st[v*2].re,st[v*2+1].re),st[v*2].suf+st[v*2+1].pre);\\t\\n\\t}\\n}\\n\\n vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        \\n    \\n\\t\\n\\tvector<ll> ans;\\n\\t\\n\\tint n=nums.size();\\n     a=vector<ll> (n,0);\\n     for(ll j=0;j<n;j++)\\n     {\\n         a[j]=nums[j];\\n     }\\n\\tst=vector<Node>(4*n,Node({0,0,0,0}));\\n\\tbuildTree(1,0,n-1);\\n\\tfor (int i=0;i<q.size();++i){\\n\\t\\tll x;\\n        x=q[i];\\n\\t\\tupdate(1,0,n-1,x,-9e13);\\n\\t\\tans.push_back(max(st[1].re,0LL));\\n\\t}\\n     return ans;\\n }\\n   \\n};```\\n",
                "solutionTags": [],
                "code": "```class Solution {\\npublic:\\n    \\n    #define ll long long\\n    struct Node{\\n\\tll s;\\n\\tll pre;\\n\\tll suf;\\n\\tll re;\\n};\\n\\nvector<Node> st;\\nvector<ll> a;\\nint n,q;\\n\\nvoid buildTree(int v,int tl, int tr){\\n\\tif (tl==tr){\\n\\t\\tst[v].s=st[v].pre=st[v].suf=st[v].re=a[tl];\\n\\t\\treturn;\\n\\t}\\n\\tll mid = (tl+tr)>>1LL;\\n\\tbuildTree(v*2,tl,mid);\\n\\tbuildTree(v*2+1,mid+1,tr);\\n\\tst[v].s=st[v*2].s+st[v*2+1].s;\\n\\tst[v].pre=max(st[v*2].pre,st[v*2].s+st[v*2+1].pre);\\n\\tst[v].suf=max(st[v*2+1].suf,st[v*2+1].s+st[v*2].suf);\\n\\tst[v].re=max(max(st[v*2].re,st[v*2+1].re),st[v*2].suf+st[v*2+1].pre);\\n}\\n\\nvoid update(ll v,ll tl, ll tr,ll pos,ll val){\\n\\tif (tl==tr){\\n\\t\\tst[v].s=st[v].pre=st[v].suf=st[v].re=val;\\n\\t}\\n\\telse {\\n\\t\\tll mid =(tl+tr)>>1LL;\\n\\t\\tif (pos<=mid) update(v*2,tl,mid,pos,val);\\n\\t\\telse update(v*2+1,mid+1,tr,pos,val);\\n\\t\\tst[v].s=st[v*2].s+st[v*2+1].s;\\n\\t\\tst[v].pre=max(st[v*2].pre,st[v*2].s+st[v*2+1].pre);\\n\\t\\tst[v].suf=max(st[v*2+1].suf,st[v*2+1].s+st[v*2].suf);\\n\\t\\tst[v].re=max(max(st[v*2].re,st[v*2+1].re),st[v*2].suf+st[v*2+1].pre);\\t\\n\\t}\\n}\\n\\n vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        \\n    \\n\\t\\n\\tvector<ll> ans;\\n\\t\\n\\tint n=nums.size();\\n     a=vector<ll> (n,0);\\n     for(ll j=0;j<n;j++)\\n     {\\n         a[j]=nums[j];\\n     }\\n\\tst=vector<Node>(4*n,Node({0,0,0,0}));\\n\\tbuildTree(1,0,n-1);\\n\\tfor (int i=0;i<q.size();++i){\\n\\t\\tll x;\\n        x=q[i];\\n\\t\\tupdate(1,0,n-1,x,-9e13);\\n\\t\\tans.push_back(max(st[1].re,0LL));\\n\\t}\\n     return ans;\\n }\\n   \\n};```",
                "codeTag": "Java"
            },
            {
                "id": 2454376,
                "title": "java-dsu",
                "content": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int l = nums.length;\\n        long[] res = new long[l];\\n        \\n        UnionFind uf = new UnionFind(l, nums);\\n        \\n        long max = 0;\\n        \\n        int[] queries = new int[l];\\n        \\n        for(int i = removeQueries.length-1; i >= 0; i--){\\n            res[i] = max;\\n            \\n            int val = removeQueries[i];\\n            \\n            queries[val] = nums[val];\\n            \\n            if((val+1 < l && queries[val+1] == 0) && (val-1 >= 0 && queries[val-1] == 0)){ }\\n            else if((val+1 < l && queries[val+1] != 0) && (val-1 >= 0 && queries[val-1] != 0)){\\n                uf.union(val, val+1);\\n                uf.union(val, val-1);\\n            }\\n            else if(val+1 < l && queries[val+1] != 0){\\n                uf.union(val, val+1);\\n            }\\n            else if(val-1 >= 0 && queries[val-1] != 0){\\n                uf.union(val, val-1);\\n            }\\n            \\n            max = Math.max(max, uf.sum(val));\\n        }\\n        \\n        // res[0] = max;\\n        \\n        return res;\\n    }\\n}\\n\\n\\nclass UnionFind {\\n    int[] nums;\\n    int[] parent;\\n    int[] rank;\\n    long[] sum;\\n    int count;\\n\\n    public UnionFind(int n, int[] nums) { // for problem 200\\n        this.nums = nums;\\n        parent = new int[n];\\n        rank = new int[n];\\n        sum = new long[n];\\n        count = n;\\n        for (int i = 0; i < n; ++i) {\\n            parent[i] = i;\\n            rank[i] = 0;\\n            sum[i] = nums[i];\\n        }\\n    }\\n    \\n    public long sum(int x){\\n        return sum[find(x)];\\n    }\\n\\n    public int find(int x) { // path compression\\n        // only the rank of the root matters, used in union op.\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void union(int x, int y) { // union with rank\\n        int rootx = find(x);\\n        int rooty = find(y);\\n        \\n        if (rootx != rooty) {\\n            parent[rootx] = rooty;\\n            sum[rooty] += sum[rootx];\\n            count--;\\n        }\\n    }\\n\\n    public int getCount() {\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int l = nums.length;\\n        long[] res = new long[l];\\n        \\n        UnionFind uf = new UnionFind(l, nums);\\n        \\n        long max = 0;\\n        \\n        int[] queries = new int[l];\\n        \\n        for(int i = removeQueries.length-1; i >= 0; i--){\\n            res[i] = max;\\n            \\n            int val = removeQueries[i];\\n            \\n            queries[val] = nums[val];\\n            \\n            if((val+1 < l && queries[val+1] == 0) && (val-1 >= 0 && queries[val-1] == 0)){ }\\n            else if((val+1 < l && queries[val+1] != 0) && (val-1 >= 0 && queries[val-1] != 0)){\\n                uf.union(val, val+1);\\n                uf.union(val, val-1);\\n            }\\n            else if(val+1 < l && queries[val+1] != 0){\\n                uf.union(val, val+1);\\n            }\\n            else if(val-1 >= 0 && queries[val-1] != 0){\\n                uf.union(val, val-1);\\n            }\\n            \\n            max = Math.max(max, uf.sum(val));\\n        }\\n        \\n        // res[0] = max;\\n        \\n        return res;\\n    }\\n}\\n\\n\\nclass UnionFind {\\n    int[] nums;\\n    int[] parent;\\n    int[] rank;\\n    long[] sum;\\n    int count;\\n\\n    public UnionFind(int n, int[] nums) { // for problem 200\\n        this.nums = nums;\\n        parent = new int[n];\\n        rank = new int[n];\\n        sum = new long[n];\\n        count = n;\\n        for (int i = 0; i < n; ++i) {\\n            parent[i] = i;\\n            rank[i] = 0;\\n            sum[i] = nums[i];\\n        }\\n    }\\n    \\n    public long sum(int x){\\n        return sum[find(x)];\\n    }\\n\\n    public int find(int x) { // path compression\\n        // only the rank of the root matters, used in union op.\\n        if (parent[x] != x)\\n            parent[x] = find(parent[x]);\\n        return parent[x];\\n    }\\n\\n    public void union(int x, int y) { // union with rank\\n        int rootx = find(x);\\n        int rooty = find(y);\\n        \\n        if (rootx != rooty) {\\n            parent[rootx] = rooty;\\n            sum[rooty] += sum[rootx];\\n            count--;\\n        }\\n    }\\n\\n    public int getCount() {\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454183,
                "title": "union-find-algorithm-o-n-time-and-space-solution",
                "content": "The key is to do the given exercise in a backward order, \\nso instead of remove element we will be adding elements at the given index.\\nWhile Adding we have to check if the neighbouring index are set, in case they are then group them\\n\\n<b>Golang</b>\\n```\\ntype DisJointSet struct{\\n  p []int\\n  size []int\\n  val []int\\n}\\nfunc CreateDisJointSet(n int) DisJointSet {\\n  p := make([]int , n)\\n  size := make([]int, n)\\n  val := make([]int, n)\\n  for i:= 0;i<n;i++ {\\n    p[i] = -1\\n  }\\n  return DisJointSet{p, size, val}\\n}\\n\\nfunc (s DisJointSet) IsSet(x int) bool {\\n  return s.p[x] != -1\\n}\\nfunc (s DisJointSet) Set(x, val int) {\\n  s.p[x] = x\\n  s.size[x] = 1\\n  s.val[x] = val\\n}\\nfunc (s DisJointSet) Find(x int) int{\\n  if s.p[x] == x{\\n    return s.p[x]\\n  }\\n  s.p[x] = s.Find(s.p[x])\\n  return s.p[x]\\n}\\n\\nfunc (s DisJointSet) Union(x, y int) {\\n  px, py := s.Find(x), s.Find(y)\\n  if px == py {\\n    return\\n  }\\n  if s.size[px]> s.size[py] {\\n    s.p[py] = px\\n    s.size[px] += s.size[py]\\n    s.val[px] += s.val[py]\\n  }else {\\n    s.p[px] = py\\n    s.size[py] += s.size[px]\\n    s.val[py] += s.val[px]\\n  }\\n}\\nfunc (s DisJointSet) Val(x int) int{\\n  return s.val[s.Find(s.p[x])]\\n}\\n\\n\\nfunc maximumSegmentSum(nums []int, removeQueries []int) []int64 {\\n  n:= len(nums)\\n  res := make([]int64, n)\\n  max := int64(0)\\n  s := CreateDisJointSet(n)\\n  for i:= n-1;i>0;i-- {\\n    rq := removeQueries[i]\\n    s.Set(rq, nums[rq])\\n    if rq>0 && s.IsSet(rq-1){\\n      s.Union(rq, rq-1)\\n    }\\n    if rq < n-1 && s.IsSet(rq+1) {\\n      s.Union(rq, rq+1)\\n    }\\n    temp := int64(s.Val(rq))\\n    if temp > max {\\n      max = temp\\n    }\\n    res[i-1] = max\\n  }\\n  return res\\n}\\n```",
                "solutionTags": [],
                "code": "```\\ntype DisJointSet struct{\\n  p []int\\n  size []int\\n  val []int\\n}\\nfunc CreateDisJointSet(n int) DisJointSet {\\n  p := make([]int , n)\\n  size := make([]int, n)\\n  val := make([]int, n)\\n  for i:= 0;i<n;i++ {\\n    p[i] = -1\\n  }\\n  return DisJointSet{p, size, val}\\n}\\n\\nfunc (s DisJointSet) IsSet(x int) bool {\\n  return s.p[x] != -1\\n}\\nfunc (s DisJointSet) Set(x, val int) {\\n  s.p[x] = x\\n  s.size[x] = 1\\n  s.val[x] = val\\n}\\nfunc (s DisJointSet) Find(x int) int{\\n  if s.p[x] == x{\\n    return s.p[x]\\n  }\\n  s.p[x] = s.Find(s.p[x])\\n  return s.p[x]\\n}\\n\\nfunc (s DisJointSet) Union(x, y int) {\\n  px, py := s.Find(x), s.Find(y)\\n  if px == py {\\n    return\\n  }\\n  if s.size[px]> s.size[py] {\\n    s.p[py] = px\\n    s.size[px] += s.size[py]\\n    s.val[px] += s.val[py]\\n  }else {\\n    s.p[px] = py\\n    s.size[py] += s.size[px]\\n    s.val[py] += s.val[px]\\n  }\\n}\\nfunc (s DisJointSet) Val(x int) int{\\n  return s.val[s.Find(s.p[x])]\\n}\\n\\n\\nfunc maximumSegmentSum(nums []int, removeQueries []int) []int64 {\\n  n:= len(nums)\\n  res := make([]int64, n)\\n  max := int64(0)\\n  s := CreateDisJointSet(n)\\n  for i:= n-1;i>0;i-- {\\n    rq := removeQueries[i]\\n    s.Set(rq, nums[rq])\\n    if rq>0 && s.IsSet(rq-1){\\n      s.Union(rq, rq-1)\\n    }\\n    if rq < n-1 && s.IsSet(rq+1) {\\n      s.Union(rq, rq+1)\\n    }\\n    temp := int64(s.Val(rq))\\n    if temp > max {\\n      max = temp\\n    }\\n    res[i-1] = max\\n  }\\n  return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4030782,
                "title": "c-use-union-find",
                "content": "# Intuition\\n1. traverse from back to front of removeQueries and use \"Union find\" to add each element to the group\\n2. keep track the \"max segmention sum\" when doing Union\\n\\n# Code\\n```\\nclass UnionFind{\\npublic:\\n    int *parent;\\n    int *size;\\n    int group_size;\\n    long long *sum;\\n    long long MaxSum;\\n    UnionFind(int n)\\n    {\\n        parent = new int[n];\\n        size = new int[n];\\n        sum = new long long[n];\\n        group_size = n;\\n        MaxSum = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            parent[i] = i;\\n            size[i] = 1;\\n            sum[i] = 0;\\n        }\\n    }\\n    void add (int idx, int val)\\n    {\\n        sum[idx] = val;\\n        if(sum[idx] > MaxSum) MaxSum = sum[idx];\\n    }\\n    int find(int p)\\n    {\\n        int src = p;\\n        while(parent[src]!=src)\\n        {\\n            parent[src] = parent[parent[src]]; //compress tree while doing find\\n            src=parent[src];\\n        }\\n        return src;\\n    }\\n    bool Union(int p, int q)\\n    {\\n        int rootP = find(p);\\n        int rootQ = find(q);\\n        if(rootP == rootQ) return false;\\n        else\\n        {\\n            if(size[rootP] > size[rootQ])\\n            {\\n                parent[rootQ] = rootP;\\n                size[rootP]+= size[rootQ];\\n                sum[rootP] += sum[rootQ];\\n                if(sum[rootP] > MaxSum) MaxSum = sum[rootP];\\n\\n            }\\n            else\\n            {\\n                parent[rootP] = rootQ;\\n                size[rootQ]+= size[rootP];\\n                sum[rootQ] += sum[rootP];\\n                if(sum[rootQ] > MaxSum) MaxSum = sum[rootQ];\\n            }\\n        }\\n        group_size--;\\n        return true;\\n    }\\n    void Print(int n)\\n    {\\n        cout<<\"parent: \";\\n        for(int i=0; i<n; i++)\\n        {\\n            cout<<parent[i]<<\" \";\\n        }\\n        cout<<\"\\\\n\";\\n\\n        cout<<\"size: \";\\n        for(int i=0; i<n; i++)\\n        {\\n            cout<<size[i]<<\" \";\\n        }\\n        cout<<\"\\\\n\";        \\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = removeQueries.size();\\n        vector<long long> vRet(n);\\n        vector<int> vTable(n, 0);\\n        UnionFind *uf = new UnionFind(n);\\n        for(int i=n-1; i>=1; i--)\\n        {\\n            int iRemoveIdx = removeQueries[i];\\n            vTable[iRemoveIdx] = nums[iRemoveIdx];\\n            uf->add(iRemoveIdx, nums[iRemoveIdx]);\\n            if(iRemoveIdx-1 >=0 && vTable[iRemoveIdx-1] >0) uf->Union(iRemoveIdx-1, iRemoveIdx);\\n            if(iRemoveIdx+1 <n && vTable[iRemoveIdx+1] >0) uf->Union(iRemoveIdx+1, iRemoveIdx);\\n            vRet[i-1] = uf->MaxSum;\\n\\n        }\\n \\n        return vRet;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass UnionFind{\\npublic:\\n    int *parent;\\n    int *size;\\n    int group_size;\\n    long long *sum;\\n    long long MaxSum;\\n    UnionFind(int n)\\n    {\\n        parent = new int[n];\\n        size = new int[n];\\n        sum = new long long[n];\\n        group_size = n;\\n        MaxSum = 0;\\n        for(int i=0; i<n; i++)\\n        {\\n            parent[i] = i;\\n            size[i] = 1;\\n            sum[i] = 0;\\n        }\\n    }\\n    void add (int idx, int val)\\n    {\\n        sum[idx] = val;\\n        if(sum[idx] > MaxSum) MaxSum = sum[idx];\\n    }\\n    int find(int p)\\n    {\\n        int src = p;\\n        while(parent[src]!=src)\\n        {\\n            parent[src] = parent[parent[src]]; //compress tree while doing find\\n            src=parent[src];\\n        }\\n        return src;\\n    }\\n    bool Union(int p, int q)\\n    {\\n        int rootP = find(p);\\n        int rootQ = find(q);\\n        if(rootP == rootQ) return false;\\n        else\\n        {\\n            if(size[rootP] > size[rootQ])\\n            {\\n                parent[rootQ] = rootP;\\n                size[rootP]+= size[rootQ];\\n                sum[rootP] += sum[rootQ];\\n                if(sum[rootP] > MaxSum) MaxSum = sum[rootP];\\n\\n            }\\n            else\\n            {\\n                parent[rootP] = rootQ;\\n                size[rootQ]+= size[rootP];\\n                sum[rootQ] += sum[rootP];\\n                if(sum[rootQ] > MaxSum) MaxSum = sum[rootQ];\\n            }\\n        }\\n        group_size--;\\n        return true;\\n    }\\n    void Print(int n)\\n    {\\n        cout<<\"parent: \";\\n        for(int i=0; i<n; i++)\\n        {\\n            cout<<parent[i]<<\" \";\\n        }\\n        cout<<\"\\\\n\";\\n\\n        cout<<\"size: \";\\n        for(int i=0; i<n; i++)\\n        {\\n            cout<<size[i]<<\" \";\\n        }\\n        cout<<\"\\\\n\";        \\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = removeQueries.size();\\n        vector<long long> vRet(n);\\n        vector<int> vTable(n, 0);\\n        UnionFind *uf = new UnionFind(n);\\n        for(int i=n-1; i>=1; i--)\\n        {\\n            int iRemoveIdx = removeQueries[i];\\n            vTable[iRemoveIdx] = nums[iRemoveIdx];\\n            uf->add(iRemoveIdx, nums[iRemoveIdx]);\\n            if(iRemoveIdx-1 >=0 && vTable[iRemoveIdx-1] >0) uf->Union(iRemoveIdx-1, iRemoveIdx);\\n            if(iRemoveIdx+1 <n && vTable[iRemoveIdx+1] >0) uf->Union(iRemoveIdx+1, iRemoveIdx);\\n            vRet[i-1] = uf->MaxSum;\\n\\n        }\\n \\n        return vRet;\\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3979158,
                "title": "rust-two-ordered-sets",
                "content": "# Intuition\\n\\nUse ordered sets to keep track of each segment.\\n\\nNote that this is the \"online\" approach. Since all queries are given ahead of time, an \"offline\" approach is also possible and might be faster.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n \\\\log n)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```rust\\npub fn to_pref_vec(vec: Vec<u32>) -> Vec<u64> {\\n    let mut ret = Vec::with_capacity(vec.len() + 1);\\n    let mut pref_sum = u64::MIN;\\n    ret.push(pref_sum);\\n\\n    for e in vec {\\n        pref_sum += e as u64;\\n        ret.push(pref_sum);\\n    }\\n\\n    ret\\n}\\n\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn maximum_segment_sum(vec: Vec<i32>, queries: Vec<i32>) -> Vec<i64> {\\n        let vec = vec.into_iter()\\n            .map(|e| e as u32)\\n            .collect::<Vec<_>>();\\n        // println!(\"vec: {:?}\", vec);\\n        let n = vec.len();\\n        let pref_vec = to_pref_vec(vec);\\n        // println!(\"pref_vec: {:?}\", pref_vec);\\n\\n        let queries = queries.into_iter()\\n            .map(|e| e as usize)\\n            .collect::<Vec<_>>();\\n        // println!(\"queries: {:?}\", queries);\\n\\n        let mut ret = vec![];\\n\\n        let mut queries_set = BTreeSet::new();\\n        let mut segments_set = BTreeSet::new();\\n        segments_set.insert((pref_vec[n] - pref_vec[0], 0, n));\\n        for i in queries {\\n            let ptr_frnt = queries_set.range(..=i).rev().next().cloned()\\n                .map(|e| e + 1).unwrap_or(usize::MIN);\\n            let ptr_back = queries_set.range(i..).next().cloned()\\n                .unwrap_or(n);\\n\\n            let segment_sum = pref_vec[ptr_back] - pref_vec[ptr_frnt];\\n            segments_set.remove(&(segment_sum, ptr_frnt, ptr_back));\\n\\n            if ptr_frnt < i {\\n                let segment_sum = pref_vec[i] - pref_vec[ptr_frnt];\\n                segments_set.insert((segment_sum, ptr_frnt, i));\\n            }\\n\\n            if i + 1 < ptr_back {\\n                let segment_sum = pref_vec[ptr_back] - pref_vec[i + 1];\\n                segments_set.insert((segment_sum, i + 1, ptr_back));\\n            }\\n\\n            queries_set.insert(i);\\n\\n            let seg_max = segments_set.iter().rev().next().cloned()\\n                .map(|(e0, _, _)| e0)\\n                .unwrap_or(u64::MIN);\\n            ret.push(seg_max);\\n\\n            // println!(\"segments: {:?}\", segments_set);\\n            // println!(\"queries: {:?}\", queries_set);\\n        }\\n\\n        ret.into_iter()\\n            .map(|e| e as i64)\\n            .collect::<Vec<_>>()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```rust\\npub fn to_pref_vec(vec: Vec<u32>) -> Vec<u64> {\\n    let mut ret = Vec::with_capacity(vec.len() + 1);\\n    let mut pref_sum = u64::MIN;\\n    ret.push(pref_sum);\\n\\n    for e in vec {\\n        pref_sum += e as u64;\\n        ret.push(pref_sum);\\n    }\\n\\n    ret\\n}\\n\\nuse std::collections::BTreeSet;\\n\\nimpl Solution {\\n    pub fn maximum_segment_sum(vec: Vec<i32>, queries: Vec<i32>) -> Vec<i64> {\\n        let vec = vec.into_iter()\\n            .map(|e| e as u32)\\n            .collect::<Vec<_>>();\\n        // println!(\"vec: {:?}\", vec);\\n        let n = vec.len();\\n        let pref_vec = to_pref_vec(vec);\\n        // println!(\"pref_vec: {:?}\", pref_vec);\\n\\n        let queries = queries.into_iter()\\n            .map(|e| e as usize)\\n            .collect::<Vec<_>>();\\n        // println!(\"queries: {:?}\", queries);\\n\\n        let mut ret = vec![];\\n\\n        let mut queries_set = BTreeSet::new();\\n        let mut segments_set = BTreeSet::new();\\n        segments_set.insert((pref_vec[n] - pref_vec[0], 0, n));\\n        for i in queries {\\n            let ptr_frnt = queries_set.range(..=i).rev().next().cloned()\\n                .map(|e| e + 1).unwrap_or(usize::MIN);\\n            let ptr_back = queries_set.range(i..).next().cloned()\\n                .unwrap_or(n);\\n\\n            let segment_sum = pref_vec[ptr_back] - pref_vec[ptr_frnt];\\n            segments_set.remove(&(segment_sum, ptr_frnt, ptr_back));\\n\\n            if ptr_frnt < i {\\n                let segment_sum = pref_vec[i] - pref_vec[ptr_frnt];\\n                segments_set.insert((segment_sum, ptr_frnt, i));\\n            }\\n\\n            if i + 1 < ptr_back {\\n                let segment_sum = pref_vec[ptr_back] - pref_vec[i + 1];\\n                segments_set.insert((segment_sum, i + 1, ptr_back));\\n            }\\n\\n            queries_set.insert(i);\\n\\n            let seg_max = segments_set.iter().rev().next().cloned()\\n                .map(|(e0, _, _)| e0)\\n                .unwrap_or(u64::MIN);\\n            ret.push(seg_max);\\n\\n            // println!(\"segments: {:?}\", segments_set);\\n            // println!(\"queries: {:?}\", queries_set);\\n        }\\n\\n        ret.into_iter()\\n            .map(|e| e as i64)\\n            .collect::<Vec<_>>()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3971027,
                "title": "c-python-union-find-solution-with-explanation",
                "content": "we can do query backward, which means add a number to nums.\\n\\nAnd use union find to record group sum.\\n\\ntc is O(n), sc is O(n).\\n### python\\n```python\\nclass DSU:\\n    def __init__(self, size):\\n        self.parent = [i for i in range(size)]\\n        self.sum = [0] * size\\n    \\n    def find(self, p):\\n        if self.parent[p] != p:\\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def join(self, p, q):\\n        pp, pq = self.find(p), self.find(q)\\n        if pp == pq: return\\n        self.parent[pq] = pp\\n        self.sum[pp] += self.sum[pq]\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        size = len(nums)\\n        seen = [False] * size\\n        dsu = DSU(size)\\n        ans = [0] * size\\n        for i in range(size - 1, 0, -1):\\n            idx = removeQueries[i]\\n            dsu.sum[idx] = nums[idx]\\n            seen[idx] = True\\n            if idx + 1 < size and seen[idx+1]:\\n                dsu.join(idx, idx+1)\\n            if idx - 1 >= 0 and seen[idx-1]:\\n                dsu.join(idx, idx-1)\\n            cur = dsu.sum[dsu.find(idx)]\\n            ans[i-1] = cur if cur > ans[i] else ans[i]\\n        return ans\\n```\\n\\n### c++\\n```cpp\\nclass DSU {\\npublic:\\n    vector<int> parent;\\n    vector<long long> sum;\\n    DSU (int size): parent(size), sum(size) {\\n        for (int i = 0; i < size; i+=1)\\n            parent[i] = i;\\n    }\\n    int find(int p) {\\n        if (this -> parent[p] != p)\\n            this -> parent[p] = this -> find(this -> parent[p]);\\n        return this -> parent[p];\\n    }\\n    void join(int p, int q) {\\n        int pp = this -> find(p), pq = this -> find(q);\\n        if (pp == pq) return;\\n        this -> parent[pq] = pp;\\n        this -> sum[pp] += this -> sum[pq];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int size = nums.size();\\n        DSU dsu (size);\\n        vector<long long> ans (size);\\n        vector<bool> seen (size);\\n        for (int i = size-1; i > 0; i-=1) {\\n            int &idx = removeQueries[i];\\n            dsu.sum[idx] = nums[idx];\\n            seen[idx] = true;\\n            if (idx + 1 < size && seen[idx + 1])\\n                dsu.join(idx, idx+1);\\n            if (idx - 1 >= 0 && seen[idx - 1])\\n                dsu.join(idx, idx-1);\\n            \\n            long long& cur = dsu.sum[dsu.find(idx)];\\n            ans[i-1] = cur > ans[i] ? cur: ans[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Python",
                    "C",
                    "Union Find"
                ],
                "code": "```python\\nclass DSU:\\n    def __init__(self, size):\\n        self.parent = [i for i in range(size)]\\n        self.sum = [0] * size\\n    \\n    def find(self, p):\\n        if self.parent[p] != p:\\n            self.parent[p] = self.find(self.parent[p])\\n        return self.parent[p]\\n    \\n    def join(self, p, q):\\n        pp, pq = self.find(p), self.find(q)\\n        if pp == pq: return\\n        self.parent[pq] = pp\\n        self.sum[pp] += self.sum[pq]\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        size = len(nums)\\n        seen = [False] * size\\n        dsu = DSU(size)\\n        ans = [0] * size\\n        for i in range(size - 1, 0, -1):\\n            idx = removeQueries[i]\\n            dsu.sum[idx] = nums[idx]\\n            seen[idx] = True\\n            if idx + 1 < size and seen[idx+1]:\\n                dsu.join(idx, idx+1)\\n            if idx - 1 >= 0 and seen[idx-1]:\\n                dsu.join(idx, idx-1)\\n            cur = dsu.sum[dsu.find(idx)]\\n            ans[i-1] = cur if cur > ans[i] else ans[i]\\n        return ans\\n```\n```cpp\\nclass DSU {\\npublic:\\n    vector<int> parent;\\n    vector<long long> sum;\\n    DSU (int size): parent(size), sum(size) {\\n        for (int i = 0; i < size; i+=1)\\n            parent[i] = i;\\n    }\\n    int find(int p) {\\n        if (this -> parent[p] != p)\\n            this -> parent[p] = this -> find(this -> parent[p]);\\n        return this -> parent[p];\\n    }\\n    void join(int p, int q) {\\n        int pp = this -> find(p), pq = this -> find(q);\\n        if (pp == pq) return;\\n        this -> parent[pq] = pp;\\n        this -> sum[pp] += this -> sum[pq];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int size = nums.size();\\n        DSU dsu (size);\\n        vector<long long> ans (size);\\n        vector<bool> seen (size);\\n        for (int i = size-1; i > 0; i-=1) {\\n            int &idx = removeQueries[i];\\n            dsu.sum[idx] = nums[idx];\\n            seen[idx] = true;\\n            if (idx + 1 < size && seen[idx + 1])\\n                dsu.join(idx, idx+1);\\n            if (idx - 1 >= 0 && seen[idx - 1])\\n                dsu.join(idx, idx-1);\\n            \\n            long long& cur = dsu.sum[dsu.find(idx)];\\n            ans[i-1] = cur > ans[i] ? cur: ans[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3960253,
                "title": "python-ordered-set-binary-search",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nfrom sortedcontainers import SortedList\\nfrom bisect import bisect_left\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n\\n        values=SortedList()\\n        rang=SortedList()\\n        pre=[]\\n        last=0\\n        l=0\\n        for i in nums:\\n            pre.append(last+nums[l])\\n            last=pre[-1]\\n            l+=1\\n        values.add(pre[-1])\\n        rang.add((0,0,pre[-1]))\\n        rang.add((l-1,1,pre[-1]))\\n        ans=[]\\n\\n        for i in removeQueries:\\n\\n            K=bisect_right(rang,(i,0,0))\\n            nxt_gtr=rang[K]\\n\\n            if nxt_gtr[0]==i:\\n                if nxt_gtr[1]==0:\\n                    nn_gtr=rang[K+1]\\n                    if nxt_gtr[0]==nn_gtr[0]:\\n                        rang.discard(nn_gtr)\\n                        rang.discard(nxt_gtr)\\n                        values.discard(nxt_gtr[2])\\n                    else:\\n                        rang.discard(nxt_gtr)\\n                        rang.discard(nn_gtr)\\n                        values.discard(nxt_gtr[2])\\n                        rang.add((nxt_gtr[0]+1,0,nxt_gtr[2]-nums[i]))\\n                        rang.add((nn_gtr[0],1,nxt_gtr[2]-nums[i]))\\n                        values.add(nxt_gtr[2]-nums[i])\\n                elif nxt_gtr[1]==1:\\n                    pn_gtr=rang[K-1]\\n                    rang.discard(nxt_gtr)\\n                    rang.discard(pn_gtr)\\n                    values.discard(nxt_gtr[2])\\n                    rang.add((nxt_gtr[0]-1,1,nxt_gtr[2]-nums[i]))\\n                    rang.add((pn_gtr[0],0,nxt_gtr[2]-nums[i]))\\n                    values.add(nxt_gtr[2]-nums[i])\\n            else:\\n                pn_gtr=rang[K-1]\\n                rang.discard(nxt_gtr)\\n                rang.discard(pn_gtr)\\n                values.discard(nxt_gtr[2])\\n                rang.add((pn_gtr[0],0,pre[i-1]-pre[pn_gtr[0]]+nums[pn_gtr[0]]))\\n                rang.add((i-1,1,pre[i-1]-pre[pn_gtr[0]]+nums[pn_gtr[0]]))\\n                values.add(pre[i-1]-pre[pn_gtr[0]]+nums[pn_gtr[0]])\\n                rang.add((i+1,0,pre[nxt_gtr[0]]-pre[i]))\\n                rang.add((nxt_gtr[0],1,pre[nxt_gtr[0]]-pre[i]))\\n                values.add(pre[nxt_gtr[0]]-pre[i])\\n            \\n            if not values:\\n                ans.append(0)\\n            else:\\n                ans.append(values[-1])\\n        return ans\\n\\n\\n\\n\\n                    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n            \\n            \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nfrom bisect import bisect_left\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n\\n        values=SortedList()\\n        rang=SortedList()\\n        pre=[]\\n        last=0\\n        l=0\\n        for i in nums:\\n            pre.append(last+nums[l])\\n            last=pre[-1]\\n            l+=1\\n        values.add(pre[-1])\\n        rang.add((0,0,pre[-1]))\\n        rang.add((l-1,1,pre[-1]))\\n        ans=[]\\n\\n        for i in removeQueries:\\n\\n            K=bisect_right(rang,(i,0,0))\\n            nxt_gtr=rang[K]\\n\\n            if nxt_gtr[0]==i:\\n                if nxt_gtr[1]==0:\\n                    nn_gtr=rang[K+1]\\n                    if nxt_gtr[0]==nn_gtr[0]:\\n                        rang.discard(nn_gtr)\\n                        rang.discard(nxt_gtr)\\n                        values.discard(nxt_gtr[2])\\n                    else:\\n                        rang.discard(nxt_gtr)\\n                        rang.discard(nn_gtr)\\n                        values.discard(nxt_gtr[2])\\n                        rang.add((nxt_gtr[0]+1,0,nxt_gtr[2]-nums[i]))\\n                        rang.add((nn_gtr[0],1,nxt_gtr[2]-nums[i]))\\n                        values.add(nxt_gtr[2]-nums[i])\\n                elif nxt_gtr[1]==1:\\n                    pn_gtr=rang[K-1]\\n                    rang.discard(nxt_gtr)\\n                    rang.discard(pn_gtr)\\n                    values.discard(nxt_gtr[2])\\n                    rang.add((nxt_gtr[0]-1,1,nxt_gtr[2]-nums[i]))\\n                    rang.add((pn_gtr[0],0,nxt_gtr[2]-nums[i]))\\n                    values.add(nxt_gtr[2]-nums[i])\\n            else:\\n                pn_gtr=rang[K-1]\\n                rang.discard(nxt_gtr)\\n                rang.discard(pn_gtr)\\n                values.discard(nxt_gtr[2])\\n                rang.add((pn_gtr[0],0,pre[i-1]-pre[pn_gtr[0]]+nums[pn_gtr[0]]))\\n                rang.add((i-1,1,pre[i-1]-pre[pn_gtr[0]]+nums[pn_gtr[0]]))\\n                values.add(pre[i-1]-pre[pn_gtr[0]]+nums[pn_gtr[0]])\\n                rang.add((i+1,0,pre[nxt_gtr[0]]-pre[i]))\\n                rang.add((nxt_gtr[0],1,pre[nxt_gtr[0]]-pre[i]))\\n                values.add(pre[nxt_gtr[0]]-pre[i])\\n            \\n            if not values:\\n                ans.append(0)\\n            else:\\n                ans.append(values[-1])\\n        return ans\\n\\n\\n\\n\\n                    \\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n            \\n            \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3948236,
                "title": "javascript-reverse-union-find-377ms",
                "content": "\\n```\\n/////////////////////// Template /////////////////////////////\\nfunction DJSet(n) {\\n    let p = Array(n).fill(-1), s = Array(n).fill(0); // s: group prefix sum\\n    return { find, union, update, sum, par }\\n    function find(x) {\\n        return p[x] < 0 ? x : p[x] = find(p[x]);\\n    }\\n    function union(x, y) {\\n        x = find(x);\\n        y = find(y);\\n        if (x == y) return false;\\n        if (p[x] < p[y]) [x, y] = [y, x];\\n        p[x] += p[y];\\n        p[y] = x;\\n        s[x] += s[y];\\n        return true;\\n    }\\n    function update(idx, v) {\\n        s[idx] = v;\\n        // s[idx] += v;\\n    }\\n    function sum() {\\n        return s;\\n    }\\n    function par() {\\n        return p;\\n    }\\n}\\n////////////////////////////////////////////////////////////\\n\\nconst maximumSegmentSum = (a, b) => {\\n    let n = a.length, res = [0], ds = new DJSet(n), used = new Set(), max = 0;\\n    for (let i = n - 1; i >= 1; i--) {\\n        used.add(b[i]);\\n        ds.update(b[i], a[b[i]]);\\n        if (used.has(b[i] - 1)) ds.union(b[i], b[i] - 1);\\n        if (used.has(b[i] + 1)) ds.union(b[i], b[i] + 1);\\n        max = Math.max(max, ds.sum()[ds.find([b[i]])]);\\n        res.push(max);\\n    }\\n    return res.reverse();\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find",
                    "Prefix Sum"
                ],
                "code": "```\\n/////////////////////// Template /////////////////////////////\\nfunction DJSet(n) {\\n    let p = Array(n).fill(-1), s = Array(n).fill(0); // s: group prefix sum\\n    return { find, union, update, sum, par }\\n    function find(x) {\\n        return p[x] < 0 ? x : p[x] = find(p[x]);\\n    }\\n    function union(x, y) {\\n        x = find(x);\\n        y = find(y);\\n        if (x == y) return false;\\n        if (p[x] < p[y]) [x, y] = [y, x];\\n        p[x] += p[y];\\n        p[y] = x;\\n        s[x] += s[y];\\n        return true;\\n    }\\n    function update(idx, v) {\\n        s[idx] = v;\\n        // s[idx] += v;\\n    }\\n    function sum() {\\n        return s;\\n    }\\n    function par() {\\n        return p;\\n    }\\n}\\n////////////////////////////////////////////////////////////\\n\\nconst maximumSegmentSum = (a, b) => {\\n    let n = a.length, res = [0], ds = new DJSet(n), used = new Set(), max = 0;\\n    for (let i = n - 1; i >= 1; i--) {\\n        used.add(b[i]);\\n        ds.update(b[i], a[b[i]]);\\n        if (used.has(b[i] - 1)) ds.union(b[i], b[i] - 1);\\n        if (used.has(b[i] + 1)) ds.union(b[i], b[i] + 1);\\n        max = Math.max(max, ds.sum()[ds.find([b[i]])]);\\n        res.push(max);\\n    }\\n    return res.reverse();\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3929372,
                "title": "java-ordered-set-treemap",
                "content": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] queries) {\\n        \\n        int n = nums.length;\\n        \\n        TreeMap<Long, Integer> map = new TreeMap<>();\\n        TreeSet<int[]> s = new TreeSet<>((a,b) -> a[0] < b[0] ? -1 : 1);\\n        long[] ans = new long[n], prefix = new long[n];\\n        prefix[0] = (long) nums[0];\\n        for (int i = 1; i < n; i++) prefix[i] = (long) nums[i] + prefix[i - 1];\\n        s.add(new int[]{0, n - 1});\\n        map.put(prefix[n - 1], 1);\\n        for (int i = 0; i < n; i++) {\\n            int[] curr = s.lower(new int[]{queries[i] + 1, queries[i] + 1});\\n            long res = prefix[curr[1]] - (curr[0] - 1 < 0 ? 0L : prefix[curr[0] - 1]);\\n            map.put(res, map.get(res) - 1);\\n            if (map.get(res) == 0) map.remove(res);\\n            if (curr[0] == queries[i] && curr[0] != curr[1]) {\\n                map.put(prefix[curr[1]] - prefix[curr[0]], map.getOrDefault(prefix[curr[1]] - prefix[curr[0]], 0) + 1);\\n                s.add(new int[]{curr[0] + 1, curr[1]});\\n            } else if (curr[1] == queries[i] && curr[0] != curr[1]) {\\n                map.put(prefix[curr[1] - 1] - (curr[0] - 1 < 0 ? 0L : prefix[curr[0] - 1]), map.getOrDefault(prefix[curr[1] - 1] - (curr[0] - 1 < 0 ? 0L : prefix[curr[0] - 1]), 0) + 1);\\n                s.add(new int[]{curr[0], curr[1] - 1});\\n            } else if (curr[0] != curr[1]) {\\n                long left = prefix[queries[i] - 1] - (curr[0] - 1 < 0 ? 0L : prefix[curr[0] - 1]), right = prefix[curr[1]] - prefix[queries[i]];\\n                map.put(left, map.getOrDefault(left, 0) + 1);\\n                map.put(right, map.getOrDefault(right, 0) + 1);\\n                s.add(new int[]{curr[0], queries[i] - 1});\\n                s.add(new int[]{queries[i] + 1, curr[1]});\\n            }\\n            ans[i] = map.isEmpty() ? 0 : map.lastKey();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] queries) {\\n        \\n        int n = nums.length;\\n        \\n        TreeMap<Long, Integer> map = new TreeMap<>();\\n        TreeSet<int[]> s = new TreeSet<>((a,b) -> a[0] < b[0] ? -1 : 1);\\n        long[] ans = new long[n], prefix = new long[n];\\n        prefix[0] = (long) nums[0];\\n        for (int i = 1; i < n; i++) prefix[i] = (long) nums[i] + prefix[i - 1];\\n        s.add(new int[]{0, n - 1});\\n        map.put(prefix[n - 1], 1);\\n        for (int i = 0; i < n; i++) {\\n            int[] curr = s.lower(new int[]{queries[i] + 1, queries[i] + 1});\\n            long res = prefix[curr[1]] - (curr[0] - 1 < 0 ? 0L : prefix[curr[0] - 1]);\\n            map.put(res, map.get(res) - 1);\\n            if (map.get(res) == 0) map.remove(res);\\n            if (curr[0] == queries[i] && curr[0] != curr[1]) {\\n                map.put(prefix[curr[1]] - prefix[curr[0]], map.getOrDefault(prefix[curr[1]] - prefix[curr[0]], 0) + 1);\\n                s.add(new int[]{curr[0] + 1, curr[1]});\\n            } else if (curr[1] == queries[i] && curr[0] != curr[1]) {\\n                map.put(prefix[curr[1] - 1] - (curr[0] - 1 < 0 ? 0L : prefix[curr[0] - 1]), map.getOrDefault(prefix[curr[1] - 1] - (curr[0] - 1 < 0 ? 0L : prefix[curr[0] - 1]), 0) + 1);\\n                s.add(new int[]{curr[0], curr[1] - 1});\\n            } else if (curr[0] != curr[1]) {\\n                long left = prefix[queries[i] - 1] - (curr[0] - 1 < 0 ? 0L : prefix[curr[0] - 1]), right = prefix[curr[1]] - prefix[queries[i]];\\n                map.put(left, map.getOrDefault(left, 0) + 1);\\n                map.put(right, map.getOrDefault(right, 0) + 1);\\n                s.add(new int[]{curr[0], queries[i] - 1});\\n                s.add(new int[]{queries[i] + 1, curr[1]});\\n            }\\n            ans[i] = map.isEmpty() ? 0 : map.lastKey();\\n        }\\n        \\n        return ans;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3872270,
                "title": "striver-s-union-find-with-slight-modification-c",
                "content": "# Intuition\\ni got a intution of dsu by seeing that we have to take the sum of continuous subarrays like type of connected components but there was a issue in normal dsu we dont have the sum of the components so i thought of making a slight modification here and i aslo stored the sum of connected components \\n\\n# Approach\\nfirst make a dsu and add one more component here that is sum which will store sum of all connected components after making dsu lets come to the logic part we can see that if we traverse from back then that will be the only element left and so on like this basically from removing it get converted to type of adding from end and maintainng the ans in mx \\nnow one more thing was there since it has asked to take the sum of continous subarrays suppose i am on ith index and my (i-1th) or (i+1th) index is visited which means they are there so i need to add them as well in my sum so i need to take a union there and update the ans\\n\\n# Complexity\\n- Time complexity:\\nO(logn)\\n\\n- Space complexity:\\nO(n)\\n\\n# Code\\n```\\nclass DisjointSet{\\n    public:\\n    vector<long long> rank,par,sum;\\n    long long mx;\\n    DisjointSet(long long n){\\n        rank.resize(n+1,0);\\n        par.resize(n+1);\\n        sum.resize(n+1);\\n        for(long long i=0; i<=n; i++){\\n            par[i]=i;\\n        }\\n    }\\n    void unionByRank(long long a,long long b){\\n        long long upa=findUPar(a);\\n        long long upb=findUPar(b);\\n        if(upa==upb){\\n            return;\\n        }\\n        if(rank[upa]>rank[upb])\\n        {\\n            par[upb] = upa;\\n            sum[upa] += sum[upb];\\n            mx = max(mx, sum[upa]);\\n        }\\n        else if(rank[upb]>rank[upa])\\n        {\\n            par[upa] = upb;\\n            sum[upb] += sum[upa];\\n            mx = max(mx, sum[upb]);\\n        }\\n        else{\\n            par[upa] = upb;\\n            rank[upb] ++;\\n            sum[upb] += sum[upa];\\n            mx = max(mx, sum[upb]);\\n        }\\n    }\\n    long long findUPar(long long a){\\n        if(par[a]==a){\\n            return a;\\n        }\\n        return par[a]=findUPar(par[a]);\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        int n=nums.size();\\n        DisjointSet ds(n);\\n        ds.mx=0;\\n        vector<long long> ans(n,0);\\n        vector<int> vis(n,0);\\n        \\n        for(int i=n-1; i>0; i--){\\n            int ind=q[i];\\n            ds.sum[ind]=nums[ind];\\n            vis[ind]=1;\\n            ds.mx=max(ds.mx,(long long)nums[ind]);\\n            if(ind-1>=0 && vis[ind-1]){\\n                ds.unionByRank(ind,ind-1);\\n            }\\n            if(ind+1<n && vis[ind+1]){\\n                ds.unionByRank(ind,ind+1);\\n            }\\n            ans[i-1]=ds.mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass DisjointSet{\\n    public:\\n    vector<long long> rank,par,sum;\\n    long long mx;\\n    DisjointSet(long long n){\\n        rank.resize(n+1,0);\\n        par.resize(n+1);\\n        sum.resize(n+1);\\n        for(long long i=0; i<=n; i++){\\n            par[i]=i;\\n        }\\n    }\\n    void unionByRank(long long a,long long b){\\n        long long upa=findUPar(a);\\n        long long upb=findUPar(b);\\n        if(upa==upb){\\n            return;\\n        }\\n        if(rank[upa]>rank[upb])\\n        {\\n            par[upb] = upa;\\n            sum[upa] += sum[upb];\\n            mx = max(mx, sum[upa]);\\n        }\\n        else if(rank[upb]>rank[upa])\\n        {\\n            par[upa] = upb;\\n            sum[upb] += sum[upa];\\n            mx = max(mx, sum[upb]);\\n        }\\n        else{\\n            par[upa] = upb;\\n            rank[upb] ++;\\n            sum[upb] += sum[upa];\\n            mx = max(mx, sum[upb]);\\n        }\\n    }\\n    long long findUPar(long long a){\\n        if(par[a]==a){\\n            return a;\\n        }\\n        return par[a]=findUPar(par[a]);\\n    }\\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        int n=nums.size();\\n        DisjointSet ds(n);\\n        ds.mx=0;\\n        vector<long long> ans(n,0);\\n        vector<int> vis(n,0);\\n        \\n        for(int i=n-1; i>0; i--){\\n            int ind=q[i];\\n            ds.sum[ind]=nums[ind];\\n            vis[ind]=1;\\n            ds.mx=max(ds.mx,(long long)nums[ind]);\\n            if(ind-1>=0 && vis[ind-1]){\\n                ds.unionByRank(ind,ind-1);\\n            }\\n            if(ind+1<n && vis[ind+1]){\\n                ds.unionByRank(ind,ind+1);\\n            }\\n            ans[i-1]=ds.mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3730577,
                "title": "simple-c-30-lines-code-multiset-prefix-sum",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n  int n = nums.size();\\n  vector<long long>arr(n + 2), pref(n + 2);\\n  multiset<long long>idx, vals;\\n  arr[0] = 0;\\n  pref[0] = 0;\\n  for (int i = 1; i <= n; i++) arr[i] = nums[i - 1];\\n  arr[n + 1] = 0;\\n  for (int i = 1; i <= n + 1; i++) pref[i] = pref[i - 1] + arr[i];\\n  idx.insert(0);\\n  idx.insert(n + 1);\\n  vals.insert(pref[n + 1]);\\n  vector<long long>ans;\\n  for (auto q : removeQueries) {\\n    auto it = idx.lower_bound(q + 1);\\n    int y = *it;\\n    it--;\\n    int x = *it;\\n    if (vals.find(pref[y - 1] - pref[x]) != vals.end()) vals.erase(vals.find(pref[y - 1] - pref[x]));\\n    if (q <= x) vals.insert(0);\\n    else vals.insert(pref[q] - pref[x]);\\n    if (y - 1 <= q + 1) vals.insert(0);\\n    else vals.insert(pref[y - 1] - pref[q + 1]);\\n    ans.push_back(*(--vals.end()));\\n    idx.insert(q + 1);\\n  }\\n  return ans;\\n}\\n\\n\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n  int n = nums.size();\\n  vector<long long>arr(n + 2), pref(n + 2);\\n  multiset<long long>idx, vals;\\n  arr[0] = 0;\\n  pref[0] = 0;\\n  for (int i = 1; i <= n; i++) arr[i] = nums[i - 1];\\n  arr[n + 1] = 0;\\n  for (int i = 1; i <= n + 1; i++) pref[i] = pref[i - 1] + arr[i];\\n  idx.insert(0);\\n  idx.insert(n + 1);\\n  vals.insert(pref[n + 1]);\\n  vector<long long>ans;\\n  for (auto q : removeQueries) {\\n    auto it = idx.lower_bound(q + 1);\\n    int y = *it;\\n    it--;\\n    int x = *it;\\n    if (vals.find(pref[y - 1] - pref[x]) != vals.end()) vals.erase(vals.find(pref[y - 1] - pref[x]));\\n    if (q <= x) vals.insert(0);\\n    else vals.insert(pref[q] - pref[x]);\\n    if (y - 1 <= q + 1) vals.insert(0);\\n    else vals.insert(pref[y - 1] - pref[q + 1]);\\n    ans.push_back(*(--vals.end()));\\n    idx.insert(q + 1);\\n  }\\n  return ans;\\n}\\n\\n\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3724131,
                "title": "easiest-c-solution-set-prefix-sum",
                "content": "# Intuition\\n<!-- Describe ywwour first thoughts on how to solve this problem. -->\\n\\n# Approach\\nprefix sum approach, to store all segments sum in a multiset in order to get highest value after every removal\\n\\n# Complexity\\n- Time comoplexity:\\no(nlogn)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq) {\\n       \\n        int n=nums.size();\\n        vector<long long> ans(n,0);\\n        set<long long> s1;\\n        multiset<long long> s2;\\n        vector<long long> pre(n+1,0);\\n        pre[1]=nums[0];\\n        for(int i=1;i<n;i++) pre[i+1]=pre[i] +nums[i];\\n        // s1 contains all removed indexes\\n        // s2 contains all sum of segments\\n\\n        <!--  // we wanna continuosly evaluate our problem b/w removed indexes so we initially assumed -1 ans n to be our removed indexes -->\\n        s1.insert(-1);\\n        s1.insert(n);\\n        s2.insert(pre[n]);\\n        for(int i=0;i<n;i++){\\n            auto it1=s1.upper_bound(rq[i]);\\n            int a=*it1;\\n            if(it1!=s1.begin()) {\\n                auto it2=--it1;\\n                int b=*it2;\\n                // deleting the sum of the broken segment and replacing it with sum of new segments\\n                auto q=s2.find(pre[a]-pre[b+1]);\\n                s2.erase(q);\\n                s2.insert(pre[a]-pre[rq[i]+1]);\\n                s2.insert(pre[rq[i]]-pre[b+1]);\\n                s1.insert(rq[i]);\\n            }\\n            ans[i]=*s2.rbegin();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq) {\\n       \\n        int n=nums.size();\\n        vector<long long> ans(n,0);\\n        set<long long> s1;\\n        multiset<long long> s2;\\n        vector<long long> pre(n+1,0);\\n        pre[1]=nums[0];\\n        for(int i=1;i<n;i++) pre[i+1]=pre[i] +nums[i];\\n        // s1 contains all removed indexes\\n        // s2 contains all sum of segments\\n\\n        <!--  // we wanna continuosly evaluate our problem b/w removed indexes so we initially assumed -1 ans n to be our removed indexes -->\\n        s1.insert(-1);\\n        s1.insert(n);\\n        s2.insert(pre[n]);\\n        for(int i=0;i<n;i++){\\n            auto it1=s1.upper_bound(rq[i]);\\n            int a=*it1;\\n            if(it1!=s1.begin()) {\\n                auto it2=--it1;\\n                int b=*it2;\\n                // deleting the sum of the broken segment and replacing it with sum of new segments\\n                auto q=s2.find(pre[a]-pre[b+1]);\\n                s2.erase(q);\\n                s2.insert(pre[a]-pre[rq[i]+1]);\\n                s2.insert(pre[rq[i]]-pre[b+1]);\\n                s1.insert(rq[i]);\\n            }\\n            ans[i]=*s2.rbegin();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3681602,
                "title": "segment-tree-explanation-from-scratch-c",
                "content": "# Intuition\\n- whenever i found questions involving key words like queries[i.e range/point queries] i try to check whether this question can be solved using fenwick tree/ segment tree.\\n\\n# Approach\\n\\nupdating a pos (= removeQueries[i]) as -inf so that we can maxsum from [0,n-1].\\n\\n1. this code is just basic template of segment tree where seg[id] gives info regarding totalsum,max_prefix,max_suffix,max_subarraysum in range [l,r].\\n3. explanation of combining of left seg[2*id], right seg[2*id+1] to parent seg[2*id+1];\\n  - max_prefix sum can be formed from max_prefix sum from left    segmenet or leftsegment totalsum+max_prefix sum of right segement.\\nsimilar approach for max_suffis sum.\\n - maxsubarray sum can be formed either from 1.left segemt 2. right segment 3. combining of both left and right segment[left.max_suffix+right.max_pref]\\n\\n# if you find this solution helpful please upvote :).\\n\\n# Code\\n```\\nstruct st{\\n    long long tot;\\n    long long max_prefix;\\n    long long max_suffix;\\n    long long max_sum;\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    const long long inf = 8e13;\\n\\n    st combine(st left,st right)\\n    {\\n        st temp;\\n        temp.tot=left.tot+right.tot;\\n        temp.max_prefix=max(left.max_prefix,left.tot+right.max_prefix);\\n        temp.max_suffix=max(right.max_suffix,right.tot+left.max_suffix);\\n        temp.max_sum=max({left.max_sum,right.max_sum,left.max_suffix+right.max_prefix});\\n        return temp;\\n    }\\n\\n    void build(int id,int l,int r,vector<int> &nums,vector<st> &seg)\\n    {\\n        if(l==r){\\n            seg[id].tot=(long long)nums[l];\\n            seg[id].max_prefix=(long long)nums[l];\\n            seg[id].max_suffix=(long long)nums[l];\\n            seg[id].max_sum=(long long)nums[l];\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        build(2*id,l,mid,nums,seg);\\n        build(2*id+1,mid+1,r,nums,seg);\\n        seg[id]=combine(seg[2*id],seg[2*id+1]);\\n    }\\n\\n    void update(int pos,int id,int l,int r,vector<st> &seg)\\n    {\\n        if(l==r){\\n            seg[id].tot=-inf;\\n            seg[id].max_prefix=-inf;\\n            seg[id].max_suffix=-inf;\\n            seg[id].max_sum=-inf;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        if(pos<=mid)update(pos,2*id,l,mid,seg);\\n        else update(pos,2*id+1,mid+1,r,seg);\\n        seg[id]=combine(seg[2*id],seg[2*id+1]);\\n    }\\n\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n=nums.size();\\n        vector<st>seg(4*n+1);\\n        build(1,0,n-1,nums,seg);\\n        vector<long long>ans(n);\\n        cout<<seg[1].max_sum;\\n        for(int i=0;i<n;i++){\\n            int pos=removeQueries[i];\\n            update(pos,1,0,n-1,seg);\\n            ans[i]=max((long long)0,seg[1].max_sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Segment Tree"
                ],
                "code": "```\\nstruct st{\\n    long long tot;\\n    long long max_prefix;\\n    long long max_suffix;\\n    long long max_sum;\\n};\\n\\n\\n\\nclass Solution {\\npublic:\\n\\n    const long long inf = 8e13;\\n\\n    st combine(st left,st right)\\n    {\\n        st temp;\\n        temp.tot=left.tot+right.tot;\\n        temp.max_prefix=max(left.max_prefix,left.tot+right.max_prefix);\\n        temp.max_suffix=max(right.max_suffix,right.tot+left.max_suffix);\\n        temp.max_sum=max({left.max_sum,right.max_sum,left.max_suffix+right.max_prefix});\\n        return temp;\\n    }\\n\\n    void build(int id,int l,int r,vector<int> &nums,vector<st> &seg)\\n    {\\n        if(l==r){\\n            seg[id].tot=(long long)nums[l];\\n            seg[id].max_prefix=(long long)nums[l];\\n            seg[id].max_suffix=(long long)nums[l];\\n            seg[id].max_sum=(long long)nums[l];\\n            return;\\n        }\\n        int mid=(l+r)/2;\\n        build(2*id,l,mid,nums,seg);\\n        build(2*id+1,mid+1,r,nums,seg);\\n        seg[id]=combine(seg[2*id],seg[2*id+1]);\\n    }\\n\\n    void update(int pos,int id,int l,int r,vector<st> &seg)\\n    {\\n        if(l==r){\\n            seg[id].tot=-inf;\\n            seg[id].max_prefix=-inf;\\n            seg[id].max_suffix=-inf;\\n            seg[id].max_sum=-inf;\\n            return;\\n        }\\n        int mid=(l+r)>>1;\\n        if(pos<=mid)update(pos,2*id,l,mid,seg);\\n        else update(pos,2*id+1,mid+1,r,seg);\\n        seg[id]=combine(seg[2*id],seg[2*id+1]);\\n    }\\n\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n=nums.size();\\n        vector<st>seg(4*n+1);\\n        build(1,0,n-1,nums,seg);\\n        vector<long long>ans(n);\\n        cout<<seg[1].max_sum;\\n        for(int i=0;i<n;i++){\\n            int pos=removeQueries[i];\\n            update(pos,1,0,n-1,seg);\\n            ans[i]=max((long long)0,seg[1].max_sum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3664622,
                "title": "c-union-find-modify-the-uf-class",
                "content": "# Code\\n```\\nclass UF{\\n    public:\\n    // In UF class, a group is a continuous segment\\n    // add an additional map to store the sum of that segment\\n    unordered_map<long long, long long> parent, rank, sum;\\n    long long mx;\\n    long long find (int n)\\n    {\\n        if(parent[n]!=n)\\n            return parent[n] = find(parent[n]);\\n        return n;\\n    }\\n    void merge(int x, int y)\\n    {\\n        long a = find(x), b = find(y);\\n        if(rank[a]>rank[b])\\n        {\\n            parent[b] = a;\\n            sum[a] += sum[b];\\n            mx = max(mx, sum[a]);\\n        }\\n        else if(rank[b]>rank[a])\\n        {\\n            parent[a] = b;\\n            sum[b] += sum[a];\\n            mx = max(mx, sum[b]);\\n        }\\n        else{\\n            parent[a] = b;\\n            rank[b] ++;\\n            sum[b] += sum[a];\\n            mx = max(mx, sum[b]);\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        UF u;\\n        u.mx = 0;\\n        vector<long long> ans(q.size(), 0);\\n        vector<bool> vis(q.size(), false);\\n        // Start from the end\\n        // Assume that there are no elements available, \\n        //then start adding them one by one and perform Union\\n        for(int i=q.size()-1; i>0; i--)\\n        {\\n            int ind =q[i];\\n            u.parent[ind] = ind;\\n            u.sum[ind] = nums[ind];\\n            vis[ind] = 1;\\n            u.mx = max(u.mx, (long long)nums[ind]);\\n            if(ind-1>=0 && vis[ind-1])\\n                u.merge(ind, ind-1);\\n            if(ind+1<nums.size() && vis[ind+1])\\n                u.merge(ind, ind+1);\\n            ans[i-1] = u.mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass UF{\\n    public:\\n    // In UF class, a group is a continuous segment\\n    // add an additional map to store the sum of that segment\\n    unordered_map<long long, long long> parent, rank, sum;\\n    long long mx;\\n    long long find (int n)\\n    {\\n        if(parent[n]!=n)\\n            return parent[n] = find(parent[n]);\\n        return n;\\n    }\\n    void merge(int x, int y)\\n    {\\n        long a = find(x), b = find(y);\\n        if(rank[a]>rank[b])\\n        {\\n            parent[b] = a;\\n            sum[a] += sum[b];\\n            mx = max(mx, sum[a]);\\n        }\\n        else if(rank[b]>rank[a])\\n        {\\n            parent[a] = b;\\n            sum[b] += sum[a];\\n            mx = max(mx, sum[b]);\\n        }\\n        else{\\n            parent[a] = b;\\n            rank[b] ++;\\n            sum[b] += sum[a];\\n            mx = max(mx, sum[b]);\\n        }\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        UF u;\\n        u.mx = 0;\\n        vector<long long> ans(q.size(), 0);\\n        vector<bool> vis(q.size(), false);\\n        // Start from the end\\n        // Assume that there are no elements available, \\n        //then start adding them one by one and perform Union\\n        for(int i=q.size()-1; i>0; i--)\\n        {\\n            int ind =q[i];\\n            u.parent[ind] = ind;\\n            u.sum[ind] = nums[ind];\\n            vis[ind] = 1;\\n            u.mx = max(u.mx, (long long)nums[ind]);\\n            if(ind-1>=0 && vis[ind-1])\\n                u.merge(ind, ind-1);\\n            if(ind+1<nums.size() && vis[ind+1])\\n                u.merge(ind, ind+1);\\n            ans[i-1] = u.mx;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3544814,
                "title": "python-union-find-think-backward-insert-from-the-last-removal-indexes",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        parent = [i for i in range(len(nums))]\\n        size = [n for n in nums]\\n        def find(x):\\n            if x != parent[x]:\\n                parent[x] = find(parent[x])\\n                \\n            return parent[x]\\n        \\n        def union(x, y):\\n            u, v = find(x), find(y)\\n            if u != v:\\n                parent[u] = v\\n                size[v] += size[u]\\n                size[u] = 0\\n            \\n            \\n        ans = [0] * len(nums)\\n        temp = [0] * len(nums)\\n        for i in range(len(removeQueries) - 2, -1, -1):\\n            n = removeQueries[i + 1]\\n            temp[n] = nums[n]\\n            if n - 1 >= 0 and temp[n - 1] > 0:\\n                union(n - 1, n)\\n                \\n            if n + 1 < len(nums) and temp[n + 1] > 0:\\n                union(n, n + 1)\\n                \\n            ans[i] = max(ans[i + 1], size[find(n)])\\n        \\n        return ans\\n            \\n            \\n    \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        parent = [i for i in range(len(nums))]\\n        size = [n for n in nums]\\n        def find(x):\\n            if x != parent[x]:\\n                parent[x] = find(parent[x])\\n                \\n            return parent[x]\\n        \\n        def union(x, y):\\n            u, v = find(x), find(y)\\n            if u != v:\\n                parent[u] = v\\n                size[v] += size[u]\\n                size[u] = 0\\n            \\n            \\n        ans = [0] * len(nums)\\n        temp = [0] * len(nums)\\n        for i in range(len(removeQueries) - 2, -1, -1):\\n            n = removeQueries[i + 1]\\n            temp[n] = nums[n]\\n            if n - 1 >= 0 and temp[n - 1] > 0:\\n                union(n - 1, n)\\n                \\n            if n + 1 < len(nums) and temp[n + 1] > 0:\\n                union(n, n + 1)\\n                \\n            ans[i] = max(ans[i + 1], size[find(n)])\\n        \\n        return ans\\n            \\n            \\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3526347,
                "title": "set-map-prefix-sum",
                "content": "# Intuition\\nEvery remove one element, remove the interval of it. And may add two intervals [left,k-1],[k+1,right]. \\none map store<sum of interval, numbers of sum>, one map store <left index,sum of interval>. That is to erase sum of interval according it\\'s left index, and get max sum of interval in O(1).\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approachs\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(nlogn)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    class segement\\n    {\\n        public:\\n        set<pair<int,int>> intervals; // [left,right]\\n        map<long long,int> sum; // <sum,times>\\n        map<int, long long> lefts; // <left,sum>\\n        \\n        const int INF=1e9+1;\\n        segement(vector<long long>& presum)\\n        {            \\n            long long sum1=presum[presum.size()-1];\\n            intervals.insert({0,presum.size()-2});\\n            sum[sum1]++;\\n            lefts[0]=sum1;\\n        }\\n        void remove(vector<long long>& presum,int n)\\n        {\\n            if (intervals.empty())\\n                return;\\n            auto it=intervals.upper_bound({n,INF});\\n            if (it!=intervals.begin())\\n            {\\n                --it;\\n            }\\n            int left=it->first, right=it->second;\\n            intervals.erase(it);\\n            long long cursum=lefts[left]; \\n            lefts.erase(lefts.find(left));\\n            if (--sum[cursum]==0)\\n                sum.erase(cursum);\\n\\n            long long sum1, sum2;\\n            if (n>left)\\n            {\\n                int left1=left, right1=n-1;\\n                intervals.insert({left1,right1});\\n                sum1=presum[right1+1]-presum[left1];\\n                sum[sum1]++;\\n                lefts[left1]=sum1;   \\n            }\\n            if (n<right)\\n            {\\n                int left2=n+1, right2=right;\\n                intervals.insert({left2,right2});\\n                sum2=presum[right2+1]-presum[left2];\\n                sum[sum2]++;                 \\n                lefts[left2]=sum2;             \\n            }  \\n        }\\n        long long get() // return sum must be long long\\n        {\\n            if (sum.empty())\\n                return 0;\\n            return sum.rbegin()->first;\\n        }\\n    };\\n\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n=removeQueries.size();\\n        vector<long long> presum(n+1);        \\n        for (int i=0; i<nums.size(); i++)\\n        {\\n            presum[i+1]=presum[i]+nums[i];\\n        }\\n        vector<long long> res(n);\\n        segement s(presum);\\n        for (int i=0; i<n; i++)\\n        {\\n            int k=removeQueries[i];\\n            s.remove(presum,k);\\n            res[i]=s.get();\\n        }\\n        return res;\\n    }\\n};\\n",
                "solutionTags": [
                    "C++",
                    "Ordered Map",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    class segement\\n    {\\n        public:\\n        set<pair<int,int>> intervals; // [left,right]\\n        map<long long,int> sum; // <sum,times>\\n        map<int, long long> lefts; // <left,sum>\\n        \\n        const int INF=1e9+1;\\n        segement(vector<long long>& presum)\\n        {            \\n            long long sum1=presum[presum.size()-1];\\n            intervals.insert({0,presum.size()-2}",
                "codeTag": "Java"
            },
            {
                "id": 3450247,
                "title": "c-reverse-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass disjoint_set{\\n    int n;\\n    public:\\n    long long maxi=0;\\n    int* par;\\n    long long* sum;\\n    disjoint_set(int N){\\n        n=N;\\n        par=new int[n];\\n        sum=new long long[n];\\n        for(int i=0;i<n;i++){\\n            par[i]=-1;\\n            sum[i]=0;\\n        }\\n    }\\n    int find(int i){\\n        if(par[i]<0){\\n            return i;\\n        }\\n        int res=find(par[i]);\\n        par[i]=res;\\n        return res;\\n    }\\n    bool Union(int i,int j){\\n        int i_rep=find(i);\\n        int j_rep=find(j);\\n        par[i_rep]+=par[j_rep];\\n        sum[i_rep]+=sum[j_rep];\\n        par[j_rep]=i_rep;\\n        return 1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        int n=nums.size();\\n        vector<long long> ans(n);\\n        disjoint_set* obj=new disjoint_set(n); \\n        for(int i=n-1;i>0;i--){\\n            ans[i]=obj->maxi;\\n            int sum=nums[q[i]];\\n            if(q[i]>0){\\n                int x=obj->find(q[i]-1);\\n                if(obj->sum[x]!=0){\\n                    obj->Union(q[i]-1,q[i]);\\n                }\\n            }\\n            if(q[i]<n-1){\\n                int x=obj->find(q[i]+1);\\n                if(obj->sum[x]!=0){\\n                    obj->Union(q[i]+1,q[i]);\\n                }\\n            }\\n            int i_rep=obj->find(q[i]);\\n            obj->sum[i_rep]+=sum;\\n            obj->maxi=max(obj->maxi,obj->sum[i_rep]);\\n        }\\n        ans[0]=obj->maxi;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass disjoint_set{\\n    int n;\\n    public:\\n    long long maxi=0;\\n    int* par;\\n    long long* sum;\\n    disjoint_set(int N){\\n        n=N;\\n        par=new int[n];\\n        sum=new long long[n];\\n        for(int i=0;i<n;i++){\\n            par[i]=-1;\\n            sum[i]=0;\\n        }\\n    }\\n    int find(int i){\\n        if(par[i]<0){\\n            return i;\\n        }\\n        int res=find(par[i]);\\n        par[i]=res;\\n        return res;\\n    }\\n    bool Union(int i,int j){\\n        int i_rep=find(i);\\n        int j_rep=find(j);\\n        par[i_rep]+=par[j_rep];\\n        sum[i_rep]+=sum[j_rep];\\n        par[j_rep]=i_rep;\\n        return 1;\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        int n=nums.size();\\n        vector<long long> ans(n);\\n        disjoint_set* obj=new disjoint_set(n); \\n        for(int i=n-1;i>0;i--){\\n            ans[i]=obj->maxi;\\n            int sum=nums[q[i]];\\n            if(q[i]>0){\\n                int x=obj->find(q[i]-1);\\n                if(obj->sum[x]!=0){\\n                    obj->Union(q[i]-1,q[i]);\\n                }\\n            }\\n            if(q[i]<n-1){\\n                int x=obj->find(q[i]+1);\\n                if(obj->sum[x]!=0){\\n                    obj->Union(q[i]+1,q[i]);\\n                }\\n            }\\n            int i_rep=obj->find(q[i]);\\n            obj->sum[i_rep]+=sum;\\n            obj->maxi=max(obj->maxi,obj->sum[i_rep]);\\n        }\\n        ans[0]=obj->maxi;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3435847,
                "title": "python-simple-union-find",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        n = len(nums)\\n\\n        dict1, ans = defaultdict(int), [0]*n\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a, b = find(x), find(y)\\n\\n            if a != b:\\n                dict1[b] = a\\n                ans[a] += ans[b]\\n\\n        result = [0]*n\\n\\n        for i in range(n-1,-1,-1):\\n            idx = removeQueries[i]\\n            ans[idx] = nums[idx]\\n\\n            if idx>0 and ans[idx-1]:\\n                union(idx,idx-1)\\n\\n            if idx<n-1 and ans[idx+1]:\\n                union(idx,idx+1)\\n\\n            if i>0:\\n                result[i-1] = max(result[i],ans[find(idx)])\\n\\n        return result\\n\\n\\n\\n\\n        \\n\\n\\n\\n        \\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        n = len(nums)\\n\\n        dict1, ans = defaultdict(int), [0]*n\\n\\n        def find(x):\\n            if x not in dict1:\\n                return x\\n            else:\\n                if x != dict1[x]:\\n                    dict1[x] = find(dict1[x])\\n                return dict1[x]\\n\\n        def union(x,y):\\n            a, b = find(x), find(y)\\n\\n            if a != b:\\n                dict1[b] = a\\n                ans[a] += ans[b]\\n\\n        result = [0]*n\\n\\n        for i in range(n-1,-1,-1):\\n            idx = removeQueries[i]\\n            ans[idx] = nums[idx]\\n\\n            if idx>0 and ans[idx-1]:\\n                union(idx,idx-1)\\n\\n            if idx<n-1 and ans[idx+1]:\\n                union(idx,idx+1)\\n\\n            if i>0:\\n                result[i-1] = max(result[i],ans[find(idx)])\\n\\n        return result\\n\\n\\n\\n\\n        \\n\\n\\n\\n        \\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3327209,
                "title": "c-unionfind",
                "content": "```\\npublic class Solution {\\n    int[] parent;\\n    long[] size;\\n    long maxsize=0;\\n    public long[] MaximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n=removeQueries.Length;\\n        parent=Enumerable.Range(0,n).ToArray();\\n        size= new long[n];\\n        \\n        long[] res =new long[n];\\n        \\n        for(int i=n-1;i>0;i--)\\n        {\\n            int j=removeQueries[i];\\n            size[j]=nums[j];\\n            \\n            if(j<n-1 && size[j+1]>0)\\n                union(j,j+1);\\n            \\n            if(j>0 && size[j-1]>0)\\n                union(j,j-1);\\n            maxsize=Math.Max(nums[j],maxsize);  \\n            res[i-1]=maxsize;\\n        }\\n        \\n        \\n        return res;\\n        \\n    }\\n    \\n    \\n    int find(int i)\\n    {\\n        if(parent[i]!=i)\\n            parent[i]=find(parent[i]);\\n        return parent[i];\\n    }\\n    \\n    void union(int i,int j)\\n    {\\n        int pi=find(i);\\n        int pj=find(j);\\n        \\n        if(i==j)\\n            return;\\n        \\n        parent[pi]=parent[pj];\\n        size[pj]+=size[pi];\\n        \\n        maxsize=Math.Max(maxsize,size[pj]);\\n        \\n        \\n    }\\n}\\n\\n```",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "```\\npublic class Solution {\\n    int[] parent;\\n    long[] size;\\n    long maxsize=0;\\n    public long[] MaximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n=removeQueries.Length;\\n        parent=Enumerable.Range(0,n).ToArray();\\n        size= new long[n];\\n        \\n        long[] res =new long[n];\\n        \\n        for(int i=n-1;i>0;i--)\\n        {\\n            int j=removeQueries[i];\\n            size[j]=nums[j];\\n            \\n            if(j<n-1 && size[j+1]>0)\\n                union(j,j+1);\\n            \\n            if(j>0 && size[j-1]>0)\\n                union(j,j-1);\\n            maxsize=Math.Max(nums[j],maxsize);  \\n            res[i-1]=maxsize;\\n        }\\n        \\n        \\n        return res;\\n        \\n    }\\n    \\n    \\n    int find(int i)\\n    {\\n        if(parent[i]!=i)\\n            parent[i]=find(parent[i]);\\n        return parent[i];\\n    }\\n    \\n    void union(int i,int j)\\n    {\\n        int pi=find(i);\\n        int pj=find(j);\\n        \\n        if(i==j)\\n            return;\\n        \\n        parent[pi]=parent[pj];\\n        size[pj]+=size[pi];\\n        \\n        maxsize=Math.Max(maxsize,size[pj]);\\n        \\n        \\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3114212,
                "title": "c-binarysearch-prefixsum-priorityqueue-hashmap",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nAt first there will be only 1 interval [0,n-1] and we can using PrefixSum approach to get sum of range [i,j] in O(1).\\n\\nEvery remove operation equal to get the correct interval , then split it to at most 2 new sub intervals.\\n\\nHow to get max value of all valid intervals in list?\\nWe can using PriorityQueue as max heap.\\n\\nBut there must be some out-of-date max values, we need a hashMap to ignore them.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- Design a List<int[]> to hold all valid intervals.\\n- Create a prefixSum long[ ] to cache sum of range [0,i]\\n- Using binary search to find the interval contain removeQueries[i]\\n- Using PriorityQueue as maxheap to get max sum of all intervals\\n- Create a Dictionary<long,int> as {maxValue, frequencies}, to avoid invalid max value.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n         public long[] MaximumSegmentSum(int[] nums, int[] removeQueries)\\n        {\\n            int n = nums.Length;\\n            long[] res = new long[n];\\n            //list to store all intervals, sorted\\n            List<int[]> list =new List<int[]>() { new int[] { 0, n-1 } };\\n            long[] prefixSum = new long[n];//create prefixSum array\\n            long sum = 0;\\n            for(int i = 0; i<n; i++)\\n            {\\n                sum+= nums[i];\\n                prefixSum[i]= sum;\\n            }\\n            //max heap\\n            PriorityQueue<long, long> pq = new PriorityQueue<long, long>(Comparer<long>.Create((x, y) =>\\n            {\\n                if (x>y) return -1;\\n                else if (x<y) return 1;\\n                else return 0;\\n            }));\\n\\n            //{maxValue, frequencies} pairs\\n            Dictionary<long, int> dict = new Dictionary<long, int>();\\n            dict.Add(sum,1);//if dict[k]==0, this k is invalid\\n\\n            pq.Enqueue(sum, sum);\\n\\n            int index = 0;\\n            while (index<n)\\n            {\\n                int left = 0;\\n                int right = list.Count-1;\\n                //using binary search to get correct interval\\n                while (left<right)\\n                {\\n                    int mid = (left+right)/2;\\n                    int[] curr = list[mid];\\n                    if (curr[1]<removeQueries[index])\\n                    {\\n                        left = mid+1;\\n                    }\\n                    else if (list[mid][0]>removeQueries[index])\\n                    {\\n                        right = mid;\\n                    }\\n                    else\\n                    {\\n                        left=mid;\\n                        break;\\n                    }\\n                }\\n\\n                int[] toDelete = list[left];//split this interval\\n                list.RemoveAt(left);//remove from list\\n                long total = prefixSum[toDelete[1]];\\n                if(toDelete[0]>0)\\n                    total-=prefixSum[toDelete[0]-1];\\n\\n                dict[total]--;//subtract freq\\n                //after split , right sub is valid\\n                if (toDelete[1] > removeQueries[index])\\n                {\\n                    list.Insert(left, new int[] { removeQueries[index]+1, toDelete[1] });\\n                    long sub = prefixSum[toDelete[1]]- prefixSum[removeQueries[index]];\\n                    if (!dict.ContainsKey(sub))\\n                        dict.Add(sub, 0);\\n                    dict[sub]++;//update dict\\n                    pq.Enqueue(sub, sub);\\n                }\\n                //left sub is valid\\n                if (toDelete[0] < removeQueries[index])\\n                {\\n                    list.Insert(left, new int[] { toDelete[0],removeQueries[index]-1 });\\n                    long sub = prefixSum[removeQueries[index]-1];\\n                    if (toDelete[0]>0)\\n                        sub-= prefixSum[toDelete[0]-1];\\n\\n                    if (!dict.ContainsKey(sub))\\n                        dict.Add(sub, 0);\\n                    dict[sub]++;\\n                    pq.Enqueue(sub, sub);\\n                }\\n\\n                long max = 0;\\n                while (pq.Count>0)\\n                {\\n                    long top = pq.Peek();\\n                    //if currect max is valid\\n                    if (dict.ContainsKey(top)&&dict[top]>0)\\n                    {\\n                        max=top;\\n                        break;\\n                    }\\n                    else pq.Dequeue();//discard invalid\\n                }\\n                res[index++] = max;\\n            }\\n\\n            return res;\\n        }\\n\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n         public long[] MaximumSegmentSum(int[] nums, int[] removeQueries)\\n        {\\n            int n = nums.Length;\\n            long[] res = new long[n];\\n            //list to store all intervals, sorted\\n            List<int[]> list =new List<int[]>() { new int[] { 0, n-1 } };\\n            long[] prefixSum = new long[n];//create prefixSum array\\n            long sum = 0;\\n            for(int i = 0; i<n; i++)\\n            {\\n                sum+= nums[i];\\n                prefixSum[i]= sum;\\n            }\\n            //max heap\\n            PriorityQueue<long, long> pq = new PriorityQueue<long, long>(Comparer<long>.Create((x, y) =>\\n            {\\n                if (x>y) return -1;\\n                else if (x<y) return 1;\\n                else return 0;\\n            }));\\n\\n            //{maxValue, frequencies} pairs\\n            Dictionary<long, int> dict = new Dictionary<long, int>();\\n            dict.Add(sum,1);//if dict[k]==0, this k is invalid\\n\\n            pq.Enqueue(sum, sum);\\n\\n            int index = 0;\\n            while (index<n)\\n            {\\n                int left = 0;\\n                int right = list.Count-1;\\n                //using binary search to get correct interval\\n                while (left<right)\\n                {\\n                    int mid = (left+right)/2;\\n                    int[] curr = list[mid];\\n                    if (curr[1]<removeQueries[index])\\n                    {\\n                        left = mid+1;\\n                    }\\n                    else if (list[mid][0]>removeQueries[index])\\n                    {\\n                        right = mid;\\n                    }\\n                    else\\n                    {\\n                        left=mid;\\n                        break;\\n                    }\\n                }\\n\\n                int[] toDelete = list[left];//split this interval\\n                list.RemoveAt(left);//remove from list\\n                long total = prefixSum[toDelete[1]];\\n                if(toDelete[0]>0)\\n                    total-=prefixSum[toDelete[0]-1];\\n\\n                dict[total]--;//subtract freq\\n                //after split , right sub is valid\\n                if (toDelete[1] > removeQueries[index])\\n                {\\n                    list.Insert(left, new int[] { removeQueries[index]+1, toDelete[1] });\\n                    long sub = prefixSum[toDelete[1]]- prefixSum[removeQueries[index]];\\n                    if (!dict.ContainsKey(sub))\\n                        dict.Add(sub, 0);\\n                    dict[sub]++;//update dict\\n                    pq.Enqueue(sub, sub);\\n                }\\n                //left sub is valid\\n                if (toDelete[0] < removeQueries[index])\\n                {\\n                    list.Insert(left, new int[] { toDelete[0],removeQueries[index]-1 });\\n                    long sub = prefixSum[removeQueries[index]-1];\\n                    if (toDelete[0]>0)\\n                        sub-= prefixSum[toDelete[0]-1];\\n\\n                    if (!dict.ContainsKey(sub))\\n                        dict.Add(sub, 0);\\n                    dict[sub]++;\\n                    pq.Enqueue(sub, sub);\\n                }\\n\\n                long max = 0;\\n                while (pq.Count>0)\\n                {\\n                    long top = pq.Peek();\\n                    //if currect max is valid\\n                    if (dict.ContainsKey(top)&&dict[top]>0)\\n                    {\\n                        max=top;\\n                        break;\\n                    }\\n                    else pq.Dequeue();//discard invalid\\n                }\\n                res[index++] = max;\\n            }\\n\\n            return res;\\n        }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079273,
                "title": "golang-union-find-and-process-in-reverse",
                "content": "```go\\nfunc maximumSegmentSum(nums []int, removeQueries []int) []int64 {\\n  // We process in reverse and union segments together as we add elements.\\n  // We keep track of the maximum segment Sum and every time we add an element\\n  // (since we process in reverse, we add instead of removing) we try to add it \\n  // to a new segment or create an existing segment, or merge two existing segments.\\n  // We update the max segment sum as we do that.\\n  n := len(nums)\\n  root := make([]int, n)\\n  rank := make([]int, n)\\n  for i := 0; i < len(root); i++ {\\n    root[i] = i\\n  }\\n  groupSum := make([]int64, n)\\n  grouped := make([]bool, n)\\n  res := make([]int64, n)\\n  var maxSeen int64\\n  for i := n-1; i >= 0; i-- {\\n    res[i] = maxSeen // the value at n-1 is always 0\\n    q := removeQueries[i]\\n    var leftSum, rightSum int64\\n    if q > 0 && grouped[q-1] {\\n      leftSum = groupSum[find(root, q-1)]\\n      union(root, rank, q, q-1)\\n    }\\n    if q < n-1 && grouped[q+1] {\\n      rightSum = groupSum[find(root, q+1)]\\n      union(root, rank, q, q+1)\\n    }\\n    sum := leftSum + rightSum + int64(nums[q])\\n    maxSeen = max(maxSeen, sum)\\n    groupSum[find(root, q)] = sum\\n    grouped[q] = true\\n  }\\n  return res\\n}\\n\\nfunc find(root []int, x int) int {\\n  if root[x] == x {\\n    return x\\n  }\\n  root[x] = find(root, root[x])\\n  return root[x]\\n}\\n\\nfunc union(root, rank []int, x, y int) {\\n  rootX := find(root, x)\\n  rootY := find(root, y)\\n  if rootX != rootY {\\n    if rank[rootX] > rank[rootY] {\\n      root[rootY] = rootX\\n    } else if rank[rootX] < rank[rootY] {\\n      root[rootX] = rootY\\n    } else {\\n      root[rootY] = rootX\\n      rank[rootX]++\\n    }\\n  }\\n}\\n\\nfunc max(a, b int64) int64 {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "solutionTags": [
                    "Go",
                    "Union Find"
                ],
                "code": "```go\\nfunc maximumSegmentSum(nums []int, removeQueries []int) []int64 {\\n  // We process in reverse and union segments together as we add elements.\\n  // We keep track of the maximum segment Sum and every time we add an element\\n  // (since we process in reverse, we add instead of removing) we try to add it \\n  // to a new segment or create an existing segment, or merge two existing segments.\\n  // We update the max segment sum as we do that.\\n  n := len(nums)\\n  root := make([]int, n)\\n  rank := make([]int, n)\\n  for i := 0; i < len(root); i++ {\\n    root[i] = i\\n  }\\n  groupSum := make([]int64, n)\\n  grouped := make([]bool, n)\\n  res := make([]int64, n)\\n  var maxSeen int64\\n  for i := n-1; i >= 0; i-- {\\n    res[i] = maxSeen // the value at n-1 is always 0\\n    q := removeQueries[i]\\n    var leftSum, rightSum int64\\n    if q > 0 && grouped[q-1] {\\n      leftSum = groupSum[find(root, q-1)]\\n      union(root, rank, q, q-1)\\n    }\\n    if q < n-1 && grouped[q+1] {\\n      rightSum = groupSum[find(root, q+1)]\\n      union(root, rank, q, q+1)\\n    }\\n    sum := leftSum + rightSum + int64(nums[q])\\n    maxSeen = max(maxSeen, sum)\\n    groupSum[find(root, q)] = sum\\n    grouped[q] = true\\n  }\\n  return res\\n}\\n\\nfunc find(root []int, x int) int {\\n  if root[x] == x {\\n    return x\\n  }\\n  root[x] = find(root, root[x])\\n  return root[x]\\n}\\n\\nfunc union(root, rank []int, x, y int) {\\n  rootX := find(root, x)\\n  rootY := find(root, y)\\n  if rootX != rootY {\\n    if rank[rootX] > rank[rootY] {\\n      root[rootY] = rootX\\n    } else if rank[rootX] < rank[rootY] {\\n      root[rootX] = rootY\\n    } else {\\n      root[rootY] = rootX\\n      rank[rootX]++\\n    }\\n  }\\n}\\n\\nfunc max(a, b int64) int64 {\\n  if a > b {\\n    return a\\n  }\\n  return b\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2941027,
                "title": "golang-union-find-reverse",
                "content": "```\\nfunc maximumSegmentSum(nums []int, rq []int) []int64 {\\n\\tn := len(nums)\\n\\tuf := new(UF)\\n\\tuf.r = make([]int, n)\\n\\tuf.p = make([]int, n)\\n\\tfor i := 0; i < n; i++ { uf.p[i] = i }\\n\\tres := make([]int64, len(rq))\\n\\tfor i := len(rq) - 1; i >= 0; i-- {\\n\\t\\tres[i] = int64(uf.mx)\\n        uf.SetR(rq[i], nums[rq[i]])\\n\\t\\tfor ni := rq[i] + 1; ni < n; ni++ {\\n\\t\\t\\tif uf.r[ni] != 0 && uf.Find(ni) != uf.Find(ni-1) {\\n\\t\\t\\t\\tuf.Union(ni, ni-1)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor ni := rq[i] - 1; ni >= 0; ni-- {\\n\\t\\t\\tif uf.r[ni] != 0 && uf.Find(ni) != uf.Find(ni+1) {\\n\\t\\t\\t\\tuf.Union(ni, ni+1)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n\\ntype UF struct {\\n\\tp, r []int\\n\\tmx   int\\n}\\n\\nfunc (uf *UF) SetR(e, v int) {\\n    uf.r[e] = v\\n    if uf.r[e] > uf.mx { uf.mx = uf.r[e] }\\n}\\nfunc (uf *UF) Find(e int) int {\\n\\tif uf.p[e] == e {\\n\\t\\treturn e\\n\\t}\\n\\tuf.p[e] = uf.Find(uf.p[e])\\n\\treturn uf.p[e]\\n}\\n\\nfunc (uf *UF) Union(e1, e2 int) {\\n\\tr1 := uf.Find(e1)\\n\\tr2 := uf.Find(e2)\\n\\tif r1 == r2 {\\n\\t\\treturn\\n\\t}\\n\\n\\tswitch {\\n\\tcase uf.r[r1] < uf.r[r2]:\\n\\t\\tuf.p[r1] = r2\\n\\t\\tuf.r[r2] += uf.r[r1]\\n\\t\\tif uf.r[r2] > uf.mx { uf.mx = uf.r[r2] }\\n\\tcase uf.r[r1] >= uf.r[r2]:\\n\\t\\tuf.p[r2] = r1\\n\\t\\tuf.r[r1] += uf.r[r2]\\n\\t\\tif uf.r[r1] > uf.mx { uf.mx = uf.r[r1] }\\n\\t}\\n\\treturn\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nfunc maximumSegmentSum(nums []int, rq []int) []int64 {\\n\\tn := len(nums)\\n\\tuf := new(UF)\\n\\tuf.r = make([]int, n)\\n\\tuf.p = make([]int, n)\\n\\tfor i := 0; i < n; i++ { uf.p[i] = i }\\n\\tres := make([]int64, len(rq))\\n\\tfor i := len(rq) - 1; i >= 0; i-- {\\n\\t\\tres[i] = int64(uf.mx)\\n        uf.SetR(rq[i], nums[rq[i]])\\n\\t\\tfor ni := rq[i] + 1; ni < n; ni++ {\\n\\t\\t\\tif uf.r[ni] != 0 && uf.Find(ni) != uf.Find(ni-1) {\\n\\t\\t\\t\\tuf.Union(ni, ni-1)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tfor ni := rq[i] - 1; ni >= 0; ni-- {\\n\\t\\t\\tif uf.r[ni] != 0 && uf.Find(ni) != uf.Find(ni+1) {\\n\\t\\t\\t\\tuf.Union(ni, ni+1)\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tbreak\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\n\\treturn res\\n}\\n\\ntype UF struct {\\n\\tp, r []int\\n\\tmx   int\\n}\\n\\nfunc (uf *UF) SetR(e, v int) {\\n    uf.r[e] = v\\n    if uf.r[e] > uf.mx { uf.mx = uf.r[e] }\\n}\\nfunc (uf *UF) Find(e int) int {\\n\\tif uf.p[e] == e {\\n\\t\\treturn e\\n\\t}\\n\\tuf.p[e] = uf.Find(uf.p[e])\\n\\treturn uf.p[e]\\n}\\n\\nfunc (uf *UF) Union(e1, e2 int) {\\n\\tr1 := uf.Find(e1)\\n\\tr2 := uf.Find(e2)\\n\\tif r1 == r2 {\\n\\t\\treturn\\n\\t}\\n\\n\\tswitch {\\n\\tcase uf.r[r1] < uf.r[r2]:\\n\\t\\tuf.p[r1] = r2\\n\\t\\tuf.r[r2] += uf.r[r1]\\n\\t\\tif uf.r[r2] > uf.mx { uf.mx = uf.r[r2] }\\n\\tcase uf.r[r1] >= uf.r[r2]:\\n\\t\\tuf.p[r2] = r1\\n\\t\\tuf.r[r1] += uf.r[r2]\\n\\t\\tif uf.r[r1] > uf.mx { uf.mx = uf.r[r1] }\\n\\t}\\n\\treturn\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2886056,
                "title": "union-find-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nUnion Find\\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(2 * n)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    int parent[100005];\\n    long long value[100005];\\n\\n    int find(int i) {\\n        if(i == parent[i]) {\\n            return i;\\n        }\\n        return parent[i] = find(parent[i]);\\n    }\\n    void unite(int i, long long& maximum, vector<int>& A) {\\n        int n = A.size();\\n        bool ok = true;\\n        value[i] = A[i];\\n        if(i + 1 < n) {\\n            int P = find(i + 1);\\n            if(value[P] != 0) {\\n                ok = 0;\\n                value[P] += value[find(i)];\\n                parent[find(i)] = P;\\n            }\\n        }\\n        if(i - 1 >= 0) {\\n            int P = find(i - 1);\\n            if(value[P] != 0) {\\n                ok = 0;\\n                value[P] += value[find(i)];\\n                parent[find(i)] = P;\\n            }\\n        }\\n        maximum = max(maximum, value[find(i)]);\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& A, vector<int>& Q) {\\n        int n = A.size();\\n        reverse(Q.begin(), Q.end());\\n        for(int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            value[i] = 0;\\n        }\\n        long long maximum = 0;\\n        vector<long long> ans(n);\\n        for(int i = 0; i + 1 < n; i++) {\\n            unite(Q[i], maximum, A);\\n            ans[i + 1] = maximum;  \\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int parent[100005];\\n    long long value[100005];\\n\\n    int find(int i) {\\n        if(i == parent[i]) {\\n            return i;\\n        }\\n        return parent[i] = find(parent[i]);\\n    }\\n    void unite(int i, long long& maximum, vector<int>& A) {\\n        int n = A.size();\\n        bool ok = true;\\n        value[i] = A[i];\\n        if(i + 1 < n) {\\n            int P = find(i + 1);\\n            if(value[P] != 0) {\\n                ok = 0;\\n                value[P] += value[find(i)];\\n                parent[find(i)] = P;\\n            }\\n        }\\n        if(i - 1 >= 0) {\\n            int P = find(i - 1);\\n            if(value[P] != 0) {\\n                ok = 0;\\n                value[P] += value[find(i)];\\n                parent[find(i)] = P;\\n            }\\n        }\\n        maximum = max(maximum, value[find(i)]);\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& A, vector<int>& Q) {\\n        int n = A.size();\\n        reverse(Q.begin(), Q.end());\\n        for(int i = 0; i < n; i++) {\\n            parent[i] = i;\\n            value[i] = 0;\\n        }\\n        long long maximum = 0;\\n        vector<long long> ans(n);\\n        for(int i = 0; i + 1 < n; i++) {\\n            unite(Q[i], maximum, A);\\n            ans[i + 1] = maximum;  \\n        }\\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2849616,
                "title": "using-sets-and-prefix-sum-array-o-nlogn",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<ll> maximumSegmentSum(vector<int>& a, vector<int>& q) {\\n        ll n=a.size();\\n        multiset<ll> st;\\n        \\n        vector<ll> p(n+2,0);\\n        for(int i=1;i<=n;i++)\\n            p[i]=a[i-1]+p[i-1];\\n        \\n        st.insert(p[n]);\\n        set<ll> indl,indr;\\n        indl.insert(0);\\n        indr.insert(n+1);\\n        \\n        vector<ll> ans(n,0);\\n        \\n        for(ll i=0;i<q.size();i++){\\n            auto itl=indl.lower_bound(-q[i]-1);\\n            auto itr=indr.lower_bound(q[i]+1);\\n        \\n            ll lind=-(*itl),rind=*itr;\\n            ll val=p[rind-1]-p[lind];\\n            st.erase(st.find(val));\\n            \\n            ll left=p[q[i]]-p[lind];\\n            ll right=p[rind-1]-p[q[i]+1];\\n            \\n            st.insert(left);\\n            st.insert(right);\\n            \\n            indl.insert(-q[i]-1);\\n            indr.insert(q[i]+1);\\n            \\n            auto it=st.end();\\n            --it;\\n            \\n            ans[i]=*it;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    vector<ll> maximumSegmentSum(vector<int>& a, vector<int>& q) {\\n        ll n=a.size();\\n        multiset<ll> st;\\n        \\n        vector<ll> p(n+2,0);\\n        for(int i=1;i<=n;i++)\\n            p[i]=a[i-1]+p[i-1];\\n        \\n        st.insert(p[n]);\\n        set<ll> indl,indr;\\n        indl.insert(0);\\n        indr.insert(n+1);\\n        \\n        vector<ll> ans(n,0);\\n        \\n        for(ll i=0;i<q.size();i++){\\n            auto itl=indl.lower_bound(-q[i]-1);\\n            auto itr=indr.lower_bound(q[i]+1);\\n        \\n            ll lind=-(*itl),rind=*itr;\\n            ll val=p[rind-1]-p[lind];\\n            st.erase(st.find(val));\\n            \\n            ll left=p[q[i]]-p[lind];\\n            ll right=p[rind-1]-p[q[i]+1];\\n            \\n            st.insert(left);\\n            st.insert(right);\\n            \\n            indl.insert(-q[i]-1);\\n            indr.insert(q[i]+1);\\n            \\n            auto it=st.end();\\n            --it;\\n            \\n            ans[i]=*it;\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2829868,
                "title": "python-reverse-union-find-idea-concise-code",
                "content": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        self.maxSegment = 0\\n        parent = {}\\n        total = {}\\n        \\n        def find(x):\\n            if parent[x] == x: return x\\n            parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        def union(u,v):\\n            U,V = find(u), find(v)\\n            if U == V: return\\n            parent[V] = parent[U]\\n            total[V] += total[U]\\n            total[U] = total[V]\\n            self.maxSegment = max(self.maxSegment, total[U])\\n            \\n        def mergeSegments(u):\\n            parent[u] = u\\n            total[u] = nums[u]\\n            self.maxSegment = max(self.maxSegment, total[u])\\n            if u-1 in parent: union(u,u-1)\\n            if u+1 in parent: union(u,u+1)\\n            \\n        ans = [0]*len(nums)\\n        for i in range(len(nums)-1, -1, -1):\\n            ans[i] = self.maxSegment\\n            removed_index = removeQueries[i]\\n            mergeSegments(removed_index)\\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        self.maxSegment = 0\\n        parent = {}\\n        total = {}\\n        \\n        def find(x):\\n            if parent[x] == x: return x\\n            parent[x] = find(parent[x])\\n            return parent[x]\\n        \\n        def union(u,v):\\n            U,V = find(u), find(v)\\n            if U == V: return\\n            parent[V] = parent[U]\\n            total[V] += total[U]\\n            total[U] = total[V]\\n            self.maxSegment = max(self.maxSegment, total[U])\\n            \\n        def mergeSegments(u):\\n            parent[u] = u\\n            total[u] = nums[u]\\n            self.maxSegment = max(self.maxSegment, total[u])\\n            if u-1 in parent: union(u,u-1)\\n            if u+1 in parent: union(u,u+1)\\n            \\n        ans = [0]*len(nums)\\n        for i in range(len(nums)-1, -1, -1):\\n            ans[i] = self.maxSegment\\n            removed_index = removeQueries[i]\\n            mergeSegments(removed_index)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2803134,
                "title": "o-n-solution-using-union-find",
                "content": "# Complexity\\n- Time complexity: O(n)\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] q) {\\n        int n = nums.length;\\n        long[] ans = new long[n];\\n\\n        UnionFind ob = new UnionFind(n);\\n        long max = 0;\\n\\n        for(int i=n-1; i>0; i--) {\\n            int index = q[i];\\n            ob.sum[index] = nums[index];\\n\\n            if(index+1<n && ob.sum[index+1] != 0) {\\n                ob.union(index, index+1);\\n            }\\n            if(index-1>-1 && ob.sum[index-1] != 0) {\\n                ob.union(index, index-1);\\n            }\\n\\n            max = Math.max(max, ob.sum[index]);\\n            ans[i-1] = max;\\n        }\\n        return ans;\\n    }\\n}\\nclass UnionFind {\\n    int[] par;\\n    long[] sum;\\n    UnionFind(int n) {\\n        par = new int[n];\\n        sum = new long[n];\\n\\n        for(int i=0; i<n; i++) {\\n            par[i] = i;\\n        }\\n    }\\n    int findPar(int x) {\\n        if(this.par[x] == x) return x;\\n        return this.par[x] = findPar(this.par[x]);\\n    }\\n    void union(int x, int y) {\\n        int a = findPar(x);\\n        int b = findPar(y);\\n\\n        par[b] = a;\\n        sum[a]+=sum[b];\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] q) {\\n        int n = nums.length;\\n        long[] ans = new long[n];\\n\\n        UnionFind ob = new UnionFind(n);\\n        long max = 0;\\n\\n        for(int i=n-1; i>0; i--) {\\n            int index = q[i];\\n            ob.sum[index] = nums[index];\\n\\n            if(index+1<n && ob.sum[index+1] != 0) {\\n                ob.union(index, index+1);\\n            }\\n            if(index-1>-1 && ob.sum[index-1] != 0) {\\n                ob.union(index, index-1);\\n            }\\n\\n            max = Math.max(max, ob.sum[index]);\\n            ans[i-1] = max;\\n        }\\n        return ans;\\n    }\\n}\\nclass UnionFind {\\n    int[] par;\\n    long[] sum;\\n    UnionFind(int n) {\\n        par = new int[n];\\n        sum = new long[n];\\n\\n        for(int i=0; i<n; i++) {\\n            par[i] = i;\\n        }\\n    }\\n    int findPar(int x) {\\n        if(this.par[x] == x) return x;\\n        return this.par[x] = findPar(this.par[x]);\\n    }\\n    void union(int x, int y) {\\n        int a = findPar(x);\\n        int b = findPar(y);\\n\\n        par[b] = a;\\n        sum[a]+=sum[b];\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2795891,
                "title": "c-reverse-queries-with-jump-table-o-n",
                "content": "No panic!  You don\\'t need Union-Find or Segment Tree. \\n\\nThe drawback for processing `removeQueries` in normal order is you have to maintain all of the segment sums and find out what\\'s the max at the current point from them. The advantage of the reversing approach is you are adding elements back to the `num` and the maximum segment sum will be monotonic therefore you only need to record the current maximum. \\n\\nIn the meantime, you still need to maintain the valid segments when you add in elements. Two possibilities:\\n1. the new element is alone by itself\\n2. the new element is adjacent to the `end` point of the previous segment or/and the `start` point of the segment on its right hand side.\\n\\nThe second above can be maintained with a `jump` table such that `jump[start] = end ` and `jump[end]=start` where `start` and `end` are indices of the starting point and the end point of a segment. And you don\\'t need to take care of the elements in between, since `removeQueries` are all unique so that internal elements will not be exposed once again. \\n\\nLastly, the segment sum can be calculated with a prefix sum array since all the elements within it are all continuous. \\n\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        vector<long long> prefix;\\n        long long sum = 0; \\n        for(int val: nums){\\n            prefix.push_back(sum);\\n            sum += val;\\n        }\\n        prefix.push_back(sum);\\n         \\n        vector<long long> ans; \\n        vector<int> jumps(n,-1);\\n         \\n        long long max_seg_sum = 0;\\n        ans.push_back(0);\\n        for(int i=n-1;i>0;i--){\\n            int start = removeQueries[i], end = removeQueries[i];\\n            if(start-1>=0 && jumps[start-1]!=-1){\\n                start = jumps[start-1]; \\n            }\\n            if(end+1<n && jumps[end+1]!=-1){\\n                end = jumps[end+1];         \\n            }\\n            jumps[end] = start;\\n            jumps[start] = end;\\n            \\n            long long curr_sum = prefix[end+1] - prefix[start];\\n            if(curr_sum > max_seg_sum){\\n                max_seg_sum = curr_sum;\\n            }\\n            ans.push_back(max_seg_sum);\\n        }\\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        vector<long long> prefix;\\n        long long sum = 0; \\n        for(int val: nums){\\n            prefix.push_back(sum);\\n            sum += val;\\n        }\\n        prefix.push_back(sum);\\n         \\n        vector<long long> ans; \\n        vector<int> jumps(n,-1);\\n         \\n        long long max_seg_sum = 0;\\n        ans.push_back(0);\\n        for(int i=n-1;i>0;i--){\\n            int start = removeQueries[i], end = removeQueries[i];\\n            if(start-1>=0 && jumps[start-1]!=-1){\\n                start = jumps[start-1]; \\n            }\\n            if(end+1<n && jumps[end+1]!=-1){\\n                end = jumps[end+1];         \\n            }\\n            jumps[end] = start;\\n            jumps[start] = end;\\n            \\n            long long curr_sum = prefix[end+1] - prefix[start];\\n            if(curr_sum > max_seg_sum){\\n                max_seg_sum = curr_sum;\\n            }\\n            ans.push_back(max_seg_sum);\\n        }\\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2738541,
                "title": "c-multiset-concise-o-nlogn",
                "content": "store the sum of segments in a multiset, and store the removed index in a set.\\nalso store the prefix sum\\nFor every query, say, remove index k will cause segment A is split to B and C. \\nthe boundry of A can be found be index.upper_bound()\\nso we can get the sum of A, B, C by prefix sum.\\nerease sum of A and insert of B, C into the multiset. \\nand return the largest sum in the set.\\n\\n```\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        const int n = nums.size();\\n        vector<long long> res, vsum = {0};\\n        set<int> index = {-1, n};\\n        for(auto x:nums) vsum.push_back(x+vsum.back());\\n        multiset<long long, greater<>> sums = {vsum.back()};\\n        for(int k : removeQueries){\\n            auto it = index.upper_bound(k);\\n            int a = *prev(it), b = *it;\\n            auto preSum = vsum[b] - vsum[a+1];\\n            sums.erase(sums.find(preSum));\\n            index.insert(k);\\n            auto sumLeft = vsum[k] - vsum[a+1], sumRight = vsum[b] - vsum[k+1];\\n            if(sumLeft>0) sums.insert(sumLeft);\\n            if(sumRight>0) sums.insert(sumRight);\\n            res.push_back(*sums.begin());\\n        }\\n        return res;        \\n    }",
                "solutionTags": [],
                "code": "store the sum of segments in a multiset, and store the removed index in a set.\\nalso store the prefix sum\\nFor every query, say, remove index k will cause segment A is split to B and C. \\nthe boundry of A can be found be index.upper_bound()\\nso we can get the sum of A, B, C by prefix sum.\\nerease sum of A and insert of B, C into the multiset. \\nand return the largest sum in the set.\\n\\n```\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        const int n = nums.size();\\n        vector<long long> res, vsum = {0};\\n        set<int> index = {-1, n};\\n        for(auto x:nums) vsum.push_back(x+vsum.back());\\n        multiset<long long, greater<>> sums = {vsum.back()};\\n        for(int k : removeQueries){\\n            auto it = index.upper_bound(k);\\n            int a = *prev(it), b = *it;\\n            auto preSum = vsum[b] - vsum[a+1];\\n            sums.erase(sums.find(preSum));\\n            index.insert(k);\\n            auto sumLeft = vsum[k] - vsum[a+1], sumRight = vsum[b] - vsum[k+1];\\n            if(sumLeft>0) sums.insert(sumLeft);\\n            if(sumRight>0) sums.insert(sumRight);\\n            res.push_back(*sums.begin());\\n        }\\n        return res;        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2713552,
                "title": "python-relatively-simple-solution",
                "content": "Runtime: 1695 ms, faster than 83.08%\\nMemory Usage: 35.8 MB, less than 95.38%\\n\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        ans, j = [0] * len(removeQueries), -1\\n        \\n        mx = 0\\n        arr = [] #segments container\\n        for idx in reversed(removeQueries):\\n            ans[j], j = mx, j - 1\\n            \\n            i = bisect_left(arr, [idx])\\n            if i > 0 and arr[i - 1][1] == idx - 1:\\n                if i < len(arr) and arr[i][0] == idx + 1:\\n\\t\\t\\t\\t\\t#merging the previous segment into the current segment\\n                    arr[i][0] = arr[i - 1][0]\\n                    arr[i][2] += arr[i - 1][2] + nums[idx]\\n                    if arr[i][2] > mx: mx = arr[i][2]\\n                    del arr[i - 1]\\n                else:\\n\\t\\t\\t\\t\\t#append the idx to the previous segment\\n                    arr[i - 1][1] += 1\\n                    arr[i - 1][2] += nums[idx]\\n                    if arr[i - 1][2] > mx: mx = arr[i - 1][2]\\n                    \\n            elif i < len(arr) and arr[i][0] == idx + 1:\\n\\t\\t\\t\\t#append the idx to the current segment\\n                arr[i][0] -= 1\\n                arr[i][2] += nums[idx]\\n                if arr[i][2] > mx: mx = arr[i][2]\\n            \\n            else:\\n\\t\\t\\t\\t#insert a new segment\\n                arr.insert(i, [idx, idx, nums[idx]]) # segment: [start point, end point, sum]\\n                if nums[idx] > mx: mx = nums[idx]\\n                \\n        return ans\\n",
                "solutionTags": [],
                "code": "Runtime: 1695 ms, faster than 83.08%\\nMemory Usage: 35.8 MB, less than 95.38%\\n\\n    def maximumSegmentSum(self, nums, removeQueries):\\n        ans, j = [0] * len(removeQueries), -1\\n        \\n        mx = 0\\n        arr = [] #segments container\\n        for idx in reversed(removeQueries):\\n            ans[j], j = mx, j - 1\\n            \\n            i = bisect_left(arr, [idx])\\n            if i > 0 and arr[i - 1][1] == idx - 1:\\n                if i < len(arr) and arr[i][0] == idx + 1:\\n\\t\\t\\t\\t\\t#merging the previous segment into the current segment\\n                    arr[i][0] = arr[i - 1][0]\\n                    arr[i][2] += arr[i - 1][2] + nums[idx]\\n                    if arr[i][2] > mx: mx = arr[i][2]\\n                    del arr[i - 1]\\n                else:\\n\\t\\t\\t\\t\\t#append the idx to the previous segment\\n                    arr[i - 1][1] += 1\\n                    arr[i - 1][2] += nums[idx]\\n                    if arr[i - 1][2] > mx: mx = arr[i - 1][2]\\n                    \\n            elif i < len(arr) and arr[i][0] == idx + 1:\\n\\t\\t\\t\\t#append the idx to the current segment\\n                arr[i][0] -= 1\\n                arr[i][2] += nums[idx]\\n                if arr[i][2] > mx: mx = arr[i][2]\\n            \\n            else:\\n\\t\\t\\t\\t#insert a new segment\\n                arr.insert(i, [idx, idx, nums[idx]]) # segment: [start point, end point, sum]\\n                if nums[idx] > mx: mx = nums[idx]\\n                \\n        return ans\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2697710,
                "title": "stuck-runtime-error",
                "content": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& num, vector<int>& q) {\\n        ll n = num.size();\\n            ll m = q.size();\\n            set<int> st; //removed indexes\\n            st.insert(-1);\\n            st.insert(n);\\n            vector<int> pref(n,0);\\n            pref[0] = num[0];\\n            for(ll i=1;i<n;i++)\\n            {\\n                    pref[i] = num[i] + pref[i-1];\\n            }\\n            vector<ll> ans;\\n            multiset<ll> mst; //segment sums\\n            mst.insert(pref[n-1]);\\n            for(ll i=0;i<m;i++)\\n            {\\n                    ll k = q[i];\\n                    auto prev_itr = st.lower_bound(k);\\n                    prev_itr--;\\n                    ll L = *(prev_itr);\\n                    L++;\\n                    auto next_itr = st.upper_bound(k);\\n                    ll R = *(next_itr);\\n                    R--;\\n                    \\n                    ll y;\\n                    if(L>0){ y = pref[R] - pref[L-1]; }\\n                    else{ y = pref[R]; }\\n                    \\n                    ll y1 = 0;\\n                    if(k-1>=0){ if(L>0){y1 = pref[k-1] - pref[L-1];}else{y1 = pref[k-1];} }\\n                    ll y2 = 0;\\n                    if(k < R){ y2 = pref[R] - pref[k]; }\\n                    auto it2 = mst.find(y);\\n                    if(it2 != mst.end()){ mst.erase(it2); }\\n                    mst.insert(y1);\\n                    mst.insert(y2);\\n                    auto it = mst.end(); it--;\\n                    ans.push_back(*it);\\n                    st.insert(k);\\n            }\\n            return ans;\\n    }\\n};\\n```\\nThis solution is giving runtime error. Please help me resolve that",
                "solutionTags": [],
                "code": "```\\n#define ll long long \\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& num, vector<int>& q) {\\n        ll n = num.size();\\n            ll m = q.size();\\n            set<int> st; //removed indexes\\n            st.insert(-1);\\n            st.insert(n);\\n            vector<int> pref(n,0);\\n            pref[0] = num[0];\\n            for(ll i=1;i<n;i++)\\n            {\\n                    pref[i] = num[i] + pref[i-1];\\n            }\\n            vector<ll> ans;\\n            multiset<ll> mst; //segment sums\\n            mst.insert(pref[n-1]);\\n            for(ll i=0;i<m;i++)\\n            {\\n                    ll k = q[i];\\n                    auto prev_itr = st.lower_bound(k);\\n                    prev_itr--;\\n                    ll L = *(prev_itr);\\n                    L++;\\n                    auto next_itr = st.upper_bound(k);\\n                    ll R = *(next_itr);\\n                    R--;\\n                    \\n                    ll y;\\n                    if(L>0){ y = pref[R] - pref[L-1]; }\\n                    else{ y = pref[R]; }\\n                    \\n                    ll y1 = 0;\\n                    if(k-1>=0){ if(L>0){y1 = pref[k-1] - pref[L-1];}else{y1 = pref[k-1];} }\\n                    ll y2 = 0;\\n                    if(k < R){ y2 = pref[R] - pref[k]; }\\n                    auto it2 = mst.find(y);\\n                    if(it2 != mst.end()){ mst.erase(it2); }\\n                    mst.insert(y1);\\n                    mst.insert(y2);\\n                    auto it = mst.end(); it--;\\n                    ans.push_back(*it);\\n                    st.insert(k);\\n            }\\n            return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2696103,
                "title": "c-union-find",
                "content": "```\\n#define v vector\\n#define ll long long\\n\\nclass UnionFind {\\nprivate:\\n    v<int> root;\\n    v<int> rank;\\n    v<ll> val;\\n    int size;\\n\\npublic:\\n    UnionFind(int sz) {\\n        for(int i = 0; i < sz; i++) root.push_back(i);\\n        rank.resize(sz, 1);\\n        val.resize(sz, 0);\\n        size = sz;\\n    }\\n    \\n    void init(int index, int value) {\\n        val[index] = value;\\n    }\\n    \\n    int find(int x) {\\n        if(x == root[x]) return x;\\n        return x = find(root[x]);\\n    }\\n    \\n    void set(int x, int y) {\\n        if(x < 0 || x >= size) return;\\n        if(y < 0 || y >= size) return;\\n        \\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(!val[rootX] || !val[rootY]) return;\\n        \\n        if(rank[rootX] > rank[rootY]) {\\n            root[rootY] = rootX;\\n            val[rootX] += val[rootY];\\n        } else if(rank[rootX] < rank[rootY]) {\\n            root[rootX] = rootY;\\n            val[rootY] += val[rootX];\\n        } else {\\n            root[rootY] = rootX;\\n            rank[rootX]++;\\n            val[rootX] += val[rootY];\\n        }\\n    }\\n    \\n    ll get(int x) {\\n        int rootX = find(x);\\n        return val[rootX];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    v<ll> maximumSegmentSum(v<int>& nums, v<int>& removeQueries) {\\n        int sz = nums.size();\\n        UnionFind uf(sz);\\n        v<ll> res(sz);\\n        ll maxCur = 0;\\n        \\n        for(int i = sz - 1; i >= 0; i--) {\\n            res[i] = maxCur;\\n            \\n            int query = removeQueries[i];\\n            uf.init(query, nums[query]);\\n            \\n            uf.set(query, query - 1);\\n            uf.set(query, query + 1);\\n            maxCur = max(maxCur, uf.get(query));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define v vector\\n#define ll long long\\n\\nclass UnionFind {\\nprivate:\\n    v<int> root;\\n    v<int> rank;\\n    v<ll> val;\\n    int size;\\n\\npublic:\\n    UnionFind(int sz) {\\n        for(int i = 0; i < sz; i++) root.push_back(i);\\n        rank.resize(sz, 1);\\n        val.resize(sz, 0);\\n        size = sz;\\n    }\\n    \\n    void init(int index, int value) {\\n        val[index] = value;\\n    }\\n    \\n    int find(int x) {\\n        if(x == root[x]) return x;\\n        return x = find(root[x]);\\n    }\\n    \\n    void set(int x, int y) {\\n        if(x < 0 || x >= size) return;\\n        if(y < 0 || y >= size) return;\\n        \\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if(!val[rootX] || !val[rootY]) return;\\n        \\n        if(rank[rootX] > rank[rootY]) {\\n            root[rootY] = rootX;\\n            val[rootX] += val[rootY];\\n        } else if(rank[rootX] < rank[rootY]) {\\n            root[rootX] = rootY;\\n            val[rootY] += val[rootX];\\n        } else {\\n            root[rootY] = rootX;\\n            rank[rootX]++;\\n            val[rootX] += val[rootY];\\n        }\\n    }\\n    \\n    ll get(int x) {\\n        int rootX = find(x);\\n        return val[rootX];\\n    }\\n};\\n\\nclass Solution {\\npublic:\\n    v<ll> maximumSegmentSum(v<int>& nums, v<int>& removeQueries) {\\n        int sz = nums.size();\\n        UnionFind uf(sz);\\n        v<ll> res(sz);\\n        ll maxCur = 0;\\n        \\n        for(int i = sz - 1; i >= 0; i--) {\\n            res[i] = maxCur;\\n            \\n            int query = removeQueries[i];\\n            uf.init(query, nums[query]);\\n            \\n            uf.set(query, query - 1);\\n            uf.set(query, query + 1);\\n            maxCur = max(maxCur, uf.get(query));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2680564,
                "title": "stl-hashmap-multiset-faster-than-60",
                "content": "#define ll long long\\n\\nclass Solution\\n{\\n    \\npublic:\\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq)\\n    {\\n        \\n        int n=nums.size();\\n        vector<ll> presum(n+1);\\n        for(int i=1;i<=n;i++) presum[i]=presum[i-1]+nums[i-1];\\n        \\n        map<int,int> mp;\\n        multiset<ll> ms;\\n        \\n        mp[1]=n;\\n        ms.insert( presum[n] );\\n        vector<ll> ans;\\n        \\n        for(auto x: rq)\\n        {\\n            x++;\\n            auto it=mp.upper_bound( x );\\n            it--;\\n            int fs=it->first, sc=it->second;\\n            \\n            ll sum=presum[ sc ]-presum[ fs-1 ];\\n            ms.erase( ms.find( sum ) );\\n            mp.erase( fs );\\n            \\n            if( fs<x )\\n            {\\n                mp[fs]=x-1;\\n                ms.insert( presum[x-1]-presum[fs-1] );\\n            }\\n            \\n            if(sc>x)\\n            {\\n                mp[x+1]=sc;\\n                ms.insert( presum[sc]-presum[x] );\\n            }\\n            \\n            if(ms.size())  ans.push_back( *--ms.end() );\\n            else ans.push_back( 0 );\\n            \\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution\\n{\\n    \\npublic:\\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq)\\n    {\\n        \\n        int n=nums.size();\\n        vector<ll> presum(n+1);\\n        for(int i=1;i<=n;i++) presum[i]=presum[i-1]+nums[i-1];\\n        \\n        map<int,int> mp;\\n        multiset<ll> ms;\\n        \\n        mp[1]=n;\\n        ms.insert( presum[n] );\\n        vector<ll> ans;\\n        \\n        for(auto x: rq)\\n        {\\n            x++;\\n            auto it=mp.upper_bound( x );\\n            it--;\\n            int fs=it->first, sc=it->second;\\n            \\n            ll sum=presum[ sc ]-presum[ fs-1 ];\\n            ms.erase( ms.find( sum ) );\\n            mp.erase( fs );\\n            \\n            if( fs<x )\\n            {\\n                mp[fs]=x-1;\\n                ms.insert( presum[x-1]-presum[fs-1] );\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2664770,
                "title": "c-segment-tree-generic-approach",
                "content": "Use segment tree but instead of storing just sum of the range, store some more information about the range.\\nLets say we have a node that will keep information about range [L,R] then we have\\n1. st , which represents sum starting from index L having all non zero elements.\\n2. en,  which represents sum ending at index R having all non zero elements.\\n3. mx,  which represents maximum sum of any subarray between [L,R] having all non zero elements.\\n4. sum,  which represents sum of all elements in range [L,R].\\n\\nNow the important thing here is add method that will perform merge operation on two nodes.\\n\\n```\\ntypedef long long ll;\\nstruct node{\\n    ll st,en,mx,sum;\\n};\\n\\nvoid add(node& a,node& b,node& c){\\n    c.st = a.st;\\n    if(a.st == a.en && a.st == a.sum && a.st != 0)c.st += b.st;\\n\\n    c.en = b.en;\\n    if(b.en == b.st && b.sum == b.en && b.en != 0) c.en += a.en;\\n\\n    c.sum = a.sum + b.sum;\\n    c.mx = max({a.mx , b.mx, c.st , c.en , a.en + b.st});\\n}\\n\\nconst int mx = 1e5;\\nnode st[3*mx];\\n\\nvoid insert(int ss,int se,int si,const int& idx,const int& val){\\n    \\n    if(ss == se){\\n        st[si].st = st[si].en = st[si].mx = st[si].sum = val;\\n        return;\\n    }\\n    \\n    int mid = (ss + se) / 2;\\n    \\n    if(idx >= ss && idx <= mid) insert(ss,mid,2*si+1,idx,val);\\n    else insert(mid+1,se,2*si+2,idx,val);\\n    \\n    add(st[2*si+1],st[2*si+2],st[si]);\\n}\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<long long> ans(removeQueries.size());\\n        int n = nums.size();\\n        for(int i = 0 ; i < n ; i++){\\n            insert(0 , n - 1, 0 , i , nums[i]);\\n        }\\n        for(int i = 0 ; i < removeQueries.size() ; i++){\\n            insert(0,n-1,0,removeQueries[i],0);\\n            ans[i] = st[0].mx;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\ntypedef long long ll;\\nstruct node{\\n    ll st,en,mx,sum;\\n};\\n\\nvoid add(node& a,node& b,node& c){\\n    c.st = a.st;\\n    if(a.st == a.en && a.st == a.sum && a.st != 0)c.st += b.st;\\n\\n    c.en = b.en;\\n    if(b.en == b.st && b.sum == b.en && b.en != 0) c.en += a.en;\\n\\n    c.sum = a.sum + b.sum;\\n    c.mx = max({a.mx , b.mx, c.st , c.en , a.en + b.st});\\n}\\n\\nconst int mx = 1e5;\\nnode st[3*mx];\\n\\nvoid insert(int ss,int se,int si,const int& idx,const int& val){\\n    \\n    if(ss == se){\\n        st[si].st = st[si].en = st[si].mx = st[si].sum = val;\\n        return;\\n    }\\n    \\n    int mid = (ss + se) / 2;\\n    \\n    if(idx >= ss && idx <= mid) insert(ss,mid,2*si+1,idx,val);\\n    else insert(mid+1,se,2*si+2,idx,val);\\n    \\n    add(st[2*si+1],st[2*si+2],st[si]);\\n}\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<long long> ans(removeQueries.size());\\n        int n = nums.size();\\n        for(int i = 0 ; i < n ; i++){\\n            insert(0 , n - 1, 0 , i , nums[i]);\\n        }\\n        for(int i = 0 ; i < removeQueries.size() ; i++){\\n            insert(0,n-1,0,removeQueries[i],0);\\n            ans[i] = st[0].mx;\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641608,
                "title": "o-n-using-reverse-union-find-union-by-rank-path-compression-simple-code-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    \\n    int get(int i, vector<int>&parent){\\n        \\n        return parent[i] == i ? i :  parent[i] = get(parent[i], parent);\\n    }\\n    \\n    \\n    void Union(int n1, int n2, vector<int> &parent, vector<int> &rank, vector<long long> &sum){\\n        \\n        int p1 = get(n1, parent);\\n        int p2 = get(n2, parent);\\n        \\n        if(rank[p1] == rank[p2]){\\n            sum[p1] += sum[p2];\\n            parent[p2] = p1;\\n            rank[p1]++;\\n        }\\n        else if(rank[p1]<rank[p2]) parent[p1] = p2, sum[p2] += sum[p1];\\n        \\n        else parent[p2] = p1, sum[p1] += sum[p2];\\n    }\\n    \\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq) {\\n        \\n        long long n = nums.size(), maxi = 0; // Maxi stores current maximum segement sum\\n        vector<long long> ans(n);\\n        vector<long long> sum(n,0); // sum[i] = sum of segment whose leader is  = i\\n        vector<int> parent(n, INT_MAX);\\n        vector<int> rank(n,0);\\n        ans[n-1]=0;\\n        \\n        for(int i = n-2;i>=0; i--){\\n            \\n            int node = rq[i+1];\\n            \\n            parent[node] = node;\\n            sum[node] = nums[node];\\n            \\n            if(node-1 >= 0 and parent[node - 1] != INT_MAX)\\n                Union(node, node-1, parent, rank, sum);\\n\\n            if(node+1 < n and parent[node + 1] != INT_MAX)\\n                Union(node, node+1, parent, rank, sum);\\n            \\n            maxi = max(maxi, sum[get(node, parent)]);\\n            \\n            ans[i] = maxi;\\n        }        \\n        \\n        return ans;   \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    \\n    int get(int i, vector<int>&parent){\\n        \\n        return parent[i] == i ? i :  parent[i] = get(parent[i], parent);\\n    }\\n    \\n    \\n    void Union(int n1, int n2, vector<int> &parent, vector<int> &rank, vector<long long> &sum){\\n        \\n        int p1 = get(n1, parent);\\n        int p2 = get(n2, parent);\\n        \\n        if(rank[p1] == rank[p2]){\\n            sum[p1] += sum[p2];\\n            parent[p2] = p1;\\n            rank[p1]++;\\n        }\\n        else if(rank[p1]<rank[p2]) parent[p1] = p2, sum[p2] += sum[p1];\\n        \\n        else parent[p2] = p1, sum[p1] += sum[p2];\\n    }\\n    \\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq) {\\n        \\n        long long n = nums.size(), maxi = 0; // Maxi stores current maximum segement sum\\n        vector<long long> ans(n);\\n        vector<long long> sum(n,0); // sum[i] = sum of segment whose leader is  = i\\n        vector<int> parent(n, INT_MAX);\\n        vector<int> rank(n,0);\\n        ans[n-1]=0;\\n        \\n        for(int i = n-2;i>=0; i--){\\n            \\n            int node = rq[i+1];\\n            \\n            parent[node] = node;\\n            sum[node] = nums[node];\\n            \\n            if(node-1 >= 0 and parent[node - 1] != INT_MAX)\\n                Union(node, node-1, parent, rank, sum);\\n\\n            if(node+1 < n and parent[node + 1] != INT_MAX)\\n                Union(node, node+1, parent, rank, sum);\\n            \\n            maxi = max(maxi, sum[get(node, parent)]);\\n            \\n            ans[i] = maxi;\\n        }        \\n        \\n        return ans;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2626313,
                "title": "javascription-solution-with-hash-table",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} removeQueries\\n * @return {number[]}\\n */\\nvar maximumSegmentSum = function(nums, removeQueries) {\\n    let res = [];\\n    // prefix sum\\n    let prefix = [];\\n    let s = 0;\\n    for(let i=0; i<nums.length; i++){\\n        s += nums[i];\\n        prefix.push(s);\\n    }\\n    \\n    res.push(0);\\n    let len = nums.length;\\n    // save interval, key means left side, value means right side\\n    let map1 = new Map();\\n    // save interval, key means right side, value means left side\\n    let map2 = new Map();\\n\\t\\n    for(let i=len-1; i>0; i--){\\n        let index = removeQueries[i];\\n        let sum = 0;\\n\\t\\t// check if interval exist\\n\\t\\t// interval not exist, save directly\\n        if(!map1.has(index+1) && !map2.has(index-1)){\\n            map1.set(index, index);\\n            map2.set(index, index);\\n            sum = index-1 >= 0 ? prefix[index] - prefix[index-1] : prefix[index];\\n\\t\\t// interval exist, try to merge\\n        }else if(!map2.has(index-1)){\\n\\t\\t\\t// update right side\\n            let end = map1.get(index+1);\\n            map1.set(index, end);\\n\\t\\t\\tmap2.set(end, index);\\n\\t\\t\\t// delete old data\\n            map1.delete(index+1);\\n            map2.delete(end);\\n            sum = index-1 >= 0 ? prefix[end] - prefix[index-1] : prefix[end];\\n\\t\\t// interval exist, try to merge\\t\\n        }else if(!map1.has(index+1)){\\n\\t\\t\\t// update left side\\n            let start = map2.get(index-1);\\n            map2.set(index, start);\\n\\t\\t\\tmap1.set(start, index);\\n\\t\\t\\t// delete old data\\n            map2.delete(index-1);\\n            map1.delete(start);\\n            sum = start-1 >= 0 ? prefix[index] - prefix[start-1] : prefix[index];\\n        }else{\\n            let end = map1.get(index+1);\\n            let start = map2.get(index-1);\\n            map1.delete(index+1);\\n            map2.delete(index-1);\\n            map1.set(start,end);\\n            map2.set(end, start);\\n\\n            sum = start-1 >= 0 ? prefix[end] - prefix[start-1] : prefix[end];\\n        }\\n\\t\\t// compare and get the max one\\n        if(sum > res[res.length-1]){\\n            res.push(sum);\\n        }else{\\n            let last = res[res.length-1];\\n            res.push(last);\\n        }\\n    }\\n\\n    res = res.reverse();\\n\\n    return res;    \\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} removeQueries\\n * @return {number[]}\\n */\\nvar maximumSegmentSum = function(nums, removeQueries) {\\n    let res = [];\\n    // prefix sum\\n    let prefix = [];\\n    let s = 0;\\n    for(let i=0; i<nums.length; i++){\\n        s += nums[i];\\n        prefix.push(s);\\n    }\\n    \\n    res.push(0);\\n    let len = nums.length;\\n    // save interval, key means left side, value means right side\\n    let map1 = new Map();\\n    // save interval, key means right side, value means left side\\n    let map2 = new Map();\\n\\t\\n    for(let i=len-1; i>0; i--){\\n        let index = removeQueries[i];\\n        let sum = 0;\\n\\t\\t// check if interval exist\\n\\t\\t// interval not exist, save directly\\n        if(!map1.has(index+1) && !map2.has(index-1)){\\n            map1.set(index, index);\\n            map2.set(index, index);\\n            sum = index-1 >= 0 ? prefix[index] - prefix[index-1] : prefix[index];\\n\\t\\t// interval exist, try to merge\\n        }else if(!map2.has(index-1)){\\n\\t\\t\\t// update right side\\n            let end = map1.get(index+1);\\n            map1.set(index, end);\\n\\t\\t\\tmap2.set(end, index);\\n\\t\\t\\t// delete old data\\n            map1.delete(index+1);\\n            map2.delete(end);\\n            sum = index-1 >= 0 ? prefix[end] - prefix[index-1] : prefix[end];\\n\\t\\t// interval exist, try to merge\\t\\n        }else if(!map1.has(index+1)){\\n\\t\\t\\t// update left side\\n            let start = map2.get(index-1);\\n            map2.set(index, start);\\n\\t\\t\\tmap1.set(start, index);\\n\\t\\t\\t// delete old data\\n            map2.delete(index-1);\\n            map1.delete(start);\\n            sum = start-1 >= 0 ? prefix[index] - prefix[start-1] : prefix[index];\\n        }else{\\n            let end = map1.get(index+1);\\n            let start = map2.get(index-1);\\n            map1.delete(index+1);\\n            map2.delete(index-1);\\n            map1.set(start,end);\\n            map2.set(end, start);\\n\\n            sum = start-1 >= 0 ? prefix[end] - prefix[start-1] : prefix[end];\\n        }\\n\\t\\t// compare and get the max one\\n        if(sum > res[res.length-1]){\\n            res.push(sum);\\n        }else{\\n            let last = res[res.length-1];\\n            res.push(last);\\n        }\\n    }\\n\\n    res = res.reverse();\\n\\n    return res;    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2602928,
                "title": "c-prefixsum-set-heap-tle-prefixsum-set-mulltiset-accepted",
                "content": "The two methods are similar but the first one require more constant time work. \\n```\\n// TLE\\n#include <bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<ll> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<ll> res;\\n\\t\\tpriority_queue<pair<ll, pair<int, int>>> pq;\\n\\t\\tset<int> removed;\\n\\t\\tll sum = 0;\\n\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t}\\n\\t\\tvector<ll> prefix(nums.size() + 1, 0);\\n\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\tprefix[i + 1] = prefix[i] + (ll)nums[i];\\n\\t\\t}\\n\\t\\tpq.emplace(sum, make_pair(0, nums.size() - 1));\\n\\t\\tfor (int i = 0; i < removeQueries.size() - 1; i++) {\\n\\t\\t\\tremoved.insert(removeQueries[i]);\\n\\t\\t\\tbool done = false;\\n\\t\\t\\twhile (!done) {\\n\\t\\t\\t\\tauto curr = pq.top(); \\n\\t\\t\\t\\tll sum = curr.first;\\n\\t\\t\\t\\tint l = curr.second.first, r = curr.second.second;\\n\\t\\t\\t\\t// if (l > r) continue;\\n\\t\\t\\t\\tauto itr = lower_bound(removed.begin(), removed.end(), l);\\n\\t\\t\\t\\tif (itr == removed.end() || *itr > r) {\\n\\t\\t\\t\\t\\tdone = true;\\n\\t\\t\\t\\t\\tres.push_back(sum);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\t\\tif (*itr == l && l < r) {\\n\\t\\t\\t\\t\\t\\tpq.emplace(prefix[r + 1] - prefix[l + 1], make_pair(l + 1, r));\\n\\t\\t\\t\\t\\t} else if (*itr == r && l < r) {\\n\\t\\t\\t\\t\\t\\tpq.emplace(prefix[r] - prefix[l], make_pair(l, r - 1));\\n\\t\\t\\t\\t\\t} else if (*itr > l && *itr < r) {\\n\\t\\t\\t\\t\\t\\tpq.emplace(prefix[(*itr)] - prefix[l], make_pair(l, (*itr) - 1));\\n\\t\\t\\t\\t\\t\\tpq.emplace(prefix[r + 1] - prefix[(*itr) + 1], make_pair((*itr) + 1, r));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres.push_back(0);\\n\\t\\treturn res;\\n    }\\n};\\n```\\nNeed to notice that when removing an element from the multiset, we need to remove the iterator instead of by value, the latter one will remove all element has that value. \\n```\\n// Accepted\\n#include <bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<ll> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n\\t\\tint n = nums.size();\\n        multiset<ll> valid;\\n\\t\\tset<int> removed;\\n\\t\\tvector<ll> S(n + 1, 0);\\n\\t\\tvector<ll> res;\\n\\t\\tfor (int i = 0; i < n; i++) S[i + 1] = S[i] + nums[i];\\n\\t\\tvalid.insert(S[n]);\\n\\t\\tvalid.insert(0);\\n\\t\\tremoved.insert(-1);\\n\\t\\tremoved.insert(n);\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tremoved.insert(removeQueries[i]);\\n\\t\\t\\tauto pre = prev(removed.find(removeQueries[i]));\\n\\t\\t\\tauto ne = next(removed.find(removeQueries[i]));\\n\\t\\t\\tint l = *pre, r = *ne;\\n            valid.erase(valid.find(S[r] - S[l + 1]));\\n\\t\\t\\tif (l + 1 != removeQueries[i]) {\\n\\t\\t\\t\\tvalid.insert(S[removeQueries[i]] - S[l + 1]);\\n\\t\\t\\t}\\n\\t\\t\\tif (r - 1 != removeQueries[i]) {\\n\\t\\t\\t\\tvalid.insert(S[r] - S[removeQueries[i] + 1]);\\n\\t\\t\\t}\\n\\t\\t\\tres.push_back(*prev(valid.end()));\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\n// TLE\\n#include <bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<ll> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<ll> res;\\n\\t\\tpriority_queue<pair<ll, pair<int, int>>> pq;\\n\\t\\tset<int> removed;\\n\\t\\tll sum = 0;\\n\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\tsum += nums[i];\\n\\t\\t}\\n\\t\\tvector<ll> prefix(nums.size() + 1, 0);\\n\\t\\tfor (int i = 0; i < nums.size(); i++) {\\n\\t\\t\\tprefix[i + 1] = prefix[i] + (ll)nums[i];\\n\\t\\t}\\n\\t\\tpq.emplace(sum, make_pair(0, nums.size() - 1));\\n\\t\\tfor (int i = 0; i < removeQueries.size() - 1; i++) {\\n\\t\\t\\tremoved.insert(removeQueries[i]);\\n\\t\\t\\tbool done = false;\\n\\t\\t\\twhile (!done) {\\n\\t\\t\\t\\tauto curr = pq.top(); \\n\\t\\t\\t\\tll sum = curr.first;\\n\\t\\t\\t\\tint l = curr.second.first, r = curr.second.second;\\n\\t\\t\\t\\t// if (l > r) continue;\\n\\t\\t\\t\\tauto itr = lower_bound(removed.begin(), removed.end(), l);\\n\\t\\t\\t\\tif (itr == removed.end() || *itr > r) {\\n\\t\\t\\t\\t\\tdone = true;\\n\\t\\t\\t\\t\\tres.push_back(sum);\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tpq.pop();\\n\\t\\t\\t\\t\\tif (*itr == l && l < r) {\\n\\t\\t\\t\\t\\t\\tpq.emplace(prefix[r + 1] - prefix[l + 1], make_pair(l + 1, r));\\n\\t\\t\\t\\t\\t} else if (*itr == r && l < r) {\\n\\t\\t\\t\\t\\t\\tpq.emplace(prefix[r] - prefix[l], make_pair(l, r - 1));\\n\\t\\t\\t\\t\\t} else if (*itr > l && *itr < r) {\\n\\t\\t\\t\\t\\t\\tpq.emplace(prefix[(*itr)] - prefix[l], make_pair(l, (*itr) - 1));\\n\\t\\t\\t\\t\\t\\tpq.emplace(prefix[r + 1] - prefix[(*itr) + 1], make_pair((*itr) + 1, r));\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tres.push_back(0);\\n\\t\\treturn res;\\n    }\\n};\\n```\n```\\n// Accepted\\n#include <bits/stdc++.h>\\nusing namespace std;\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<ll> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n\\t\\tint n = nums.size();\\n        multiset<ll> valid;\\n\\t\\tset<int> removed;\\n\\t\\tvector<ll> S(n + 1, 0);\\n\\t\\tvector<ll> res;\\n\\t\\tfor (int i = 0; i < n; i++) S[i + 1] = S[i] + nums[i];\\n\\t\\tvalid.insert(S[n]);\\n\\t\\tvalid.insert(0);\\n\\t\\tremoved.insert(-1);\\n\\t\\tremoved.insert(n);\\n\\t\\tfor (int i = 0; i < n; i++) {\\n\\t\\t\\tremoved.insert(removeQueries[i]);\\n\\t\\t\\tauto pre = prev(removed.find(removeQueries[i]));\\n\\t\\t\\tauto ne = next(removed.find(removeQueries[i]));\\n\\t\\t\\tint l = *pre, r = *ne;\\n            valid.erase(valid.find(S[r] - S[l + 1]));\\n\\t\\t\\tif (l + 1 != removeQueries[i]) {\\n\\t\\t\\t\\tvalid.insert(S[removeQueries[i]] - S[l + 1]);\\n\\t\\t\\t}\\n\\t\\t\\tif (r - 1 != removeQueries[i]) {\\n\\t\\t\\t\\tvalid.insert(S[r] - S[removeQueries[i] + 1]);\\n\\t\\t\\t}\\n\\t\\t\\tres.push_back(*prev(valid.end()));\\n\\t\\t}\\n\\t\\treturn res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2584930,
                "title": "2-dimention-segment-tree-solution",
                "content": "It is kind of complicated.\\n\\nThe time complexity is O(N(logN)^2).\\nThe merge function costs (logN)^2 beacuse there is a segment tree used to maintain the interval sum in it and it executes logN times.\\nShould I call it 2D-segment tree?\\n\\nI feel incredible when it works.\\nJust want ro record something.\\nIf you can understand it , that is great.\\n```\\nclass Sgtree2{\\n    public:\\n    vector<long long> v;\\n    Sgtree2(vector<int>& input){\\n        int n = input.size();\\n        v = vector<long long>(4*n,0);\\n        build(0,n-1,0,input);\\n    }\\n    void build(int l , int r, int node,vector<int>& arr){\\n        if(l==r){\\n            v[node] = arr[l];\\n            return ;\\n        }\\n        int m = (l+r)/2;\\n        build(l,m,node*2+1,arr);\\n        build(m+1,r,node*2+2,arr);\\n        v[node] = v[node*2+1]+v[node*2+2];\\n    }\\n    void update(int l , int r,int node , int pos,int val){\\n        if(l==r){\\n            v[node] = val;\\n            return;\\n        }\\n        int m = (l+r)/2;\\n        if(pos>=l && pos <= m ){\\n            update(l,m,node*2+1,pos,val);\\n        }else{\\n            update(m+1,r,node*2+2,pos,val);\\n        }\\n        v[node] = v[node*2+1]+v[node*2+2];\\n    }\\n    long long query(int l , int r, int L , int R, int node){\\n        if(l==L && r == R){\\n            return v[node];\\n        }\\n        int M = (L+R)/2;\\n        if( r <= M ){\\n            return query(l,r,L,M,node*2+1);\\n        }else if(l>M){\\n            return query(l,r,M+1,R,node*2+2);\\n        }else{\\n            return query(l,M,L,M,node*2+1) + query(M+1,r,M+1,R,node*2+2);\\n        }\\n    }\\n    \\n};\\nclass Sgtree{\\n    public:\\n    vector<long long> v;\\n    vector<int> left,right;//the leftmost/rightmost value of interval of v[node] \\n    vector<int> leftzero , rightzero;//leftmost/rightmost zero\\'s idx of interval of v[node].\\n    \\n    int n ;\\n    Sgtree2 *pre;\\n    Sgtree(vector<int>& arr,Sgtree2 *t){\\n        n = arr.size();\\n        v = vector<long long>(4*n,0);\\n        left = vector<int>(4*n,0);\\n        right = vector<int>(4*n,0);\\n        \\n        leftzero = vector<int>(4*n,-1);\\n        rightzero = vector<int>(4*n,-1);\\n        \\n        pre = t;\\n        build(0,n-1,0,arr);\\n    }\\n    void build(int l , int r, int node,vector<int>& arr){\\n        if(l==r){\\n            v[node] = arr[l];\\n            left[node]=arr[l];\\n            right[node]=arr[l];\\n            if(arr[l]==0){\\n                leftzero[node] = l;\\n                rightzero[node] = l;\\n            }\\n            return ;\\n        }\\n        int m = (l+r)/2;\\n        build(l,m,node*2+1,arr);\\n        build(m+1,r,node*2+2,arr);\\n        merge(l,r,node);\\n    }\\n    long long update(int l , int r , int node , int pos , int val){\\n        if(l==r){\\n            v[node] = val;\\n            left[node]=val;\\n            right[node]=val;\\n            if(val==0){\\n                leftzero[node] = l;\\n                rightzero[node] = l;\\n            }\\n            pre->update(0,n-1,0,pos,val);\\n            return v[node];\\n        }\\n        int m = (l+r)/2;\\n        if(pos>=l && pos <= m ){\\n            update(l,m,node*2+1,pos,val);\\n        }else{\\n            update(m+1,r,node*2+2,pos,val);\\n        }\\n        \\n        merge(l,r,node);\\n        return v[node];\\n    }\\n    void merge(int l ,int r , int node){\\n        if(right[node*2+1] == 0 || left[node*2+2] == 0 ){\\n            v[node] = max(v[node*2+1],v[node*2+2]);\\n        }else{\\n            if(rightzero[node*2+1] == -1 && leftzero[node*2+2]==-1){\\n                v[node] = v[node*2+1]+v[node*2+2];\\n            }else if(rightzero[node*2+1] == -1){\\n                int idx = leftzero[node*2+2];\\n                v[node] = max( pre->query( l , idx ,0 ,n-1,0) , v[node*2+2] );\\n            }else if(leftzero[node*2+2]==-1){\\n                int idx = rightzero[node*2+1];\\n                v[node] = max( pre->query( idx , r ,0 ,n-1,0) , v[node*2+1] );\\n            }else{\\n                int tl = rightzero[node*2+1];\\n                int tr = leftzero[node*2+2];\\n                v[node] = max( {v[node*2+1],v[node*2+2] , pre->query( tl , tr ,0 ,n-1,0) } );\\n            }\\n        }\\n        left[node] = left[node*2+1];\\n        right[node] = right[node*2+2];\\n        if(leftzero[node*2+1]==-1){\\n            leftzero[node] = leftzero[node*2+2];\\n        }else{\\n            leftzero[node] = leftzero[node*2+1];\\n        }\\n        if(rightzero[node*2+2]==-1){\\n            rightzero[node] = rightzero[node*2+1];\\n        }else{\\n            rightzero[node] = rightzero[node*2+2];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        //time O(n(logn)^2 );\\n        int n = nums.size();\\n        vector<long long> ans;\\n        Sgtree2 * pre = new Sgtree2(nums);\\n        Sgtree *sgt = new Sgtree(nums,pre);\\n        \\n        for(auto&& i : removeQueries){\\n            ans.push_back(sgt->update(0,n-1,0,i,0));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Sgtree2{\\n    public:\\n    vector<long long> v;\\n    Sgtree2(vector<int>& input){\\n        int n = input.size();\\n        v = vector<long long>(4*n,0);\\n        build(0,n-1,0,input);\\n    }\\n    void build(int l , int r, int node,vector<int>& arr){\\n        if(l==r){\\n            v[node] = arr[l];\\n            return ;\\n        }\\n        int m = (l+r)/2;\\n        build(l,m,node*2+1,arr);\\n        build(m+1,r,node*2+2,arr);\\n        v[node] = v[node*2+1]+v[node*2+2];\\n    }\\n    void update(int l , int r,int node , int pos,int val){\\n        if(l==r){\\n            v[node] = val;\\n            return;\\n        }\\n        int m = (l+r)/2;\\n        if(pos>=l && pos <= m ){\\n            update(l,m,node*2+1,pos,val);\\n        }else{\\n            update(m+1,r,node*2+2,pos,val);\\n        }\\n        v[node] = v[node*2+1]+v[node*2+2];\\n    }\\n    long long query(int l , int r, int L , int R, int node){\\n        if(l==L && r == R){\\n            return v[node];\\n        }\\n        int M = (L+R)/2;\\n        if( r <= M ){\\n            return query(l,r,L,M,node*2+1);\\n        }else if(l>M){\\n            return query(l,r,M+1,R,node*2+2);\\n        }else{\\n            return query(l,M,L,M,node*2+1) + query(M+1,r,M+1,R,node*2+2);\\n        }\\n    }\\n    \\n};\\nclass Sgtree{\\n    public:\\n    vector<long long> v;\\n    vector<int> left,right;//the leftmost/rightmost value of interval of v[node] \\n    vector<int> leftzero , rightzero;//leftmost/rightmost zero\\'s idx of interval of v[node].\\n    \\n    int n ;\\n    Sgtree2 *pre;\\n    Sgtree(vector<int>& arr,Sgtree2 *t){\\n        n = arr.size();\\n        v = vector<long long>(4*n,0);\\n        left = vector<int>(4*n,0);\\n        right = vector<int>(4*n,0);\\n        \\n        leftzero = vector<int>(4*n,-1);\\n        rightzero = vector<int>(4*n,-1);\\n        \\n        pre = t;\\n        build(0,n-1,0,arr);\\n    }\\n    void build(int l , int r, int node,vector<int>& arr){\\n        if(l==r){\\n            v[node] = arr[l];\\n            left[node]=arr[l];\\n            right[node]=arr[l];\\n            if(arr[l]==0){\\n                leftzero[node] = l;\\n                rightzero[node] = l;\\n            }\\n            return ;\\n        }\\n        int m = (l+r)/2;\\n        build(l,m,node*2+1,arr);\\n        build(m+1,r,node*2+2,arr);\\n        merge(l,r,node);\\n    }\\n    long long update(int l , int r , int node , int pos , int val){\\n        if(l==r){\\n            v[node] = val;\\n            left[node]=val;\\n            right[node]=val;\\n            if(val==0){\\n                leftzero[node] = l;\\n                rightzero[node] = l;\\n            }\\n            pre->update(0,n-1,0,pos,val);\\n            return v[node];\\n        }\\n        int m = (l+r)/2;\\n        if(pos>=l && pos <= m ){\\n            update(l,m,node*2+1,pos,val);\\n        }else{\\n            update(m+1,r,node*2+2,pos,val);\\n        }\\n        \\n        merge(l,r,node);\\n        return v[node];\\n    }\\n    void merge(int l ,int r , int node){\\n        if(right[node*2+1] == 0 || left[node*2+2] == 0 ){\\n            v[node] = max(v[node*2+1],v[node*2+2]);\\n        }else{\\n            if(rightzero[node*2+1] == -1 && leftzero[node*2+2]==-1){\\n                v[node] = v[node*2+1]+v[node*2+2];\\n            }else if(rightzero[node*2+1] == -1){\\n                int idx = leftzero[node*2+2];\\n                v[node] = max( pre->query( l , idx ,0 ,n-1,0) , v[node*2+2] );\\n            }else if(leftzero[node*2+2]==-1){\\n                int idx = rightzero[node*2+1];\\n                v[node] = max( pre->query( idx , r ,0 ,n-1,0) , v[node*2+1] );\\n            }else{\\n                int tl = rightzero[node*2+1];\\n                int tr = leftzero[node*2+2];\\n                v[node] = max( {v[node*2+1],v[node*2+2] , pre->query( tl , tr ,0 ,n-1,0) } );\\n            }\\n        }\\n        left[node] = left[node*2+1];\\n        right[node] = right[node*2+2];\\n        if(leftzero[node*2+1]==-1){\\n            leftzero[node] = leftzero[node*2+2];\\n        }else{\\n            leftzero[node] = leftzero[node*2+1];\\n        }\\n        if(rightzero[node*2+2]==-1){\\n            rightzero[node] = rightzero[node*2+1];\\n        }else{\\n            rightzero[node] = rightzero[node*2+2];\\n        }\\n    }\\n    \\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        //time O(n(logn)^2 );\\n        int n = nums.size();\\n        vector<long long> ans;\\n        Sgtree2 * pre = new Sgtree2(nums);\\n        Sgtree *sgt = new Sgtree(nums,pre);\\n        \\n        for(auto&& i : removeQueries){\\n            ans.push_back(sgt->update(0,n-1,0,i,0));\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581903,
                "title": "c-direct-simulation-multiset-prefix-sum",
                "content": "```\\nclass Solution {\\n    \\npublic:\\n    #define LL long long\\n    \\n    \\n    multiset<LL> segsum;\\n    LL prefix[100010] = {0};\\n    vector<LL> ans;\\n    set<int> qid;\\n    int n;\\n    \\n    void split(int l, int r, int at){\\n        LL ori = prefix[r-1] - prefix[l];\\n        LL n1 = prefix[at-1] - prefix[l];\\n        LL n2 = prefix[r-1] - prefix[at];\\n   \\n        segsum.erase(segsum.lower_bound(ori)); // erase only 1 element, not all element with same value\\n        segsum.insert(n1);\\n        segsum.insert(n2);\\n        \\n        ans.push_back(*prev(segsum.end()));\\n    }\\n    \\n    pair<int,int> findSegRange(int at){\\n        auto pos = qid.lower_bound(at);\\n        int lo = *prev(pos) ;\\n        int hi = *pos;\\n\\n        return {lo, hi};\\n    }\\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        n = nums.size();\\n        \\n        for(int i=1; i<=n; i++) prefix[i] = prefix[i-1] + nums[i-1];\\n        qid.insert(0);\\n        qid.insert(n+1);\\n        segsum.insert(prefix[n]);\\n        \\n        for(int q : removeQueries){\\n            auto range = findSegRange(q+1);\\n            split(range.first, range.second, q+1);\\n            qid.insert(q+1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Simulation",
                    "Binary Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\n    \\npublic:\\n    #define LL long long\\n    \\n    \\n    multiset<LL> segsum;\\n    LL prefix[100010] = {0};\\n    vector<LL> ans;\\n    set<int> qid;\\n    int n;\\n    \\n    void split(int l, int r, int at){\\n        LL ori = prefix[r-1] - prefix[l];\\n        LL n1 = prefix[at-1] - prefix[l];\\n        LL n2 = prefix[r-1] - prefix[at];\\n   \\n        segsum.erase(segsum.lower_bound(ori)); // erase only 1 element, not all element with same value\\n        segsum.insert(n1);\\n        segsum.insert(n2);\\n        \\n        ans.push_back(*prev(segsum.end()));\\n    }\\n    \\n    pair<int,int> findSegRange(int at){\\n        auto pos = qid.lower_bound(at);\\n        int lo = *prev(pos) ;\\n        int hi = *pos;\\n\\n        return {lo, hi};\\n    }\\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        n = nums.size();\\n        \\n        for(int i=1; i<=n; i++) prefix[i] = prefix[i-1] + nums[i-1];\\n        qid.insert(0);\\n        qid.insert(n+1);\\n        segsum.insert(prefix[n]);\\n        \\n        for(int q : removeQueries){\\n            auto range = findSegRange(q+1);\\n            split(range.first, range.second, q+1);\\n            qid.insert(q+1);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2568519,
                "title": "python-reverse-with-explantions",
                "content": "## IDEA:\\nWe start from an empty list and will add elements from the last removed one by one. \\nWe keep an array of segments with each element containing the left, right, and the sum of the segment in it. Adding a new element to the list has four different scenarios. It either adds a new segment ( meaning left and right is empty) or merges left, right, or both. A merge function merges to segment using the most left node of the left list and the rightmost node of the correct list. We first try to merge the new segment with the left segment and then merge it again with the right segment. Finally, we have a value of max from the last segments. We compare it to the new segment created and add it to the answer list. \\n\\n**if you find the solution helpful. PLEASE CONSIDER UPVOTING.\\nTHANK YOU**\\n\\n```\\nclass Solution:\\n\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        answer, segs = [0]*n, [0] * n\\n        curMax = 0\\n        index = n-2\\n        for i in range(n):\\n            segs[i] = [0, 0, 0]\\n        for i in removeQueries[::-1][:-1]:\\n            segs[i] = [i, i, nums[i]]\\n            if(i > 0 and segs[i-1][2] > 0):\\n                myMerge(segs[i-1][0], segs[i][1], segs)\\n            if(i < n-1 and segs[i+1][2] > 0):\\n                myMerge(segs[i][0], segs[i+1][1], segs)\\n            curMax = max(segs[segs[i][0]][2], curMax)\\n            answer[index] = curMax\\n            index -= 1\\n        return answer\\n\\n\\ndef myMerge(left, right, array):\\n    array[left][1] = right\\n    array[right][0] = left\\n    array[left][2] = array[right][2]+array[left][2]\\n    array[right][2] = array[left][2]\\n```",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        answer, segs = [0]*n, [0] * n\\n        curMax = 0\\n        index = n-2\\n        for i in range(n):\\n            segs[i] = [0, 0, 0]\\n        for i in removeQueries[::-1][:-1]:\\n            segs[i] = [i, i, nums[i]]\\n            if(i > 0 and segs[i-1][2] > 0):\\n                myMerge(segs[i-1][0], segs[i][1], segs)\\n            if(i < n-1 and segs[i+1][2] > 0):\\n                myMerge(segs[i][0], segs[i+1][1], segs)\\n            curMax = max(segs[segs[i][0]][2], curMax)\\n            answer[index] = curMax\\n            index -= 1\\n        return answer\\n\\n\\ndef myMerge(left, right, array):\\n    array[left][1] = right\\n    array[right][0] = left\\n    array[left][2] = array[right][2]+array[left][2]\\n    array[right][2] = array[left][2]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2556691,
                "title": "python-o-n-solution-using-array-sum",
                "content": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        length, maximum = len(nums), 0\\n        ans, sm, count = [0 for _ in range(length)], [0 for _ in range(length)], [0 for _ in range(length)]\\n        for i in range(length - 1, -1, -1):\\n            ans[i], index = maximum, removeQueries[i]\\n            leftCount = count[index - 1] if index - 1 >= 0 else 0\\n            leftSum = sm[index - 1] if index - 1 >= 0 else 0\\n            rightCount = count[index + 1] if index + 1 < length else 0\\n            rightSum = sm[index + 1] if index + 1 < length else 0\\n            count[index] = 1 + leftCount + rightCount\\n            count[index - leftCount] = 1 + leftCount + rightCount\\n            count[index + rightCount] = 1 + leftCount + rightCount\\n            sm[index] = nums[index] + leftSum + rightSum\\n            sm[index - leftCount] = nums[index] + leftSum + rightSum\\n            sm[index + rightCount] = nums[index] + leftSum + rightSum\\n            maximum = max(maximum, sm[index])\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        length, maximum = len(nums), 0\\n        ans, sm, count = [0 for _ in range(length)], [0 for _ in range(length)], [0 for _ in range(length)]\\n        for i in range(length - 1, -1, -1):\\n            ans[i], index = maximum, removeQueries[i]\\n            leftCount = count[index - 1] if index - 1 >= 0 else 0\\n            leftSum = sm[index - 1] if index - 1 >= 0 else 0\\n            rightCount = count[index + 1] if index + 1 < length else 0\\n            rightSum = sm[index + 1] if index + 1 < length else 0\\n            count[index] = 1 + leftCount + rightCount\\n            count[index - leftCount] = 1 + leftCount + rightCount\\n            count[index + rightCount] = 1 + leftCount + rightCount\\n            sm[index] = nums[index] + leftSum + rightSum\\n            sm[index - leftCount] = nums[index] + leftSum + rightSum\\n            sm[index + rightCount] = nums[index] + leftSum + rightSum\\n            maximum = max(maximum, sm[index])\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549943,
                "title": "100-simple-boundary-java-solution-with-just-array-sum-and-count",
                "content": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n     \\n        int len=nums.length;\\n        long ans[]=new long[len];\\n        long sum[]=new long[len];\\n        int count[]=new int[len];\\n        long max=0;\\n       \\n        for(int i=len-1;i>=0;i--){\\n            ans[i]=max;\\n            int index=removeQueries[i];\\n            \\n            int leftCount=index-1>=0?count[index-1]:0;\\n            long leftSum=index-1>=0?sum[index-1]:0;\\n            \\n            int rightCount=index+1<len?count[index+1]:0; \\n            long rightSum=index+1<len?sum[index+1]:0; \\n            \\n            \\n            count[index]=1+leftCount+rightCount;\\n            count[index-leftCount]=1+leftCount+rightCount;\\n            count[index+rightCount]=1+leftCount+rightCount;\\n            \\n            sum[index]=nums[index]+leftSum+rightSum;\\n            sum[index-leftCount]=nums[index]+leftSum+rightSum;\\n            sum[index+rightCount]=nums[index]+leftSum+rightSum;\\n            \\n            max=Math.max(sum[index],max);\\n          \\n        }\\n        return ans;\\n    }\\n}\\n",
                "solutionTags": [
                    "Java",
                    "Prefix Sum"
                ],
                "code": "class Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n     \\n        int len=nums.length;\\n        long ans[]=new long[len];\\n        long sum[]=new long[len];\\n        int count[]=new int[len];\\n        long max=0;\\n       \\n        for(int i=len-1;i>=0;i--){\\n            ans[i]=max;\\n            int index=removeQueries[i];\\n            \\n            int leftCount=index-1>=0?count[index-1]:0;\\n            long leftSum=index-1>=0?sum[index-1]:0;\\n            \\n            int rightCount=index+1<len?count[index+1]:0; \\n            long rightSum=index+1<len?sum[index+1]:0; \\n            \\n            \\n            count[index]=1+leftCount+rightCount;\\n            count[index-leftCount]=1+leftCount+rightCount;\\n            count[index+rightCount]=1+leftCount+rightCount;\\n            \\n            sum[index]=nums[index]+leftSum+rightSum;\\n            sum[index-leftCount]=nums[index]+leftSum+rightSum;\\n            sum[index+rightCount]=nums[index]+leftSum+rightSum;\\n            \\n            max=Math.max(sum[index],max);\\n          \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2506406,
                "title": "c-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        map<long long,long long>mp;\\n        int n=nums.size();\\n        set<int>remove{-1,n};\\n        multiset<long long>temp;\\n        vector<long long>ans(n,0);\\n        long long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            mp[i]=sum;\\n        }\\n        for(int i=0;i<n;i++){\\n            auto r=(remove.lower_bound(removeQueries[i]));\\n            auto l=--(remove.lower_bound(removeQueries[i]));\\n            long long rem=mp[*(r)-1]-mp[*(l)];\\n            if(temp.find(rem)!=temp.end())\\n                temp.erase(temp.find(rem));\\n            long long t1=mp[*(r)-1]-mp[removeQueries[i]];\\n            long long t2=mp[removeQueries[i]-1]-mp[*(l)];\\n            remove.insert(removeQueries[i]);\\n            temp.insert(t1);\\n            temp.insert(t2);\\n            ans[i]=*(temp.rbegin());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        map<long long,long long>mp;\\n        int n=nums.size();\\n        set<int>remove{-1,n};\\n        multiset<long long>temp;\\n        vector<long long>ans(n,0);\\n        long long sum=0;\\n        for(int i=0;i<n;i++){\\n            sum+=nums[i];\\n            mp[i]=sum;\\n        }\\n        for(int i=0;i<n;i++){\\n            auto r=(remove.lower_bound(removeQueries[i]));\\n            auto l=--(remove.lower_bound(removeQueries[i]));\\n            long long rem=mp[*(r)-1]-mp[*(l)];\\n            if(temp.find(rem)!=temp.end())\\n                temp.erase(temp.find(rem));\\n            long long t1=mp[*(r)-1]-mp[removeQueries[i]];\\n            long long t2=mp[removeQueries[i]-1]-mp[*(l)];\\n            remove.insert(removeQueries[i]);\\n            temp.insert(t1);\\n            temp.insert(t2);\\n            ans[i]=*(temp.rbegin());\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498324,
                "title": "clean-c-solution-o-n-using-dsu",
                "content": "\\n\\'\\'\\'\\n\\nclass Solution {\\npublic:\\n\\nstruct dsu {\\n\\n    vector<int> p;\\n    vector<long long> sum;\\n    int n;\\n    dsu(int _n = -1) {if (_n >= 0) init(_n);}\\n\\n    void init(int _n) {p.assign(_n + 1, -1); n = _n;sum.assign(n+1,0LL);}\\n    int find(int x) \\n\\t{\\n\\t\\t\\treturn p[x] == x ? x : p[x] = find(p[x]);\\n\\t}\\n    bool unite(int x, int y) {\\n        x = find(x),y = find(y),sum[x] += sum[y],p[y] = x;\\n        return true;\\n    }\\n    long long  getsum(int x){\\n\\t\\t\\treturn sum[find(x)];\\n\\t}\\n};\\n\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& qr) {\\n        vector<long long> ans;      \\n        int n=  qr.size();\\n        long long cur=0;\\n        ans.push_back(cur);\\n        reverse(qr.begin(),qr.end());\\n        qr.pop_back();\\n        dsu tr=dsu(n);\\n        for(int &x:qr)\\n        {\\n            tr.p[x]=x;\\n            tr.sum[x]=nums[x];\\n            if(x+1<n && tr.p[x+1]>x){\\n                tr.sum[x]+=tr.sum[x+1];\\n                tr.p[x+1]=x;\\n            }            \\n            if(x>0 && tr.p[x-1]>=0)tr.unite(x-1,x);\\n\\n            cur=max(cur,tr.getsum(x));\\n            ans.push_back(cur);\\n        }\\n\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [
                    "Union Find"
                ],
                "code": "class Solution {\\npublic:\\n\\nstruct dsu {\\n\\n    vector<int> p;\\n    vector<long long> sum;\\n    int n;\\n    dsu(int _n = -1) {if (_n >= 0) init(_n);}",
                "codeTag": "Java"
            },
            {
                "id": 2497514,
                "title": "c",
                "content": "**Main Idea:**\\nRevert the procedure; Use root of disjoint set as the key of unordered map, similar to https://leetcode.com/submissions/detail/766337032/\\n\\n```\\nclass UnionFind {\\npublic:\\n    UnionFind(int sz) : root(sz), rank(sz) {\\n        for (int i = 0; i < sz; i++) {\\n            root[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n\\n    int find(int x) {\\n        while (x != root[x]) {\\n            x = root[x];\\n        }\\n        return x;\\n    }\\n\\n    void unionSet(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if (rootX != rootY) {\\n            if (rank[rootX] > rank[rootY]) {\\n                root[rootY] = rootX;\\n            } else if (rank[rootX] < rank[rootY]) {\\n                root[rootX] = rootY;\\n            } else {\\n                root[rootY] = rootX;\\n                rank[rootX] += 1;\\n            }\\n        }\\n    }\\n\\n    bool connected(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n\\nprivate:\\n    vector<int> root;\\n    vector<int> rank;\\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        unordered_set<int> get;\\n        unordered_map<int, long long> root_to_val;\\n        UnionFind uf(nums.size());\\n        vector<long long> ans = {0};\\n        long long prev = 0;\\n        \\n        for (int i = removeQueries.size() - 1; i >= 1; -- i){\\n            int curr = removeQueries[i];\\n            get.insert(curr);\\n            long long left_val = 0, right_val = 0;\\n            \\n            if (get.find(curr - 1) != get.end()){\\n                left_val = root_to_val[uf.find(curr - 1)];\\n                uf.unionSet(curr, curr - 1);\\n            }\\n            if (get.find(curr + 1) != get.end()){\\n                right_val = root_to_val[uf.find(curr + 1)];\\n                uf.unionSet(curr, curr + 1);\\n            }\\n            \\n            prev = max(nums[curr] + left_val + right_val, prev);\\n            root_to_val[uf.find(curr)] = nums[curr] + left_val + right_val;\\n            ans.push_back(prev);\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n    \\n    long long max(long long a, long long b){\\n        return a > b ? a : b;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass UnionFind {\\npublic:\\n    UnionFind(int sz) : root(sz), rank(sz) {\\n        for (int i = 0; i < sz; i++) {\\n            root[i] = i;\\n            rank[i] = 1;\\n        }\\n    }\\n\\n    int find(int x) {\\n        while (x != root[x]) {\\n            x = root[x];\\n        }\\n        return x;\\n    }\\n\\n    void unionSet(int x, int y) {\\n        int rootX = find(x);\\n        int rootY = find(y);\\n        if (rootX != rootY) {\\n            if (rank[rootX] > rank[rootY]) {\\n                root[rootY] = rootX;\\n            } else if (rank[rootX] < rank[rootY]) {\\n                root[rootX] = rootY;\\n            } else {\\n                root[rootY] = rootX;\\n                rank[rootX] += 1;\\n            }\\n        }\\n    }\\n\\n    bool connected(int x, int y) {\\n        return find(x) == find(y);\\n    }\\n\\nprivate:\\n    vector<int> root;\\n    vector<int> rank;\\n};\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        unordered_set<int> get;\\n        unordered_map<int, long long> root_to_val;\\n        UnionFind uf(nums.size());\\n        vector<long long> ans = {0};\\n        long long prev = 0;\\n        \\n        for (int i = removeQueries.size() - 1; i >= 1; -- i){\\n            int curr = removeQueries[i];\\n            get.insert(curr);\\n            long long left_val = 0, right_val = 0;\\n            \\n            if (get.find(curr - 1) != get.end()){\\n                left_val = root_to_val[uf.find(curr - 1)];\\n                uf.unionSet(curr, curr - 1);\\n            }\\n            if (get.find(curr + 1) != get.end()){\\n                right_val = root_to_val[uf.find(curr + 1)];\\n                uf.unionSet(curr, curr + 1);\\n            }\\n            \\n            prev = max(nums[curr] + left_val + right_val, prev);\\n            root_to_val[uf.find(curr)] = nums[curr] + left_val + right_val;\\n            ans.push_back(prev);\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        return ans;\\n    }\\n    \\n    long long max(long long a, long long b){\\n        return a > b ? a : b;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2496365,
                "title": "segment-tree",
                "content": "This segment tree will calculate the maximum segment sum\\nIf we seperate the segments with a very large value like -10^14. Than this tree can handle this question\\n```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        long[] arr = new long[nums.length];\\n        for(int i=0;i<nums.length;i++) arr[i] = (long)nums[i];\\n        MaximalSumSegmentTree maximalSumSegmentTree = new MaximalSumSegmentTree(arr);\\n        long[] answer = new long[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            long res = maximalSumSegmentTree.updateQuery(removeQueries[i],-1_000_000_000_000_00L).maximumSegmentSum;\\n            if(res>0) answer[i] = res;\\n        }\\n        return answer;\\n    }\\n}\\nclass MaximalSumSegmentTree{\\n    int lengthOfArray;\\n    Node[] segmentArray;\\n\\n    public MaximalSumSegmentTree(long[] arr){\\n        this.lengthOfArray = arr.length;\\n        int heightOfSegmentTree = (int)Math.ceil(Math.log(lengthOfArray)/Math.log(2));\\n        int sizeOfSegmentArray = 2*(1<<heightOfSegmentTree)-1;\\n        this.segmentArray = new Node[sizeOfSegmentArray];\\n        constructorUtil(0,lengthOfArray-1,0,arr);\\n    }\\n    public Node constructorUtil(int segmentStart, int segmentEnd, int segmentIndex, long[] arr){\\n        if(segmentEnd==segmentStart){\\n            if(arr[segmentStart]>=0){\\n                return segmentArray[segmentIndex] = new Node(arr[segmentStart],arr[segmentStart],arr[segmentStart],arr[segmentStart]);\\n            }\\n            return segmentArray[segmentIndex] = new Node(0,0,arr[segmentStart],0);\\n        }\\n        int mid = getMid(segmentStart,segmentEnd);\\n        Node leftChild = constructorUtil(segmentStart,mid,segmentIndex*2+1,arr);\\n        Node rightChild = constructorUtil(mid+1,segmentEnd,segmentIndex*2+2,arr);\\n        return segmentArray[segmentIndex] = new Node(Math.max(leftChild.prefixSum,leftChild.totalSum+rightChild.prefixSum),\\n                Math.max(rightChild.suffixSum,rightChild.totalSum+ leftChild.suffixSum),\\n                leftChild.totalSum+ rightChild.totalSum,\\n                Math.max(leftChild.suffixSum+ rightChild.prefixSum,Math.max(leftChild.maximumSegmentSum,rightChild.maximumSegmentSum)));\\n    }\\n    private int getMid(int segmentStart, int segmentEnd){\\n        return (segmentStart+segmentEnd)>>1;\\n    }\\n    public Node updateQuery(int index, long newValue){\\n        return updateUtil(0,lengthOfArray-1,0,index,newValue);\\n    }\\n    private Node updateUtil(int segmentStart, int segmentEnd, int segmentIndex, int index, long newValue){\\n        if(index<segmentStart || index>segmentEnd) return segmentArray[segmentIndex];\\n        if(index==segmentStart && index==segmentEnd) {\\n            if(newValue>=0){\\n                return segmentArray[segmentIndex] = new Node(newValue,newValue,newValue,newValue);\\n            }\\n            return segmentArray[segmentIndex] = new Node(0,0,newValue,0);\\n        }\\n        int mid = getMid(segmentStart,segmentEnd);\\n        Node leftChild = updateUtil(segmentStart,mid,segmentIndex*2+1,index,newValue);\\n        Node rightChild = updateUtil(mid+1,segmentEnd,segmentIndex*2+2,index,newValue);\\n        return segmentArray[segmentIndex] = new Node(Math.max(leftChild.prefixSum,leftChild.totalSum+rightChild.prefixSum),\\n                Math.max(rightChild.suffixSum,rightChild.totalSum+ leftChild.suffixSum),\\n                leftChild.totalSum+ rightChild.totalSum,\\n                Math.max(leftChild.suffixSum+ rightChild.prefixSum,Math.max(leftChild.maximumSegmentSum,rightChild.maximumSegmentSum)));\\n    }\\n}\\nclass Node{\\n    long prefixSum;\\n    long suffixSum;\\n    long totalSum;\\n    long maximumSegmentSum;\\n\\n    public Node(long prefixSum, long suffixSum, long totalSum, long maximumSegmentSum) {\\n        this.prefixSum = prefixSum;\\n        this.suffixSum = suffixSum;\\n        this.totalSum = totalSum;\\n        this.maximumSegmentSum = maximumSegmentSum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        long[] arr = new long[nums.length];\\n        for(int i=0;i<nums.length;i++) arr[i] = (long)nums[i];\\n        MaximalSumSegmentTree maximalSumSegmentTree = new MaximalSumSegmentTree(arr);\\n        long[] answer = new long[nums.length];\\n        for(int i=0;i<nums.length;i++){\\n            long res = maximalSumSegmentTree.updateQuery(removeQueries[i],-1_000_000_000_000_00L).maximumSegmentSum;\\n            if(res>0) answer[i] = res;\\n        }\\n        return answer;\\n    }\\n}\\nclass MaximalSumSegmentTree{\\n    int lengthOfArray;\\n    Node[] segmentArray;\\n\\n    public MaximalSumSegmentTree(long[] arr){\\n        this.lengthOfArray = arr.length;\\n        int heightOfSegmentTree = (int)Math.ceil(Math.log(lengthOfArray)/Math.log(2));\\n        int sizeOfSegmentArray = 2*(1<<heightOfSegmentTree)-1;\\n        this.segmentArray = new Node[sizeOfSegmentArray];\\n        constructorUtil(0,lengthOfArray-1,0,arr);\\n    }\\n    public Node constructorUtil(int segmentStart, int segmentEnd, int segmentIndex, long[] arr){\\n        if(segmentEnd==segmentStart){\\n            if(arr[segmentStart]>=0){\\n                return segmentArray[segmentIndex] = new Node(arr[segmentStart],arr[segmentStart],arr[segmentStart],arr[segmentStart]);\\n            }\\n            return segmentArray[segmentIndex] = new Node(0,0,arr[segmentStart],0);\\n        }\\n        int mid = getMid(segmentStart,segmentEnd);\\n        Node leftChild = constructorUtil(segmentStart,mid,segmentIndex*2+1,arr);\\n        Node rightChild = constructorUtil(mid+1,segmentEnd,segmentIndex*2+2,arr);\\n        return segmentArray[segmentIndex] = new Node(Math.max(leftChild.prefixSum,leftChild.totalSum+rightChild.prefixSum),\\n                Math.max(rightChild.suffixSum,rightChild.totalSum+ leftChild.suffixSum),\\n                leftChild.totalSum+ rightChild.totalSum,\\n                Math.max(leftChild.suffixSum+ rightChild.prefixSum,Math.max(leftChild.maximumSegmentSum,rightChild.maximumSegmentSum)));\\n    }\\n    private int getMid(int segmentStart, int segmentEnd){\\n        return (segmentStart+segmentEnd)>>1;\\n    }\\n    public Node updateQuery(int index, long newValue){\\n        return updateUtil(0,lengthOfArray-1,0,index,newValue);\\n    }\\n    private Node updateUtil(int segmentStart, int segmentEnd, int segmentIndex, int index, long newValue){\\n        if(index<segmentStart || index>segmentEnd) return segmentArray[segmentIndex];\\n        if(index==segmentStart && index==segmentEnd) {\\n            if(newValue>=0){\\n                return segmentArray[segmentIndex] = new Node(newValue,newValue,newValue,newValue);\\n            }\\n            return segmentArray[segmentIndex] = new Node(0,0,newValue,0);\\n        }\\n        int mid = getMid(segmentStart,segmentEnd);\\n        Node leftChild = updateUtil(segmentStart,mid,segmentIndex*2+1,index,newValue);\\n        Node rightChild = updateUtil(mid+1,segmentEnd,segmentIndex*2+2,index,newValue);\\n        return segmentArray[segmentIndex] = new Node(Math.max(leftChild.prefixSum,leftChild.totalSum+rightChild.prefixSum),\\n                Math.max(rightChild.suffixSum,rightChild.totalSum+ leftChild.suffixSum),\\n                leftChild.totalSum+ rightChild.totalSum,\\n                Math.max(leftChild.suffixSum+ rightChild.prefixSum,Math.max(leftChild.maximumSegmentSum,rightChild.maximumSegmentSum)));\\n    }\\n}\\nclass Node{\\n    long prefixSum;\\n    long suffixSum;\\n    long totalSum;\\n    long maximumSegmentSum;\\n\\n    public Node(long prefixSum, long suffixSum, long totalSum, long maximumSegmentSum) {\\n        this.prefixSum = prefixSum;\\n        this.suffixSum = suffixSum;\\n        this.totalSum = totalSum;\\n        this.maximumSegmentSum = maximumSegmentSum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490353,
                "title": "java-javascript-c-solution",
                "content": "**Java**\\n```\\nimport java.util.stream.IntStream;\\n\\npublic class Solution {\\n\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n\\n        UnionFind unionFind = new UnionFind(nums.length);\\n        long[] maxSegmentSum = new long[nums.length];\\n        long currentMax = 0;\\n\\n        for (int i = nums.length - 1; i >= 0; --i) {\\n            int query = removeQueries[i];\\n            maxSegmentSum[i] = currentMax;\\n            unionFind.rank[query] = nums[query];\\n\\n            if (query - 1 >= 0 && unionFind.rank[query - 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query - 1), unionFind.findParent(query));\\n            }\\n            if (query + 1 < nums.length && unionFind.rank[query + 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query + 1), unionFind.findParent(query));\\n            }\\n            currentMax = Math.max(currentMax, unionFind.rank[unionFind.findParent(query)]);\\n        }\\n        return maxSegmentSum;\\n    }\\n}\\n\\nclass UnionFind {\\n\\n    int[] parent;\\n    long[] rank;\\n\\n    UnionFind(int sizeInput) {\\n        parent = IntStream.range(0, sizeInput).toArray();\\n        rank = new long[sizeInput];\\n    }\\n\\n    int findParent(int index) {\\n        if (parent[index] != index) {\\n            parent[index] = findParent(parent[index]);\\n        }\\n        return parent[index];\\n    }\\n\\n    void joinByRank(int indexOne, int indexTwo) {\\n        if (rank[indexOne] >= rank[indexTwo]) {\\n            rank[indexOne] += rank[indexTwo];\\n            parent[indexTwo] = indexOne;\\n        } else {\\n            rank[indexTwo] += rank[indexOne];\\n            parent[indexOne] = indexTwo;\\n        }\\n    }\\n}\\n```\\n**JavaScript**\\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} removeQueries\\n * @return {number[]}\\n */\\nvar maximumSegmentSum = function (nums, removeQueries) {\\n\\n    const unionFind = new UnionFind(nums.length);\\n    const maxSegmentSum = new Array(nums.length).fill(0);\\n    let currentMax = 0;\\n\\n    for (let i = nums.length - 1; i >= 0; --i) {\\n        let query = removeQueries[i];\\n        maxSegmentSum[i] = currentMax;\\n        unionFind.rank[query] = nums[query];\\n\\n        if (query - 1 >= 0 && unionFind.rank[query - 1] > 0) {\\n            unionFind.joinByRank(unionFind.findParent(query - 1), unionFind.findParent(query));\\n        }\\n        if (query + 1 < nums.length && unionFind.rank[query + 1] > 0) {\\n            unionFind.joinByRank(unionFind.findParent(query + 1), unionFind.findParent(query));\\n        }\\n        currentMax = Math.max(currentMax, unionFind.rank[unionFind.findParent(query)]);\\n    }\\n    return maxSegmentSum;\\n};\\n\\nclass UnionFind {\\n\\n    constructor(sizeInput) {\\n        this.parent = Array.from(new Array(sizeInput).keys());\\n        this.rank = new Array(sizeInput).fill(0);\\n    }\\n\\n    findParent(index) {\\n        if (this.parent[index] !== index) {\\n            this.parent[index] = this.findParent(this.parent[index]);\\n        }\\n        return this.parent[index];\\n    }\\n\\n    joinByRank(indexOne, indexTwo) {\\n        if (this.rank[indexOne] >= this.rank[indexTwo]) {\\n            this.rank[indexOne] += this.rank[indexTwo];\\n            this.parent[indexTwo] = indexOne;\\n        } else {\\n            this.rank[indexTwo] += this.rank[indexOne];\\n            this.parent[indexOne] = indexTwo;\\n        }\\n    }\\n}\\n```\\n**C++**\\n```\\n#include <vector>\\nusing namespace std;\\n\\nclass UnionFind {\\n    \\npublic:\\n    vector<int> parent;\\n    vector<long long> rank;\\n\\n    UnionFind(size_t sizeInput) {\\n        parent.resize(sizeInput);\\n        iota(parent.begin(), parent.end(), 0);\\n        rank.resize(sizeInput);\\n    }\\n\\n    int findParent(int index) {\\n        if (parent[index] != index) {\\n            parent[index] = findParent(parent[index]);\\n        }\\n        return parent[index];\\n    }\\n\\n    void joinByRank(int indexOne, int indexTwo) {\\n        if (rank[indexOne] >= rank[indexTwo]) {\\n            rank[indexOne] += rank[indexTwo];\\n            parent[indexTwo] = indexOne;\\n        } else {\\n            rank[indexTwo] += rank[indexOne];\\n            parent[indexOne] = indexTwo;\\n        }\\n    }\\n};\\n\\nclass Solution {\\n    \\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        UnionFind unionFind(nums.size());\\n        vector<long long> maxSegmentSum(nums.size());\\n        long currentMax = 0;\\n        \\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            int query = removeQueries[i];\\n            maxSegmentSum[i] = currentMax;\\n            unionFind.rank[query] = nums[query];\\n\\n            if (query - 1 >= 0 && unionFind.rank[query - 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query - 1), unionFind.findParent(query));\\n            }\\n            if (query + 1 < nums.size() && unionFind.rank[query + 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query + 1), unionFind.findParent(query));\\n            }\\n            currentMax = currentMax > unionFind.rank[unionFind.findParent(query)] ?\\n                         currentMax : unionFind.rank[unionFind.findParent(query)];\\n        }\\n        return maxSegmentSum;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "C",
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\nimport java.util.stream.IntStream;\\n\\npublic class Solution {\\n\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n\\n        UnionFind unionFind = new UnionFind(nums.length);\\n        long[] maxSegmentSum = new long[nums.length];\\n        long currentMax = 0;\\n\\n        for (int i = nums.length - 1; i >= 0; --i) {\\n            int query = removeQueries[i];\\n            maxSegmentSum[i] = currentMax;\\n            unionFind.rank[query] = nums[query];\\n\\n            if (query - 1 >= 0 && unionFind.rank[query - 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query - 1), unionFind.findParent(query));\\n            }\\n            if (query + 1 < nums.length && unionFind.rank[query + 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query + 1), unionFind.findParent(query));\\n            }\\n            currentMax = Math.max(currentMax, unionFind.rank[unionFind.findParent(query)]);\\n        }\\n        return maxSegmentSum;\\n    }\\n}\\n\\nclass UnionFind {\\n\\n    int[] parent;\\n    long[] rank;\\n\\n    UnionFind(int sizeInput) {\\n        parent = IntStream.range(0, sizeInput).toArray();\\n        rank = new long[sizeInput];\\n    }\\n\\n    int findParent(int index) {\\n        if (parent[index] != index) {\\n            parent[index] = findParent(parent[index]);\\n        }\\n        return parent[index];\\n    }\\n\\n    void joinByRank(int indexOne, int indexTwo) {\\n        if (rank[indexOne] >= rank[indexTwo]) {\\n            rank[indexOne] += rank[indexTwo];\\n            parent[indexTwo] = indexOne;\\n        } else {\\n            rank[indexTwo] += rank[indexOne];\\n            parent[indexOne] = indexTwo;\\n        }\\n    }\\n}\\n```\n```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} removeQueries\\n * @return {number[]}\\n */\\nvar maximumSegmentSum = function (nums, removeQueries) {\\n\\n    const unionFind = new UnionFind(nums.length);\\n    const maxSegmentSum = new Array(nums.length).fill(0);\\n    let currentMax = 0;\\n\\n    for (let i = nums.length - 1; i >= 0; --i) {\\n        let query = removeQueries[i];\\n        maxSegmentSum[i] = currentMax;\\n        unionFind.rank[query] = nums[query];\\n\\n        if (query - 1 >= 0 && unionFind.rank[query - 1] > 0) {\\n            unionFind.joinByRank(unionFind.findParent(query - 1), unionFind.findParent(query));\\n        }\\n        if (query + 1 < nums.length && unionFind.rank[query + 1] > 0) {\\n            unionFind.joinByRank(unionFind.findParent(query + 1), unionFind.findParent(query));\\n        }\\n        currentMax = Math.max(currentMax, unionFind.rank[unionFind.findParent(query)]);\\n    }\\n    return maxSegmentSum;\\n};\\n\\nclass UnionFind {\\n\\n    constructor(sizeInput) {\\n        this.parent = Array.from(new Array(sizeInput).keys());\\n        this.rank = new Array(sizeInput).fill(0);\\n    }\\n\\n    findParent(index) {\\n        if (this.parent[index] !== index) {\\n            this.parent[index] = this.findParent(this.parent[index]);\\n        }\\n        return this.parent[index];\\n    }\\n\\n    joinByRank(indexOne, indexTwo) {\\n        if (this.rank[indexOne] >= this.rank[indexTwo]) {\\n            this.rank[indexOne] += this.rank[indexTwo];\\n            this.parent[indexTwo] = indexOne;\\n        } else {\\n            this.rank[indexTwo] += this.rank[indexOne];\\n            this.parent[indexOne] = indexTwo;\\n        }\\n    }\\n}\\n```\n```\\n#include <vector>\\nusing namespace std;\\n\\nclass UnionFind {\\n    \\npublic:\\n    vector<int> parent;\\n    vector<long long> rank;\\n\\n    UnionFind(size_t sizeInput) {\\n        parent.resize(sizeInput);\\n        iota(parent.begin(), parent.end(), 0);\\n        rank.resize(sizeInput);\\n    }\\n\\n    int findParent(int index) {\\n        if (parent[index] != index) {\\n            parent[index] = findParent(parent[index]);\\n        }\\n        return parent[index];\\n    }\\n\\n    void joinByRank(int indexOne, int indexTwo) {\\n        if (rank[indexOne] >= rank[indexTwo]) {\\n            rank[indexOne] += rank[indexTwo];\\n            parent[indexTwo] = indexOne;\\n        } else {\\n            rank[indexTwo] += rank[indexOne];\\n            parent[indexOne] = indexTwo;\\n        }\\n    }\\n};\\n\\nclass Solution {\\n    \\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        UnionFind unionFind(nums.size());\\n        vector<long long> maxSegmentSum(nums.size());\\n        long currentMax = 0;\\n        \\n        for (int i = nums.size() - 1; i >= 0; --i) {\\n            int query = removeQueries[i];\\n            maxSegmentSum[i] = currentMax;\\n            unionFind.rank[query] = nums[query];\\n\\n            if (query - 1 >= 0 && unionFind.rank[query - 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query - 1), unionFind.findParent(query));\\n            }\\n            if (query + 1 < nums.size() && unionFind.rank[query + 1] > 0) {\\n                unionFind.joinByRank(unionFind.findParent(query + 1), unionFind.findParent(query));\\n            }\\n            currentMax = currentMax > unionFind.rank[unionFind.findParent(query)] ?\\n                         currentMax : unionFind.rank[unionFind.findParent(query)];\\n        }\\n        return maxSegmentSum;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2489258,
                "title": "c-recursive-solution-bruteforce",
                "content": "```\\nclass Solution {\\n      vector<long long> ans;\\n      int i=0;\\npublic:\\n    long long Sum(vector<int>& nums){\\n        vector<long long> vec;\\n        int flag=0;\\n        long long sum=0;\\n        for(auto x : nums){\\n            if(x==0){\\n                vec.push_back(sum);\\n                sum=0;\\n                flag=1;\\n            } \\n            else sum += x;\\n        }\\n        if(flag==1) vec.push_back(sum);\\n        return *max_element(vec.begin(),vec.end());\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n      \\n        //rec case\\n        if(i==nums.size()){\\n            return ans;\\n        }\\n        nums[removeQueries[i]] = 0;\\n        ans.push_back(Sum(nums));\\n        i++;\\n        return maximumSegmentSum(nums, removeQueries);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n      vector<long long> ans;\\n      int i=0;\\npublic:\\n    long long Sum(vector<int>& nums){\\n        vector<long long> vec;\\n        int flag=0;\\n        long long sum=0;\\n        for(auto x : nums){\\n            if(x==0){\\n                vec.push_back(sum);\\n                sum=0;\\n                flag=1;\\n            } \\n            else sum += x;\\n        }\\n        if(flag==1) vec.push_back(sum);\\n        return *max_element(vec.begin(),vec.end());\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n      \\n        //rec case\\n        if(i==nums.size()){\\n            return ans;\\n        }\\n        nums[removeQueries[i]] = 0;\\n        ans.push_back(Sum(nums));\\n        i++;\\n        return maximumSegmentSum(nums, removeQueries);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2484414,
                "title": "c-solution-using-sets-and-prefix-sum",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        int n=nums.size();  \\n        long long int pref[n+1];\\n        pref[0]=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            pref[i+1]=pref[i]+nums[i];\\n        }\\n        \\n        set<int>idx;\\n        multiset<long long int>s;\\n        s.insert(pref[n]);\\n        idx.insert(0);\\n        idx.insert(n+1);\\n        \\n        vector<long long>ans;\\n        \\n        for(auto it:removeQueries)\\n        {\\n            it++;\\n            auto itt=idx.upper_bound(it);\\n            int sec=*itt;\\n            itt--;\\n            int f=*itt;\\n            \\n            long long int val=pref[sec-1]-pref[f];\\n           \\n            auto xi=s.find(val);\\n            if(xi!=s.end())\\n            s.erase(xi);\\n            \\n            s.insert(pref[it-1]-pref[f]);\\n            s.insert(pref[sec-1]-pref[it]);\\n            idx.insert(it);\\n            \\n            ans.push_back(*s.rbegin());    \\n        }\\n        return ans;   \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        int n=nums.size();  \\n        long long int pref[n+1];\\n        pref[0]=0;\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n            pref[i+1]=pref[i]+nums[i];\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2483475,
                "title": "o-nlogn-priority-queue-map-prefixsum-cpp",
                "content": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    \\n    //initializing\\n    int n;\\n    vector<int>a;\\n    map<int,int>m;//indices of elements that have been removed!\\n    priority_queue<array<ll,3>>pq;//store sum as well as thier bounded range and sorting on the basis of maximum sum\\n    vector<ll>pre;//stores the prefix sum\\n    vector<ll>ans;\\n    \\n    //insertion into priority queue\\n    void insert(int l,int r){\\n        if(l<0||l>=n||r<0||r>=n||l>r)return;\\n        ll sum=pre[r+1]-pre[l];\\n        auto x={sum,(ll)l,(ll)r};\\n        pq.push({sum,l,r});\\n    }\\n\\n    //finding the highest segment sum\\n    ll fun(){\\n        if(pq.empty())return 0;\\n        auto x=pq.top();\\n        auto itr=m.lower_bound(x[1]);\\n        if(itr==m.end())\\n            return x[0];\\n        else{\\n            if(x[2]<itr->first)\\n                return x[0];\\n            else{\\n                pq.pop();\\n                return fun();\\n            }\\n        }\\n    }\\n    \\n    //main function\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        a=nums;\\n        n=a.size();\\n        \\n        //prefix sum\\n        pre.resize(n+1);\\n        pre[0]=0;\\n        for(int i=1;i<=n;i++){\\n            pre[i]=a[i-1]+pre[i-1];\\n        }\\n        \\n        //handling queries\\n        for(auto i:q){\\n            m[i]=1;\\n            \\n            //right segment\\n            auto r=m.upper_bound(i);\\n            if(r==m.end())insert(i+1,n-1);\\n            else insert(i+1,r->first-1);\\n            \\n            //left segment\\n            auto l=m.lower_bound(i);\\n            if(l==m.begin())insert(0,i-1);\\n            else insert(prev(l)->first+1,i-1);\\n\\n            //maximum among segments\\n            ans.push_back(fun());\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Heap (Priority Queue)",
                    "Prefix Sum"
                ],
                "code": "```\\n#define ll long long int\\nclass Solution {\\npublic:\\n    \\n    //initializing\\n    int n;\\n    vector<int>a;\\n    map<int,int>m;//indices of elements that have been removed!\\n    priority_queue<array<ll,3>>pq;//store sum as well as thier bounded range and sorting on the basis of maximum sum\\n    vector<ll>pre;//stores the prefix sum\\n    vector<ll>ans;\\n    \\n    //insertion into priority queue\\n    void insert(int l,int r){\\n        if(l<0||l>=n||r<0||r>=n||l>r)return;\\n        ll sum=pre[r+1]-pre[l];\\n        auto x={sum,(ll)l,(ll)r};\\n        pq.push({sum,l,r});\\n    }\\n\\n    //finding the highest segment sum\\n    ll fun(){\\n        if(pq.empty())return 0;\\n        auto x=pq.top();\\n        auto itr=m.lower_bound(x[1]);\\n        if(itr==m.end())\\n            return x[0];\\n        else{\\n            if(x[2]<itr->first)\\n                return x[0];\\n            else{\\n                pq.pop();\\n                return fun();\\n            }\\n        }\\n    }\\n    \\n    //main function\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        a=nums;\\n        n=a.size();\\n        \\n        //prefix sum\\n        pre.resize(n+1);\\n        pre[0]=0;\\n        for(int i=1;i<=n;i++){\\n            pre[i]=a[i-1]+pre[i-1];\\n        }\\n        \\n        //handling queries\\n        for(auto i:q){\\n            m[i]=1;\\n            \\n            //right segment\\n            auto r=m.upper_bound(i);\\n            if(r==m.end())insert(i+1,n-1);\\n            else insert(i+1,r->first-1);\\n            \\n            //left segment\\n            auto l=m.lower_bound(i);\\n            if(l==m.begin())insert(0,i-1);\\n            else insert(prev(l)->first+1,i-1);\\n\\n            //maximum among segments\\n            ans.push_back(fun());\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482936,
                "title": "simple-set-solution",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    #define pll pair<ll,ll>\\n    #define f first\\n    #define s second\\n    vector<ll>ps;\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<ll>v;\\n        ll ss=0;\\n        for(auto i:nums){v.push_back(i); ss+=i;}\\n        ll n=nums.size();\\n        ps=v;\\n        partial_sum(begin(v),end(v),begin(ps));\\n        map<ll,ll,greater<ll>>m;\\n        m[ss]++;\\n        m[0]++;\\n        vector<ll>ans; \\n        set<pll>s={{0,n-1}};\\n\\t   for(auto i:removeQueries){\\n\\t\\tauto ptr=s.upper_bound({i,INT_MAX});\\n\\tptr--;\\n\\tauto pp=*ptr;\\n\\ts.erase(pp);\\n\\tauto kk=ps[pp.s]-ps[pp.f]+v[pp.f];\\n\\tm[kk]--;\\n\\tif(m[kk]==0){m.erase(kk);}\\n\\tif(pp.f<i and i<pp.s){\\n\\t\\ts.insert({pp.f,i-1});\\n\\t\\ts.insert({i+1,pp.s});\\n\\t\\tss=ps[i-1]-ps[pp.f]+v[pp.f];\\n\\t\\tm[ss]++;\\n\\t\\tss=ps[pp.s]-ps[i];\\n\\t\\tm[ss]++;\\n\\t}\\n\\telse if(pp.f==i and pp.s==i){\\n\\n\\t}\\n\\telse if(pp.f==i){\\n\\t\\ts.insert({i+1,pp.s});\\n\\t\\tss=ps[pp.s]-ps[i];\\n\\t\\tm[ss]++;\\n\\t}\\n\\telse {\\n\\t\\ts.insert({pp.f,pp.s-1});\\n\\t\\tss=ps[pp.s-1]-ps[pp.f]+v[pp.f];\\n\\t\\tm[ss]++;\\n\\t}\\n\\n\\tans.push_back(begin(m)->first);\\n}\\nreturn ans;\\n}\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    typedef long long ll;\\n    #define pll pair<ll,ll>\\n    #define f first\\n    #define s second\\n    vector<ll>ps;\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<ll>v;\\n        ll ss=0;\\n        for(auto i:nums){v.push_back(i); ss+=i;}\\n        ll n=nums.size();\\n        ps=v;\\n        partial_sum(begin(v),end(v),begin(ps));\\n        map<ll,ll,greater<ll>>m;\\n        m[ss]++;\\n        m[0]++;\\n        vector<ll>ans; \\n        set<pll>s={{0,n-1}};\\n\\t   for(auto i:removeQueries){\\n\\t\\tauto ptr=s.upper_bound({i,INT_MAX});\\n\\tptr--;\\n\\tauto pp=*ptr;\\n\\ts.erase(pp);\\n\\tauto kk=ps[pp.s]-ps[pp.f]+v[pp.f];\\n\\tm[kk]--;\\n\\tif(m[kk]==0){m.erase(kk);}\\n\\tif(pp.f<i and i<pp.s){\\n\\t\\ts.insert({pp.f,i-1});\\n\\t\\ts.insert({i+1,pp.s});\\n\\t\\tss=ps[i-1]-ps[pp.f]+v[pp.f];\\n\\t\\tm[ss]++;\\n\\t\\tss=ps[pp.s]-ps[i];\\n\\t\\tm[ss]++;\\n\\t}\\n\\telse if(pp.f==i and pp.s==i){\\n\\n\\t}\\n\\telse if(pp.f==i){\\n\\t\\ts.insert({i+1,pp.s});\\n\\t\\tss=ps[pp.s]-ps[i];\\n\\t\\tm[ss]++;\\n\\t}\\n\\telse {\\n\\t\\ts.insert({pp.f,pp.s-1});\\n\\t\\tss=ps[pp.s-1]-ps[pp.f]+v[pp.f];\\n\\t\\tm[ss]++;\\n\\t}\\n\\n\\tans.push_back(begin(m)->first);\\n}\\nreturn ans;\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482723,
                "title": "c-python-dsu",
                "content": "TC : O(n)\\nSC: O(n)\\nPre-Requisites: Union-Find/DSU\\nImplement queries in reverse order and keep joining disjoint sets by checking with neighbouring indices and update size(sum of all nos in that set) in every union function call.\\n\\nC++ -> \\n\\n```\\nclass Solution {\\npublic:\\n    vector <long long> parent,size;\\n    pair<long long,long long> find(int x){\\n        if (parent[x]==x) return make_pair(parent[x],size[x]);\\n        auto res=find(parent[x]);\\n        return res;\\n    }\\n    \\n    void Union(int x,int y){\\n        auto r1=find(x);\\n        auto r2=find(y);\\n        if (r1.first!=r2.first){\\n            parent[r2.first]=r1.first;\\n            size[r1.first]+=size[r2.first];\\n        }\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& Q) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\\n        int n=nums.size();\\n        vector <long long> ans(n);\\n        vector <int> seen(n,0);\\n        vector <long long> Parent(n),Size(n);\\n        vector <pair<int,int>> queries;\\n        for (int i=0;i<n;i++){\\n            Parent[i]=i;\\n            Size[i]=nums[i];\\n            queries.push_back(make_pair(i,Q[i]));\\n        }\\n        parent=Parent;\\n        size=Size;\\n        reverse(queries.begin(),queries.end());\\n        long long mmax=0;\\n        for (int k=0;k<n;k++){\\n            int idx=queries[k].first,i=queries[k].second;\\n            ans[idx]=mmax;\\n            if (i-1>=0 && seen[i-1]){\\n                Union(i-1,i);\\n                auto res=find(i-1);\\n                mmax=max(mmax,res.second);\\n            }\\n            if (i+1<n && seen[i+1]){\\n                Union(i,i+1);\\n                auto res=find(i+1);\\n                mmax=max(mmax,res.second);\\n            }\\n            mmax=max(mmax,size[i]);\\n            seen[i]=1;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nPython ->\\n\\n```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], queries: List[int]) -> List[int]:\\n        n=len(nums)\\n        queries=[(i,val) for i,val in enumerate(queries)]\\n        queries=queries[::-1]\\n        ans=[-1]*n\\n        parent=[i for i in range(n)]\\n        size=[num for num in nums]\\n        def find(x):\\n            if parent[x]==x:\\n                return parent[x],size[x]\\n            parent[x],size[x]=find(parent[x])\\n            return parent[x],size[x]\\n        def union(x,y):\\n            r1,_=find(x)\\n            r2,_=find(y)\\n            if r1!=r2:\\n                parent[r2]=r1\\n                size[r1]+=size[r2]\\n        mmax=0\\n        seen=[0]*n\\n        for idx,i in queries:\\n            ans[idx]=mmax\\n            if i-1>=0 and seen[i-1]:\\n                union(i-1,i)\\n                _,res=find(i-1)\\n                mmax=max(mmax,res)\\n            if i+1<n and seen[i+1]:\\n                union(i,i+1)\\n                _,res=find(i+1)\\n                mmax=max(mmax,res)\\n            mmax=max(mmax,size[i])\\n            seen[i]=1\\n        return ans\\n        \\n```\\n\\nPlz Upvote!!!",
                "solutionTags": [
                    "Python",
                    "C",
                    "Union Find"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector <long long> parent,size;\\n    pair<long long,long long> find(int x){\\n        if (parent[x]==x) return make_pair(parent[x],size[x]);\\n        auto res=find(parent[x]);\\n        return res;\\n    }\\n    \\n    void Union(int x,int y){\\n        auto r1=find(x);\\n        auto r2=find(y);\\n        if (r1.first!=r2.first){\\n            parent[r2.first]=r1.first;\\n            size[r1.first]+=size[r2.first];\\n        }\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& Q) {\\n        ios_base::sync_with_stdio(false); cin.tie(NULL); cout.tie(NULL);\\n        int n=nums.size();\\n        vector <long long> ans(n);\\n        vector <int> seen(n,0);\\n        vector <long long> Parent(n),Size(n);\\n        vector <pair<int,int>> queries;\\n        for (int i=0;i<n;i++){\\n            Parent[i]=i;\\n            Size[i]=nums[i];\\n            queries.push_back(make_pair(i,Q[i]));\\n        }\\n        parent=Parent;\\n        size=Size;\\n        reverse(queries.begin(),queries.end());\\n        long long mmax=0;\\n        for (int k=0;k<n;k++){\\n            int idx=queries[k].first,i=queries[k].second;\\n            ans[idx]=mmax;\\n            if (i-1>=0 && seen[i-1]){\\n                Union(i-1,i);\\n                auto res=find(i-1);\\n                mmax=max(mmax,res.second);\\n            }\\n            if (i+1<n && seen[i+1]){\\n                Union(i,i+1);\\n                auto res=find(i+1);\\n                mmax=max(mmax,res.second);\\n            }\\n            mmax=max(mmax,size[i]);\\n            seen[i]=1;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], queries: List[int]) -> List[int]:\\n        n=len(nums)\\n        queries=[(i,val) for i,val in enumerate(queries)]\\n        queries=queries[::-1]\\n        ans=[-1]*n\\n        parent=[i for i in range(n)]\\n        size=[num for num in nums]\\n        def find(x):\\n            if parent[x]==x:\\n                return parent[x],size[x]\\n            parent[x],size[x]=find(parent[x])\\n            return parent[x],size[x]\\n        def union(x,y):\\n            r1,_=find(x)\\n            r2,_=find(y)\\n            if r1!=r2:\\n                parent[r2]=r1\\n                size[r1]+=size[r2]\\n        mmax=0\\n        seen=[0]*n\\n        for idx,i in queries:\\n            ans[idx]=mmax\\n            if i-1>=0 and seen[i-1]:\\n                union(i-1,i)\\n                _,res=find(i-1)\\n                mmax=max(mmax,res)\\n            if i+1<n and seen[i+1]:\\n                union(i,i+1)\\n                _,res=find(i+1)\\n                mmax=max(mmax,res)\\n            mmax=max(mmax,size[i])\\n            seen[i]=1\\n        return ans\\n        \\n```",
                "codeTag": "C++"
            },
            {
                "id": 2479603,
                "title": "python-solution-using-union-find",
                "content": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        def findParent(parent,val):\\n            if parent[val]==val:\\n                return val\\n            parent[val]=findParent(parent,parent[val])\\n            return parent[val]\\n        def union(a,b,rank,parent):\\n            parentA=findParent(parent,a)\\n            parentB=findParent(parent,b)\\n            if rank[parentA] > rank[parentB]:\\n                parent[parentB]=parentA\\n            elif rank[parentB] > rank[parentA]:\\n                parent[parentA]=parentB\\n            else:\\n                rank[parentA]+=1\\n                parent[parentB]=parentA\\n        res=[0]\\n        maxx=0\\n        rank={i:0 for i in range(-1,len(nums)+1)}\\n        parent={i:i for i in range(-1,len(nums)+1)}\\n        val=rank.copy()\\n        while removeQueries:\\n            i=removeQueries.pop()\\n            v=nums[i]\\n            val[i]=v\\n            if val[i-1]!=0:\\n                parentA=findParent(parent,i-1)\\n                parentB=findParent(parent,i)\\n                if rank[parentA] >= rank[parentB]:\\n                    val[parentA]+=val[parentB]\\n                else:\\n                    val[parentB]+=val[parentA]\\n                maxx=max(maxx,val[parentA],val[parentB])\\n                union(parentA,parentB,rank,parent)\\n            if val[i+1]!=0:\\n                parentA=findParent(parent,i+1)\\n                parentB=findParent(parent,i)\\n                if rank[parentA] >= rank[parentB]:\\n                    val[parentA]+=val[parentB]\\n                else:\\n                    val[parentB]+=val[parentA]\\n                maxx=max(maxx,val[parentA],val[parentB])\\n                union(parentA,parentB,rank,parent)\\n            maxx=max(maxx,v)\\n            res.append(maxx)\\n        res.pop()\\n        return res[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        def findParent(parent,val):\\n            if parent[val]==val:\\n                return val\\n            parent[val]=findParent(parent,parent[val])\\n            return parent[val]\\n        def union(a,b,rank,parent):\\n            parentA=findParent(parent,a)\\n            parentB=findParent(parent,b)\\n            if rank[parentA] > rank[parentB]:\\n                parent[parentB]=parentA\\n            elif rank[parentB] > rank[parentA]:\\n                parent[parentA]=parentB\\n            else:\\n                rank[parentA]+=1\\n                parent[parentB]=parentA\\n        res=[0]\\n        maxx=0\\n        rank={i:0 for i in range(-1,len(nums)+1)}\\n        parent={i:i for i in range(-1,len(nums)+1)}\\n        val=rank.copy()\\n        while removeQueries:\\n            i=removeQueries.pop()\\n            v=nums[i]\\n            val[i]=v\\n            if val[i-1]!=0:\\n                parentA=findParent(parent,i-1)\\n                parentB=findParent(parent,i)\\n                if rank[parentA] >= rank[parentB]:\\n                    val[parentA]+=val[parentB]\\n                else:\\n                    val[parentB]+=val[parentA]\\n                maxx=max(maxx,val[parentA],val[parentB])\\n                union(parentA,parentB,rank,parent)\\n            if val[i+1]!=0:\\n                parentA=findParent(parent,i+1)\\n                parentB=findParent(parent,i)\\n                if rank[parentA] >= rank[parentB]:\\n                    val[parentA]+=val[parentB]\\n                else:\\n                    val[parentB]+=val[parentA]\\n                maxx=max(maxx,val[parentA],val[parentB])\\n                union(parentA,parentB,rank,parent)\\n            maxx=max(maxx,v)\\n            res.append(maxx)\\n        res.pop()\\n        return res[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479330,
                "title": "intuition-of-prefix-sums-upper-bound-multisets-c-in-hindi",
                "content": "It was a great learning experience solving this challenge. Prefix sums, C++ Multiset, Upper Bound were the concepts used.\\nMy thought process from brute to optimal below :\\nIn case you prefer video solution, please refer :https://youtu.be/lZht4j2Ux-c\\n\\n\\nNaive solution: After every remove query, find the sum to remove and add new subset sums\\nby calculating it through iteration. O(N*N)\\n\\nOptimal: If we track subset sum in one set and subset ranges in another set then for\\nevery query we can find relevant subset by using binary search and update both\\nthe segments as well as the sum values.\\nex: nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]\\ncurrent_segments = {0, 4}\\nremove = 0 new_segments = {1, 4} sums = {14}\\nremove = 3 new_segments = {1, 2} {4, 4} sums = {7, 1}\\nremove = 2 new_segments = {1, 1} {4, 4} sums = {2 ,1}",
                "solutionTags": [],
                "code": "It was a great learning experience solving this challenge. Prefix sums, C++ Multiset, Upper Bound were the concepts used.\\nMy thought process from brute to optimal below :\\nIn case you prefer video solution, please refer :https://youtu.be/lZht4j2Ux-c\\n\\n\\nNaive solution: After every remove query, find the sum to remove and add new subset sums\\nby calculating it through iteration. O(N*N)\\n\\nOptimal: If we track subset sum in one set and subset ranges in another set then for\\nevery query we can find relevant subset by using binary search and update both\\nthe segments as well as the sum values.\\nex: nums = [1,2,5,6,1], removeQueries = [0,3,2,4,1]\\ncurrent_segments = {0, 4}\\nremove = 0 new_segments = {1, 4} sums = {14}\\nremove = 3 new_segments = {1, 2} {4, 4} sums = {7, 1}\\nremove = 2 new_segments = {1, 1} {4, 4} sums = {2 ,1}",
                "codeTag": "Unknown"
            },
            {
                "id": 2478641,
                "title": "set-of-pairs",
                "content": "#include<bits/stdc++.h>\\nusing namespace std;\\n\\n//leetcode link : https://leetcode.com/problems/maximum-segment-sum-after-removals/\\n//approach=> is that first we find that interval in which the index lying => after that we divide that interval\\n//and this should be done in efficient time complexity that\\'s why i have used set of pairs and mulst to store sums of intervals that are present in the set\\n//time complexity = >O(nlogn)\\n//space complexity = O(n)\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n  = nums.size();\\n        //set to store intervals\\n        set<pair<int,int>>st;\\n        //multiset to store sums\\n        multiset<long long>mulst;\\n\\n        //prefix sum array\\n        vector<long long>prefix_sum(n,nums[0]);\\n        for(int i = 1;i<n;i++)\\n        prefix_sum[i] = prefix_sum[i-1]+nums[i];\\n\\n        st.insert({0,n-1});\\n        mulst.insert(prefix_sum[n-1]);\\n        //if no element left then sum is zero\\n        mulst.insert(0);\\n         vector<long long>res;\\n        for(int i = 0;i<n;i++)\\n        {\\n             auto it = st.upper_bound({removeQueries[i],INT_MAX});\\n             it--;\\n             long long left_sum = (removeQueries[i]>0 ? prefix_sum[removeQueries[i]-1]:0)-(it->first>0?prefix_sum[it->first -1]:0);\\n             long long right_sum = prefix_sum[it->second]-prefix_sum[removeQueries[i]];\\n\\n             //push left interval\\n             if(it->first<removeQueries[i])\\n             {\\n                 st.insert({it->first,removeQueries[i]-1});\\n                 //insert left interval sum also\\n                 mulst.insert(left_sum);\\n             }\\n             //push right interval\\n             if(it->second>removeQueries[i])\\n             {\\n                 st.insert({removeQueries[i]+1,it->second});\\n                 //insert right interval sum also\\n                 mulst.insert(right_sum);\\n             }\\n             //erase the sum of the interval that we have divided\\n             long long sum = prefix_sum[it->second]-(it->first>0?prefix_sum[it->first -1]:0);\\n             mulst.erase(mulst.find(sum));\\n             //also erase the interval aslo\\n             st.erase(it);\\n             res.push_back(*mulst.rbegin());\\n        }\\n        return res;\\n\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n  = nums.size();\\n        //set to store intervals\\n        set<pair<int,int>>st;\\n        //multiset to store sums\\n        multiset<long long>mulst;\\n\\n        //prefix sum array\\n        vector<long long>prefix_sum(n,nums[0]);\\n        for(int i = 1;i<n;i++)\\n        prefix_sum[i] = prefix_sum[i-1]+nums[i];\\n\\n        st.insert({0,n-1}",
                "codeTag": "Java"
            },
            {
                "id": 2477482,
                "title": "python3-o-n-solution",
                "content": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        #### reverse adding\\n        # N[i] = [s, e, sum]\\n        # where s is the start index of the segment that contains nums[i], e is the end index, and sum is the summation of segment\\n        N = defaultdict(list)\\n        ret = [0]       # result after all elements are removed\\n        max_seg = 0\\n        \\n        removeQueries.reverse()\\n        # Taking example 1 as instance: removeQueries = [1,4,2,3,0]\\n        # before iterations: [0 0 0 0 0] ==> max = 0\\n        # after iteration 0: [0 2 0 0 0] ==> max = max(0, 2) = 2                                    : sum_seg(2) = 2\\n        # after iteration 1: [0 2 0 0 1] ==> max = max(2, 1) = 2                                    : sum_seg(1) = 1\\n        # after iteration 2: [0 2 5 0 1] ==> max = max(2, sum_seg(2)+5) = 7                         : sum_seg(2,5) = 7\\n        # after iteration 3: [0 2 5 6 1] ==> max = max(7, sum_seg(2,5) + 6 + sum_seg(1)) = 14       : sum_seg(2,5,6,1) = 14\\n        # after iteration 4: [1 2 5 6 1] ==> max = max(14, 1 + sum_seg(2,5,6,1)) = 15               : sum_all = 15\\n        \\n        for i in removeQueries:\\n            # segment that only contains nums[i]\\n            cur = nums[i]\\n            N[i] = [i, i, cur]\\n            \\n            # concatenate segment(nums[i]) with its nearby segments if exist\\n            if N[i-1] != []:\\n                cur += N[i-1][2]\\n                s = N[i-1][0]\\n                e = N[i][1]\\n                # update segment\\n                N[s] = [s, e, cur]\\n                N[e] = [s, e, cur]\\n            \\n            if N[i+1] != []:\\n                cur += N[i+1][2]\\n                s = N[i][0]\\n                e = N[i+1][1]\\n                N[s] = [s, e, cur]\\n                N[e] = [s, e, cur]\\n                \\n            max_seg = max(max_seg, cur)\\n            ret.append(max_seg)\\n         \\n        ret.reverse()\\n        ret = ret[1:]\\n        return ret\\n                \\n```",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        #### reverse adding\\n        # N[i] = [s, e, sum]\\n        # where s is the start index of the segment that contains nums[i], e is the end index, and sum is the summation of segment\\n        N = defaultdict(list)\\n        ret = [0]       # result after all elements are removed\\n        max_seg = 0\\n        \\n        removeQueries.reverse()\\n        # Taking example 1 as instance: removeQueries = [1,4,2,3,0]\\n        # before iterations: [0 0 0 0 0] ==> max = 0\\n        # after iteration 0: [0 2 0 0 0] ==> max = max(0, 2) = 2                                    : sum_seg(2) = 2\\n        # after iteration 1: [0 2 0 0 1] ==> max = max(2, 1) = 2                                    : sum_seg(1) = 1\\n        # after iteration 2: [0 2 5 0 1] ==> max = max(2, sum_seg(2)+5) = 7                         : sum_seg(2,5) = 7\\n        # after iteration 3: [0 2 5 6 1] ==> max = max(7, sum_seg(2,5) + 6 + sum_seg(1)) = 14       : sum_seg(2,5,6,1) = 14\\n        # after iteration 4: [1 2 5 6 1] ==> max = max(14, 1 + sum_seg(2,5,6,1)) = 15               : sum_all = 15\\n        \\n        for i in removeQueries:\\n            # segment that only contains nums[i]\\n            cur = nums[i]\\n            N[i] = [i, i, cur]\\n            \\n            # concatenate segment(nums[i]) with its nearby segments if exist\\n            if N[i-1] != []:\\n                cur += N[i-1][2]\\n                s = N[i-1][0]\\n                e = N[i][1]\\n                # update segment\\n                N[s] = [s, e, cur]\\n                N[e] = [s, e, cur]\\n            \\n            if N[i+1] != []:\\n                cur += N[i+1][2]\\n                s = N[i][0]\\n                e = N[i+1][1]\\n                N[s] = [s, e, cur]\\n                N[e] = [s, e, cur]\\n                \\n            max_seg = max(max_seg, cur)\\n            ret.append(max_seg)\\n         \\n        ret.reverse()\\n        ret = ret[1:]\\n        return ret\\n                \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475496,
                "title": "c-working-backwards-well-commented-priority-queue-2d-array",
                "content": "Here is the idea of my solution:\\n->Work backwards and treat the removeQueries like an \\'add\\' queries\\n->Initialize priority queue with 0 as the sum and length as the priority to represent the final max segment of any testcase\\n->Use a 2d array to store the segment sum, left index, and right index of the segment as each row of the array\\n->Check for adjacent non-zero sums to see if the current index being added needs to merge with a segment\\n->Find left and rightmost segment indexes and add sums to then update both left and right indexes of the sum with current info\\n->Keep track of the largest segment so only the past largest segment and the current one being calculated matter\\n->Add largest segment to priority queue using the current index to represent priority\\n->Dequeue all elements of priority queue into array and return\\n\\n```\\npublic class Solution {\\n    public long[] MaximumSegmentSum(int[] nums, int[] removeQueries) {\\n        // each index will store the sum, left index, and right index of given segment\\n        long[,] sumStore = new long[nums.Length, 3]; \\n        // will store highest segment sum for current query\\n        PriorityQueue<long, int> maxSum = new();\\n        // last query will always be zero\\n        // assign priority as nums length and decrement for each query because dequeue returns low to high prio\\n        maxSum.Enqueue(0L, nums.Length); \\n        long sum; \\n        long pastSum = 0; // stores past highest segment sum\\n        long lI, rI; // left index and right index for given segment\\n        for(int i = removeQueries.Length-1; i > 0; i--){ //stop at index 1 because we dont care what the first removed element is\\n            sum = nums[removeQueries[i]]; // get value at index to be \\'added\\'\\n            lI = removeQueries[i]; // before checking for adjacent segments assume this is a one element segment \\n            rI = removeQueries[i];\\n            if(removeQueries[i] > 0 && sumStore[removeQueries[i]-1, 0] != 0){ // if left adjacent segment add its sum and update left most index\\n                sum += sumStore[removeQueries[i]-1, 0];\\n                lI = sumStore[removeQueries[i]-1, 1];\\n            }\\n            if(removeQueries[i] < nums.Length-1 && sumStore[removeQueries[i]+1, 0] != 0){ // same deal but check for right segment\\n                sum += sumStore[removeQueries[i]+1, 0];\\n                rI = sumStore[removeQueries[i]+1, 2];\\n            }\\n            // update current segment with sum and index values\\n            sumStore[removeQueries[i], 0] = sum;\\n            sumStore[removeQueries[i], 1] = lI;\\n            sumStore[removeQueries[i], 2] = rI;\\n            // update leftmost and rightmost index of segment with new segment info\\n            if(lI != removeQueries[i]){\\n                sumStore[lI, 0] = sum;\\n                sumStore[lI, 1] = lI;\\n                sumStore[lI, 2] = rI;\\n            }\\n            if(rI != removeQueries[i]){\\n                sumStore[rI, 0] = sum;\\n                sumStore[rI, 1] = lI;\\n                sumStore[rI, 2] = rI;\\n            }\\n            if(sum > pastSum){ // keeps track of second largest segment in case the once currently being checked is smaller\\n                pastSum = sum;\\n                maxSum.Enqueue(sum, i);\\n            }else{\\n                 maxSum.Enqueue(pastSum, i);\\n             }\\n        }\\n        long[] sol = new long[nums.Length]; // to be returned\\n        for(int j = 0; j < nums.Length; j++){ // fill return array with max segments from priority queue\\n            sol[j] = maxSum.Dequeue();\\n        }\\n        return sol;\\n    }\\n}\\n```\\n\\nIf you have any optimization tips or other data structures I could have used please leave a comment! \\nI am always trying to learn and improve my programming skills. Hope this could help someone.\\n",
                "solutionTags": [
                    "C#",
                    "Array",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    public long[] MaximumSegmentSum(int[] nums, int[] removeQueries) {\\n        // each index will store the sum, left index, and right index of given segment\\n        long[,] sumStore = new long[nums.Length, 3]; \\n        // will store highest segment sum for current query\\n        PriorityQueue<long, int> maxSum = new();\\n        // last query will always be zero\\n        // assign priority as nums length and decrement for each query because dequeue returns low to high prio\\n        maxSum.Enqueue(0L, nums.Length); \\n        long sum; \\n        long pastSum = 0; // stores past highest segment sum\\n        long lI, rI; // left index and right index for given segment\\n        for(int i = removeQueries.Length-1; i > 0; i--){ //stop at index 1 because we dont care what the first removed element is\\n            sum = nums[removeQueries[i]]; // get value at index to be \\'added\\'\\n            lI = removeQueries[i]; // before checking for adjacent segments assume this is a one element segment \\n            rI = removeQueries[i];\\n            if(removeQueries[i] > 0 && sumStore[removeQueries[i]-1, 0] != 0){ // if left adjacent segment add its sum and update left most index\\n                sum += sumStore[removeQueries[i]-1, 0];\\n                lI = sumStore[removeQueries[i]-1, 1];\\n            }\\n            if(removeQueries[i] < nums.Length-1 && sumStore[removeQueries[i]+1, 0] != 0){ // same deal but check for right segment\\n                sum += sumStore[removeQueries[i]+1, 0];\\n                rI = sumStore[removeQueries[i]+1, 2];\\n            }\\n            // update current segment with sum and index values\\n            sumStore[removeQueries[i], 0] = sum;\\n            sumStore[removeQueries[i], 1] = lI;\\n            sumStore[removeQueries[i], 2] = rI;\\n            // update leftmost and rightmost index of segment with new segment info\\n            if(lI != removeQueries[i]){\\n                sumStore[lI, 0] = sum;\\n                sumStore[lI, 1] = lI;\\n                sumStore[lI, 2] = rI;\\n            }\\n            if(rI != removeQueries[i]){\\n                sumStore[rI, 0] = sum;\\n                sumStore[rI, 1] = lI;\\n                sumStore[rI, 2] = rI;\\n            }\\n            if(sum > pastSum){ // keeps track of second largest segment in case the once currently being checked is smaller\\n                pastSum = sum;\\n                maxSum.Enqueue(sum, i);\\n            }else{\\n                 maxSum.Enqueue(pastSum, i);\\n             }\\n        }\\n        long[] sol = new long[nums.Length]; // to be returned\\n        for(int j = 0; j < nums.Length; j++){ // fill return array with max segments from priority queue\\n            sol[j] = maxSum.Dequeue();\\n        }\\n        return sol;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2475243,
                "title": "java-hashmap-simple-solution",
                "content": "```\\npublic long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        int dp[] = new int[n];\\n        int parent[] = new int[n];\\n        Arrays.fill(parent,-1);\\n        long ans[] = new long[n];\\n        long max = 0;\\n        Map<Integer,Long> map = new HashMap();\\n        for(int i=n-1;i>0;i--){\\n            int r = removeQueries[i];\\n            dp[r] = 1;\\n            long temp = nums[r];\\n            if(r+1 <n && dp[r+1]==1){\\n                \\n                int index = parent[r+1];\\n                int val=r+1;\\n                if(index==-1) parent[r+1]=r; \\n                while(index!=-1){\\n                    val = parent[index];\\n                    if(val==-1){\\n                        val = index;\\n                         parent[val] = r;\\n                        break;\\n                    }\\n                    \\n                    index=val;\\n                \\n                }\\n                \\n                temp = temp + map.getOrDefault(val,(long)0);\\n            }\\n            if(r-1>=0 && dp[r-1]==1){\\n                int index = parent[r-1];\\n                int val=r-1;\\n                if(index==-1) parent[r-1]=r; \\n                while(index!=-1){\\n                    val = parent[index];\\n                    if(val==-1){\\n                        val = index;\\n                        parent[val] = r;\\n                        break;\\n                    }\\n                    \\n                    index=val;\\n                 \\n                }\\n                \\n                temp = temp + map.getOrDefault(val,(long)0);\\n            }\\n            map.put(r,temp);\\n            max = Math.max(max,temp);\\n            ans[i-1] = max;\\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```\\npublic long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = nums.length;\\n        int dp[] = new int[n];\\n        int parent[] = new int[n];\\n        Arrays.fill(parent,-1);\\n        long ans[] = new long[n];\\n        long max = 0;\\n        Map<Integer,Long> map = new HashMap();\\n        for(int i=n-1;i>0;i--){\\n            int r = removeQueries[i];\\n            dp[r] = 1;\\n            long temp = nums[r];\\n            if(r+1 <n && dp[r+1]==1){\\n                \\n                int index = parent[r+1];\\n                int val=r+1;\\n                if(index==-1) parent[r+1]=r; \\n                while(index!=-1){\\n                    val = parent[index];\\n                    if(val==-1){\\n                        val = index;\\n                         parent[val] = r;\\n                        break;\\n                    }\\n                    \\n                    index=val;\\n                \\n                }\\n                \\n                temp = temp + map.getOrDefault(val,(long)0);\\n            }\\n            if(r-1>=0 && dp[r-1]==1){\\n                int index = parent[r-1];\\n                int val=r-1;\\n                if(index==-1) parent[r-1]=r; \\n                while(index!=-1){\\n                    val = parent[index];\\n                    if(val==-1){\\n                        val = index;\\n                        parent[val] = r;\\n                        break;\\n                    }\\n                    \\n                    index=val;\\n                 \\n                }\\n                \\n                temp = temp + map.getOrDefault(val,(long)0);\\n            }\\n            map.put(r,temp);\\n            max = Math.max(max,temp);\\n            ans[i-1] = max;\\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2473731,
                "title": "c-map-set-prefix-sum",
                "content": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) \\n    {\\n        int n=nums.size();\\n        vector<ll>prefix(n,0);\\n        prefix[0]=nums[0];\\n        for(int i=1;i<n;i++)prefix[i]=prefix[i-1]+nums[i];\\n        multiset<ll>Set;\\n        map<int,int>Map;\\n        Set.insert(prefix[n-1]),Map[0]=n-1;\\n        vector<ll>res;\\n        for(auto &x:removeQueries)\\n        {\\n            auto it=Map.lower_bound(x);\\n            int l=0,r=0;\\n            if(it==Map.end())\\n            {\\n                auto cur=*Map.rbegin();\\n                l=cur.first,r=cur.second;\\n            }else\\n            {\\n                if(it->first>x)it--;\\n                l=it->first;\\n                r=it->second;\\n            }\\n            ll tot=prefix[r]-(l-1>=0 ? prefix[l-1] : 0);\\n            Set.erase(Set.find(tot));\\n            Map.erase(l);\\n            if((r-l)!=0)\\n            {\\n                if(l==x)Set.insert(prefix[r]-prefix[l]),Map[l+1]=r;\\n                else if(r==x)Set.insert(prefix[r-1]-(l-1>=0 ? prefix[l-1] : 0)),Map[l]=r-1;\\n                else\\n                {\\n                    Set.insert(prefix[x-1]-(l-1>=0 ? prefix[l-1] : 0)),Map[l]=x-1;\\n                    Set.insert(prefix[r]-prefix[x]),Map[x+1]=r;\\n                }\\n            }\\n            if(Set.size()>0)res.push_back(*Set.rbegin());\\n            else res.push_back(0);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\ntypedef long long ll;\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) \\n    {\\n        int n=nums.size();\\n        vector<ll>prefix(n,0);\\n        prefix[0]=nums[0];\\n        for(int i=1;i<n;i++)prefix[i]=prefix[i-1]+nums[i];\\n        multiset<ll>Set;\\n        map<int,int>Map;\\n        Set.insert(prefix[n-1]),Map[0]=n-1;\\n        vector<ll>res;\\n        for(auto &x:removeQueries)\\n        {\\n            auto it=Map.lower_bound(x);\\n            int l=0,r=0;\\n            if(it==Map.end())\\n            {\\n                auto cur=*Map.rbegin();\\n                l=cur.first,r=cur.second;\\n            }else\\n            {\\n                if(it->first>x)it--;\\n                l=it->first;\\n                r=it->second;\\n            }\\n            ll tot=prefix[r]-(l-1>=0 ? prefix[l-1] : 0);\\n            Set.erase(Set.find(tot));\\n            Map.erase(l);\\n            if((r-l)!=0)\\n            {\\n                if(l==x)Set.insert(prefix[r]-prefix[l]),Map[l+1]=r;\\n                else if(r==x)Set.insert(prefix[r-1]-(l-1>=0 ? prefix[l-1] : 0)),Map[l]=r-1;\\n                else\\n                {\\n                    Set.insert(prefix[x-1]-(l-1>=0 ? prefix[l-1] : 0)),Map[l]=x-1;\\n                    Set.insert(prefix[r]-prefix[x]),Map[x+1]=r;\\n                }\\n            }\\n            if(Set.size()>0)res.push_back(*Set.rbegin());\\n            else res.push_back(0);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472697,
                "title": "c-prefix-sum-map-priority-queue",
                "content": "**Intuition:**\\n\\nFirstly, Create a vector dp contains `dp[i] = nums[0] + ... + nums[i-1]`, so we can use `dp[j+1] - dp[i]` to find range sum in constant time.\\n\\nWe use map to mark every range that haven\\'t been removed for every element, and update it in every `removeQueries`.\\n\\nHence, we use `priority_queue` to find the maximum, since we have already updated range in `map`, if we encounters those with different range with current range, discard that.\\n\\n**Code**\\n```\\n#define ll long long\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rmQueries) {\\n\\tint n = nums.size();\\n\\tvector<ll> dp(n+1);\\n\\tll acc = 0;\\n\\tfor(int i = 0; i < n; i++) \\n\\t\\tdp[i+1] = acc += nums[i];\\n\\n\\tvector<ll> res;\\n\\tmap<int,int> ran;\\n\\tpriority_queue<array<ll,3>> pq;\\n\\tpq.push({dp.back(), 0, n-1});\\n\\tran[0] = n-1;\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tauto it = --ran.upper_bound(rmQueries[i]);\\n\\n\\t\\tif(rmQueries[i]+1 < n && ran.find(rmQueries[i]+1) == ran.end()) {\\n\\t\\t\\tran[rmQueries[i]+1] = it->second;\\n\\t\\t\\tpq.push({dp[it->second+1] - dp[rmQueries[i]+1], rmQueries[i]+1, it->second});                \\n\\t\\t}\\n\\n\\t\\tif(rmQueries[i] == it->first)\\n\\t\\t\\tran.erase(rmQueries[i]);\\n\\t\\telse {\\n\\t\\t\\tit->second = rmQueries[i]-1;\\n\\t\\t\\tpq.push({dp[it->second+1] - dp[it->first], it->first, it->second});             \\n\\t\\t}\\n\\n\\t\\twhile(!pq.empty() && (ran.find(pq.top()[1]) == ran.end() || pq.top()[2] != ran[pq.top()[1]]))\\n\\t\\t\\tpq.pop();\\n\\n\\t\\tif(pq.empty())\\n\\t\\t\\tres.push_back(0);\\n\\t\\telse\\n\\t\\t\\tres.push_back(pq.top()[0]);\\n\\n\\t}\\n\\n\\treturn res;\\n}\\n```\\n\\n**Complexity Analysis**\\n\\n**Time:** `O(n*log(n))`\\n**Space:** `O(n)`\\n\\n**If you consider this helpful, please consider upvote. It meant a lot.**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define ll long long\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rmQueries) {\\n\\tint n = nums.size();\\n\\tvector<ll> dp(n+1);\\n\\tll acc = 0;\\n\\tfor(int i = 0; i < n; i++) \\n\\t\\tdp[i+1] = acc += nums[i];\\n\\n\\tvector<ll> res;\\n\\tmap<int,int> ran;\\n\\tpriority_queue<array<ll,3>> pq;\\n\\tpq.push({dp.back(), 0, n-1});\\n\\tran[0] = n-1;\\n\\tfor(int i = 0; i < n; i++) {\\n\\t\\tauto it = --ran.upper_bound(rmQueries[i]);\\n\\n\\t\\tif(rmQueries[i]+1 < n && ran.find(rmQueries[i]+1) == ran.end()) {\\n\\t\\t\\tran[rmQueries[i]+1] = it->second;\\n\\t\\t\\tpq.push({dp[it->second+1] - dp[rmQueries[i]+1], rmQueries[i]+1, it->second});                \\n\\t\\t}\\n\\n\\t\\tif(rmQueries[i] == it->first)\\n\\t\\t\\tran.erase(rmQueries[i]);\\n\\t\\telse {\\n\\t\\t\\tit->second = rmQueries[i]-1;\\n\\t\\t\\tpq.push({dp[it->second+1] - dp[it->first], it->first, it->second});             \\n\\t\\t}\\n\\n\\t\\twhile(!pq.empty() && (ran.find(pq.top()[1]) == ran.end() || pq.top()[2] != ran[pq.top()[1]]))\\n\\t\\t\\tpq.pop();\\n\\n\\t\\tif(pq.empty())\\n\\t\\t\\tres.push_back(0);\\n\\t\\telse\\n\\t\\t\\tres.push_back(pq.top()[0]);\\n\\n\\t}\\n\\n\\treturn res;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2471593,
                "title": "simple-solution-using-dsu-and-multiset-keep-on-merging-the-adjacent-segments",
                "content": "```\\nclass Solution {\\npublic:\\n\\n    vector<long long> parent, sum;\\n    multiset<long long> mst;\\n    \\n    void make(int v){\\n        parent[v] = v;\\n        sum[v] = 0;\\n        mst.insert(0);\\n    }\\n    \\n    int find(int v){\\n        if(parent[v] == v){\\n            return v;\\n        }\\n        return find(parent[v]);\\n    }\\n    \\n    void Union(int a, int b){\\n        a = find(a); b = find(b);\\n        if(a != b){\\n            parent[b] = a;\\n            \\n            auto it = mst.find(sum[b]);\\n            mst.erase(it);\\n            it = mst.find(sum[a]);\\n            mst.erase(it);\\n            sum[a] += sum[b];\\n            mst.insert(sum[a]);\\n        }\\n    }\\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        parent.resize(n+1);\\n        sum.resize(n+1);\\n        mst.clear();\\n        \\n        for(int i=1; i<=n; i++){\\n            make(i);\\n        }\\n        vector<long long> ans;\\n        \\n        for(int i=n-1; i>=0; i--){\\n            int rm = removeQueries[i]+1;\\n            ans.push_back(*(--mst.end()));\\n            \\n            auto it = mst.find(sum[rm]);\\n            mst.erase(it);\\n            sum[rm] = nums[rm-1];\\n            mst.insert(sum[rm]);\\n            \\n            if(rm > 1 and sum[rm-1] != 0){\\n                Union(rm , rm-1);\\n            }\\n            if(rm < n and sum[rm+1] != 0){\\n                Union(rm, rm+1);\\n            }\\n        }\\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    vector<long long> parent, sum;\\n    multiset<long long> mst;\\n    \\n    void make(int v){\\n        parent[v] = v;\\n        sum[v] = 0;\\n        mst.insert(0);\\n    }\\n    \\n    int find(int v){\\n        if(parent[v] == v){\\n            return v;\\n        }\\n        return find(parent[v]);\\n    }\\n    \\n    void Union(int a, int b){\\n        a = find(a); b = find(b);\\n        if(a != b){\\n            parent[b] = a;\\n            \\n            auto it = mst.find(sum[b]);\\n            mst.erase(it);\\n            it = mst.find(sum[a]);\\n            mst.erase(it);\\n            sum[a] += sum[b];\\n            mst.insert(sum[a]);\\n        }\\n    }\\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        parent.resize(n+1);\\n        sum.resize(n+1);\\n        mst.clear();\\n        \\n        for(int i=1; i<=n; i++){\\n            make(i);\\n        }\\n        vector<long long> ans;\\n        \\n        for(int i=n-1; i>=0; i--){\\n            int rm = removeQueries[i]+1;\\n            ans.push_back(*(--mst.end()));\\n            \\n            auto it = mst.find(sum[rm]);\\n            mst.erase(it);\\n            sum[rm] = nums[rm-1];\\n            mst.insert(sum[rm]);\\n            \\n            if(rm > 1 and sum[rm-1] != 0){\\n                Union(rm , rm-1);\\n            }\\n            if(rm < n and sum[rm+1] != 0){\\n                Union(rm, rm+1);\\n            }\\n        }\\n        reverse(ans.begin(), ans.end());\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2471155,
                "title": "c-bit-approach-difference-array",
                "content": "Algorithm: \\nAfter each operation we divide the current range to two halves left and right.\\nWe remove the range curr elements belongs to and add 2 new ranges i.e left and right\\nBut the problem is we need to know the range for each element after new updation i.e we need to do range updation\\n\\nFor range updation we can use BIT + difference array \\n\\nDS used:\\nmultisets: for maximum sum\\nmap: for information about each range i.e lowerbound upperbound and sum\\nBIT: update the new range\\n\\n\\n````\\nclass BIT {\\n    int n;\\n    vector<long long>  v;\\npublic:\\n\\n    BIT(int sz) {\\n        n = sz;\\n        v.resize(n + 1);\\n    }\\n\\n    long long sum(int k) {\\n        long long sum = 0;\\n        while (k > 0) {\\n            sum += v[k];\\n            k -= k & -k;\\n        }\\n        return sum;\\n    }\\n\\n    void add(int k , int x) {\\n        while (k <= n) {\\n            v[k] += x;\\n            k += k & -k;\\n        }\\n    }\\n\\n};\\n\\n\\nclass Solution {\\npublic:\\nint cnt = 0;\\nmap < int, vector<long long> > range;\\nmultiset<long long> s;\\n\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n\\n    int n = nums.size();\\n    vector<long long> diff(n + 1, 0), prefix(n + 1, 0),ans; //difference array\\n    for (int i = 0; i < n; i++) {\\n        prefix[i + 1] = prefix[i] + nums[i];\\n    }\\n\\n    BIT T(diff.size());\\n    s.insert(-prefix[n]);   //insert negative for maximum\\n    range[0] = {1, n, prefix[n]};     //now follow one based indexing\\n\\n\\n    for (int index : removeQueries) {\\n        index++;\\n        int currRange = T.sum(index);   //curr range of element\\n\\n        //dimensions of range\\n        int start = range[currRange][0] , end = range[currRange][1];\\n        long long currSum = range[currRange][2];\\n\\n\\n        //remove that sum from set\\n        auto it = s.find(-currSum);\\n        s.erase(it);\\n\\n        //remove currrange from map\\n        range.erase(currRange);\\n\\n        //partition into two parts l to index-1 and index+1 to r\\n        if (start <= index - 1) {\\n            cnt++;//we need new range\\n            int l = start , r = index - 1;\\n            long long this_range_sum = prefix[r] - prefix[l - 1];\\n\\n            //update the elements in l to r with new range\\n            //we need to increase byt cnt-currRange times\\n            T.add(r + 1, -(cnt - currRange));\\n            T.add(l , cnt - currRange);\\n\\n            //add in set\\n            s.insert(-this_range_sum);\\n\\n            //add in map\\n            range[cnt] = {l, r, this_range_sum};\\n        }\\n\\n        if (index + 1 <= end) {\\n            cnt++;//we need new range\\n            int l = index + 1 , r = end;\\n            long long this_range_sum = prefix[r] - prefix[l - 1];\\n\\n            //update the elements in l to r with new range\\n            //we need to increase byt cnt-currRange times\\n            T.add(r + 1, -(cnt - currRange));\\n            T.add(l , cnt - currRange);\\n\\n            //add in set\\n            s.insert(-this_range_sum);\\n\\n            //add in map\\n            range[cnt] = {l, r, this_range_sum};\\n        }\\n\\n        auto itr = s.begin();\\n        ans.push_back(-(*itr));\\n    }\\n    \\n    return ans;\\n\\n}\\n\\n};\\n````",
                "solutionTags": [],
                "code": "````\\nclass BIT {\\n    int n;\\n    vector<long long>  v;\\npublic:\\n\\n    BIT(int sz) {\\n        n = sz;\\n        v.resize(n + 1);\\n    }\\n\\n    long long sum(int k) {\\n        long long sum = 0;\\n        while (k > 0) {\\n            sum += v[k];\\n            k -= k & -k;\\n        }\\n        return sum;\\n    }\\n\\n    void add(int k , int x) {\\n        while (k <= n) {\\n            v[k] += x;\\n            k += k & -k;\\n        }\\n    }\\n\\n};\\n\\n\\nclass Solution {\\npublic:\\nint cnt = 0;\\nmap < int, vector<long long> > range;\\nmultiset<long long> s;\\n\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n\\n    int n = nums.size();\\n    vector<long long> diff(n + 1, 0), prefix(n + 1, 0),ans; //difference array\\n    for (int i = 0; i < n; i++) {\\n        prefix[i + 1] = prefix[i] + nums[i];\\n    }\\n\\n    BIT T(diff.size());\\n    s.insert(-prefix[n]);   //insert negative for maximum\\n    range[0] = {1, n, prefix[n]};     //now follow one based indexing\\n\\n\\n    for (int index : removeQueries) {\\n        index++;\\n        int currRange = T.sum(index);   //curr range of element\\n\\n        //dimensions of range\\n        int start = range[currRange][0] , end = range[currRange][1];\\n        long long currSum = range[currRange][2];\\n\\n\\n        //remove that sum from set\\n        auto it = s.find(-currSum);\\n        s.erase(it);\\n\\n        //remove currrange from map\\n        range.erase(currRange);\\n\\n        //partition into two parts l to index-1 and index+1 to r\\n        if (start <= index - 1) {\\n            cnt++;//we need new range\\n            int l = start , r = index - 1;\\n            long long this_range_sum = prefix[r] - prefix[l - 1];\\n\\n            //update the elements in l to r with new range\\n            //we need to increase byt cnt-currRange times\\n            T.add(r + 1, -(cnt - currRange));\\n            T.add(l , cnt - currRange);\\n\\n            //add in set\\n            s.insert(-this_range_sum);\\n\\n            //add in map\\n            range[cnt] = {l, r, this_range_sum};\\n        }\\n\\n        if (index + 1 <= end) {\\n            cnt++;//we need new range\\n            int l = index + 1 , r = end;\\n            long long this_range_sum = prefix[r] - prefix[l - 1];\\n\\n            //update the elements in l to r with new range\\n            //we need to increase byt cnt-currRange times\\n            T.add(r + 1, -(cnt - currRange));\\n            T.add(l , cnt - currRange);\\n\\n            //add in set\\n            s.insert(-this_range_sum);\\n\\n            //add in map\\n            range[cnt] = {l, r, this_range_sum};\\n        }\\n\\n        auto itr = s.begin();\\n        ans.push_back(-(*itr));\\n    }\\n    \\n    return ans;\\n\\n}\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2469670,
                "title": "disjoint-set-or-union-find-template-python3",
                "content": "The Disjoint Set(or Union-Find) class template is universal. For this specific problem, one observation is we can maintain segments from the end to the start of the queries to find the maximum segment sum.\\n\\nSince the template only gives us information about whether two elements belong to the same group, the only tricky part is how to keep track of the size information. So we need a Counter `segments` for creating a new group and merging existing groups.\\n\\n``` py\\nclass DSU:\\n    def __init__(self, n):\\n        self.p = list(range(n))\\n\\n    def find(self, x):\\n        if self.p[x]!=x: self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n\\n    def union(self, x, y):\\n        self.p[self.find(x)] = self.find(y)\\n\\nclass Solution:\\n    def maximumSegmentSum(self, A: List[int], Q: List[int]) -> List[int]:\\n        dsu = DSU(len(A))\\n        ans, mx, segments = [], 0, Counter()\\n        for x in reversed(Q):\\n            ans.append(mx)\\n            l, r = 0, 0\\n            if x+1<len(A):\\n                r = segments[dsu.find(x+1)]\\n                if r:\\n                    dsu.union(x, x+1)\\n                    segments.pop(dsu.find(x+1))\\n            if x-1>=0:\\n                l = segments[dsu.find(x-1)]\\n                if l:\\n                    dsu.union(x, x-1)\\n                    segments.pop(dsu.find(x-1))\\n            segments[dsu.find(x)] += l+r+A[x]\\n            mx = max(mx, segments[dsu.find(x)])\\n        return ans[::-1]\\n```",
                "solutionTags": [
                    "Python3",
                    "Union Find"
                ],
                "code": "``` py\\nclass DSU:\\n    def __init__(self, n):\\n        self.p = list(range(n))\\n\\n    def find(self, x):\\n        if self.p[x]!=x: self.p[x] = self.find(self.p[x])\\n        return self.p[x]\\n\\n    def union(self, x, y):\\n        self.p[self.find(x)] = self.find(y)\\n\\nclass Solution:\\n    def maximumSegmentSum(self, A: List[int], Q: List[int]) -> List[int]:\\n        dsu = DSU(len(A))\\n        ans, mx, segments = [], 0, Counter()\\n        for x in reversed(Q):\\n            ans.append(mx)\\n            l, r = 0, 0\\n            if x+1<len(A):\\n                r = segments[dsu.find(x+1)]\\n                if r:\\n                    dsu.union(x, x+1)\\n                    segments.pop(dsu.find(x+1))\\n            if x-1>=0:\\n                l = segments[dsu.find(x-1)]\\n                if l:\\n                    dsu.union(x, x-1)\\n                    segments.pop(dsu.find(x-1))\\n            segments[dsu.find(x)] += l+r+A[x]\\n            mx = max(mx, segments[dsu.find(x)])\\n        return ans[::-1]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2468342,
                "title": "java-solution-using-treeset-and-treemap",
                "content": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n=nums.length;\\n        long[]prefix=new long[n];\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                prefix[i]=nums[i];\\n            }else{\\n                prefix[i]+=(nums[i]+prefix[i-1]);\\n            }\\n        }\\n        \\n        long[]ans=new long[n];\\n        TreeSet<Integer>poppedIndex=new TreeSet();\\n        TreeMap<Long,Long>segmentSum=new TreeMap();\\n        segmentSum.put(prefix[n-1],1L);\\n        for(int i=0;i<n;i++){\\n            int idx=removeQueries[i];\\n            Integer floorIdx=poppedIndex.floor(idx);\\n            Integer ceilIdx=poppedIndex.ceiling(idx);\\n            int floor=floorIdx!=null?floorIdx+1:0;\\n            int ceil=ceilIdx!=null?ceilIdx-1:n-1;\\n            long sumInRange=getSumWithinRange(floor,ceil,prefix);\\n            long leftSum=getSumWithinRange(floor,idx-1,prefix);\\n            long rightSum=getSumWithinRange(idx+1,ceil,prefix);\\n            segmentSum.put(sumInRange,segmentSum.get(sumInRange)-1);\\n            if(segmentSum.get(sumInRange)==0){\\n                segmentSum.remove(sumInRange);\\n            }\\n            segmentSum.put(leftSum,segmentSum.getOrDefault(leftSum,0L)+1);\\n            segmentSum.put(rightSum,segmentSum.getOrDefault(rightSum,0L)+1);\\n            \\n            ans[i]=segmentSum.lastKey();\\n            poppedIndex.add(idx);\\n        }\\n        return ans;\\n    }\\n    \\n    public long  getSumWithinRange(int floor, int ceil,long[] prefix){\\n        if(floor>ceil){\\n            return 0L;\\n        }\\n        if(floor==0){\\n                return prefix[ceil];\\n            }else{\\n               return prefix[ceil]-prefix[floor-1];\\n            } \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n=nums.length;\\n        long[]prefix=new long[n];\\n        for(int i=0;i<n;i++){\\n            if(i==0){\\n                prefix[i]=nums[i];\\n            }else{\\n                prefix[i]+=(nums[i]+prefix[i-1]);\\n            }\\n        }\\n        \\n        long[]ans=new long[n];\\n        TreeSet<Integer>poppedIndex=new TreeSet();\\n        TreeMap<Long,Long>segmentSum=new TreeMap();\\n        segmentSum.put(prefix[n-1],1L);\\n        for(int i=0;i<n;i++){\\n            int idx=removeQueries[i];\\n            Integer floorIdx=poppedIndex.floor(idx);\\n            Integer ceilIdx=poppedIndex.ceiling(idx);\\n            int floor=floorIdx!=null?floorIdx+1:0;\\n            int ceil=ceilIdx!=null?ceilIdx-1:n-1;\\n            long sumInRange=getSumWithinRange(floor,ceil,prefix);\\n            long leftSum=getSumWithinRange(floor,idx-1,prefix);\\n            long rightSum=getSumWithinRange(idx+1,ceil,prefix);\\n            segmentSum.put(sumInRange,segmentSum.get(sumInRange)-1);\\n            if(segmentSum.get(sumInRange)==0){\\n                segmentSum.remove(sumInRange);\\n            }\\n            segmentSum.put(leftSum,segmentSum.getOrDefault(leftSum,0L)+1);\\n            segmentSum.put(rightSum,segmentSum.getOrDefault(rightSum,0L)+1);\\n            \\n            ans[i]=segmentSum.lastKey();\\n            poppedIndex.add(idx);\\n        }\\n        return ans;\\n    }\\n    \\n    public long  getSumWithinRange(int floor, int ceil,long[] prefix){\\n        if(floor>ceil){\\n            return 0L;\\n        }\\n        if(floor==0){\\n                return prefix[ceil];\\n            }else{\\n               return prefix[ceil]-prefix[floor-1];\\n            } \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467942,
                "title": "c-disjoint-set-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    class UnionFind {\\n        vector<pair<int, long long>> st;\\n        public:\\n        UnionFind(int n, vector<int>& nums) {\\n            st = vector<pair<int, long long>> (n);\\n            for (int i = 0; i < n; i++) {\\n                st[i].first = i;\\n                st[i].second = nums[i];\\n            }\\n        }\\n        int find(int v) {\\n            if (v == st[v].first) return v;\\n            return st[v].first = find(st[v].first);\\n        }\\n        long long findValue(int v) {\\n            int pos = find(v);\\n            return st[pos].second;\\n        }\\n        void merge(int u, int v) {\\n            int x = find(u);\\n            int y = find(v);\\n            if (x != y) {\\n                st[x].first = y;\\n                st[y].second += st[x].second;\\n            }\\n        }\\n    };\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        vector<bool> mark(n);\\n        vector<long long> sol(n);\\n        mark[removeQueries[n - 1]] = true;\\n        UnionFind uf(n, nums);\\n        set<long long> mxSegment;\\n        mxSegment.insert(nums[removeQueries[n - 1]]);\\n        for (int i = n - 2; i >= 0; i--) {\\n            long long mxValue = *prev(mxSegment.end());\\n            sol[i] = mxValue;\\n            int pos = removeQueries[i];\\n            mark[pos] = true;\\n            if (pos - 1 >= 0 && mark[pos - 1]) {\\n                uf.merge(pos, pos - 1);\\n            }\\n            if (pos + 1 < n && mark[pos + 1]) {\\n                uf.merge(pos, pos + 1);\\n            }\\n            long long segValue = uf.findValue(pos);\\n            mxSegment.insert(segValue);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    class UnionFind {\\n        vector<pair<int, long long>> st;\\n        public:\\n        UnionFind(int n, vector<int>& nums) {\\n            st = vector<pair<int, long long>> (n);\\n            for (int i = 0; i < n; i++) {\\n                st[i].first = i;\\n                st[i].second = nums[i];\\n            }\\n        }\\n        int find(int v) {\\n            if (v == st[v].first) return v;\\n            return st[v].first = find(st[v].first);\\n        }\\n        long long findValue(int v) {\\n            int pos = find(v);\\n            return st[pos].second;\\n        }\\n        void merge(int u, int v) {\\n            int x = find(u);\\n            int y = find(v);\\n            if (x != y) {\\n                st[x].first = y;\\n                st[y].second += st[x].second;\\n            }\\n        }\\n    };\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        vector<bool> mark(n);\\n        vector<long long> sol(n);\\n        mark[removeQueries[n - 1]] = true;\\n        UnionFind uf(n, nums);\\n        set<long long> mxSegment;\\n        mxSegment.insert(nums[removeQueries[n - 1]]);\\n        for (int i = n - 2; i >= 0; i--) {\\n            long long mxValue = *prev(mxSegment.end());\\n            sol[i] = mxValue;\\n            int pos = removeQueries[i];\\n            mark[pos] = true;\\n            if (pos - 1 >= 0 && mark[pos - 1]) {\\n                uf.merge(pos, pos - 1);\\n            }\\n            if (pos + 1 < n && mark[pos + 1]) {\\n                uf.merge(pos, pos + 1);\\n            }\\n            long long segValue = uf.findValue(pos);\\n            mxSegment.insert(segValue);\\n        }\\n        return sol;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467592,
                "title": "c-100-space-and-time-lower-bound-reverse-sum",
                "content": "```\\n#define max(x,y) x > y ? x : y\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& que) {\\n        const int n = nums.size();\\n        vector<ll> ans(n);\\n        map<int,ll> m;\\n        ll maxSum = 0;\\n        vector<bool> present(n,false);\\n        for(int i = n - 1;i >= 0;i--){\\n            ll sum = 0,q = que[i],cur = q;\\n            present[q] = true;\\n            if(q > 0 && present[q - 1]){\\n                sum += m[q - 1];\\n                m.erase(q-1);\\n            }\\n            if(q + 1 < n && present[q + 1]){\\n                auto it = *m.lower_bound(q);\\n                sum += it.second;\\n                cur = it.first;\\n            }\\n            m[cur] = sum + nums[q];\\n            ans[i] = maxSum;\\n            maxSum = max(m[cur],maxSum);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/65166e3c-a49e-4d14-bcf9-6260bdc493a8_1661242132.6122313.png)\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n#define max(x,y) x > y ? x : y\\n#define ll long long int\\n\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& que) {\\n        const int n = nums.size();\\n        vector<ll> ans(n);\\n        map<int,ll> m;\\n        ll maxSum = 0;\\n        vector<bool> present(n,false);\\n        for(int i = n - 1;i >= 0;i--){\\n            ll sum = 0,q = que[i],cur = q;\\n            present[q] = true;\\n            if(q > 0 && present[q - 1]){\\n                sum += m[q - 1];\\n                m.erase(q-1);\\n            }\\n            if(q + 1 < n && present[q + 1]){\\n                auto it = *m.lower_bound(q);\\n                sum += it.second;\\n                cur = it.first;\\n            }\\n            m[cur] = sum + nums[q];\\n            ans[i] = maxSum;\\n            maxSum = max(m[cur],maxSum);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467403,
                "title": "python-reverse-segment-union-memory-100-runtime-80-explained-with-comments",
                "content": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        removeQueries = removeQueries[::-1]  #Reverse queries\\n        \\n        result = [0]                         #Add zero to result for last removal\\n        edge = {}                            #Track segment edges\\n        \\n        segmentSum = [0 for _ in range(n)]   #Store sum of each segment\\n        currMax = 0                          #Maximum sum of current segments\\n        \\n        for i in range(n-1):\\n            idx = removeQueries[i]           #Index of element to be added \\n            \\n            start = edge[idx+1] if idx+1 in edge else idx          #If next index is start of any segment then update start else current index is start of new segment\\n            end = edge[idx-1] if idx-1 in edge else idx            #If previous index is end of any segment then update end else current index is end of new segment\\n            \\n            edge[start] = end                #Update start and end after adding current element\\n            edge[end] = start\\n\\n            val = nums[idx] + segmentSum[start] + segmentSum[end]  #Update segment sum\\n            segmentSum[start] = val\\n            segmentSum[end] = val\\n\\n            currMax = max(currMax , val)     #Update current segment sum maximum\\n            \\n            result.append(currMax)           #Add maximum segment sum to result\\n        \\n        return result[::-1]                  #Return reverse of result list\\n```\\n\\nPlease Upvote if you find it helpful. My first solution post :)",
                "solutionTags": [
                    "Python",
                    "Union Find"
                ],
                "code": "```\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        n = len(nums)\\n        removeQueries = removeQueries[::-1]  #Reverse queries\\n        \\n        result = [0]                         #Add zero to result for last removal\\n        edge = {}                            #Track segment edges\\n        \\n        segmentSum = [0 for _ in range(n)]   #Store sum of each segment\\n        currMax = 0                          #Maximum sum of current segments\\n        \\n        for i in range(n-1):\\n            idx = removeQueries[i]           #Index of element to be added \\n            \\n            start = edge[idx+1] if idx+1 in edge else idx          #If next index is start of any segment then update start else current index is start of new segment\\n            end = edge[idx-1] if idx-1 in edge else idx            #If previous index is end of any segment then update end else current index is end of new segment\\n            \\n            edge[start] = end                #Update start and end after adding current element\\n            edge[end] = start\\n\\n            val = nums[idx] + segmentSum[start] + segmentSum[end]  #Update segment sum\\n            segmentSum[start] = val\\n            segmentSum[end] = val\\n\\n            currMax = max(currMax , val)     #Update current segment sum maximum\\n            \\n            result.append(currMax)           #Add maximum segment sum to result\\n        \\n        return result[::-1]                  #Return reverse of result list\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467238,
                "title": "python-solved-by-reversed-and-tow-dict-with-explain-runtime-83-memory-100",
                "content": "**Explain:**\\n\\nnums = [1, 2, 5, 6, 1] \\nremoveQueries = [0, 3, 2, 4, 1] \\n\\nReverse as : \\nnums = [0, 0, 0, 0, 0]\\naddQueries  [1, 4, 2, 3, 0]\\n\\n\\nAdd addQueries one by one, and confirm whether it is connected to the left or right\\n\\naddQ = 1 \\n* nums : [0,0,0,0,0] -> [0,[2],0,0,0]  \\n* this round max = max(2,0) = 2\\n\\naddQ = 4\\n* nums : [0,[2],0,0,0] -> [0,[2],0,0,[1]] \\n* this round max = max(1,pre round max) = 2\\n\\naddQ = 2 \\n* nums : [0,[2],0,0,[1]] -> [0,[2,5],0,[1]] \\n* this round max = max(7,pre round max) = 7\\n\\naddQ = 3\\n* nums :  [0,[2,5],0,[1]]  -> [0,[2,5,6,1]] \\n* this round max = max(14,pre round max) = 14\\n\\n\\n\\n**Solution**\\n\\t\\n\\tclass Solution:\\n\\t\\tdef maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n\\t\\t\\tres = [0]\\n\\n\\t\\t\\tse_d = dict()  # use to find end or start of segment\\n\\t\\t\\tseg_d = dict()  # segment sum dict\\n\\t\\t\\tmx = 0\\n\\t\\t\\tfor addQ in removeQueries[:0:-1]:\\n\\t\\t\\t\\tsum = nums[addQ]\\n\\t\\t\\t\\tstart = end = addQ\\n\\n\\t\\t\\t\\t#Check if there are connected segment\\n\\t\\t\\t\\tif addQ + 1 in se_d.keys():\\n\\t\\t\\t\\t\\tend = se_d.pop(addQ + 1)\\n\\t\\t\\t\\t\\tsum += seg_d.pop((addQ + 1, end))\\n\\n\\t\\t\\t\\tif addQ - 1 in se_d.keys():\\n\\t\\t\\t\\t\\tstart = se_d.pop(addQ - 1)\\n\\t\\t\\t\\t\\tsum += seg_d.pop((start, addQ - 1))\\n\\n\\t\\t\\t\\t#save start,end,sum of segment\\n\\t\\t\\t\\tse_d[start] = end\\n\\t\\t\\t\\tse_d[end] = start\\n\\t\\t\\t\\tseg_d[(start, end)] = sum\\n\\n\\t\\t\\t\\t#check this segment sum is maximum or not\\n\\t\\t\\t\\tmx = max(mx, sum)\\n\\t\\t\\t\\tres.append(mx)\\n\\n\\t\\t\\treturn res[::-1]\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "**Explain:**\\n\\nnums = [1, 2, 5, 6, 1] \\nremoveQueries = [0, 3, 2, 4, 1] \\n\\nReverse as : \\nnums = [0, 0, 0, 0, 0]\\naddQueries  [1, 4, 2, 3, 0]\\n\\n\\nAdd addQueries one by one, and confirm whether it is connected to the left or right\\n\\naddQ = 1 \\n* nums : [0,0,0,0,0] -> [0,[2],0,0,0]  \\n* this round max = max(2,0) = 2\\n\\naddQ = 4\\n* nums : [0,[2],0,0,0] -> [0,[2],0,0,[1]] \\n* this round max = max(1,pre round max) = 2\\n\\naddQ = 2 \\n* nums : [0,[2],0,0,[1]] -> [0,[2,5],0,[1]] \\n* this round max = max(7,pre round max) = 7\\n\\naddQ = 3\\n* nums :  [0,[2,5],0,[1]]  -> [0,[2,5,6,1]] \\n* this round max = max(14,pre round max) = 14\\n\\n\\n\\n**Solution**\\n\\t\\n\\tclass Solution:\\n\\t\\tdef maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n\\t\\t\\tres = [0]\\n\\n\\t\\t\\tse_d = dict()  # use to find end or start of segment\\n\\t\\t\\tseg_d = dict()  # segment sum dict\\n\\t\\t\\tmx = 0\\n\\t\\t\\tfor addQ in removeQueries[:0:-1]:\\n\\t\\t\\t\\tsum = nums[addQ]\\n\\t\\t\\t\\tstart = end = addQ\\n\\n\\t\\t\\t\\t#Check if there are connected segment\\n\\t\\t\\t\\tif addQ + 1 in se_d.keys():\\n\\t\\t\\t\\t\\tend = se_d.pop(addQ + 1)\\n\\t\\t\\t\\t\\tsum += seg_d.pop((addQ + 1, end))\\n\\n\\t\\t\\t\\tif addQ - 1 in se_d.keys():\\n\\t\\t\\t\\t\\tstart = se_d.pop(addQ - 1)\\n\\t\\t\\t\\t\\tsum += seg_d.pop((start, addQ - 1))\\n\\n\\t\\t\\t\\t#save start,end,sum of segment\\n\\t\\t\\t\\tse_d[start] = end\\n\\t\\t\\t\\tse_d[end] = start\\n\\t\\t\\t\\tseg_d[(start, end)] = sum\\n\\n\\t\\t\\t\\t#check this segment sum is maximum or not\\n\\t\\t\\t\\tmx = max(mx, sum)\\n\\t\\t\\t\\tres.append(mx)\\n\\n\\t\\t\\treturn res[::-1]\\n",
                "codeTag": "Java"
            },
            {
                "id": 2464509,
                "title": "swift-segment-tree",
                "content": "```\\nclass Solution {\\n    class SgTree {\\n        var l: Int // left bound\\n        var r: Int // right bound\\n        var left: SgTree?\\n        var right: SgTree?\\n        \\n        var hasZero = false\\n        var maxVal: Int // max sum of subarray without zero\\n        var prefix: Int // sum from left to 1st zero\\n        var suffix: Int // sum from right to 1st zero\\n        \\n        init(_ nums: [Int], _ l: Int, _ r: Int) {\\n            self.l = l\\n            self.r = r\\n            if l == r {\\n                maxVal = nums[l]\\n                prefix = nums[l]\\n                suffix = nums[l]\\n            } else {\\n                let mid = (l + r) / 2\\n                let n1 = SgTree(nums, l, mid)\\n                let n2 = SgTree(nums, mid + 1, r)\\n                (left, right) = (n1, n2)\\n                maxVal = n1.maxVal + n2.maxVal\\n                prefix = n1.maxVal + n2.maxVal\\n                suffix = n1.maxVal + n2.maxVal\\n            }\\n        }\\n        \\n        func setZero(at i: Int) {\\n            if l == r {\\n                hasZero = true\\n                maxVal = 0\\n                prefix = 0\\n                suffix = 0\\n            } else if let n1 = left, let n2 = right {\\n                if i <= n1.r {\\n                    n1.setZero(at: i)\\n                } else {\\n                    n2.setZero(at: i)\\n                }\\n                if !n1.hasZero && !n2.hasZero {\\n                    maxVal = n1.maxVal + n2.maxVal\\n                    prefix = n1.maxVal + n2.maxVal\\n                    suffix = n1.maxVal + n2.maxVal\\n                } else {\\n                    hasZero = true\\n                    maxVal = max(n1.suffix + n2.prefix, n1.maxVal, n2.maxVal)\\n                    prefix = n1.hasZero ? n1.prefix : n1.maxVal + n2.prefix\\n                    suffix = n2.hasZero ? n2.suffix : n1.suffix + n2.maxVal\\n                }\\n            }\\n        }\\n    }\\n    func maximumSegmentSum(_ nums: [Int], _ removeQueries: [Int]) -> [Int] {\\n        let n = nums.count\\n        let sgTree = SgTree(nums, 0, n - 1)\\n        var res: [Int] = []\\n        for i in removeQueries {\\n            sgTree.setZero(at: i)\\n            res.append(sgTree.maxVal)\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    class SgTree {\\n        var l: Int // left bound\\n        var r: Int // right bound\\n        var left: SgTree?\\n        var right: SgTree?\\n        \\n        var hasZero = false\\n        var maxVal: Int // max sum of subarray without zero\\n        var prefix: Int // sum from left to 1st zero\\n        var suffix: Int // sum from right to 1st zero\\n        \\n        init(_ nums: [Int], _ l: Int, _ r: Int) {\\n            self.l = l\\n            self.r = r\\n            if l == r {\\n                maxVal = nums[l]\\n                prefix = nums[l]\\n                suffix = nums[l]\\n            } else {\\n                let mid = (l + r) / 2\\n                let n1 = SgTree(nums, l, mid)\\n                let n2 = SgTree(nums, mid + 1, r)\\n                (left, right) = (n1, n2)\\n                maxVal = n1.maxVal + n2.maxVal\\n                prefix = n1.maxVal + n2.maxVal\\n                suffix = n1.maxVal + n2.maxVal\\n            }\\n        }\\n        \\n        func setZero(at i: Int) {\\n            if l == r {\\n                hasZero = true\\n                maxVal = 0\\n                prefix = 0\\n                suffix = 0\\n            } else if let n1 = left, let n2 = right {\\n                if i <= n1.r {\\n                    n1.setZero(at: i)\\n                } else {\\n                    n2.setZero(at: i)\\n                }\\n                if !n1.hasZero && !n2.hasZero {\\n                    maxVal = n1.maxVal + n2.maxVal\\n                    prefix = n1.maxVal + n2.maxVal\\n                    suffix = n1.maxVal + n2.maxVal\\n                } else {\\n                    hasZero = true\\n                    maxVal = max(n1.suffix + n2.prefix, n1.maxVal, n2.maxVal)\\n                    prefix = n1.hasZero ? n1.prefix : n1.maxVal + n2.prefix\\n                    suffix = n2.hasZero ? n2.suffix : n1.suffix + n2.maxVal\\n                }\\n            }\\n        }\\n    }\\n    func maximumSegmentSum(_ nums: [Int], _ removeQueries: [Int]) -> [Int] {\\n        let n = nums.count\\n        let sgTree = SgTree(nums, 0, n - 1)\\n        var res: [Int] = []\\n        for i in removeQueries {\\n            sgTree.setZero(at: i)\\n            res.append(sgTree.maxVal)\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2464455,
                "title": "c-map-set",
                "content": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll pre[100100];\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        pre[0]=nums[0];\\n        for(ll i=1;i<nums.size();i++)\\n        {\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        set<tuple<ll,ll,ll>>s;\\n        map<ll,ll>m;\\n        ll jhc=0;\\n        for(ll i:nums)\\n        {\\n            jhc+=i;\\n        }\\n        ll n=nums.size();\\n        s.insert(make_tuple(n-1,0,jhc));\\n        cout<<jhc<<\"=jhc\\\\n\";\\n        m[-1*jhc]+=1;\\n        vector<ll>ans;\\n        for(ll i:removeQueries)\\n        {\\n            auto it=s.lower_bound(make_tuple(i,-1,0));\\n            ll sum=(get<2>(*it));\\n            ll sind=get<1>(*it);\\n            ll eind=get<0>(*it);\\n            s.erase(*it);\\n            m[-1*sum]-=1;\\n            if(m[-1*sum]==0)\\n            {\\n                m.erase(-1*sum);\\n            }\\n            ll sum1=pre[i]-pre[sind]+nums[sind]-nums[i];\\n            ll sum2=pre[eind]-pre[i];\\n            m[-1*sum1]+=1;\\n            m[-1*sum2]+=1;\\n            if(sind<=i-1)\\n            {\\n                s.insert(make_tuple(i-1,sind,sum1));\\n            }\\n            if(i+1<=eind)\\n            {\\n                s.insert(make_tuple(eind,i+1,sum2));                \\n            }\\n            auto kk=m.begin();\\n            ans.push_back(-1*(kk->first));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n#define ll long long\\nclass Solution {\\npublic:\\n    ll pre[100100];\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        pre[0]=nums[0];\\n        for(ll i=1;i<nums.size();i++)\\n        {\\n            pre[i]=pre[i-1]+nums[i];\\n        }\\n        set<tuple<ll,ll,ll>>s;\\n        map<ll,ll>m;\\n        ll jhc=0;\\n        for(ll i:nums)\\n        {\\n            jhc+=i;\\n        }\\n        ll n=nums.size();\\n        s.insert(make_tuple(n-1,0,jhc));\\n        cout<<jhc<<\"=jhc\\\\n\";\\n        m[-1*jhc]+=1;\\n        vector<ll>ans;\\n        for(ll i:removeQueries)\\n        {\\n            auto it=s.lower_bound(make_tuple(i,-1,0));\\n            ll sum=(get<2>(*it));\\n            ll sind=get<1>(*it);\\n            ll eind=get<0>(*it);\\n            s.erase(*it);\\n            m[-1*sum]-=1;\\n            if(m[-1*sum]==0)\\n            {\\n                m.erase(-1*sum);\\n            }\\n            ll sum1=pre[i]-pre[sind]+nums[sind]-nums[i];\\n            ll sum2=pre[eind]-pre[i];\\n            m[-1*sum1]+=1;\\n            m[-1*sum2]+=1;\\n            if(sind<=i-1)\\n            {\\n                s.insert(make_tuple(i-1,sind,sum1));\\n            }\\n            if(i+1<=eind)\\n            {\\n                s.insert(make_tuple(eind,i+1,sum2));                \\n            }\\n            auto kk=m.begin();\\n            ans.push_back(-1*(kk->first));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2464052,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        set<int> used;\\n        vector<long long> res;\\n        multiset<long long> val;\\n        vector<long long> pre(n+1, 0);\\n        for(int i = 1; i <= n; i++) {\\n            pre[i] = pre[i-1] + nums[i-1];\\n        }\\n        used.insert(-1);\\n        used.insert(n);\\n        val.insert(pre[n]);\\n        for(auto idx : removeQueries) {\\n            long long hi = *used.upper_bound(idx);\\n            long long lo = *(--used.lower_bound(idx));\\n            long long sum = pre[hi] - pre[lo+1];\\n            long long sump1 = pre[idx]-pre[lo+1];\\n            long long sump2 = pre[hi] - pre[idx+1];\\n            used.insert(idx);\\n            val.insert(sump1);\\n            val.insert(sump2);\\n            val.erase(val.lower_bound(sum));\\n            res.push_back(*(--val.end()));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n = nums.size();\\n        set<int> used;\\n        vector<long long> res;\\n        multiset<long long> val;\\n        vector<long long> pre(n+1, 0);\\n        for(int i = 1; i <= n; i++) {\\n            pre[i] = pre[i-1] + nums[i-1];\\n        }\\n        used.insert(-1);\\n        used.insert(n);\\n        val.insert(pre[n]);\\n        for(auto idx : removeQueries) {\\n            long long hi = *used.upper_bound(idx);\\n            long long lo = *(--used.lower_bound(idx));\\n            long long sum = pre[hi] - pre[lo+1];\\n            long long sump1 = pre[idx]-pre[lo+1];\\n            long long sump2 = pre[hi] - pre[idx+1];\\n            used.insert(idx);\\n            val.insert(sump1);\\n            val.insert(sump2);\\n            val.erase(val.lower_bound(sum));\\n            res.push_back(*(--val.end()));\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463413,
                "title": "c-map-multiset-prefix-sum-commented-simple",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& num, vector<int>& que) {\\n        int n=num.size();\\n        vector<long long> ans;\\n        vector<long long> nums(n);\\n        nums[0]=num[0];\\n        for(int i=1;i<n;i++)  //store prefix sum in nums (prefix sum is used to calculate sum of a segment)\\n            nums[i]=nums[i-1]+num[i];\\n\\t\\t\\t\\n\\t\\t//define and initialize map and set\\n        map<pair<int,int>,long long> m;  //pair is for starting and end indices of a segment and sum for that segment is stored as value\\n        m[{0,n-1}]=nums[n-1];\\n        multiset<long long> s;  //sum of all current segments are stored in set\\n        s.insert(nums[n-1]);\\n\\t\\t\\n        for(int i=0;i<n-1;i++){\\n            long long id=que[i];\\n            auto it=m.lower_bound({id,0});  //find in which segment the index(to be removed) is present\\n            if(it==m.end() || id<(*it).first.first) it--;\\n            \\n            auto p=*it;\\n            int a=p.first.first,b=id-1,c=id+1,d=p.first.second;  //break that segment into two segments\\n            \\n            m.erase(it);   //delete current segment\\n            \\n            auto it2=s.find(p.second);\\n            s.erase(it2);      //delete the value of current segment from set\\n            \\n            if(b>=a){     // if end index > starting index of new segment, then add the segment in map and set\\n                long long s1=nums[b]-(a>0?nums[a-1]:0);\\n                m[{a,b}]=s1;\\n                s.insert(s1);\\n            }\\n            if(d>=c){     // same for the second new segment\\n                long long s2=nums[d]-(c>0?nums[c-1]:0);\\n                m[{c,d}]=s2;\\n                s.insert(s2);\\n            }\\n            ans.push_back(*s.rbegin());    //store the maximum value of current segments in the answer array\\n        }\\n        ans.push_back(0);   //last value will be 0 when all the indices are removed\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& num, vector<int>& que) {\\n        int n=num.size();\\n        vector<long long> ans;\\n        vector<long long> nums(n);\\n        nums[0]=num[0];\\n        for(int i=1;i<n;i++)  //store prefix sum in nums (prefix sum is used to calculate sum of a segment)\\n            nums[i]=nums[i-1]+num[i];\\n\\t\\t\\t\\n\\t\\t//define and initialize map and set\\n        map<pair<int,int>,long long> m;  //pair is for starting and end indices of a segment and sum for that segment is stored as value\\n        m[{0,n-1}]=nums[n-1];\\n        multiset<long long> s;  //sum of all current segments are stored in set\\n        s.insert(nums[n-1]);\\n\\t\\t\\n        for(int i=0;i<n-1;i++){\\n            long long id=que[i];\\n            auto it=m.lower_bound({id,0});  //find in which segment the index(to be removed) is present\\n            if(it==m.end() || id<(*it).first.first) it--;\\n            \\n            auto p=*it;\\n            int a=p.first.first,b=id-1,c=id+1,d=p.first.second;  //break that segment into two segments\\n            \\n            m.erase(it);   //delete current segment\\n            \\n            auto it2=s.find(p.second);\\n            s.erase(it2);      //delete the value of current segment from set\\n            \\n            if(b>=a){     // if end index > starting index of new segment, then add the segment in map and set\\n                long long s1=nums[b]-(a>0?nums[a-1]:0);\\n                m[{a,b}]=s1;\\n                s.insert(s1);\\n            }\\n            if(d>=c){     // same for the second new segment\\n                long long s2=nums[d]-(c>0?nums[c-1]:0);\\n                m[{c,d}]=s2;\\n                s.insert(s2);\\n            }\\n            ans.push_back(*s.rbegin());    //store the maximum value of current segments in the answer array\\n        }\\n        ans.push_back(0);   //last value will be 0 when all the indices are removed\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463259,
                "title": "art-of-coding-o-n-reverse-coding-no-pre-requisite",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& val) {\\n        reverse(val.begin(),val.end());\\n        vector<long long>ans;\\n        map<long long,pair<pair<long long,long long>,long long>>m;\\n        for(int i = 0; i < nums.size(); ++ i){\\n            m[i] = {{i,i},0};\\n        }\\n        long long pre = 0;\\n        ans.push_back(pre);\\n        for(auto a:val){\\n            long long cur = nums[a];\\n            long long left = -1, right = -1;\\n            if(a>0){\\n                left = m[a-1].first.first;\\n                cur += m[a-1].second;\\n            }\\n            if(a<nums.size()-1){\\n                right = m[a+1].first.second;\\n                cur += m[a+1].second;\\n            }\\n            if(left == -1){\\n                m[a] = {{0,right},cur};\\n                m[right-1] = {{0,right},cur};\\n            }else if(right == -1){\\n                m[a] = {{left,nums.size()-1},cur};\\n                m[left+1] = {{left,nums.size()-1},cur};\\n            }else{\\n                m[a] = {{left,right},cur};\\n                m[left+1] = {{left,right},cur};\\n                m[right-1] ={{left,right},cur};\\n            }\\n            pre = max(cur,pre);\\n            ans.push_back(pre);\\n        }\\n        ans.pop_back();\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& val) {\\n        reverse(val.begin(),val.end());\\n        vector<long long>ans;\\n        map<long long,pair<pair<long long,long long>,long long>>m;\\n        for(int i = 0; i < nums.size(); ++ i){\\n            m[i] = {{i,i},0};\\n        }\\n        long long pre = 0;\\n        ans.push_back(pre);\\n        for(auto a:val){\\n            long long cur = nums[a];\\n            long long left = -1, right = -1;\\n            if(a>0){\\n                left = m[a-1].first.first;\\n                cur += m[a-1].second;\\n            }\\n            if(a<nums.size()-1){\\n                right = m[a+1].first.second;\\n                cur += m[a+1].second;\\n            }\\n            if(left == -1){\\n                m[a] = {{0,right},cur};\\n                m[right-1] = {{0,right},cur};\\n            }else if(right == -1){\\n                m[a] = {{left,nums.size()-1},cur};\\n                m[left+1] = {{left,nums.size()-1},cur};\\n            }else{\\n                m[a] = {{left,right},cur};\\n                m[left+1] = {{left,right},cur};\\n                m[right-1] ={{left,right},cur};\\n            }\\n            pre = max(cur,pre);\\n            ans.push_back(pre);\\n        }\\n        ans.pop_back();\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461904,
                "title": "python-sortedlist",
                "content": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        s = SortedList(); n = len(nums)\\n        sumList = SortedList()\\n        p = [0]*(len(nums)+1)\\n        for i in range(len(nums)):\\n            p[i+1] += p[i] + nums[i]\\n        s.add([0,n-1,p[-1]])\\n        sumList.add(p[-1])\\n        ans = []\\n        for i in removeQueries:\\n            idx = s.bisect_left([i,-1,-1])\\n            if idx==len(s) or s[idx][0]>i:\\n                idx-=1\\n            start,end,segSum = s[idx]\\n            sumList.remove(segSum)\\n            leftSum = p[i]-p[start]\\n            rightSum = p[end+1] - p[i+1]\\n            s.remove(s[idx])\\n            if i!=start:\\n                sumList.add(leftSum)\\n                s.add([start,i-1,leftSum])\\n            if i!=end:\\n                sumList.add(rightSum)\\n                s.add([i+1,end,rightSum])\\n            if not sumList:\\n                ans.append(0)\\n            else:\\n                ans.append(sumList[-1])\\n        return ans\\n            \\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nfrom sortedcontainers import SortedList\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        s = SortedList(); n = len(nums)\\n        sumList = SortedList()\\n        p = [0]*(len(nums)+1)\\n        for i in range(len(nums)):\\n            p[i+1] += p[i] + nums[i]\\n        s.add([0,n-1,p[-1]])\\n        sumList.add(p[-1])\\n        ans = []\\n        for i in removeQueries:\\n            idx = s.bisect_left([i,-1,-1])\\n            if idx==len(s) or s[idx][0]>i:\\n                idx-=1\\n            start,end,segSum = s[idx]\\n            sumList.remove(segSum)\\n            leftSum = p[i]-p[start]\\n            rightSum = p[end+1] - p[i+1]\\n            s.remove(s[idx])\\n            if i!=start:\\n                sumList.add(leftSum)\\n                s.add([start,i-1,leftSum])\\n            if i!=end:\\n                sumList.add(rightSum)\\n                s.add([i+1,end,rightSum])\\n            if not sumList:\\n                ans.append(0)\\n            else:\\n                ans.append(sumList[-1])\\n        return ans\\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460857,
                "title": "python-reverse-union-find",
                "content": "A simple good solution for starting from back and then merging the chains.\\n\\n```\\ndef find_parent(j, ds):\\n    if ds[j] < 0:\\n        return j\\n    # it might be possible that we have a chain, so we need to\\n    # recurse\\n    parent_index = find_parent(ds[j], ds)\\n    # to optimise the chain, we save the final parent:)\\n    ds[j] = parent_index\\n    return parent_index\\n\\ndef merge(left, b, ds):\\n    # Make the left chain the parent chain\\n    p_left = find_parent(left, ds)\\n    p2 = find_parent(b, ds)\\n    # add the right chain value to the left chain\\n    ds[p_left] += ds[p2]\\n    # connect the right chain to point to the parent of left chain\\n    ds[p2] = p_left\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        N = len(nums)\\n        res = [0] * N\\n        INT_MAX = float(\\'inf\\')\\n        ds = [INT_MAX]*N\\n        \\n        for i in range(N-1, 0, -1):\\n            j = removeQueries[i]\\n            # create a single node chain\\n            ds[j] = -nums[j]\\n            # if there is a chain to the left, then merge them\\n            if (j > 0 and ds[j - 1] != INT_MAX):\\n                merge(j-1, j, ds)\\n            # if there is the chain to the right then merge them\\n            if (j < N - 1 and ds[j + 1] != INT_MAX):\\n                merge(j, j + 1, ds)\\n            # check if the merged chain are bigger than existing biggest\\n            res[i - 1] = max(res[i], -ds[find_parent(j, ds)]);\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\ndef find_parent(j, ds):\\n    if ds[j] < 0:\\n        return j\\n    # it might be possible that we have a chain, so we need to\\n    # recurse\\n    parent_index = find_parent(ds[j], ds)\\n    # to optimise the chain, we save the final parent:)\\n    ds[j] = parent_index\\n    return parent_index\\n\\ndef merge(left, b, ds):\\n    # Make the left chain the parent chain\\n    p_left = find_parent(left, ds)\\n    p2 = find_parent(b, ds)\\n    # add the right chain value to the left chain\\n    ds[p_left] += ds[p2]\\n    # connect the right chain to point to the parent of left chain\\n    ds[p2] = p_left\\n\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        N = len(nums)\\n        res = [0] * N\\n        INT_MAX = float(\\'inf\\')\\n        ds = [INT_MAX]*N\\n        \\n        for i in range(N-1, 0, -1):\\n            j = removeQueries[i]\\n            # create a single node chain\\n            ds[j] = -nums[j]\\n            # if there is a chain to the left, then merge them\\n            if (j > 0 and ds[j - 1] != INT_MAX):\\n                merge(j-1, j, ds)\\n            # if there is the chain to the right then merge them\\n            if (j < N - 1 and ds[j + 1] != INT_MAX):\\n                merge(j, j + 1, ds)\\n            # check if the merged chain are bigger than existing biggest\\n            res[i - 1] = max(res[i], -ds[find_parent(j, ds)]);\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460255,
                "title": "why-my-solution-using-multiset-giving-tle",
                "content": "can somebody tell me why my code is giving TLE???\\n\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rem) {\\n        long long n=nums.size();\\n        set<long long> st;\\n        // st.insert(-1);\\n        multiset<long long> values;\\n        // st.insert(n);\\n        vector<long long> pref(n); \\n        pref[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pref[i]=nums[i];\\n            pref[i]+=pref[i-1];\\n        }\\n        values.insert(pref[n-1]);\\n        values.insert(0);\\n        vector<long long> ret;\\n        for(int i=0;i<rem.size();i++){\\n            long long ind=rem[i];\\n            auto it=upper_bound(st.begin(),st.end(),ind);\\n            long long last=n-1;\\n            long long stt=0;\\n            if(it!=st.end()){\\n                last=(*it)-1;\\n            }\\n            if(it!=st.begin()){\\n                it--;\\n                stt=(*it)+1;\\n            }\\n            long long val=pref[last];\\n            if((stt-1)>=0)val-=pref[stt-1];\\n            values.erase(values.lower_bound(val));\\n            if((ind-1)>=stt){\\n                long long val1=pref[ind-1];\\n                if(stt-1>=0)val1-=pref[stt-1];\\n                values.insert(val1);\\n            }\\n            if((ind+1)<=last){\\n                long long val2=pref[last];\\n                val2-=pref[ind];\\n                values.insert(val2);\\n            }\\n            st.insert(ind);\\n            ret.push_back(*values.rbegin());\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rem) {\\n        long long n=nums.size();\\n        set<long long> st;\\n        // st.insert(-1);\\n        multiset<long long> values;\\n        // st.insert(n);\\n        vector<long long> pref(n); \\n        pref[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pref[i]=nums[i];\\n            pref[i]+=pref[i-1];\\n        }\\n        values.insert(pref[n-1]);\\n        values.insert(0);\\n        vector<long long> ret;\\n        for(int i=0;i<rem.size();i++){\\n            long long ind=rem[i];\\n            auto it=upper_bound(st.begin(),st.end(),ind);\\n            long long last=n-1;\\n            long long stt=0;\\n            if(it!=st.end()){\\n                last=(*it)-1;\\n            }\\n            if(it!=st.begin()){\\n                it--;\\n                stt=(*it)+1;\\n            }\\n            long long val=pref[last];\\n            if((stt-1)>=0)val-=pref[stt-1];\\n            values.erase(values.lower_bound(val));\\n            if((ind-1)>=stt){\\n                long long val1=pref[ind-1];\\n                if(stt-1>=0)val1-=pref[stt-1];\\n                values.insert(val1);\\n            }\\n            if((ind+1)<=last){\\n                long long val2=pref[last];\\n                val2-=pref[ind];\\n                values.insert(val2);\\n            }\\n            st.insert(ind);\\n            ret.push_back(*values.rbegin());\\n        }\\n        return ret;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459970,
                "title": "binary-search-copied-credit-codingmohan",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n=nums.size();\\n        \\n        multiset<long long> segment;\\n        set<int> range;\\n        \\n        vector<long long> pref(n+1,0);\\n        for(int i=1;i<=n;i++)\\n            pref[i]=pref[i-1]+nums[i-1];\\n        \\n        segment.insert(pref[n]);\\n        segment.insert(0);\\n        \\n        \\n        vector<long long> res;\\n        \\n        for(auto ind : removeQueries)\\n        {\\n            ind++;\\n            \\n            int start=1;\\n            int end=n;\\n            \\n            auto next_itr=range.upper_bound(ind);\\n            \\n            if(next_itr!=range.end())\\n            {\\n                end=*next_itr-1;\\n            }\\n            if(next_itr!=range.begin())\\n            {\\n                --next_itr;\\n                start=*next_itr+1;\\n            }\\n            \\n            long long rangesum=pref[end]-pref[start-1];\\n            segment.erase(segment.find(rangesum));\\n            \\n            if(ind-1>=start)\\n                segment.insert(pref[ind-1]-pref[start-1]);\\n            if(ind+1<=end)\\n                segment.insert(pref[end]-pref[ind]);\\n            \\n            range.insert(ind);\\n            \\n            res.push_back(*segment.rbegin());\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Tree",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n=nums.size();\\n        \\n        multiset<long long> segment;\\n        set<int> range;\\n        \\n        vector<long long> pref(n+1,0);\\n        for(int i=1;i<=n;i++)\\n            pref[i]=pref[i-1]+nums[i-1];\\n        \\n        segment.insert(pref[n]);\\n        segment.insert(0);\\n        \\n        \\n        vector<long long> res;\\n        \\n        for(auto ind : removeQueries)\\n        {\\n            ind++;\\n            \\n            int start=1;\\n            int end=n;\\n            \\n            auto next_itr=range.upper_bound(ind);\\n            \\n            if(next_itr!=range.end())\\n            {\\n                end=*next_itr-1;\\n            }\\n            if(next_itr!=range.begin())\\n            {\\n                --next_itr;\\n                start=*next_itr+1;\\n            }\\n            \\n            long long rangesum=pref[end]-pref[start-1];\\n            segment.erase(segment.find(rangesum));\\n            \\n            if(ind-1>=start)\\n                segment.insert(pref[ind-1]-pref[start-1]);\\n            if(ind+1<=end)\\n                segment.insert(pref[end]-pref[ind]);\\n            \\n            range.insert(ind);\\n            \\n            res.push_back(*segment.rbegin());\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459572,
                "title": "array-data-structure-only-o-n-time-o-n-space",
                "content": "While going in reverse order of the queries, numbers are inserted at ```index``` and all we have to check is whether adding the number makes it a part of already existing group(segment) or not.\\nThere are 4 cases for this:\\n1: At  both ```index```-1 and ```index```+1 there is a group.\\n2: Only at ```index```-1 there is a group.\\n3: Only at ```index```+1 there is a group.\\n4: No groups at ```index```-1 and ```index```+1.\\nFor a group three values are needed the ```startingIndex```, ```endingIndex``` and ```sum```.\\nAs we can notice in the above cases we need these values to be present only at the ends of the group and not everywhere in the group as we are not going to make an insertion inside an existing group.\\nSo maintain this information and for every new insertion we can update the values in O(1) time.\\nFor the maximum segment sum as the numbers are positive the max is always increasing so curr_max is max(curr_max , sum of new group which is formed)\\nat start ```curr_max``` is ```0```\\nCases:\\n1. At  both ```index```-1 and ```index```+1 there is a group.\\n\\tThese two groups will be merged to one with the current insertion so, values are updated only at the starting index of ```index```-1 group and ending index of ```index```+1 group.\\n\\t```newSum``` of new group is \\n\\t```groupinfo[index-1].sum + groupinfo[index+1].sum + nums[index]```\\n\\t\\n\\t```newStartingIndex``` is\\n\\t```groupinfo[index-1].startingIndex```\\n\\t\\n\\t```newEndingIndex``` is\\n\\t```groupinfo[index+1].endingIndex```\\n\\t\\n\\t```groupinfo[newStartingindex].sum = newSum``` \\n\\t```groupinfo[newStartingindex].endingIndex = newEndingIndex``` \\n\\t\\t\\n\\t```groupinfo[newEndingIndex].sum = newSum``` \\n\\t```groupinfo[newEndingIndex].startingindex = newStartingindex``` \\n\\t```curr_max = max(curr_max,newSum)```\\n2. Only at ```index```-1 there is a group.\\n\\t```newSum``` of new group is \\n\\t```groupinfo[index-1].sum + nums[index]```\\n\\t\\n\\t```newStartingIndex``` is\\n\\t```groupinfo[index-1].startingIndex```\\n\\t\\n\\t```newEndingIndex``` is\\n\\t```index```\\n\\t\\n\\t```groupinfo[newStartingindex].sum = newSum``` \\n\\t```groupinfo[newStartingindex].endingIndex = newEndingIndex``` \\n\\t\\t\\n\\t```groupinfo[newEndingIndex].sum = newSum``` \\n\\t```groupinfo[newEndingIndex].startingindex = newStartingindex```\\n\\t```groupinfo[newEndingIndex].endingindex = newEndingIndex```\\n\\t```curr_max = max(curr_max,newSum)```\\n3. Only at ```index```+1 there is a group.\\n\\t```newSum``` of new group is \\n\\t```groupinfo[index+1].sum + nums[index]```\\n\\t\\n\\t```newStartingIndex``` is\\n\\t```index```\\n\\t\\n\\t```newEndingIndex``` is\\n\\t```groupinfo[index+1].endingIndex```\\n\\t\\n\\t```groupinfo[newStartingindex].sum = newSum``` \\n\\t```groupinfo[newStartingindex].startingIndex = newStartingindex``` \\n\\t```groupinfo[newStartingindex].endingIndex = newEndingIndex``` \\n\\t\\t\\n\\t```groupinfo[newEndingIndex].sum = newSum``` \\n\\t```groupinfo[newEndingIndex].startingindex = newStartingindex```\\n\\t```curr_max = max(curr_max,newSum)```\\n4. No groups at ```index```-1 and ```index```+1.\\n\\t```newSum``` of new group is \\n\\t```nums[index]```\\n\\t\\n\\tboth ```newStartingIndex``` and ```newEndingIndex``` is```index```\\n\\t\\n\\t```groupinfo[index].sum = newSum``` \\n\\t```groupinfo[index].startingIndex = newStartingindex``` \\n\\t```groupinfo[index].endingIndex = newEndingIndex```\\n\\t```curr_max = max(curr_max,newSum)```\\n\\t\\nC++ Code\\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        const long long n=nums.size();\\n        vector<vector<long long>>groupinfo(n,{-1,-1,-1});\\n\\t\\t//for i\\'th index\\n\\t\\t// groupinfo[i][0] is startingIndex\\n\\t\\t// groupinfo[i][1] is endingIndex\\n\\t\\t// groupinfo[i][2] is sum\\n        vector<long long>res(n);\\n        long long mx=0;\\n        for(long long i=n-1;i>=0;--i){\\n            res[i]=mx;\\n            long long index=removeQueries[i];\\n            long long l,r,sum;\\n            if(index!=0 && index!=n-1 && groupinfo[index-1][0]!=-1 && groupinfo[index+1][0]!=-1){\\n                sum=groupinfo[index-1][2]+groupinfo[index+1][2]+nums[index];\\n                l=groupinfo[index-1][0];\\n                r=groupinfo[index+1][1];\\n                groupinfo[l][1]=r;\\n                groupinfo[l][2]=sum;\\n                groupinfo[r][0]=l;\\n                groupinfo[r][2]=sum;\\n            }else if(index!=0 && groupinfo[index-1][0]!=-1){\\n                l=groupinfo[index-1][0];\\n                sum=groupinfo[l][2]+nums[index];\\n                groupinfo[l][1]=index;\\n                groupinfo[l][2]=sum;\\n                groupinfo[index][0]=l;\\n                groupinfo[index][1]=index;\\n                groupinfo[index][2]=sum;\\n            }else if(index!=n-1 && groupinfo[index+1][0]!=-1){\\n                r=groupinfo[index+1][1];\\n                sum=groupinfo[r][2]+nums[index];\\n                groupinfo[r][0]=index;\\n                groupinfo[r][2]=sum;\\n                groupinfo[index][0]=index;\\n                groupinfo[index][1]=r;\\n                groupinfo[index][2]=sum;\\n            }else{\\n                groupinfo[index][0]=groupinfo[index][1]=index;\\n                groupinfo[index][2]=nums[index];\\n                sum=nums[index];\\n            }\\n            mx=max(mx,sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Array"
                ],
                "code": "```index```\n```index```\n```index```\n```index```\n```index```\n```index```\n```index```\n```startingIndex```\n```endingIndex```\n```sum```\n```curr_max```\n```0```\n```index```\n```index```\n```index```\n```index```\n```newSum```\n```groupinfo[index-1].sum + groupinfo[index+1].sum + nums[index]```\n```newStartingIndex```\n```groupinfo[index-1].startingIndex```\n```newEndingIndex```\n```groupinfo[index+1].endingIndex```\n```groupinfo[newStartingindex].sum = newSum```\n```groupinfo[newStartingindex].endingIndex = newEndingIndex```\n```groupinfo[newEndingIndex].sum = newSum```\n```groupinfo[newEndingIndex].startingindex = newStartingindex```\n```curr_max = max(curr_max,newSum)```\n```index```\n```newSum```\n```groupinfo[index-1].sum + nums[index]```\n```newStartingIndex```\n```groupinfo[index-1].startingIndex```\n```newEndingIndex```\n```index```\n```groupinfo[newStartingindex].sum = newSum```\n```groupinfo[newStartingindex].endingIndex = newEndingIndex```\n```groupinfo[newEndingIndex].sum = newSum```\n```groupinfo[newEndingIndex].startingindex = newStartingindex```\n```groupinfo[newEndingIndex].endingindex = newEndingIndex```\n```curr_max = max(curr_max,newSum)```\n```index```\n```newSum```\n```groupinfo[index+1].sum + nums[index]```\n```newStartingIndex```\n```index```\n```newEndingIndex```\n```groupinfo[index+1].endingIndex```\n```groupinfo[newStartingindex].sum = newSum```\n```groupinfo[newStartingindex].startingIndex = newStartingindex```\n```groupinfo[newStartingindex].endingIndex = newEndingIndex```\n```groupinfo[newEndingIndex].sum = newSum```\n```groupinfo[newEndingIndex].startingindex = newStartingindex```\n```curr_max = max(curr_max,newSum)```\n```index```\n```index```\n```newSum```\n```nums[index]```\n```newStartingIndex```\n```newEndingIndex```\n```index```\n```groupinfo[index].sum = newSum```\n```groupinfo[index].startingIndex = newStartingindex```\n```groupinfo[index].endingIndex = newEndingIndex```\n```curr_max = max(curr_max,newSum)```\n```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        const long long n=nums.size();\\n        vector<vector<long long>>groupinfo(n,{-1,-1,-1});\\n\\t\\t//for i\\'th index\\n\\t\\t// groupinfo[i][0] is startingIndex\\n\\t\\t// groupinfo[i][1] is endingIndex\\n\\t\\t// groupinfo[i][2] is sum\\n        vector<long long>res(n);\\n        long long mx=0;\\n        for(long long i=n-1;i>=0;--i){\\n            res[i]=mx;\\n            long long index=removeQueries[i];\\n            long long l,r,sum;\\n            if(index!=0 && index!=n-1 && groupinfo[index-1][0]!=-1 && groupinfo[index+1][0]!=-1){\\n                sum=groupinfo[index-1][2]+groupinfo[index+1][2]+nums[index];\\n                l=groupinfo[index-1][0];\\n                r=groupinfo[index+1][1];\\n                groupinfo[l][1]=r;\\n                groupinfo[l][2]=sum;\\n                groupinfo[r][0]=l;\\n                groupinfo[r][2]=sum;\\n            }else if(index!=0 && groupinfo[index-1][0]!=-1){\\n                l=groupinfo[index-1][0];\\n                sum=groupinfo[l][2]+nums[index];\\n                groupinfo[l][1]=index;\\n                groupinfo[l][2]=sum;\\n                groupinfo[index][0]=l;\\n                groupinfo[index][1]=index;\\n                groupinfo[index][2]=sum;\\n            }else if(index!=n-1 && groupinfo[index+1][0]!=-1){\\n                r=groupinfo[index+1][1];\\n                sum=groupinfo[r][2]+nums[index];\\n                groupinfo[r][0]=index;\\n                groupinfo[r][2]=sum;\\n                groupinfo[index][0]=index;\\n                groupinfo[index][1]=r;\\n                groupinfo[index][2]=sum;\\n            }else{\\n                groupinfo[index][0]=groupinfo[index][1]=index;\\n                groupinfo[index][2]=nums[index];\\n                sum=nums[index];\\n            }\\n            mx=max(mx,sum);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458882,
                "title": "intuitive-solution-using-map-and-multiset",
                "content": "```\\nclass Solution {\\npublic:\\n    long long su(int l,int r,vector<long long> &v){ //prefix sum function for fast range sum calculation\\n        if(l==0) return v[r];\\n        else return v[r]-v[l-1];\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& remo) {\\n        map<pair<long long,long long>,long long> mp;\\n        int n=nums.size();\\n        vector<long long> v(n,0);v[0]=nums[0];\\n        for(int i=1;i<n;i++) v[i]=v[i-1]+nums[i];\\n        multiset<long long> mt;\\n        mp[{0,n-1}]=su(0,n-1,v);\\n        mt.insert(su(0,n-1,v));\\n        vector<long long> ans;\\n        for(int i=0;i<n;i++){\\n            int x=remo[i];\\n            auto it = mp.upper_bound({x,1e9}); //finding in which segment the x is\\n            it--;\\n            int l=it->first.first,r=it->first.second;\\n            long long val=it->second;\\n            mt.erase(mt.find(val));\\n            mp.erase(it);\\n            if(l==r){}                  // do nothing if segment is single value\\n            else if(x==l){              //only add right segment after partion\\n                int l2=x+1,r2=r;\\n                if(l2<=r2){\\n                    mt.insert(su(l2,r2,v));\\n                    mp[{l2,r2}]=su(l2,r2,v);\\n                }\\n            }else if(x==r){              //only add left segment\\n                int l1=l,r1=x-1;\\n                if(l1<=r1){\\n                    mt.insert(su(l1,r1,v));\\n                    mp[{l1,r1}]=su(l1,r1,v);\\n                }\\n            }else{                         //otherwise\\n                int l1=l,r1=x-1,l2=x+1,r2=r;\\n                if(l1<=r1){\\n                    mt.insert(su(l1,r1,v));\\n                    mp[{l1,r1}]=su(l1,r1,v);\\n                }\\n                if(l2<=r2){\\n                    mt.insert(su(l2,r2,v));\\n                    mp[{l2,r2}]=su(l2,r2,v);\\n                }\\n            }\\n            auto it1=mt.end();\\n            if(!mt.empty()){it1--;ans.push_back(*it1);}\\n        }\\n        ans.push_back(0);     //adding 0 for the last element\\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long su(int l,int r,vector<long long> &v){ //prefix sum function for fast range sum calculation\\n        if(l==0) return v[r];\\n        else return v[r]-v[l-1];\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2458735,
                "title": "segment-tree-approach",
                "content": "There are multiple approachs to this problem, however I feel only segment tree approach more intuitive. \\n\\n```\\nclass Solution {\\n    \\n    class SegTree{\\n        \\n        long maxSeg;\\n        long pmaxSeg;\\n        long smaxSeg;\\n        \\n        int pPointer;\\n        int sPointer;\\n        \\n        int left;\\n        int right;\\n        \\n        SegTree leftChild;\\n        SegTree rightChild;\\n        \\n        public SegTree(int[] a, int l, int r){\\n            \\n            pPointer = -1;\\n            sPointer = -1;\\n            left = l;\\n            right = r;\\n\\n            if(l==r){\\n                maxSeg = a[l];\\n                pmaxSeg = a[l];\\n                smaxSeg = a[l];\\n                return;\\n            }\\n            \\n            int m = l+(r-l)/2;\\n            leftChild = new SegTree(a, l, m);\\n            rightChild = new SegTree(a, m+1, r);\\n            recalc();\\n            \\n        }\\n        \\n        public void update(int x){\\n            if(left==right){\\n                maxSeg = 0;\\n                pmaxSeg = 0;\\n                smaxSeg = 0;\\n                pPointer = left;\\n                sPointer = left;\\n                return;\\n            }\\n            if(x<=leftChild.right){\\n                leftChild.update(x);\\n            }else{\\n                rightChild.update(x);\\n            }\\n            recalc();\\n        }\\n        \\n        private void recalc(){\\n            \\n            pmaxSeg = leftChild.pmaxSeg;\\n            if(leftChild.pPointer == -1){\\n                pmaxSeg = rightChild.pmaxSeg + leftChild.pmaxSeg;\\n            }\\n            \\n            smaxSeg = rightChild.smaxSeg;\\n            if(rightChild.sPointer == -1){\\n                smaxSeg = leftChild.smaxSeg + rightChild.smaxSeg;\\n            }\\n            \\n            pPointer = leftChild.pPointer;\\n            if(leftChild.pPointer == -1) pPointer = rightChild.pPointer;\\n            \\n            sPointer = rightChild.sPointer;\\n            if(rightChild.sPointer == -1) sPointer = leftChild.sPointer;\\n            \\n            maxSeg = Math.max(leftChild.maxSeg, rightChild.maxSeg);\\n            \\n            //check if maxSeg lies half left and half right\\n            if(leftChild.pPointer == -1){\\n                maxSeg = Math.max(maxSeg, leftChild.maxSeg + rightChild.pmaxSeg);\\n            }\\n            \\n            if(rightChild.sPointer == -1){\\n                maxSeg = Math.max(maxSeg, rightChild.maxSeg + leftChild.smaxSeg);\\n            }\\n            \\n            maxSeg = Math.max(maxSeg, leftChild.smaxSeg + rightChild.pmaxSeg);\\n            \\n            \\n        }\\n        \\n        \\n    }\\n    \\n    boolean debug = false;\\n    \\n    \\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        \\n        int n = nums.length;\\n        SegTree seg = new SegTree(nums, 0, n-1);\\n        \\n        if(debug){\\n            \\n            System.out.println(seg.leftChild.maxSeg+\" \"+seg.rightChild.maxSeg);\\n            \\n        }\\n        \\n        int m = removeQueries.length;\\n        long[] ans = new long[m];\\n        int i = 0;\\n        \\n        for(int x: removeQueries){\\n            \\n            seg.update(x);\\n            if(debug){\\n                System.out.println(seg.leftChild.maxSeg+\" \"+seg.rightChild.maxSeg);\\n                System.out.println(seg.leftChild.smaxSeg+\" \"+seg.rightChild.pmaxSeg);\\n                System.out.println(\"----\");\\n            }\\n            long y = seg.maxSeg;\\n            ans[i++] = y;\\n        }\\n        \\n        return ans;\\n                \\n    }\\n    \\n    \\n    \\n    \\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    class SegTree{\\n        \\n        long maxSeg;\\n        long pmaxSeg;\\n        long smaxSeg;\\n        \\n        int pPointer;\\n        int sPointer;\\n        \\n        int left;\\n        int right;\\n        \\n        SegTree leftChild;\\n        SegTree rightChild;\\n        \\n        public SegTree(int[] a, int l, int r){\\n            \\n            pPointer = -1;\\n            sPointer = -1;\\n            left = l;\\n            right = r;\\n\\n            if(l==r){\\n                maxSeg = a[l];\\n                pmaxSeg = a[l];\\n                smaxSeg = a[l];\\n                return;\\n            }\\n            \\n            int m = l+(r-l)/2;\\n            leftChild = new SegTree(a, l, m);\\n            rightChild = new SegTree(a, m+1, r);\\n            recalc();\\n            \\n        }\\n        \\n        public void update(int x){\\n            if(left==right){\\n                maxSeg = 0;\\n                pmaxSeg = 0;\\n                smaxSeg = 0;\\n                pPointer = left;\\n                sPointer = left;\\n                return;\\n            }\\n            if(x<=leftChild.right){\\n                leftChild.update(x);\\n            }else{\\n                rightChild.update(x);\\n            }\\n            recalc();\\n        }\\n        \\n        private void recalc(){\\n            \\n            pmaxSeg = leftChild.pmaxSeg;\\n            if(leftChild.pPointer == -1){\\n                pmaxSeg = rightChild.pmaxSeg + leftChild.pmaxSeg;\\n            }\\n            \\n            smaxSeg = rightChild.smaxSeg;\\n            if(rightChild.sPointer == -1){\\n                smaxSeg = leftChild.smaxSeg + rightChild.smaxSeg;\\n            }\\n            \\n            pPointer = leftChild.pPointer;\\n            if(leftChild.pPointer == -1) pPointer = rightChild.pPointer;\\n            \\n            sPointer = rightChild.sPointer;\\n            if(rightChild.sPointer == -1) sPointer = leftChild.sPointer;\\n            \\n            maxSeg = Math.max(leftChild.maxSeg, rightChild.maxSeg);\\n            \\n            //check if maxSeg lies half left and half right\\n            if(leftChild.pPointer == -1){\\n                maxSeg = Math.max(maxSeg, leftChild.maxSeg + rightChild.pmaxSeg);\\n            }\\n            \\n            if(rightChild.sPointer == -1){\\n                maxSeg = Math.max(maxSeg, rightChild.maxSeg + leftChild.smaxSeg);\\n            }\\n            \\n            maxSeg = Math.max(maxSeg, leftChild.smaxSeg + rightChild.pmaxSeg);\\n            \\n            \\n        }\\n        \\n        \\n    }\\n    \\n    boolean debug = false;\\n    \\n    \\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        \\n        int n = nums.length;\\n        SegTree seg = new SegTree(nums, 0, n-1);\\n        \\n        if(debug){\\n            \\n            System.out.println(seg.leftChild.maxSeg+\" \"+seg.rightChild.maxSeg);\\n            \\n        }\\n        \\n        int m = removeQueries.length;\\n        long[] ans = new long[m];\\n        int i = 0;\\n        \\n        for(int x: removeQueries){\\n            \\n            seg.update(x);\\n            if(debug){\\n                System.out.println(seg.leftChild.maxSeg+\" \"+seg.rightChild.maxSeg);\\n                System.out.println(seg.leftChild.smaxSeg+\" \"+seg.rightChild.pmaxSeg);\\n                System.out.println(\"----\");\\n            }\\n            long y = seg.maxSeg;\\n            ans[i++] = y;\\n        }\\n        \\n        return ans;\\n                \\n    }\\n    \\n    \\n    \\n    \\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458208,
                "title": "brute-force-approach-to-think",
                "content": "This is the inutitive first easy approach that you may start with.\\n\\n\\n\\n\\n\\n\\n        \\n    vector<long long> maximumSegmentSum(vector<int>& nums,vector<int>& removeQueries) {\\n        vector<long long> ans;  \\n        \\n        vector<int> temp(nums.size()) ;\\n        for(int i = 0 ; i<nums.size() ; i++)       temp[i] = nums[i] ;\\n        \\n        for(int i = 0 ; i<removeQueries.size() ; i++){\\n            \\n           \\n            temp[removeQueries[i]] = 0 ;\\n            \\n             long long curr_sum = 0 ;\\n             long long max_sum_till_now = INT_MIN ;\\n        \\n        \\n          for(int i = 0 ; i<temp.size() ; i++){\\n            \\n            curr_sum += temp[i] ;\\n            max_sum_till_now = max(max_sum_till_now, curr_sum) ;\\n            \\n           if(temp[i]==0)   curr_sum = 0 ;\\n        }\\n            \\n            ans.push_back(max_sum_till_now) ;\\n        }\\n        \\n        \\n        \\n        return ans ;\\n        \\n        \\n    }\\n\\t\\n\\t\\n\\t\\n\\t//29 test cases are passed . this is how yoou can start.",
                "solutionTags": [
                    "C"
                ],
                "code": "This is the inutitive first easy approach that you may start with.\\n\\n\\n\\n\\n\\n\\n        \\n    vector<long long> maximumSegmentSum(vector<int>& nums,vector<int>& removeQueries) {\\n        vector<long long> ans;  \\n        \\n        vector<int> temp(nums.size()) ;\\n        for(int i = 0 ; i<nums.size() ; i++)       temp[i] = nums[i] ;\\n        \\n        for(int i = 0 ; i<removeQueries.size() ; i++){\\n            \\n           \\n            temp[removeQueries[i]] = 0 ;\\n            \\n             long long curr_sum = 0 ;\\n             long long max_sum_till_now = INT_MIN ;\\n        \\n        \\n          for(int i = 0 ; i<temp.size() ; i++){\\n            \\n            curr_sum += temp[i] ;\\n            max_sum_till_now = max(max_sum_till_now, curr_sum) ;\\n            \\n           if(temp[i]==0)   curr_sum = 0 ;\\n        }\\n            \\n            ans.push_back(max_sum_till_now) ;\\n        }\\n        \\n        \\n        \\n        return ans ;\\n        \\n        \\n    }\\n\\t\\n\\t\\n\\t\\n\\t//29 test cases are passed . this is how yoou can start.",
                "codeTag": "Unknown"
            },
            {
                "id": 2457314,
                "title": "python-go-c-c-merge-segments-reversely-for-split-playback-o-n",
                "content": "*Python* w/ prefix sum\\n\\n```python\\ndef maximumSegmentSum(self, nums, removeQueries):\\n    res, seen, psum = [0], {}, list(itertools.accumulate(nums, initial=0))\\n    for i in removeQueries[:0:-1]:                      # iterate reversely\\n        l, r = seen.get(i - 1, i), seen.get(i + 1, i)   # find leftmost and rightmost for current conjuntion\\n        seen[l], seen[r] = r, l                         # mark and merge segments from leftmost to rightmost\\n        res.append(max(res[-1], psum[r + 1] - psum[l])) # maximize segment sum from leftmost to rightmost\\n    return res[::-1]\\n```\\n\\n*Go* w/ prefix sum\\n\\n```go\\nfunc max(x, y int64) int64 {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc maximumSegmentSum(nums []int, removeQueries []int) []int64 {\\n\\tvar (\\n\\t\\tn    = len(nums)\\n\\t\\tres  = make([]int64, n)\\n\\t\\tseen = make(map[int]int)\\n\\t\\tpsum = make([]int64, 1)\\n\\t)\\n\\tfor i, num := range nums {\\n\\t\\tpsum = append(psum, psum[i]+int64(num))\\n\\t}\\n\\tfor i := n - 1; i > 0; i-- {\\n\\t\\tj := removeQueries[i]\\n\\t\\tl, r := j, j\\n\\t\\tif k, ok := seen[j-1]; ok {\\n\\t\\t\\tl = k\\n\\t\\t}\\n\\t\\tif k, ok := seen[j+1]; ok {\\n\\t\\t\\tr = k\\n\\t\\t}\\n\\t\\tseen[l], seen[r] = r, l\\n\\t\\tres[i-1] = max(res[i], psum[r+1]-psum[l])\\n\\t}\\n\\treturn res\\n}\\n```\\n\\n*C++* w/ prefix sum\\n\\n```c++\\nvector<long long> maximumSegmentSum(vector<int> &nums, vector<int> &removeQueries) {\\n    int n = nums.size();\\n    vector<long long> res(n, 0), psum(1, 0);\\n    unordered_map<int, int> seen;\\n    for (int i = 0; i < n; ++i) psum.push_back(*rbegin(psum) + nums[i]);\\n    for (int i = n - 1; i > 0; --i) {\\n        int j = removeQueries[i], l = seen.count(j - 1) ? seen[j - 1] : j, r = seen.count(j + 1) ? seen[j + 1] : j;\\n        seen[l] = r, seen[r] = l;\\n        res[i - 1] = max(res[i], psum[r + 1] - psum[l]);\\n    }\\n    return res;\\n}\\n```\\n\\n*C* w/ prefix sum\\n\\n```c\\ntypedef long long ll;\\nll max(ll x, ll y) { return x > y ? x : y; }\\nint or(int x, int y) { return x ? x : y; }\\n\\nlong long *maximumSegmentSum(int *nums, int numsSize, int *removeQueries, int removeQueriesSize, int *returnSize) {\\n    \\n    ll *res = (ll *)calloc(numsSize, sizeof(ll));\\n    int *vis = (int *)calloc(numsSize + 2, sizeof(int));\\n    ll *psum = (ll *)calloc(numsSize + 1, sizeof(ll));\\n    \\n    for (int i = 0; i < numsSize; ++i) psum[i + 1] = psum[i] + nums[i];\\n    \\n    for (int i = numsSize - 1; i > 0; --i) {\\n        int j = removeQueries[i] + 1, l = or(vis[j - 1], j), r = or(vis[j + 1], j);\\n        vis[l] = r, vis[r] = l;\\n        res[i - 1] = max(res[i], psum[r] - psum[l - 1]);\\n    }\\n    \\n    *returnSize = numsSize;\\n    return res;\\n}\\n```",
                "solutionTags": [],
                "code": "```python\\ndef maximumSegmentSum(self, nums, removeQueries):\\n    res, seen, psum = [0], {}, list(itertools.accumulate(nums, initial=0))\\n    for i in removeQueries[:0:-1]:                      # iterate reversely\\n        l, r = seen.get(i - 1, i), seen.get(i + 1, i)   # find leftmost and rightmost for current conjuntion\\n        seen[l], seen[r] = r, l                         # mark and merge segments from leftmost to rightmost\\n        res.append(max(res[-1], psum[r + 1] - psum[l])) # maximize segment sum from leftmost to rightmost\\n    return res[::-1]\\n```\n```go\\nfunc max(x, y int64) int64 {\\n\\tif x > y {\\n\\t\\treturn x\\n\\t}\\n\\treturn y\\n}\\n\\nfunc maximumSegmentSum(nums []int, removeQueries []int) []int64 {\\n\\tvar (\\n\\t\\tn    = len(nums)\\n\\t\\tres  = make([]int64, n)\\n\\t\\tseen = make(map[int]int)\\n\\t\\tpsum = make([]int64, 1)\\n\\t)\\n\\tfor i, num := range nums {\\n\\t\\tpsum = append(psum, psum[i]+int64(num))\\n\\t}\\n\\tfor i := n - 1; i > 0; i-- {\\n\\t\\tj := removeQueries[i]\\n\\t\\tl, r := j, j\\n\\t\\tif k, ok := seen[j-1]; ok {\\n\\t\\t\\tl = k\\n\\t\\t}\\n\\t\\tif k, ok := seen[j+1]; ok {\\n\\t\\t\\tr = k\\n\\t\\t}\\n\\t\\tseen[l], seen[r] = r, l\\n\\t\\tres[i-1] = max(res[i], psum[r+1]-psum[l])\\n\\t}\\n\\treturn res\\n}\\n```\n```c++\\nvector<long long> maximumSegmentSum(vector<int> &nums, vector<int> &removeQueries) {\\n    int n = nums.size();\\n    vector<long long> res(n, 0), psum(1, 0);\\n    unordered_map<int, int> seen;\\n    for (int i = 0; i < n; ++i) psum.push_back(*rbegin(psum) + nums[i]);\\n    for (int i = n - 1; i > 0; --i) {\\n        int j = removeQueries[i], l = seen.count(j - 1) ? seen[j - 1] : j, r = seen.count(j + 1) ? seen[j + 1] : j;\\n        seen[l] = r, seen[r] = l;\\n        res[i - 1] = max(res[i], psum[r + 1] - psum[l]);\\n    }\\n    return res;\\n}\\n```\n```c\\ntypedef long long ll;\\nll max(ll x, ll y) { return x > y ? x : y; }\\nint or(int x, int y) { return x ? x : y; }\\n\\nlong long *maximumSegmentSum(int *nums, int numsSize, int *removeQueries, int removeQueriesSize, int *returnSize) {\\n    \\n    ll *res = (ll *)calloc(numsSize, sizeof(ll));\\n    int *vis = (int *)calloc(numsSize + 2, sizeof(int));\\n    ll *psum = (ll *)calloc(numsSize + 1, sizeof(ll));\\n    \\n    for (int i = 0; i < numsSize; ++i) psum[i + 1] = psum[i] + nums[i];\\n    \\n    for (int i = numsSize - 1; i > 0; --i) {\\n        int j = removeQueries[i] + 1, l = or(vis[j - 1], j), r = or(vis[j + 1], j);\\n        vis[l] = r, vis[r] = l;\\n        res[i - 1] = max(res[i], psum[r] - psum[l - 1]);\\n    }\\n    \\n    *returnSize = numsSize;\\n    return res;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2456272,
                "title": "easy-c-solution-range-splitting",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& Queries) {\\n        set<pair<int,int>> range;\\n        multiset<long long> ms;\\n        ms.insert(0);\\n        vector<long long> a(nums.size());\\n        a[0] = nums[0];\\n        for(int i=1; i<nums.size(); i++) a[i] = nums[i] + a[i-1];\\n        vector<long long> ans;\\n        ms.insert(a.back());  // sum of range [0,n-1]\\n        range.insert({0,nums.size()-1});  // range [0..n-1]\\n        for(int q : Queries) {\\n            auto pos = range.upper_bound({q,2e9});\\n            if(pos == range.begin()) {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            pos--;\\n            \\n            long long Left = (q ? a[q - 1] : 0) - (pos->first ? a[pos->first - 1] : 0);\\n            long long Right = a[pos->second] - a[q];\\n            long long cur = a[pos->second] - (pos->first ? a[pos->first - 1] : 0);\\n            \\n            \\n            // range [1...4] , erase q = 3 , split into => range[1..2] & range[4..4]     \\n            \\n            if(pos->first<=q-1) {\\n                 range.insert({pos->first,q-1});   // left split\\n                 ms.insert(Left);\\n            }\\n            if(pos->second>=q+1) {\\n                 range.insert({q+1,pos->second});   // rightsplit\\n                 ms.insert(Right);\\n            }\\n            \\n            ms.erase(ms.find(cur));  // erase the sum of range \\n            \\n            range.erase(pos);  // erase the range\\n         \\n            ans.push_back(*ms.rbegin());   // maximum range sum\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Binary Search",
                    "Greedy",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& Queries) {\\n        set<pair<int,int>> range;\\n        multiset<long long> ms;\\n        ms.insert(0);\\n        vector<long long> a(nums.size());\\n        a[0] = nums[0];\\n        for(int i=1; i<nums.size(); i++) a[i] = nums[i] + a[i-1];\\n        vector<long long> ans;\\n        ms.insert(a.back());  // sum of range [0,n-1]\\n        range.insert({0,nums.size()-1});  // range [0..n-1]\\n        for(int q : Queries) {\\n            auto pos = range.upper_bound({q,2e9});\\n            if(pos == range.begin()) {\\n                ans.push_back(0);\\n                continue;\\n            }\\n            pos--;\\n            \\n            long long Left = (q ? a[q - 1] : 0) - (pos->first ? a[pos->first - 1] : 0);\\n            long long Right = a[pos->second] - a[q];\\n            long long cur = a[pos->second] - (pos->first ? a[pos->first - 1] : 0);\\n            \\n            \\n            // range [1...4] , erase q = 3 , split into => range[1..2] & range[4..4]     \\n            \\n            if(pos->first<=q-1) {\\n                 range.insert({pos->first,q-1});   // left split\\n                 ms.insert(Left);\\n            }\\n            if(pos->second>=q+1) {\\n                 range.insert({q+1,pos->second});   // rightsplit\\n                 ms.insert(Right);\\n            }\\n            \\n            ms.erase(ms.find(cur));  // erase the sum of range \\n            \\n            range.erase(pos);  // erase the range\\n         \\n            ans.push_back(*ms.rbegin());   // maximum range sum\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456230,
                "title": "python-easy-solution-o-n",
                "content": "segments[q] contains two informations curv and cur_len which is the value of the interval that contains q and length of the interval, respectively.\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        segments = defaultdict(lambda:(0,0))\\n        cur_max = 0\\n        res = []\\n        for q in reversed(removeQueries):\\n            lv, left_len = segments[q-1]\\n            rv, right_len = segments[q+1]\\n            curv, cur_len = lv+rv+nums[q], left_len+right_len+1 \\n            segments[q-left_len] = (curv, cur_len)\\n            segments[q+right_len] = (curv, cur_len)\\n            cur_max = max(cur_max, curv)\\n            res.append(cur_max)\\n        res.pop()\\n        res.reverse()\\n        res.append(0)\\n        return res",
                "solutionTags": [
                    "Python"
                ],
                "code": "segments[q] contains two informations curv and cur_len which is the value of the interval that contains q and length of the interval, respectively.\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        segments = defaultdict(lambda:(0,0))\\n        cur_max = 0\\n        res = []\\n        for q in reversed(removeQueries):\\n            lv, left_len = segments[q-1]\\n            rv, right_len = segments[q+1]\\n            curv, cur_len = lv+rv+nums[q], left_len+right_len+1 \\n            segments[q-left_len] = (curv, cur_len)\\n            segments[q+right_len] = (curv, cur_len)\\n            cur_max = max(cur_max, curv)\\n            res.append(cur_max)\\n        res.pop()\\n        res.reverse()\\n        res.append(0)\\n        return res",
                "codeTag": "Java"
            },
            {
                "id": 2456219,
                "title": "typescript-solution-bst-and-pq",
                "content": "class LinkedList {\\n      constructor(\\n        public key = 0,\\n        public color = \"B\",\\n        public left: LinkedList | null = null,\\n        public right: LinkedList | null = null,\\n        public p: LinkedList | null = null\\n      ) {}\\n    }\\n\\n    class BST {\\n      private root: LinkedList | null;\\n      constructor() {\\n        this.root = null;\\n      }\\n\\n      private rotateLeft = function (x: LinkedList) {\\n        let y = x.right!;\\n        y.p = x.p;\\n\\n        if (x.p === null) this.root = y;\\n        else if (x.p.left === x) x.p.left = y;\\n        else x.p.right = y;\\n\\n        x.right = y.left;\\n        if (x.right !== null) x.right.p = x;\\n\\n        y.left = x;\\n        x.p = y;\\n      };\\n      private rotateRight = function (y: LinkedList) {\\n        let x = y.left!;\\n        x.p = y.p;\\n\\n        if (y.p === null) this.root = x;\\n        else if (y.p.left === y) y.p.left = x;\\n        else y.p.right = x;\\n\\n        y.left = x.right;\\n        if (y.left !== null) y.left.p = y;\\n\\n        x.right = y;\\n        y.p = x;\\n      };\\n      private insertFixUp = function (x: LinkedList | null) {\\n        while (x && x.p !== null && x.p.color === \"R\" && x.p.p) {\\n          if (x.p === x.p.p.left) {\\n            let y = x.p.p.right;\\n            if (y !== null && y.color === \"R\") {\\n              x.p.color = \"B\";\\n              y.color = \"B\";\\n              x.p.p.color = \"R\";\\n              x = x.p.p;\\n            } else {\\n              if (x === x.p.right) {\\n                x = x.p;\\n                this.rotateLeft(x);\\n              }\\n\\n              x.p!.color = \"B\";\\n              x.p!.p.color = \"R\";\\n              this.rotateRight(x.p!.p);\\n            }\\n          } else {\\n            let y = x.p.p.left;\\n            if (y !== null && y.color === \"R\") {\\n              x.p.color = \"B\";\\n              y.color = \"B\";\\n              x.p.p.color = \"R\";\\n              x = x.p.p;\\n            } else {\\n              if (x === x.p.left) {\\n                x = x.p;\\n                this.rotateRight(x);\\n              }\\n\\n              x.p!.color = \"B\";\\n              x.p!.p.color = \"R\";\\n              this.rotateLeft(x.p!.p);\\n            }\\n          }\\n        }\\n        this.root.color = \"B\";\\n      };\\n      insertNode = function (key: number) : number {\\n        let t: LinkedList | null = this.root;\\n        let y = t;\\n        let node = new LinkedList(key, \"R\");\\n        let min = -1;\\n        while (t !== null) {\\n          y = t;\\n          if (key < t.key) t = t.left;\\n          else {\\n            min = t.key;\\n            t = t.right;\\n          }\\n        }\\n\\n        if (y === null) this.root = y = node;\\n        else {\\n          t = node;\\n          if (key < y.key) {\\n            y.left = t;\\n          } else y.right = t;\\n          t.p = y;\\n        }\\n\\n        this.insertFixUp(node);\\n        return min;\\n      };\\n    }\\n\\n    class PriorityQueue {\\n        private pQueue : {sum: number, lowerRangeIndex: number}[];\\n        private lowerRngIndexPair: Map<number, number>;\\n        private heapSize : number;\\n        constructor() {\\n            this.pQueue = [];\\n            this.heapSize = 0;    \\n            this.lowerRngIndexPair = new Map<number, number>();\\n        }\\n        heapMax = function () : number {\\n            return (this.pQueue[0] as {sum: number, lowerRangeIndex: number}).sum;\\n        }\\n        pop = function (lwrRngIndex: number) : number {\\n            let hpIdx = (this.lowerRngIndexPair as Map<number, number>).get(lwrRngIndex)!;\\n            let max = (this.pQueue[hpIdx] as {sum: number, lowerRangeIndex: number}).sum;\\n            this.swapElements(hpIdx, this.heapSize - 1);\\n            (this.lowerRngIndexPair as Map<number, number>).delete(lwrRngIndex);\\n            this.heapSize--;\\n            \\n            let i = hpIdx;\\n            let parent = Math.ceil(i / 2) - 1;\\n            if (parent >= 0 && i > 0 && this.pQueue[i].sum >= this.pQueue[parent].sum) {\\n              while (parent >= 0) {\\n                if (this.pQueue[i].sum > this.pQueue[parent].sum) {\\n                  this.swapElements(i, parent);\\n                  i = parent;\\n                  parent = Math.ceil(i / 2) - 1;\\n                } else break;\\n              }\\n            }\\n            else this.maxHeap(hpIdx);\\n            return max;\\n\\n        }\\n        insert = function (sum : number, lowerRangeIndex: number) {\\n            this.heapSize++;\\n            this.pQueue[this.heapSize - 1] = { sum: sum, lowerRangeIndex: lowerRangeIndex };\\n            (this.lowerRngIndexPair as Map<number, number>).set(lowerRangeIndex, this.heapSize - 1);\\n            if (this.heapSize === 1)\\n                return;\\n\\n            let i = this.heapSize - 1;\\n            let parent = Math.ceil(i / 2) - 1;\\n\\n            while (parent >= 0) {\\n                if (this.pQueue[i].sum > this.pQueue[parent].sum) {\\n                    this.swapElements(i, parent);\\n                    i = parent;\\n                    parent = Math.ceil(i / 2) - 1;\\n                }\\n                else\\n                    break;\\n            }\\n        }\\n        private swapElements(i : number, j : number) {\\n            let temp = this.pQueue[i];\\n            this.pQueue[i] = this.pQueue[j];\\n            this.lowerRngIndexPair.set(this.pQueue[i].lowerRangeIndex, i);\\n            this.pQueue[j] = temp;\\n            this.lowerRngIndexPair.set(this.pQueue[j].lowerRangeIndex, j);\\n        }\\n        private maxHeap(i: number) {\\n            let leftChildIndex = 2 * i + 1;\\n            if (leftChildIndex >= this.heapSize)\\n                return;\\n    \\n            let rightChildIndex = leftChildIndex + 1;\\n            if (rightChildIndex >= this.heapSize) {\\n                if (this.pQueue[i].sum < this.pQueue[leftChildIndex].sum)\\n                    this.swapElements(i, leftChildIndex);\\n            }\\n            else if (this.pQueue[i].sum < this.pQueue[leftChildIndex].sum || this.pQueue[i].sum < this.pQueue[rightChildIndex].sum) {\\n                if (this.pQueue[leftChildIndex].sum <= this.pQueue[rightChildIndex].sum) {\\n                    this.swapElements(i, rightChildIndex);\\n                    this.maxHeap(rightChildIndex);\\n                }\\n                else if (this.pQueue[rightChildIndex].sum < this.pQueue[leftChildIndex].sum) {\\n                    this.swapElements(i, leftChildIndex);\\n                    this.maxHeap(leftChildIndex);\\n                }\\n            }\\n        }\\n    }\\n    \\n    function maximumSegmentSum(nums: number[], removeQueries: number[]): number[] {\\n\\n     if(nums.length === 1) return [0];\\n      const sumNums : number[] = [nums[0]];\\n      const maxSegSum : number[] = [];\\n      for(let i = 1; i< nums.length; i++) {\\n        sumNums[i] = sumNums[i - 1] + nums[i];\\n      }\\n\\n      const calcRangeSum = (l1:number, l2:number) : number => {\\n        let res = sumNums[l2];\\n        res -= ((l1 === 0) ? 0 : sumNums[l1 - 1]);\\n        return res;\\n      }\\n\\n      const tree = new BST();\\n      const pq = new PriorityQueue();\\n      {\\n        let upperRIndx = removeQueries[0];\\n        let lowerRIndx = tree.insertNode(upperRIndx);\\n        if(upperRIndx !== 0) {\\n          let rSum = calcRangeSum(lowerRIndx + 1, upperRIndx - 1);\\n          pq.insert(rSum, lowerRIndx);\\n        }\\n        if(upperRIndx != nums.length - 1) {\\n          let rSum = calcRangeSum(upperRIndx + 1, nums.length - 1);\\n          pq.insert(rSum, upperRIndx);\\n        }\\n        maxSegSum.push(pq.heapMax());\\n      }\\n      for (let i = 1; i < removeQueries.length - 1; i++) {\\n        let upperRIndx = removeQueries[i];\\n        let lowerRIndx = tree.insertNode(upperRIndx);\\n        let totalSum = pq.pop(lowerRIndx);\\n        let lSum = (lowerRIndx < upperRIndx - 1) ? calcRangeSum(lowerRIndx + 1, upperRIndx - 1) : 0;\\n        let rSum = totalSum - lSum - nums[removeQueries[i]];\\n        if (lSum) pq.insert(lSum, lowerRIndx);\\n        if (rSum) pq.insert(rSum, upperRIndx);\\n        maxSegSum.push(pq.heapMax());\\n      }\\n      maxSegSum.push(0);\\n      return maxSegSum;\\n    };",
                "solutionTags": [
                    "Binary Search Tree",
                    "Heap (Priority Queue)"
                ],
                "code": "class LinkedList {\\n      constructor(\\n        public key = 0,\\n        public color = \"B\",\\n        public left: LinkedList | null = null,\\n        public right: LinkedList | null = null,\\n        public p: LinkedList | null = null\\n      ) {}\\n    }\\n\\n    class BST {\\n      private root: LinkedList | null;\\n      constructor() {\\n        this.root = null;\\n      }\\n\\n      private rotateLeft = function (x: LinkedList) {\\n        let y = x.right!;\\n        y.p = x.p;\\n\\n        if (x.p === null) this.root = y;\\n        else if (x.p.left === x) x.p.left = y;\\n        else x.p.right = y;\\n\\n        x.right = y.left;\\n        if (x.right !== null) x.right.p = x;\\n\\n        y.left = x;\\n        x.p = y;\\n      };\\n      private rotateRight = function (y: LinkedList) {\\n        let x = y.left!;\\n        x.p = y.p;\\n\\n        if (y.p === null) this.root = x;\\n        else if (y.p.left === y) y.p.left = x;\\n        else y.p.right = x;\\n\\n        y.left = x.right;\\n        if (y.left !== null) y.left.p = y;\\n\\n        x.right = y;\\n        y.p = x;\\n      };\\n      private insertFixUp = function (x: LinkedList | null) {\\n        while (x && x.p !== null && x.p.color === \"R\" && x.p.p) {\\n          if (x.p === x.p.p.left) {\\n            let y = x.p.p.right;\\n            if (y !== null && y.color === \"R\") {\\n              x.p.color = \"B\";\\n              y.color = \"B\";\\n              x.p.p.color = \"R\";\\n              x = x.p.p;\\n            } else {\\n              if (x === x.p.right) {\\n                x = x.p;\\n                this.rotateLeft(x);\\n              }\\n\\n              x.p!.color = \"B\";\\n              x.p!.p.color = \"R\";\\n              this.rotateRight(x.p!.p);\\n            }\\n          } else {\\n            let y = x.p.p.left;\\n            if (y !== null && y.color === \"R\") {\\n              x.p.color = \"B\";\\n              y.color = \"B\";\\n              x.p.p.color = \"R\";\\n              x = x.p.p;\\n            } else {\\n              if (x === x.p.left) {\\n                x = x.p;\\n                this.rotateRight(x);\\n              }\\n\\n              x.p!.color = \"B\";\\n              x.p!.p.color = \"R\";\\n              this.rotateLeft(x.p!.p);\\n            }\\n          }\\n        }\\n        this.root.color = \"B\";\\n      };\\n      insertNode = function (key: number) : number {\\n        let t: LinkedList | null = this.root;\\n        let y = t;\\n        let node = new LinkedList(key, \"R\");\\n        let min = -1;\\n        while (t !== null) {\\n          y = t;\\n          if (key < t.key) t = t.left;\\n          else {\\n            min = t.key;\\n            t = t.right;\\n          }\\n        }\\n\\n        if (y === null) this.root = y = node;\\n        else {\\n          t = node;\\n          if (key < y.key) {\\n            y.left = t;\\n          } else y.right = t;\\n          t.p = y;\\n        }\\n\\n        this.insertFixUp(node);\\n        return min;\\n      };\\n    }\\n\\n    class PriorityQueue {\\n        private pQueue : {sum: number, lowerRangeIndex: number}[];\\n        private lowerRngIndexPair: Map<number, number>;\\n        private heapSize : number;\\n        constructor() {\\n            this.pQueue = [];\\n            this.heapSize = 0;    \\n            this.lowerRngIndexPair = new Map<number, number>();\\n        }\\n        heapMax = function () : number {\\n            return (this.pQueue[0] as {sum: number, lowerRangeIndex: number}).sum;\\n        }\\n        pop = function (lwrRngIndex: number) : number {\\n            let hpIdx = (this.lowerRngIndexPair as Map<number, number>).get(lwrRngIndex)!;\\n            let max = (this.pQueue[hpIdx] as {sum: number, lowerRangeIndex: number}).sum;\\n            this.swapElements(hpIdx, this.heapSize - 1);\\n            (this.lowerRngIndexPair as Map<number, number>).delete(lwrRngIndex);\\n            this.heapSize--;\\n            \\n            let i = hpIdx;\\n            let parent = Math.ceil(i / 2) - 1;\\n            if (parent >= 0 && i > 0 && this.pQueue[i].sum >= this.pQueue[parent].sum) {\\n              while (parent >= 0) {\\n                if (this.pQueue[i].sum > this.pQueue[parent].sum) {\\n                  this.swapElements(i, parent);\\n                  i = parent;\\n                  parent = Math.ceil(i / 2) - 1;\\n                } else break;\\n              }\\n            }\\n            else this.maxHeap(hpIdx);\\n            return max;\\n\\n        }\\n        insert = function (sum : number, lowerRangeIndex: number) {\\n            this.heapSize++;\\n            this.pQueue[this.heapSize - 1] = { sum: sum, lowerRangeIndex: lowerRangeIndex };\\n            (this.lowerRngIndexPair as Map<number, number>).set(lowerRangeIndex, this.heapSize - 1);\\n            if (this.heapSize === 1)\\n                return;\\n\\n            let i = this.heapSize - 1;\\n            let parent = Math.ceil(i / 2) - 1;\\n\\n            while (parent >= 0) {\\n                if (this.pQueue[i].sum > this.pQueue[parent].sum) {\\n                    this.swapElements(i, parent);\\n                    i = parent;\\n                    parent = Math.ceil(i / 2) - 1;\\n                }\\n                else\\n                    break;\\n            }\\n        }\\n        private swapElements(i : number, j : number) {\\n            let temp = this.pQueue[i];\\n            this.pQueue[i] = this.pQueue[j];\\n            this.lowerRngIndexPair.set(this.pQueue[i].lowerRangeIndex, i);\\n            this.pQueue[j] = temp;\\n            this.lowerRngIndexPair.set(this.pQueue[j].lowerRangeIndex, j);\\n        }\\n        private maxHeap(i: number) {\\n            let leftChildIndex = 2 * i + 1;\\n            if (leftChildIndex >= this.heapSize)\\n                return;\\n    \\n            let rightChildIndex = leftChildIndex + 1;\\n            if (rightChildIndex >= this.heapSize) {\\n                if (this.pQueue[i].sum < this.pQueue[leftChildIndex].sum)\\n                    this.swapElements(i, leftChildIndex);\\n            }\\n            else if (this.pQueue[i].sum < this.pQueue[leftChildIndex].sum || this.pQueue[i].sum < this.pQueue[rightChildIndex].sum) {\\n                if (this.pQueue[leftChildIndex].sum <= this.pQueue[rightChildIndex].sum) {\\n                    this.swapElements(i, rightChildIndex);\\n                    this.maxHeap(rightChildIndex);\\n                }\\n                else if (this.pQueue[rightChildIndex].sum < this.pQueue[leftChildIndex].sum) {\\n                    this.swapElements(i, leftChildIndex);\\n                    this.maxHeap(leftChildIndex);\\n                }\\n            }\\n        }\\n    }\\n    \\n    function maximumSegmentSum(nums: number[], removeQueries: number[]): number[] {\\n\\n     if(nums.length === 1) return [0];\\n      const sumNums : number[] = [nums[0]];\\n      const maxSegSum : number[] = [];\\n      for(let i = 1; i< nums.length; i++) {\\n        sumNums[i] = sumNums[i - 1] + nums[i];\\n      }\\n\\n      const calcRangeSum = (l1:number, l2:number) : number => {\\n        let res = sumNums[l2];\\n        res -= ((l1 === 0) ? 0 : sumNums[l1 - 1]);\\n        return res;\\n      }\\n\\n      const tree = new BST();\\n      const pq = new PriorityQueue();\\n      {\\n        let upperRIndx = removeQueries[0];\\n        let lowerRIndx = tree.insertNode(upperRIndx);\\n        if(upperRIndx !== 0) {\\n          let rSum = calcRangeSum(lowerRIndx + 1, upperRIndx - 1);\\n          pq.insert(rSum, lowerRIndx);\\n        }\\n        if(upperRIndx != nums.length - 1) {\\n          let rSum = calcRangeSum(upperRIndx + 1, nums.length - 1);\\n          pq.insert(rSum, upperRIndx);\\n        }\\n        maxSegSum.push(pq.heapMax());\\n      }\\n      for (let i = 1; i < removeQueries.length - 1; i++) {\\n        let upperRIndx = removeQueries[i];\\n        let lowerRIndx = tree.insertNode(upperRIndx);\\n        let totalSum = pq.pop(lowerRIndx);\\n        let lSum = (lowerRIndx < upperRIndx - 1) ? calcRangeSum(lowerRIndx + 1, upperRIndx - 1) : 0;\\n        let rSum = totalSum - lSum - nums[removeQueries[i]];\\n        if (lSum) pq.insert(lSum, lowerRIndx);\\n        if (rSum) pq.insert(rSum, upperRIndx);\\n        maxSegSum.push(pq.heapMax());\\n      }\\n      maxSegSum.push(0);\\n      return maxSegSum;\\n    };",
                "codeTag": "Java"
            },
            {
                "id": 2455931,
                "title": "c-reverse-seg-merge-100",
                "content": "Inspired by https://leetcode.com/problems/maximum-segment-sum-after-removals/discuss/2454208/Reverse-Union-Find\\n**Time O(n) space O(n)**\\nOne more improvement is we actually don\\u2019t need union find. \\nFor calculate a rang sum , use prefix sum array. \\nFor handle segment merge use the start and end point of the range to store length of a segment, this would  and make everything **strictly O(n)**\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<long long> prefix;\\n    vector<long long> ans;\\n    vector<int> segs;\\n    long long getsum(int l, int r) {\\n        if (l > r) return 0;\\n        return prefix[r + 1] - prefix[l];\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq) {\\n        n = nums.size();\\n        ans = vector<long long>(n);\\n        prefix = vector<long long>(n + 1, 0);\\n        segs = vector<int>(n, 0);\\n        for (int i = 0; i < n; i++) prefix[i + 1] = (long long)(nums[i]) + prefix[i];\\n        long long pre = 0;\\n        ans[n -1] = 0;\\n        for (int i = n -1; i>= 1; i--) {\\n            int q = rq[i];\\n            int cur = 1;\\n            int lr = q - 1;\\n            int ll = lr >= 0 ? lr - segs[lr] + 1 : lr + 1;\\n            long long ls = getsum(ll, lr);\\n            \\n            int rl = q + 1;\\n            int rr = rl < n ? rl + segs[rl] - 1 : rl - 1;\\n            long long rs = getsum(rl, rr);\\n            ans[i - 1] = max(pre, ls + rs + nums[q]);\\n            pre = ans[i - 1];\\n            \\n            int a = (ll <= lr) ? ll : q;\\n            int b = (rl <= rr) ? rr : q;\\n            int l = b - a + 1;\\n            segs[a] = l;\\n            segs[b] = l;\\n        }\\n        return ans;\\n    }\\n};\\n```\\n\\nOption 2, use multiset , forward simulation O(nlog(n))\\n\\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<long long> prefix;\\n    vector<long long> ans;\\n    multiset<long long> mp;\\n    set<int> seg;\\n    long long getsum(int l, int r) {\\n        if (l > r) return 0;\\n        return prefix[r + 1] - prefix[l];\\n    }\\n    // sum by seg\\n    long long getsum1(int l, int r) {\\n        return getsum(l + 1, r -1);\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq) {\\n        n = nums.size();\\n        prefix = vector<long long>(n + 1, 0);\\n        for (int i = 0; i < n; i++) prefix[i + 1] = (long long)(nums[i]) + prefix[i];\\n        mp.insert(prefix[n]);\\n        seg.insert(n);\\n        seg.insert(-1);\\n        for (auto& q : rq) {\\n            auto r = seg.upper_bound(q);\\n            int b = *r;\\n            r--;\\n            int a = *r;\\n            //cout << q << \",\" << a << \",\" << b << endl;\\n            long long s = getsum1(a, b);\\n            auto iter = mp.find(s);\\n            mp.erase(iter);\\n            \\n            long long ls = getsum1(a, q);\\n            long long rs = getsum1(q, b);\\n            if (ls > 0) mp.insert(ls);\\n            if (rs > 0) mp.insert(rs);\\n            long long cur = mp.empty() ? 0 : *mp.rbegin();\\n            //cout << q << \",\" << ls << \",\" << rs << \",\" << cur << endl;\\n            ans.push_back(cur);\\n            seg.insert(q);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<long long> prefix;\\n    vector<long long> ans;\\n    vector<int> segs;\\n    long long getsum(int l, int r) {\\n        if (l > r) return 0;\\n        return prefix[r + 1] - prefix[l];\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq) {\\n        n = nums.size();\\n        ans = vector<long long>(n);\\n        prefix = vector<long long>(n + 1, 0);\\n        segs = vector<int>(n, 0);\\n        for (int i = 0; i < n; i++) prefix[i + 1] = (long long)(nums[i]) + prefix[i];\\n        long long pre = 0;\\n        ans[n -1] = 0;\\n        for (int i = n -1; i>= 1; i--) {\\n            int q = rq[i];\\n            int cur = 1;\\n            int lr = q - 1;\\n            int ll = lr >= 0 ? lr - segs[lr] + 1 : lr + 1;\\n            long long ls = getsum(ll, lr);\\n            \\n            int rl = q + 1;\\n            int rr = rl < n ? rl + segs[rl] - 1 : rl - 1;\\n            long long rs = getsum(rl, rr);\\n            ans[i - 1] = max(pre, ls + rs + nums[q]);\\n            pre = ans[i - 1];\\n            \\n            int a = (ll <= lr) ? ll : q;\\n            int b = (rl <= rr) ? rr : q;\\n            int l = b - a + 1;\\n            segs[a] = l;\\n            segs[b] = l;\\n        }\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int n;\\n    vector<long long> prefix;\\n    vector<long long> ans;\\n    multiset<long long> mp;\\n    set<int> seg;\\n    long long getsum(int l, int r) {\\n        if (l > r) return 0;\\n        return prefix[r + 1] - prefix[l];\\n    }\\n    // sum by seg\\n    long long getsum1(int l, int r) {\\n        return getsum(l + 1, r -1);\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& rq) {\\n        n = nums.size();\\n        prefix = vector<long long>(n + 1, 0);\\n        for (int i = 0; i < n; i++) prefix[i + 1] = (long long)(nums[i]) + prefix[i];\\n        mp.insert(prefix[n]);\\n        seg.insert(n);\\n        seg.insert(-1);\\n        for (auto& q : rq) {\\n            auto r = seg.upper_bound(q);\\n            int b = *r;\\n            r--;\\n            int a = *r;\\n            //cout << q << \",\" << a << \",\" << b << endl;\\n            long long s = getsum1(a, b);\\n            auto iter = mp.find(s);\\n            mp.erase(iter);\\n            \\n            long long ls = getsum1(a, q);\\n            long long rs = getsum1(q, b);\\n            if (ls > 0) mp.insert(ls);\\n            if (rs > 0) mp.insert(rs);\\n            long long cur = mp.empty() ? 0 : *mp.rbegin();\\n            //cout << q << \",\" << ls << \",\" << rs << \",\" << cur << endl;\\n            ans.push_back(cur);\\n            seg.insert(q);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2455910,
                "title": "o-nlogn-merging-intervals-and-sum-values-using-hash-map-example-illustration",
                "content": "**Main Idea**:\\n+ The problem changes to **find maximum segment sum** after **inserting elements** with positions **from last to begin** of removeQueries.\\n+ Data structure for intervals **(ai, bi)** where **hs[ai]=bi**, **he[bi]=ai**, with sum values **s[(ai, bi)]** and sorted set **seg[(si, (ai, bi))]**\\n\\n**Examples**:\\n```\\n[1, 2, 5, 6, 1] [0, 3, 2, 4, 1]\\n+ 1 sums: [2] - s: [(2, (1, 1))] - hs: {1: 1} - he: {1: 1} - ans: [0, 2]\\n+ 4 sums: [2, 1] - s: [(1, (4, 4)), (2, (1, 1))] - hs: {1: 1, 4: 4} - he: {1: 1, 4: 4} - ans: [0, 2, 2]\\n+ 2 sums: [1, 7] - s: [(1, (4, 4)), (7, (1, 2))] - hs: {1: 2, 4: 4} - he: {4: 4, 2: 1} - ans: [0, 2, 2, 7]\\n+ 3 sums: [14] - s: [(14, (1, 4))] - hs: {1: 4} - he: {4: 1} - ans: [0, 2, 2, 7, 14]\\nans: [14, 7, 2, 2, 0]\\n====================\\n\\n[3, 2, 11, 1] [3, 2, 1, 0]\\n+ 0 sums: [3] - s: [(3, (0, 0))] - hs: {0: 0} - he: {0: 0} - ans: [0, 3]\\n+ 1 sums: [5] - s: [(5, (0, 1))] - hs: {0: 1} - he: {1: 0} - ans: [0, 3, 5]\\n+ 2 sums: [16] - s: [(16, (0, 2))] - hs: {0: 2} - he: {2: 0} - ans: [0, 3, 5, 16]\\nans: [16, 5, 3, 0]\\n====================\\n```\\n**Code**:\\n```\\nfrom sortedcontainers import SortedSet\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        seg = SortedSet([])\\n        hs = {}\\n        he = {}\\n        s = {}\\n        ans = [0]\\n        cnt = 0\\n        removeQueries = removeQueries[::-1][:-1]\\n        for pi in removeQueries:\\n            ai, bi, si = pi, pi, nums[pi]\\n            if hs.get(bi+1) is not None:\\n                ki = (bi+1, hs[bi+1])\\n                ti = s[ki]\\n                seg.discard((ti, ki)); s.pop(ki)\\n                bi = hs.pop(bi+1)\\n                si += ti\\n            if he.get(ai-1) is not None:\\n                ki = (he[ai-1], ai-1)\\n                ti = s[ki]\\n                seg.discard((ti, ki)); s.pop(ki)\\n                ai = he.pop(ai-1)\\n                si += ti\\n            hs[ai], he[bi] = bi, ai\\n            s[(ai, bi)] = si\\n            seg.add((si, (ai, bi)))\\n            ans.append(seg[-1][0])\\n            print(\"+\", pi, \"sums:\", list(s.values()), \"- s:\", list(seg), \"- hs:\", hs, \"- he:\", he, \"- ans:\", ans)\\n        \\n        ans = ans[::-1]\\n        print(\"ans:\", ans)\\n        print(\"=\"*20)\\n        return ans\\n    \\nprint = lambda *a,**aa: ()\\n```",
                "solutionTags": [],
                "code": "```\\n[1, 2, 5, 6, 1] [0, 3, 2, 4, 1]\\n+ 1 sums: [2] - s: [(2, (1, 1))] - hs: {1: 1} - he: {1: 1} - ans: [0, 2]\\n+ 4 sums: [2, 1] - s: [(1, (4, 4)), (2, (1, 1))] - hs: {1: 1, 4: 4} - he: {1: 1, 4: 4} - ans: [0, 2, 2]\\n+ 2 sums: [1, 7] - s: [(1, (4, 4)), (7, (1, 2))] - hs: {1: 2, 4: 4} - he: {4: 4, 2: 1} - ans: [0, 2, 2, 7]\\n+ 3 sums: [14] - s: [(14, (1, 4))] - hs: {1: 4} - he: {4: 1} - ans: [0, 2, 2, 7, 14]\\nans: [14, 7, 2, 2, 0]\\n====================\\n\\n[3, 2, 11, 1] [3, 2, 1, 0]\\n+ 0 sums: [3] - s: [(3, (0, 0))] - hs: {0: 0} - he: {0: 0} - ans: [0, 3]\\n+ 1 sums: [5] - s: [(5, (0, 1))] - hs: {0: 1} - he: {1: 0} - ans: [0, 3, 5]\\n+ 2 sums: [16] - s: [(16, (0, 2))] - hs: {0: 2} - he: {2: 0} - ans: [0, 3, 5, 16]\\nans: [16, 5, 3, 0]\\n====================\\n```\n```\\nfrom sortedcontainers import SortedSet\\nclass Solution:\\n    def maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n        seg = SortedSet([])\\n        hs = {}\\n        he = {}\\n        s = {}\\n        ans = [0]\\n        cnt = 0\\n        removeQueries = removeQueries[::-1][:-1]\\n        for pi in removeQueries:\\n            ai, bi, si = pi, pi, nums[pi]\\n            if hs.get(bi+1) is not None:\\n                ki = (bi+1, hs[bi+1])\\n                ti = s[ki]\\n                seg.discard((ti, ki)); s.pop(ki)\\n                bi = hs.pop(bi+1)\\n                si += ti\\n            if he.get(ai-1) is not None:\\n                ki = (he[ai-1], ai-1)\\n                ti = s[ki]\\n                seg.discard((ti, ki)); s.pop(ki)\\n                ai = he.pop(ai-1)\\n                si += ti\\n            hs[ai], he[bi] = bi, ai\\n            s[(ai, bi)] = si\\n            seg.add((si, (ai, bi)))\\n            ans.append(seg[-1][0])\\n            print(\"+\", pi, \"sums:\", list(s.values()), \"- s:\", list(seg), \"- hs:\", hs, \"- he:\", he, \"- ans:\", ans)\\n        \\n        ans = ans[::-1]\\n        print(\"ans:\", ans)\\n        print(\"=\"*20)\\n        return ans\\n    \\nprint = lambda *a,**aa: ()\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455907,
                "title": "log-n-update-query-sum-segment-tree",
                "content": "```\\n vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {     \\n      int n=nums.size();\\n      long long maxi=-1;\\n      int a[n];\\n      for(int i=0;i<n;i++){\\n        a[i]=nums[i];\\n         if(maxi<nums[i])\\n            maxi=nums[i];\\n      }\\n      build(a, 0, n - 1, 0);\\n      \\n       vector<long long> ans;\\n      \\n      for(int i=0;i<n;i++){\\n        \\n        \\tint index = removeQueries[i];\\n\\t        long long value = -((n/2)*maxi);\\n\\t        a[index] = value;\\n        \\tupdate(a, 0, 0, n - 1, index, value);\\n           long long res=1ll*(query(a, 0, 0, n - 1, 0 , n- 1).maxsum);\\n            if(res<=0)res=0;\\n          ans.push_back(res); \\n  }\\n    \\n     return ans;\\n      \\n    }\\n\\n  \\n  \\n  \\n  \\nstruct node {\\n  long long  sum, prefixsum, suffixsum, maxsum;\\n};\\n\\n\\nnode tree[4 * 100005];\\n\\nvoid build(int arr[], int low, int high, int index)\\n{\\n\\tif (low == high) {\\n\\t\\ttree[index].sum = arr[low];\\n\\t\\ttree[index].prefixsum = arr[low];\\n\\t\\ttree[index].suffixsum = arr[low];\\n\\t\\ttree[index].maxsum = arr[low];\\n\\t}\\n\\telse {\\n\\t\\tint mid = (low + high) / 2;\\n\\n\\t\\tbuild(arr, low, mid, 2 * index + 1);\\n\\t\\t\\n\\n\\t\\tbuild(arr, mid + 1, high, 2 * index + 2);\\n\\n\\n\\t\\ttree[index].sum = tree[2 * index + 1].sum +\\n\\t\\t\\t\\t\\t\\ttree[2 * index + 2].sum;\\n\\n\\t\\n\\t\\ttree[index].prefixsum =\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 1].prefixsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 1].sum +\\n\\t\\t\\t\\t\\ttree[2 * index + 2].prefixsum);\\n\\n\\t\\t\\n\\t\\ttree[index].suffixsum =\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 2].suffixsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 2].sum +\\n\\t\\t\\t\\t\\ttree[2 * index + 1].suffixsum);\\n\\n\\n\\t\\ttree[index].maxsum =\\n\\t\\t\\t\\t\\tmax(tree[index].prefixsum,\\n\\t\\t\\t\\t\\tmax(tree[index].suffixsum,\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 1].maxsum,\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 2].maxsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 1].suffixsum +\\n\\t\\t\\t\\t\\ttree[2 * index + 2].prefixsum))));\\n\\t}\\n}\\n\\n\\nvoid update(int arr[], int index, int low, int high,\\n\\t\\t\\tint idx, long long value)\\n{\\n\\n\\tif (low == high) {\\n\\t\\ttree[index].sum = value;\\n\\t\\ttree[index].prefixsum = value;\\n\\t\\ttree[index].suffixsum = value;\\n\\t\\ttree[index].maxsum = value;\\n\\t}\\n\\telse {\\n\\n\\t\\tint mid = (low + high) / 2;\\n\\n\\t\\tif (idx <= mid)\\n\\t\\t\\tupdate(arr, 2 * index + 1, low, mid, idx, value);\\n\\t\\t\\n\\n\\t\\telse\\n\\t\\t\\tupdate(arr, 2 * index + 2, mid + 1,\\n\\t\\t\\t\\thigh, idx, value);\\n\\n\\n\\t\\ttree[index].sum = tree[2 * index + 1].sum +\\n\\t\\t\\t\\t\\t\\ttree[2 * index + 2].sum;\\n\\n\\t\\n\\t\\ttree[index].prefixsum =\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 1].prefixsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 1].sum +\\n\\t\\t\\t\\t\\ttree[2 * index + 2].prefixsum);\\n\\n\\t\\ttree[index].suffixsum =\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 2].suffixsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 2].sum +\\n\\t\\t\\t\\t\\ttree[2 * index + 1].suffixsum);\\n\\n\\t\\n\\t\\ttree[index].maxsum =\\n\\t\\t\\t\\t\\tmax(tree[index].prefixsum,\\n\\t\\t\\t\\t\\tmax(tree[index].suffixsum,\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 1].maxsum,\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 2].maxsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 1].suffixsum +\\n\\t\\t\\t\\t\\ttree[2 * index + 2].prefixsum))));\\n\\t}\\n}\\n\\n\\nnode query(int arr[], int index, int low,\\n\\t\\tint high, int l, int r)\\n{\\n\\t// initially all the values are INT_MIN\\n\\tnode result;\\n\\tresult.sum = result.prefixsum =\\n\\t\\t\\t\\tresult.suffixsum =\\n\\t\\t\\t\\tresult.maxsum = INT_MIN;\\n\\n\\n\\tif (r < low || high < l)\\n\\t\\treturn result;\\n\\n\\t// complete overlap of range\\n\\tif (l <= low && high <= r)\\n\\t\\treturn tree[index];\\n\\n\\tint mid = (low + high) / 2;\\n\\n\\n\\tif (l > mid)\\n\\t\\treturn query(arr, 2 * index + 2,\\n\\t\\t\\t\\t\\tmid + 1, high, l, r);\\n\\n\\tif (r <= mid)\\n\\t\\treturn query(arr, 2 * index + 1,\\n\\t\\t\\t\\t\\tlow, mid, l, r);\\n\\n\\tnode left = query(arr, 2 * index + 1,\\n\\t\\t\\t\\t\\tlow, mid, l, r);\\n\\tnode right = query(arr, 2 * index + 2,\\n\\t\\t\\t\\t\\t\\tmid + 1, high, l, r);\\n\\n\\n\\tresult.sum = left.sum + right.sum;\\n\\tresult.prefixsum = max(left.prefixsum, left.sum +\\n\\t\\t\\t\\t\\t\\tright.prefixsum);\\n\\t\\t\\t\\t\\t\\t\\t\\n\\tresult.suffixsum = max(right.suffixsum,\\n\\t\\t\\t\\t\\tright.sum + left.suffixsum);\\n\\tresult.maxsum = max(result.prefixsum,\\n\\t\\t\\t\\t\\tmax(result.suffixsum,\\n\\t\\t\\t\\t\\tmax(left.maxsum,\\n\\t\\t\\t\\t\\tmax(right.maxsum,\\n\\t\\t\\t\\t\\tleft.suffixsum + right.prefixsum))));\\n\\t\\t\\t\\t\\t\\n\\treturn result;\\n}\\n};\\n\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {     \\n      int n=nums.size();\\n      long long maxi=-1;\\n      int a[n];\\n      for(int i=0;i<n;i++){\\n        a[i]=nums[i];\\n         if(maxi<nums[i])\\n            maxi=nums[i];\\n      }\\n      build(a, 0, n - 1, 0);\\n      \\n       vector<long long> ans;\\n      \\n      for(int i=0;i<n;i++){\\n        \\n        \\tint index = removeQueries[i];\\n\\t        long long value = -((n/2)*maxi);\\n\\t        a[index] = value;\\n        \\tupdate(a, 0, 0, n - 1, index, value);\\n           long long res=1ll*(query(a, 0, 0, n - 1, 0 , n- 1).maxsum);\\n            if(res<=0)res=0;\\n          ans.push_back(res); \\n  }\\n    \\n     return ans;\\n      \\n    }\\n\\n  \\n  \\n  \\n  \\nstruct node {\\n  long long  sum, prefixsum, suffixsum, maxsum;\\n};\\n\\n\\nnode tree[4 * 100005];\\n\\nvoid build(int arr[], int low, int high, int index)\\n{\\n\\tif (low == high) {\\n\\t\\ttree[index].sum = arr[low];\\n\\t\\ttree[index].prefixsum = arr[low];\\n\\t\\ttree[index].suffixsum = arr[low];\\n\\t\\ttree[index].maxsum = arr[low];\\n\\t}\\n\\telse {\\n\\t\\tint mid = (low + high) / 2;\\n\\n\\t\\tbuild(arr, low, mid, 2 * index + 1);\\n\\t\\t\\n\\n\\t\\tbuild(arr, mid + 1, high, 2 * index + 2);\\n\\n\\n\\t\\ttree[index].sum = tree[2 * index + 1].sum +\\n\\t\\t\\t\\t\\t\\ttree[2 * index + 2].sum;\\n\\n\\t\\n\\t\\ttree[index].prefixsum =\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 1].prefixsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 1].sum +\\n\\t\\t\\t\\t\\ttree[2 * index + 2].prefixsum);\\n\\n\\t\\t\\n\\t\\ttree[index].suffixsum =\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 2].suffixsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 2].sum +\\n\\t\\t\\t\\t\\ttree[2 * index + 1].suffixsum);\\n\\n\\n\\t\\ttree[index].maxsum =\\n\\t\\t\\t\\t\\tmax(tree[index].prefixsum,\\n\\t\\t\\t\\t\\tmax(tree[index].suffixsum,\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 1].maxsum,\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 2].maxsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 1].suffixsum +\\n\\t\\t\\t\\t\\ttree[2 * index + 2].prefixsum))));\\n\\t}\\n}\\n\\n\\nvoid update(int arr[], int index, int low, int high,\\n\\t\\t\\tint idx, long long value)\\n{\\n\\n\\tif (low == high) {\\n\\t\\ttree[index].sum = value;\\n\\t\\ttree[index].prefixsum = value;\\n\\t\\ttree[index].suffixsum = value;\\n\\t\\ttree[index].maxsum = value;\\n\\t}\\n\\telse {\\n\\n\\t\\tint mid = (low + high) / 2;\\n\\n\\t\\tif (idx <= mid)\\n\\t\\t\\tupdate(arr, 2 * index + 1, low, mid, idx, value);\\n\\t\\t\\n\\n\\t\\telse\\n\\t\\t\\tupdate(arr, 2 * index + 2, mid + 1,\\n\\t\\t\\t\\thigh, idx, value);\\n\\n\\n\\t\\ttree[index].sum = tree[2 * index + 1].sum +\\n\\t\\t\\t\\t\\t\\ttree[2 * index + 2].sum;\\n\\n\\t\\n\\t\\ttree[index].prefixsum =\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 1].prefixsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 1].sum +\\n\\t\\t\\t\\t\\ttree[2 * index + 2].prefixsum);\\n\\n\\t\\ttree[index].suffixsum =\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 2].suffixsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 2].sum +\\n\\t\\t\\t\\t\\ttree[2 * index + 1].suffixsum);\\n\\n\\t\\n\\t\\ttree[index].maxsum =\\n\\t\\t\\t\\t\\tmax(tree[index].prefixsum,\\n\\t\\t\\t\\t\\tmax(tree[index].suffixsum,\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 1].maxsum,\\n\\t\\t\\t\\t\\tmax(tree[2 * index + 2].maxsum,\\n\\t\\t\\t\\t\\ttree[2 * index + 1].suffixsum +\\n\\t\\t\\t\\t\\ttree[2 * index + 2].prefixsum))));\\n\\t}\\n}\\n\\n\\nnode query(int arr[], int index, int low,\\n\\t\\tint high, int l, int r)\\n{\\n\\t// initially all the values are INT_MIN\\n\\tnode result;\\n\\tresult.sum = result.prefixsum =\\n\\t\\t\\t\\tresult.suffixsum =\\n\\t\\t\\t\\tresult.maxsum = INT_MIN;\\n\\n\\n\\tif (r < low || high < l)\\n\\t\\treturn result;\\n\\n\\t// complete overlap of range\\n\\tif (l <= low && high <= r)\\n\\t\\treturn tree[index];\\n\\n\\tint mid = (low + high) / 2;\\n\\n\\n\\tif (l > mid)\\n\\t\\treturn query(arr, 2 * index + 2,\\n\\t\\t\\t\\t\\tmid + 1, high, l, r);\\n\\n\\tif (r <= mid)\\n\\t\\treturn query(arr, 2 * index + 1,\\n\\t\\t\\t\\t\\tlow, mid, l, r);\\n\\n\\tnode left = query(arr, 2 * index + 1,\\n\\t\\t\\t\\t\\tlow, mid, l, r);\\n\\tnode right = query(arr, 2 * index + 2,\\n\\t\\t\\t\\t\\t\\tmid + 1, high, l, r);\\n\\n\\n\\tresult.sum = left.sum + right.sum;\\n\\tresult.prefixsum = max(left.prefixsum, left.sum +\\n\\t\\t\\t\\t\\t\\tright.prefixsum);\\n\\t\\t\\t\\t\\t\\t\\t\\n\\tresult.suffixsum = max(right.suffixsum,\\n\\t\\t\\t\\t\\tright.sum + left.suffixsum);\\n\\tresult.maxsum = max(result.prefixsum,\\n\\t\\t\\t\\t\\tmax(result.suffixsum,\\n\\t\\t\\t\\t\\tmax(left.maxsum,\\n\\t\\t\\t\\t\\tmax(right.maxsum,\\n\\t\\t\\t\\t\\tleft.suffixsum + right.prefixsum))));\\n\\t\\t\\t\\t\\t\\n\\treturn result;\\n}\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455870,
                "title": "javascript-solution-using-union-and-find",
                "content": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} removeQueries\\n * @return {number[]}\\n */\\nvar maximumSegmentSum = function(nums, removeQueries) {\\n    const res = Array(nums.length).fill(0) \\n    const ds = Array(nums.length).fill(Number.MAX_VALUE);\\n    for (let i = removeQueries.length - 1; i > 0; --i) {\\n        let j = removeQueries[i];\\n        ds[j] = -nums[j];\\n        if (j > 0 && ds[j - 1] !== Number.MAX_VALUE)\\n            merge(j, j - 1, ds);\\n        if (j < nums.length - 1 && ds[j + 1] !== Number.MAX_VALUE)\\n            merge(j, j + 1, ds);\\n        res[i - 1] = Math.max(res[i], -ds[find(j, ds)]);\\n    }\\n    return res;\\n};\\n\\nfunction find(i, ds) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds[i], ds);\\n}\\n\\nfunction merge(s1, s2, ds) {\\n    let p1 = find(s1, ds);\\n    let p2 = find(s2, ds);\\n    ds[p2] += ds[p1];\\n    ds[p1] = p2;\\n}\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Union Find"
                ],
                "code": "```\\n/**\\n * @param {number[]} nums\\n * @param {number[]} removeQueries\\n * @return {number[]}\\n */\\nvar maximumSegmentSum = function(nums, removeQueries) {\\n    const res = Array(nums.length).fill(0) \\n    const ds = Array(nums.length).fill(Number.MAX_VALUE);\\n    for (let i = removeQueries.length - 1; i > 0; --i) {\\n        let j = removeQueries[i];\\n        ds[j] = -nums[j];\\n        if (j > 0 && ds[j - 1] !== Number.MAX_VALUE)\\n            merge(j, j - 1, ds);\\n        if (j < nums.length - 1 && ds[j + 1] !== Number.MAX_VALUE)\\n            merge(j, j + 1, ds);\\n        res[i - 1] = Math.max(res[i], -ds[find(j, ds)]);\\n    }\\n    return res;\\n};\\n\\nfunction find(i, ds) {\\n    return ds[i] < 0 ? i : ds[i] = find(ds[i], ds);\\n}\\n\\nfunction merge(s1, s2, ds) {\\n    let p1 = find(s1, ds);\\n    let p2 = find(s2, ds);\\n    ds[p2] += ds[p1];\\n    ds[p1] = p2;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455785,
                "title": "c-map-multiset",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n=nums.size();\\n        multiset<long long> s;\\n        map<int,long long> m;\\n        vector<long long> dp(n);\\n        \\n        dp[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            dp[i]=dp[i-1]+nums[i];    \\n        }\\n        s.insert(dp[n-1]);\\n        \\n        m[-1]=0;\\n        m[n]=dp[n-1];\\n        vector<long long> ans(n);\\n        for(int i=0;i<n;i++){\\n            auto it=m.lower_bound(removeQueries[i]);\\n            auto it1=prev(it);\\n            \\n\\n            s.erase(s.find(dp[it->first-1]-it1->second));\\n            if(it->first-1>removeQueries[i])\\n                s.insert(dp[it->first-1]-dp[removeQueries[i]]);\\n            if(removeQueries[i]-1>it1->first)\\n                s.insert(dp[removeQueries[i]-1]-it1->second);\\n            \\n            m[removeQueries[i]]=dp[removeQueries[i]];\\n            ans[i]=(s.empty() ? 0 : *s.rbegin());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        int n=nums.size();\\n        multiset<long long> s;\\n        map<int,long long> m;\\n        vector<long long> dp(n);\\n        \\n        dp[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            dp[i]=dp[i-1]+nums[i];    \\n        }\\n        s.insert(dp[n-1]);\\n        \\n        m[-1]=0;\\n        m[n]=dp[n-1];\\n        vector<long long> ans(n);\\n        for(int i=0;i<n;i++){\\n            auto it=m.lower_bound(removeQueries[i]);\\n            auto it1=prev(it);\\n            \\n\\n            s.erase(s.find(dp[it->first-1]-it1->second));\\n            if(it->first-1>removeQueries[i])\\n                s.insert(dp[it->first-1]-dp[removeQueries[i]]);\\n            if(removeQueries[i]-1>it1->first)\\n                s.insert(dp[removeQueries[i]-1]-it1->second);\\n            \\n            m[removeQueries[i]]=dp[removeQueries[i]];\\n            ans[i]=(s.empty() ? 0 : *s.rbegin());\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455752,
                "title": "java-reverse-union-find-100-time-14-space",
                "content": "```java\\nclass Solution {\\n    \\n    class UF {\\n        int[] root;\\n        long[] sum;\\n        \\n        public UF(int n){\\n            this.root = new int[n];\\n            Arrays.fill(this.root, -1);\\n            this.sum = new long[n];\\n        }\\n        \\n        \\n        public void insert(int x, int value){\\n            if(root[x] != -1 || sum[x] != 0) return;\\n            \\n            this.root[x] = x;\\n            this.sum[x] = (long)value;\\n        }\\n        \\n        public int find(int x){\\n            while(root[x] != x){\\n                int fa = root[x];\\n                int ga = root[fa];\\n                root[x] = ga;\\n                x = fa;\\n            }\\n            \\n            return x;\\n        }\\n        \\n        public void union(int x, int y){\\n            int rx = find(x);\\n            int ry = find(y);\\n            \\n            if(x == y) return;\\n            \\n            root[rx] = ry;\\n            sum[ry] += sum[rx];\\n        }\\n        \\n        public boolean has(int x){\\n            return root[x] != -1 || sum[x] != 0;\\n        }\\n    }\\n    \\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = removeQueries.length;\\n        long[] ret = new long[n];\\n        long max = 0L;\\n        UF uf = new UF(n);\\n        for(int i = n - 1; i >= 0; i--){\\n            int u = removeQueries[i];\\n            uf.insert(u, nums[u]);\\n            for(int v = u - 1; v <= u + 1; v += 2){\\n                if(v >= 0 && v < n && uf.has(v)){\\n                    uf.union(v, u);\\n                }\\n            }\\n            \\n            ret[i] = max;\\n            int ru = uf.find(u);\\n            max = Math.max(max, uf.sum[ru]);\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\nclass Solution {\\n    \\n    class UF {\\n        int[] root;\\n        long[] sum;\\n        \\n        public UF(int n){\\n            this.root = new int[n];\\n            Arrays.fill(this.root, -1);\\n            this.sum = new long[n];\\n        }\\n        \\n        \\n        public void insert(int x, int value){\\n            if(root[x] != -1 || sum[x] != 0) return;\\n            \\n            this.root[x] = x;\\n            this.sum[x] = (long)value;\\n        }\\n        \\n        public int find(int x){\\n            while(root[x] != x){\\n                int fa = root[x];\\n                int ga = root[fa];\\n                root[x] = ga;\\n                x = fa;\\n            }\\n            \\n            return x;\\n        }\\n        \\n        public void union(int x, int y){\\n            int rx = find(x);\\n            int ry = find(y);\\n            \\n            if(x == y) return;\\n            \\n            root[rx] = ry;\\n            sum[ry] += sum[rx];\\n        }\\n        \\n        public boolean has(int x){\\n            return root[x] != -1 || sum[x] != 0;\\n        }\\n    }\\n    \\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int n = removeQueries.length;\\n        long[] ret = new long[n];\\n        long max = 0L;\\n        UF uf = new UF(n);\\n        for(int i = n - 1; i >= 0; i--){\\n            int u = removeQueries[i];\\n            uf.insert(u, nums[u]);\\n            for(int v = u - 1; v <= u + 1; v += 2){\\n                if(v >= 0 && v < n && uf.has(v)){\\n                    uf.union(v, u);\\n                }\\n            }\\n            \\n            ret[i] = max;\\n            int ru = uf.find(u);\\n            max = Math.max(max, uf.sum[ru]);\\n        }\\n        \\n        return ret;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455731,
                "title": "c-simple-simulation-o-nlogn",
                "content": "```\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries)\\n{\\n    vector<long long> ans;\\n    vector<int64_t> pref(nums.size() + 1);\\n    for (int i = 0; i < nums.size(); ++i) {\\n        pref[i + 1] = pref[i] + nums[i];\\n    }\\n    map<int, int> ranges;\\n    multiset<int64_t> max_sum = { 0 };\\n    auto add = [&](int l, int r) {\\n        if (l < r) {\\n            ranges[r] = l;\\n            max_sum.insert(pref[r] - pref[l]);\\n        }\\n    };\\n    add(0, nums.size());\\n    for (int i = 0; i < removeQueries.size(); ++i) {\\n        int j = removeQueries[i];\\n        auto [r, l] = *ranges.lower_bound(j);\\n        max_sum.erase(max_sum.find(pref[r] - pref[l]));\\n        add(l, j);\\n        add(j + 1, r);\\n        ans.push_back(*max_sum.rbegin());\\n    }\\n    return ans;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries)\\n{\\n    vector<long long> ans;\\n    vector<int64_t> pref(nums.size() + 1);\\n    for (int i = 0; i < nums.size(); ++i) {\\n        pref[i + 1] = pref[i] + nums[i];\\n    }\\n    map<int, int> ranges;\\n    multiset<int64_t> max_sum = { 0 };\\n    auto add = [&](int l, int r) {\\n        if (l < r) {\\n            ranges[r] = l;\\n            max_sum.insert(pref[r] - pref[l]);\\n        }\\n    };\\n    add(0, nums.size());\\n    for (int i = 0; i < removeQueries.size(); ++i) {\\n        int j = removeQueries[i];\\n        auto [r, l] = *ranges.lower_bound(j);\\n        max_sum.erase(max_sum.find(pref[r] - pref[l]));\\n        add(l, j);\\n        add(j + 1, r);\\n        ans.push_back(*max_sum.rbegin());\\n    }\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2455691,
                "title": "leetcode-1970-803",
                "content": "This problem is basically LeetCode [#1970](https://leetcode.com/problems/last-day-where-you-can-still-cross/) and[ #803](https://leetcode.com/problems/bricks-falling-when-hit/), in which we reverse the process and use union find.\\n\\nThe below is an implementation that uses **Union By Rank** and **Path Compression**.\\n`RunTime 35ms`\\n`Time O(N)`\\n`Space O(N)`\\n```Java\\nclass Solution { // Java\\n    int[] A;\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        A = nums;\\n        UF uf = new UF(nums.length);\\n        long[] ans = new long[removeQueries.length];\\n        for (int i = ans.length-1; i >= 0; i--){\\n            ans[i] = uf.max;\\n            int j = removeQueries[i];\\n            uf.union(j, j+1);\\n            uf.union(j, j-1);\\n        }\\n        return ans;\\n    }\\n    \\n    private class UF{\\n        int[] rank;\\n        int[] parent;\\n        long[] weight;\\n        long max = 0;\\n        \\n        UF (int n){\\n            rank = new int[n];\\n            weight = new long[n];\\n            parent = IntStream.range(0, n).toArray();\\n        }\\n        \\n        int find(int x){\\n            return x == parent[x]? x : (parent[x] = find(parent[x]));\\n        }\\n        \\n        void union(int x, int y){\\n            weight[x] = A[x];\\n            max = Math.max(A[x], max);\\n            if (y < 0 || y == rank.length){\\n                return;\\n            }\\n            x = find(x); y = find(y);\\n            if (x == y || weight[y] == 0){\\n                return;\\n            }\\n            if (rank[x] > rank[y]){\\n                parent[y] = x;\\n                weight[x] += weight[y];\\n            }else{\\n                parent[x] = y;\\n                weight[y] += weight[x];\\n                if (rank[x] == rank[y]){\\n                    rank[y]++;\\n                }\\n            }\\n            max = Math.max(max, weight[x]);\\n            max = Math.max(max, weight[y]);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Union Find"
                ],
                "code": "```Java\\nclass Solution { // Java\\n    int[] A;\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        A = nums;\\n        UF uf = new UF(nums.length);\\n        long[] ans = new long[removeQueries.length];\\n        for (int i = ans.length-1; i >= 0; i--){\\n            ans[i] = uf.max;\\n            int j = removeQueries[i];\\n            uf.union(j, j+1);\\n            uf.union(j, j-1);\\n        }\\n        return ans;\\n    }\\n    \\n    private class UF{\\n        int[] rank;\\n        int[] parent;\\n        long[] weight;\\n        long max = 0;\\n        \\n        UF (int n){\\n            rank = new int[n];\\n            weight = new long[n];\\n            parent = IntStream.range(0, n).toArray();\\n        }\\n        \\n        int find(int x){\\n            return x == parent[x]? x : (parent[x] = find(parent[x]));\\n        }\\n        \\n        void union(int x, int y){\\n            weight[x] = A[x];\\n            max = Math.max(A[x], max);\\n            if (y < 0 || y == rank.length){\\n                return;\\n            }\\n            x = find(x); y = find(y);\\n            if (x == y || weight[y] == 0){\\n                return;\\n            }\\n            if (rank[x] > rank[y]){\\n                parent[y] = x;\\n                weight[x] += weight[y];\\n            }else{\\n                parent[x] = y;\\n                weight[y] += weight[x];\\n                if (rank[x] == rank[y]){\\n                    rank[y]++;\\n                }\\n            }\\n            max = Math.max(max, weight[x]);\\n            max = Math.max(max, weight[y]);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455510,
                "title": "c-version-of-solution-by-user9591",
                "content": "Original Python solution - https://leetcode.com/problems/maximum-segment-sum-after-removals/discuss/2454397/Do-it-backwards-O(N)\\n\\n```\\npublic class Solution\\n{\\n    public long[] MaximumSegmentSum(int[] nums, int[] removeQueries)\\n    {\\n        var mp = new Dictionary<int, (long, int)>();\\n        var cur = 0L;\\n        var res = new List<long>();\\n\\n        foreach (var q in removeQueries[1..].Reverse())\\n        {\\n            mp.Add(q, (nums[q], 1));\\n            \\n            (long rv, int rLen) = mp.TryGetValue(q + 1, out var value) ? value : (0, 0);\\n            (long lv, int lLen) = mp.TryGetValue(q - 1, out value) ? value : (0, 0);\\n            \\n            var total = nums[q] + rv + lv;\\n            mp[q + rLen] = (total, lLen + rLen + 1);\\n            mp[q - lLen] = (total, lLen + rLen + 1);\\n\\n            cur = Math.Max(cur, total);\\n            res.Add(cur);\\n        }\\n\\n        res.Reverse();\\n        res.Add(0);\\n\\n        return res.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public long[] MaximumSegmentSum(int[] nums, int[] removeQueries)\\n    {\\n        var mp = new Dictionary<int, (long, int)>();\\n        var cur = 0L;\\n        var res = new List<long>();\\n\\n        foreach (var q in removeQueries[1..].Reverse())\\n        {\\n            mp.Add(q, (nums[q], 1));\\n            \\n            (long rv, int rLen) = mp.TryGetValue(q + 1, out var value) ? value : (0, 0);\\n            (long lv, int lLen) = mp.TryGetValue(q - 1, out value) ? value : (0, 0);\\n            \\n            var total = nums[q] + rv + lv;\\n            mp[q + rLen] = (total, lLen + rLen + 1);\\n            mp[q - lLen] = (total, lLen + rLen + 1);\\n\\n            cur = Math.Max(cur, total);\\n            res.Add(cur);\\n        }\\n\\n        res.Reverse();\\n        res.Add(0);\\n\\n        return res.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455464,
                "title": "rust-solution-using-btreeset-hashset",
                "content": "~~~\\n// The idea is \\n// 1) to use s as an order set for tracking the  segments\\n// 2) to use the ordered set cuts is for tracking all the cuts made so far. \\n// Therefore, for a new cut, we can easily determine which segment gets cut\\n//  what new segments are created\\n  \\nuse std::collections::BTreeSet;\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn maximum_segment_sum(nums: Vec<i32>, remove_queries: Vec<i32>) -> Vec<i64> {\\n        let n = nums.len();\\n        let mut sum = vec![0i64; n + 1];\\n        for i in 0..n {\\n            sum[i + 1] = sum[i] + nums[i] as i64;\\n        }\\n\\t\\t\\n\\t\\tlet mut cuts = BTreeSet::<i32>::new();\\n        let mut s = BTreeSet::<(i64, i32, i32)>::new();\\n        let mut ret: Vec<i64> = vec![];\\n\\t\\t\\n        cuts.insert(-1);\\n        cuts.insert(n as i32);\\n        s.insert((sum[n], -1, n as i32));\\n        \\n        for r in remove_queries {\\n            let left = if let Some(a) = cuts.range(..r).rev().next() { *a } else { 0 };\\n            let right = if let Some(a) = cuts.range(r..).next() { *a } else { n as i32 };\\n            let total = sum[right as usize] - sum[(left + 1) as  usize];\\n            \\n            //println![\"r: {}, left: {}, right: {}. total: {}\", r, left, right, total];  \\n            s.remove(&(total, left,  right));\\n            cuts.insert(r);\\n            \\n            if left + 1 < r {\\n                let total = sum[r as usize] - sum[left as usize + 1];\\n                s.insert((total, left, r));\\n            }\\n            \\n            if r + 1 < right {\\n                let total = sum[right as usize] - sum[r as usize + 1];\\n                s.insert((total, r, right));\\n            }\\n            \\n            if let Some((val, _, _)) = s.iter().next_back() {\\n                ret.push(*val);\\n            } else {\\n                ret.push(0);\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust"
                ],
                "code": "~~~\\n// The idea is \\n// 1) to use s as an order set for tracking the  segments\\n// 2) to use the ordered set cuts is for tracking all the cuts made so far. \\n// Therefore, for a new cut, we can easily determine which segment gets cut\\n//  what new segments are created\\n  \\nuse std::collections::BTreeSet;\\nuse std::collections::HashMap;\\n\\nimpl Solution {\\n    pub fn maximum_segment_sum(nums: Vec<i32>, remove_queries: Vec<i32>) -> Vec<i64> {\\n        let n = nums.len();\\n        let mut sum = vec![0i64; n + 1];\\n        for i in 0..n {\\n            sum[i + 1] = sum[i] + nums[i] as i64;\\n        }\\n\\t\\t\\n\\t\\tlet mut cuts = BTreeSet::<i32>::new();\\n        let mut s = BTreeSet::<(i64, i32, i32)>::new();\\n        let mut ret: Vec<i64> = vec![];\\n\\t\\t\\n        cuts.insert(-1);\\n        cuts.insert(n as i32);\\n        s.insert((sum[n], -1, n as i32));\\n        \\n        for r in remove_queries {\\n            let left = if let Some(a) = cuts.range(..r).rev().next() { *a } else { 0 };\\n            let right = if let Some(a) = cuts.range(r..).next() { *a } else { n as i32 };\\n            let total = sum[right as usize] - sum[(left + 1) as  usize];\\n            \\n            //println![\"r: {}, left: {}, right: {}. total: {}\", r, left, right, total];  \\n            s.remove(&(total, left,  right));\\n            cuts.insert(r);\\n            \\n            if left + 1 < r {\\n                let total = sum[r as usize] - sum[left as usize + 1];\\n                s.insert((total, left, r));\\n            }\\n            \\n            if r + 1 < right {\\n                let total = sum[right as usize] - sum[r as usize + 1];\\n                s.insert((total, r, right));\\n            }\\n            \\n            if let Some((val, _, _)) = s.iter().next_back() {\\n                ret.push(*val);\\n            } else {\\n                ret.push(0);\\n            }\\n        }\\n        \\n        ret\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2455384,
                "title": "c-prefix-sum-segment-tree-o-n-logn-time",
                "content": "**Logic:**\\nFor every input query, you want to find the segment to which it belongs. Due to removal of this query, your segment splits into two new segments. \\nI have maintained two segment tree to get the segment the query belongs to, namely, st_seg_tree and en_seg_tree.\\n\\ngetRightMost -> returns you the right most element in the st_seg_tree which corresponds to the starting indices of all the segments created\\ngetLeftMost -> returns you the left most element in the en_seg_tree which corresponds to the ending indices of all the segments created\\n*range passed in the argument is a function of the index which is being removed*\\n\\nOnce you have the segment to which your query belongs to, you have to update the set structure by removing the current segment sum and adding the new segment sums. For this purpose, you can use a prefix sum array to get the segment sum in O(1) time. \\n\\nOverall time complexity of the code is O(N logN)\\n\\n```\\nclass Solution {\\npublic:\\n    void updateStartSegTree(int i, int idx, int l, int r, vector<int>& st_seg_tree)\\n    {\\n        //cout << \"updateStartSegTree input: i = \" << i << \", idx = \" << idx << \", l = \" << l << \", r = \" << r << endl;\\n        if(l==r)\\n        {\\n            st_seg_tree[idx] = i;\\n            return;\\n        }\\n        \\n        int mid = (l+r) >> 1;\\n        if(i<=mid)\\n            updateStartSegTree(i, 2*idx+1, l, mid, st_seg_tree);\\n        else\\n            updateStartSegTree(i, 2*idx+2, mid+1, r, st_seg_tree);\\n        \\n        if(st_seg_tree[2*idx+2] != -1)\\n            st_seg_tree[idx] = st_seg_tree[2*idx+2];\\n        else\\n            st_seg_tree[idx] = st_seg_tree[2*idx+1];\\n        \\n        return;\\n    }\\n    void updateEndSegTree(int i, int idx, int l, int r, vector<int>& en_seg_tree)\\n    {\\n        //cout << \"updateEndSegTree input: i = \" << i << \", idx = \" << idx << \", l = \" << l << \", r = \" << r << endl;\\n        if(l==r)\\n        {\\n            en_seg_tree[idx] = i;\\n            return;\\n        }\\n        \\n        int mid = (l+r)>>1;\\n        if(i<=mid)\\n            updateEndSegTree(i, 2*idx+1, l, mid, en_seg_tree);\\n        else\\n            updateEndSegTree(i, 2*idx+2, mid+1, r, en_seg_tree);\\n        \\n        if(en_seg_tree[2*idx+1] != -1)\\n            en_seg_tree[idx] = en_seg_tree[2*idx+1];\\n        else\\n            en_seg_tree[idx] = en_seg_tree[2*idx+2];\\n        \\n        return;\\n    }\\n    int getRightMost(int idx, int ql, int qr, int l, int r, vector<int>& st_seg_tree)\\n    {\\n        //cout << \"getRightMost input: idx = \" << idx << \", ql = \" << ql << \", qr = \" << qr << \", l = \" << l << \", r = \" << r << endl;\\n        if(ql==l && qr==r)\\n            return st_seg_tree[idx];\\n        \\n        int mid = (l+r)>>1;\\n        if(qr <= mid)\\n            return getRightMost(2*idx+1, ql, qr, l, mid, st_seg_tree);\\n        if(ql>mid)\\n            return getRightMost(2*idx+2, ql, qr, mid+1, r, st_seg_tree);\\n        \\n        int ans_l = getRightMost(2*idx+1, ql, mid, l, mid, st_seg_tree);\\n        int ans_r = getRightMost(2*idx+2, mid+1, qr, mid+1, r, st_seg_tree);\\n        if(ans_r != -1)\\n            return ans_r;\\n        return ans_l;\\n    }\\n    int getLeftMost(int idx, int ql, int qr, int l, int r, vector<int>& en_seg_tree)\\n    {\\n        //cout << \"getLeftMost input: idx = \" << idx << \", ql = \" << ql << \", qr = \" << qr << \", l = \" << l << \", r = \" << r << endl;\\n        if(ql==l && qr==r)\\n            return en_seg_tree[idx];\\n        \\n        int mid = (l+r)>>1;\\n        if(qr<=mid)\\n            return getLeftMost(2*idx+1, ql, qr, l, mid, en_seg_tree);\\n        if(ql>mid)\\n            return getLeftMost(2*idx+2, ql, qr, mid+1, r, en_seg_tree);\\n        \\n        int ans_l = getLeftMost(2*idx+1, ql, mid, l, mid, en_seg_tree);\\n        int ans_r = getLeftMost(2*idx+2, mid+1, qr, mid+1, r, en_seg_tree);\\n        \\n        if(ans_l != -1)\\n            return ans_l;\\n        return ans_r;\\n    }\\n    void printSet(set<tuple<long long, int, int>>& s)\\n    {\\n        auto it = s.begin();\\n        cout << \"printing set\" << endl;\\n        while(it != s.end())\\n        {\\n            cout << get<0>(*it) << \", \" << get<1>(*it) << \", \" << get<2>(*it) << endl;\\n            it++;\\n        }\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) \\n    {\\n        // Approach 1 - My own idea using segment tree\\n        int n = nums.size();\\n        vector<int> st_seg_tree(4*n, -1);\\n        vector<int> en_seg_tree(4*n, -1);\\n        updateStartSegTree(0, 0, 0, n-1, st_seg_tree);\\n        updateEndSegTree(n-1, 0, 0, n-1, en_seg_tree);\\n        \\n        vector<long long> pref_sum(n, 0);\\n        \\n        for(int i= 0; i< n; i++)\\n        {\\n            pref_sum[i] = nums[i];\\n            if(i-1>=0)\\n                pref_sum[i] += pref_sum[i-1];\\n        }\\n        \\n        set<tuple<long long,int,int>> s; // <-sum, st, en> for every segment is stored\\n        s.insert({-pref_sum[n-1], 0, n-1});\\n        vector<long long> ans;\\n        vector<int> rem(n, 0);\\n        \\n        for(int i= 0; i< n-1; i++)\\n        {\\n            int idx = removeQueries[i];\\n            int st_idx = getRightMost(0, 0, idx, 0, n-1, st_seg_tree);\\n            int en_idx = getLeftMost(0, idx, n-1, 0, n-1, en_seg_tree);\\n            \\n            rem[idx] = 1;\\n            if(idx-1>=0 && rem[idx-1] == 0)\\n                updateEndSegTree(idx-1, 0, 0, n-1, en_seg_tree);\\n            if(idx+1<n && rem[idx+1] == 0)\\n                updateStartSegTree(idx+1, 0, 0, n-1, st_seg_tree);\\n            \\n            long long curr_sum = pref_sum[en_idx];\\n            if(st_idx-1 >= 0) curr_sum -= pref_sum[st_idx-1];\\n            s.erase({-curr_sum, st_idx, en_idx});\\n\\n            if(idx-1 >= st_idx)\\n            {\\n                long long val = pref_sum[idx-1];\\n                if(st_idx-1 >= 0) val -= pref_sum[st_idx-1];\\n                s.insert({-val, st_idx, idx-1});\\n            }\\n            \\n            if(idx+1 <= en_idx)\\n            {\\n                long long val = pref_sum[en_idx];\\n                if(idx >= 0) val -= pref_sum[idx];\\n                s.insert({-val, idx+1, en_idx});\\n            }\\n            \\n            auto it = s.begin();\\n            ans.push_back(-1*get<0>(*it));\\n        }\\n        ans.push_back(0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void updateStartSegTree(int i, int idx, int l, int r, vector<int>& st_seg_tree)\\n    {\\n        //cout << \"updateStartSegTree input: i = \" << i << \", idx = \" << idx << \", l = \" << l << \", r = \" << r << endl;\\n        if(l==r)\\n        {\\n            st_seg_tree[idx] = i;\\n            return;\\n        }\\n        \\n        int mid = (l+r) >> 1;\\n        if(i<=mid)\\n            updateStartSegTree(i, 2*idx+1, l, mid, st_seg_tree);\\n        else\\n            updateStartSegTree(i, 2*idx+2, mid+1, r, st_seg_tree);\\n        \\n        if(st_seg_tree[2*idx+2] != -1)\\n            st_seg_tree[idx] = st_seg_tree[2*idx+2];\\n        else\\n            st_seg_tree[idx] = st_seg_tree[2*idx+1];\\n        \\n        return;\\n    }\\n    void updateEndSegTree(int i, int idx, int l, int r, vector<int>& en_seg_tree)\\n    {\\n        //cout << \"updateEndSegTree input: i = \" << i << \", idx = \" << idx << \", l = \" << l << \", r = \" << r << endl;\\n        if(l==r)\\n        {\\n            en_seg_tree[idx] = i;\\n            return;\\n        }\\n        \\n        int mid = (l+r)>>1;\\n        if(i<=mid)\\n            updateEndSegTree(i, 2*idx+1, l, mid, en_seg_tree);\\n        else\\n            updateEndSegTree(i, 2*idx+2, mid+1, r, en_seg_tree);\\n        \\n        if(en_seg_tree[2*idx+1] != -1)\\n            en_seg_tree[idx] = en_seg_tree[2*idx+1];\\n        else\\n            en_seg_tree[idx] = en_seg_tree[2*idx+2];\\n        \\n        return;\\n    }\\n    int getRightMost(int idx, int ql, int qr, int l, int r, vector<int>& st_seg_tree)\\n    {\\n        //cout << \"getRightMost input: idx = \" << idx << \", ql = \" << ql << \", qr = \" << qr << \", l = \" << l << \", r = \" << r << endl;\\n        if(ql==l && qr==r)\\n            return st_seg_tree[idx];\\n        \\n        int mid = (l+r)>>1;\\n        if(qr <= mid)\\n            return getRightMost(2*idx+1, ql, qr, l, mid, st_seg_tree);\\n        if(ql>mid)\\n            return getRightMost(2*idx+2, ql, qr, mid+1, r, st_seg_tree);\\n        \\n        int ans_l = getRightMost(2*idx+1, ql, mid, l, mid, st_seg_tree);\\n        int ans_r = getRightMost(2*idx+2, mid+1, qr, mid+1, r, st_seg_tree);\\n        if(ans_r != -1)\\n            return ans_r;\\n        return ans_l;\\n    }\\n    int getLeftMost(int idx, int ql, int qr, int l, int r, vector<int>& en_seg_tree)\\n    {\\n        //cout << \"getLeftMost input: idx = \" << idx << \", ql = \" << ql << \", qr = \" << qr << \", l = \" << l << \", r = \" << r << endl;\\n        if(ql==l && qr==r)\\n            return en_seg_tree[idx];\\n        \\n        int mid = (l+r)>>1;\\n        if(qr<=mid)\\n            return getLeftMost(2*idx+1, ql, qr, l, mid, en_seg_tree);\\n        if(ql>mid)\\n            return getLeftMost(2*idx+2, ql, qr, mid+1, r, en_seg_tree);\\n        \\n        int ans_l = getLeftMost(2*idx+1, ql, mid, l, mid, en_seg_tree);\\n        int ans_r = getLeftMost(2*idx+2, mid+1, qr, mid+1, r, en_seg_tree);\\n        \\n        if(ans_l != -1)\\n            return ans_l;\\n        return ans_r;\\n    }\\n    void printSet(set<tuple<long long, int, int>>& s)\\n    {\\n        auto it = s.begin();\\n        cout << \"printing set\" << endl;\\n        while(it != s.end())\\n        {\\n            cout << get<0>(*it) << \", \" << get<1>(*it) << \", \" << get<2>(*it) << endl;\\n            it++;\\n        }\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) \\n    {\\n        // Approach 1 - My own idea using segment tree\\n        int n = nums.size();\\n        vector<int> st_seg_tree(4*n, -1);\\n        vector<int> en_seg_tree(4*n, -1);\\n        updateStartSegTree(0, 0, 0, n-1, st_seg_tree);\\n        updateEndSegTree(n-1, 0, 0, n-1, en_seg_tree);\\n        \\n        vector<long long> pref_sum(n, 0);\\n        \\n        for(int i= 0; i< n; i++)\\n        {\\n            pref_sum[i] = nums[i];\\n            if(i-1>=0)\\n                pref_sum[i] += pref_sum[i-1];\\n        }\\n        \\n        set<tuple<long long,int,int>> s; // <-sum, st, en> for every segment is stored\\n        s.insert({-pref_sum[n-1], 0, n-1});\\n        vector<long long> ans;\\n        vector<int> rem(n, 0);\\n        \\n        for(int i= 0; i< n-1; i++)\\n        {\\n            int idx = removeQueries[i];\\n            int st_idx = getRightMost(0, 0, idx, 0, n-1, st_seg_tree);\\n            int en_idx = getLeftMost(0, idx, n-1, 0, n-1, en_seg_tree);\\n            \\n            rem[idx] = 1;\\n            if(idx-1>=0 && rem[idx-1] == 0)\\n                updateEndSegTree(idx-1, 0, 0, n-1, en_seg_tree);\\n            if(idx+1<n && rem[idx+1] == 0)\\n                updateStartSegTree(idx+1, 0, 0, n-1, st_seg_tree);\\n            \\n            long long curr_sum = pref_sum[en_idx];\\n            if(st_idx-1 >= 0) curr_sum -= pref_sum[st_idx-1];\\n            s.erase({-curr_sum, st_idx, en_idx});\\n\\n            if(idx-1 >= st_idx)\\n            {\\n                long long val = pref_sum[idx-1];\\n                if(st_idx-1 >= 0) val -= pref_sum[st_idx-1];\\n                s.insert({-val, st_idx, idx-1});\\n            }\\n            \\n            if(idx+1 <= en_idx)\\n            {\\n                long long val = pref_sum[en_idx];\\n                if(idx >= 0) val -= pref_sum[idx];\\n                s.insert({-val, idx+1, en_idx});\\n            }\\n            \\n            auto it = s.begin();\\n            ans.push_back(-1*get<0>(*it));\\n        }\\n        ans.push_back(0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2455319,
                "title": "reverse-union-find-java-version",
                "content": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int length = nums.length;\\n        long[] res= new long[length];\\n        UnionFind uf=new UnionFind(length);\\n        \\n        TreeSet<Long> set = new TreeSet<>();\\n        \\n        for(int i=length-1;i>=0;i--){\\n            uf.sum[removeQueries[i]]=nums[removeQueries[i]];\\n            if(removeQueries[i]+1<length&&uf.sum[removeQueries[i]+1]!=0){\\n                uf.union(removeQueries[i], removeQueries[i]+1);\\n            }\\n            \\n             if(removeQueries[i]>0&&uf.sum[removeQueries[i]-1]!=0){\\n                uf.union(removeQueries[i], removeQueries[i]-1);\\n            }\\n            set.add(uf.sum[uf.find(removeQueries[i])]);\\n            \\n            if(i>0)\\n                res[i-1]=set.last();\\n            \\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n}\\n\\nclass UnionFind{\\n    int[] f;\\n    long[] sum;\\n    public UnionFind(int size){\\n        f = new int[size];\\n        sum = new long[size];\\n        for(int i = 0; i < size; i++){\\n            f[i] = i;\\n        }\\n    }\\n    public int find(int x){\\n        if (f[x] != x){\\n            f[x] = find(f[x]);\\n        }\\n        return f[x];\\n    }\\n    public void union(int x, int y){\\n        int fx = find(x);\\n        int fy = find(y);\\n        f[f[y]] = fx;\\n        sum[fx]+=sum[fy];\\n    }    \\n}``\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public long[] maximumSegmentSum(int[] nums, int[] removeQueries) {\\n        int length = nums.length;\\n        long[] res= new long[length];\\n        UnionFind uf=new UnionFind(length);\\n        \\n        TreeSet<Long> set = new TreeSet<>();\\n        \\n        for(int i=length-1;i>=0;i--){\\n            uf.sum[removeQueries[i]]=nums[removeQueries[i]];\\n            if(removeQueries[i]+1<length&&uf.sum[removeQueries[i]+1]!=0){\\n                uf.union(removeQueries[i], removeQueries[i]+1);\\n            }\\n            \\n             if(removeQueries[i]>0&&uf.sum[removeQueries[i]-1]!=0){\\n                uf.union(removeQueries[i], removeQueries[i]-1);\\n            }\\n            set.add(uf.sum[uf.find(removeQueries[i])]);\\n            \\n            if(i>0)\\n                res[i-1]=set.last();\\n            \\n        }\\n        \\n        return res;\\n        \\n        \\n    }\\n}\\n\\nclass UnionFind{\\n    int[] f;\\n    long[] sum;\\n    public UnionFind(int size){\\n        f = new int[size];\\n        sum = new long[size];\\n        for(int i = 0; i < size; i++){\\n            f[i] = i;\\n        }\\n    }\\n    public int find(int x){\\n        if (f[x] != x){\\n            f[x] = find(f[x]);\\n        }\\n        return f[x];\\n    }\\n    public void union(int x, int y){\\n        int fx = find(x);\\n        int fy = find(y);\\n        f[f[y]] = fx;\\n        sum[fx]+=sum[fy];\\n    }    \\n}``\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455279,
                "title": "c-easy-solution-with-set-and-multiset-easy-to-understand-readable-code",
                "content": "```class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        int n = nums.size();\\n        vector<long long> pre = {0};\\n        for(int i = 0; i < n; i++) pre.push_back(pre.back() + nums[i]);\\n\\n        set <pair<long long, long long>> st;\\n        st.insert({n - 1, 0});//only valid ones that are not removed or queried values will be present here\\n        \\n        multiset<long long>s = {0};\\n        s.insert(pre.back());\\n        \\n        vector<long long>ans;\\n        \\n        for(auto &x : removeQueries)\\n        {\\n            auto bound = *st.lower_bound({x, 0});\\n            st.erase(bound);\\n            long long leftidx = bound.second, rightidx = bound.first;\\n            \\n            long long toremove = pre[rightidx + 1] - pre[leftidx];\\n            \\n            s.erase(s.find(pre[rightidx + 1] - pre[leftidx]));\\n            \\n            if(x != leftidx)\\n            {\\n                long long leftseg = pre[x] - pre[leftidx];\\n                s.insert(leftseg);\\n                st.insert({x - 1, leftidx});\\n            }\\n            if(x != rightidx)\\n            {\\n                long long rightseg = pre[rightidx + 1] - pre[x + 1];\\n                s.insert(rightseg);\\n                st.insert({rightidx, x + 1});\\n            }\\n            ans.push_back(*s.rbegin());\\n        }\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        int n = nums.size();\\n        vector<long long> pre = {0}",
                "codeTag": "Java"
            },
            {
                "id": 2455247,
                "title": "c-set-map-binary-search",
                "content": "```\\ntypedef long long ll;\\n\\nclass Solution {\\n    \\n    ll get_sum(int l, int r, vector<ll> &sum) {\\n        return l == 0 ? sum[r] : sum[r] - sum[l-1];\\n    }\\n    \\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        int n = nums.size();\\n        vector<ll> ans(n); \\n        \\n        map<ll, int> mp;\\n        set<pair<pair<int, int>, ll>> ranges;\\n        \\n        vector<ll> psum(n);\\n        for(int i = 0; i < n; i++) {\\n            psum[i] = nums[i];\\n            if(i > 0)\\n                psum[i] += psum[i-1];\\n        }\\n        \\n        ranges.insert({{0, n-1}, psum[n-1]});\\n        mp[0] += 1;\\n        mp[psum[n-1]] += 1;\\n        \\n        for(int i = 0; i < n; i++) {\\n            pair<pair<int, int>, ll> pi = {{q[i], 1e9}, -1};\\n            auto it = --ranges.upper_bound(pi);\\n            \\n            if(it == ranges.end()) {\\n                ans[i] = 0;\\n                cout << i << endl;\\n                continue;\\n            }\\n            \\n            int l = it->first.first;\\n            int r = it->first.second;\\n            ll sum = it->second;\\n            \\n            //remove from range\\n            ranges.erase(it);\\n            \\n            // remove from map;\\n            mp[sum] -= 1;\\n            if(mp[sum] <= 0) \\n                mp.erase(sum);\\n            \\n            if(l == r) {\\n                // do nothing\\n            }\\n            else if(l == q[i]) {\\n                sum = get_sum(l+1, r, psum);\\n                mp[sum] += 1;\\n                ranges.insert({{l+1, r}, sum});\\n            } \\n            else if(r == q[i]) {\\n                sum = get_sum(l, r-1, psum);\\n                mp[sum] += 1;\\n                ranges.insert({{l, r-1}, sum});\\n            }\\n            else {\\n                sum = get_sum(l, q[i]-1, psum);\\n                mp[sum] += 1;\\n                ranges.insert({{l, q[i]-1}, sum});\\n                \\n                sum = get_sum(q[i]+1, r, psum);\\n                mp[sum] += 1;\\n                ranges.insert({{q[i]+1, r}, sum});\\n            }\\n            \\n            if(mp.size() == 0) \\n                ans[i] = 0;\\n            else {\\n                auto tmp = --mp.end();\\n                ans[i] = tmp->first;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree",
                    "Ordered Set"
                ],
                "code": "```\\ntypedef long long ll;\\n\\nclass Solution {\\n    \\n    ll get_sum(int l, int r, vector<ll> &sum) {\\n        return l == 0 ? sum[r] : sum[r] - sum[l-1];\\n    }\\n    \\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& q) {\\n        int n = nums.size();\\n        vector<ll> ans(n); \\n        \\n        map<ll, int> mp;\\n        set<pair<pair<int, int>, ll>> ranges;\\n        \\n        vector<ll> psum(n);\\n        for(int i = 0; i < n; i++) {\\n            psum[i] = nums[i];\\n            if(i > 0)\\n                psum[i] += psum[i-1];\\n        }\\n        \\n        ranges.insert({{0, n-1}, psum[n-1]});\\n        mp[0] += 1;\\n        mp[psum[n-1]] += 1;\\n        \\n        for(int i = 0; i < n; i++) {\\n            pair<pair<int, int>, ll> pi = {{q[i], 1e9}, -1};\\n            auto it = --ranges.upper_bound(pi);\\n            \\n            if(it == ranges.end()) {\\n                ans[i] = 0;\\n                cout << i << endl;\\n                continue;\\n            }\\n            \\n            int l = it->first.first;\\n            int r = it->first.second;\\n            ll sum = it->second;\\n            \\n            //remove from range\\n            ranges.erase(it);\\n            \\n            // remove from map;\\n            mp[sum] -= 1;\\n            if(mp[sum] <= 0) \\n                mp.erase(sum);\\n            \\n            if(l == r) {\\n                // do nothing\\n            }\\n            else if(l == q[i]) {\\n                sum = get_sum(l+1, r, psum);\\n                mp[sum] += 1;\\n                ranges.insert({{l+1, r}, sum});\\n            } \\n            else if(r == q[i]) {\\n                sum = get_sum(l, r-1, psum);\\n                mp[sum] += 1;\\n                ranges.insert({{l, r-1}, sum});\\n            }\\n            else {\\n                sum = get_sum(l, q[i]-1, psum);\\n                mp[sum] += 1;\\n                ranges.insert({{l, q[i]-1}, sum});\\n                \\n                sum = get_sum(q[i]+1, r, psum);\\n                mp[sum] += 1;\\n                ranges.insert({{q[i]+1, r}, sum});\\n            }\\n            \\n            if(mp.size() == 0) \\n                ans[i] = 0;\\n            else {\\n                auto tmp = --mp.end();\\n                ans[i] = tmp->first;\\n            }\\n        }\\n        \\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2455150,
                "title": "video-explanation-both-with-and-without-dsu",
                "content": "https://www.youtube.com/watch?v=L_EU1nxzFKg",
                "solutionTags": [
                    "Prefix Sum",
                    "Ordered Set"
                ],
                "code": "https://www.youtube.com/watch?v=L_EU1nxzFKg",
                "codeTag": "Unknown"
            },
            {
                "id": 2455146,
                "title": "segment-tree",
                "content": "```\\n//Link->https://leetcode.com/contest/biweekly-contest-85/problems/maximum-segment-sum-after-removals/\\n//same concept like this ->https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/A\\n//Author: Rohit Kumar\\n//Status: Accepted\\n//Time_complexity: O(nlongn)\\n//Space_complexity: O(n)\\n//Submission_date: 20/08/2022\\n//idea-> used segment tree to find the maximum subsegmet sum of a segment of the array\\n//whenver we remove an element from the array we update the segment tree\\n//we have to find maxium seb_segement sum of the array after removing an element which will lead\\n//us to divide the array into two parts ..... removedelement ......\\n//so how to handle this situation using segement tree\\n//so we no how to find subsegment sum of the array \\n// if we have to part  exampale [1,2,3,-4] [2,3,4,-5];\\n// so if we add this segement so the we have many senario like the max_sum is sum of both array\\n//or maxvalue is sum of first_arrray and max_prefix of second array\\n//or max_suffix of first array and sum of second array\\n//so we have to consider all these senario and find the max value\\n//also we have to update the prefix and suffix of the array for merging the interval\\n\\n#include<bits/stdc++.h>\\n#define ll long long int\\nstruct node{\\n        ll maxvalue;\\n        ll prefix,suffix,sum;\\n};\\n    \\n    \\n    \\nvector<node> seg_tree;\\nvoid assign(int index){\\n    seg_tree[index].maxvalue=max(seg_tree[2*index+1].maxvalue,seg_tree[2*index+2].maxvalue);\\n        seg_tree[index].maxvalue=max(seg_tree[index].maxvalue,seg_tree[2*index+1].suffix+seg_tree[2*index+2].prefix);\\n        seg_tree[index].maxvalue=max(seg_tree[index].maxvalue,seg_tree[2*index+1].sum+seg_tree[2*index+2].prefix);\\n        seg_tree[index].maxvalue=max(seg_tree[index].maxvalue,seg_tree[2*index+1].suffix+seg_tree[2*index+2].sum);\\n         seg_tree[index].maxvalue=max(seg_tree[index].maxvalue,seg_tree[2*index+1].sum+seg_tree[2*index+2].sum);\\n        seg_tree[index].prefix=max(seg_tree[2*index+1].prefix,seg_tree[2*index+1].sum+seg_tree[2*index+2].prefix);\\n        seg_tree[index].prefix=max(seg_tree[index].prefix,seg_tree[2*index+1].sum+seg_tree[2*index+2].sum);\\n        seg_tree[index].suffix=max(seg_tree[2*index+2].suffix,seg_tree[2*index+2].sum+seg_tree[2*index+1].suffix);\\n        seg_tree[index].suffix=max(seg_tree[index].suffix,seg_tree[2*index+1].sum+seg_tree[2*index+2].sum);\\n        ll sm=-1e14;\\n        seg_tree[index].sum=max(sm,seg_tree[2*index+1].sum+seg_tree[2*index+2].sum);\\n}\\n\\n    void build_tree(vector<int>&nums,int left,int right,int index){\\n        if(left>right){\\n            return;\\n        }\\n        if(left==right){\\n            seg_tree[index].maxvalue=nums[left];\\n            seg_tree[index].prefix=nums[left];\\n            seg_tree[index].suffix=nums[left];\\n            seg_tree[index].sum=nums[left];\\n            return;\\n        }\\n        int mid=(left+right)/2;\\n        build_tre(nums,left,mid,2*index+1);\\n        build_tre(nums,mid+1,right,2*index+2);\\n        assign(index);\\n       \\n    }\\n    void update(int pos,int left,int right,int index){\\n        if(left>pos||right<pos){\\n            return;\\n        }\\n        if(left==right&&left==pos){\\n            seg_tree[index].maxvalue=-1e14;\\n            seg_tree[index].prefix=-1e14;\\n            seg_tree[index].suffix=-1e14;\\n            seg_tree[index].sum=-1e14;\\n            return;\\n        }\\n        int mid=(left+right)/2;\\n        update(pos,left,mid,2*index+1);\\n        update(pos,mid+1,right,2*index+2);\\n        assign(index);\\n        \\n    }\\n    \\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n       int n=nums.size();\\n        seg_tree.resize(4*n);\\n        build_tree(nums,0,n-1,0);\\n        vector<ll> ans;\\n        for(int i=0;i<n-1;i++){\\n            update(removeQueries[i],0,n-1,0);\\n            ans.push_back(seg_tree[0].maxvalue);\\n        }\\n        ans.push_back(0);\\n        return ans;\\n    }\\n\\n\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\n//Link->https://leetcode.com/contest/biweekly-contest-85/problems/maximum-segment-sum-after-removals/\\n//same concept like this ->https://codeforces.com/edu/course/2/lesson/4/2/practice/contest/273278/problem/A\\n//Author: Rohit Kumar\\n//Status: Accepted\\n//Time_complexity: O(nlongn)\\n//Space_complexity: O(n)\\n//Submission_date: 20/08/2022\\n//idea-> used segment tree to find the maximum subsegmet sum of a segment of the array\\n//whenver we remove an element from the array we update the segment tree\\n//we have to find maxium seb_segement sum of the array after removing an element which will lead\\n//us to divide the array into two parts ..... removedelement ......\\n//so how to handle this situation using segement tree\\n//so we no how to find subsegment sum of the array \\n// if we have to part  exampale [1,2,3,-4] [2,3,4,-5];\\n// so if we add this segement so the we have many senario like the max_sum is sum of both array\\n//or maxvalue is sum of first_arrray and max_prefix of second array\\n//or max_suffix of first array and sum of second array\\n//so we have to consider all these senario and find the max value\\n//also we have to update the prefix and suffix of the array for merging the interval\\n\\n#include<bits/stdc++.h>\\n#define ll long long int\\nstruct node{\\n        ll maxvalue;\\n        ll prefix,suffix,sum;\\n};\\n    \\n    \\n    \\nvector<node> seg_tree;\\nvoid assign(int index){\\n    seg_tree[index].maxvalue=max(seg_tree[2*index+1].maxvalue,seg_tree[2*index+2].maxvalue);\\n        seg_tree[index].maxvalue=max(seg_tree[index].maxvalue,seg_tree[2*index+1].suffix+seg_tree[2*index+2].prefix);\\n        seg_tree[index].maxvalue=max(seg_tree[index].maxvalue,seg_tree[2*index+1].sum+seg_tree[2*index+2].prefix);\\n        seg_tree[index].maxvalue=max(seg_tree[index].maxvalue,seg_tree[2*index+1].suffix+seg_tree[2*index+2].sum);\\n         seg_tree[index].maxvalue=max(seg_tree[index].maxvalue,seg_tree[2*index+1].sum+seg_tree[2*index+2].sum);\\n        seg_tree[index].prefix=max(seg_tree[2*index+1].prefix,seg_tree[2*index+1].sum+seg_tree[2*index+2].prefix);\\n        seg_tree[index].prefix=max(seg_tree[index].prefix,seg_tree[2*index+1].sum+seg_tree[2*index+2].sum);\\n        seg_tree[index].suffix=max(seg_tree[2*index+2].suffix,seg_tree[2*index+2].sum+seg_tree[2*index+1].suffix);\\n        seg_tree[index].suffix=max(seg_tree[index].suffix,seg_tree[2*index+1].sum+seg_tree[2*index+2].sum);\\n        ll sm=-1e14;\\n        seg_tree[index].sum=max(sm,seg_tree[2*index+1].sum+seg_tree[2*index+2].sum);\\n}\\n\\n    void build_tree(vector<int>&nums,int left,int right,int index){\\n        if(left>right){\\n            return;\\n        }\\n        if(left==right){\\n            seg_tree[index].maxvalue=nums[left];\\n            seg_tree[index].prefix=nums[left];\\n            seg_tree[index].suffix=nums[left];\\n            seg_tree[index].sum=nums[left];\\n            return;\\n        }\\n        int mid=(left+right)/2;\\n        build_tre(nums,left,mid,2*index+1);\\n        build_tre(nums,mid+1,right,2*index+2);\\n        assign(index);\\n       \\n    }\\n    void update(int pos,int left,int right,int index){\\n        if(left>pos||right<pos){\\n            return;\\n        }\\n        if(left==right&&left==pos){\\n            seg_tree[index].maxvalue=-1e14;\\n            seg_tree[index].prefix=-1e14;\\n            seg_tree[index].suffix=-1e14;\\n            seg_tree[index].sum=-1e14;\\n            return;\\n        }\\n        int mid=(left+right)/2;\\n        update(pos,left,mid,2*index+1);\\n        update(pos,mid+1,right,2*index+2);\\n        assign(index);\\n        \\n    }\\n    \\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n       int n=nums.size();\\n        seg_tree.resize(4*n);\\n        build_tree(nums,0,n-1,0);\\n        vector<ll> ans;\\n        for(int i=0;i<n-1;i++){\\n            update(removeQueries[i],0,n-1,0);\\n            ans.push_back(seg_tree[0].maxvalue);\\n        }\\n        ans.push_back(0);\\n        return ans;\\n    }\\n\\n\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2455138,
                "title": "c-dsu-iterate-from-back",
                "content": "Build the array from reverse order and combine the adjacent components and keep updating max sum. \\n```\\nclass Solution {\\npublic:\\n    long long re = INT_MIN;\\n    int find(vector<vector<long long>>& nums,int i){\\n        if(nums[i][0]==-1) return i;\\n        else return nums[i][0] = find(nums,nums[i][0]);\\n    }\\n    void union_(vector<vector<long long>>& nums,int x,int y){\\n        int i = find(nums,x), j = find(nums,y);\\n        if(i!=j){\\n            if(i<j){ nums[j][0] = i; nums[i][1]+=nums[j][1]; re = max(re,nums[i][1]); }\\n            else{ nums[i][0] = j; nums[j][1]+=nums[i][1]; re = max(re,nums[j][1]); }\\n        }\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& arr, vector<int>& q) {\\n        int n = arr.size();\\n        vector<vector<long long>> nums(n,vector<long long>(2,-1));\\n        vector<long long> ans = {0};\\n        for(int i = n-1; i>0; --i){\\n            int j = q[i];\\n            nums[j][1] = arr[j]; \\n            re = max(re,(long long)arr[j]);\\n            if(j+1<n && nums[j+1][1]!=-1) union_(nums,j,j+1);\\n            if(j-1>=0 && nums[j-1][1]!=-1) union_(nums,j,j-1);\\n            ans.push_back(re);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    long long re = INT_MIN;\\n    int find(vector<vector<long long>>& nums,int i){\\n        if(nums[i][0]==-1) return i;\\n        else return nums[i][0] = find(nums,nums[i][0]);\\n    }\\n    void union_(vector<vector<long long>>& nums,int x,int y){\\n        int i = find(nums,x), j = find(nums,y);\\n        if(i!=j){\\n            if(i<j){ nums[j][0] = i; nums[i][1]+=nums[j][1]; re = max(re,nums[i][1]); }\\n            else{ nums[i][0] = j; nums[j][1]+=nums[i][1]; re = max(re,nums[j][1]); }\\n        }\\n    }\\n    vector<long long> maximumSegmentSum(vector<int>& arr, vector<int>& q) {\\n        int n = arr.size();\\n        vector<vector<long long>> nums(n,vector<long long>(2,-1));\\n        vector<long long> ans = {0};\\n        for(int i = n-1; i>0; --i){\\n            int j = q[i];\\n            nums[j][1] = arr[j]; \\n            re = max(re,(long long)arr[j]);\\n            if(j+1<n && nums[j+1][1]!=-1) union_(nums,j,j+1);\\n            if(j-1>=0 && nums[j-1][1]!=-1) union_(nums,j,j-1);\\n            ans.push_back(re);\\n        }\\n        reverse(ans.begin(),ans.end());\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2455102,
                "title": "segment-tree-naive-approach",
                "content": "# This problem is similar to subarray sum for updates and queries using segment tree.\\n\\n\\nclass Solution {\\npublic:\\n    long long sum[400001];\\n    long long prefix_sum[400001];\\n    long long suffix_sum[400001];\\n    long long subarray_sum[400001];\\n    void build(int i,int l,int r,int index,long long num)\\n    {\\n        if(i<l or i>r)\\n            return;\\n        \\n        if(l == r && i == l)\\n        {\\n            sum[index] = num;\\n            prefix_sum[index] = num;\\n            suffix_sum[index] = num;\\n            subarray_sum[index] = num;\\n            return;\\n        }\\n        \\n        if(l>=r)\\n            return;\\n        \\n        int mid =(l+r)/2;\\n        \\n        build(i,l,mid,2*index+1,num);\\n        build(i,mid+1,r,2*index+2,num);\\n        \\n        long long buf = -1e18;\\n        sum[index] = max(buf,sum[2*index+1]+sum[2*index+2]);\\n        prefix_sum[index] = max(prefix_sum[2*index+1],sum[2*index+1]+prefix_sum[2*index+2]);\\n        suffix_sum[index] = max(suffix_sum[2*index+2],sum[2*index+2]+suffix_sum[2*index+1]);\\n        subarray_sum[index] = max(subarray_sum[2*index+1],subarray_sum[2*index+2]);\\n        subarray_sum[index] = max(subarray_sum[index],prefix_sum[2*index+2]+suffix_sum[2*index+1]);\\n        \\n    }\\n    \\n    \\n    \\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        \\n        long long n = nums.size();\\n        vector<long long> dp(n,0);\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            build(i,0,n-1,0,nums[i]);\\n        }\\n        \\n        long long arr = -1e18;\\n        for(int i = 0;i<n-1;i++)\\n        {\\n            build(removeQueries[i],0,n-1,0,arr);\\n            dp[i] = subarray_sum[0];\\n        }\\n        dp[n-1] = 0;\\n        \\n        return dp;\\n          \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    long long sum[400001];\\n    long long prefix_sum[400001];\\n    long long suffix_sum[400001];\\n    long long subarray_sum[400001];\\n    void build(int i,int l,int r,int index,long long num)\\n    {\\n        if(i<l or i>r)\\n            return;\\n        \\n        if(l == r && i == l)\\n        {\\n            sum[index] = num;\\n            prefix_sum[index] = num;\\n            suffix_sum[index] = num;\\n            subarray_sum[index] = num;\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2455021,
                "title": "my-solutions",
                "content": "**1. Use the map and the multiset**\\n```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  vector<long long> maximumSegmentSum(const vector<int> &nums, const vector<int> &removeQueries) {\\n    const int n = static_cast<int>(nums.size());\\n    long long presums[n + 1];\\n    presums[0] = 0LL;\\n    for (int i = 0; i < n; ++i) {\\n      presums[i + 1] = presums[i] + nums[i];\\n    }\\n    \\n    map<int, int> intervals;\\n    multiset<long long> interval_sums;\\n    intervals[0] = n;\\n    interval_sums.emplace(presums[n] - presums[0]);\\n    vector<long long> ret(n);\\n    for (int i = 0; i < n; ++i) {\\n      const int remove = removeQueries[i];\\n      auto itr = prev(intervals.upper_bound(remove));\\n      const auto [left, right] = *itr;\\n      intervals.erase(itr);\\n      const long long sum = presums[right] - presums[left];\\n      auto itr_sum = interval_sums.find(sum);\\n      interval_sums.erase(itr_sum);\\n      vector<pair<int, int>> segments;\\n      segments.emplace_back(left, remove);\\n      segments.emplace_back(remove + 1, right);\\n      for (const auto [begin, end] : segments) {\\n        if (begin < end) {\\n          intervals[begin] = end;\\n          interval_sums.emplace(presums[end] - presums[begin]);\\n        }\\n      }\\n      ret[i] = interval_sums.empty() ? 0 : *interval_sums.rbegin();\\n    }\\n    return ret;\\n  }\\n};\\n```\\n**2. Use the Disjoint Set**\\n```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const vector<int> &nums)\\n      : parents_(nums.size(), -1), ranks_(nums.size(), 0), sums_(nums.size()), max_sum_(0LL) {\\n        copy(nums.begin(), nums.end(), sums_.begin());\\n    }\\n    \\n    long long insert(const int index) {\\n      const int n = static_cast<int>(parents_.size());\\n      parents_[index] = index;\\n      max_sum_ = max(max_sum_, sums_[index]);\\n      if (index > 0 && parents_[index - 1] != -1) {\\n        max_sum_ = max(max_sum_, do_union(index - 1, index));\\n      }\\n      if (index + 1 < n && parents_[index + 1] != -1) {\\n        max_sum_ = max(max_sum_, do_union(index, index + 1));\\n      }\\n      return max_sum_;\\n    }\\n    \\n   private:\\n    int find(const int i) {\\n      if (i == parents_[i]) {\\n        return i;\\n      }\\n      \\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    long long do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return sums_[parent_i];\\n      }\\n      \\n      if (ranks_[parent_i] < ranks_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n        sums_[parent_j] += sums_[parent_i];\\n        sums_[parent_i] = 0;\\n      } else if (ranks_[parent_i] > ranks_[parent_j]) {\\n        parents_[parent_j] = parent_i;\\n        sums_[parent_i] += sums_[parent_j];\\n        sums_[parent_j] = 0;\\n      } else {\\n        // ranks_[parent_i] == ranks_[parent_j]\\n        parents_[parent_i] = parent_j;\\n        ++ranks_[parent_j];\\n        sums_[parent_j] += sums_[parent_i];\\n        sums_[parent_i] = 0;\\n      }\\n      return max(sums_[parent_i], sums_[parent_j]);\\n    }\\n    \\n    vector<int> parents_;\\n    vector<int> ranks_;\\n    vector<long long> sums_;\\n    long long max_sum_;\\n  };\\n  \\n public:\\n  vector<long long> maximumSegmentSum(const vector<int> &nums, const vector<int> &removeQueries) {\\n    const int n = static_cast<int>(nums.size());\\n    DisjointSet ds(nums);\\n    vector<long long> ret(n);\\n    ret.back() = 0;\\n    for (int i = n - 1; i > 0; --i) {\\n      ret[i - 1] = ds.insert(removeQueries[i]);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Time Complexity: O(n * log(n))\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n public:\\n  vector<long long> maximumSegmentSum(const vector<int> &nums, const vector<int> &removeQueries) {\\n    const int n = static_cast<int>(nums.size());\\n    long long presums[n + 1];\\n    presums[0] = 0LL;\\n    for (int i = 0; i < n; ++i) {\\n      presums[i + 1] = presums[i] + nums[i];\\n    }\\n    \\n    map<int, int> intervals;\\n    multiset<long long> interval_sums;\\n    intervals[0] = n;\\n    interval_sums.emplace(presums[n] - presums[0]);\\n    vector<long long> ret(n);\\n    for (int i = 0; i < n; ++i) {\\n      const int remove = removeQueries[i];\\n      auto itr = prev(intervals.upper_bound(remove));\\n      const auto [left, right] = *itr;\\n      intervals.erase(itr);\\n      const long long sum = presums[right] - presums[left];\\n      auto itr_sum = interval_sums.find(sum);\\n      interval_sums.erase(itr_sum);\\n      vector<pair<int, int>> segments;\\n      segments.emplace_back(left, remove);\\n      segments.emplace_back(remove + 1, right);\\n      for (const auto [begin, end] : segments) {\\n        if (begin < end) {\\n          intervals[begin] = end;\\n          interval_sums.emplace(presums[end] - presums[begin]);\\n        }\\n      }\\n      ret[i] = interval_sums.empty() ? 0 : *interval_sums.rbegin();\\n    }\\n    return ret;\\n  }\\n};\\n```\n```\\n/**\\n * Time Complexity: O(n)\\n * Space Complexity: O(n)\\n * where `n` is the length of the vector `nums`\\n */\\nclass Solution {\\n private:\\n  class DisjointSet {\\n   public:\\n    DisjointSet(const vector<int> &nums)\\n      : parents_(nums.size(), -1), ranks_(nums.size(), 0), sums_(nums.size()), max_sum_(0LL) {\\n        copy(nums.begin(), nums.end(), sums_.begin());\\n    }\\n    \\n    long long insert(const int index) {\\n      const int n = static_cast<int>(parents_.size());\\n      parents_[index] = index;\\n      max_sum_ = max(max_sum_, sums_[index]);\\n      if (index > 0 && parents_[index - 1] != -1) {\\n        max_sum_ = max(max_sum_, do_union(index - 1, index));\\n      }\\n      if (index + 1 < n && parents_[index + 1] != -1) {\\n        max_sum_ = max(max_sum_, do_union(index, index + 1));\\n      }\\n      return max_sum_;\\n    }\\n    \\n   private:\\n    int find(const int i) {\\n      if (i == parents_[i]) {\\n        return i;\\n      }\\n      \\n      parents_[i] = find(parents_[i]);\\n      return parents_[i];\\n    }\\n    \\n    long long do_union(const int i, const int j) {\\n      const int parent_i = find(i);\\n      const int parent_j = find(j);\\n      if (parent_i == parent_j) {\\n        return sums_[parent_i];\\n      }\\n      \\n      if (ranks_[parent_i] < ranks_[parent_j]) {\\n        parents_[parent_i] = parent_j;\\n        sums_[parent_j] += sums_[parent_i];\\n        sums_[parent_i] = 0;\\n      } else if (ranks_[parent_i] > ranks_[parent_j]) {\\n        parents_[parent_j] = parent_i;\\n        sums_[parent_i] += sums_[parent_j];\\n        sums_[parent_j] = 0;\\n      } else {\\n        // ranks_[parent_i] == ranks_[parent_j]\\n        parents_[parent_i] = parent_j;\\n        ++ranks_[parent_j];\\n        sums_[parent_j] += sums_[parent_i];\\n        sums_[parent_i] = 0;\\n      }\\n      return max(sums_[parent_i], sums_[parent_j]);\\n    }\\n    \\n    vector<int> parents_;\\n    vector<int> ranks_;\\n    vector<long long> sums_;\\n    long long max_sum_;\\n  };\\n  \\n public:\\n  vector<long long> maximumSegmentSum(const vector<int> &nums, const vector<int> &removeQueries) {\\n    const int n = static_cast<int>(nums.size());\\n    DisjointSet ds(nums);\\n    vector<long long> ret(n);\\n    ret.back() = 0;\\n    for (int i = n - 1; i > 0; --i) {\\n      ret[i - 1] = ds.insert(removeQueries[i]);\\n    }\\n    return ret;\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2454794,
                "title": "python-3-o-n-2-solution-that-succeeds",
                "content": "As far as N=1E5 problems go, Python O(N^2) solutions generally don\\'t work. However, a list insertion in the inner loop is sometimes okay, and then it depends on the complexity of the test cases. This is not a winning approach, but having no good ideas, I went with a brute-force algorithm. This clocked in at under 7 seconds (out of 10 seconds maximum):\\n\\n```\\ndef maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n\\tpsums = [0]  # Left-pad psums.\\n\\tfor num in nums:\\n\\t\\tpsums.append(psums[-1] + num)\\n\\tn = len(nums)            \\n\\tans = []\\n\\tremovals = [-1, n]  # Pad removals.\\n\\tsegmentHeap = []  # Store -score, start, end.\\n\\n\\tdef addSegmentToHeap(startIncl, endIncl):\\n\\t\\tif startIncl <= endIncl:\\n\\t\\t\\tscore = psums[endIncl + 1] - psums[startIncl]\\n\\t\\t\\theapq.heappush(segmentHeap, (-score, startIncl, endIncl))\\n\\n\\tfor i in range(n):\\n\\t\\tremoval = removeQueries[i]\\n\\t\\tiRem = bisect.bisect_left(removals, removal)\\n\\t\\tremovals.insert(iRem, removal)  # Fast O(N) operation.\\n\\t\\t# Removal splits a segment. Add both new segments to heap.\\n\\t\\taddSegmentToHeap(removals[iRem - 1] + 1, removal - 1)\\n\\t\\taddSegmentToHeap(removal + 1, removals[iRem + 1] - 1)\\n\\t\\tfound = False\\n\\t\\twhile segmentHeap:\\n\\t\\t\\tnegScore, topLo, topHi = segmentHeap[0]\\n\\t\\t\\tiTopLo = bisect.bisect_left(removals, topLo - 1)\\n\\t\\t\\t# Return top segment if it is fresh. If it is stale (due to\\n\\t\\t\\t# a split) pop it and continue.\\n\\t\\t\\tif removals[iTopLo + 1] == topHi + 1:\\n\\t\\t\\t\\tans.append(-negScore)\\n\\t\\t\\t\\tfound = True\\n\\t\\t\\t\\tbreak\\n\\t\\t\\theapq.heappop(segmentHeap)\\n\\t\\tif not found:\\n\\t\\t\\tans.append(0)\\n\\n\\treturn ans\\n```\\n\\nThis may not be a solution that will get you hired, but if you point out that the constant on `removals.insert(iRem, removal)` is very small, a good interviewer will consider that your ability to think beyond just runtime complexity makes you a decent candidate.\\n\\n",
                "solutionTags": [],
                "code": "```\\ndef maximumSegmentSum(self, nums: List[int], removeQueries: List[int]) -> List[int]:\\n\\tpsums = [0]  # Left-pad psums.\\n\\tfor num in nums:\\n\\t\\tpsums.append(psums[-1] + num)\\n\\tn = len(nums)            \\n\\tans = []\\n\\tremovals = [-1, n]  # Pad removals.\\n\\tsegmentHeap = []  # Store -score, start, end.\\n\\n\\tdef addSegmentToHeap(startIncl, endIncl):\\n\\t\\tif startIncl <= endIncl:\\n\\t\\t\\tscore = psums[endIncl + 1] - psums[startIncl]\\n\\t\\t\\theapq.heappush(segmentHeap, (-score, startIncl, endIncl))\\n\\n\\tfor i in range(n):\\n\\t\\tremoval = removeQueries[i]\\n\\t\\tiRem = bisect.bisect_left(removals, removal)\\n\\t\\tremovals.insert(iRem, removal)  # Fast O(N) operation.\\n\\t\\t# Removal splits a segment. Add both new segments to heap.\\n\\t\\taddSegmentToHeap(removals[iRem - 1] + 1, removal - 1)\\n\\t\\taddSegmentToHeap(removal + 1, removals[iRem + 1] - 1)\\n\\t\\tfound = False\\n\\t\\twhile segmentHeap:\\n\\t\\t\\tnegScore, topLo, topHi = segmentHeap[0]\\n\\t\\t\\tiTopLo = bisect.bisect_left(removals, topLo - 1)\\n\\t\\t\\t# Return top segment if it is fresh. If it is stale (due to\\n\\t\\t\\t# a split) pop it and continue.\\n\\t\\t\\tif removals[iTopLo + 1] == topHi + 1:\\n\\t\\t\\t\\tans.append(-negScore)\\n\\t\\t\\t\\tfound = True\\n\\t\\t\\t\\tbreak\\n\\t\\t\\theapq.heappop(segmentHeap)\\n\\t\\tif not found:\\n\\t\\t\\tans.append(0)\\n\\n\\treturn ans\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2454674,
                "title": "trieset-based-sln-o-n-log-n-with-prefix-sums",
                "content": "```\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n    const int n = size(nums);\\n    using ll = long long;\\n    vector<ll> sums(n + 1);\\n    for (int i = 0; i < n; ++i) {\\n        sums[i + 1] = sums[i] + nums[i];\\n    }\\n    set<pair<int, int>> segments;\\n    segments.emplace(0, n - 1);\\n    multiset<ll> segmentSums;\\n    segmentSums.insert(sums[n]);\\n    vector<ll> ans;\\n    for (const auto v : removeQueries) {\\n        const auto it = prev(segments.upper_bound({ v, numeric_limits<int>::max() }));\\n        int l = it->first, r = it->second;\\n        segments.erase(it);\\n        segmentSums.erase(segmentSums.find(sums[r + 1] - sums[l]));\\n        if (l != v) {\\n            segments.emplace(l, v - 1);\\n            segmentSums.insert(sums[v] - sums[l]);\\n        }\\n        if (r != v) {\\n            segments.emplace(v + 1, r);\\n            segmentSums.insert(sums[r + 1] - sums[v + 1]);\\n        }\\n        ans.push_back(empty(segmentSums) ? 0 : *prev(end(segmentSums)));\\n    }\\n    return ans;\\n}",
                "solutionTags": [],
                "code": "```\\nvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n    const int n = size(nums);\\n    using ll = long long;\\n    vector<ll> sums(n + 1);\\n    for (int i = 0; i < n; ++i) {\\n        sums[i + 1] = sums[i] + nums[i];\\n    }\\n    set<pair<int, int>> segments;\\n    segments.emplace(0, n - 1);\\n    multiset<ll> segmentSums;\\n    segmentSums.insert(sums[n]);\\n    vector<ll> ans;\\n    for (const auto v : removeQueries) {\\n        const auto it = prev(segments.upper_bound({ v, numeric_limits<int>::max() }));\\n        int l = it->first, r = it->second;\\n        segments.erase(it);\\n        segmentSums.erase(segmentSums.find(sums[r + 1] - sums[l]));\\n        if (l != v) {\\n            segments.emplace(l, v - 1);\\n            segmentSums.insert(sums[v] - sums[l]);\\n        }\\n        if (r != v) {\\n            segments.emplace(v + 1, r);\\n            segmentSums.insert(sums[r + 1] - sums[v + 1]);\\n        }\\n        ans.push_back(empty(segmentSums) ? 0 : *prev(end(segmentSums)));\\n    }\\n    return ans;\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2454651,
                "title": "simple-reverse-traversing-o-n-c",
                "content": "```\\n\\nPrerequisite :- https://leetcode.com/problems/longest-consecutive-sequence/\\n\\nvector<long long> maximumSegmentSum(vector<int>& v,vector<int>& q){\\n        long long cur=0,n=v.size();\\n        vector<long long>sum(n,0),count(n,0),ans(n,0);\\n        for(int i=n-1;i>=0;i--){\\n            ans[i]=cur;\\n            int x=q[i];\\n            \\n            long long leftsum=0,leftcount=0;\\n            if(x!=0) leftsum=sum[x-1],leftcount=count[x-1];\\n            \\n            long long rightsum=0,rightcount=0;\\n            if(x!=n-1) rightsum=sum[x+1],rightcount=count[x+1];\\n            \\n            long long cursum,curcount;\\n            cursum=v[x]+leftsum+rightsum;\\n            curcount=1+leftcount+rightcount;\\n            \\n            if(x!=0) sum[x-leftcount]=cursum,count[x-leftcount]=curcount;\\n            if(x!=n-1) sum[x+rightcount]=cursum,count[x+rightcount]=curcount;\\n            \\n            cur=max(cur,cursum);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "solutionTags": [],
                "code": "```\\n\\nPrerequisite :- https://leetcode.com/problems/longest-consecutive-sequence/\\n\\nvector<long long> maximumSegmentSum(vector<int>& v,vector<int>& q){\\n        long long cur=0,n=v.size();\\n        vector<long long>sum(n,0),count(n,0),ans(n,0);\\n        for(int i=n-1;i>=0;i--){\\n            ans[i]=cur;\\n            int x=q[i];\\n            \\n            long long leftsum=0,leftcount=0;\\n            if(x!=0) leftsum=sum[x-1],leftcount=count[x-1];\\n            \\n            long long rightsum=0,rightcount=0;\\n            if(x!=n-1) rightsum=sum[x+1],rightcount=count[x+1];\\n            \\n            long long cursum,curcount;\\n            cursum=v[x]+leftsum+rightsum;\\n            curcount=1+leftcount+rightcount;\\n            \\n            if(x!=0) sum[x-leftcount]=cursum,count[x-leftcount]=curcount;\\n            if(x!=n-1) sum[x+rightcount]=cursum,count[x+rightcount]=curcount;\\n            \\n            cur=max(cur,cursum);\\n        }\\n        return ans;\\n    }\\n\\t```",
                "codeTag": "Unknown"
            },
            {
                "id": 2454617,
                "title": "c-set-and-prefix-sum-clean-code",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<long long> ans, prefixSum(n + 1);\\n\\t\\t\\tfor(int i = 1; i <= n; i++) \\n\\t\\t\\t\\tprefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n\\t\\t\\t\\t\\n\\t\\t\\tset<pair<int, int>> setIndex;\\n\\t\\t\\tsetIndex.insert({0, n - 1});\\n\\t\\t\\t\\n\\t\\t\\tmultiset<long long> setSum;\\n\\t\\t\\tsetSum.insert(0);\\n\\t\\t\\tsetSum.insert(prefixSum[n]);\\n\\t\\t\\t\\n\\t\\t\\tfor(auto& index : removeQueries) {\\n\\t\\t\\t\\tauto it = setIndex.upper_bound({index, n});\\n\\t\\t\\t\\tit--;\\n\\t\\t\\t\\tauto [start, end] = *it;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tlong long currSum = prefixSum[end + 1] - prefixSum[start];\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tsetIndex.erase(it);\\n\\t\\t\\t\\tsetSum.erase(setSum.find(currSum));\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(end > index) {\\n\\t\\t\\t\\t\\tsetIndex.insert({index + 1, end});\\n\\t\\t\\t\\t\\tsetSum.insert(prefixSum[end + 1] - prefixSum[index + 1]);\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\t\\n\\t\\t\\t\\tif(start < index) {\\n\\t\\t\\t\\t\\tsetIndex.insert({start, index - 1});\\n\\t\\t\\t\\t\\tsetSum.insert(prefixSum[index] - prefixSum[start]);               \\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tlong long currMax = *setSum.rbegin();\\n\\t\\t\\t\\tans.push_back(currMax);\\n\\t\\t\\t}\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tvector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n\\t\\t\\tint n = nums.size();\\n\\t\\t\\tvector<long long> ans, prefixSum(n + 1);\\n\\t\\t\\tfor(int i = 1; i <= n; i++) \\n\\t\\t\\t\\tprefixSum[i] = prefixSum[i - 1] + nums[i - 1];\\n\\t\\t\\t\\t\\n\\t\\t\\tset<pair<int, int>> setIndex;\\n\\t\\t\\tsetIndex.insert({0, n - 1}",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 2053313,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Hint:\\n1. traverse from back to front of removeQueries and use \"Union find\" to add each element to the group\\n2.  keep track the \"max segmention sum\" when doing Union"
                    },
                    {
                        "username": "GandhiHarsh",
                        "content": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<long long > ans;      \\n        int n=nums.size();\\n        vector<long long> pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n\\n        }\\n        set<int> s;\\n        multiset<long long> st;\\n        s.insert(-1);\\n        st.insert(pre[n-1]);\\n        st.insert(0);\\n        for(auto x: removeQueries){\\n            auto it=lower_bound(s.begin(),s.end(),x);\\n            int left,right;\\n            if(it==s.end()){\\n                right=n-1;\\n            }else{\\n                right=(*it)-1;\\n            }\\n            it--;\\n            left=(*it);\\n            auto it2=st.begin();\\n            if(left==-1){\\n                it2=st.find(pre[right]);\\n            }else{\\n                it2=st.find(pre[right]-pre[left]);\\n            }\\n            st.erase(it2);\\n            if(pre[right]-pre[x]!=0)\\n                st.insert(pre[right]-pre[x]);\\n            if(x!=0){\\n                if(left==-1){\\n                    st.insert(pre[x-1] );\\n                }else{\\n                    if(pre[x-1]-pre[left]!=0)\\n                        st.insert(pre[x-1]-pre[left]);\\n                    \\n                }\\n            }\\n            it2=st.end();\\n            it2--;\\n            \\n            ans.push_back(*it2);\\n            s.insert(x);\\n        }\\n        return ans;\\n    }\\n}; `your inline code...your inline code...`\\ncan anyone plz tell me why is it giving me tle"
                    },
                    {
                        "username": "Finesse",
                        "content": "The hints, which tell to make a data structure for storing removal points (binary search tree) and use a heap to find maximum sums, lead to an inefficient solution that doesn't pass in Python.\n\nThis was my initial idea. I implemented the following algorithm:\n1. Create a prefix sum array for `nums`\n2. Walk the remove queries forward\n    1. For each query find the nearest left and right queries in the BST\n    2. These 2 numbers (left, right) form a segment, that must be removed from the heap because it's split by the query. But since you can't remove an arbitrary heap element faster than `O(n)`, add the segment boundaries to a set instead.\n    3. These 3 numbers (left, query, right) form 2 sub-segments. Find their sums using the prefix sum array (takes `O(1)`). Put the sums into the heap together with their segment boundaries.\n    4. Put the query into the BST\n    5. Get biggest element in the heap. If it's in the set (of removed segments), pop it from the queue. Keep popping until a not removed segment is found. Put that sum to the result array (don't remove it from the heap).\n\nThe problem is that in test cases where the remove queries array is just `[0, 1, 2, 3, ...]`, the BST is very inefficient, even if you balance it times to times. A more tricky BST that joins consecutive numbers can be made, but it's a dead end because there is a much easier and more performant way to solve the problem."
                    }
                ]
            },
            {
                "id": 1960982,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Hint:\\n1. traverse from back to front of removeQueries and use \"Union find\" to add each element to the group\\n2.  keep track the \"max segmention sum\" when doing Union"
                    },
                    {
                        "username": "GandhiHarsh",
                        "content": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<long long > ans;      \\n        int n=nums.size();\\n        vector<long long> pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n\\n        }\\n        set<int> s;\\n        multiset<long long> st;\\n        s.insert(-1);\\n        st.insert(pre[n-1]);\\n        st.insert(0);\\n        for(auto x: removeQueries){\\n            auto it=lower_bound(s.begin(),s.end(),x);\\n            int left,right;\\n            if(it==s.end()){\\n                right=n-1;\\n            }else{\\n                right=(*it)-1;\\n            }\\n            it--;\\n            left=(*it);\\n            auto it2=st.begin();\\n            if(left==-1){\\n                it2=st.find(pre[right]);\\n            }else{\\n                it2=st.find(pre[right]-pre[left]);\\n            }\\n            st.erase(it2);\\n            if(pre[right]-pre[x]!=0)\\n                st.insert(pre[right]-pre[x]);\\n            if(x!=0){\\n                if(left==-1){\\n                    st.insert(pre[x-1] );\\n                }else{\\n                    if(pre[x-1]-pre[left]!=0)\\n                        st.insert(pre[x-1]-pre[left]);\\n                    \\n                }\\n            }\\n            it2=st.end();\\n            it2--;\\n            \\n            ans.push_back(*it2);\\n            s.insert(x);\\n        }\\n        return ans;\\n    }\\n}; `your inline code...your inline code...`\\ncan anyone plz tell me why is it giving me tle"
                    },
                    {
                        "username": "Finesse",
                        "content": "The hints, which tell to make a data structure for storing removal points (binary search tree) and use a heap to find maximum sums, lead to an inefficient solution that doesn't pass in Python.\n\nThis was my initial idea. I implemented the following algorithm:\n1. Create a prefix sum array for `nums`\n2. Walk the remove queries forward\n    1. For each query find the nearest left and right queries in the BST\n    2. These 2 numbers (left, right) form a segment, that must be removed from the heap because it's split by the query. But since you can't remove an arbitrary heap element faster than `O(n)`, add the segment boundaries to a set instead.\n    3. These 3 numbers (left, query, right) form 2 sub-segments. Find their sums using the prefix sum array (takes `O(1)`). Put the sums into the heap together with their segment boundaries.\n    4. Put the query into the BST\n    5. Get biggest element in the heap. If it's in the set (of removed segments), pop it from the queue. Keep popping until a not removed segment is found. Put that sum to the result array (don't remove it from the heap).\n\nThe problem is that in test cases where the remove queries array is just `[0, 1, 2, 3, ...]`, the BST is very inefficient, even if you balance it times to times. A more tricky BST that joins consecutive numbers can be made, but it's a dead end because there is a much easier and more performant way to solve the problem."
                    }
                ]
            },
            {
                "id": 1746302,
                "content": [
                    {
                        "username": "chandleryeh",
                        "content": "Hint:\\n1. traverse from back to front of removeQueries and use \"Union find\" to add each element to the group\\n2.  keep track the \"max segmention sum\" when doing Union"
                    },
                    {
                        "username": "GandhiHarsh",
                        "content": "class Solution {\\npublic:\\n    vector<long long> maximumSegmentSum(vector<int>& nums, vector<int>& removeQueries) {\\n        vector<long long > ans;      \\n        int n=nums.size();\\n        vector<long long> pre(n,0);\\n        pre[0]=nums[0];\\n        for(int i=1;i<n;i++){\\n            pre[i]=pre[i-1]+nums[i];\\n\\n        }\\n        set<int> s;\\n        multiset<long long> st;\\n        s.insert(-1);\\n        st.insert(pre[n-1]);\\n        st.insert(0);\\n        for(auto x: removeQueries){\\n            auto it=lower_bound(s.begin(),s.end(),x);\\n            int left,right;\\n            if(it==s.end()){\\n                right=n-1;\\n            }else{\\n                right=(*it)-1;\\n            }\\n            it--;\\n            left=(*it);\\n            auto it2=st.begin();\\n            if(left==-1){\\n                it2=st.find(pre[right]);\\n            }else{\\n                it2=st.find(pre[right]-pre[left]);\\n            }\\n            st.erase(it2);\\n            if(pre[right]-pre[x]!=0)\\n                st.insert(pre[right]-pre[x]);\\n            if(x!=0){\\n                if(left==-1){\\n                    st.insert(pre[x-1] );\\n                }else{\\n                    if(pre[x-1]-pre[left]!=0)\\n                        st.insert(pre[x-1]-pre[left]);\\n                    \\n                }\\n            }\\n            it2=st.end();\\n            it2--;\\n            \\n            ans.push_back(*it2);\\n            s.insert(x);\\n        }\\n        return ans;\\n    }\\n}; `your inline code...your inline code...`\\ncan anyone plz tell me why is it giving me tle"
                    },
                    {
                        "username": "Finesse",
                        "content": "The hints, which tell to make a data structure for storing removal points (binary search tree) and use a heap to find maximum sums, lead to an inefficient solution that doesn't pass in Python.\n\nThis was my initial idea. I implemented the following algorithm:\n1. Create a prefix sum array for `nums`\n2. Walk the remove queries forward\n    1. For each query find the nearest left and right queries in the BST\n    2. These 2 numbers (left, right) form a segment, that must be removed from the heap because it's split by the query. But since you can't remove an arbitrary heap element faster than `O(n)`, add the segment boundaries to a set instead.\n    3. These 3 numbers (left, query, right) form 2 sub-segments. Find their sums using the prefix sum array (takes `O(1)`). Put the sums into the heap together with their segment boundaries.\n    4. Put the query into the BST\n    5. Get biggest element in the heap. If it's in the set (of removed segments), pop it from the queue. Keep popping until a not removed segment is found. Put that sum to the result array (don't remove it from the heap).\n\nThe problem is that in test cases where the remove queries array is just `[0, 1, 2, 3, ...]`, the BST is very inefficient, even if you balance it times to times. A more tricky BST that joins consecutive numbers can be made, but it's a dead end because there is a much easier and more performant way to solve the problem."
                    }
                ]
            }
        ]
    },
    {
        "title": "Minimum Hours of Training to Win a Competition",
        "question_content": "<p>You are entering a competition, and are given two <strong>positive</strong> integers <code>initialEnergy</code> and <code>initialExperience</code> denoting your initial energy and initial experience respectively.</p>\n\n<p>You are also given two <strong>0-indexed</strong> integer arrays <code>energy</code> and <code>experience</code>, both of length <code>n</code>.</p>\n\n<p>You will face <code>n</code> opponents <strong>in order</strong>. The energy and experience of the <code>i<sup>th</sup></code> opponent is denoted by <code>energy[i]</code> and <code>experience[i]</code> respectively. When you face an opponent, you need to have both <strong>strictly</strong> greater experience and energy to defeat them and move to the next opponent if available.</p>\n\n<p>Defeating the <code>i<sup>th</sup></code> opponent <strong>increases</strong> your experience by <code>experience[i]</code>, but <strong>decreases</strong> your energy by <code>energy[i]</code>.</p>\n\n<p>Before starting the competition, you can train for some number of hours. After each hour of training, you can <strong>either</strong> choose to increase your initial experience by one, or increase your initial energy by one.</p>\n\n<p>Return <em>the <strong>minimum</strong> number of training hours required to defeat all </em><code>n</code><em> opponents</em>.</p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> initialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]\n<strong>Output:</strong> 8\n<strong>Explanation:</strong> You can increase your energy to 11 after 6 hours of training, and your experience to 5 after 2 hours of training.\nYou face the opponents in the following order:\n- You have more energy and experience than the 0<sup>th</sup> opponent so you win.\n  Your energy becomes 11 - 1 = 10, and your experience becomes 5 + 2 = 7.\n- You have more energy and experience than the 1<sup>st</sup> opponent so you win.\n  Your energy becomes 10 - 4 = 6, and your experience becomes 7 + 6 = 13.\n- You have more energy and experience than the 2<sup>nd</sup> opponent so you win.\n  Your energy becomes 6 - 3 = 3, and your experience becomes 13 + 3 = 16.\n- You have more energy and experience than the 3<sup>rd</sup> opponent so you win.\n  Your energy becomes 3 - 2 = 1, and your experience becomes 16 + 1 = 17.\nYou did a total of 6 + 2 = 8 hours of training before the competition, so we return 8.\nIt can be proven that no smaller answer exists.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> initialEnergy = 2, initialExperience = 4, energy = [1], experience = [3]\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> You do not need any additional energy or experience to win the competition, so we return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>n == energy.length == experience.length</code></li>\n\t<li><code>1 &lt;= n &lt;= 100</code></li>\n\t<li><code>1 &lt;= initialEnergy, initialExperience, energy[i], experience[i] &lt;= 100</code></li>\n</ul>\n",
        "solutions": [
            {
                "id": 2456694,
                "title": "easy-understanding-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ie, int ig, vector<int>& energy, vector<int>& experience) \\n    {\\n        int hours = 0;\\n        for (int i = 0; i < energy.size(); i++)\\n        {\\n            if (energy[i] >= ie)\\n            {\\n                hours += energy[i] - ie + 1;\\n                ie += energy[i] - ie + 1;\\n            }\\n            if (experience[i] >= ig)\\n            {\\n                hours += experience[i] - ig + 1;\\n                ig += experience[i] - ig + 1;\\n            }\\n\\t\\t\\t// At the end increase the experience by experience[i] and decrease the energy by energy[i].\\n            ie -= energy[i];\\n            ig += experience[i];\\n        }\\n        return hours;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ie, int ig, vector<int>& energy, vector<int>& experience) \\n    {\\n        int hours = 0;\\n        for (int i = 0; i < energy.size(); i++)\\n        {\\n            if (energy[i] >= ie)\\n            {\\n                hours += energy[i] - ie + 1;\\n                ie += energy[i] - ie + 1;\\n            }\\n            if (experience[i] >= ig)\\n            {\\n                hours += experience[i] - ig + 1;\\n                ig += experience[i] - ig + 1;\\n            }\\n\\t\\t\\t// At the end increase the experience by experience[i] and decrease the energy by energy[i].\\n            ie -= energy[i];\\n            ig += experience[i];\\n        }\\n        return hours;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456630,
                "title": "c-easy-self-explanatory-faster-than-100-00",
                "content": "**Do UPVOTE if it helps :)**\\n\\n```\\nint minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int sum=0,a=0,cnt=0;\\n        for(int i : energy) sum+=i;\\n        if(sum>= initialEnergy) a = sum-initialEnergy+1;\\n        for(int i=0;i<size(experience);i++)\\n        {\\n            if(experience[i]>=initialExperience) {\\n                int temp = experience[i]-initialExperience+1;\\n                cnt+=temp;\\n                initialExperience+=temp+experience[i];\\n            }\\n            else initialExperience+=experience[i];\\n        }\\n        return a+cnt;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int sum=0,a=0,cnt=0;\\n        for(int i : energy) sum+=i;\\n        if(sum>= initialEnergy) a = sum-initialEnergy+1;\\n        for(int i=0;i<size(experience);i++)\\n        {\\n            if(experience[i]>=initialExperience) {\\n                int temp = experience[i]-initialExperience+1;\\n                cnt+=temp;\\n                initialExperience+=temp+experience[i];\\n            }\\n            else initialExperience+=experience[i];\\n        }\\n        return a+cnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2457243,
                "title": "easy-c-train-and-fight-clean-fast-and-friendly-code-tc-o-n-sc-o-1",
                "content": "The main idea here is to arrange the \" **if\\'s** \" properly. The first \\' if \\' will check if we have enough **Energy** and **Experience** , we train accordingly and then we move on to fight the opponent.\\nNext is losing energy and gaining experience after fighting every opponent.\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n = energy.size();     // since energy and experience arrays are of same size\\n        int trainingHours = 0;\\n        \\n        for (int i = 0; i < n; ++i) {\\n\\t\\t\\t// TRAIN if needed\\n            if (initialEnergy <= energy[i]) {\\n                int difference = energy[i] - initialEnergy;\\n                initialEnergy += difference + 1;\\n                trainingHours += difference + 1;\\n            }\\n            if (initialExperience <= experience[i]) {\\n                int difference = experience[i] - initialExperience;\\n                initialExperience += difference + 1;\\n                trainingHours += difference + 1;\\n            }\\n            \\n\\t\\t\\t// FIGHT because you got to!\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        }\\n        return trainingHours;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n = energy.size();     // since energy and experience arrays are of same size\\n        int trainingHours = 0;\\n        \\n        for (int i = 0; i < n; ++i) {\\n\\t\\t\\t// TRAIN if needed\\n            if (initialEnergy <= energy[i]) {\\n                int difference = energy[i] - initialEnergy;\\n                initialEnergy += difference + 1;\\n                trainingHours += difference + 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2456744,
                "title": "java-easy-to-understand-solution-with-explanation-o-n",
                "content": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int n = energy.length;\\n        int sum = 0;\\n        int res = 0;\\n\\t\\t//the energy needed is the total sum \\n        for (int i : energy) {\\n            sum += i;\\n        }\\n        res += sum - initialEnergy >= 0 ? sum - initialEnergy + 1: 0;\\n        // if curExp < opponents\\u2018 exp, we need to study to earn more\\n        for (int i : experience) {\\n            if (initialExperience <= i) {\\n                res += i - initialExperience + 1;\\n                initialExperience = i + 1;\\n            }\\n            initialExperience += i;\\n        }\\n        return res;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int n = energy.length;\\n        int sum = 0;\\n        int res = 0;\\n\\t\\t//the energy needed is the total sum \\n        for (int i : energy) {\\n            sum += i;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2464962,
                "title": "prefix-sum",
                "content": "The energy is simple - we just need the sum of energy of all opponents, plus one.\\n\\nThe experience is trickier, as it depends on the order of opponents.\\n\\n**C++**\\n```cpp\\nint minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n    int need_exp = 0, cur_exp = initialExperience;\\n    for (int i = 0; i < experience.size();  cur_exp += experience[i++])\\n        need_exp += max(experience[i] - need_exp - cur_exp + 1, 0);\\n    return max(accumulate(begin(energy), end(energy), 1) - initialEnergy, 0) + need_exp;\\n}\\n```\\n\\nNo raw loops version, just for fun. It\\'s neither shorter nor more efficient, just wanted to see if it can be done.\\n\\nWe use prefix sum (partial sum) and transform to compute additional experience we need for each opponent.\\n\\n**C++**\\n```cpp\\nint minNumberOfHours(int initialEnergy, int initialExp, vector<int>& energy, vector<int>& exp) {\\n    vector<int> ps;\\n    partial_sum(begin(exp), end(exp), back_inserter(ps));\\n    transform(begin(ps) + 1, end(ps), begin(ps), begin(exp) + 1, [](int pa, int pb) { return max(pa - 2 * pb, 0); });\\n    return max(accumulate(begin(energy), end(energy), 1) - initialEnergy, 0) + \\n        max(accumulate(begin(exp), end(exp), 0, [](int need, int delta) { return need + max(delta - need + 1, 0); }) - initialExp, 0);\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n    int need_exp = 0, cur_exp = initialExperience;\\n    for (int i = 0; i < experience.size();  cur_exp += experience[i++])\\n        need_exp += max(experience[i] - need_exp - cur_exp + 1, 0);\\n    return max(accumulate(begin(energy), end(energy), 1) - initialEnergy, 0) + need_exp;\\n}\\n```\n```cpp\\nint minNumberOfHours(int initialEnergy, int initialExp, vector<int>& energy, vector<int>& exp) {\\n    vector<int> ps;\\n    partial_sum(begin(exp), end(exp), back_inserter(ps));\\n    transform(begin(ps) + 1, end(ps), begin(ps), begin(exp) + 1, [](int pa, int pb) { return max(pa - 2 * pb, 0); });\\n    return max(accumulate(begin(energy), end(energy), 1) - initialEnergy, 0) + \\n        max(accumulate(begin(exp), end(exp), 0, [](int need, int delta) { return need + max(delta - need + 1, 0); }) - initialExp, 0);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2456759,
                "title": "python-easy-approach",
                "content": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        \\n        ans = 0\\n        n = len(energy)\\n\\n        for i in range(n):\\n            while initialEnergy <= energy[i] or initialExperience <= experience[i]:\\n                if initialEnergy <= energy[i]:\\n                    initialEnergy += 1\\n                    ans += 1\\n                if initialExperience <= experience[i]:\\n                    initialExperience += 1\\n                    ans += 1\\n            initialEnergy -= energy[i]\\n            initialExperience += experience[i]\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        \\n        ans = 0\\n        n = len(energy)\\n\\n        for i in range(n):\\n            while initialEnergy <= energy[i] or initialExperience <= experience[i]:\\n                if initialEnergy <= energy[i]:\\n                    initialEnergy += 1\\n                    ans += 1\\n                if initialExperience <= experience[i]:\\n                    initialExperience += 1\\n                    ans += 1\\n            initialEnergy -= energy[i]\\n            initialExperience += experience[i]\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459984,
                "title": "simulation",
                "content": "##### Java\\n```java\\npublic int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hours = 0, currentEnergy = initialEnergy, currentExperience = initialExperience;\\n\\n        for (int opponent = 0; opponent < energy.length; opponent++) {\\n            if (energy[opponent] >= currentEnergy) {\\n                int energyDifference = energy[opponent] - currentEnergy;\\n                hours += energyDifference + 1;\\n                currentEnergy += energyDifference + 1;\\n            }\\n            \\n            if (experience[opponent] >= currentExperience) {\\n                int experienceDifference = experience[opponent] - currentExperience;\\n                hours += experienceDifference + 1;\\n                currentExperience += experienceDifference + 1;\\n            }\\n            \\n            currentEnergy -= energy[opponent];\\n            currentExperience += experience[opponent];\\n        }\\n\\n        return hours;\\n    }\\n```\\n\\n##### C++\\n```c++\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int hours = 0, currentEnergy = initialEnergy, currentExperience = initialExperience;\\n\\n        for (int opponent = 0; opponent < energy.size(); opponent++) {\\n            if (energy[opponent] >= currentEnergy) {\\n                int energyDifference = energy[opponent] - currentEnergy;\\n                hours += energyDifference + 1;\\n                currentEnergy += energyDifference + 1;\\n            }\\n\\n            if (experience[opponent] >= currentExperience) {\\n                int experienceDifference = experience[opponent] - currentExperience;\\n                hours += experienceDifference + 1;\\n                currentExperience += experienceDifference + 1;\\n            }\\n\\n            currentEnergy -= energy[opponent];\\n            currentExperience += experience[opponent];\\n        }\\n\\n        return hours;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "C"
                ],
                "code": "```java\\npublic int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hours = 0, currentEnergy = initialEnergy, currentExperience = initialExperience;\\n\\n        for (int opponent = 0; opponent < energy.length; opponent++) {\\n            if (energy[opponent] >= currentEnergy) {\\n                int energyDifference = energy[opponent] - currentEnergy;\\n                hours += energyDifference + 1;\\n                currentEnergy += energyDifference + 1;\\n            }\\n            \\n            if (experience[opponent] >= currentExperience) {\\n                int experienceDifference = experience[opponent] - currentExperience;\\n                hours += experienceDifference + 1;\\n                currentExperience += experienceDifference + 1;\\n            }\\n            \\n            currentEnergy -= energy[opponent];\\n            currentExperience += experience[opponent];\\n        }\\n\\n        return hours;\\n    }\\n```\n```c++\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int hours = 0, currentEnergy = initialEnergy, currentExperience = initialExperience;\\n\\n        for (int opponent = 0; opponent < energy.size(); opponent++) {\\n            if (energy[opponent] >= currentEnergy) {\\n                int energyDifference = energy[opponent] - currentEnergy;\\n                hours += energyDifference + 1;\\n                currentEnergy += energyDifference + 1;\\n            }\\n\\n            if (experience[opponent] >= currentExperience) {\\n                int experienceDifference = experience[opponent] - currentExperience;\\n                hours += experienceDifference + 1;\\n                currentExperience += experienceDifference + 1;\\n            }\\n\\n            currentEnergy -= energy[opponent];\\n            currentExperience += experience[opponent];\\n        }\\n\\n        return hours;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2456773,
                "title": "python-greedy-o-n",
                "content": "Explained the variable names in code with comment.\\n<hr />\\n\\nThe idea is to just greedily simulate the process.\\n\\nWhenever we don\\'t have enough energy to move to the next stage, we add the minimum required to have +1 energy, and the same for experience.\\n\\nThen we add the experience from the current stage, and reduce the enery from the current stage as required by the problem.\\n\\nAt the end, we added X energy, and Y experience. So we return the sum, minus the initial starting values we had. \\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        en = 0 # Energy\\n        ex = 0 # Experience\\n        \\n        an = 0 # Added energy\\n        ax = 0 # Added experience\\n       \\n        for ener, exp in zip(energy, experience):\\n            if ener >= en:\\n                an += (ener - en + 1)\\n                en += (ener - en + 1)\\n            if exp >= ex:\\n                ax += (exp - ex + 1)\\n                ex += (exp - ex + 1)\\n            \\n            en -= ener\\n            ex += exp\\n            \\n        return max(0, (an - initialEnergy)) + max(0, (ax - initialExperience))\\n```",
                "solutionTags": [
                    "Python",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        en = 0 # Energy\\n        ex = 0 # Experience\\n        \\n        an = 0 # Added energy\\n        ax = 0 # Added experience\\n       \\n        for ener, exp in zip(energy, experience):\\n            if ener >= en:\\n                an += (ener - en + 1)\\n                en += (ener - en + 1)\\n            if exp >= ex:\\n                ax += (exp - ex + 1)\\n                ex += (exp - ex + 1)\\n            \\n            en -= ener\\n            ex += exp\\n            \\n        return max(0, (an - initialEnergy)) + max(0, (ax - initialExperience))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456645,
                "title": "java-solution",
                "content": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int currentEnergy = initialEnergy;\\n        int currentExperience = initialExperience;\\n        int result = 0;\\n        int diff = 0;\\n        for (int i = 0; i < energy.length; i++) {\\n            if (energy[i] >= currentEnergy) {   \\n                diff = energy[i] - currentEnergy + 1;\\n                result = result + diff;\\n                currentEnergy = currentEnergy + diff;\\n            }\\n            currentEnergy = currentEnergy - energy[i];\\n            if (experience[i] >= currentExperience) {\\n                diff = experience[i] - currentExperience + 1;\\n                result = result + diff;\\n                currentExperience = currentExperience + diff;\\n            }\\n            currentExperience = currentExperience + experience[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int currentEnergy = initialEnergy;\\n        int currentExperience = initialExperience;\\n        int result = 0;\\n        int diff = 0;\\n        for (int i = 0; i < energy.length; i++) {\\n            if (energy[i] >= currentEnergy) {   \\n                diff = energy[i] - currentEnergy + 1;\\n                result = result + diff;\\n                currentEnergy = currentEnergy + diff;\\n            }\\n            currentEnergy = currentEnergy - energy[i];\\n            if (experience[i] >= currentExperience) {\\n                diff = experience[i] - currentExperience + 1;\\n                result = result + diff;\\n                currentExperience = currentExperience + diff;\\n            }\\n            currentExperience = currentExperience + experience[i];\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456624,
                "title": "c-simple-efficient-solution",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int minNumberOfHours(int i, int e, vector<int>& ener, vector<int>& exp) \\n    {\\n        int cnt=0, diff;\\n        for(int k=0; k<ener.size(); k++)\\n        {\\n            if(i<=ener[k])\\n            {\\n                diff = (ener[k]-i+1);\\n                i += diff;\\n                cnt += diff;\\n            }\\n            if(e<=exp[k])\\n            {\\n                diff = (exp[k]-e+1);\\n                e += diff;\\n                cnt += diff;\\n            }\\n            \\n            i -= ener[k];\\n            e += exp[k];\\n                \\n        }\\n        return cnt;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int minNumberOfHours(int i, int e, vector<int>& ener, vector<int>& exp) \\n    {\\n        int cnt=0, diff;\\n        for(int k=0; k<ener.size(); k++)\\n        {\\n            if(i<=ener[k])\\n            {\\n                diff = (ener[k]-i+1);\\n                i += diff;\\n                cnt += diff;\\n            }\\n            if(e<=exp[k])\\n            {\\n                diff = (exp[k]-e+1);\\n                e += diff;\\n                cnt += diff;\\n            }\\n            \\n            i -= ener[k];\\n            e += exp[k];\\n                \\n        }\\n        return cnt;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2722230,
                "title": "python-java-elegant-short-one-pass",
                "content": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(1)\\n    \"\"\"\\n\\n    def minNumberOfHours(self, energy: int, experience: int, energies: List[int], experiences: List[int]) -> int:\\n        hours = 0\\n\\n        for eng, exp in zip(energies, experiences):\\n            # Adding the missing amount of energy\\n            extra_en = max(0, eng - energy + 1)\\n            energy += extra_en\\n\\n            # Adding the missing amount of experience\\n            extra_ex = max(0, exp - experience + 1)\\n            experience += extra_ex\\n\\n            energy -= eng\\n            experience += exp\\n            hours += extra_en + extra_ex\\n\\n        return hours\\n```\\n\\n```\\npublic class Solution {\\n\\n    /**\\n     * Time:   O(n)\\n     * Memory: O(1)\\n     */\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hours = 0;\\n\\n        for (int i = 0; i < energy.length; ++i) {\\n            // Adding the missing amount of energy\\n            int extraEnergy = Math.max(0, energy[i] - initialEnergy + 1);\\n            initialEnergy += extraEnergy;\\n\\n            // Adding the missing amount of experience\\n            int extraExperience = Math.max(0, experience[i] - initialExperience + 1);\\n            initialExperience += extraExperience;\\n\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n\\n            hours += extraEnergy + extraExperience;\\n        }\\n\\n        return hours;\\n    }\\n}\\n```\\n\\nIf you like this solution remember to **upvote it** to let me know.\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    \"\"\"\\n    Time:   O(n)\\n    Memory: O(1)\\n    \"\"\"\\n\\n    def minNumberOfHours(self, energy: int, experience: int, energies: List[int], experiences: List[int]) -> int:\\n        hours = 0\\n\\n        for eng, exp in zip(energies, experiences):\\n            # Adding the missing amount of energy\\n            extra_en = max(0, eng - energy + 1)\\n            energy += extra_en\\n\\n            # Adding the missing amount of experience\\n            extra_ex = max(0, exp - experience + 1)\\n            experience += extra_ex\\n\\n            energy -= eng\\n            experience += exp\\n            hours += extra_en + extra_ex\\n\\n        return hours\\n```\n```\\npublic class Solution {\\n\\n    /**\\n     * Time:   O(n)\\n     * Memory: O(1)\\n     */\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hours = 0;\\n\\n        for (int i = 0; i < energy.length; ++i) {\\n            // Adding the missing amount of energy\\n            int extraEnergy = Math.max(0, energy[i] - initialEnergy + 1);\\n            initialEnergy += extraEnergy;\\n\\n            // Adding the missing amount of experience\\n            int extraExperience = Math.max(0, experience[i] - initialExperience + 1);\\n            initialExperience += extraExperience;\\n\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n\\n            hours += extraEnergy + extraExperience;\\n        }\\n\\n        return hours;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2600984,
                "title": "python-c-java-beginner-level-simple-short-solution-greedy-approach",
                "content": "***Please upvote to motivate me in my quest of documenting all leetcode solutions. HAPPY CODING:)\\nAny suggestions and improvements are always welcome*.**\\n___________________\\n_________________\\n***Q2383. Minimum Hours of Training to Win a Competition***\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **Python  Code** :\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        traning = 0\\n        totalEnergy = sum(energy)\\n        if initialEnergy <= totalEnergy:\\n            traning += (totalEnergy - initialEnergy + 1)\\n        for opponentExperience in experience:\\n            if initialExperience <= opponentExperience:\\n                traning += (opponentExperience - initialExperience + 1)\\n                initialExperience = opponentExperience + 1\\n            initialExperience += opponentExperience\\n            \\n        return traning\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\n\\u2705 **Java Code** :\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int traning=0,n=energy.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(energy[i]>=initialEnergy)\\n            {\\n                int diff=energy[i]-initialEnergy;\\n                traning+=diff+1;\\n                initialEnergy+=diff+1;\\n            }\\n            if(experience[i]>=initialExperience)\\n            {\\n                int diff=experience[i]-initialExperience;\\n                traning+=diff+1;\\n                initialExperience+=diff+1;\\n            }\\n            initialEnergy-=energy[i];\\n            initialExperience+=experience[i];\\n        }\\n        return traning;\\n    }\\n    \\n}\\n```\\n\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\n\\u2705 **C++  Code** :\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int traning=0,n=energy.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(energy[i]>=initialEnergy)\\n            {\\n                int diff=energy[i]-initialEnergy;\\n                traning+=diff+1;\\n                initialEnergy+=diff+1;\\n            }\\n            if(experience[i]>=initialExperience)\\n            {\\n                int diff=experience[i]-initialExperience;\\n                traning+=diff+1;\\n                initialExperience+=diff+1;\\n            }\\n            initialEnergy-=energy[i];\\n            initialExperience+=experience[i];\\n        }\\n        return traning;\\n    }\\n};\\n```\\n____________________________________________________________________________________________________________________\\n____________________________________________________________________________________________________________________\\nIf you like the solution, please upvote \\uD83D\\uDD3C\\nFor any questions, or discussions, comment below. \\uD83D\\uDC47\\uFE0F\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        traning = 0\\n        totalEnergy = sum(energy)\\n        if initialEnergy <= totalEnergy:\\n            traning += (totalEnergy - initialEnergy + 1)\\n        for opponentExperience in experience:\\n            if initialExperience <= opponentExperience:\\n                traning += (opponentExperience - initialExperience + 1)\\n                initialExperience = opponentExperience + 1\\n            initialExperience += opponentExperience\\n            \\n        return traning\\n```\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int traning=0,n=energy.length;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(energy[i]>=initialEnergy)\\n            {\\n                int diff=energy[i]-initialEnergy;\\n                traning+=diff+1;\\n                initialEnergy+=diff+1;\\n            }\\n            if(experience[i]>=initialExperience)\\n            {\\n                int diff=experience[i]-initialExperience;\\n                traning+=diff+1;\\n                initialExperience+=diff+1;\\n            }\\n            initialEnergy-=energy[i];\\n            initialExperience+=experience[i];\\n        }\\n        return traning;\\n    }\\n    \\n}\\n```\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int traning=0,n=energy.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(energy[i]>=initialEnergy)\\n            {\\n                int diff=energy[i]-initialEnergy;\\n                traning+=diff+1;\\n                initialEnergy+=diff+1;\\n            }\\n            if(experience[i]>=initialExperience)\\n            {\\n                int diff=experience[i]-initialExperience;\\n                traning+=diff+1;\\n                initialExperience+=diff+1;\\n            }\\n            initialEnergy-=energy[i];\\n            initialExperience+=experience[i];\\n        }\\n        return traning;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460220,
                "title": "python-solution",
                "content": "- for energy:\\n\\t- get sum of opponent energy and calculate hours needed to have at least one more energy\\n- for experience\\n\\t- iterate through each opponentj\\n\\t\\t- if experience is not greater\\n\\t\\t\\t- add hours so experience is one greater\\n\\t\\t- add opponent experience\\n\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        hours = 0\\n        totalEnergy = sum(energy)\\n        if initialEnergy <= totalEnergy:\\n            hours += (totalEnergy - initialEnergy + 1)\\n        for opponentExperience in experience:\\n            if initialExperience <= opponentExperience:\\n                hours += (opponentExperience - initialExperience + 1)\\n                initialExperience = opponentExperience + 1\\n            initialExperience += opponentExperience\\n            \\n        return hours\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        hours = 0\\n        totalEnergy = sum(energy)\\n        if initialEnergy <= totalEnergy:\\n            hours += (totalEnergy - initialEnergy + 1)\\n        for opponentExperience in experience:\\n            if initialExperience <= opponentExperience:\\n                hours += (opponentExperience - initialExperience + 1)\\n                initialExperience = opponentExperience + 1\\n            initialExperience += opponentExperience\\n            \\n        return hours\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456641,
                "title": "c-greedy-approach-o-n",
                "content": "**Connect with me on LinkedIn**: https://www.linkedin.com/in/abhay5349singh/\\n\\n**Approach**:\\n1. at each step gaining just enough energy & experience to win over current opponent\\n2. in end, if initialEnergy > 1, we can reduce \\' initialEnergy -1 \\' amount of training time \\n```\\nclass Solution {\\npublic:\\n\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n=energy.size();\\n        \\n        int time=0;\\n        for(int i=0;i<n;i++){\\n            int d1 = initialEnergy-energy[i], d2 = initialExperience-experience[i];\\n            \\n            time += (d1<=0 ? abs(d1)+1:0) + (d2<=0 ? abs(d2)+1:0); // adding \\' +1\\' as we need strictly greater energy & experience\\n            \\n            initialEnergy = max(initialEnergy-energy[i],1);\\n            initialExperience += experience[i] + (d2<=0 ? abs(d2)+1:0);\\n        }\\n        \\n        time -= (initialEnergy-1);\\n        \\n        return max(time,0);\\n    }\\n};\\n```\\n\\n**Do UPVOTE if it helps :)**",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n=energy.size();\\n        \\n        int time=0;\\n        for(int i=0;i<n;i++){\\n            int d1 = initialEnergy-energy[i], d2 = initialExperience-experience[i];\\n            \\n            time += (d1<=0 ? abs(d1)+1:0) + (d2<=0 ? abs(d2)+1:0); // adding \\' +1\\' as we need strictly greater energy & experience\\n            \\n            initialEnergy = max(initialEnergy-energy[i],1);\\n            initialExperience += experience[i] + (d2<=0 ? abs(d2)+1:0);\\n        }\\n        \\n        time -= (initialEnergy-1);\\n        \\n        return max(time,0);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504679,
                "title": "c-solution-greedy-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int iniEne, int iniExp, vector<int>& ene, vector<int>& exp) {\\n        int sumEne=0;\\n        int ans=0;\\n        for(int i=0;i<size(ene);i++)\\n        {\\n            sumEne+=ene[i];\\n        }\\n        if(sumEne>=iniEne)\\n        {\\n            ans+=(sumEne-iniEne)+1;\\n        }\\n        for(int i=0;i<size(exp);i++)\\n        {\\n            if(iniExp>exp[i])\\n                iniExp+=exp[i];\\n            else\\n            {\\n                ans+=(exp[i]-iniExp)+1;\\n                iniExp+=((exp[i]-iniExp)+1)+exp[i];\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int iniEne, int iniExp, vector<int>& ene, vector<int>& exp) {\\n        int sumEne=0;\\n        int ans=0;\\n        for(int i=0;i<size(ene);i++)\\n        {\\n            sumEne+=ene[i];\\n        }\\n        if(sumEne>=iniEne)\\n        {\\n            ans+=(sumEne-iniEne)+1;\\n        }\\n        for(int i=0;i<size(exp);i++)\\n        {\\n            if(iniExp>exp[i])\\n                iniExp+=exp[i];\\n            else\\n            {\\n                ans+=(exp[i]-iniExp)+1;\\n                iniExp+=((exp[i]-iniExp)+1)+exp[i];\\n            }\\n            \\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465034,
                "title": "easy-java-solution",
                "content": "# Minimum Hours of Training to Win a Competition\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        //Variable to store ans\\n        int ans=0;\\n        int energysum=0;\\n        //Variable to store the total energy require\\n        for(int num:energy){\\n            energysum+=num;\\n        }\\n        //If initialEnergy is less than totalEnergy require so adding the difference among the two energy + 1 to initalEnergy\\n        if(initialEnergy<(energysum+1)){\\n            ans+=energysum-initialEnergy+1;\\n            initialEnergy=energysum+1;\\n        }\\n        int i=0;\\n        //Variable add keeps track of the experience require to be added to initialExperience\\n        int add=0;\\n        while(i<experience.length){\\n            //If initialExperience is less then the require experience than computing the differnce among the two experiences + 1, and storing the max of this computed value and value in variable add in add\\n            if(initialExperience<=experience[i]){\\n                add=Math.max(add,experience[i]-initialExperience+1);\\n            }\\n            //Decreasing energy\\n            initialEnergy-=energy[i];\\n            //Adding experience\\n            initialExperience+=experience[i];\\n            ++i;\\n        }\\n        //Adding the required experience to be added to ans variable\\n        ans+=add;\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        //Variable to store ans\\n        int ans=0;\\n        int energysum=0;\\n        //Variable to store the total energy require\\n        for(int num:energy){\\n            energysum+=num;\\n        }\\n        //If initialEnergy is less than totalEnergy require so adding the difference among the two energy + 1 to initalEnergy\\n        if(initialEnergy<(energysum+1)){\\n            ans+=energysum-initialEnergy+1;\\n            initialEnergy=energysum+1;\\n        }\\n        int i=0;\\n        //Variable add keeps track of the experience require to be added to initialExperience\\n        int add=0;\\n        while(i<experience.length){\\n            //If initialExperience is less then the require experience than computing the differnce among the two experiences + 1, and storing the max of this computed value and value in variable add in add\\n            if(initialExperience<=experience[i]){\\n                add=Math.max(add,experience[i]-initialExperience+1);\\n            }\\n            //Decreasing energy\\n            initialEnergy-=energy[i];\\n            //Adding experience\\n            initialExperience+=experience[i];\\n            ++i;\\n        }\\n        //Adding the required experience to be added to ans variable\\n        ans+=add;\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461087,
                "title": "java-this-problem-is-actually-very-easy",
                "content": "**Runtime: 0 ms, faster than 100.00% of Java online submissions for Minimum Hours of Training to Win a Competition.\\nMemory Usage: 41.9 MB, less than 57.14% of Java online submissions for Minimum Hours of Training to Win a Competition.**\\n\\nJava code:\\n```\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int training = 0;  // keep track of how many hours needed to train\\n        int energyNum = initialEnergy;\\n        int experienceNum = initialExperience;\\n        for(int i = 0; i<energy.length; i++) { // loop through all the opponents\\n            if (energyNum <= energy[i]) {                // if you don\\'t have enough energy\\n                training += (energy[i] + 1) - energyNum; // , then spend the min amount of hours needed to get enough energy\\n                energyNum= energy[i] + 1;                //  to beat the opponent\\n            }\\n            if(experienceNum <= experience[i]) {                 // if you don\\'t have enough experience\\n                training += (experience[i] + 1) - experienceNum; // , then spend the min amount of hours needed to get enough\\n                experienceNum = experience[i] + 1;               // experience to beat the opponent\\n            }\\n            energyNum -= energy[i]; // after beating the opponent, your energy decreases\\n            experienceNum += experience[i]; // after beating the opponent, your experience increases\\n        }\\n        return training;\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int training = 0;  // keep track of how many hours needed to train\\n        int energyNum = initialEnergy;\\n        int experienceNum = initialExperience;\\n        for(int i = 0; i<energy.length; i++) { // loop through all the opponents\\n            if (energyNum <= energy[i]) {                // if you don\\'t have enough energy\\n                training += (energy[i] + 1) - energyNum; // , then spend the min amount of hours needed to get enough energy\\n                energyNum= energy[i] + 1;                //  to beat the opponent\\n            }\\n            if(experienceNum <= experience[i]) {                 // if you don\\'t have enough experience\\n                training += (experience[i] + 1) - experienceNum; // , then spend the min amount of hours needed to get enough\\n                experienceNum = experience[i] + 1;               // experience to beat the opponent\\n            }\\n            energyNum -= energy[i]; // after beating the opponent, your energy decreases\\n            experienceNum += experience[i]; // after beating the opponent, your experience increases\\n        }\\n        return training;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2457041,
                "title": "python-easy",
                "content": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        need = 0\\n        for i in range(len(energy)):\\n            if initialExperience <= experience[i]:\\n                need += experience[i] + 1 - initialExperience\\n                initialExperience = experience[i] + 1 \\n            initialExperience += experience[i]\\n            initialEnergy -= energy[i]\\n        if initialEnergy <= 0:\\n            need -= initialEnergy - 1\\n        return need",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        need = 0\\n        for i in range(len(energy)):\\n            if initialExperience <= experience[i]:\\n                need += experience[i] + 1 - initialExperience\\n                initialExperience = experience[i] + 1 \\n            initialExperience += experience[i]\\n            initialEnergy -= energy[i]\\n        if initialEnergy <= 0:\\n            need -= initialEnergy - 1\\n        return need",
                "codeTag": "Java"
            },
            {
                "id": 2456579,
                "title": "c-simple-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience)\\n    {\\n        int op=0;\\n        int n = energy.size();\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(initialEnergy<=energy[i])\\n            {\\n                diff = (energy[i]-initialEnergy+1);\\n                initialEnergy += diff;\\n                op += diff;\\n            }\\n            if(initialExperience<=experience[i])\\n            {\\n                diff = (experience[i]-initialExperience+1);\\n                initialExperience += diff;\\n                op += diff;\\n            }\\n            \\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        }\\n \\n        return op;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience)\\n    {\\n        int op=0;\\n        int n = energy.size();\\n        int diff=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(initialEnergy<=energy[i])\\n            {\\n                diff = (energy[i]-initialEnergy+1);\\n                initialEnergy += diff;\\n                op += diff;\\n            }\\n            if(initialExperience<=experience[i])\\n            {\\n                diff = (experience[i]-initialExperience+1);\\n                initialExperience += diff;\\n                op += diff;\\n            }\\n            \\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        }\\n \\n        return op;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3466541,
                "title": "minimum-hours-of-training-to-win-a-competition-solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int i, flag=1, ans=0;\\n        for(i=0 ; i<energy.size() ; i++)\\n        {\\n            if(experience[i]<initialExperience)\\n            {\\n                initialExperience += experience[i];\\n            }\\n            else if(experience[i]>=initialExperience)\\n            {\\n                ans += experience[i] - initialExperience + 1;\\n                initialExperience += 2*experience[i] - initialExperience + 1;\\n            }\\n            if(energy[i]<initialEnergy)\\n            {\\n                initialEnergy -= energy[i];\\n            }\\n            else if(energy[i]>=initialEnergy)\\n            {\\n                ans += energy[i] - initialEnergy + 1;\\n                initialEnergy = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\n![upvote new.jpg](https://assets.leetcode.com/users/images/0f95901e-4be5-4d52-b6bb-1df2ff572fc4_1682781377.0021822.jpeg)\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int i, flag=1, ans=0;\\n        for(i=0 ; i<energy.size() ; i++)\\n        {\\n            if(experience[i]<initialExperience)\\n            {\\n                initialExperience += experience[i];\\n            }\\n            else if(experience[i]>=initialExperience)\\n            {\\n                ans += experience[i] - initialExperience + 1;\\n                initialExperience += 2*experience[i] - initialExperience + 1;\\n            }\\n            if(energy[i]<initialEnergy)\\n            {\\n                initialEnergy -= energy[i];\\n            }\\n            else if(energy[i]>=initialEnergy)\\n            {\\n                ans += energy[i] - initialEnergy + 1;\\n                initialEnergy = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656873,
                "title": "java-easy-solution-o-n",
                "content": "```\\npublic int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int res =0;\\n        int n= energy.length;\\n        int energySum =0;\\n        for(int i=0;i<n;i++){\\n            energySum+=energy[i];\\n            \\n        }\\n        res=energySum-initialEnergy>=0 ? energySum-initialEnergy+1:0;\\n        \\n        \\n         for(int i=0;i<n;i++){\\n           if(initialExperience<=experience[i]){\\n               res+=experience[i]-initialExperience+1;\\n               initialExperience = experience[i]+1;\\n           }\\n             initialExperience+=experience[i];\\n        }\\n        return res;\\n    }",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\npublic int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int res =0;\\n        int n= energy.length;\\n        int energySum =0;\\n        for(int i=0;i<n;i++){\\n            energySum+=energy[i];\\n            \\n        }\\n        res=energySum-initialEnergy>=0 ? energySum-initialEnergy+1:0;\\n        \\n        \\n         for(int i=0;i<n;i++){\\n           if(initialExperience<=experience[i]){\\n               res+=experience[i]-initialExperience+1;\\n               initialExperience = experience[i]+1;\\n           }\\n             initialExperience+=experience[i];\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2499445,
                "title": "c-o-n-soluion",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int en , int xp, vector<int>& energy, vector<int>& exp) {\\n        \\n        int timer = 0 ;\\n        for(int i = 0 ; i < energy.size() ; ++i ){\\n            if(en <= energy[i]) timer += energy[i] - en + 1 , en += energy[i] - en + 1 ;\\n            if(xp <= exp[i]) timer += exp[i] - xp + 1, xp += exp[i] - xp + 1 ;\\n            \\n            en -= energy[i] ;  //energy will reduce\\n            xp += exp[i] ;     //xp will increase\\n        }\\n        \\n        return timer ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int en , int xp, vector<int>& energy, vector<int>& exp) {\\n        \\n        int timer = 0 ;\\n        for(int i = 0 ; i < energy.size() ; ++i ){\\n            if(en <= energy[i]) timer += energy[i] - en + 1 , en += energy[i] - en + 1 ;\\n            if(xp <= exp[i]) timer += exp[i] - xp + 1, xp += exp[i] - xp + 1 ;\\n            \\n            en -= energy[i] ;  //energy will reduce\\n            xp += exp[i] ;     //xp will increase\\n        }\\n        \\n        return timer ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2473401,
                "title": "easy-understanding-o-n-c",
                "content": "```\\n int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n= energy.size();\\n        int energy_sum=1;\\n        int curr_exp=initialExperience;\\n\\t\\t\\n\\t\\t// let training hours needed in maintaining experience and initiate as 0\\n        int training_hours=0;\\n        for (int i=0; i<n; i++)\\n        {\\n            energy_sum+=energy[i];\\n            \\n\\t\\t\\t// if current experience is greater than experience needed to kill ith task\\n            if (curr_exp>experience[i])\\n            {\\n               curr_exp+=experience[i];\\n            }\\n            else {\\n\\t\\t\\t// training hours to increase experience to complete ith task\\n                training_hours+=experience[i]+1-curr_exp;\\n                curr_exp= experience[i]+1+ experience[i];\\n               \\n            }\\n            \\n        }\\n        int s=energy_sum-initialEnergy;\\n\\t\\t\\n\\t\\t//if energy sum is lesser than initial energy\\n        if(s<=0)\\n        {\\n            s=0;\\n        }\\n        return s+training_hours;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n= energy.size();\\n        int energy_sum=1;\\n        int curr_exp=initialExperience;\\n\\t\\t\\n\\t\\t// let training hours needed in maintaining experience and initiate as 0\\n        int training_hours=0;\\n        for (int i=0; i<n; i++)\\n        {\\n            energy_sum+=energy[i];\\n            \\n\\t\\t\\t// if current experience is greater than experience needed to kill ith task\\n            if (curr_exp>experience[i])\\n            {\\n               curr_exp+=experience[i];\\n            }\\n            else {\\n\\t\\t\\t// training hours to increase experience to complete ith task\\n                training_hours+=experience[i]+1-curr_exp;\\n                curr_exp= experience[i]+1+ experience[i];\\n               \\n            }\\n            \\n        }\\n        int s=energy_sum-initialEnergy;\\n\\t\\t\\n\\t\\t//if energy sum is lesser than initial energy\\n        if(s<=0)\\n        {\\n            s=0;\\n        }\\n        return s+training_hours;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2473024,
                "title": "java-beginner-friendly-well-commented-code-explanation",
                "content": "Below is commented Java code -\\n\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int i;\\n        int n = energy.length;\\n        // \\'ans\\' will track minimum number of training hours\\n        int ans = 0;\\n        for(i=0;i<n;i++){\\n            // If initial energy is more then we simply take a portion of this\\n            // i.e. we decrement it by energy[i]\\n            if(initialEnergy > energy[i]){\\n                initialEnergy -= energy[i];\\n            }\\n            else{\\n                // (initialEnergy <= energy[i])\\n                // if we had less or equal initial energy, then how much more energy do we need?\\n                // we need (energy[i] - initialEnergy + 1) more initial energy. Because only then\\n                // our initial energy will be more than energy[i]\\n                // For example, if energy[i] = 4 and initialEnergy = 3, then we need\\n                // 2 more energy units i.e. (4 - 3 + 1) units more are needed in initialEnergy\\n                // so we add this amount in the answer\\n                ans += (energy[i] - initialEnergy + 1);\\n                // add this to initial energy because that much amount more is needed\\n                initialEnergy += (energy[i] - initialEnergy + 1);\\n                // now we consumed energy[i] so decrement it from initial energy\\n                initialEnergy -= energy[i];\\n            }\\n            \\n            if(initialExperience > experience[i]){\\n                // If initial experience is more then we simply add it to experience[i]\\n                initialExperience += experience[i];\\n            }\\n            else {\\n                // (initialExperience <= experience[i])\\n                // In case we had less than or equal experience, then how much more initial\\n                // experience do we need?\\n                // We will need (experience[i] - initialExperience) + 1.\\n                // Same example as given in above comments (this time for experience)\\n                ans += (experience[i] - initialExperience) + 1;\\n                // add this to initial experience because that much amount more is needed\\n                initialExperience += (experience[i] - initialExperience) + 1;\\n                // now our experience will increase because \\n                // condition of -> initialExperience > experience[i] is now satisfied\\n                initialExperience += experience[i];\\n            }\\n        }\\n        \\n        // return minimum number of hours\\n        return ans;\\n    }\\n}\\n```\\n\\n\\n*Kindly upvote if this solution has helped you.\\nThanks for reading! :)*",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int i;\\n        int n = energy.length;\\n        // \\'ans\\' will track minimum number of training hours\\n        int ans = 0;\\n        for(i=0;i<n;i++){\\n            // If initial energy is more then we simply take a portion of this\\n            // i.e. we decrement it by energy[i]\\n            if(initialEnergy > energy[i]){\\n                initialEnergy -= energy[i];\\n            }\\n            else{\\n                // (initialEnergy <= energy[i])\\n                // if we had less or equal initial energy, then how much more energy do we need?\\n                // we need (energy[i] - initialEnergy + 1) more initial energy. Because only then\\n                // our initial energy will be more than energy[i]\\n                // For example, if energy[i] = 4 and initialEnergy = 3, then we need\\n                // 2 more energy units i.e. (4 - 3 + 1) units more are needed in initialEnergy\\n                // so we add this amount in the answer\\n                ans += (energy[i] - initialEnergy + 1);\\n                // add this to initial energy because that much amount more is needed\\n                initialEnergy += (energy[i] - initialEnergy + 1);\\n                // now we consumed energy[i] so decrement it from initial energy\\n                initialEnergy -= energy[i];\\n            }\\n            \\n            if(initialExperience > experience[i]){\\n                // If initial experience is more then we simply add it to experience[i]\\n                initialExperience += experience[i];\\n            }\\n            else {\\n                // (initialExperience <= experience[i])\\n                // In case we had less than or equal experience, then how much more initial\\n                // experience do we need?\\n                // We will need (experience[i] - initialExperience) + 1.\\n                // Same example as given in above comments (this time for experience)\\n                ans += (experience[i] - initialExperience) + 1;\\n                // add this to initial experience because that much amount more is needed\\n                initialExperience += (experience[i] - initialExperience) + 1;\\n                // now our experience will increase because \\n                // condition of -> initialExperience > experience[i] is now satisfied\\n                initialExperience += experience[i];\\n            }\\n        }\\n        \\n        // return minimum number of hours\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467893,
                "title": "python-o-n",
                "content": "```class Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        sol=0\\n        for i in range(len(energy)):\\n            if(initialEnergy<=energy[i]):  \\n                sol+=(energy[i]-initialEnergy+1)\\n                initialEnergy+=(energy[i]-initialEnergy+1)\\n            if(initialExperience<=experience[i]):\\n                sol+=(experience[i]-initialExperience+1)\\n                initialExperience+=(experience[i]-initialExperience+1)\\n            initialEnergy-=energy[i]\\n            initialExperience+=experience[i]\\n        return sol\\n```\\n",
                "solutionTags": [
                    "Array"
                ],
                "code": "```class Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        sol=0\\n        for i in range(len(energy)):\\n            if(initialEnergy<=energy[i]):  \\n                sol+=(energy[i]-initialEnergy+1)\\n                initialEnergy+=(energy[i]-initialEnergy+1)\\n            if(initialExperience<=experience[i]):\\n                sol+=(experience[i]-initialExperience+1)\\n                initialExperience+=(experience[i]-initialExperience+1)\\n            initialEnergy-=energy[i]\\n            initialExperience+=experience[i]\\n        return sol\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460663,
                "title": "c-simulate-easy-to-understand-0ms-100-fast-o-n-time-o-1-space",
                "content": "We can just simluate this. I have renamed the method arguments to make the code a bit more terse.\\n\\n```\\n    int minNumberOfHours(int energy, int experience, vector<int>& energies, vector<int>& experiences) {\\n        int training = 0;\\n        for (int i = 0; i < size(energies); ++i) {\\n            // Energy.\\n            if (energy <= energies[i]) {\\n                // How much more training hours do we need to be 1 higher?\\n                training += energies[i] + 1 - energy;\\n                energy = energies[i] + 1;\\n            }\\n            energy -= energies[i];\\n            \\n            // Experience.\\n            if (experience <= experiences[i]) {\\n                // Same here.\\n                training += experiences[i] + 1 - experience;\\n                experience = experiences[i] + 1;\\n            }\\n            experience += experiences[i];\\n        }\\n        return training;\\n    }\\n```\\n\\nTime complexity: ```O(n)``` we look at each of the ```energies``` and ```experiences``` element onces.\\nSpace complexity: ```O(1)``` only a loop variable and one integer for the result\\n\\nWe could also simluate energy and experience independently, this allows use to use structured loop.\\n\\n```\\n    int minNumberOfHours(int energy, int experience, vector<int>& energies, vector<int>& experiences) {\\n        int training = 0;\\n\\n        // Energy.\\n        for (int eng : energies) {\\n            if (energy <= eng) {\\n                // How much more training hours do we need to be 1 higher?\\n                training += eng + 1 - energy;\\n                energy = eng + 1;\\n            }\\n            energy -= eng;\\n        }\\n            \\n        // Experience.\\n        for (int exp : experiences) {\\n            if (experience <= exp) {\\n                // Same here.\\n                training += exp + 1 - experience;\\n                experience = exp + 1;\\n            }\\n            experience += exp;\\n        }\\n\\n        return training;\\n    }\\n```\\n\\nTime and space complexity is the same. The actual runtime seem to be a bit slower, maybe because we have more loop overhead, but I guess without proper microbench marks this is hard to compare.\\n\\n\\n",
                "solutionTags": [
                    "C",
                    "Simulation"
                ],
                "code": "```\\n    int minNumberOfHours(int energy, int experience, vector<int>& energies, vector<int>& experiences) {\\n        int training = 0;\\n        for (int i = 0; i < size(energies); ++i) {\\n            // Energy.\\n            if (energy <= energies[i]) {\\n                // How much more training hours do we need to be 1 higher?\\n                training += energies[i] + 1 - energy;\\n                energy = energies[i] + 1;\\n            }\\n            energy -= energies[i];\\n            \\n            // Experience.\\n            if (experience <= experiences[i]) {\\n                // Same here.\\n                training += experiences[i] + 1 - experience;\\n                experience = experiences[i] + 1;\\n            }\\n            experience += experiences[i];\\n        }\\n        return training;\\n    }\\n```\n```O(n)```\n```energies```\n```experiences```\n```O(1)```\n```\\n    int minNumberOfHours(int energy, int experience, vector<int>& energies, vector<int>& experiences) {\\n        int training = 0;\\n\\n        // Energy.\\n        for (int eng : energies) {\\n            if (energy <= eng) {\\n                // How much more training hours do we need to be 1 higher?\\n                training += eng + 1 - energy;\\n                energy = eng + 1;\\n            }\\n            energy -= eng;\\n        }\\n            \\n        // Experience.\\n        for (int exp : experiences) {\\n            if (experience <= exp) {\\n                // Same here.\\n                training += exp + 1 - experience;\\n                experience = exp + 1;\\n            }\\n            experience += exp;\\n        }\\n\\n        return training;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2459272,
                "title": "100-easy-approach-c-basic-for-loop-o-n",
                "content": "**Please Upvote**\\n\\n```\\nint minNumberOfHours(int e, int ex, vector<int>& energy, vector<int>& experience) {\\n        int count=0;\\n        for(int i=0;i<energy.size();i++){\\n            if(energy[i]>=e){\\n                while(e<=energy[i]){\\n                    e++;\\n                    count++;\\n                }\\n            }\\n            if(experience[i]>=ex){\\n                while(ex<=experience[i]){\\n                    ex++;\\n                    count++;\\n                }\\n            }\\n            ex+=experience[i];\\n            e-=energy[i];\\n        }\\n        return count;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nint minNumberOfHours(int e, int ex, vector<int>& energy, vector<int>& experience) {\\n        int count=0;\\n        for(int i=0;i<energy.size();i++){\\n            if(energy[i]>=e){\\n                while(e<=energy[i]){\\n                    e++;\\n                    count++;\\n                }\\n            }\\n            if(experience[i]>=ex){\\n                while(ex<=experience[i]){\\n                    ex++;\\n                    count++;\\n                }\\n            }\\n            ex+=experience[i];\\n            e-=energy[i];\\n        }\\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2458603,
                "title": "fastest-c-solution-2-4-ms-with-full-explaination-every-details-of-what-and-why-with-how",
                "content": "**Problem**: In this problem it have been asking for number of minimum training hours required to win the competition. Winning competition meaning you have your Energy and Experience should be strictly greater than whatever given in Energy and Experience array.\\n\\n![image](https://assets.leetcode.com/users/images/fb2d4ab2-030c-4fc6-8d00-f3f50635b208_1661079758.4140139.png)\\n\\n**The following variety you may observe while solving it:**\\n\\n1.> Your initial energy and initial experience is greater than other opponents and in this you really don\\'t have to do anything you can simply return zero.\\n\\n2.> Your initial energy and experience is not greater than other opponents than you require to train and increase your experience and energy. Yes its a bit confusing that am saying to training and also increasing the energy here i mean your required energy that you need to be more than other competents obviously while doing competition your energy will decrease.\\n\\nNow come to the approach here what we can observe your energy should remain 1 more than the complete energy array sum. So you can just add the energy array sum and your training hours will become (for energy not for experience) sum_energy - initial energy + 1.\\n\\nThis can\\'t be valid for experience and for experience you need to do differently.\\n\\nFor experience you have to check your experience from next opponent there will be two following case:\\n1. InitialExperience is more than opponents directly add the initialExperience and opponents experience as you WON.\\n2. InitialExperience is less now you need training so you do opponentExp - initialExperience +1 this should be added in your trianing hours after this training procedure you can move on and add opponent Exp with your Exp + training hours.\\n\\nOnly this thing you need to do and return the trainig hours at the end.\\n\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n\\t    \\n            int tr_energy = 0, tr_exp = initialExperience ,tr_hrs=0;\\n            \\n            for(int i=0;i<energy.size();i++) { tr_energy += energy[i] ; }\\n            if(initialEnergy > tr_energy) return 0; //Base case when you have more initial Energy then all the opponents.\\n            \\n            for( int i=0; i<energy.size(); i++) \\n            { \\n               if(tr_exp<=experience[i])\\n                 {\\n                   tr_hrs += (experience[i] - tr_exp) + 1;\\n                   tr_exp += experience[i] + tr_hrs;\\n                 }            \\n               else\\n                 {\\n                   tr_exp += experience[i];\\n                 }\\n            }\\n\\t\\t\\t//till this step we have tr_hrs for experience now add tr_hrs required for energy\\n            tr_hrs += (tr_energy + 1) - initialEnergy;\\n         \\n            return tr_hrs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n\\t    \\n            int tr_energy = 0, tr_exp = initialExperience ,tr_hrs=0;\\n            \\n            for(int i=0;i<energy.size();i++) { tr_energy += energy[i] ; }\\n            if(initialEnergy > tr_energy) return 0; //Base case when you have more initial Energy then all the opponents.\\n            \\n            for( int i=0; i<energy.size(); i++) \\n            { \\n               if(tr_exp<=experience[i])\\n                 {\\n                   tr_hrs += (experience[i] - tr_exp) + 1;\\n                   tr_exp += experience[i] + tr_hrs;\\n                 }            \\n               else\\n                 {\\n                   tr_exp += experience[i];\\n                 }\\n            }\\n\\t\\t\\t//till this step we have tr_hrs for experience now add tr_hrs required for energy\\n            tr_hrs += (tr_energy + 1) - initialEnergy;\\n         \\n            return tr_hrs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458412,
                "title": "c-soln-100-faster-brute-force-approach-soln-with-full-explanation",
                "content": "\\tint energySum = accumulate(energy.begin(),energy.end(),0);\\n       int playerEnergyGain = 0;\\n       int playerExperienceGain = 0;\\n        \\n        \\n        if(energySum >= initialEnergy)\\n             playerEnergyGain = energySum - initialEnergy + 1;\\n       \\n        for(int i = 0; i < experience.size();i++){\\n            if(initialExperience <= experience[i]){\\n                int temp = initialExperience;\\n                initialExperience = (initialExperience*(experience[i]/initialExperience)) + (experience[i] % initialExperience) + 1;\\n                playerExperienceGain += initialExperience - temp;\\n                 }\\n            if(initialExperience > experience[i])\\n                initialExperience += experience[i];\\n        }\\n        \\n            return playerEnergyGain + playerExperienceGain;    \\n        }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\tint energySum = accumulate(energy.begin(),energy.end(),0);\\n       int playerEnergyGain = 0;\\n       int playerExperienceGain = 0;\\n        \\n        \\n        if(energySum >= initialEnergy)\\n             playerEnergyGain = energySum - initialEnergy + 1;\\n       \\n        for(int i = 0; i < experience.size();i++){\\n            if(initialExperience <= experience[i]){\\n                int temp = initialExperience;\\n                initialExperience = (initialExperience*(experience[i]/initialExperience)) + (experience[i] % initialExperience) + 1;\\n                playerExperienceGain += initialExperience - temp;\\n                 }\\n            if(initialExperience > experience[i])\\n                initialExperience += experience[i];\\n        }\\n        \\n            return playerEnergyGain + playerExperienceGain;    \\n        }",
                "codeTag": "Unknown"
            },
            {
                "id": 2458305,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int hrs = 0;\\n        int ine = initialEnergy;\\n        int inex = initialExperience;\\n        int n = energy.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n                if(energy[i]>=ine)\\n                {\\n                    hrs += energy[i]+1-ine;\\n                    \\n                    ine=energy[i]+1;\\n                }\\n                if(experience[i]>=inex)\\n                {\\n                    hrs += experience[i]+1-inex;\\n                    \\n                    inex=experience[i]+1;\\n                }\\n                ine=ine-energy[i];\\n                inex=inex+experience[i];\\n            \\n        }\\n        return hrs;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int hrs = 0;\\n        int ine = initialEnergy;\\n        int inex = initialExperience;\\n        int n = energy.size();\\n        \\n        for(int i=0;i<n;i++)\\n        {\\n                if(energy[i]>=ine)\\n                {\\n                    hrs += energy[i]+1-ine;\\n                    \\n                    ine=energy[i]+1;\\n                }\\n                if(experience[i]>=inex)\\n                {\\n                    hrs += experience[i]+1-inex;\\n                    \\n                    inex=experience[i]+1;\\n                }\\n                ine=ine-energy[i];\\n                inex=inex+experience[i];\\n            \\n        }\\n        return hrs;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457962,
                "title": "100-faster-java-ac-o-n",
                "content": "\\n\\t \\n\\t class Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        \\n        int sum=0;\\n        for(int i:energy)\\n            sum+=i;\\n        int hours = sum>=initialEnergy?sum-initialEnergy+1:0;\\n        for(int i=0;i<experience.length;i++)\\n        {\\n            if(experience[i]<initialExperience)\\n                initialExperience+=experience[i];\\n            else{\\n                hours+= experience[i]-initialExperience + 1;\\n                initialExperience+= experience[i]-initialExperience + 1 + experience[i];\\n                \\n            }\\n        }\\n        return hours;\\n    }\\n    }",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        \\n        int sum=0;\\n        for(int i:energy)\\n            sum+=i;\\n        int hours = sum>=initialEnergy?sum-initialEnergy+1:0;\\n        for(int i=0;i<experience.length;i++)\\n        {\\n            if(experience[i]<initialExperience)\\n                initialExperience+=experience[i];\\n            else{\\n                hours+= experience[i]-initialExperience + 1;\\n                initialExperience+= experience[i]-initialExperience + 1 + experience[i];\\n                \\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2457442,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(1)***\\n\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        \\n        int n = energy.size();\\n        \\n        int total_energy = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            total_energy += energy[i];\\n        }\\n        \\n        // cal. the exercise req for get sufficient energy\\n        \\n        int exercise_for_energy = 0;\\n        \\n        if(initialEnergy <= total_energy)\\n        {\\n            exercise_for_energy += total_energy + 1 - initialEnergy;\\n        }\\n        \\n        // cal. the exercise req for get sufficient experience\\n        \\n        int exercise_for_experience = 0;\\n        \\n        int curr_experience = initialExperience;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(curr_experience > experience[i])\\n            {\\n                curr_experience += experience[i];\\n            }\\n            else\\n            {\\n                int req_experience = experience[i] + 1 - curr_experience;\\n                \\n                exercise_for_experience += req_experience;\\n                \\n                curr_experience +=  req_experience + experience[i];\\n            }\\n        }\\n    \\n        return exercise_for_energy + exercise_for_experience;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        \\n        int n = energy.size();\\n        \\n        int total_energy = 0;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            total_energy += energy[i];\\n        }\\n        \\n        // cal. the exercise req for get sufficient energy\\n        \\n        int exercise_for_energy = 0;\\n        \\n        if(initialEnergy <= total_energy)\\n        {\\n            exercise_for_energy += total_energy + 1 - initialEnergy;\\n        }\\n        \\n        // cal. the exercise req for get sufficient experience\\n        \\n        int exercise_for_experience = 0;\\n        \\n        int curr_experience = initialExperience;\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            if(curr_experience > experience[i])\\n            {\\n                curr_experience += experience[i];\\n            }\\n            else\\n            {\\n                int req_experience = experience[i] + 1 - curr_experience;\\n                \\n                exercise_for_experience += req_experience;\\n                \\n                curr_experience +=  req_experience + experience[i];\\n            }\\n        }\\n    \\n        return exercise_for_energy + exercise_for_experience;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456854,
                "title": "c-greedy-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int Energyy, int Exp, vector<int>& Energy, vector<int>& experience) {\\n        int exp=0;\\n        int energy=0;\\n        for(int i=0;i<experience.size();i++){\\n            if(Exp>experience[i]){\\n                Exp+=experience[i];\\n            } \\n            else{\\n                int temp=experience[i]+1;\\n                exp+=temp-Exp;\\n                Exp=temp+experience[i];\\n            }\\n        }\\n        int sum=1;\\n        for(auto i:Energy) sum+=i;\\n        if(sum>Energyy){\\n            energy=sum-Energyy;\\n        }\\n        return exp+energy;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "class Solution {\\npublic:\\n    int minNumberOfHours(int Energyy, int Exp, vector<int>& Energy, vector<int>& experience) {\\n        int exp=0;\\n        int energy=0;\\n        for(int i=0;i<experience.size();i++){\\n            if(Exp>experience[i]){\\n                Exp+=experience[i];\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2456798,
                "title": "c-o-n-0ms-intuition-solution-with-explanation",
                "content": "There are three key things here\\n1. strictly greater [most important]\\n2. energy will be deducted always\\n3. exp will gain\\n\\nBased on the first key, we need to add additional 1 to guarantee `strictly greater`.\\nBased on the second key, we know that our initialEnergy will always be exhausted. Therefore, it is intuitive to sum them up. BUT!!! We only add it up when our initialEnergy failed to exhaust the energy cost.\\nLastly, this one is very straightforward in combat with the monster of the experience array. If exp[i] is great or equal to the initialExperience, we should add up the diff with an additional one. \\nThat\\'s all. Interesting question. Best.\\n\\n```cpp\\nint minNumberOfHours(int initialEnergy, int ie, vector<int>& energy, vector<int>& exp) {\\n  int ans = 0, su=-initialEnergy+1;\\n  for (auto n: energy) su+=n;\\n  ans += su>0?su:0;\\n\\n  for (int i=0;i<exp.size()&&ie<100;i++) {\\n\\tif (exp[i]>=ie) {\\n\\t  ans+=exp[i]-ie+1;\\n\\t  ie=exp[i]+1;\\n\\t}\\n\\tie+=exp[i];\\n  }\\n  return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint minNumberOfHours(int initialEnergy, int ie, vector<int>& energy, vector<int>& exp) {\\n  int ans = 0, su=-initialEnergy+1;\\n  for (auto n: energy) su+=n;\\n  ans += su>0?su:0;\\n\\n  for (int i=0;i<exp.size()&&ie<100;i++) {\\n\\tif (exp[i]>=ie) {\\n\\t  ans+=exp[i]-ie+1;\\n\\t  ie=exp[i]+1;\\n\\t}\\n\\tie+=exp[i];\\n  }\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2456615,
                "title": "python3-simulation",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b7391a11acc4e9dbe563ebef84f8d78f7943a0f7) for solutions of weekly 307. \\n\\n**Intuition**\\nHere, we can simply run a simulation to progressively check each energy and experience. If the current energy or experience value is not enough to win. Adjust the value and update the answer. \\n\\n**Analysis**\\nTime complexity O(N)\\nSpace complexity O(1) \\n```\\nclass Solution: \\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        ans = 0 \\n        for x, y in zip(energy, experience): \\n            if initialEnergy <= x: \\n                ans += x + 1 - initialEnergy\\n                initialEnergy = x + 1\\n            if initialExperience <= y: \\n                ans += y + 1 - initialExperience\\n                initialExperience = y + 1\\n            initialEnergy -= x\\n            initialExperience += y \\n        return ans \\n```\\t\\t",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution: \\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        ans = 0 \\n        for x, y in zip(energy, experience): \\n            if initialEnergy <= x: \\n                ans += x + 1 - initialEnergy\\n                initialEnergy = x + 1\\n            if initialExperience <= y: \\n                ans += y + 1 - initialExperience\\n                initialExperience = y + 1\\n            initialEnergy -= x\\n            initialExperience += y \\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456585,
                "title": "java-simplest-solution",
                "content": "```\\nclass Solution {\\n    public int minNumberOfHours(int a, int b, int[] A, int[] B) {\\n        int maxA = 0;\\n        int maxB = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            maxA = Math.max(maxA, A[i]-a+1);\\n            maxB = Math.max(maxB, B[i]-b+1);\\n            a -= A[i];\\n            b += B[i];            \\n        }\\n        return maxA + maxB;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int a, int b, int[] A, int[] B) {\\n        int maxA = 0;\\n        int maxB = 0;\\n        for (int i = 0; i < A.length; i++) {\\n            maxA = Math.max(maxA, A[i]-a+1);\\n            maxB = Math.max(maxB, B[i]-b+1);\\n            a -= A[i];\\n            b += B[i];            \\n        }\\n        return maxA + maxB;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3348101,
                "title": "python-easy-o-n",
                "content": "\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n\\n        \\n        exdif = 0\\n        ensum = 0\\n        for i in range(len(energy)):\\n\\n            if initialExperience <= experience[i]:\\n                exdif = max(1,exdif,experience[i]+1-initialExperience)\\n\\n            initialExperience += experience[i]\\n            ensum += energy[i]\\n\\n\\n        return max(ensum-initialEnergy+1,0) + exdif\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n\\n        \\n        exdif = 0\\n        ensum = 0\\n        for i in range(len(energy)):\\n\\n            if initialExperience <= experience[i]:\\n                exdif = max(1,exdif,experience[i]+1-initialExperience)\\n\\n            initialExperience += experience[i]\\n            ensum += energy[i]\\n\\n\\n        return max(ensum-initialEnergy+1,0) + exdif\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072049,
                "title": "c-simple-solution-plus-1-liner-linq-bonus-70ms-100",
                "content": "More intuitive for experience diff (code optimized below)\\n```\\npublic class Solution {\\n    public int MinNumberOfHours(\\n        int initialEnergy, int initialExperience, int[] energy, int[] experience) \\n    {\\n        var hours = Math.Max(0, energy.Sum()+1-initialEnergy);  // extra energy\\n\\n        foreach(var current in experience)\\n        {\\n            var diff = initialExperience - current;\\n\\n            diff = diff > 0 ? 0 : 1 - diff;\\n\\n            hours += diff;\\n\\n            initialExperience += diff + current;\\n        }\\n\\n        return hours;\\n    }\\n}\\n```\\nwith some refactoring for diff\\n```\\npublic class Solution {\\n    public int MinNumberOfHours(\\n        int initialEnergy, int initialExperience, int[] energy, int[] experience) \\n    {\\n        var hours = Math.Max(0, energy.Sum()+1-initialEnergy);  // extra energy\\n\\n        foreach(var current in experience)\\n        {\\n            var diff = 1 - Math.Min(1, initialExperience-current);\\n\\n            hours += diff;\\n\\n            initialExperience += diff + current;\\n        }\\n\\n        return hours;\\n    }\\n}\\n```\\n# \"1-liner\" with Linq\\n(Not exactly pure 1-liner. Maybe Linq\\'s guru could turn it to true 1-liner)\\n```\\npublic class Solution {\\n    public int MinNumberOfHours(\\n        int initialEnergy, int initialExperience, \\n        int[] energy, int[] experience) \\n\\n    => Math.Max(0, energy.Sum()+1-initialEnergy)\\n      + experience.Sum(exp =>\\n        {\\n            var diff = 1 - Math.Min(1, initialExperience - exp);\\n\\n            initialExperience += diff + exp;\\n\\n            return diff;\\n        });\\n}\\n```\\nThis is like true 1-liner if re-use optional diff=0 parameter in method\\'s singnature\\n```\\npublic class Solution {\\n    public int MinNumberOfHours(\\n        int initialEnergy, int initialExperience, \\n        int[] energy, int[] experience, int diff = 0) \\n\\n    => Math.Max(0, energy.Sum()+1-initialEnergy)\\n      + experience.Sum(exp =>\\n         new {\\n            diffForSum = (diff = 1-Math.Min(1, initialExperience - exp)),\\n            _ = (initialExperience += diff + exp)\\n        }.diffForSum);\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinNumberOfHours(\\n        int initialEnergy, int initialExperience, int[] energy, int[] experience) \\n    {\\n        var hours = Math.Max(0, energy.Sum()+1-initialEnergy);  // extra energy\\n\\n        foreach(var current in experience)\\n        {\\n            var diff = initialExperience - current;\\n\\n            diff = diff > 0 ? 0 : 1 - diff;\\n\\n            hours += diff;\\n\\n            initialExperience += diff + current;\\n        }\\n\\n        return hours;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MinNumberOfHours(\\n        int initialEnergy, int initialExperience, int[] energy, int[] experience) \\n    {\\n        var hours = Math.Max(0, energy.Sum()+1-initialEnergy);  // extra energy\\n\\n        foreach(var current in experience)\\n        {\\n            var diff = 1 - Math.Min(1, initialExperience-current);\\n\\n            hours += diff;\\n\\n            initialExperience += diff + current;\\n        }\\n\\n        return hours;\\n    }\\n}\\n```\n```\\npublic class Solution {\\n    public int MinNumberOfHours(\\n        int initialEnergy, int initialExperience, \\n        int[] energy, int[] experience) \\n\\n    => Math.Max(0, energy.Sum()+1-initialEnergy)\\n      + experience.Sum(exp =>\\n        {\\n            var diff = 1 - Math.Min(1, initialExperience - exp);\\n\\n            initialExperience += diff + exp;\\n\\n            return diff;\\n        });\\n}\\n```\n```\\npublic class Solution {\\n    public int MinNumberOfHours(\\n        int initialEnergy, int initialExperience, \\n        int[] energy, int[] experience, int diff = 0) \\n\\n    => Math.Max(0, energy.Sum()+1-initialEnergy)\\n      + experience.Sum(exp =>\\n         new {\\n            diffForSum = (diff = 1-Math.Min(1, initialExperience - exp)),\\n            _ = (initialExperience += diff + exp)\\n        }.diffForSum);\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2641714,
                "title": "calculate-energy-and-exp-hours-seperately",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int iEn, int iEx, vector<int>& en, vector<int>& ex) {\\n        for(int i=1;i<en.size();i++){\\n            en[i] += en[i-1];\\n        }\\n        int EnHours = en[en.size()-1] - iEn+1;\\n        EnHours = (EnHours<0)?0:EnHours;\\n        int ExHours=0;\\n        for(int i=0;i<ex.size();){\\n            if(iEx > ex[i]){\\n                iEx += ex[i];\\n                i++;\\n            }else{\\n                ExHours += ex[i]-iEx+1;\\n                iEx = ex[i]+1;\\n            }\\n        }\\n        cout<<EnHours<<\" \"<<ExHours<<\" \";\\n        return EnHours + ExHours;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int iEn, int iEx, vector<int>& en, vector<int>& ex) {\\n        for(int i=1;i<en.size();i++){\\n            en[i] += en[i-1];\\n        }\\n        int EnHours = en[en.size()-1] - iEn+1;\\n        EnHours = (EnHours<0)?0:EnHours;\\n        int ExHours=0;\\n        for(int i=0;i<ex.size();){\\n            if(iEx > ex[i]){\\n                iEx += ex[i];\\n                i++;\\n            }else{\\n                ExHours += ex[i]-iEx+1;\\n                iEx = ex[i]+1;\\n            }\\n        }\\n        cout<<EnHours<<\" \"<<ExHours<<\" \";\\n        return EnHours + ExHours;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2641077,
                "title": "simple-python-solution-time-o-n-space-o-1",
                "content": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        N = len(energy)\\n        currEnergy, currExp = initialEnergy, initialExperience\\n        enNeeded, expNeeded = 0, 0\\n        for i in range(N):\\n            enNeeded = max(1 + energy[i] - currEnergy, enNeeded)\\n            expNeeded = max(1 + experience[i] - currExp, expNeeded)\\n            currEnergy -= energy[i]\\n            currExp += experience[i]\\n        return enNeeded + expNeeded\\n    # Time: O(n) where n is the length of energy\\n    # Space: O(1)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        N = len(energy)\\n        currEnergy, currExp = initialEnergy, initialExperience\\n        enNeeded, expNeeded = 0, 0\\n        for i in range(N):\\n            enNeeded = max(1 + energy[i] - currEnergy, enNeeded)\\n            expNeeded = max(1 + experience[i] - currExp, expNeeded)\\n            currEnergy -= energy[i]\\n            currExp += experience[i]\\n        return enNeeded + expNeeded\\n    # Time: O(n) where n is the length of energy\\n    # Space: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2630548,
                "title": "c-100-faster-than-all-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int traning=0,n=energy.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(energy[i]>=initialEnergy)\\n            {\\n                int diff=energy[i]-initialEnergy;\\n                traning+=diff+1;\\n                initialEnergy+=diff+1;\\n            }\\n            if(experience[i]>=initialExperience)\\n            {\\n                int diff=experience[i]-initialExperience;\\n                traning+=diff+1;\\n                initialExperience+=diff+1;\\n            }\\n            initialEnergy-=energy[i];\\n            initialExperience+=experience[i];\\n        }\\n        return traning;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int traning=0,n=energy.size();\\n        for(int i=0;i<n;i++)\\n        {\\n            if(energy[i]>=initialEnergy)\\n            {\\n                int diff=energy[i]-initialEnergy;\\n                traning+=diff+1;\\n                initialEnergy+=diff+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2599533,
                "title": "java-dp-solution",
                "content": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int ene = energy[energy.length - 1] + 1;\\n        int exp = experience[energy.length - 1] + 1;\\n        for (int i = energy.length - 2; i >= 0; i--) {\\n            ene = ene + energy[i];\\n            exp = Math.max(exp - experience[i], experience[i] + 1);\\n        }\\n        return Math.max(ene - initialEnergy, 0) + Math.max(exp - initialExperience, 0);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int ene = energy[energy.length - 1] + 1;\\n        int exp = experience[energy.length - 1] + 1;\\n        for (int i = energy.length - 2; i >= 0; i--) {\\n            ene = ene + energy[i];\\n            exp = Math.max(exp - experience[i], experience[i] + 1);\\n        }\\n        return Math.max(ene - initialEnergy, 0) + Math.max(exp - initialExperience, 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2532842,
                "title": "java-iterative-straightforward-solution",
                "content": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int ene = initialEnergy;\\n        int exp = initialExperience;\\n        int res=0,diff=0;\\n        for (int i=0;i<energy.length;i++) {\\n            if (energy[i]>=ene) {   \\n                diff = energy[i]-ene+1;\\n                res = res+diff;\\n                ene = ene+diff;\\n            }\\n            ene = ene-energy[i];\\n            if (experience[i]>=exp) {\\n                diff = experience[i]-exp+1;\\n                res = res+diff;\\n                exp = exp+diff;\\n            }\\n            exp = exp+experience[i];\\n        }\\n        return res;\\n    }\\n}\\n```\\nKindly upvote if you like the code.",
                "solutionTags": [
                    "Java",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int ene = initialEnergy;\\n        int exp = initialExperience;\\n        int res=0,diff=0;\\n        for (int i=0;i<energy.length;i++) {\\n            if (energy[i]>=ene) {   \\n                diff = energy[i]-ene+1;\\n                res = res+diff;\\n                ene = ene+diff;\\n            }\\n            ene = ene-energy[i];\\n            if (experience[i]>=exp) {\\n                diff = experience[i]-exp+1;\\n                res = res+diff;\\n                exp = exp+diff;\\n            }\\n            exp = exp+experience[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2512273,
                "title": "basic-practice-linear-traversal-python",
                "content": "1- Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        \\n        res = 0\\n        cur_eng, cur_epe = initialEnergy, initialExperience\\n        \\n        for E, e in zip(energy, experience):\\n            if cur_eng < E + 1:\\n                res += E + 1 - cur_eng\\n                cur_eng = E + 1\\n            if cur_epe < e + 1:\\n                res += e + 1 - cur_epe\\n                cur_epe = e + 1\\n            cur_eng, cur_epe = cur_eng - E, cur_epe + e\\n        \\n        return res\\n```\\n\\n2- Video Explanation: [Click Here](https://youtu.be/JaE7uegBikY;)\\n\\n3- Analysis\\n\\n\"\"\"\\nMethod: linear traversal\\n\\nIdea:\\n\\n- During the linear traversal, we check the cur_energy and cur_experience\\nwith the opponent_energy, opponent_experience\\n\\n- If the cur_engery > opponent_energy and cur_experience > oppenent_experience,\\nno training is needed.\\n- Else:\\n  the training hours needed are:\\n       if cur_energy < opponent_enery:  \\n          opponent_energy + 1 - cur_energy\\n          We can reset the cur_energy = opponent_energy + 1 after traning\\n       if cur_experience < opponent_experience:\\n          opponent_experience + 1 - cur_experience\\n          We can reset the cur_experience = opponent_experience + 1 after traning\\n\\n  As we have done the reset, after beating current opponent, the energy and experience\\n  before meeting next opponent are:\\n        cur_energy - current opponent_energy\\n        cur_experience + current opponent_experience.\\n        \\n        \\nWalkthrough\\n\\ninitialEnergy = 5, initialExperience = 3, energy = [1,4,3,2], experience = [2,6,3,1]\\n\\nBefore beat opponent 0: cur_energy 5, cur_epe 3, res: 0\\nAfter beat opponent 0: cur_energy 4, cur_epe 5, res: 0\\n\\nBefore beat opponent 1: cur_energy 4, cur_epe 5, res: 0\\nAfter beat opponent 1: cur_energy 1, cur_epe 13, res: 3\\n\\nBefore beat opponent 2: cur_energy 1, cur_epe 13, res: 3\\nAfter beat opponent 2: cur_energy 1, cur_epe 16, res: 6\\n\\nBefore beat opponent 3: cur_energy 1, cur_epe 16, res: 6\\nAfter beat opponent 3: cur_energy 1, cur_epe 17, res: 8\\n    \\n\"\"\"",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        \\n        res = 0\\n        cur_eng, cur_epe = initialEnergy, initialExperience\\n        \\n        for E, e in zip(energy, experience):\\n            if cur_eng < E + 1:\\n                res += E + 1 - cur_eng\\n                cur_eng = E + 1\\n            if cur_epe < e + 1:\\n                res += e + 1 - cur_epe\\n                cur_epe = e + 1\\n            cur_eng, cur_epe = cur_eng - E, cur_epe + e\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2510651,
                "title": "c-solution-easy-to-understand",
                "content": "{\\n        int hours=0,p=0;\\n        for(int i=0;i<energy.size();i++)\\n        {\\n            hours = energy[i] + hours; \\n        }\\n        hours = hours-initialEnergy+1;\\n        if(hours<0)\\n        {hours=0;}\\n        while(p<energy.size())\\n        {\\n            if(initialExperience<=experience[p])\\n            {\\n                int diff=experience[p]-initialExperience+1;\\n                hours += diff;\\n                initialExperience+= diff;\\n            }\\n            initialExperience=initialExperience+experience[p];\\n            p++;\\n        }\\n        return hours;\\n    }",
                "solutionTags": [],
                "code": "{\\n        int hours=0,p=0;\\n        for(int i=0;i<energy.size();i++)\\n        {\\n            hours = energy[i] + hours; \\n        }\\n        hours = hours-initialEnergy+1;\\n        if(hours<0)\\n        {hours=0;}\\n        while(p<energy.size())\\n        {\\n            if(initialExperience<=experience[p])\\n            {\\n                int diff=experience[p]-initialExperience+1;\\n                hours += diff;\\n                initialExperience+= diff;\\n            }\\n            initialExperience=initialExperience+experience[p];\\n            p++;\\n        }\\n        return hours;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2508105,
                "title": "2383-minimum-hours-of-training-to-win-a-competition",
                "content": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        t=0\\n        e=0\\n        exp=0\\n        if sum(energy)>=initialEnergy:\\n            e=sum(energy)-initialEnergy+1\\n        else:\\n            e=0\\n        #e=e-initialEnergy\\n        #print(e)\\n        for i in range(len(experience)):\\n            if experience[i]>=initialExperience:\\n                exp+=experience[i]-initialExperience+1\\n                initialExperience=experience[i]+1\\n            initialExperience+=experience[i]\\n        #print(exp)\\n        t=e+exp\\n        return t\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        t=0\\n        e=0\\n        exp=0\\n        if sum(energy)>=initialEnergy:\\n            e=sum(energy)-initialEnergy+1\\n        else:\\n            e=0\\n        #e=e-initialEnergy\\n        #print(e)\\n        for i in range(len(experience)):\\n            if experience[i]>=initialExperience:\\n                exp+=experience[i]-initialExperience+1\\n                initialExperience=experience[i]+1\\n            initialExperience+=experience[i]\\n        #print(exp)\\n        t=e+exp\\n        return t\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2497519,
                "title": "simple-python-solution-full-explanation",
                "content": "```python\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        \"\"\"\\n        This function calculates the minimum number of training hours required for \\n        the outcome. The function first initialises the required_energy at 0, after \\n        which the energy requirement is calculated, relative to initialEnergy. The\\n        player must end with positive energy, hence the +1. After this, the\\n        experience component is handled, by evaluating and modifying the\\n        initialExperience inplace, based on the experience values required. If\\n        the player cannot win, the required_experience is added as the experience\\n        required minus the initialExperience, the initialExperience is then modified \\n        inplace to reflect this requirement.\\n        \\n        :param initialEnergy: the energy of the player. (int)\\n        :param initialExperience: the experience of the player. (int)\\n        :param energy: the energy profiles of the other players. (List[int])\\n        :param experience: the experience profiles of the other players. (List[int])\\n        :return: the required training time. (int)\\n        \"\"\"\\n        required_experience = 0\\n        if sum(energy) >= initialEnergy:\\n            required_energy = sum(energy) - initialEnergy + 1\\n        else:\\n            required_energy = 0\\n            \\n        for i in range(len(experience)):\\n            if initialExperience > experience[i]:\\n                initialExperience += experience[i]\\n            else:\\n                required_experience += (experience[i] - initialExperience + 1)\\n                initialExperience += (experience[i] - initialExperience + 1) + experience[i]\\n        return (required_energy + required_experience)\\n",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        \"\"\"\\n        This function calculates the minimum number of training hours required for \\n        the outcome. The function first initialises the required_energy at 0, after \\n        which the energy requirement is calculated, relative to initialEnergy. The\\n        player must end with positive energy, hence the +1. After this, the\\n        experience component is handled, by evaluating and modifying the\\n        initialExperience inplace, based on the experience values required. If\\n        the player cannot win, the required_experience is added as the experience\\n        required minus the initialExperience, the initialExperience is then modified \\n        inplace to reflect this requirement.\\n        \\n        :param initialEnergy: the energy of the player. (int)\\n        :param initialExperience: the experience of the player. (int)\\n        :param energy: the energy profiles of the other players. (List[int])\\n        :param experience: the experience profiles of the other players. (List[int])\\n        :return: the required training time. (int)\\n        \"\"\"\\n        required_experience = 0\\n        if sum(energy) >= initialEnergy:\\n            required_energy = sum(energy) - initialEnergy + 1\\n        else:\\n            required_energy = 0\\n            \\n        for i in range(len(experience)):\\n            if initialExperience > experience[i]:\\n                initialExperience += experience[i]\\n            else:\\n                required_experience += (experience[i] - initialExperience + 1)\\n                initialExperience += (experience[i] - initialExperience + 1) + experience[i]\\n        return (required_energy + required_experience)\\n",
                "codeTag": "Java"
            },
            {
                "id": 2490725,
                "title": "java-hand-written-explaination-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/491f7c03-2a26-4362-9757-26600e21b398_1661612155.9461555.jpeg)\\n```\\n\\t\\t\\nint n=energy.length;\\n        int ene=initialEnergy;\\n        int exp=initialExperience;\\n        int c=0,i=0;\\n        while(i<n){\\n            if(exp>experience[i] && ene>energy[i]){\\n                exp=exp+experience[i];\\n                ene=ene-energy[i];\\n                i++;\\n            }\\n            else{\\n                if(exp<=experience[i]){\\n                    c++;\\n                    exp++;\\n                }\\n                if(ene<=energy[i]){\\n                    c++;\\n                    ene++;\\n                }\\n            }\\n        }\\n        return c;\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\t\\t\\nint n=energy.length;\\n        int ene=initialEnergy;\\n        int exp=initialExperience;\\n        int c=0,i=0;\\n        while(i<n){\\n            if(exp>experience[i] && ene>energy[i]){\\n                exp=exp+experience[i];\\n                ene=ene-energy[i];\\n                i++;\\n            }\\n            else{\\n                if(exp<=experience[i]){\\n                    c++;\\n                    exp++;\\n                }\\n                if(ene<=energy[i]){\\n                    c++;\\n                    ene++;\\n                }\\n            }\\n        }\\n        return c;\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2484839,
                "title": "kotlin-python-lazy-training",
                "content": "Kotlin\\n```\\nclass Solution {\\n    fun minNumberOfHours(initialEnergy: Int, initialExperience: Int, energy: IntArray, experience: IntArray): Int {\\n        var training = 0\\n        var curEn = initialEnergy\\n        var curEx = initialExperience\\n        for ((en, ex) in (energy zip experience)) {\\n            if (curEn <= en) {\\n                training += en - curEn + 1\\n                curEn = en + 1\\n            }\\n            if (curEx <= ex) {\\n                training += ex - curEx + 1\\n                curEx = ex + 1\\n            }\\n            curEn -= en\\n            curEx += ex\\n        }\\n        return training\\n    }\\n}\\n```\\n\\nPython\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        training = 0\\n        curEn = initialEnergy\\n        curEx = initialExperience\\n        for en, ex in zip(energy, experience):\\n            if curEn <= en:\\n                training += en - curEn + 1\\n                curEn = en + 1\\n            \\n            if curEx <= ex:\\n                training += ex - curEx + 1\\n                curEx = ex + 1\\n            \\n            curEn -= en\\n            curEx += ex\\n        return training\\n```",
                "solutionTags": [
                    "Python",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minNumberOfHours(initialEnergy: Int, initialExperience: Int, energy: IntArray, experience: IntArray): Int {\\n        var training = 0\\n        var curEn = initialEnergy\\n        var curEx = initialExperience\\n        for ((en, ex) in (energy zip experience)) {\\n            if (curEn <= en) {\\n                training += en - curEn + 1\\n                curEn = en + 1\\n            }\\n            if (curEx <= ex) {\\n                training += ex - curEx + 1\\n                curEx = ex + 1\\n            }\\n            curEn -= en\\n            curEx += ex\\n        }\\n        return training\\n    }\\n}\\n```\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        training = 0\\n        curEn = initialEnergy\\n        curEx = initialExperience\\n        for en, ex in zip(energy, experience):\\n            if curEn <= en:\\n                training += en - curEn + 1\\n                curEn = en + 1\\n            \\n            if curEx <= ex:\\n                training += ex - curEx + 1\\n                curEx = ex + 1\\n            \\n            curEn -= en\\n            curEx += ex\\n        return training\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2482454,
                "title": "c-easy-understanding",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ie, int ix,vector<int>& en, vector<int>& ex) {\\n        int n=en.size();\\n        int val=0; //total hours needed\\n        for(int i=0;i<n;i++){\\n            if(en[i]>=ie){\\n                val+=en[i]-ie+1; // adding additional hours in energy\\n                ie+=en[i]-ie+1;\\n            }\\n            if(ex[i]>=ix){\\n                val+=ex[i]-ix+1; // adding additional hours in experience\\n                ix+=ex[i]-ix+1;\\n            }\\n            ie-=en[i];\\n            ix+=ex[i];\\n            \\n        }\\n        return val;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ie, int ix,vector<int>& en, vector<int>& ex) {\\n        int n=en.size();\\n        int val=0; //total hours needed\\n        for(int i=0;i<n;i++){\\n            if(en[i]>=ie){\\n                val+=en[i]-ie+1; // adding additional hours in energy\\n                ie+=en[i]-ie+1;\\n            }\\n            if(ex[i]>=ix){\\n                val+=ex[i]-ix+1; // adding additional hours in experience\\n                ix+=ex[i]-ix+1;\\n            }\\n            ie-=en[i];\\n            ix+=ex[i];\\n            \\n        }\\n        return val;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2480239,
                "title": "the-easiest-and-concise-o-n-solution-beats-100",
                "content": "**Code:-**\\n\\n```\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience)\\n    {\\n        int count=0;\\n        for (int i = 0; i < energy.length; i++)\\n        {\\n            if (initialExperience <= experience[i])\\n            {\\n                count+= experience[i]-initialExperience+1;\\n                initialExperience+= experience[i]-initialExperience+1;     // if current experience < required experience, then we first bridge the gap and make the current experience more than the required experience      \\n            }\\n            initialEnergy-= energy[i];     // decrementing energy           \\n            initialExperience+= experience[i];     // incrementing experience\\n        }\\n        if (initialEnergy < 1)\\n            count+= 1-initialEnergy;     // if energy is still greater than 0, then no need of training \\n        return count;\\n    }\\n```\\t",
                "solutionTags": [
                    "Java",
                    "JavaScript",
                    "Greedy"
                ],
                "code": "```\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience)\\n    {\\n        int count=0;\\n        for (int i = 0; i < energy.length; i++)\\n        {\\n            if (initialExperience <= experience[i])\\n            {\\n                count+= experience[i]-initialExperience+1;\\n                initialExperience+= experience[i]-initialExperience+1;     // if current experience < required experience, then we first bridge the gap and make the current experience more than the required experience      \\n            }\\n            initialEnergy-= energy[i];     // decrementing energy           \\n            initialExperience+= experience[i];     // incrementing experience\\n        }\\n        if (initialEnergy < 1)\\n            count+= 1-initialEnergy;     // if energy is still greater than 0, then no need of training \\n        return count;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2479755,
                "title": "javascript-faster-than-100-memory-less-than-100",
                "content": "```\\nvar minNumberOfHours = function(power, knowledge, energy, experience) {\\n    let hours = 0;\\n    for (let i = 0; i < energy.length; i++) {\\n        if (power <= energy[i] || knowledge <= experience[i]) {\\n            while (power <= energy[i]) {\\n                power++;\\n                hours++;\\n            } while (knowledge <= experience[i]) {\\n                knowledge++;\\n                hours++;\\n            }\\n        } if (power > energy[i] && knowledge > experience[i]) {\\n            power -= energy[i]\\n            knowledge += experience[i]\\n        }\\n    } return hours\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/3685a266-8f80-4a6f-bc3d-19195d9c21ab_1661448842.9609663.png)",
                "solutionTags": [],
                "code": "```\\nvar minNumberOfHours = function(power, knowledge, energy, experience) {\\n    let hours = 0;\\n    for (let i = 0; i < energy.length; i++) {\\n        if (power <= energy[i] || knowledge <= experience[i]) {\\n            while (power <= energy[i]) {\\n                power++;\\n                hours++;\\n            } while (knowledge <= experience[i]) {\\n                knowledge++;\\n                hours++;\\n            }\\n        } if (power > energy[i] && knowledge > experience[i]) {\\n            power -= energy[i]\\n            knowledge += experience[i]\\n        }\\n    } return hours\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2464029,
                "title": "javascript-solution",
                "content": "```\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let count = 0\\n    for (let i=0; i<energy.length; i++) {\\n        if (energy[i]>=initialEnergy) {\\n            count+=energy[i]-initialEnergy+1\\n            initialEnergy = 1\\n        } else {\\n            initialEnergy -= energy[i]\\n        } \\n        if (experience[i]<initialExperience) {\\n            initialExperience += experience[i]\\n        } else {\\n            count+=experience[i]-initialExperience+1\\n            initialExperience += experience[i]+experience[i]-initialExperience+1       \\n        }\\n       \\n    }\\n    return count\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let count = 0\\n    for (let i=0; i<energy.length; i++) {\\n        if (energy[i]>=initialEnergy) {\\n            count+=energy[i]-initialEnergy+1\\n            initialEnergy = 1\\n        } else {\\n            initialEnergy -= energy[i]\\n        } \\n        if (experience[i]<initialExperience) {\\n            initialExperience += experience[i]\\n        } else {\\n            count+=experience[i]-initialExperience+1\\n            initialExperience += experience[i]+experience[i]-initialExperience+1       \\n        }\\n       \\n    }\\n    return count\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2459112,
                "title": "time-o-n-space-o-1-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ene, int exp, vector<int>& a, vector<int>& b) {\\n        //calculating energy\\n        int energy;\\n        for(auto it:a)\\n            ene-=it;\\n        energy=(ene>0)?0:abs(ene)+1;\\n        \\n        //calculating exp\\n        int experience =0;\\n        for(auto it:b)\\n            if(exp>it)exp+=it;\\n            else experience +=it-exp+1,exp+=it+experience ;\\n        \\n        return energy+experience ;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ene, int exp, vector<int>& a, vector<int>& b) {\\n        //calculating energy\\n        int energy;\\n        for(auto it:a)\\n            ene-=it;\\n        energy=(ene>0)?0:abs(ene)+1;\\n        \\n        //calculating exp\\n        int experience =0;\\n        for(auto it:b)\\n            if(exp>it)exp+=it;\\n            else experience +=it-exp+1,exp+=it+experience ;\\n        \\n        return energy+experience ;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458414,
                "title": "easy-to-understand-python-solution-100-faster",
                "content": "![image](https://assets.leetcode.com/users/images/947cdd5a-5dd0-487e-b98e-364b937a6be9_1661076362.0836651.png)\\n\\n...\\nclass Solution:\\n\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        #Base Case\\n        if sum(energy) < initialEnergy and sum(experience) < initialExperience:\\n            return 0\\n        \\n        \\n        z = []\\n        count = 0\\n        y = 0\\n        \\n        # initial check\\n        z.append(initialExperience)\\n        if z[0] < experience[0]:\\n            t = experience[0]-z[0]+1\\n            y+=t\\n            z[0] = t + z[0]\\n            \\n            \\n        if z[0] == experience[0]:\\n            t = experience[0]-z[0]+1\\n            y+=t\\n            z[0] = t + experience[0]\\n            \\n\\n        z[0] = z[0]+experience[0]\\n        \\n\\n        if len(experience)==1 and sum(energy) < initialEnergy:\\n            return y\\n\\n        \\n        # number of hours to get sufficient experience   \\n        for i in range(1,len(experience)):\\n            if z[0] < experience[i]:\\n                t = experience[i]-z[0]+1\\n                y+=t\\n                z[0] = t + z[0]\\n                \\n            if z[0] == experience[i]:\\n                t = experience[i]-z[0]+1\\n                y+=t\\n                z[0] =t + experience[1]\\n            \\n            z[0] = z[0]+experience[i]\\n            \\n            \\n        \\n        # calculating number of hours to fulfill energy requirement \\n        x = sum(energy) - initialEnergy + 1\\n        \\n        # returning total number of hours\\n        return x+y\\n\\t\\t\\n...",
                "solutionTags": [
                    "Python",
                    "Array"
                ],
                "code": "![image](https://assets.leetcode.com/users/images/947cdd5a-5dd0-487e-b98e-364b937a6be9_1661076362.0836651.png)\\n\\n...\\nclass Solution:\\n\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        #Base Case\\n        if sum(energy) < initialEnergy and sum(experience) < initialExperience:\\n            return 0\\n        \\n        \\n        z = []\\n        count = 0\\n        y = 0\\n        \\n        # initial check\\n        z.append(initialExperience)\\n        if z[0] < experience[0]:\\n            t = experience[0]-z[0]+1\\n            y+=t\\n            z[0] = t + z[0]\\n            \\n            \\n        if z[0] == experience[0]:\\n            t = experience[0]-z[0]+1\\n            y+=t\\n            z[0] = t + experience[0]\\n            \\n\\n        z[0] = z[0]+experience[0]\\n        \\n\\n        if len(experience)==1 and sum(energy) < initialEnergy:\\n            return y\\n\\n        \\n        # number of hours to get sufficient experience   \\n        for i in range(1,len(experience)):\\n            if z[0] < experience[i]:\\n                t = experience[i]-z[0]+1\\n                y+=t\\n                z[0] = t + z[0]\\n                \\n            if z[0] == experience[i]:\\n                t = experience[i]-z[0]+1\\n                y+=t\\n                z[0] =t + experience[1]\\n            \\n            z[0] = z[0]+experience[i]\\n            \\n            \\n        \\n        # calculating number of hours to fulfill energy requirement \\n        x = sum(energy) - initialEnergy + 1\\n        \\n        # returning total number of hours\\n        return x+y\\n\\t\\t\\n...",
                "codeTag": "Java"
            },
            {
                "id": 2458169,
                "title": "cpp-simple-solution",
                "content": "```\\nint minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int energyHour = 0;\\n        int expHour = 0;\\n        for(int i = 0; i < energy.size(); i++)\\n        {\\n            int diffEnergy = abs(initialEnergy - energy[i]);\\n            if(initialEnergy - energy[i] < 1)\\n            {\\n                initialEnergy += diffEnergy + 1 - energy[i];\\n                energyHour += diffEnergy + 1;\\n                diffEnergy = 0;\\n            }\\n            else\\n            {\\n                initialEnergy -= energy[i];\\n            }\\n            int diffExp = abs(initialExperience - experience[i]);\\n            if(initialExperience - experience[i] < 1)\\n            {\\n                initialExperience += experience[i] + diffExp + 1;\\n                expHour += diffExp + 1;\\n                diffExp = 0;\\n            }\\n            else\\n            {\\n                initialExperience += experience[i];\\n            }\\n        }\\n        return expHour + energyHour;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int energyHour = 0;\\n        int expHour = 0;\\n        for(int i = 0; i < energy.size(); i++)\\n        {\\n            int diffEnergy = abs(initialEnergy - energy[i]);\\n            if(initialEnergy - energy[i] < 1)\\n            {\\n                initialEnergy += diffEnergy + 1 - energy[i];\\n                energyHour += diffEnergy + 1;\\n                diffEnergy = 0;\\n            }\\n            else\\n            {\\n                initialEnergy -= energy[i];\\n            }\\n            int diffExp = abs(initialExperience - experience[i]);\\n            if(initialExperience - experience[i] < 1)\\n            {\\n                initialExperience += experience[i] + diffExp + 1;\\n                expHour += diffExp + 1;\\n                diffExp = 0;\\n            }\\n            else\\n            {\\n                initialExperience += experience[i];\\n            }\\n        }\\n        return expHour + energyHour;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2458079,
                "title": "java-solution",
                "content": "\\n\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        \\n        \\n        int hrs=0;\\n\\n         int sumEne=0;\\n\\n         for(int x:energy){\\n             sumEne+=x;\\n         }\\n\\n     \\n        if(sumEne>=initialEnergy) {\\n            hrs = sumEne - initialEnergy + 1;\\n        }\\n\\n\\n        int tempHrs=0;\\n\\t\\t\\n         for(int i=0;i<experience.length;i++){\\n\\n             if(initialExperience<=experience[i]){\\n\\n                 tempHrs+=experience[i]-initialExperience+1;\\n                 initialExperience+=experience[i]+tempHrs;\\n             }else{\\n                 initialExperience+=experience[i];\\n             }\\n         }\\n        \\n        return hrs+tempHrs;\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        \\n        \\n        int hrs=0;\\n\\n         int sumEne=0;\\n\\n         for(int x:energy){\\n             sumEne+=x;\\n         }\\n\\n     \\n        if(sumEne>=initialEnergy) {\\n            hrs = sumEne - initialEnergy + 1;\\n        }\\n\\n\\n        int tempHrs=0;\\n\\t\\t\\n         for(int i=0;i<experience.length;i++){\\n\\n             if(initialExperience<=experience[i]){\\n\\n                 tempHrs+=experience[i]-initialExperience+1;\\n                 initialExperience+=experience[i]+tempHrs;\\n             }else{\\n                 initialExperience+=experience[i];\\n             }\\n         }\\n        \\n        return hrs+tempHrs;\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458037,
                "title": "leetcode-the-hard-way-solution-with-explaination",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n = energy.size(), ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            // if initialEnergy is not enough, then we need to add some training hours\\n            if (initialEnergy <= energy[i]) {\\n                // + 1 here because we need it to be strictly greater\\n                int need = energy[i] - initialEnergy + 1;\\n                // ans is the number of training hours\\n                ans += need;\\n                // since we train, we gain energy\\n                initialEnergy += need;\\n            }\\n            // similarly for experience\\n            // if initialExperience is not enough, then we need to add some training hours\\n            if (initialExperience <= experience[i]) {\\n                // + 1 here because we need it to be strictly greater\\n                int need = experience[i] - initialExperience + 1;\\n                // ans is the number of training hours\\n                ans += need;\\n                // since we train, we gain experience\\n                initialExperience += need;\\n            }\\n            // start a competition\\n            // increases your experience by experience[i]\\n            initialEnergy -= energy[i];\\n            // and decreases your energy by energy[i]\\n            initialExperience += experience[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n = energy.size(), ans = 0;\\n        for (int i = 0; i < n; i++) {\\n            // if initialEnergy is not enough, then we need to add some training hours\\n            if (initialEnergy <= energy[i]) {\\n                // + 1 here because we need it to be strictly greater\\n                int need = energy[i] - initialEnergy + 1;\\n                // ans is the number of training hours\\n                ans += need;\\n                // since we train, we gain energy\\n                initialEnergy += need;\\n            }\\n            // similarly for experience\\n            // if initialExperience is not enough, then we need to add some training hours\\n            if (initialExperience <= experience[i]) {\\n                // + 1 here because we need it to be strictly greater\\n                int need = experience[i] - initialExperience + 1;\\n                // ans is the number of training hours\\n                ans += need;\\n                // since we train, we gain experience\\n                initialExperience += need;\\n            }\\n            // start a competition\\n            // increases your experience by experience[i]\\n            initialEnergy -= energy[i];\\n            // and decreases your energy by energy[i]\\n            initialExperience += experience[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457856,
                "title": "easy-python-solution",
                "content": "```\\n    def minNumberOfHours(self, initialEnergy, initialExperience, energy, experience):\\n        energyHours = max(0, sum(energy) - initialEnergy + 1)\\n        \\n        experHours = max(0, experience[0] + 1 - initialExperience)\\n        preSum = experience[0] + initialExperience\\n        \\n        for i in range(1, len(experience)):\\n            experHours = max(experHours, 1 + experience[i] - preSum)\\n            preSum += experience[i]\\n            \\n        return energyHours + experHours\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def minNumberOfHours(self, initialEnergy, initialExperience, energy, experience):\\n        energyHours = max(0, sum(energy) - initialEnergy + 1)\\n        \\n        experHours = max(0, experience[0] + 1 - initialExperience)\\n        preSum = experience[0] + initialExperience\\n        \\n        for i in range(1, len(experience)):\\n            experHours = max(experHours, 1 + experience[i] - preSum)\\n            preSum += experience[i]\\n            \\n        return energyHours + experHours\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2457787,
                "title": "java-solution-o-n",
                "content": "### ***Please Upvote !!!***\\n#### Weekly Contest 307\\n##### (21 August, 2022)\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        \\n        int n = energy.length;\\n        int ans = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            \\n            if (initialEnergy <= energy[i]) {\\n                int tempEnergy = energy[i] + 1 - initialEnergy;\\n                ans += tempEnergy;\\n                initialEnergy += tempEnergy;\\n            }\\n            \\n            if (initialExperience <= experience[i]) {\\n                int tempExperience = experience[i] + 1 - initialExperience;\\n                ans += tempExperience;\\n                initialExperience += tempExperience;\\n            }\\n            \\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        \\n        int n = energy.length;\\n        int ans = 0;\\n        \\n        for (int i = 0; i < n; i++) {\\n            \\n            if (initialEnergy <= energy[i]) {\\n                int tempEnergy = energy[i] + 1 - initialEnergy;\\n                ans += tempEnergy;\\n                initialEnergy += tempEnergy;\\n            }\\n            \\n            if (initialExperience <= experience[i]) {\\n                int tempExperience = experience[i] + 1 - initialExperience;\\n                ans += tempExperience;\\n                initialExperience += tempExperience;\\n            }\\n            \\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        }\\n        \\n        return ans;\\n    }\\n}\\n\\n// TC: O(n), SC: O(1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457728,
                "title": "java-easy-faster-than-100",
                "content": "```\\n\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int sum = 0, exp =0;\\n        \\n        for(int n : energy){\\n            sum += n;  //total energy \\n        }\\n           int totalEnergy = (initialEnergy>sum) ? 0: (sum-initialEnergy) + 1 ; //total energy required\\n              \\n        for(int n : experience){\\n            if(initialExperience > n){\\n                initialExperience += n;\\n            } else{\\n                exp += (n - initialExperience) + 1; //exp holds additional experience required for particular itertion\\n                initialExperience += exp+n;  //upadate initial experience for next iteration\\n            }\\n        }\\n        return totalEnergy + exp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int sum = 0, exp =0;\\n        \\n        for(int n : energy){\\n            sum += n;  //total energy \\n        }\\n           int totalEnergy = (initialEnergy>sum) ? 0: (sum-initialEnergy) + 1 ; //total energy required\\n              \\n        for(int n : experience){\\n            if(initialExperience > n){\\n                initialExperience += n;\\n            } else{\\n                exp += (n - initialExperience) + 1; //exp holds additional experience required for particular itertion\\n                initialExperience += exp+n;  //upadate initial experience for next iteration\\n            }\\n        }\\n        return totalEnergy + exp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457598,
                "title": "easy-to-understand-100-faster-solution-o-n-approach",
                "content": "class Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n= experience.size();\\n        int count =0;\\n        for(int i=0;i<n;i++){\\n            if(energy[i]>=initialEnergy){\\n                int diff = energy[i]-initialEnergy;\\n                initialEnergy += diff+1;\\n                count += diff+1;\\n            }\\n            if(experience[i]>=initialExperience){\\n                int diff = experience[i]-initialExperience;\\n                initialExperience += diff+1;\\n                count += diff+1;\\n            }\\n            if(energy[i]<initialEnergy && experience[i]<initialExperience){\\n                initialEnergy -= energy[i];\\n                initialExperience += experience[i];\\n            }\\n            \\n        }\\n        return count;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n= experience.size();\\n        int count =0;\\n        for(int i=0;i<n;i++){\\n            if(energy[i]>=initialEnergy){\\n                int diff = energy[i]-initialEnergy;\\n                initialEnergy += diff+1;\\n                count += diff+1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2457248,
                "title": "easy-efficient-solution-with-explanation-100-faster",
                "content": "* **Approach :**\\n\\t* There are three cases for this problem -\\n\\t\\ti) Training for Energy gain.\\n\\t\\tii) Traing for Experience gain.\\n\\t\\tiii) Defeating the opponents\\n\\t* For case - i :\\n\\t\\t* Training hours required, hours += energy[i] - initialEnergy + 1\\n\\t\\t* Energy gained, initialEnergy +=  .energy[i] - initialEnergy + 1\\n\\t* For case - ii :\\n\\t\\t* Training hours required, hours += experience[i] - initialExperience + 1\\n\\t\\t* Experience gained, initialExperience += experience[i] - initialExperience + 1\\n\\t* For case - iii :\\n\\t\\t* Experience will increase, initialExperience += experience[i]\\n\\t\\t* Energy will decrease, initialEnergy -= energy[i]\\n\\t* Finally return the ans (hours).\\n\\n* **Code :**\\n```\\nint minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        \\n        int n = energy.size();\\n        int hours = 0;\\n        \\n        for(int i = 0; i < n; ++i)\\n        {\\n            // Case : 1\\n            if(initialEnergy <= energy[i])\\n            {\\n                hours += energy[i] - initialEnergy + 1;\\n                initialEnergy += energy[i] - initialEnergy + 1;\\n            }    \\n            \\n            // Case : 2\\n            if(initialExperience <= experience[i])\\n            {\\n                hours += experience[i] - initialExperience + 1;\\n                initialExperience += experience[i] - initialExperience + 1;\\n            }\\n            \\n            // Case : 3\\n            initialExperience += experience[i] ;\\n            initialEnergy -= energy[i];\\n        }\\n        return hours;\\n    }\\n```\\n\\n* **Complexity Analysis :**\\n\\t* Time Complexity : O(n)\\n\\t* Space Complexity : O(1)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        \\n        int n = energy.size();\\n        int hours = 0;\\n        \\n        for(int i = 0; i < n; ++i)\\n        {\\n            // Case : 1\\n            if(initialEnergy <= energy[i])\\n            {\\n                hours += energy[i] - initialEnergy + 1;\\n                initialEnergy += energy[i] - initialEnergy + 1;\\n            }    \\n            \\n            // Case : 2\\n            if(initialExperience <= experience[i])\\n            {\\n                hours += experience[i] - initialExperience + 1;\\n                initialExperience += experience[i] - initialExperience + 1;\\n            }\\n            \\n            // Case : 3\\n            initialExperience += experience[i] ;\\n            initialEnergy -= energy[i];\\n        }\\n        return hours;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2457232,
                "title": "o-n-approach-c-easy-to-understand-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        \\n        int n=energy.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(energy[i]>=initialEnergy){\\n                int dif=energy[i]-initialEnergy;\\n                initialEnergy+=dif+1;\\n                ans+=dif+1;\\n            }\\n            if(experience[i]>=initialExperience){\\n                int dif=experience[i]-initialExperience;\\n                initialExperience+=dif+1;\\n                ans+=dif+1;\\n            }\\n            if(energy[i]<initialEnergy && experience[i]<initialExperience){\\n                initialEnergy-=energy[i];\\n                initialExperience+=experience[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        \\n        int n=energy.size();\\n        int ans=0;\\n        for(int i=0;i<n;i++){\\n            if(energy[i]>=initialEnergy){\\n                int dif=energy[i]-initialEnergy;\\n                initialEnergy+=dif+1;\\n                ans+=dif+1;\\n            }\\n            if(experience[i]>=initialExperience){\\n                int dif=experience[i]-initialExperience;\\n                initialExperience+=dif+1;\\n                ans+=dif+1;\\n            }\\n            if(energy[i]<initialEnergy && experience[i]<initialExperience){\\n                initialEnergy-=energy[i];\\n                initialExperience+=experience[i];\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457188,
                "title": "c-easy-simple-and-fast-code-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n=energy.size();\\n        int sum=0 ;\\n        int reqEnergy=1;\\n        for(int i=0 ; i<n ; i++){\\n            int temp=experience[i];\\n            experience[i]=experience[i]-sum;\\n            sum+=temp;\\n            reqEnergy+=energy[i];\\n        }\\n        int ans1=0;\\n        if(reqEnergy>initialEnergy){\\n            ans1=reqEnergy-initialEnergy;\\n        }\\n        else{\\n            ans1=0;\\n        }\\n        // cout<<reqEnergy;\\n        \\n        sum=*max_element(experience.begin(),experience.end())+1;\\n        \\n        if(sum>=initialExperience){\\n            sum=sum-initialExperience;\\n        }\\n        else{\\n            sum=0;\\n        }\\n        \\n        int ans=ans1+sum;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Iterator"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int n=energy.size();\\n        int sum=0 ;\\n        int reqEnergy=1;\\n        for(int i=0 ; i<n ; i++){\\n            int temp=experience[i];\\n            experience[i]=experience[i]-sum;\\n            sum+=temp;\\n            reqEnergy+=energy[i];\\n        }\\n        int ans1=0;\\n        if(reqEnergy>initialEnergy){\\n            ans1=reqEnergy-initialEnergy;\\n        }\\n        else{\\n            ans1=0;\\n        }\\n        // cout<<reqEnergy;\\n        \\n        sum=*max_element(experience.begin(),experience.end())+1;\\n        \\n        if(sum>=initialExperience){\\n            sum=sum-initialExperience;\\n        }\\n        else{\\n            sum=0;\\n        }\\n        \\n        int ans=ans1+sum;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2457125,
                "title": "c-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int p=0,q=0;\\n        int curr=initialExperience;\\n        for(auto x:energy)\\n            p+=x;\\n        for(int i=0;i<experience.size();i++)\\n        {\\n            if(curr<=experience[i])\\n            {\\n                q+=experience[i]-curr+1;\\n                curr=experience[i]+1;\\n            }\\n            curr+=experience[i];\\n        }\\n        if(p>=initialEnergy)\\n            p=p-initialEnergy+1;\\n        else\\n            p=0;\\n        \\n        int res=0;\\n        if(p>0)\\n            res+=p;\\n        if(q>0)\\n            res+=q;\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int p=0,q=0;\\n        int curr=initialExperience;\\n        for(auto x:energy)\\n            p+=x;\\n        for(int i=0;i<experience.size();i++)\\n        {\\n            if(curr<=experience[i])\\n            {\\n                q+=experience[i]-curr+1;\\n                curr=experience[i]+1;\\n            }\\n            curr+=experience[i];\\n        }\\n        if(p>=initialEnergy)\\n            p=p-initialEnergy+1;\\n        else\\n            p=0;\\n        \\n        int res=0;\\n        if(p>0)\\n            res+=p;\\n        if(q>0)\\n            res+=q;\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456845,
                "title": "easy-beginners-solutions-explained-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int TotalEnemyEnergy=0 , myExp=initialExperience , expTraining=0;\\n        \\n        for(int e:energy) TotalEnemyEnergy += e;  //total energy required to defeat enemy.\\n        \\n        //for experience training.\\n        for(int i=0;i<experience.size();i++){  //check enemies in order.\\n            if(myExp<=experience[i]){  //if training required to fight ith enemy.\\n                expTraining += experience[i] - myExp + 1;  //calculate how much to train.\\n                myExp += expTraining;  //increase exp after training.\\n            }\\n            myExp += experience[i];  //increase exp after defeating enemy.\\n        }\\n        if(initialEnergy>TotalEnemyEnergy) return expTraining;//iniatially energy is more than enough..check training required only for exp. \\n        return (TotalEnemyEnergy-initialEnergy+1 + expTraining);  \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int TotalEnemyEnergy=0 , myExp=initialExperience , expTraining=0;\\n        \\n        for(int e:energy) TotalEnemyEnergy += e;  //total energy required to defeat enemy.\\n        \\n        //for experience training.\\n        for(int i=0;i<experience.size();i++){  //check enemies in order.\\n            if(myExp<=experience[i]){  //if training required to fight ith enemy.\\n                expTraining += experience[i] - myExp + 1;  //calculate how much to train.\\n                myExp += expTraining;  //increase exp after training.\\n            }\\n            myExp += experience[i];  //increase exp after defeating enemy.\\n        }\\n        if(initialEnergy>TotalEnemyEnergy) return expTraining;//iniatially energy is more than enough..check training required only for exp. \\n        return (TotalEnemyEnergy-initialEnergy+1 + expTraining);  \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456821,
                "title": "binary-search-sol",
                "content": "```cpp\\nclass Solution {\\npublic:\\n    \\n    inline bool check(int exp, vector<int> &ene) {\\n        for (auto i: ene) {\\n            if (i >= exp) {\\n                return false;\\n            } else {\\n                exp += i;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int minNumberOfHours(int initialEnergy, int exp, vector<int>& energy, vector<int>& experience) {\\n        int ans = 0;\\n        for (auto &x: energy) {\\n            ans += x;\\n        }\\n        ans = max(0, ans + 1 - initialEnergy);\\n        \\n        int lo = 0, hi = 100000, mid;\\n        \\n        while (lo < hi) {\\n            mid = (lo + hi) >> 1;\\n            if (check(mid + exp, experience)) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        return ans + lo;\\n    }\\n};\\n```\\n\\nspent too much time on question 1 so directly doing binary search sol.",
                "solutionTags": [
                    "Binary Search"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    \\n    inline bool check(int exp, vector<int> &ene) {\\n        for (auto i: ene) {\\n            if (i >= exp) {\\n                return false;\\n            } else {\\n                exp += i;\\n            }\\n        }\\n        return true;\\n    }\\n    \\n    int minNumberOfHours(int initialEnergy, int exp, vector<int>& energy, vector<int>& experience) {\\n        int ans = 0;\\n        for (auto &x: energy) {\\n            ans += x;\\n        }\\n        ans = max(0, ans + 1 - initialEnergy);\\n        \\n        int lo = 0, hi = 100000, mid;\\n        \\n        while (lo < hi) {\\n            mid = (lo + hi) >> 1;\\n            if (check(mid + exp, experience)) {\\n                hi = mid;\\n            } else {\\n                lo = mid + 1;\\n            }\\n        }\\n        \\n        return ans + lo;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456761,
                "title": "c",
                "content": "```\\npublic class Solution\\n    {\\n        public int MinNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience)\\n        {\\n            var result = 0;\\n            for (int index = 0; index < energy.Length; index++)\\n            {\\n                if (initialEnergy <= energy[index])\\n                {\\n                    var minVal = energy[index] + 1 - initialEnergy;\\n                    result += minVal;\\n                    initialEnergy += minVal;\\n                }\\n                initialEnergy -= energy[index];\\n                if (initialExperience <= experience[index])\\n                {\\n                    var minVal = experience[index] + 1 - initialExperience;\\n                    result += minVal;\\n                    initialExperience += minVal;\\n                }\\n                initialExperience += experience[index];\\n            }\\n            return result;\\n        }\\n    }",
                "solutionTags": [],
                "code": "class Solution\\n    {\\n        public int MinNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience)\\n        {\\n            var result = 0;\\n            for (int index = 0; index < energy.Length; index++)\\n            {\\n                if (initialEnergy <= energy[index])\\n                {\\n                    var minVal = energy[index] + 1 - initialEnergy;\\n                    result += minVal;\\n                    initialEnergy += minVal;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2456681,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int n = energy.length;\\n        int enSum = 0;\\n        for(int en : energy) {\\n            enSum += en;\\n        }\\n        int ans1 = enSum >= initialEnergy ? Math.abs(enSum - initialEnergy) + 1 : 0;\\n        int ans2 = 0;\\n        for(int i = 0; i < n; i++) {\\n            if(initialExperience <= experience[i]) {\\n                ans2 += (experience[i] - initialExperience) + 1;\\n                initialExperience += (ans2 + experience[i]);\\n            }\\n            else {\\n                initialExperience += experience[i];\\n            }\\n            \\n            System.out.println(initialExperience);\\n        }\\n        System.out.println(ans1 + \" \" + ans2);\\n        return ans1 + ans2;\\n    }\\n}",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "class Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int n = energy.length;\\n        int enSum = 0;\\n        for(int en : energy) {\\n            enSum += en;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2456671,
                "title": "java-o-n-easy",
                "content": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int res = 0, n = energy.length, sum=0;\\n        for(int i=0; i<n-1; i++){\\n            sum+=energy[i];\\n        }\\n        res+=Math.max(0, energy[n-1]+1+sum-initialEnergy);\\n        for(int i=0; i<n; i++){\\n            if(experience[i]>=initialExperience){\\n                res += experience[i]+1-initialExperience;\\n                initialExperience = experience[i]+1;\\n            }\\n            initialExperience+=experience[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int res = 0, n = energy.length, sum=0;\\n        for(int i=0; i<n-1; i++){\\n            sum+=energy[i];\\n        }\\n        res+=Math.max(0, energy[n-1]+1+sum-initialEnergy);\\n        for(int i=0; i<n; i++){\\n            if(experience[i]>=initialExperience){\\n                res += experience[i]+1-initialExperience;\\n                initialExperience = experience[i]+1;\\n            }\\n            initialExperience+=experience[i];\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456643,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ini, int ie, vector<int>&numse, vector<int>& numsx)\\n    {\\n        int n=numse.size();\\n        int val1=ini;\\n        int count1=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(numse[i]>=val1)\\n            {\\n                count1+=(numse[i]-val1+1);\\n                val1+=(numse[i]-val1+1);\\n            }\\n            val1-=numse[i];\\n        }\\n         int val2=ie;\\n        int count2=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(numsx[i]>=val2)\\n            {\\n                count2+=(numsx[i]-val2+1);\\n                val2+=(count2);\\n            }\\n            val2+=numsx[i];\\n        }\\n        // cout<<count1<<\" \"<<count2<<endl;\\n        return count1+count2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ini, int ie, vector<int>&numse, vector<int>& numsx)\\n    {\\n        int n=numse.size();\\n        int val1=ini;\\n        int count1=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(numse[i]>=val1)\\n            {\\n                count1+=(numse[i]-val1+1);\\n                val1+=(numse[i]-val1+1);\\n            }\\n            val1-=numse[i];\\n        }\\n         int val2=ie;\\n        int count2=0;\\n        for(int i=0;i<n;i++)\\n        {\\n            if(numsx[i]>=val2)\\n            {\\n                count2+=(numsx[i]-val2+1);\\n                val2+=(count2);\\n            }\\n            val2+=numsx[i];\\n        }\\n        // cout<<count1<<\" \"<<count2<<endl;\\n        return count1+count2;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 4090441,
                "title": "one-line-solution",
                "content": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        return max(sum(energy)-initialEnergy+1, 0) + max(max(map(sub, experience, accumulate(experience, initial= initialExperience)))+1, 0)      \\n```\\n> More readable\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        cnt, max_cnt = initialExperience, 0\\n        for e in experience:\\n            max_cnt = max(e-cnt+1, max_cnt)\\n            cnt += e\\n        return max(sum(energy)-initialEnergy+1, 0) + max_cnt\\n```\\n\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        return max(sum(energy)-initialEnergy+1, 0) + max(max(map(sub, experience, accumulate(experience, initial= initialExperience)))+1, 0)      \\n```\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        cnt, max_cnt = initialExperience, 0\\n        for e in experience:\\n            max_cnt = max(e-cnt+1, max_cnt)\\n            cnt += e\\n        return max(sum(energy)-initialEnergy+1, 0) + max_cnt\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4089634,
                "title": "too-easy-to-understand-throughly-explained-beats-runtime-100-memory-71",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nThis problem can be solved with simple array traversal approach.\\nTake i as an opponent index, which should increment only when the player has strictly greater energy and experience than the opponent.\\nIf the player does not satisfied any of these condition then it should train for hours equivalnet to the difference b/w energy or experience (whichever is unsatisfied) + 1 (+1 because of strictly condition). This training hour can be counted by any variable.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n![image.png](https://assets.leetcode.com/users/images/ea84da01-69e8-43ed-a727-1e413665b43f_1695661187.3696287.png)\\n\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int energy, int experience, int[] Energy, int[] Experience) {\\n\\n        int count = 0;\\n        int n = Energy.length;\\n        int i = 0;\\n        while(i < n){\\n            //when the player energy and experience are greater than that of opponent\\n            //let them fight and decrease the energy and increse the experience of the player\\n            if(energy > Energy[i] && experience > Experience[i]){\\n                experience += Experience[i];\\n                energy -= Energy[i];\\n                i++;\\n                continue;\\n            }\\n            //if energy of player is less than the energy of the opponent\\n            //train hours equivalent to the differnces b/w energy + 1\\n            if(energy <= Energy[i]){\\n                count += Energy[i] - energy + 1;\\n                energy += Energy[i] - energy + 1;\\n            }\\n            //conditions for experience is same as energy\\n            if(experience <= Experience[i]){\\n                count += Experience[i] - experience + 1;\\n                experience += Experience[i] - experience + 1;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int energy, int experience, int[] Energy, int[] Experience) {\\n\\n        int count = 0;\\n        int n = Energy.length;\\n        int i = 0;\\n        while(i < n){\\n            //when the player energy and experience are greater than that of opponent\\n            //let them fight and decrease the energy and increse the experience of the player\\n            if(energy > Energy[i] && experience > Experience[i]){\\n                experience += Experience[i];\\n                energy -= Energy[i];\\n                i++;\\n                continue;\\n            }\\n            //if energy of player is less than the energy of the opponent\\n            //train hours equivalent to the differnces b/w energy + 1\\n            if(energy <= Energy[i]){\\n                count += Energy[i] - energy + 1;\\n                energy += Energy[i] - energy + 1;\\n            }\\n            //conditions for experience is same as energy\\n            if(experience <= Experience[i]){\\n                count += Experience[i] - experience + 1;\\n                experience += Experience[i] - experience + 1;\\n            }\\n        }\\n\\n        return count;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070487,
                "title": "java-greedy-beats-100",
                "content": "\\n\\n# Approach\\nSimple Greedy Approach. \\nYou Start with initial energy and experience. As you face a opponent, gain the extra energy and experience.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int ce = initialEnergy;\\n        int cp = initialExperience;\\n        int extraE = 0;\\n        int extraP = 0;\\n\\n        for(int i = 0; i < energy.length; i++)\\n        {\\n            if(ce <= energy[i])\\n            {\\n                int x = energy[i] - ce + 1;\\n                ce += x;\\n                extraE += x;\\n            }\\n            ce = ce - energy[i];\\n            if(cp <= experience[i])\\n            {\\n                int x = experience[i] - cp + 1;\\n                cp +=x;\\n                extraP += x;\\n            }\\n            cp += experience[i];\\n        }\\n\\n        return extraE + extraP;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int ce = initialEnergy;\\n        int cp = initialExperience;\\n        int extraE = 0;\\n        int extraP = 0;\\n\\n        for(int i = 0; i < energy.length; i++)\\n        {\\n            if(ce <= energy[i])\\n            {\\n                int x = energy[i] - ce + 1;\\n                ce += x;\\n                extraE += x;\\n            }\\n            ce = ce - energy[i];\\n            if(cp <= experience[i])\\n            {\\n                int x = experience[i] - cp + 1;\\n                cp +=x;\\n                extraP += x;\\n            }\\n            cp += experience[i];\\n        }\\n\\n        return extraE + extraP;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4011490,
                "title": "simple-condition-based-solution",
                "content": "# Intuition\\nFirst I thought it was a tough question for me given various conditions in questions but when I understood the problem then it seemed quite easy.\\n\\n# Approach\\nFirst I took the example given and broke it into different steps to better understand the question, then I wrote the steps needed to complete the code. After that, I implemented the code in the solution.\\n\\n# Complexity\\n- Time complexity:\\nO(n) -> n is the number of opponents in the energy and experience array.\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hours = 0;\\n\\n        int opponent = 0;\\n        while (opponent < energy.length) {\\n            // how much the opponent energy is more than initital energy\\n            int energyDiff = energy[opponent] - initialEnergy; \\n            // how much the opponent experience is more than initial experience\\n            int expDiff = experience[opponent] - initialExperience; \\n\\n            if (energyDiff >= 0) {\\n                initialEnergy += energyDiff + 1;\\n                hours += energyDiff + 1;\\n            }\\n\\n            if (expDiff >= 0) {\\n                initialExperience += expDiff + 1;\\n                hours += expDiff + 1;\\n            }\\n\\n            // Adjustments after the fight with opponent\\n            initialEnergy -= energy[opponent];\\n            initialExperience += experience[opponent];\\n            opponent++;\\n        }\\n\\n        return hours;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hours = 0;\\n\\n        int opponent = 0;\\n        while (opponent < energy.length) {\\n            // how much the opponent energy is more than initital energy\\n            int energyDiff = energy[opponent] - initialEnergy; \\n            // how much the opponent experience is more than initial experience\\n            int expDiff = experience[opponent] - initialExperience; \\n\\n            if (energyDiff >= 0) {\\n                initialEnergy += energyDiff + 1;\\n                hours += energyDiff + 1;\\n            }\\n\\n            if (expDiff >= 0) {\\n                initialExperience += expDiff + 1;\\n                hours += expDiff + 1;\\n            }\\n\\n            // Adjustments after the fight with opponent\\n            initialEnergy -= energy[opponent];\\n            initialExperience += experience[opponent];\\n            opponent++;\\n        }\\n\\n        return hours;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3989127,
                "title": "easy-approach-cpp",
                "content": "# Intuition\\nThe goal of this problem is to determine the minimum number of hours of training required to defeat all opponents in a competition. To do this, we need to consider two aspects: energy and experience. We need both energy and experience to defeat an opponent. So, we have two options during training: increase energy or increase experience.\\n\\n# Approach\\nWe can iterate through the opponents one by one and determine if we have enough energy and experience to defeat each opponent. If we don\\'t, we need to decide whether to increase energy, experience, or both to meet the requirements.\\n\\nHere\\'s the step-by-step approach:\\n\\n1. Initialize a variable `cnt` to keep track of the total training hours required.\\n\\n2. Iterate through the opponents from the first to the last.\\n\\n3. For each opponent, check if our current energy (`ini`) is greater than the opponent\\'s energy (`en[i]`) and our experience (`ie`) is greater than the opponent\\'s experience (`exp[i]`).\\n\\n   - If both conditions are met, we can defeat the opponent without training. Update `ie` by adding `exp[i]` and decrease `ini` by `en[i]`.\\n\\n   - If one or both conditions are not met, we need to train.\\n\\n4. Determine the training strategy based on the conditions:\\n\\n   - If `ini` is less than or equal to `en[i]` and `ie` is less than or equal to `exp[i]`, we need to increase both energy and experience. Calculate the hours required for both and add them to `cnt`.\\n\\n   - If `ini` is greater than `en[i]` and `ie` is less than or equal to `exp[i]`, we need to increase experience. Calculate the hours required to reach `exp[i]` and add them to `cnt`.\\n\\n   - If `ini` is less than or equal to `en[i]` and `ie` is greater than `exp[i]`, we need to increase energy. Calculate the hours required to reach `en[i]` and add them to `cnt`.\\n\\n5. Update `ini` and `ie` based on the training strategy.\\n\\n6. Repeat the process for the next opponent.\\n\\n7. After defeating all opponents, return `cnt` as the minimum training hours required.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the number of opponents. We iterate through the opponents once.\\n- Space complexity: O(1) as we use a constant amount of additional space.\\n\\n# Code\\n```cpp\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ini, int ie, vector<int>& en, vector<int>& exp) {\\n        int cnt = 0;\\n        for(int i = 0; i < en.size(); i++) {\\n            if(ini > en[i] && ie < exp[i]) {\\n                // We can defeat the opponent without training\\n                ie += exp[i];\\n                ini -= en[i];\\n            }\\n            else {\\n                if(ini <= en[i] && ie <= exp[i]) {\\n                    // Need to increase both energy and experience\\n                    cnt += (en[i] - ini + 1);\\n                    ini = 1;\\n                    cnt += (exp[i] - ie + 1);\\n                    ie += exp[i] + (exp[i] - ie + 1);\\n                }\\n                else if(ini > en[i] && ie <= exp[i]) {\\n                    // Need to increase experience\\n                    cnt += (exp[i] - ie + 1);\\n                    ie += exp[i] + (exp[i] - ie + 1);\\n                    ini -= en[i];\\n                }\\n                else if(ini <= en[i] && ie > exp[i]) {\\n                    // Need to increase energy\\n                    cnt += (en[i] - ini + 1);\\n                    ini = 1;\\n                    ie += exp[i];\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```\\n\\nThis code follows the described approach and calculates the minimum training hours required to win the competition.",
                "solutionTags": [
                    "C++"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ini, int ie, vector<int>& en, vector<int>& exp) {\\n        int cnt = 0;\\n        for(int i = 0; i < en.size(); i++) {\\n            if(ini > en[i] && ie < exp[i]) {\\n                // We can defeat the opponent without training\\n                ie += exp[i];\\n                ini -= en[i];\\n            }\\n            else {\\n                if(ini <= en[i] && ie <= exp[i]) {\\n                    // Need to increase both energy and experience\\n                    cnt += (en[i] - ini + 1);\\n                    ini = 1;\\n                    cnt += (exp[i] - ie + 1);\\n                    ie += exp[i] + (exp[i] - ie + 1);\\n                }\\n                else if(ini > en[i] && ie <= exp[i]) {\\n                    // Need to increase experience\\n                    cnt += (exp[i] - ie + 1);\\n                    ie += exp[i] + (exp[i] - ie + 1);\\n                    ini -= en[i];\\n                }\\n                else if(ini <= en[i] && ie > exp[i]) {\\n                    // Need to increase energy\\n                    cnt += (en[i] - ini + 1);\\n                    ini = 1;\\n                    ie += exp[i];\\n                }\\n            }\\n        }\\n        return cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3981150,
                "title": "beats-100-00-of-users-with-python3",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n1. Initialize variables exdif to track the difference between current experience and the opponent\\'s experience, and ensum to track the sum of energy.\\n2. Iterate through the opponents\\' attributes using a zip of energy and experience lists.\\n    - If your initial experience is less than or equal to the opponent\\'s experience, update exdif to ensure that you have a positive difference for the required training.\\n    - Update your experience by adding the opponent\\'s experience and the energy sum by adding the opponent\\'s energy.\\n3. Calculate the result by finding the maximum between the difference of total energy and initial energy (plus one to represent the time spent training) and exdif. If the calculated result is negative, replace it with zero.\\n4. Return the calculated result.\\n\\n# Complexity\\n- Time complexity: **O(n)**\\n\\nThe time complexity of the solution is **O(n)**, where n is the length of the energy and experience lists. The loop iterates through the lists once to calculate the required values.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n\\nThe space complexity of this solution is **O(1)**, as it only uses a constant amount of additional space to store the variables (exdif and ensum) regardless of the size of the input lists.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        exdif = 0\\n        ensum = 0\\n        \\n        for e, exp in zip(energy, experience):\\n            if initialExperience <= exp:\\n                exdif = max(exdif, exp + 1 - initialExperience)\\n            \\n            initialExperience += exp\\n            ensum += e\\n        \\n        return max(ensum - initialEnergy + 1, 0) + exdif\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        exdif = 0\\n        ensum = 0\\n        \\n        for e, exp in zip(energy, experience):\\n            if initialExperience <= exp:\\n                exdif = max(exdif, exp + 1 - initialExperience)\\n            \\n            initialExperience += exp\\n            ensum += e\\n        \\n        return max(ensum - initialEnergy + 1, 0) + exdif\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3980996,
                "title": "solved-using-greedy-algorithm",
                "content": "# Intuition\\nThe problem asks to find minimum number of training hours hence it can be solved using DP or greedy algorithm.\\n\\n# Approach\\nThe idea is to calculate difference before each component for engery and experience and add them into results. \\n\\n# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n         int hours = 0;\\n\\n        for (int i = 0; i < energy.length; ++i) {\\n            // Adding the missing amount of energy\\n            int extraEnergy = Math.max(0, energy[i] - initialEnergy + 1);\\n            initialEnergy += extraEnergy;\\n\\n            // Adding the missing amount of experience\\n            int extraExperience = Math.max(0, experience[i] - initialExperience + 1);\\n            initialExperience += extraExperience;\\n\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n\\n            hours += extraEnergy + extraExperience;\\n        }\\n\\n        return hours;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n         int hours = 0;\\n\\n        for (int i = 0; i < energy.length; ++i) {\\n            // Adding the missing amount of energy\\n            int extraEnergy = Math.max(0, energy[i] - initialEnergy + 1);\\n            initialEnergy += extraEnergy;\\n\\n            // Adding the missing amount of experience\\n            int extraExperience = Math.max(0, experience[i] - initialExperience + 1);\\n            initialExperience += extraExperience;\\n\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n\\n            hours += extraEnergy + extraExperience;\\n        }\\n\\n        return hours;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3977821,
                "title": "clean-fast-beginner-friendly-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nMake a variable to keep track of training hour then prefix_sum and simple mathematical arithmetic operations(addition and subtraction) \\nto keep track value of energy and experience.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nPrefix_sum approach and simple maths addition substraction is approached\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nAs array is traversed once complexity order is O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nNo extra space used -->therefore, complexity is O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int tr_hour=0;\\n        int n=energy.size();\\n        int ep=initialExperience;\\n        int e=initialEnergy;\\n\\n        for(int i=0;i<n;i++ ){\\n            if(energy[i]>e && experience[i]>ep){\\n                tr_hour+=energy[i]-e+experience[i]-ep;\\n                e+=energy[i]-e;\\n                ep+=experience[i]-ep;\\n            } \\n            if(energy[i]>e && experience[i]<ep){\\n                tr_hour+=energy[i]-e;\\n                e+=energy[i]-e;\\n            } \\n            if(energy[i]<e && experience[i]>ep){\\n                tr_hour+=experience[i]-ep;\\n                ep+=experience[i]-ep;\\n            } \\n            if(energy[i]==e && experience[i]==ep){\\n                 tr_hour+=2;\\n                 e++;\\n                 ep++;\\n            }\\n            if(energy[i]==e && experience[i]>ep){\\n                tr_hour+=1+experience[i]-ep;\\n                e++;\\n                ep+=experience[i]-ep;\\n            }\\n            \\n             \\n            if(experience[i]==ep && energy[i]>e){\\n                tr_hour+=1+energy[i]-e;\\n                ep++;\\n                e+=energy[i]-e;\\n            }\\n            if(experience[i]==ep){\\n                tr_hour+=1;\\n                ep++;\\n               \\n            }\\n            if(energy[i]==e ){\\n                tr_hour+=1;\\n                e++;\\n                \\n            }\\n             \\n            e=e-energy[i];\\n            ep=ep+experience[i];\\n\\n        }\\n        return tr_hour;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int tr_hour=0;\\n        int n=energy.size();\\n        int ep=initialExperience;\\n        int e=initialEnergy;\\n\\n        for(int i=0;i<n;i++ ){\\n            if(energy[i]>e && experience[i]>ep){\\n                tr_hour+=energy[i]-e+experience[i]-ep;\\n                e+=energy[i]-e;\\n                ep+=experience[i]-ep;\\n            } \\n            if(energy[i]>e && experience[i]<ep){\\n                tr_hour+=energy[i]-e;\\n                e+=energy[i]-e;\\n            } \\n            if(energy[i]<e && experience[i]>ep){\\n                tr_hour+=experience[i]-ep;\\n                ep+=experience[i]-ep;\\n            } \\n            if(energy[i]==e && experience[i]==ep){\\n                 tr_hour+=2;\\n                 e++;\\n                 ep++;\\n            }\\n            if(energy[i]==e && experience[i]>ep){\\n                tr_hour+=1+experience[i]-ep;\\n                e++;\\n                ep+=experience[i]-ep;\\n            }\\n            \\n             \\n            if(experience[i]==ep && energy[i]>e){\\n                tr_hour+=1+energy[i]-e;\\n                ep++;\\n                e+=energy[i]-e;\\n            }\\n            if(experience[i]==ep){\\n                tr_hour+=1;\\n                ep++;\\n               \\n            }\\n            if(energy[i]==e ){\\n                tr_hour+=1;\\n                e++;\\n                \\n            }\\n             \\n            e=e-energy[i];\\n            ep=ep+experience[i];\\n\\n        }\\n        return tr_hour;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3961230,
                "title": "easy-solution-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(N)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(1)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int training = 0, temp;\\n        for(int i=0; i < energy.size(); i++){\\n            bool flag = 0;\\n            if(initialEnergy > energy[i] and initialExperience > experience[i]){\\n                initialEnergy-=energy[i];\\n                initialExperience+=experience[i];\\n            }\\n            else{\\n                if(initialEnergy <= energy[i]){\\n                    temp = energy[i]-initialEnergy;\\n                    if(temp==0) temp = 1;\\n                    initialEnergy+=temp;\\n                    training+=temp;\\n                    flag = 1;\\n                }\\n                if(initialExperience <= experience[i]){\\n                    temp = experience[i] - initialExperience;\\n                    if(temp==0) temp = 1;\\n                    initialExperience+=temp;\\n                    training+=temp;\\n                    flag = 1;\\n                }\\n                if(flag) i--;\\n            }\\n        }\\n        return training;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int training = 0, temp;\\n        for(int i=0; i < energy.size(); i++){\\n            bool flag = 0;\\n            if(initialEnergy > energy[i] and initialExperience > experience[i]){\\n                initialEnergy-=energy[i];\\n                initialExperience+=experience[i];\\n            }\\n            else{\\n                if(initialEnergy <= energy[i]){\\n                    temp = energy[i]-initialEnergy;\\n                    if(temp==0) temp = 1;\\n                    initialEnergy+=temp;\\n                    training+=temp;\\n                    flag = 1;\\n                }\\n                if(initialExperience <= experience[i]){\\n                    temp = experience[i] - initialExperience;\\n                    if(temp==0) temp = 1;\\n                    initialExperience+=temp;\\n                    training+=temp;\\n                    flag = 1;\\n                }\\n                if(flag) i--;\\n            }\\n        }\\n        return training;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3930141,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n  public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy,\\n                              int[] experience) {\\n    return getRequiredEnergy(initialEnergy, energy) +\\n        getRequiredExperience(initialExperience, experience);\\n  }\\n\\n  private int getRequiredEnergy(int initialEnergy, int[] energy) {\\n    return Math.max(0, Arrays.stream(energy).sum() + 1 - initialEnergy);\\n  }\\n\\n  private int getRequiredExperience(int currentExperience, int[] experience) {\\n    int requiredExperience = 0;\\n    for (final int e : experience) {\\n      if (e >= currentExperience) {\\n        requiredExperience += e + 1 - currentExperience;\\n        currentExperience += e + 1 - currentExperience;\\n      }\\n      currentExperience += e;\\n    }\\n    return requiredExperience;\\n  }\\n}\\n\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n  public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy,\\n                              int[] experience) {\\n    return getRequiredEnergy(initialEnergy, energy) +\\n        getRequiredExperience(initialExperience, experience);\\n  }\\n\\n  private int getRequiredEnergy(int initialEnergy, int[] energy) {\\n    return Math.max(0, Arrays.stream(energy).sum() + 1 - initialEnergy);\\n  }\\n\\n  private int getRequiredExperience(int currentExperience, int[] experience) {\\n    int requiredExperience = 0;\\n    for (final int e : experience) {\\n      if (e >= currentExperience) {\\n        requiredExperience += e + 1 - currentExperience;\\n        currentExperience += e + 1 - currentExperience;\\n      }\\n      currentExperience += e;\\n    }\\n    return requiredExperience;\\n  }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3925492,
                "title": "solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        \\n        int count = 0;\\n        int diff;\\n\\n        for(int i=0; i<energy.size(); i++){\\n            if(initialEnergy <= energy[i]){\\n                diff = energy[i] - initialEnergy + 1;\\n                initialEnergy += diff;\\n                count += diff;\\n            }\\n            if(initialExperience <= experience[i]){\\n                diff = (experience[i] - initialExperience + 1);\\n                initialExperience += diff;\\n                count += diff;\\n            }\\n\\n            initialExperience += experience[i];\\n            initialEnergy -= energy[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        \\n        int count = 0;\\n        int diff;\\n\\n        for(int i=0; i<energy.size(); i++){\\n            if(initialEnergy <= energy[i]){\\n                diff = energy[i] - initialEnergy + 1;\\n                initialEnergy += diff;\\n                count += diff;\\n            }\\n            if(initialExperience <= experience[i]){\\n                diff = (experience[i] - initialExperience + 1);\\n                initialExperience += diff;\\n                count += diff;\\n            }\\n\\n            initialExperience += experience[i];\\n            initialEnergy -= energy[i];\\n        }\\n        return count;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3879749,
                "title": "java-0ms-beats-100-00",
                "content": "# Intuition & Approach\\n- perform a simulation\\n- keep track of each round\\'s shortfalls\\n\\n\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n\\n        int n = energy.length;\\n\\n        int energyGap = 0;  // what we\\'ll return\\n        int experienceGap = 0;  // what we\\'ll return\\n\\n        int curEnergy = initialEnergy;\\n        int curExperience = initialExperience;\\n\\n        for (int opponent = 0; opponent < n; ++opponent) {\\n\\n            int energyDelta = curEnergy - energy[opponent];\\n            if (energyDelta <= 0) {\\n                int energyNeeded = -1 * energyDelta + 1;\\n                curEnergy += energyNeeded;\\n                energyGap += energyNeeded;\\n            }\\n\\n            int experienceDelta = curExperience - experience[opponent];\\n            if (experienceDelta <= 0) {\\n                int experienceNeeded = -1 * experienceDelta + 1;\\n                curExperience += experienceNeeded;\\n                experienceGap += experienceNeeded;\\n            }\\n\\n            // post-opponent stat changes\\n            curExperience += experience[opponent];\\n            curEnergy -= energy[opponent];\\n        }\\n\\n        return energyGap + experienceGap;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n\\n        int n = energy.length;\\n\\n        int energyGap = 0;  // what we\\'ll return\\n        int experienceGap = 0;  // what we\\'ll return\\n\\n        int curEnergy = initialEnergy;\\n        int curExperience = initialExperience;\\n\\n        for (int opponent = 0; opponent < n; ++opponent) {\\n\\n            int energyDelta = curEnergy - energy[opponent];\\n            if (energyDelta <= 0) {\\n                int energyNeeded = -1 * energyDelta + 1;\\n                curEnergy += energyNeeded;\\n                energyGap += energyNeeded;\\n            }\\n\\n            int experienceDelta = curExperience - experience[opponent];\\n            if (experienceDelta <= 0) {\\n                int experienceNeeded = -1 * experienceDelta + 1;\\n                curExperience += experienceNeeded;\\n                experienceGap += experienceNeeded;\\n            }\\n\\n            // post-opponent stat changes\\n            curExperience += experience[opponent];\\n            curEnergy -= energy[opponent];\\n        }\\n\\n        return energyGap + experienceGap;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3875470,
                "title": "easy-c-solution-prefix-sum-greedy",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int in, int ix, vector<int>& en, vector<int>& ex) {\\n        int train=0;\\n        int total_en=0;\\n        for(int i=0;i<en.size();i++){\\n            total_en+=en[i];\\n        }\\n        if(total_en-in>=0){\\n            train+=total_en-in+1;\\n        }\\n        for(int i=0;i<ex.size();i++){\\n            if(ex[i]-ix>=0){\\n                train+=ex[i]-ix+1;\\n                ix+=ex[i]-ix+1;\\n            }\\n            ix+=ex[i];\\n        }\\n        \\n        return train;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Greedy",
                    "Prefix Sum"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int in, int ix, vector<int>& en, vector<int>& ex) {\\n        int train=0;\\n        int total_en=0;\\n        for(int i=0;i<en.size();i++){\\n            total_en+=en[i];\\n        }\\n        if(total_en-in>=0){\\n            train+=total_en-in+1;\\n        }\\n        for(int i=0;i<ex.size();i++){\\n            if(ex[i]-ix>=0){\\n                train+=ex[i]-ix+1;\\n                ix+=ex[i]-ix+1;\\n            }\\n            ix+=ex[i];\\n        }\\n        \\n        return train;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3869811,
                "title": "easy-cpp-solution-beats-74-8-in-runtime-beginner-friendly",
                "content": "![image.png](https://assets.leetcode.com/users/images/d38d7c19-3b83-4f30-913a-2bb291bc3c2b_1691293736.2784266.png)\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ie, int iE, vector<int>& e, vector<int>& E) {\\n        // Temporary variables\\n        int ideale = ie, idealE = iE;\\n        // ext1 for extra energy, ext for extra experience required\\n        int ext1 = 0, ext = 0;\\n        for(int i=0; i<e.size(); i++)\\n            ideale -= e[i];\\n        \\n        for(int i=0; i<E.size(); i++){\\n            if(idealE <= E[i]){\\n                ext+= (E[i] - idealE) + 1;\\n                idealE+=(E[i] - idealE) + 1;\\n            }\\n            idealE += E[i];\\n        }\\n        \\n        if(ideale <= 0) ext1 = (ideale*-1) + 1;\\n\\n        return ext1 + ext;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int ie, int iE, vector<int>& e, vector<int>& E) {\\n        // Temporary variables\\n        int ideale = ie, idealE = iE;\\n        // ext1 for extra energy, ext for extra experience required\\n        int ext1 = 0, ext = 0;\\n        for(int i=0; i<e.size(); i++)\\n            ideale -= e[i];\\n        \\n        for(int i=0; i<E.size(); i++){\\n            if(idealE <= E[i]){\\n                ext+= (E[i] - idealE) + 1;\\n                idealE+=(E[i] - idealE) + 1;\\n            }\\n            idealE += E[i];\\n        }\\n        \\n        if(ideale <= 0) ext1 = (ideale*-1) + 1;\\n\\n        return ext1 + ext;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3862275,
                "title": "2383-minimum-hours-of-training-to-win-a-competition-java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFirst try to solve the total energy and additional hour required the run for the exp part and keep on adding the exp else calculate the additional training hours required to gain that experience.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hoursEnergy = 0;\\n        int totalEnergy = 0;\\n        for (int i = 0 ; i < energy.length; i++) {\\n            totalEnergy += energy[i];\\n        }\\n        if (totalEnergy >= initialEnergy) {\\n            hoursEnergy = totalEnergy - initialEnergy + 1;\\n            initialEnergy += hoursEnergy;\\n        }\\n        \\n        int hoursExp = 0;\\n        for (int i = 0 ; i < experience.length; i++) {\\n            if (initialExperience > experience[i]) {\\n                initialExperience += experience[i];\\n                \\n            } else {\\n                int temp = experience[i] + 1 - initialExperience;\\n                hoursExp += temp;\\n                initialExperience += temp;\\n                initialExperience += experience[i];\\n            }\\n        }\\n        return hoursExp + hoursEnergy;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hoursEnergy = 0;\\n        int totalEnergy = 0;\\n        for (int i = 0 ; i < energy.length; i++) {\\n            totalEnergy += energy[i];\\n        }\\n        if (totalEnergy >= initialEnergy) {\\n            hoursEnergy = totalEnergy - initialEnergy + 1;\\n            initialEnergy += hoursEnergy;\\n        }\\n        \\n        int hoursExp = 0;\\n        for (int i = 0 ; i < experience.length; i++) {\\n            if (initialExperience > experience[i]) {\\n                initialExperience += experience[i];\\n                \\n            } else {\\n                int temp = experience[i] + 1 - initialExperience;\\n                hoursExp += temp;\\n                initialExperience += temp;\\n                initialExperience += experience[i];\\n            }\\n        }\\n        return hoursExp + hoursEnergy;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3849369,
                "title": "easy-to-understand-linear-time-complexity-constant-space-complexity",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        \\n        \\n        minimum = max(sum(energy) - initialEnergy + 1, 0)\\n        \\n        for e in experience:\\n            diff = max(0, e+1 - initialExperience)\\n            if diff >= 0:\\n                minimum += diff\\n            initialExperience += e + diff\\n        return minimum\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        \\n        \\n        minimum = max(sum(energy) - initialEnergy + 1, 0)\\n        \\n        for e in experience:\\n            diff = max(0, e+1 - initialExperience)\\n            if diff >= 0:\\n                minimum += diff\\n            initialExperience += e + diff\\n        return minimum\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3827142,
                "title": "intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int total = 0;\\n        for(int i = 0; i<energy.size(); i++){\\n            if(initialEnergy <= energy[i]){\\n                total += 1 + energy[i] - initialEnergy;\\n                initialEnergy = 1;\\n            }\\n            else{\\n                initialEnergy-=energy[i];\\n            }\\n            if(initialExperience <= experience[i]){\\n                total += 1 + experience[i] - initialExperience;\\n                initialExperience = 2*experience[i] + 1;\\n            }\\n            else{\\n                initialExperience+=experience[i];\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int total = 0;\\n        for(int i = 0; i<energy.size(); i++){\\n            if(initialEnergy <= energy[i]){\\n                total += 1 + energy[i] - initialEnergy;\\n                initialEnergy = 1;\\n            }\\n            else{\\n                initialEnergy-=energy[i];\\n            }\\n            if(initialExperience <= experience[i]){\\n                total += 1 + experience[i] - initialExperience;\\n                initialExperience = 2*experience[i] + 1;\\n            }\\n            else{\\n                initialExperience+=experience[i];\\n            }\\n        }\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3821902,
                "title": "swift-one-liner-o-n-time-o-1-space-beats-100",
                "content": "\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    func minNumberOfHours(_ initialEnergy: Int, _ initialExperience: Int, _ energy: [Int], _ experience: [Int]) -> Int {\\n        max(energy.reduce(1-initialEnergy, +),0)\\n        + experience.reduce((initialExperience, 0)) { ($0.0 + $1, max($0.1, 0, $1 - $0.0 + 1)) }.1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minNumberOfHours(_ initialEnergy: Int, _ initialExperience: Int, _ energy: [Int], _ experience: [Int]) -> Int {\\n        max(energy.reduce(1-initialEnergy, +),0)\\n        + experience.reduce((initialExperience, 0)) { ($0.0 + $1, max($0.1, 0, $1 - $0.0 + 1)) }.1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3820262,
                "title": "js-solution",
                "content": "\\n# Code\\n```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let energySum=1;\\n    let experienceSum=0;\\n    let minExperience=0;\\n    let n=energy.length;\\n    for(let i=0;i<n;i++){\\n        energySum+=energy[i];\\n        if((experience[i]>experienceSum)&&(minExperience<(experience[i]-experienceSum))){\\n            minExperience=experience[i]-experienceSum;\\n        }\\n        experienceSum+=experience[i];\\n    }\\n    let finalEnergy = ((energySum-initialEnergy)>0)?energySum-initialEnergy:0; \\n    let finalExperience = (minExperience>=initialExperience)?(minExperience-initialExperience+1):0; \\n    console.log(finalEnergy,finalExperience);\\n    return finalEnergy+finalExperience;\\n\\n\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let energySum=1;\\n    let experienceSum=0;\\n    let minExperience=0;\\n    let n=energy.length;\\n    for(let i=0;i<n;i++){\\n        energySum+=energy[i];\\n        if((experience[i]>experienceSum)&&(minExperience<(experience[i]-experienceSum))){\\n            minExperience=experience[i]-experienceSum;\\n        }\\n        experienceSum+=experience[i];\\n    }\\n    let finalEnergy = ((energySum-initialEnergy)>0)?energySum-initialEnergy:0; \\n    let finalExperience = (minExperience>=initialExperience)?(minExperience-initialExperience+1):0; \\n    console.log(finalEnergy,finalExperience);\\n    return finalEnergy+finalExperience;\\n\\n\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3760857,
                "title": "java-greedy-explained",
                "content": "**Idea:** \\n* In each iteration, find the differences in energies and experience, and increase hours by 1 + diff if required\\n* Now you\\'re ready to fight this opponent, so decrease energy and increase experience by this opponent\\'s values\\n* Greedy approach ensures that the hours are minimum\\n>**T/S:** O(n)/O(1), where n = size(energy)\\n```\\npublic int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n\\tvar hours = 0;\\n\\n\\tfor (var i = 0; i < energy.length; i++) {\\n\\t\\tvar energyDiff = energy[i] - initialEnergy;\\n\\t\\tvar xpDiff = experience[i] - initialExperience;\\n\\n\\t\\tif (energyDiff++ >= 0) {\\n\\t\\t\\thours += energyDiff;\\n\\t\\t\\tinitialEnergy += energyDiff;\\n\\t\\t}\\n\\t\\tif (xpDiff++ >= 0) {\\n\\t\\t\\thours += xpDiff;\\n\\t\\t\\tinitialExperience += xpDiff;\\n\\t\\t}\\n\\n\\t\\tinitialEnergy -= energy[i];\\n\\t\\tinitialExperience += experience[i];\\n\\t}\\n\\n\\treturn hours;\\n}\\n```\\n***Please upvote if this helps***",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n\\tvar hours = 0;\\n\\n\\tfor (var i = 0; i < energy.length; i++) {\\n\\t\\tvar energyDiff = energy[i] - initialEnergy;\\n\\t\\tvar xpDiff = experience[i] - initialExperience;\\n\\n\\t\\tif (energyDiff++ >= 0) {\\n\\t\\t\\thours += energyDiff;\\n\\t\\t\\tinitialEnergy += energyDiff;\\n\\t\\t}\\n\\t\\tif (xpDiff++ >= 0) {\\n\\t\\t\\thours += xpDiff;\\n\\t\\t\\tinitialExperience += xpDiff;\\n\\t\\t}\\n\\n\\t\\tinitialEnergy -= energy[i];\\n\\t\\tinitialExperience += experience[i];\\n\\t}\\n\\n\\treturn hours;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3754868,
                "title": "c-3ms",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int curr_experience = initialExperience;\\n        int curr_energy = initialEnergy;\\n        \\n        int additional_experience_needed = 0;\\n        int additional_energy_needed = 0;\\n        \\n        const auto N = energy.size();\\n        for(size_t i = 0; i < N; ++i) {\\n            // check if we need additional hours of trainings for experience\\n            int delta = max(0, experience[i] - curr_experience + 1);\\n            additional_experience_needed += delta;\\n            curr_experience += delta + experience[i];\\n\\n            // check if we need additional hours of trainings for energy\\n            delta = max(0, energy[i] - curr_energy + 1);\\n            additional_energy_needed += delta;\\n            curr_energy += delta - energy[i];\\n        }\\n                        \\n        return additional_energy_needed + additional_experience_needed;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int curr_experience = initialExperience;\\n        int curr_energy = initialEnergy;\\n        \\n        int additional_experience_needed = 0;\\n        int additional_energy_needed = 0;\\n        \\n        const auto N = energy.size();\\n        for(size_t i = 0; i < N; ++i) {\\n            // check if we need additional hours of trainings for experience\\n            int delta = max(0, experience[i] - curr_experience + 1);\\n            additional_experience_needed += delta;\\n            curr_experience += delta + experience[i];\\n\\n            // check if we need additional hours of trainings for energy\\n            delta = max(0, energy[i] - curr_energy + 1);\\n            additional_energy_needed += delta;\\n            curr_energy += delta - energy[i];\\n        }\\n                        \\n        return additional_energy_needed + additional_experience_needed;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3739430,
                "title": "greedy-c-time-o-n-space-o-1",
                "content": "# Approach\\nTrain if needed, then fight.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int t = 0;\\n        int n = energy.size();\\n        for(int i = 0; i < n ; ){\\n            if(initialEnergy > energy[i] && initialExperience > experience[i]){\\n                initialEnergy -= energy[i];\\n                initialExperience += experience[i];\\n                i++;\\n            }\\n            else{\\n                if(initialEnergy <= energy[i]){\\n                    t += (energy[i] - initialEnergy +1);\\n                    initialEnergy += (energy[i] - initialEnergy + 1);\\n                }\\n                if(initialExperience <= experience[i]){\\n                    t += (experience[i] - initialExperience +1);\\n                    initialExperience += (experience[i] - initialExperience + 1);\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int t = 0;\\n        int n = energy.size();\\n        for(int i = 0; i < n ; ){\\n            if(initialEnergy > energy[i] && initialExperience > experience[i]){\\n                initialEnergy -= energy[i];\\n                initialExperience += experience[i];\\n                i++;\\n            }\\n            else{\\n                if(initialEnergy <= energy[i]){\\n                    t += (energy[i] - initialEnergy +1);\\n                    initialEnergy += (energy[i] - initialEnergy + 1);\\n                }\\n                if(initialExperience <= experience[i]){\\n                    t += (experience[i] - initialExperience +1);\\n                    initialExperience += (experience[i] - initialExperience + 1);\\n                }\\n            }\\n        }\\n        return t;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3719618,
                "title": "simple-javascript-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n        let count=0;\\n        for (let i = 0; i < energy.length; i++){\\n            if (initialExperience <= experience[i]){\\n                count+= experience[i]-initialExperience+1;\\n                initialExperience+= experience[i]-initialExperience+1;      \\n            }\\n            initialEnergy-= energy[i];           \\n            initialExperience+= experience[i];\\n        }\\n        if (initialEnergy < 1) count += 1-initialEnergy;\\n        return count;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n        let count=0;\\n        for (let i = 0; i < energy.length; i++){\\n            if (initialExperience <= experience[i]){\\n                count+= experience[i]-initialExperience+1;\\n                initialExperience+= experience[i]-initialExperience+1;      \\n            }\\n            initialEnergy-= energy[i];           \\n            initialExperience+= experience[i];\\n        }\\n        if (initialEnergy < 1) count += 1-initialEnergy;\\n        return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3714206,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int hour = 0 , prev = 0;\\n        int i = 0;\\n        while (i<energy.size()){\\n            if (initialEnergy <= energy[i]){\\n                hour += 1 + (energy[i]-initialEnergy);\\n                initialEnergy += 1 + (energy[i]-initialEnergy);\\n            }\\n            if (initialExperience <= experience[i]){\\n                hour += 1 + (experience[i] - initialExperience);\\n                initialExperience += 1 + (experience[i] - initialExperience);\\n            }\\n            \\n            if (hour != prev){\\n                prev = hour;\\n                continue;\\n            }\\n            if (initialEnergy > energy[i] && initialExperience > experience[i]){\\n                initialEnergy -= energy[i];\\n                initialExperience += experience[i];\\n                prev = hour;\\n                i++;\\n            }\\n        }\\n        return hour;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int hour = 0 , prev = 0;\\n        int i = 0;\\n        while (i<energy.size()){\\n            if (initialEnergy <= energy[i]){\\n                hour += 1 + (energy[i]-initialEnergy);\\n                initialEnergy += 1 + (energy[i]-initialEnergy);\\n            }\\n            if (initialExperience <= experience[i]){\\n                hour += 1 + (experience[i] - initialExperience);\\n                initialExperience += 1 + (experience[i] - initialExperience);\\n            }\\n            \\n            if (hour != prev){\\n                prev = hour;\\n                continue;\\n            }\\n            if (initialEnergy > energy[i] && initialExperience > experience[i]){\\n                initialEnergy -= energy[i];\\n                initialExperience += experience[i];\\n                prev = hour;\\n                i++;\\n            }\\n        }\\n        return hour;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3694286,
                "title": "python-easy-one-o-n-beats-93",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        a = sum(energy)\\n        hours = 0\\n        if initialEnergy<=a:\\n            hours+=(a-initialEnergy)+1\\n\\n        for i in experience:\\n            if initialExperience<=i:\\n                hours += i-initialExperience+1\\n                initialExperience += i+(i-initialExperience+1)\\n            else:\\n                initialExperience += i\\n\\n        return hours\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        a = sum(energy)\\n        hours = 0\\n        if initialEnergy<=a:\\n            hours+=(a-initialEnergy)+1\\n\\n        for i in experience:\\n            if initialExperience<=i:\\n                hours += i-initialExperience+1\\n                initialExperience += i+(i-initialExperience+1)\\n            else:\\n                initialExperience += i\\n\\n        return hours\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3665711,
                "title": "minimum-hours-of-training-to-win-a-competition",
                "content": "Simple Approach\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int ie, vector<int>& energy, vector<int>& ex) {\\n        int val=0,sum=0;\\n        for(int i=0;i<energy.size();i++)\\n        {\\n            sum+=energy[i];\\n        }\\n        for(int i=0;i<energy.size();i++)\\n        {\\n            if(ie>ex[i])\\n            {\\n                ie=ie+ex[i];\\n            }\\n            else\\n            {\\n                int diff=(ex[i]-ie)+1;\\n                val+=diff;\\n                ie=ie+diff;\\n                ie=ie+ex[i];\\n            }\\n        }\\n        if(initialEnergy>sum)\\n        {\\n            return val;\\n        }\\n            return (sum+1-initialEnergy+val);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int ie, vector<int>& energy, vector<int>& ex) {\\n        int val=0,sum=0;\\n        for(int i=0;i<energy.size();i++)\\n        {\\n            sum+=energy[i];\\n        }\\n        for(int i=0;i<energy.size();i++)\\n        {\\n            if(ie>ex[i])\\n            {\\n                ie=ie+ex[i];\\n            }\\n            else\\n            {\\n                int diff=(ex[i]-ie)+1;\\n                val+=diff;\\n                ie=ie+diff;\\n                ie=ie+ex[i];\\n            }\\n        }\\n        if(initialEnergy>sum)\\n        {\\n            return val;\\n        }\\n            return (sum+1-initialEnergy+val);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3664513,
                "title": "c-brute-force-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int sum_e=0;\\n        for(auto it:energy){\\n            sum_e=sum_e+it;\\n        }\\n        int hour;\\n       if(sum_e<initialEnergy){\\n           hour=0;\\n       }\\n       else{\\n       hour=sum_e+1-initialEnergy;\\n       }\\n       \\n   \\n       int sum=initialExperience;\\n        if (experience.size()> 0 && sum <= experience[0] && initialEnergy < energy[0]) {\\n            hour = hour + experience[0] - sum + 1;\\n            sum = experience[0] + 1;\\n        }\\n       for(int i=0;i<experience.size();i++){\\n           if(sum<=experience[i]){\\n               hour=hour+experience[i]-sum+1;\\n                sum = experience[i] + 1;\\n           }\\n           sum=sum+experience[i];\\n\\n       }\\n       cout<<hour;\\n       if(hour<0)return 0;\\n\\n\\n        return hour;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int sum_e=0;\\n        for(auto it:energy){\\n            sum_e=sum_e+it;\\n        }\\n        int hour;\\n       if(sum_e<initialEnergy){\\n           hour=0;\\n       }\\n       else{\\n       hour=sum_e+1-initialEnergy;\\n       }\\n       \\n   \\n       int sum=initialExperience;\\n        if (experience.size()> 0 && sum <= experience[0] && initialEnergy < energy[0]) {\\n            hour = hour + experience[0] - sum + 1;\\n            sum = experience[0] + 1;\\n        }\\n       for(int i=0;i<experience.size();i++){\\n           if(sum<=experience[i]){\\n               hour=hour+experience[i]-sum+1;\\n                sum = experience[i] + 1;\\n           }\\n           sum=sum+experience[i];\\n\\n       }\\n       cout<<hour;\\n       if(hour<0)return 0;\\n\\n\\n        return hour;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3653457,
                "title": "ruby-solution-with-explanation-100-100",
                "content": "# Intuition\\nWe can figure out energy ahead of time, but we figure out expeirence by going into fights and adjusting as needed.\\n\\n# Approach\\n1. Find the sum of energy and compare with initial energy.  If initial energy is bigger, we don\\'t have to train for more energy at all.  Otherwise, we need to train enough to make them equal, plus 1.\\n2. Go through the opponents and compare experience:\\n    - If your experience is higher, add their experience without changing total.\\n    - If you experience is *lower*, add the difference (subtract the negative difference) from count, and subtract 1 more.  You need to train enough to be one more, plus you\\'ll add their experience, so you final experience will be double theirs + 1.\\n3. Return count.\\n\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\ndef min_number_of_hours(initial_energy, initial_experience, energy, experience)\\n    count = initial_energy > energy.sum ? 0 : energy.sum + 1 - initial_energy\\n\\n    (0...experience.length).each do |i|\\n        diff = initial_experience - experience[i]\\n        if diff > 0\\n            initial_experience += experience[i]\\n        else\\n            count -= diff - 1\\n            initial_experience = 2 * experience[i] + 1\\n        end\\n    end\\n\\n    count\\nend\\n```",
                "solutionTags": [
                    "Ruby"
                ],
                "code": "```\\ndef min_number_of_hours(initial_energy, initial_experience, energy, experience)\\n    count = initial_energy > energy.sum ? 0 : energy.sum + 1 - initial_energy\\n\\n    (0...experience.length).each do |i|\\n        diff = initial_experience - experience[i]\\n        if diff > 0\\n            initial_experience += experience[i]\\n        else\\n            count -= diff - 1\\n            initial_experience = 2 * experience[i] + 1\\n        end\\n    end\\n\\n    count\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3650217,
                "title": "java-o-n-time",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hours = 0;\\n        for(int i = 0; i < energy.length;i++){\\n            if(initialEnergy <= energy[i]){\\n            hours += energy[i] - initialEnergy +1;\\n            initialEnergy = energy[i] +1;\\n            }\\n            if(initialExperience <= experience[i]){\\n                hours+= experience[i] - initialExperience+1;\\n                initialExperience = experience[i] + 1;\\n            }\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        }\\n        return hours;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hours = 0;\\n        for(int i = 0; i < energy.length;i++){\\n            if(initialEnergy <= energy[i]){\\n            hours += energy[i] - initialEnergy +1;\\n            initialEnergy = energy[i] +1;\\n            }\\n            if(initialExperience <= experience[i]){\\n                hours+= experience[i] - initialExperience+1;\\n                initialExperience = experience[i] + 1;\\n            }\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        }\\n        return hours;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3584107,
                "title": "easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n\\n        \\n        exdif = 0\\n        ensum = 0\\n        for i in range(len(energy)):\\n\\n            if initialExperience <= experience[i]:\\n                exdif = max(1,exdif,experience[i]+1-initialExperience)\\n\\n            initialExperience += experience[i]\\n            ensum += energy[i]\\n\\n\\n        return max(ensum-initialEnergy+1,0) + exdif\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n\\n        \\n        exdif = 0\\n        ensum = 0\\n        for i in range(len(energy)):\\n\\n            if initialExperience <= experience[i]:\\n                exdif = max(1,exdif,experience[i]+1-initialExperience)\\n\\n            initialExperience += experience[i]\\n            ensum += energy[i]\\n\\n\\n        return max(ensum-initialEnergy+1,0) + exdif\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3579258,
                "title": "jebas-raja-very-easy",
                "content": "# Intuition:karunya university:accenture\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) \\n    {\\n      \\n\\t \\t int hours=0;\\n\\t \\t \\n\\t \\t for (int i=0;i<energy.length;i++)\\n\\t \\t { \\n\\t \\t    //if energy is greater than or equal to initialEnergy    \\n\\t \\t    \\n\\t \\t    if (energy[i]>=initialEnergy)\\n\\t \\t    {\\n\\t \\t        hours+=(energy[i]-initialEnergy)+1;\\n\\t \\t        initialEnergy+=(energy[i]-initialEnergy)+1;\\n\\t \\t         \\n\\t \\t    }\\n\\t \\t    \\n\\t \\t    \\n\\t \\t    if (experience[i]>=initialExperience)\\n\\t \\t    {\\n\\t \\t        hours+=(experience[i]-initialExperience)+1;\\n\\t \\t        initialExperience+=(experience[i]-initialExperience)+1;\\n\\t \\t    }\\n\\t \\t    \\n\\t \\t   initialEnergy-=energy[i];\\n\\t \\t   initialExperience+=experience[i];\\n\\t \\t  \\n\\t \\t }\\n        \\n        //System.out.println(hours);    \\n        return hours;   \\n\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) \\n    {\\n      \\n\\t \\t int hours=0;\\n\\t \\t \\n\\t \\t for (int i=0;i<energy.length;i++)\\n\\t \\t { \\n\\t \\t    //if energy is greater than or equal to initialEnergy    \\n\\t \\t    \\n\\t \\t    if (energy[i]>=initialEnergy)\\n\\t \\t    {\\n\\t \\t        hours+=(energy[i]-initialEnergy)+1;\\n\\t \\t        initialEnergy+=(energy[i]-initialEnergy)+1;\\n\\t \\t         \\n\\t \\t    }\\n\\t \\t    \\n\\t \\t    \\n\\t \\t    if (experience[i]>=initialExperience)\\n\\t \\t    {\\n\\t \\t        hours+=(experience[i]-initialExperience)+1;\\n\\t \\t        initialExperience+=(experience[i]-initialExperience)+1;\\n\\t \\t    }\\n\\t \\t    \\n\\t \\t   initialEnergy-=energy[i];\\n\\t \\t   initialExperience+=experience[i];\\n\\t \\t  \\n\\t \\t }\\n        \\n        //System.out.println(hours);    \\n        return hours;   \\n\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3566782,
                "title": "trivial-c-beats-100",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        auto energyNeeded = 1, experienceNeeded = 0, currentExperience = initialExperience;\\n        for (auto i = 0; i < energy.size(); ++i) {\\n            energyNeeded += energy[i];\\n            auto experienceDiff = max(0, experience[i] - currentExperience + 1);\\n            experienceNeeded += experienceDiff;\\n            currentExperience += experienceDiff + experience[i];\\n        }\\n        return max(0, energyNeeded - initialEnergy) + experienceNeeded;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        auto energyNeeded = 1, experienceNeeded = 0, currentExperience = initialExperience;\\n        for (auto i = 0; i < energy.size(); ++i) {\\n            energyNeeded += energy[i];\\n            auto experienceDiff = max(0, experience[i] - currentExperience + 1);\\n            experienceNeeded += experienceDiff;\\n            currentExperience += experienceDiff + experience[i];\\n        }\\n        return max(0, energyNeeded - initialEnergy) + experienceNeeded;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3558479,
                "title": "beat-100-in-both-memory-and-runtime-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nAs energy is decreasing after every fight , i had calculate total energy req at the beginning by summing up the energy array. Total initial energy req will be greater then the sum by one(min condition).\\n\\nFor calculating the experience , i had taken exp to track it, which is initialised to initialexperience. Now after every fight if we encounter a experience lvl greater than or equal to exp then we need to calculate the req exprience at that lvl only, this is because after crossing that lvl our exp lvl may be eligible for the next fight simply because we are adding exp after every fight. \\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int energyCount = 0;\\n        int training = 0;\\n        for(int i=0 ; i<energy.length ; i++){\\n            energyCount += energy[i];\\n        }\\n        int reqenergy = energyCount + 1;\\n        if(reqenergy > initialEnergy){\\n            training = reqenergy-initialEnergy;\\n        }\\n        // counting experience\\n\\n        int exp = initialExperience;\\n        for(int i=0 ; i<experience.length ; i++){\\n            if(experience[i] >= exp){\\n                int reqexp = experience[i]-exp+1;\\n                training += reqexp;\\n                exp += experience[i]+(reqexp);\\n            }else{\\n                exp += experience[i];\\n            }\\n        }\\n        return training;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int energyCount = 0;\\n        int training = 0;\\n        for(int i=0 ; i<energy.length ; i++){\\n            energyCount += energy[i];\\n        }\\n        int reqenergy = energyCount + 1;\\n        if(reqenergy > initialEnergy){\\n            training = reqenergy-initialEnergy;\\n        }\\n        // counting experience\\n\\n        int exp = initialExperience;\\n        for(int i=0 ; i<experience.length ; i++){\\n            if(experience[i] >= exp){\\n                int reqexp = experience[i]-exp+1;\\n                training += reqexp;\\n                exp += experience[i]+(reqexp);\\n            }else{\\n                exp += experience[i];\\n            }\\n        }\\n        return training;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3527521,
                "title": "c-100-fast-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int sum=0,ans=0;\\n        for(int i=0;i<energy.size();i++){\\n            sum+=energy[i];\\n        }\\n        if(sum>=initialEnergy){\\n            ans=sum-initialEnergy+1;\\n        }\\n        for(int i=0;i<experience.size();i++){\\n            if(initialExperience<=experience[i]){\\n                ans+=experience[i]-initialExperience+1;\\n                initialExperience=experience[i]+1;\\n            }\\n            initialExperience+=experience[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int sum=0,ans=0;\\n        for(int i=0;i<energy.size();i++){\\n            sum+=energy[i];\\n        }\\n        if(sum>=initialEnergy){\\n            ans=sum-initialEnergy+1;\\n        }\\n        for(int i=0;i<experience.size();i++){\\n            if(initialExperience<=experience[i]){\\n                ans+=experience[i]-initialExperience+1;\\n                initialExperience=experience[i]+1;\\n            }\\n            initialExperience+=experience[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3520160,
                "title": "java-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hoursForEnergy = 0;\\n        int hoursForExperience = 0; \\n        for (int i = 0; i < energy.length; i++) {\\n            if (initialExperience <= experience[i]) {\\n                int diffOfXp = experience[i] - initialExperience + 1;\\n                hoursForExperience += diffOfXp;\\n                initialExperience += diffOfXp;\\n            }\\n            initialExperience += experience[i];\\n            hoursForEnergy += energy[i];\\n        }\\n        hoursForEnergy = hoursForEnergy - initialEnergy + 1;\\n        if (hoursForEnergy <= 0) {\\n            hoursForEnergy = 0;\\n        }\\n        return hoursForEnergy + hoursForExperience;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hoursForEnergy = 0;\\n        int hoursForExperience = 0; \\n        for (int i = 0; i < energy.length; i++) {\\n            if (initialExperience <= experience[i]) {\\n                int diffOfXp = experience[i] - initialExperience + 1;\\n                hoursForExperience += diffOfXp;\\n                initialExperience += diffOfXp;\\n            }\\n            initialExperience += experience[i];\\n            hoursForEnergy += energy[i];\\n        }\\n        hoursForEnergy = hoursForEnergy - initialEnergy + 1;\\n        if (hoursForEnergy <= 0) {\\n            hoursForEnergy = 0;\\n        }\\n        return hoursForEnergy + hoursForExperience;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507285,
                "title": "java-simple-solution-one-pass-math-greedy",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int energySum = 0;\\n        for (int currentEnergy : energy) {\\n            energySum += currentEnergy;\\n        }\\n        \\n        int experinceTrainingTime = 0;\\n        int experienceSum = initialExperience;\\n        for (int currentExperience : experience) {\\n            if (experienceSum <= currentExperience) {\\n                int difference = currentExperience - experienceSum + 1;\\n                experinceTrainingTime += difference;\\n                experienceSum += difference;\\n            }\\n            experienceSum += currentExperience;\\n        }\\n        \\n        int energyTrainingTime = 0;\\n        if (energySum >= initialEnergy) {\\n            energyTrainingTime = energySum - initialEnergy + 1;\\n        }\\n\\n        return energyTrainingTime + experinceTrainingTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\n\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int energySum = 0;\\n        for (int currentEnergy : energy) {\\n            energySum += currentEnergy;\\n        }\\n        \\n        int experinceTrainingTime = 0;\\n        int experienceSum = initialExperience;\\n        for (int currentExperience : experience) {\\n            if (experienceSum <= currentExperience) {\\n                int difference = currentExperience - experienceSum + 1;\\n                experinceTrainingTime += difference;\\n                experienceSum += difference;\\n            }\\n            experienceSum += currentExperience;\\n        }\\n        \\n        int energyTrainingTime = 0;\\n        if (energySum >= initialEnergy) {\\n            energyTrainingTime = energySum - initialEnergy + 1;\\n        }\\n\\n        return energyTrainingTime + experinceTrainingTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3490689,
                "title": "c-solution",
                "content": "# Code\\n```\\npublic class Solution {\\n    public int MinNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n\\n        int totalTraninigForEnergy = Math.Max(energy.Sum() - initialEnergy + 1, 0);\\n        int totalTraninigForExp = 0, expGained = initialExperience;\\n        foreach(int exp in experience) {\\n            if(expGained > exp) {\\n                expGained += exp;\\n            } else {\\n                int diff = exp - expGained + 1;\\n                expGained += exp + diff;\\n                totalTraninigForExp += diff;\\n            }\\n        }\\n\\n        return totalTraninigForEnergy + totalTraninigForExp;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n\\n        int totalTraninigForEnergy = Math.Max(energy.Sum() - initialEnergy + 1, 0);\\n        int totalTraninigForExp = 0, expGained = initialExperience;\\n        foreach(int exp in experience) {\\n            if(expGained > exp) {\\n                expGained += exp;\\n            } else {\\n                int diff = exp - expGained + 1;\\n                expGained += exp + diff;\\n                totalTraninigForExp += diff;\\n            }\\n        }\\n\\n        return totalTraninigForEnergy + totalTraninigForExp;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461880,
                "title": "c-solution-easy-to-understand",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int ans=0;\\n        int sumReqE=0;\\n        for(int i=0;i<energy.size();i++)\\n          sumReqE+=energy[i];\\n     \\n        \\n        sumReqE++;\\n        //energy\\n        if(initialEnergy<sumReqE)\\n          ans+=(sumReqE-initialEnergy);\\n          \\n         //Experience\\n         int i=0;\\n         int ex=initialExperience;//where to increment;\\n         int x=initialExperience;\\n         while(i<energy.size()){\\n            if(experience[i]<x){\\n               x=x+experience[i];\\n               i++;\\n             }else{\\n                i=0;\\n                ex++;\\n                x=ex;\\n            }\\n         }\\n         \\n         ans+=(ex-initialExperience);\\n         if(ans<0)\\n            return 0;\\n\\n           return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int ans=0;\\n        int sumReqE=0;\\n        for(int i=0;i<energy.size();i++)\\n          sumReqE+=energy[i];\\n     \\n        \\n        sumReqE++;\\n        //energy\\n        if(initialEnergy<sumReqE)\\n          ans+=(sumReqE-initialEnergy);\\n          \\n         //Experience\\n         int i=0;\\n         int ex=initialExperience;//where to increment;\\n         int x=initialExperience;\\n         while(i<energy.size()){\\n            if(experience[i]<x){\\n               x=x+experience[i];\\n               i++;\\n             }else{\\n                i=0;\\n                ex++;\\n                x=ex;\\n            }\\n         }\\n         \\n         ans+=(ex-initialExperience);\\n         if(ans<0)\\n            return 0;\\n\\n           return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3455145,
                "title": "java-solution-faster-than-100",
                "content": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        \\n        int reqEn = 0;\\n        for (int x: energy)\\n            reqEn += x;\\n        reqEn = Math.max(0, reqEn - initialEnergy + 1);\\n        \\n        int reqEx = 0, currEx = initialExperience;\\n        for (int x: experience)\\n        {\\n            if (currEx > x)\\n                currEx += x;\\n            else\\n            {\\n                reqEx += x - currEx + 1;\\n                currEx += (x - currEx + 1)   +   x;\\n            }\\n        }\\n        \\n        return reqEn + reqEx;\\n   \\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        \\n        int reqEn = 0;\\n        for (int x: energy)\\n            reqEn += x;\\n        reqEn = Math.max(0, reqEn - initialEnergy + 1);\\n        \\n        int reqEx = 0, currEx = initialExperience;\\n        for (int x: experience)\\n        {\\n            if (currEx > x)\\n                currEx += x;\\n            else\\n            {\\n                reqEx += x - currEx + 1;\\n                currEx += (x - currEx + 1)   +   x;\\n            }\\n        }\\n        \\n        return reqEn + reqEx;\\n   \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3434447,
                "title": "java-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:O(n) where n is the numbers of elements in array energy\\n\\n- Space complexity:O(n) where n is the numbers of elements in array energy\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        //int\\'s are positive values\\n        int hours = 0;\\n        for(int i = 0; i < energy.length; i++) {\\n            while(initialEnergy <= energy[i]){\\n                initialEnergy++;\\n                hours += 1;\\n            }\\n            while(initialExperience <= experience[i]) {\\n                initialExperience++;\\n                hours += 1;\\n            }\\n            initialExperience += experience[i];\\n            initialEnergy -= energy[i];\\n        }\\n        return hours;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        //int\\'s are positive values\\n        int hours = 0;\\n        for(int i = 0; i < energy.length; i++) {\\n            while(initialEnergy <= energy[i]){\\n                initialEnergy++;\\n                hours += 1;\\n            }\\n            while(initialExperience <= experience[i]) {\\n                initialExperience++;\\n                hours += 1;\\n            }\\n            initialExperience += experience[i];\\n            initialEnergy -= energy[i];\\n        }\\n        return hours;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3428836,
                "title": "competition-javascript-calculate-training-hours-52-ms",
                "content": "![image.png](https://assets.leetcode.com/users/images/515f583c-0b6f-46bd-89f4-25c579427b51_1681782884.5946465.png)\\n\\n```\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {  \\n    cur = initialExperience      \\n    a = b = 0        \\n    \\n    for (let i = 0; i < experience.length; i++) {  \\n        b = Math.max(experience[i] + 1 - cur, b)         \\n        cur += experience[i]          \\n        a += energy[i]            \\n    }\\n\\n    a = Math.max(0, a + 1 - initialEnergy)    \\n\\n    return a + b\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {  \\n    cur = initialExperience      \\n    a = b = 0        \\n    \\n    for (let i = 0; i < experience.length; i++) {  \\n        b = Math.max(experience[i] + 1 - cur, b)         \\n        cur += experience[i]          \\n        a += energy[i]            \\n    }\\n\\n    a = Math.max(0, a + 1 - initialEnergy)    \\n\\n    return a + b\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3408678,
                "title": "simple-c-solution-beats-100",
                "content": "\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nint minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize)\\n{\\n    int en=0,ex=initialExperience,i,h=0,min=0;\\n    for(i=0;i<energySize;i++)\\n    {\\n        en+=energy[i];\\n        if(ex<=experience[i])\\n        {\\n            h+=(experience[i]-ex+1);\\n            ex+=(experience[i]-ex+1);\\n        }\\n        ex+=experience[i];\\n    }\\n    en+=1;\\n    if(initialEnergy<en )\\n    {\\n        min=en-initialEnergy+h;\\n    }\\n    else\\n    {\\n        min+=h;\\n    }\\n    return min;\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nint minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize)\\n{\\n    int en=0,ex=initialExperience,i,h=0,min=0;\\n    for(i=0;i<energySize;i++)\\n    {\\n        en+=energy[i];\\n        if(ex<=experience[i])\\n        {\\n            h+=(experience[i]-ex+1);\\n            ex+=(experience[i]-ex+1);\\n        }\\n        ex+=experience[i];\\n    }\\n    en+=1;\\n    if(initialEnergy<en )\\n    {\\n        min=en-initialEnergy+h;\\n    }\\n    else\\n    {\\n        min+=h;\\n    }\\n    return min;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3406100,
                "title": "self-explanatory-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        train_hours = 0\\n        if initialEnergy <= sum(energy):\\n            train_hours = abs(initialEnergy - sum(energy)) + 1\\n        for exp in experience:\\n            if exp >= initialExperience:\\n                train_hours += exp - initialExperience + 1\\n                initialExperience += exp - initialExperience + 1 + exp\\n            else:\\n                initialExperience += exp\\n        return train_hours\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        train_hours = 0\\n        if initialEnergy <= sum(energy):\\n            train_hours = abs(initialEnergy - sum(energy)) + 1\\n        for exp in experience:\\n            if exp >= initialExperience:\\n                train_hours += exp - initialExperience + 1\\n                initialExperience += exp - initialExperience + 1 + exp\\n            else:\\n                initialExperience += exp\\n        return train_hours\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3385857,
                "title": "easy-for-unferstanding-solution",
                "content": "\\n\\n# Code\\n```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n\\n    let count = energy.reduce((sum, current) => sum + current, 0)-initialEnergy+1;\\n    if (count<0) {count=0;}\\n    \\n    \\n\\n    for (let i=0; i<experience.length; i++){ \\n    \\n        if (experience[i]<initialExperience) {initialExperience+=experience[i];}\\n    \\n    else {count+=experience[i]-initialExperience+1;initialExperience+=experience[i]-initialExperience+experience[i]+1; }\\n    if (count<0) {count=0;}\\n    }\\n    return count;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n\\n    let count = energy.reduce((sum, current) => sum + current, 0)-initialEnergy+1;\\n    if (count<0) {count=0;}\\n    \\n    \\n\\n    for (let i=0; i<experience.length; i++){ \\n    \\n        if (experience[i]<initialExperience) {initialExperience+=experience[i];}\\n    \\n    else {count+=experience[i]-initialExperience+1;initialExperience+=experience[i]-initialExperience+experience[i]+1; }\\n    if (count<0) {count=0;}\\n    }\\n    return count;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3384767,
                "title": "simple-solution-with-javascript",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let eng = initialEnergy\\n    let exp = initialExperience\\n    let rest = 0\\n\\n  \\tfor (let round = 0; round < energy.length; round++) {\\n        let enemyExp = experience[round]\\n        let enemyEng = energy[round]\\n      \\n        if (enemyExp >= exp && rest <= enemyExp - exp) {\\n      \\t    rest = (enemyExp - exp) + 1\\n        }\\n      \\n        exp += enemyExp\\n        eng -= enemyEng\\n    }\\n    \\n    if (eng <= 0) {\\n    \\trest += Math.abs(eng) + 1\\n    }\\n\\n    return rest\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let eng = initialEnergy\\n    let exp = initialExperience\\n    let rest = 0\\n\\n  \\tfor (let round = 0; round < energy.length; round++) {\\n        let enemyExp = experience[round]\\n        let enemyEng = energy[round]\\n      \\n        if (enemyExp >= exp && rest <= enemyExp - exp) {\\n      \\t    rest = (enemyExp - exp) + 1\\n        }\\n      \\n        exp += enemyExp\\n        eng -= enemyEng\\n    }\\n    \\n    if (eng <= 0) {\\n    \\trest += Math.abs(eng) + 1\\n    }\\n\\n    return rest\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3382290,
                "title": "easy-o-n-solution",
                "content": "# Code\\n```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    const hoursForEnergy = Math.max(energy.reduce((acc, e) => acc + e, 0) - initialEnergy + 1, 0);\\n\\n    let hoursForExpirience = 0;\\n    for (const e of experience) {\\n        if (initialExperience <= e) {\\n            const neededAdditionalExpirience = e - initialExperience + 1;\\n            hoursForExpirience += neededAdditionalExpirience;\\n            initialExperience += neededAdditionalExpirience;\\n        }\\n        initialExperience += e;\\n    }\\n\\n    return hoursForEnergy + hoursForExpirience;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    const hoursForEnergy = Math.max(energy.reduce((acc, e) => acc + e, 0) - initialEnergy + 1, 0);\\n\\n    let hoursForExpirience = 0;\\n    for (const e of experience) {\\n        if (initialExperience <= e) {\\n            const neededAdditionalExpirience = e - initialExperience + 1;\\n            hoursForExpirience += neededAdditionalExpirience;\\n            initialExperience += neededAdditionalExpirience;\\n        }\\n        initialExperience += e;\\n    }\\n\\n    return hoursForEnergy + hoursForExpirience;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3328955,
                "title": "javascript-solution",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nAt every step we check whether there is enough initial energy to defeat next competitor. If not, we should increase `hours` by `energy[i] + 1 - initialEnergy`, then `initialEnergy` becomes `energy[i] + 1`. We do the same with experience. Then we decrease amount of energy and decrease amount of experience before next step.\\n\\nTime complexity: O(n).\\n\\n# Code\\n```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let hours = 0;\\n\\n    for (let i = 0; i < energy.length; i++ ) {\\n        if (initialEnergy <= energy[i]) {\\n            hours += energy[i] + 1 - initialEnergy;\\n            initialEnergy = energy[i] + 1;\\n        }\\n\\n        if (initialExperience <= experience[i]) {\\n            hours += experience[i] + 1 - initialExperience;\\n            initialExperience = experience[i] + 1;\\n        }\\n\\n        initialEnergy -= energy[i];\\n        initialExperience += experience[i];\\n    }\\n\\n    return hours;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let hours = 0;\\n\\n    for (let i = 0; i < energy.length; i++ ) {\\n        if (initialEnergy <= energy[i]) {\\n            hours += energy[i] + 1 - initialEnergy;\\n            initialEnergy = energy[i] + 1;\\n        }\\n\\n        if (initialExperience <= experience[i]) {\\n            hours += experience[i] + 1 - initialExperience;\\n            initialExperience = experience[i] + 1;\\n        }\\n\\n        initialEnergy -= energy[i];\\n        initialExperience += experience[i];\\n    }\\n\\n    return hours;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3324170,
                "title": "python-one-line-for-energy-one-loop-for-experience",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nTraining hours for **Energy** can be calculated in just one line.\\nTraining hours for **Experience** are a bit more complicated, the most evident way is to traverse them one by one.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n- **Energy** : All we need is an additional amount of energy which is slightly greater than the sum of all opponents\\' energy. If our initial energy is significantly high, we don\\'t have to train at all.\\n\\n        energy_hr = sum(energy) - initialEnergy + 1\\n\\n-   **Experience** : For each iteration, there are two values that need updating. First, the amount of training hours needed (**ex_hr**) for every single opponent. Second is our current experience (**initialExperience**), since we receive an extra amount of experience whenever we win.\\n\\n        if initialExperience <= experience[i]:\\n            s = (experience[i] - initialExperience) + 1\\n            ex_hr += s\\n            initialExperience += s + experience[i]\\n        else: initialExperience+=experience[i]\\n\\n# Complexity\\n- Time complexity:  $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: list[int], experience: list[int]) -> int:\\n        energy_hr = sum(energy) - initialEnergy + 1\\n        ex_hr,s = 0,0\\n        if energy_hr < 0:\\n            energy_hr = 0\\n\\n        if len(energy) == 1:\\n            if experience[0] < initialExperience:  \\n                ex_hr = 0\\n            else: ex_hr = experience[0] - initialExperience + 1\\n            return energy_hr + ex_hr\\n\\n        for i in range(len(experience)):\\n            if initialExperience <= experience[i]:\\n                s = (experience[i] - initialExperience) + 1\\n                ex_hr += s\\n                initialExperience += s + experience[i]\\n            else: initialExperience+=experience[i]\\n\\n\\n        return energy_hr + ex_hr\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: list[int], experience: list[int]) -> int:\\n        energy_hr = sum(energy) - initialEnergy + 1\\n        ex_hr,s = 0,0\\n        if energy_hr < 0:\\n            energy_hr = 0\\n\\n        if len(energy) == 1:\\n            if experience[0] < initialExperience:  \\n                ex_hr = 0\\n            else: ex_hr = experience[0] - initialExperience + 1\\n            return energy_hr + ex_hr\\n\\n        for i in range(len(experience)):\\n            if initialExperience <= experience[i]:\\n                s = (experience[i] - initialExperience) + 1\\n                ex_hr += s\\n                initialExperience += s + experience[i]\\n            else: initialExperience+=experience[i]\\n\\n\\n        return energy_hr + ex_hr\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3306946,
                "title": "python-o-n-time-complexity",
                "content": "This is Larry\\'s solution. Credits to him.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nNote that it is said in the question that energy and experience should be strictly greater while defeating someone. Hence, 1 more level should be added to whenever our initial energy and experience level becomes equal to defeating someone. Reminder that energy decreases after defeating and experience increases.\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        n=len(energy)\\n\\n        needed=0\\n        current_energy=initialEnergy\\n        current_experience=initialExperience\\n\\n        for i in range(n):\\n            if current_energy<=energy[i]:\\n                delta=energy[i]-current_energy+1\\n                needed+=delta\\n                current_energy+=delta\\n            if current_experience<=experience[i]:\\n                delta=experience[i]-current_experience+1\\n                needed+=delta\\n                current_experience+=delta\\n            current_energy-=energy[i]\\n            current_experience+=experience[i]\\n        return needed\\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        n=len(energy)\\n\\n        needed=0\\n        current_energy=initialEnergy\\n        current_experience=initialExperience\\n\\n        for i in range(n):\\n            if current_energy<=energy[i]:\\n                delta=energy[i]-current_energy+1\\n                needed+=delta\\n                current_energy+=delta\\n            if current_experience<=experience[i]:\\n                delta=experience[i]-current_experience+1\\n                needed+=delta\\n                current_experience+=delta\\n            current_energy-=energy[i]\\n            current_experience+=experience[i]\\n        return needed\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3302435,
                "title": "bf-c-solution",
                "content": "```\\nint MAX(int a, int b){ return a>b?a:b; }\\nint minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize){\\n    int energySum = 0, minExp = 0, ans = 0;\\n    for(int i = 0; i < energySize; i++)\\n        energySum += energy[i];\\n    \\n    for(int i = 0; i < experienceSize; i++){\\n        if(initialExperience <= experience[i])\\n            minExp = MAX(minExp, experience[i] - initialExperience + 1);\\n        \\n        initialExperience += experience[i];\\n    }\\n\\n    ans += (initialEnergy > energySum)? 0 : energySum - initialEnergy + 1;\\n    ans += minExp;\\n    return ans;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint MAX(int a, int b){ return a>b?a:b; }\\nint minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize){\\n    int energySum = 0, minExp = 0, ans = 0;\\n    for(int i = 0; i < energySize; i++)\\n        energySum += energy[i];\\n    \\n    for(int i = 0; i < experienceSize; i++){\\n        if(initialExperience <= experience[i])\\n            minExp = MAX(minExp, experience[i] - initialExperience + 1);\\n        \\n        initialExperience += experience[i];\\n    }\\n\\n    ans += (initialEnergy > energySum)? 0 : energySum - initialEnergy + 1;\\n    ans += minExp;\\n    return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3297997,
                "title": "java-100-faster-simple-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEnergy and experience are idential except that we add vs subtract so we can make a method for it with an add/subtract boolean.\\n\\nWe need to capture the difference when there is a deficit and add 1 to get our total hours to train\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nMaintain the current value for either energy or experience while going through the arrays. When we have a deficit, we find the difference, and add 1 since it has to be entirely greater than the opponent. We add that difference to our total hours to train and continue.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nThis requires linear time $$O(n)$$\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nThis requires constant space $$O(1)$$\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        return getTrainingHours(initialEnergy, energy, false) + getTrainingHours(initialExperience, experience, true);\\n    }\\n\\n    private int getTrainingHours(int initial, int[] enemies, boolean useAddition) {\\n        int current = initial;\\n        int trainingHours = 0;\\n        for (int i = 0; i < enemies.length; i++) {\\n            int enemy = enemies[i];\\n            if (current <= enemy) {\\n                int diff = enemy - current + 1;\\n                trainingHours += diff;\\n                current += diff;\\n            }\\n\\n            if (useAddition)\\n                current += enemy;\\n            else\\n                current -= enemy;\\n        }\\n        return trainingHours;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        return getTrainingHours(initialEnergy, energy, false) + getTrainingHours(initialExperience, experience, true);\\n    }\\n\\n    private int getTrainingHours(int initial, int[] enemies, boolean useAddition) {\\n        int current = initial;\\n        int trainingHours = 0;\\n        for (int i = 0; i < enemies.length; i++) {\\n            int enemy = enemies[i];\\n            if (current <= enemy) {\\n                int diff = enemy - current + 1;\\n                trainingHours += diff;\\n                current += diff;\\n            }\\n\\n            if (useAddition)\\n                current += enemy;\\n            else\\n                current -= enemy;\\n        }\\n        return trainingHours;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3293153,
                "title": "javascript-logic",
                "content": "# Code\\n```\\n// O(n)\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let le = 0;\\n    let lex = 0;\\n    for (let i = 0; i < energy.length; i++) {\\n        if (initialEnergy <= energy[i]) {\\n            let val = Math.abs(initialEnergy - energy[i]) + 1;\\n            le += val;\\n            initialEnergy += val;\\n        }\\n        initialEnergy -= energy[i];\\n        if (initialExperience <= experience[i]) {\\n            let val = Math.abs(initialExperience - experience[i]) + 1;\\n            lex += val;\\n            initialExperience += val;\\n        }\\n        initialExperience += experience[i];\\n    }\\n    return le + lex;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n// O(n)\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let le = 0;\\n    let lex = 0;\\n    for (let i = 0; i < energy.length; i++) {\\n        if (initialEnergy <= energy[i]) {\\n            let val = Math.abs(initialEnergy - energy[i]) + 1;\\n            le += val;\\n            initialEnergy += val;\\n        }\\n        initialEnergy -= energy[i];\\n        if (initialExperience <= experience[i]) {\\n            let val = Math.abs(initialExperience - experience[i]) + 1;\\n            lex += val;\\n            initialExperience += val;\\n        }\\n        initialExperience += experience[i];\\n    }\\n    return le + lex;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3290264,
                "title": "c-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\u91DD\\u5C0D\\u6BCF\\u4E00\\u56DE\\u5408\\u5224\\u65B7Energy\\u3001Experience\\n1. initialEnergy <= energy[i] \\u2192 \\u8981\\u8A13\\u7DF4energy[i]-initialEnergy+1 \\u5C0F\\u6642\\n2. initialExperience<=experience[i] \\u2192 experience[i]-initialExperience+1 \\u5C0F\\u6642\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:97.78%(71ms)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:82.22%(38.8MB)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hour = 0;\\n        int i = 0;\\n        while(i < energy.Length)\\n        {\\n            if(initialEnergy> energy[i] && initialExperience>experience[i])\\n            {\\n                initialEnergy-=energy[i];\\n                initialExperience+=experience[i];\\n                i++;\\n            }else\\n            {\\n                if(initialEnergy <= energy[i])\\n                {\\n                    hour+=energy[i]-initialEnergy+1;\\n                    initialEnergy = energy[i] +1;                    \\n                }\\n                if(initialExperience<=experience[i])\\n                {\\n                    hour+=experience[i]-initialExperience+1;\\n                    initialExperience = experience[i]+1;                    \\n                }\\n\\n            }\\n        }\\n        return hour;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hour = 0;\\n        int i = 0;\\n        while(i < energy.Length)\\n        {\\n            if(initialEnergy> energy[i] && initialExperience>experience[i])\\n            {\\n                initialEnergy-=energy[i];\\n                initialExperience+=experience[i];\\n                i++;\\n            }else\\n            {\\n                if(initialEnergy <= energy[i])\\n                {\\n                    hour+=energy[i]-initialEnergy+1;\\n                    initialEnergy = energy[i] +1;                    \\n                }\\n                if(initialExperience<=experience[i])\\n                {\\n                    hour+=experience[i]-initialExperience+1;\\n                    initialExperience = experience[i]+1;                    \\n                }\\n\\n            }\\n        }\\n        return hour;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3290124,
                "title": "lc-2383-e-python3-a-plain-solution",
                "content": "`min_energy_hours` and `min_exp_hours` are calculated as requested independently.\\n\\n```python3 []\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        min_energy_hours = max(0, sum(energy) + 1 - initialEnergy)\\n        min_exp_hours = 0\\n        exp = initialExperience\\n        for v in experience:\\n            if (diff := v + 1 - exp) > min_exp_hours:\\n                min_exp_hours = diff\\n            exp += v\\n        \\n        return min_energy_hours + min_exp_hours\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python3 []\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        min_energy_hours = max(0, sum(energy) + 1 - initialEnergy)\\n        min_exp_hours = 0\\n        exp = initialExperience\\n        for v in experience:\\n            if (diff := v + 1 - exp) > min_exp_hours:\\n                min_exp_hours = diff\\n            exp += v\\n        \\n        return min_energy_hours + min_exp_hours\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277215,
                "title": "o-n-c-code",
                "content": "# Complexity\\n- Time complexity: **O(N)**\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: **O(1)**\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int total = 0, n = experience.size();\\n        int reqEnergy = 0, sum = accumulate(energy.begin(), energy.end(), 0);\\n        int reqXP = 0;\\n        if(sum >= initialEnergy) reqEnergy = sum - initialEnergy + 1;\\n        total += reqEnergy;\\n        cout << \"energy = \" << reqEnergy << endl;\\n        for(int i = 0; i < n; i++){\\n            if(initialExperience > experience[i]) initialExperience += experience[i];\\n            else{\\n                total += experience[i] - initialExperience + 1;\\n                initialExperience += (experience[i] - initialExperience + 1) + experience[i];\\n            }\\n        }\\n        cout << \"xp = \" << total - reqEnergy;\\n        return total;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int total = 0, n = experience.size();\\n        int reqEnergy = 0, sum = accumulate(energy.begin(), energy.end(), 0);\\n        int reqXP = 0;\\n        if(sum >= initialEnergy) reqEnergy = sum - initialEnergy + 1;\\n        total += reqEnergy;\\n        cout << \"energy = \" << reqEnergy << endl;\\n        for(int i = 0; i < n; i++){\\n            if(initialExperience > experience[i]) initialExperience += experience[i];\\n            else{\\n                total += experience[i] - initialExperience + 1;\\n                initialExperience += (experience[i] - initialExperience + 1) + experience[i];\\n            }\\n        }\\n        cout << \"xp = \" << total - reqEnergy;\\n        return total;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3226266,
                "title": "js-javascript-simple-solution-o-n",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(en, ex, energy, experience) {\\n    let hours = 0\\n    for (let i = 0; i < energy.length; i++){\\n        if (en <= energy[i]){\\n            hours += energy[i] - en + 1\\n            en = 1\\n        } else {\\n            en -= energy[i]\\n        }\\n        if (ex <= experience[i]){\\n            hours += experience[i] - ex + 1\\n            ex = experience[i] + 1\\n        }\\n        ex += experience[i]\\n\\n    }\\n    return hours\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(en, ex, energy, experience) {\\n    let hours = 0\\n    for (let i = 0; i < energy.length; i++){\\n        if (en <= energy[i]){\\n            hours += energy[i] - en + 1\\n            en = 1\\n        } else {\\n            en -= energy[i]\\n        }\\n        if (ex <= experience[i]){\\n            hours += experience[i] - ex + 1\\n            ex = experience[i] + 1\\n        }\\n        ex += experience[i]\\n\\n    }\\n    return hours\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3221942,
                "title": "python-straightforward-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\nIterate through the energy and experience arrays.\\nIf your `initialEnergy` is not enough, add the difference plus one to the result and your `initialEnergy` becomes 1.\\nIf your `initialExperience` is not enough, add the difference plus one to the result and your `initialExperience` becomes `2*experience+1`.\\n\\n\\n# Complexity\\n- Time complexity: `O(n)`\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: `O(1)`\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n\\n        res = [0, 0]\\n        for en, ex in zip(energy, experience):\\n            if initialEnergy <= en:\\n                res[0] += (en - initialEnergy) + 1\\n                initialEnergy = 1\\n            else:\\n                initialEnergy -= en\\n\\n            if initialExperience <= ex:\\n                res[1] += (ex - initialExperience) + 1\\n                initialExperience = ex * 2 + 1\\n            else:\\n                initialExperience += ex\\n        return sum(res)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n\\n        res = [0, 0]\\n        for en, ex in zip(energy, experience):\\n            if initialEnergy <= en:\\n                res[0] += (en - initialEnergy) + 1\\n                initialEnergy = 1\\n            else:\\n                initialEnergy -= en\\n\\n            if initialExperience <= ex:\\n                res[1] += (ex - initialExperience) + 1\\n                initialExperience = ex * 2 + 1\\n            else:\\n                initialExperience += ex\\n        return sum(res)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3184690,
                "title": "short-kotlin-solution",
                "content": "```\\nclass Solution {\\n    fun minNumberOfHours(initialEnergy: Int, initialExperience: Int, energy: IntArray, experience: IntArray): Int {\\n        val n = energy.size\\n        var needEng = 0\\n        var needExp = 0\\n        var currExp = initialExperience\\n        for (i in 0..n-1) {\\n            needEng += energy[i]\\n            needExp += maxOf(experience[i] - currExp - needExp + 1, 0)\\n            currExp += experience[i]\\n        }\\n        return maxOf(needEng - initialEnergy + 1, 0) + needExp\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun minNumberOfHours(initialEnergy: Int, initialExperience: Int, energy: IntArray, experience: IntArray): Int {\\n        val n = energy.size\\n        var needEng = 0\\n        var needExp = 0\\n        var currExp = initialExperience\\n        for (i in 0..n-1) {\\n            needEng += energy[i]\\n            needExp += maxOf(experience[i] - currExp - needExp + 1, 0)\\n            currExp += experience[i]\\n        }\\n        return maxOf(needEng - initialEnergy + 1, 0) + needExp\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3153522,
                "title": "o-n-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nIt\\'s quite easy to see that the total energy required is one plus the sum of the energy array, and to find the total experience, we need only to find the maximum of the experience minus the accumulated experience beforehand and add one.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nA simple one time loop is sufficient to find both of our required values.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n$$O(n)$$\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n$$O(1)$$\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        expn = initialExperience\\n        total = 0\\n        for exp in experience:\\n            if exp + 1 - total > expn:\\n                expn = exp + 1 - total\\n            total += exp\\n        energyn = sum(energy) + 1 - initialEnergy if sum(energy) + 1 > initialEnergy else 0\\n        return energyn + expn - initialExperience\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        expn = initialExperience\\n        total = 0\\n        for exp in experience:\\n            if exp + 1 - total > expn:\\n                expn = exp + 1 - total\\n            total += exp\\n        energyn = sum(energy) + 1 - initialEnergy if sum(energy) + 1 > initialEnergy else 0\\n        return energyn + expn - initialExperience\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3141253,
                "title": "javascript-solution-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let hours = 0;\\n    const n = energy.length;\\n\\n    for (let i = 0; i<n; i++) {\\n        if (initialEnergy > energy[i] && initialExperience > experience[i]) {\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        } else {\\n            if (initialEnergy <= energy[i] && initialExperience <= experience[i]) {\\n                hours += (energy[i] - initialEnergy)+1;\\n                hours += (experience[i] - initialExperience)+1;\\n                initialEnergy = 1\\n                initialExperience = experience[i] +1+experience[i];\\n            } else if (initialEnergy <= energy[i]) {\\n                hours += (energy[i] - initialEnergy)+1;\\n                initialEnergy = 1;\\n                initialExperience += experience[i];\\n            } else if (initialExperience <= experience[i]) {\\n                hours += (experience[i] - initialExperience)+1;\\n                initialExperience = experience[i] +1+experience[i];\\n                initialEnergy -= energy[i]\\n            }\\n        }\\n    }\\n    return hours;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(initialEnergy, initialExperience, energy, experience) {\\n    let hours = 0;\\n    const n = energy.length;\\n\\n    for (let i = 0; i<n; i++) {\\n        if (initialEnergy > energy[i] && initialExperience > experience[i]) {\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        } else {\\n            if (initialEnergy <= energy[i] && initialExperience <= experience[i]) {\\n                hours += (energy[i] - initialEnergy)+1;\\n                hours += (experience[i] - initialExperience)+1;\\n                initialEnergy = 1\\n                initialExperience = experience[i] +1+experience[i];\\n            } else if (initialEnergy <= energy[i]) {\\n                hours += (energy[i] - initialEnergy)+1;\\n                initialEnergy = 1;\\n                initialExperience += experience[i];\\n            } else if (initialExperience <= experience[i]) {\\n                hours += (experience[i] - initialExperience)+1;\\n                initialExperience = experience[i] +1+experience[i];\\n                initialEnergy -= energy[i]\\n            }\\n        }\\n    }\\n    return hours;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3135419,
                "title": "best-simple-solution",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int sum=0,a=0,cnt=0;\\n        for(int i : energy) sum+=i;\\n        if(sum>= initialEnergy) a = sum-initialEnergy+1;\\n        for(int i=0;i<size(experience);i++)\\n        {\\n            if(experience[i]>=initialExperience) {\\n                int temp = experience[i]-initialExperience+1;\\n                cnt+=temp;\\n                initialExperience+=temp+experience[i];\\n            }\\n            else initialExperience+=experience[i];\\n        }\\n        return a+cnt;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int sum=0,a=0,cnt=0;\\n        for(int i : energy) sum+=i;\\n        if(sum>= initialEnergy) a = sum-initialEnergy+1;\\n        for(int i=0;i<size(experience);i++)\\n        {\\n            if(experience[i]>=initialExperience) {\\n                int temp = experience[i]-initialExperience+1;\\n                cnt+=temp;\\n                initialExperience+=temp+experience[i];\\n            }\\n            else initialExperience+=experience[i];\\n        }\\n        return a+cnt;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3130846,
                "title": "beats-99-79",
                "content": "# Upvote it\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        if sum(energy) >= initialEnergy: c = sum(energy) - initialEnergy + 1\\n        else: c = 0\\n        for e in experience:\\n            if initialExperience > e: initialExperience += e\\n            else:\\n                diff = e - initialExperience + 1\\n                c += diff\\n                initialExperience += diff + e\\n        return c\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        if sum(energy) >= initialEnergy: c = sum(energy) - initialEnergy + 1\\n        else: c = 0\\n        for e in experience:\\n            if initialExperience > e: initialExperience += e\\n            else:\\n                diff = e - initialExperience + 1\\n                c += diff\\n                initialExperience += diff + e\\n        return c\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3125228,
                "title": "java-greedy-easy-to-understand-beats-100",
                "content": "# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int res=0;\\n        int sum=0;\\n        for(int x:energy){\\n            sum+=x;\\n        }\\n        if(initialEnergy<=sum){\\n            res+=sum+1-initialEnergy;\\n        }\\n        for(int y:experience){\\n            if(initialExperience>y){\\n                initialExperience+=y;\\n            }\\n            else{\\n                res+=y+1-initialExperience;\\n                initialExperience+=y+(y+1)-initialExperience;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int res=0;\\n        int sum=0;\\n        for(int x:energy){\\n            sum+=x;\\n        }\\n        if(initialEnergy<=sum){\\n            res+=sum+1-initialEnergy;\\n        }\\n        for(int y:experience){\\n            if(initialExperience>y){\\n                initialExperience+=y;\\n            }\\n            else{\\n                res+=y+1-initialExperience;\\n                initialExperience+=y+(y+1)-initialExperience;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3115485,
                "title": "find-out-train-of-en-and-ex",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int en, int ex, int[] e1, int[] e2) {\\n        int a = 0, b = 0;  //a is train of en and b is train of ex\\n        for(int n: e1)\\n        {\\n            if(en <= n) \\n            {\\n                a += n - en + 1;\\n                en = 1;\\n            }\\n            else\\n                 en -= n;\\n        }\\n        for(int n: e2)\\n        {\\n            if(ex <= n) \\n            {\\n                b += n - ex + 1;\\n                ex = n + 1;\\n            }\\n            ex += n;\\n        }\\n        return a+b;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int en, int ex, int[] e1, int[] e2) {\\n        int a = 0, b = 0;  //a is train of en and b is train of ex\\n        for(int n: e1)\\n        {\\n            if(en <= n) \\n            {\\n                a += n - en + 1;\\n                en = 1;\\n            }\\n            else\\n                 en -= n;\\n        }\\n        for(int n: e2)\\n        {\\n            if(ex <= n) \\n            {\\n                b += n - ex + 1;\\n                ex = n + 1;\\n            }\\n            ex += n;\\n        }\\n        return a+b;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3104607,
                "title": "accepted-swift",
                "content": "```\\nclass Solution {\\n    func minNumberOfHours(_ initialEnergy: Int, _ initialExperience: Int, _ energy: [Int], _ experience: [Int]) -> Int {\\n        \\n        var ee = 0\\n        var ce = initialEnergy\\n        \\n        for e in energy {\\n            while e >= ce {\\n                ce += 1\\n                ee += 1\\n            }\\n            ce -= e\\n        }\\n        \\n        var ex = 0\\n        var cx = initialExperience\\n        \\n        for e in experience {\\n            while e >= cx {\\n                ex += 1\\n                cx += 1\\n            }\\n            cx += e\\n        }\\n        \\n        return ee + ex\\n    }\\n}\\n```",
                "solutionTags": [
                    "Swift"
                ],
                "code": "```\\nclass Solution {\\n    func minNumberOfHours(_ initialEnergy: Int, _ initialExperience: Int, _ energy: [Int], _ experience: [Int]) -> Int {\\n        \\n        var ee = 0\\n        var ce = initialEnergy\\n        \\n        for e in energy {\\n            while e >= ce {\\n                ce += 1\\n                ee += 1\\n            }\\n            ce -= e\\n        }\\n        \\n        var ex = 0\\n        var cx = initialExperience\\n        \\n        for e in experience {\\n            while e >= cx {\\n                ex += 1\\n                cx += 1\\n            }\\n            cx += e\\n        }\\n        \\n        return ee + ex\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3094738,
                "title": "python-attempt-that-works-tried-to-keep-it-simple",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTried to keep it as simple as possible. By far not the best solution but I think its not too difficult to follow.\\n\\n\\n# Code\\n```\\nclass Solution(object):\\n    def minNumberOfHours(self, initialEnergy, initialExperience, energy, experience):\\n        \"\"\"\\n        :type initialEnergy: int\\n        :type initialExperience: int\\n        :type energy: List[int]\\n        :type experience: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Number of hours needed for Training\\n        hrs_train = 0\\n        # Total Opposition Energy\\n        opp_energy = 0\\n\\n        # Calculating Total Opposition Energy\\n        for i in energy:\\n            opp_energy += i\\n\\n        #print(\"Opponent Energy\",opp_energy)\\n\\n        # Adds hours to training whether initial Energy is 1 or greater\\n        if opp_energy - initialEnergy >= 0:\\n            if initialEnergy == 1:\\n                hrs_train = opp_energy \\n            else:    \\n                hrs_train = (opp_energy - initialEnergy) + 1\\n\\n        #print(\"Hours Energy Training Needed\", hrs_train)\\n        \\n        # For Total Experience Gained\\n        exp = initialExperience\\n        # Hours Difference for needed Experience\\n        diff = 0 \\n\\n        # Loop through experience and calculating number of necessarry training hours\\n        for i in range(len(experience)):\\n            # Finding difference between each experience value and dealing with it accordingly\\n            if exp < experience[i]:\\n                diff = experience[i] - exp + 1\\n                hrs_train = hrs_train + diff\\n\\n            # If experience is the same only an extra hour/ experience point is needed\\n            if exp == experience[i]:\\n                diff = 1\\n                hrs_train = hrs_train + 1\\n\\n            # Experience is calculated each turn to update new experience gained and appropriate difference if any\\n            exp = exp + experience[i] + diff\\n            diff = 0\\n\\n        return hrs_train\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    def minNumberOfHours(self, initialEnergy, initialExperience, energy, experience):\\n        \"\"\"\\n        :type initialEnergy: int\\n        :type initialExperience: int\\n        :type energy: List[int]\\n        :type experience: List[int]\\n        :rtype: int\\n        \"\"\"\\n        # Number of hours needed for Training\\n        hrs_train = 0\\n        # Total Opposition Energy\\n        opp_energy = 0\\n\\n        # Calculating Total Opposition Energy\\n        for i in energy:\\n            opp_energy += i\\n\\n        #print(\"Opponent Energy\",opp_energy)\\n\\n        # Adds hours to training whether initial Energy is 1 or greater\\n        if opp_energy - initialEnergy >= 0:\\n            if initialEnergy == 1:\\n                hrs_train = opp_energy \\n            else:    \\n                hrs_train = (opp_energy - initialEnergy) + 1\\n\\n        #print(\"Hours Energy Training Needed\", hrs_train)\\n        \\n        # For Total Experience Gained\\n        exp = initialExperience\\n        # Hours Difference for needed Experience\\n        diff = 0 \\n\\n        # Loop through experience and calculating number of necessarry training hours\\n        for i in range(len(experience)):\\n            # Finding difference between each experience value and dealing with it accordingly\\n            if exp < experience[i]:\\n                diff = experience[i] - exp + 1\\n                hrs_train = hrs_train + diff\\n\\n            # If experience is the same only an extra hour/ experience point is needed\\n            if exp == experience[i]:\\n                diff = 1\\n                hrs_train = hrs_train + 1\\n\\n            # Experience is calculated each turn to update new experience gained and appropriate difference if any\\n            exp = exp + experience[i] + diff\\n            diff = 0\\n\\n        return hrs_train\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3092784,
                "title": "simple-cpp-datta-bayo",
                "content": "Easy condition Traversal.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int hours =0;\\n        for(int i=0;i<energy.size();i++)\\n        {\\n            if(energy[i]>=initialEnergy)\\n            {\\n                hours += energy[i]-initialEnergy+1;\\n                initialEnergy+=energy[i]-initialEnergy+1;\\n\\n            }\\n            if(experience[i]>=initialExperience)\\n            {\\n                hours+=experience[i]-initialExperience+1;\\n                initialExperience+=experience[i]-initialExperience+1;\\n            }\\n            initialEnergy-=energy[i];\\n            initialExperience+=experience[i];\\n        }\\n        return hours;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int hours =0;\\n        for(int i=0;i<energy.size();i++)\\n        {\\n            if(energy[i]>=initialEnergy)\\n            {\\n                hours += energy[i]-initialEnergy+1;\\n                initialEnergy+=energy[i]-initialEnergy+1;\\n\\n            }\\n            if(experience[i]>=initialExperience)\\n            {\\n                hours+=experience[i]-initialExperience+1;\\n                initialExperience+=experience[i]-initialExperience+1;\\n            }\\n            initialEnergy-=energy[i];\\n            initialExperience+=experience[i];\\n        }\\n        return hours;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3088002,
                "title": "java-0ms-clear-explications",
                "content": "# Approach\\n1. Traverse both arrays with an index and\\n    - calculate the totalEnergy by adding energy[i]\\n    - determine if this round you need Experience or not. neededRoundExp.Start with gainedExperience = initialExperience\\n    If current exp lvl >= gainedEnergy, you need the diff + 1. neededRoundExp = diff + 1, else you need  0.\\n    Add this neededRoundExp to a global var.(totalNeededExp)\\n    Also increment your gained experience with exp[i] + nededRoundExperience.\\n2. Return the sum between totalNeededExp and (if neededEnergy >= initial, add the diff+1, else 0)\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:$$O(11)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int neededRoundExperience = 0, neededTotalExperience = 0, gainedExperience = initialExperience;\\n        int neededEnergy = 0;\\n        for (int i = 0; i < energy.length; i++) {\\n            neededRoundExperience = experience[i] >= gainedExperience ? (experience[i]  - gainedExperience) + 1 : 0;\\n            gainedExperience += experience[i] + neededRoundExperience;\\n            neededTotalExperience += neededRoundExperience;\\n            neededEnergy += energy[i];\\n        }\\n        return neededTotalExperience + (neededEnergy >= initialEnergy ? ++neededEnergy - initialEnergy : 0);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int neededRoundExperience = 0, neededTotalExperience = 0, gainedExperience = initialExperience;\\n        int neededEnergy = 0;\\n        for (int i = 0; i < energy.length; i++) {\\n            neededRoundExperience = experience[i] >= gainedExperience ? (experience[i]  - gainedExperience) + 1 : 0;\\n            gainedExperience += experience[i] + neededRoundExperience;\\n            neededTotalExperience += neededRoundExperience;\\n            neededEnergy += energy[i];\\n        }\\n        return neededTotalExperience + (neededEnergy >= initialEnergy ? ++neededEnergy - initialEnergy : 0);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3075692,
                "title": "c",
                "content": "```\\nint minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize){\\n    int ans = 0 ;\\n    // analyze energy\\n    int e = 0 ;\\n    for(int i = 0; i < energySize ; i++){\\n        e += energy[i] ;\\n    }\\n    e++ ;\\n    ans += ( (initialEnergy < e )) ? e - initialEnergy : 0 ;\\n    \\n    //analyze experience\\n    int cur = initialExperience ;\\n    for(int i = 0; i < experienceSize; i++){\\n        if( cur > experience[i] ){\\n            cur += experience[i] ;\\n        }\\n        else{\\n            ans += (experience[i] - cur + 1) ;\\n            cur = experience[i] * 2 + 1 ;\\n        }\\n    }\\n    return ans ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nint minNumberOfHours(int initialEnergy, int initialExperience, int* energy, int energySize, int* experience, int experienceSize){\\n    int ans = 0 ;\\n    // analyze energy\\n    int e = 0 ;\\n    for(int i = 0; i < energySize ; i++){\\n        e += energy[i] ;\\n    }\\n    e++ ;\\n    ans += ( (initialEnergy < e )) ? e - initialEnergy : 0 ;\\n    \\n    //analyze experience\\n    int cur = initialExperience ;\\n    for(int i = 0; i < experienceSize; i++){\\n        if( cur > experience[i] ){\\n            cur += experience[i] ;\\n        }\\n        else{\\n            ans += (experience[i] - cur + 1) ;\\n            cur = experience[i] * 2 + 1 ;\\n        }\\n    }\\n    return ans ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3058582,
                "title": "explanation-in-same-story-form",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    public int MinNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hours=0;//Cause we try to defeat with initalEnergy and initialExperience.\\n        for(int i=0;i<energy.Length;i++)//iterate through every element of opponents energy and experience\\n        {\\n            int extraEnergy = Math.Max(0,energy[i]-initialEnergy+1);//if energy required for current oppponent then required energy is added else 0 is added.\\n            initialEnergy+=extraEnergy;\\n\\n            int extraexp = Math.Max(0,experience[i]-initialExperience+1);//if experience required for current oppponent then required experience is added else 0 is added.\\n            initialExperience+=extraexp;\\n\\n            hours+=extraEnergy+extraexp;//hours of training increased here\\n            initialEnergy-=energy[i];//energy after defeating opponent is reduced.\\n            initialExperience+=experience[i];//Experinece of current opponnet is added cause he is defeated.\\n        }\\n        return hours;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public int MinNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n        int hours=0;//Cause we try to defeat with initalEnergy and initialExperience.\\n        for(int i=0;i<energy.Length;i++)//iterate through every element of opponents energy and experience\\n        {\\n            int extraEnergy = Math.Max(0,energy[i]-initialEnergy+1);//if energy required for current oppponent then required energy is added else 0 is added.\\n            initialEnergy+=extraEnergy;\\n\\n            int extraexp = Math.Max(0,experience[i]-initialExperience+1);//if experience required for current oppponent then required experience is added else 0 is added.\\n            initialExperience+=extraexp;\\n\\n            hours+=extraEnergy+extraexp;//hours of training increased here\\n            initialEnergy-=energy[i];//energy after defeating opponent is reduced.\\n            initialExperience+=experience[i];//Experinece of current opponnet is added cause he is defeated.\\n        }\\n        return hours;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026666,
                "title": "python-solution",
                "content": "\\n\\n\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        \\n        hours=0\\n        if sum(energy)>=initialEnergy:\\n            hours = sum(energy)-initialEnergy+1\\n        exph = 0\\n        for exp in experience:\\n            exph = max(1 + exp - initialExperience, exph)\\n            initialExperience += exp\\n        \\n        print(hours, exph)\\n        return hours+exph\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        \\n        hours=0\\n        if sum(energy)>=initialEnergy:\\n            hours = sum(energy)-initialEnergy+1\\n        exph = 0\\n        for exp in experience:\\n            exph = max(1 + exp - initialExperience, exph)\\n            initialExperience += exp\\n        \\n        print(hours, exph)\\n        return hours+exph\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020863,
                "title": "python3-good-enough",
                "content": "``` Python3 []\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        energy = max(0, sum(energy) - initialEnergy + 1)\\n\\n        exp = max_exp = 0\\n        for x in experience:\\n            max_exp = max(max_exp, x - exp)\\n            exp += x\\n        experience = max(0, max_exp - initialExperience + 1)\\n\\n        return energy + experience\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "``` Python3 []\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        energy = max(0, sum(energy) - initialEnergy + 1)\\n\\n        exp = max_exp = 0\\n        for x in experience:\\n            max_exp = max(max_exp, x - exp)\\n            exp += x\\n        experience = max(0, max_exp - initialExperience + 1)\\n\\n        return energy + experience\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3020794,
                "title": "simple-js-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(inen, inex, en, ex) {\\n    sol=0;\\n    for(i in en){\\n       if(inen>en[i]) inen=inen-en[i];\\n       else{\\n           sol=sol+(en[i]-inen+1) \\n           inen=1;\\n       }\\n\\n       if(inex>ex[i]) inex=inex+ex[i];\\n       else{\\n           sol=sol+(ex[i]-inex+1);\\n           inex=2*ex[i]+1\\n       }\\n    }\\n    return sol;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {number} initialEnergy\\n * @param {number} initialExperience\\n * @param {number[]} energy\\n * @param {number[]} experience\\n * @return {number}\\n */\\nvar minNumberOfHours = function(inen, inex, en, ex) {\\n    sol=0;\\n    for(i in en){\\n       if(inen>en[i]) inen=inen-en[i];\\n       else{\\n           sol=sol+(en[i]-inen+1) \\n           inen=1;\\n       }\\n\\n       if(inex>ex[i]) inex=inex+ex[i];\\n       else{\\n           sol=sol+(ex[i]-inex+1);\\n           inex=2*ex[i]+1\\n       }\\n    }\\n    return sol;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2989476,
                "title": "100",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n\\n       int trainHoursRequired = 0;\\n\\n        for (int i = 0; i < energy.length; ++i) {\\n            int extraEnergy = Math.max(0, energy[i] - initialEnergy + 1);\\n            initialEnergy += extraEnergy;\\n            initialEnergy -= energy[i];\\n            trainHoursRequired += extraEnergy;\\n        }\\n\\n\\n        for (int i = 0; i < energy.length; ++i) {\\n            int extraExperience = Math.max(0, experience[i] - initialExperience + 1);\\n            initialExperience += extraExperience;\\n            initialExperience += experience[i];\\n            trainHoursRequired +=  extraExperience;\\n        }\\n        return trainHoursRequired ;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energy, int[] experience) {\\n\\n       int trainHoursRequired = 0;\\n\\n        for (int i = 0; i < energy.length; ++i) {\\n            int extraEnergy = Math.max(0, energy[i] - initialEnergy + 1);\\n            initialEnergy += extraEnergy;\\n            initialEnergy -= energy[i];\\n            trainHoursRequired += extraEnergy;\\n        }\\n\\n\\n        for (int i = 0; i < energy.length; ++i) {\\n            int extraExperience = Math.max(0, experience[i] - initialExperience + 1);\\n            initialExperience += extraExperience;\\n            initialExperience += experience[i];\\n            trainHoursRequired +=  extraExperience;\\n        }\\n        return trainHoursRequired ;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2973349,
                "title": "java-o-n-100-runtime-100-memory",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energies, int[] experience) {\\n        return getNumberOfHoursForEnergy(initialEnergy, energies) + \\n        getNumberOfHoursForExperience(initialExperience, experience);\\n    }\\n\\n    private int getNumberOfHoursForEnergy(int initialEnergy, int[] energies) {\\n        int sum = getSum(energies);\\n        return initialEnergy > sum ? 0 : sum - initialEnergy + 1;\\n    }\\n\\n    private int getNumberOfHoursForExperience(int initialExperience, int[] experience) {\\n        int hours = 0;\\n\\n        for (int xp: experience) {\\n            if (initialExperience <= xp) {\\n                int diff = xp - initialExperience + 1; \\n                hours += diff;\\n                initialExperience += diff;\\n            }\\n            \\n            initialExperience += xp;\\n        }\\n\\n        return hours;\\n    }\\n\\n    private int getSum(int[] arr) {\\n        int sum = 0;\\n\\n        for (int num: arr)\\n            sum += num;\\n        \\n        return sum;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int minNumberOfHours(int initialEnergy, int initialExperience, int[] energies, int[] experience) {\\n        return getNumberOfHoursForEnergy(initialEnergy, energies) + \\n        getNumberOfHoursForExperience(initialExperience, experience);\\n    }\\n\\n    private int getNumberOfHoursForEnergy(int initialEnergy, int[] energies) {\\n        int sum = getSum(energies);\\n        return initialEnergy > sum ? 0 : sum - initialEnergy + 1;\\n    }\\n\\n    private int getNumberOfHoursForExperience(int initialExperience, int[] experience) {\\n        int hours = 0;\\n\\n        for (int xp: experience) {\\n            if (initialExperience <= xp) {\\n                int diff = xp - initialExperience + 1; \\n                hours += diff;\\n                initialExperience += diff;\\n            }\\n            \\n            initialExperience += xp;\\n        }\\n\\n        return hours;\\n    }\\n\\n    private int getSum(int[] arr) {\\n        int sum = 0;\\n\\n        for (int num: arr)\\n            sum += num;\\n        \\n        return sum;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2966841,
                "title": "full-explanation-100-faster",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n1. Since we know an hour of work before either gets us one more energy or experience, it is fairly straightforward to make 1 pass through the array, compute the number of hours of work we need to do to get the minimum required energy, compute the number of hours of work we need to do to get the minimum required experience, and add them together.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nWe do one loop through the energy and experience array. since their length is the same, we do all the computation within a single loop. \\nTwo cases. How to deal with energy? How to deal with effort?\\n1. Initialize two variables, initialEnergy and initialExperience, and set them equal to the parameters in the problem\\n2. for each value in the energy array, we are going to test our initialenergy against it. if initialenergy is greater than it, great, no need to do any work before we fight all n bad guys. just update initialenergy, so it is now equal to initialenergy - energy[i] where i is the currentindex. If energy[i] is greater than or equal to initial energy, we need to add the number of hours to get initialenergy 1 above energy[i] to the counter (ret), and run simulation accordingly.\\nUse similar logic for experience, but remember experience is added, not subtracted.\\n3. add the computations together\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(1)\\n\\n# Code\\n```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        ret = 0\\n        for i in range(0, len(energy)):\\n            if energy[i] >= initialEnergy:\\n                ret += energy[i] - initialEnergy + 1\\n                initialEnergy = 1\\n            else:\\n                initialEnergy -= energy[i]\\n            if experience[i] >= initialExperience:\\n                ret += experience[i] - initialExperience + 1\\n                initialExperience = experience[i] + 1 + experience[i]\\n\\n            else:\\n                initialExperience += experience[i]\\n        return ret\\n   \\n            \\n                \\n                    \\n        \\n            \\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        ret = 0\\n        for i in range(0, len(energy)):\\n            if energy[i] >= initialEnergy:\\n                ret += energy[i] - initialEnergy + 1\\n                initialEnergy = 1\\n            else:\\n                initialEnergy -= energy[i]\\n            if experience[i] >= initialExperience:\\n                ret += experience[i] - initialExperience + 1\\n                initialExperience = experience[i] + 1 + experience[i]\\n\\n            else:\\n                initialExperience += experience[i]\\n        return ret\\n   \\n            \\n                \\n                    \\n        \\n            \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2948370,
                "title": "c-simple-concise-greedy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int res = 0;\\n        int n = energy.size();\\n        for(int i = 0; i < n; i++) {\\n            if(energy[i] >= initialEnergy) {\\n                int diff = energy[i] - initialEnergy + 1;\\n                res += diff; initialEnergy += diff;\\n            }\\n            if(experience[i] >= initialExperience) {\\n                int diff = experience[i] - initialExperience + 1;\\n                res += diff; initialExperience += diff;\\n            }\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int minNumberOfHours(int initialEnergy, int initialExperience, vector<int>& energy, vector<int>& experience) {\\n        int res = 0;\\n        int n = energy.size();\\n        for(int i = 0; i < n; i++) {\\n            if(energy[i] >= initialEnergy) {\\n                int diff = energy[i] - initialEnergy + 1;\\n                res += diff; initialEnergy += diff;\\n            }\\n            if(experience[i] >= initialExperience) {\\n                int diff = experience[i] - initialExperience + 1;\\n                res += diff; initialExperience += diff;\\n            }\\n            initialEnergy -= energy[i];\\n            initialExperience += experience[i];\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2939038,
                "title": "python-solution",
                "content": "```python\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        result = 0\\n        for ene, exp in zip(energy, experience):\\n            if initialEnergy <= ene:\\n                value = 1 + ene - initialEnergy\\n                initialEnergy += value\\n                result += value\\n            initialEnergy -= ene\\n            if initialExperience <= exp:\\n                value = 1 + exp - initialExperience\\n                initialExperience += value\\n                result += value\\n            initialExperience += exp\\n        return result\\n```\\n\\n```python\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        result = 0\\n        for exp in experience:\\n            if initialExperience <= exp:\\n                value = 1 + exp - initialExperience\\n                initialExperience += value\\n                result += value\\n            initialExperience += exp\\n        return result + max(0, sum(energy) + 1 - initialEnergy)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```python\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        result = 0\\n        for ene, exp in zip(energy, experience):\\n            if initialEnergy <= ene:\\n                value = 1 + ene - initialEnergy\\n                initialEnergy += value\\n                result += value\\n            initialEnergy -= ene\\n            if initialExperience <= exp:\\n                value = 1 + exp - initialExperience\\n                initialExperience += value\\n                result += value\\n            initialExperience += exp\\n        return result\\n```\n```python\\nclass Solution:\\n    def minNumberOfHours(self, initialEnergy: int, initialExperience: int, energy: List[int], experience: List[int]) -> int:\\n        result = 0\\n        for exp in experience:\\n            if initialExperience <= exp:\\n                value = 1 + exp - initialExperience\\n                initialExperience += value\\n                result += value\\n            initialExperience += exp\\n        return result + max(0, sum(energy) + 1 - initialEnergy)\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1735899,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Good intro-level greedy problem."
                    },
                    {
                        "username": "Sarthak20574",
                        "content": " This problem screams, \"Read me\". Please don't assume things🥲\n\nI also stronly feel this problem should be a medium."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I really liked this question, why so many dislikes?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A great problem to feel greedy ideal"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Some good changes"
                    }
                ]
            },
            {
                "id": 2044144,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Good intro-level greedy problem."
                    },
                    {
                        "username": "Sarthak20574",
                        "content": " This problem screams, \"Read me\". Please don't assume things🥲\n\nI also stronly feel this problem should be a medium."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I really liked this question, why so many dislikes?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A great problem to feel greedy ideal"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Some good changes"
                    }
                ]
            },
            {
                "id": 1914905,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Good intro-level greedy problem."
                    },
                    {
                        "username": "Sarthak20574",
                        "content": " This problem screams, \"Read me\". Please don't assume things🥲\n\nI also stronly feel this problem should be a medium."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I really liked this question, why so many dislikes?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A great problem to feel greedy ideal"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Some good changes"
                    }
                ]
            },
            {
                "id": 1830897,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Good intro-level greedy problem."
                    },
                    {
                        "username": "Sarthak20574",
                        "content": " This problem screams, \"Read me\". Please don't assume things🥲\n\nI also stronly feel this problem should be a medium."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I really liked this question, why so many dislikes?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A great problem to feel greedy ideal"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Some good changes"
                    }
                ]
            },
            {
                "id": 1624061,
                "content": [
                    {
                        "username": "YusenPeng",
                        "content": "Good intro-level greedy problem."
                    },
                    {
                        "username": "Sarthak20574",
                        "content": " This problem screams, \"Read me\". Please don't assume things🥲\n\nI also stronly feel this problem should be a medium."
                    },
                    {
                        "username": "yeedaKing",
                        "content": "I really liked this question, why so many dislikes?"
                    },
                    {
                        "username": "JiayingGao",
                        "content": "A great problem to feel greedy ideal"
                    },
                    {
                        "username": "nursultanbegaliev",
                        "content": "Some good changes"
                    }
                ]
            }
        ]
    },
    {
        "title": "Largest Palindromic Number",
        "question_content": "<p>You are given a string <code>num</code> consisting of digits only.</p>\n\n<p>Return <em>the <strong>largest palindromic</strong> integer (in the form of a string) that can be formed using digits taken from </em><code>num</code>. It should not contain <strong>leading zeroes</strong>.</p>\n\n<p><strong>Notes:</strong></p>\n\n<ul>\n\t<li>You do <strong>not</strong> need to use all the digits of <code>num</code>, but you must use <strong>at least</strong> one digit.</li>\n\t<li>The digits can be reordered.</li>\n</ul>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;444947137&quot;\n<strong>Output:</strong> &quot;7449447&quot;\n<strong>Explanation:</strong> \nUse the digits &quot;4449477&quot; from &quot;<u><strong>44494</strong></u><u><strong>7</strong></u>13<u><strong>7</strong></u>&quot; to form the palindromic integer &quot;7449447&quot;.\nIt can be shown that &quot;7449447&quot; is the largest palindromic integer that can be formed.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n\n<pre>\n<strong>Input:</strong> num = &quot;00009&quot;\n<strong>Output:</strong> &quot;9&quot;\n<strong>Explanation:</strong> \nIt can be shown that &quot;9&quot; is the largest palindromic integer that can be formed.\nNote that the integer returned should not contain leading zeroes.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li><code>1 &lt;= num.length &lt;= 10<sup>5</sup></code></li>\n\t<li><code>num</code> consists of digits.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2456655,
                "title": "python-hashmap-solution-with-explanation",
                "content": "# **Explanation**\\n1. Count the frequency of all digits in `num`\\n2. Check how many pair of `9` that we have:\\nIf we have one pair of `9`, we can make `9XXXXXX9`, `res = \\'99\\'` now.\\nIf we have two pairs of `9`, we can make `99XXXX99`, `res = \\'9\\'` now.\\n3. Continue check pairs for 8,7,6,5,4,3,2,1,0\\n4. Strip the leading `0` in `res`\\n5. Find the maximum digit left that can be used for the middle digit of palindromic number.\\n6. final result is `res + mid + reversed(res)`\\n7. For special input like `00`, we need to return `0`.\\n<br>\\n\\n# **Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n<br>\\n\\n**Python**\\n```py\\n    def largestPalindromic(self, num: str) -> str:\\n        count = Counter(num)\\n        res = \\'\\'.join(count[i] // 2 * i for i in \\'9876543210\\').lstrip(\\'0\\')\\n        mid = max(count[i] % 2 * i for i in count)\\n        return (res + mid + res[::-1]) or \\'0\\'\\n```\\n",
                "solutionTags": [
                    "Python"
                ],
                "code": "```py\\n    def largestPalindromic(self, num: str) -> str:\\n        count = Counter(num)\\n        res = \\'\\'.join(count[i] // 2 * i for i in \\'9876543210\\').lstrip(\\'0\\')\\n        mid = max(count[i] % 2 * i for i in count)\\n        return (res + mid + res[::-1]) or \\'0\\'\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2456626,
                "title": "cpp-java-greedy-o-n-space-o-n-time",
                "content": "**Intuition :** Just count the frequency of each character and start from `9` to `0` and check if it is occurring more than once or not if so then keep pushing it in your ans variable untill its frequency drops to `1` or less and also keep account of the number occuring exactly once after all operations.\\n\\n**Time Complexity :** O(n)\\n**Space Complexity :** O(n)\\n\\n**CPP**\\n\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string s) {\\n        vector<int> v(10);\\n        for(char c:s)v[c-\\'0\\']++;\\n        string ans;\\n        int single=-1;\\n        for(int i=9;i>=0;i--){\\n            if(ans.empty() && i==0) continue;\\n            while(v[i]>1){\\n                ans.push_back(i+\\'0\\');\\n                v[i]-=2;\\n            }\\n            if(v[i]==1 && single==-1)single=i;\\n        }\\n        string res=string(ans.rbegin(),ans.rend());\\n        if(ans.empty() && single==-1) return \"0\";\\n        if(single!=-1)\\n            ans.push_back(single+\\'0\\');\\n        ans+=res;\\n        return ans;\\n    }\\n};\\n```\\n\\n**JAVA**\\n\\n```\\nclass Solution {\\n    public String largestPalindromic(String s) {\\n        int[] v=new int[10];\\n        for(int i=0;i<s.length();i++){\\n            v[(int)s.charAt(i)-48]++;\\n        }\\n        StringBuffer ans = new StringBuffer();\\n        int single = -1;\\n        for(int i=9;i>=0;i--){\\n            if(ans.length()==0 && i==0)continue;\\n            while(v[i]>1){\\n                ans.append((char)(i+48));\\n                v[i]-=2;\\n            }\\n            if(v[i]==1 && single == -1)single = i;\\n        }\\n        if(ans.length()==0 && single==-1)return \"0\";\\n        int i = ans.length()-1;\\n        if(single!=-1)ans.append((char)(single+48));\\n        for(;i>=0;i--){\\n            ans.append(ans.charAt(i));\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Java",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string s) {\\n        vector<int> v(10);\\n        for(char c:s)v[c-\\'0\\']++;\\n        string ans;\\n        int single=-1;\\n        for(int i=9;i>=0;i--){\\n            if(ans.empty() && i==0) continue;\\n            while(v[i]>1){\\n                ans.push_back(i+\\'0\\');\\n                v[i]-=2;\\n            }\\n            if(v[i]==1 && single==-1)single=i;\\n        }\\n        string res=string(ans.rbegin(),ans.rend());\\n        if(ans.empty() && single==-1) return \"0\";\\n        if(single!=-1)\\n            ans.push_back(single+\\'0\\');\\n        ans+=res;\\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\n    public String largestPalindromic(String s) {\\n        int[] v=new int[10];\\n        for(int i=0;i<s.length();i++){\\n            v[(int)s.charAt(i)-48]++;\\n        }\\n        StringBuffer ans = new StringBuffer();\\n        int single = -1;\\n        for(int i=9;i>=0;i--){\\n            if(ans.length()==0 && i==0)continue;\\n            while(v[i]>1){\\n                ans.append((char)(i+48));\\n                v[i]-=2;\\n            }\\n            if(v[i]==1 && single == -1)single = i;\\n        }\\n        if(ans.length()==0 && single==-1)return \"0\";\\n        int i = ans.length()-1;\\n        if(single!=-1)ans.append((char)(single+48));\\n        for(;i>=0;i--){\\n            ans.append(ans.charAt(i));\\n        }\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460540,
                "title": "c-faster-than-100-solution-with-comments-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/774f117a-a0b0-47cb-96e5-922449c3a457_1661108136.4794323.png)\\n```\\n// Please Upvote , if you find this answer Useful ;)\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int>freqArr(10); // Creating Frequency array of only size 10 as the range of characters is : 0 - 9 (total 10 different values)\\n        \\n        for(char i:num)freqArr[i - \\'0\\']++; // Storing the frequency\\n        \\n        string front = \"\", back = \"\"; // Intiliasing two empty strings \\n        \\n        for(int i = 9;i>=0;i--) // starting the loop in the reverse as we need to create largest palindrome number\\n        {\\n            // if the front and back string is empty and we add zero to it , it will have leading zeroes , which we explicitly do not want in our answer \\n           \\n            if(i == 0 && front.empty())\\n                continue;\\n           \\n            // if it has only one character as its frequency than we may or may not need it in our final answer as we can have at max only one character in our answer whose frequency is one or else we cannot create palindrome.\\n            \\n            while(freqArr[i] > 1) \\n            {\\n                // Inserting the characters in both the strings\\n                \\n                front += to_string(i);\\n                back += to_string(i);\\n                freqArr[i] -= 2;\\n            }\\n        }\\n        \\n        //As above mentioned , we can have one value whose frequency is one in our final answer, so the trick is to add the lasrgest possible value available in the frequency array to get the largest possible palindrome\\n        \\n        for(int i = 9;i>=0;i--)\\n        {\\n            if(freqArr[i]) \\n            {\\n                front += to_string(i);\\n                break;\\n            }\\n        }\\n        \\n        // reverse the back string and concatenate it with the front and return it;\\n        \\n        reverse(back.begin(),back.end());\\n        \\n        return front + back ;\\n        \\n        // Voila ! You reach to your answer.\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Array"
                ],
                "code": "```\\n// Please Upvote , if you find this answer Useful ;)\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int>freqArr(10); // Creating Frequency array of only size 10 as the range of characters is : 0 - 9 (total 10 different values)\\n        \\n        for(char i:num)freqArr[i - \\'0\\']++; // Storing the frequency\\n        \\n        string front = \"\", back = \"\"; // Intiliasing two empty strings \\n        \\n        for(int i = 9;i>=0;i--) // starting the loop in the reverse as we need to create largest palindrome number\\n        {\\n            // if the front and back string is empty and we add zero to it , it will have leading zeroes , which we explicitly do not want in our answer \\n           \\n            if(i == 0 && front.empty())\\n                continue;\\n           \\n            // if it has only one character as its frequency than we may or may not need it in our final answer as we can have at max only one character in our answer whose frequency is one or else we cannot create palindrome.\\n            \\n            while(freqArr[i] > 1) \\n            {\\n                // Inserting the characters in both the strings\\n                \\n                front += to_string(i);\\n                back += to_string(i);\\n                freqArr[i] -= 2;\\n            }\\n        }\\n        \\n        //As above mentioned , we can have one value whose frequency is one in our final answer, so the trick is to add the lasrgest possible value available in the frequency array to get the largest possible palindrome\\n        \\n        for(int i = 9;i>=0;i--)\\n        {\\n            if(freqArr[i]) \\n            {\\n                front += to_string(i);\\n                break;\\n            }\\n        }\\n        \\n        // reverse the back string and concatenate it with the front and return it;\\n        \\n        reverse(back.begin(),back.end());\\n        \\n        return front + back ;\\n        \\n        // Voila ! You reach to your answer.\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456637,
                "title": "easy-c-count",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int> cnt(10);\\n        for (char c: num) {\\n            cnt[c - \\'0\\']++;\\n        }\\n        \\n        string lp, rp; // left and right partition\\n        for (int i: num) {\\n            for (int j = 9; j >= 0; j--)  {\\n                if (cnt[j] > 1 && (j > 0 || lp.size())) {\\n                    lp += \\'0\\' + j;\\n                    rp += \\'0\\' + j;\\n                    cnt[j] -= 2;\\n                    break;\\n                }\\n            }\\n        }\\n        for (int i = 9; i >= 0; i--) {\\n            if (cnt[i]) {\\n                lp += \\'0\\' + i; break;\\n            }\\n        }\\n        reverse(begin(rp), end(rp));\\n        return lp + rp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int> cnt(10);\\n        for (char c: num) {\\n            cnt[c - \\'0\\']++;\\n        }\\n        \\n        string lp, rp; // left and right partition\\n        for (int i: num) {\\n            for (int j = 9; j >= 0; j--)  {\\n                if (cnt[j] > 1 && (j > 0 || lp.size())) {\\n                    lp += \\'0\\' + j;\\n                    rp += \\'0\\' + j;\\n                    cnt[j] -= 2;\\n                    break;\\n                }\\n            }\\n        }\\n        for (int i = 9; i >= 0; i--) {\\n            if (cnt[i]) {\\n                lp += \\'0\\' + i; break;\\n            }\\n        }\\n        reverse(begin(rp), end(rp));\\n        return lp + rp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2472073,
                "title": "solution-to-memory-limit-exceeded-in-c",
                "content": "when you append char to your string(ans) try to append like this..\\n**ans += s[i];**   (here s is the given string).\\nIf you append char like ans = ans + s[i];  it will give you Memory Limit Exceeded.\\n\\nReason->>>>>>>>\\n\\nstring operator+(string&, string&) operator copies the arguments into a new string object. You then copy this temporary return value into res - which may also involve copying into a new, larger buffer. Unless C++11 is enabled, in which case move assignment will be used, so the latter potential allocation + copy is avoided.\\n\\nstring& operator+=(const string&) does not create a new string object. It modifies the existing string buffer in-place - unless a larger buffer is needed, in which case reallocation cannot be avoided.\\n\\n**So, res += c avoids creation of temporary buffers in dynamic memory. If the string is large enough, doubling the number of simultaneously used copies can roughly double the peak memory use of the program. Also, the extra temporary allocations may increase the fragmentation of dynamic memory space, which increases the overhead of dynamic memory management. These two factors may cause the memory limit given for the program to be exceeded.**\\n",
                "solutionTags": [],
                "code": "when you append char to your string(ans) try to append like this..\\n**ans += s[i];**   (here s is the given string).\\nIf you append char like ans = ans + s[i];  it will give you Memory Limit Exceeded.\\n\\nReason->>>>>>>>\\n\\nstring operator+(string&, string&) operator copies the arguments into a new string object. You then copy this temporary return value into res - which may also involve copying into a new, larger buffer. Unless C++11 is enabled, in which case move assignment will be used, so the latter potential allocation + copy is avoided.\\n\\nstring& operator+=(const string&) does not create a new string object. It modifies the existing string buffer in-place - unless a larger buffer is needed, in which case reallocation cannot be avoided.\\n\\n**So, res += c avoids creation of temporary buffers in dynamic memory. If the string is large enough, doubling the number of simultaneously used copies can roughly double the peak memory use of the program. Also, the extra temporary allocations may increase the fragmentation of dynamic memory space, which increases the overhead of dynamic memory management. These two factors may cause the memory limit given for the program to be exceeded.**\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2456940,
                "title": "python-easy-to-understand-o-n-solution",
                "content": "```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        c = Counter(num)\\n        if len(c)==1 and c[\\'0\\']>=1:\\n            return \"0\"\\n        m = -1   #storing the mid of the number\\n        res1 = \\'\\'\\n        res2 = \\'\\'\\n        for i in range(9,-1,-1):\\n            while c[str(i)]:\\n                if not res1 and i==0:   #to avoid adding 0 at first\\n                    break \\n                if c[str(i)]>=2:\\n\\n                    res1 += str(i)\\n                    res2 = str(i) + res2\\n                    c[str(i)]-=2\\n                if c[str(i)] == 1:\\n                    m = max(m,i)  #updating medium to max\\n                    c[str(i)]-=1\\n                if c[str(i)]==0:\\n                    del c[str(i)]\\n        return res1+res2 if m==-1 else res1 + str(m) + res2",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        c = Counter(num)\\n        if len(c)==1 and c[\\'0\\']>=1:\\n            return \"0\"\\n        m = -1   #storing the mid of the number\\n        res1 = \\'\\'\\n        res2 = \\'\\'\\n        for i in range(9,-1,-1):\\n            while c[str(i)]:\\n                if not res1 and i==0:   #to avoid adding 0 at first\\n                    break \\n                if c[str(i)]>=2:\\n\\n                    res1 += str(i)\\n                    res2 = str(i) + res2\\n                    c[str(i)]-=2\\n                if c[str(i)] == 1:\\n                    m = max(m,i)  #updating medium to max\\n                    c[str(i)]-=1\\n                if c[str(i)]==0:\\n                    del c[str(i)]\\n        return res1+res2 if m==-1 else res1 + str(m) + res2",
                "codeTag": "Java"
            },
            {
                "id": 2456668,
                "title": "java-easy-to-understand-solution-using-array-with-explanation-o-n",
                "content": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int[] n = new int[10];\\n        for (char c : num.toCharArray()) {\\n            n[c - \\'0\\']++;\\n        }\\n        boolean only = false;\\n\\t\\t//seperate the result into 3 parts, the first half and second half, also the center (if exist)\\n        StringBuilder sbPre = new StringBuilder();\\n        StringBuilder sbPost = new StringBuilder();\\n        StringBuilder sbOnly = new StringBuilder();\\n\\t\\t//check from 9 to 1, to make it the largest\\n        for (int i = 9; i >= 0; i--) {\\n\\t\\t    //check for center\\n            if (n[i] % 2 != 0 && !only) {\\n                only = true;\\n                sbOnly.append(Integer.toString(i));\\n            }\\n\\t\\t\\t//handle special case of all \\'0\\' or \\'0\\' is the first digit(invalid) \\n            if (i == 0 && sbPre.length() == 0) {\\n                if (n[i] > 0 && sbOnly.length() == 0) sbOnly.append(Integer.toString(i));\\n                return sbOnly.toString();\\n            }\\n            for (int j = 0; j < n[i] / 2; j++) {\\n                sbPre.append(Integer.toString(i));\\n                sbPost.insert(0, Integer.toString(i));\\n            }\\n        }\\n        sbPre.append(sbOnly);\\n        sbPre.append(sbPost);\\n        return sbPre.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "class Solution {\\n    public String largestPalindromic(String num) {\\n        int[] n = new int[10];\\n        for (char c : num.toCharArray()) {\\n            n[c - \\'0\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2456580,
                "title": "c-deque-map-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        \\n        // map\\n        map<char,int> mp;\\n        for(auto x : num){\\n            mp[x]++;\\n        }\\n        \\n        // vectors\\n        vector<char> notone , one;\\n        \\n        for(auto x : mp){\\n            if(x.second == 1){\\n                one.push_back(x.first);\\n            }else{\\n                if(x.second%2 ==1){\\n                    one.push_back(x.first);\\n                    mp[x.first]--;\\n                }\\n                notone.push_back(x.first);\\n            }\\n        }\\n\\n        sort(one.begin(),one.end(),greater<int>());\\n        sort(notone.begin(),notone.end());\\n\\n        deque<char> dq;\\n        // putting greatest element with 1 freq in string\\n        if(one.size()>0) dq.push_front(one[0]);\\n        \\n        // case of empty with 0\\n        if(notone.size()==1 and notone[0] == \\'0\\'){ if(dq.empty()) dq.push_front(\\'0\\');}\\n        else{\\n            for(auto x : notone){\\n                int freq = mp[x]/2;\\n                while(freq-- > 0){\\n                    dq.push_back(x);\\n\\t\\t\\t\\t\\tdq.push_front(x);\\n                }\\n            }\\n        }\\n        \\n        string ans = \"\";\\n        while(!dq.empty()){\\n            ans += dq.front();\\n            dq.pop_front();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        \\n        // map\\n        map<char,int> mp;\\n        for(auto x : num){\\n            mp[x]++;\\n        }\\n        \\n        // vectors\\n        vector<char> notone , one;\\n        \\n        for(auto x : mp){\\n            if(x.second == 1){\\n                one.push_back(x.first);\\n            }else{\\n                if(x.second%2 ==1){\\n                    one.push_back(x.first);\\n                    mp[x.first]--;\\n                }\\n                notone.push_back(x.first);\\n            }\\n        }\\n\\n        sort(one.begin(),one.end(),greater<int>());\\n        sort(notone.begin(),notone.end());\\n\\n        deque<char> dq;\\n        // putting greatest element with 1 freq in string\\n        if(one.size()>0) dq.push_front(one[0]);\\n        \\n        // case of empty with 0\\n        if(notone.size()==1 and notone[0] == \\'0\\'){ if(dq.empty()) dq.push_front(\\'0\\');}\\n        else{\\n            for(auto x : notone){\\n                int freq = mp[x]/2;\\n                while(freq-- > 0){\\n                    dq.push_back(x);\\n\\t\\t\\t\\t\\tdq.push_front(x);\\n                }\\n            }\\n        }\\n        \\n        string ans = \"\";\\n        while(!dq.empty()){\\n            ans += dq.front();\\n            dq.pop_front();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458635,
                "title": "brute-force-long-but-understandable-code",
                "content": "since today google kickstart round was there I couldn\\'t attempt today\\'s weekly contest.so long story short what happened with me in today\\'s kickstart contest that I solved two questions and i was solving third,I knew brute force of that but was trying to optimize,in kickstart you get partial marks also(there are two test sets one in which your brute force will work and for passing second test you have to write optimized code,since constraints are different for both,so till last also i couldn\\'t optimize my solution and started writing brute force just before 5 minutes,it passed but after 1 minute of contest end(sad,isn\\'t?)\\nso,for this question when i was attempting virtual i tried to code totally brute force and then see if i get stuck- we\\'ll see\\n\\nso the idea is if you have let say 5 9s,4 8s,7 3 s we will go like 99..............99 because we want largest right\\nso first let\\'s have a count of 9 8 7 6 5 4 3 2 1and 0. after that let\\'s write in descending way like if i have 5 9s i will write 99 so that for making palindrome i\\'ll need other two 9s likewise 8 then 7 then 6....and so on. now when i.m done my string length is even and it is palindrome...but..but..but i can add one character also and it will still remain palindrome so ill check from 9 which character had odd frequency because we used only freq/2* 2 right , so if its odd we have one left frequency that we will add in last\\n\\n\\n*let\\'s talk about edge cases because i saw many people angry on this question so basically we can\\'t have leading zeros fine we will just check before adding zeros that earlier string is non empty it means we have other characters also and since we are adding zeros in mid no risk of that also check what if only zeros are present and all other count c1 c2 c3 c4 c5 are zero so we will return 0 in that case.*\\n\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n          int n = num.size();\\n        int i;\\n        unordered_map<char,int>mp;\\n        for(i=0;i<n;i++)\\n        {\\n            mp[num[i]]++;\\n        }\\n        string ans;\\n        int c0=mp[0+\\'0\\'];\\n        int c1=mp[1+\\'0\\'];\\n        int c2=mp[2+\\'0\\'];\\n        int c3=mp[3+\\'0\\'];\\n        int c4=mp[4+\\'0\\'];\\n        int c5=mp[5+\\'0\\'];\\n        int c6=mp[6+\\'0\\'];\\n        int c7=mp[7+\\'0\\'];\\n        int c8=mp[8+\\'0\\'];\\n        int c9=mp[9+\\'0\\'];\\n        for(i=0;i<c9/2;i++)\\n        {\\n            ans.push_back(\\'9\\');\\n        }\\n         for(i=0;i<c8/2;i++)\\n        {\\n            ans.push_back(\\'8\\');\\n        }\\n         for(i=0;i<c7/2;i++)\\n        {\\n            ans.push_back(\\'7\\');\\n        }\\n         for(i=0;i<c6/2;i++)\\n        {\\n            ans.push_back(\\'6\\');\\n        }\\n         for(i=0;i<c5/2;i++)\\n        {\\n            ans.push_back(\\'5\\');\\n        }\\n         for(i=0;i<c4/2;i++)\\n        {\\n            ans.push_back(\\'4\\');\\n        }\\n         for(i=0;i<c3/2;i++)\\n        {\\n            ans.push_back(\\'3\\');\\n        }\\n         for(i=0;i<c2/2;i++)\\n        {\\n            ans.push_back(\\'2\\');\\n        }\\n         for(i=0;i<c1/2;i++)\\n        {\\n            ans.push_back(\\'1\\');\\n        }\\n         for(i=0;i<c0/2;i++)\\n        {\\n             if(ans.size()>0)\\n             {\\n                 ans.push_back(\\'0\\');\\n             }\\n             else{\\n                 break;\\n             }\\n            \\n        }\\n        string check;\\n        int temp=0;\\n        for(i=9;i>=1;i--)\\n        {\\n            if(mp[i+\\'0\\']%2!=0)\\n            {\\n                check=i+\\'0\\';\\n                temp=1;\\n                break;\\n            }\\n        }\\n        if(temp==0 && ans.size()>0 && c0%2!=0)\\n        {\\n            check=0+\\'0\\';\\n        }\\n        string res = ans;\\n        reverse(res.begin(),res.end());\\n        ans = ans+check;\\n        ans=ans+res;\\n        if(c0>0 &&((c1+c2+c3+c4+c5+c6+c7+c8+c9)==0))\\n        {\\n            return \"0\";\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```\\ni know the code is poorly written i know but i just want to say that always write brute force because all this things like indentation code beauty and all comes after getting AC only. and when i submitted it passed and i saw faster than 100% and less space than 100%, i was damn happy :>\\ncomment if you have any doubt, also while writing this i was excited so pardon my writing skills.\\n\\np.s - always have faith in your own code!!!\\n\\nthanks.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n          int n = num.size();\\n        int i;\\n        unordered_map<char,int>mp;\\n        for(i=0;i<n;i++)\\n        {\\n            mp[num[i]]++;\\n        }\\n        string ans;\\n        int c0=mp[0+\\'0\\'];\\n        int c1=mp[1+\\'0\\'];\\n        int c2=mp[2+\\'0\\'];\\n        int c3=mp[3+\\'0\\'];\\n        int c4=mp[4+\\'0\\'];\\n        int c5=mp[5+\\'0\\'];\\n        int c6=mp[6+\\'0\\'];\\n        int c7=mp[7+\\'0\\'];\\n        int c8=mp[8+\\'0\\'];\\n        int c9=mp[9+\\'0\\'];\\n        for(i=0;i<c9/2;i++)\\n        {\\n            ans.push_back(\\'9\\');\\n        }\\n         for(i=0;i<c8/2;i++)\\n        {\\n            ans.push_back(\\'8\\');\\n        }\\n         for(i=0;i<c7/2;i++)\\n        {\\n            ans.push_back(\\'7\\');\\n        }\\n         for(i=0;i<c6/2;i++)\\n        {\\n            ans.push_back(\\'6\\');\\n        }\\n         for(i=0;i<c5/2;i++)\\n        {\\n            ans.push_back(\\'5\\');\\n        }\\n         for(i=0;i<c4/2;i++)\\n        {\\n            ans.push_back(\\'4\\');\\n        }\\n         for(i=0;i<c3/2;i++)\\n        {\\n            ans.push_back(\\'3\\');\\n        }\\n         for(i=0;i<c2/2;i++)\\n        {\\n            ans.push_back(\\'2\\');\\n        }\\n         for(i=0;i<c1/2;i++)\\n        {\\n            ans.push_back(\\'1\\');\\n        }\\n         for(i=0;i<c0/2;i++)\\n        {\\n             if(ans.size()>0)\\n             {\\n                 ans.push_back(\\'0\\');\\n             }\\n             else{\\n                 break;\\n             }\\n            \\n        }\\n        string check;\\n        int temp=0;\\n        for(i=9;i>=1;i--)\\n        {\\n            if(mp[i+\\'0\\']%2!=0)\\n            {\\n                check=i+\\'0\\';\\n                temp=1;\\n                break;\\n            }\\n        }\\n        if(temp==0 && ans.size()>0 && c0%2!=0)\\n        {\\n            check=0+\\'0\\';\\n        }\\n        string res = ans;\\n        reverse(res.begin(),res.end());\\n        ans = ans+check;\\n        ans=ans+res;\\n        if(c0>0 &&((c1+c2+c3+c4+c5+c6+c7+c8+c9)==0))\\n        {\\n            return \"0\";\\n        }\\n        return ans;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456891,
                "title": "java-map",
                "content": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int[] map = new int[10];\\n\\t\\tfor (int n : num.toCharArray()) {\\n            map[n - \\'0\\']++;\\n        }\\n\\t\\t\\n        int odd = -1;    //  stores the maximum number with odd frequency\\n        for (int i = 0; i < 10; i++) {\\n            if ((map[i] % 2) == 1) {\\n                odd = i;\\n            }\\n        }\\n        \\n\\t\\t//  build (from right to left) the second half of the palindrome, using only half of the numbers\\n        StringBuilder answer = new StringBuilder();\\n        for (int i = 9; i >= 0; i--) {\\n            for (int c = 0; c < map[i] / 2; c++) {\\n                if (i == 0 && answer.length() == 0) break;    //  edge case\\n                answer.insert(0, i);\\n            }\\n        }\\n        \\n        StringBuilder a = new StringBuilder(answer);\\n        a.reverse();\\n        if (odd == -1) {\\n\\t\\t    //  no odd number is seen and answer is empty() then return \"0\"\\n            if (answer.length() == 0) return \"0\";\\n\\t\\t\\t//  combine the two portions\\n            return a.toString() + answer.toString();\\n        }\\n\\t\\treturn a.toString() + odd + answer.toString();\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String largestPalindromic(String num) {\\n        int[] map = new int[10];\\n\\t\\tfor (int n : num.toCharArray()) {\\n            map[n - \\'0\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2456621,
                "title": "c-solution",
                "content": "```\\nclass Solution\\n{\\n    public:\\n        string largestPalindromic(string s)\\n        {\\n            int n = s.size();\\n            int dp[10];\\n            memset(dp, 0, sizeof(dp));\\n            for (int i = 0; i < n; i++)\\n            {\\n                dp[s[i] - \\'0\\']++;\\n            }\\n            string ans;\\n            for (int i = 9; i >= 0; i--)\\n            {\\n                if (ans.size() == 0 && i == 0)\\n                {\\n                    continue;\\n                }\\n                while (dp[i] != 0 && dp[i] >= 2)\\n                {\\n                    ans.push_back(i + \\'0\\');\\n                    dp[i] -= 2;\\n                }\\n            }\\n            int mid_val = -1;\\n            for (int i = 0; i <= 9; i++)\\n            {\\n                if (dp[i])\\n                {\\n                    mid_val = max(mid_val, i);\\n                }\\n            }\\n            int f = 0;\\n            string str1 = ans;\\n            string str2 = ans;\\n            reverse(str2.begin(), str2.end());\\n            return str1 + (mid_val != -1 ? string(1, mid_val + \\'0\\') : \"\") + str2;\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution\\n{\\n    public:\\n        string largestPalindromic(string s)\\n        {\\n            int n = s.size();\\n            int dp[10];\\n            memset(dp, 0, sizeof(dp));\\n            for (int i = 0; i < n; i++)\\n            {\\n                dp[s[i] - \\'0\\']++;\\n            }\\n            string ans;\\n            for (int i = 9; i >= 0; i--)\\n            {\\n                if (ans.size() == 0 && i == 0)\\n                {\\n                    continue;\\n                }\\n                while (dp[i] != 0 && dp[i] >= 2)\\n                {\\n                    ans.push_back(i + \\'0\\');\\n                    dp[i] -= 2;\\n                }\\n            }\\n            int mid_val = -1;\\n            for (int i = 0; i <= 9; i++)\\n            {\\n                if (dp[i])\\n                {\\n                    mid_val = max(mid_val, i);\\n                }\\n            }\\n            int f = 0;\\n            string str1 = ans;\\n            string str2 = ans;\\n            reverse(str2.begin(), str2.end());\\n            return str1 + (mid_val != -1 ? string(1, mid_val + \\'0\\') : \"\") + str2;\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465316,
                "title": "many-edge-cases",
                "content": "The problem is not that hard: count numbers, and greedily build half of a string starting from the largest number.\\n\\nThough, I initially got WA for the these test cases:\\n- \"00\" (answer is \"0\")\\n- \"00009\" (answer is \"9\").\\n\\n**C++**\\n```cpp\\nstring largestPalindromic(string num) {\\n    int cnt[10] = {};\\n    for (char ch : num)\\n        ++cnt[ch - \\'0\\'];\\n    string res, mid;\\n    for (int i = 9; i >= 0; --i) {\\n        res += string(cnt[i] / 2, \\'0\\' + i);\\n        if (mid.empty() && cnt[i] % 2)\\n            mid = string(1, \\'0\\' + i);\\n    }\\n    return res[0] == \\'0\\' ? (mid.empty() ? \"0\" : mid) : res + mid + string(rbegin(res), rend(res));\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nstring largestPalindromic(string num) {\\n    int cnt[10] = {};\\n    for (char ch : num)\\n        ++cnt[ch - \\'0\\'];\\n    string res, mid;\\n    for (int i = 9; i >= 0; --i) {\\n        res += string(cnt[i] / 2, \\'0\\' + i);\\n        if (mid.empty() && cnt[i] % 2)\\n            mid = string(1, \\'0\\' + i);\\n    }\\n    return res[0] == \\'0\\' ? (mid.empty() ? \"0\" : mid) : res + mid + string(rbegin(res), rend(res));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2456726,
                "title": "hashmap-solution",
                "content": "create frequency hashmap and just check frequency is even or odd ,\\nclass Solution {\\n\\n    public String largestPalindromic(String num) {\\n        \\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        \\n        for(int i=0;i<num.length();i++){\\n            int value = num.charAt(i) - \\'0\\';\\n            hm.put(value,hm.getOrDefault(value,0)+1);\\n        }\\n        \\n        StringBuilder sb = new StringBuilder();\\n        StringBuilder rev = new StringBuilder();\\n        \\n       while(true){\\n           \\n          boolean flag = false;\\n           for(int i=9;i>=0;i--){\\n               \\n               if(sb.length() == 0 && i == 0) continue;\\n               int freq = hm.getOrDefault(i,0);\\n               \\n               if(freq != 0){\\n                    if(freq%2 == 0){\\n                        for(int j=1;j<=freq/2;j++){\\n                            sb.append(i);\\n                            rev.append(i);\\n                            flag = true;\\n                        }\\n                        hm.put(i,0);\\n                    }\\n                   else{\\n                       int value  = freq/2;\\n                       int mod = freq%2;\\n                       \\n                       for(int j=1;j<=value;j++){\\n                           sb.append(i);\\n                           rev.append(i);\\n                           flag = true;\\n                       }\\n                       hm.put(i,mod);\\n                   }\\n               }\\n           }\\n           \\n           if(!flag) break;\\n       }\\n        \\n      for(int i=9;i>=0;i--){  \\n          if(hm.containsKey(i) && hm.get(i)>0){\\n              sb.append(i);\\n              break;\\n          }\\n      }\\n      String str = (sb.toString() + rev.reverse().toString());\\n      return str;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n\\n    public String largestPalindromic(String num) {\\n        \\n        HashMap<Integer,Integer> hm = new HashMap<>();\\n        \\n        for(int i=0;i<num.length();i++){\\n            int value = num.charAt(i) - \\'0\\';\\n            hm.put(value,hm.getOrDefault(value,0)+1);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2460845,
                "title": "c-frequency-count-bucket-sort-100-14ms-easy-to-understand",
                "content": "We bucket sort (frequency count) the input ```num``` and the rest is straight forward, there are only a few corner cases that need to be handled. See inline comments.\\n\\n```\\n    string largestPalindromic(const string& num) {\\n        // Frequency count.\\n        array<int, 128> counts = {};\\n        for (char ch : num) ++counts[ch];\\n        \\n        // Use the largest digits first.\\n        string front;\\n        front.reserve(size(num) / 2);\\n        for (char ch = \\'9\\'; ch >= \\'1\\'; --ch) {\\n            if (counts[ch] >= 2) front += string(counts[ch] / 2, ch);\\n        }\\n\\n        // If we have used other digits we can use ther zeros too.\\n        if (!empty(front) && counts[\\'0\\'] >= 2) front += string(counts[\\'0\\'] / 2, \\'0\\');\\n        \\n        // If we have a odd count us the largest in the center.\\n        string center;\\n        for (char ch = \\'9\\'; ch >= \\'0\\'; --ch) {\\n            if (counts[ch] & 1) {\\n                center.push_back(ch);\\n                break;\\n            }\\n        }\\n        \\n        // Special case: only even number of zero digits in the input.\\n        if (empty(front) && empty(center)) center = \"0\";\\n        \\n        // Stitch the result together.\\n        return front + center + string(crbegin(front), crend(front));\\n    }\\n```\\n\\nTime complexity: ```O(n)``` We scan the input once and at most we add ```size(num) / 2``` characters to the string ```front``` and in the end we reverse it once.\\nSpace complexity: ```O(n)``` the string ```front``` grows at most to ```size(num) / 2``` and the rest is just some loop variables.",
                "solutionTags": [
                    "C"
                ],
                "code": "```num```\n```\\n    string largestPalindromic(const string& num) {\\n        // Frequency count.\\n        array<int, 128> counts = {};\\n        for (char ch : num) ++counts[ch];\\n        \\n        // Use the largest digits first.\\n        string front;\\n        front.reserve(size(num) / 2);\\n        for (char ch = \\'9\\'; ch >= \\'1\\'; --ch) {\\n            if (counts[ch] >= 2) front += string(counts[ch] / 2, ch);\\n        }\\n\\n        // If we have used other digits we can use ther zeros too.\\n        if (!empty(front) && counts[\\'0\\'] >= 2) front += string(counts[\\'0\\'] / 2, \\'0\\');\\n        \\n        // If we have a odd count us the largest in the center.\\n        string center;\\n        for (char ch = \\'9\\'; ch >= \\'0\\'; --ch) {\\n            if (counts[ch] & 1) {\\n                center.push_back(ch);\\n                break;\\n            }\\n        }\\n        \\n        // Special case: only even number of zero digits in the input.\\n        if (empty(front) && empty(center)) center = \"0\";\\n        \\n        // Stitch the result together.\\n        return front + center + string(crbegin(front), crend(front));\\n    }\\n```\n```O(n)```\n```size(num) / 2```\n```front```\n```O(n)```\n```front```\n```size(num) / 2```",
                "codeTag": "Unknown"
            },
            {
                "id": 2456584,
                "title": "priority-queue-map",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        unordered_map<int, int> m, cm;\\n        string ans = \"\";\\n          \\n        for(int i=0; i<num.size(); i++){\\n            int n = num[i] - \\'0\\';\\n            m[n]++;\\n        }\\n        \\n        priority_queue<int> epq, opq;\\n        int oddBig = -1;\\n        \\n\\t\\t// add freq and check the biggest odd number that can be placed in middle\\n        for(auto i:m){\\n            if(i.second%2 == 0) epq.push(i.first);\\n            else if(i.second > 1 && i.second%2 == 1) opq.push(i.first);\\n            if(i.second%2 == 1) oddBig = max(oddBig, i.first);\\n        }\\n        \\n\\t\\t// copy of map\\n        cm = m;\\n\\t\\t\\n\\t\\t// generating first half of palindrome\\n        while(epq.size() && opq.size()){\\n            int e = epq.top(), o = opq.top();\\n            if(e>o){\\n                ans += (e + \\'0\\');\\n                cm[e]--;\\n                if(m[e]/2 >= cm[e]) epq.pop();\\n            } else {\\n                ans += (o + \\'0\\');\\n                cm[o]--;\\n                if(m[o]/2+1 >= cm[o]) opq.pop();\\n            }\\n        }\\n        \\n        while(epq.size()){\\n            int e = epq.top();\\n            ans += (e + \\'0\\');\\n            cm[e]--;\\n            if(m[e]/2 >= cm[e]) epq.pop();\\n        }\\n        \\n        while(opq.size()){\\n            int o = opq.top();\\n            ans += (o + \\'0\\');\\n            cm[o]--;\\n            if(m[o]/2+1 >= cm[o]) opq.pop();\\n        }\\n\\n\\t\\t// Adding other half of palindrome\\n        string temp;\\n        for(int i=ans.size()-1; i>=0; i--){\\n            temp+=ans[i];\\n        }\\n        \\n\\t\\t// Check if some number can be added in middle\\n        if(oddBig == -1){\\n            ans+=temp;\\n        } else {\\n            ans += (oddBig+\\'0\\');\\n            ans+=temp;\\n        }\\n        \\n\\t\\t// Remove precedig 0\\n        int i=0;\\n        while(ans[i] == \\'0\\'){\\n            ans = ans.substr(i+1, ans.size()-2);\\n        }\\n\\t\\t\\n        // Handle for 0 if empty string -> \"0000\" after removing preceding 0\\'s\\n        if(ans.size() == 0 && m[0]>=1){\\n            ans += \\'0\\';\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        unordered_map<int, int> m, cm;\\n        string ans = \"\";\\n          \\n        for(int i=0; i<num.size(); i++){\\n            int n = num[i] - \\'0\\';\\n            m[n]++;\\n        }\\n        \\n        priority_queue<int> epq, opq;\\n        int oddBig = -1;\\n        \\n\\t\\t// add freq and check the biggest odd number that can be placed in middle\\n        for(auto i:m){\\n            if(i.second%2 == 0) epq.push(i.first);\\n            else if(i.second > 1 && i.second%2 == 1) opq.push(i.first);\\n            if(i.second%2 == 1) oddBig = max(oddBig, i.first);\\n        }\\n        \\n\\t\\t// copy of map\\n        cm = m;\\n\\t\\t\\n\\t\\t// generating first half of palindrome\\n        while(epq.size() && opq.size()){\\n            int e = epq.top(), o = opq.top();\\n            if(e>o){\\n                ans += (e + \\'0\\');\\n                cm[e]--;\\n                if(m[e]/2 >= cm[e]) epq.pop();\\n            } else {\\n                ans += (o + \\'0\\');\\n                cm[o]--;\\n                if(m[o]/2+1 >= cm[o]) opq.pop();\\n            }\\n        }\\n        \\n        while(epq.size()){\\n            int e = epq.top();\\n            ans += (e + \\'0\\');\\n            cm[e]--;\\n            if(m[e]/2 >= cm[e]) epq.pop();\\n        }\\n        \\n        while(opq.size()){\\n            int o = opq.top();\\n            ans += (o + \\'0\\');\\n            cm[o]--;\\n            if(m[o]/2+1 >= cm[o]) opq.pop();\\n        }\\n\\n\\t\\t// Adding other half of palindrome\\n        string temp;\\n        for(int i=ans.size()-1; i>=0; i--){\\n            temp+=ans[i];\\n        }\\n        \\n\\t\\t// Check if some number can be added in middle\\n        if(oddBig == -1){\\n            ans+=temp;\\n        } else {\\n            ans += (oddBig+\\'0\\');\\n            ans+=temp;\\n        }\\n        \\n\\t\\t// Remove precedig 0\\n        int i=0;\\n        while(ans[i] == \\'0\\'){\\n            ans = ans.substr(i+1, ans.size()-2);\\n        }\\n\\t\\t\\n        // Handle for 0 if empty string -> \"0000\" after removing preceding 0\\'s\\n        if(ans.size() == 0 && m[0]>=1){\\n            ans += \\'0\\';\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463339,
                "title": "c-100-greedy-hashing-o-n-time-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        // Create a hash table to count the freq of each digit\\n        vector<int> hash(10,0);\\n        \\n        for(auto i: num)\\n            hash[i-\\'0\\']++;\\n        // now we have to track the digits with even or odd freq\\n        // basically we are storing the digits with even(>0) and 1 frequency \\n        // as for eg. \\'1\\' has frequency of 5 it can be represented as 4 + 1\\n        // thus even vector gets (\\'1\\',4) and odd vector gets (\\'1\\',1)\\n        vector<pair<char,int>> even,odd;\\n        // traverse through the hash table and push the even and odd pairs in ascending order\\n        for(int i=0;i<10;i++)\\n        {\\n            // we dont need to keep track of those numbers that didnt occur\\n            if(hash[i]==0) continue;\\n            \\n            // if the freq is odd\\n            if(hash[i]%2) \\n            {\\n                // if the freq is not 1 that means it can be splitted as (freq-1) + 1\\n                // we did this as explained above if the freq is 5 it can be splitted into 4+1\\n                \\n                // we push the even freq into even vector\\n                if(hash[i]!=1) even.push_back({i,hash[i]-1});\\n                \\n                // and push the 1 into the odd\\n                odd.push_back({i,1});\\n            }\\n            // if the freq is even directly push it\\n            else even.push_back({i,hash[i]});\\n        }\\n        \\n        // initialize an empty string\\n        string ans=\"\";\\n        \\n        // first we have to pick an element for the center of the palindromic string\\n        // palindromic string can be 11211 so if there are any num with odd freq \\n        // we need to take the one with the highest value\\n        // for eg. in 444947137 the nums with odd freq are 1,3, and 9 \\n        // but we ll take the max element for the center of our palindrome\\n        if(odd.size()) ans =to_string(odd.back().first);\\n        \\n        // now we have to expand the string in both direction by adding the even freq digits\\n        // half of the freq of that digit will go to the left of the palindrome and half to the right\\n        \\n        // check if the only digit with even freq is \\'0\\' then if ans is empty return 0 else ans \\n        if(even.size()==1 && even.back().first==0) return ans!=\"\"?ans:\"0\";\\n        \\n        // we iterate over the even pairs and as the pairs were inserted in increasing order\\n        // always the smallest value will be inserted first \\n        // For eg. we have 444947137 , currently our ans is \\'9\\'\\n        // even vector is (\\'4\\',4),(\\'7\\',2)\\n        // first we insert half of \\'4\\' to the left and half to the right, new ans = \\'44\\'+\\'9\\'+\\'44\\'\\n        // then we insert half of \\'7\\' to the left and half to the right, new ans = \\'7\\'+\\'44944\\'+\\'7\\'\\n        for(auto [character,freq]: even)\\n        {\\n            ans = string(freq/2,character+\\'0\\') + ans + string(freq/2,character+\\'0\\');\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Without Comments**\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        \\n        vector<int> hash(10,0);\\n        for(auto i: num)\\n            hash[i-\\'0\\']++;\\n    \\n        vector<pair<char,int>> even,odd;\\n        for(int i=0;i<10;i++)\\n        {\\n            if(hash[i]==0) continue;\\n            \\n            if(hash[i]%2) \\n            {\\n                if(hash[i]!=1) even.push_back({i,hash[i]-1});\\n                odd.push_back({i,1});\\n            }\\n            else even.push_back({i,hash[i]});\\n        }\\n        string ans=\"\";\\n        if(odd.size()) ans =to_string(odd.back().first);\\n        if(even.size()==1 && even.back().first==0) return ans!=\"\"?ans:\"0\";\\n        for(auto [character,freq]: even)\\n            ans = string(freq/2,character+\\'0\\') + ans + string(freq/2,character+\\'0\\');\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        // Create a hash table to count the freq of each digit\\n        vector<int> hash(10,0);\\n        \\n        for(auto i: num)\\n            hash[i-\\'0\\']++;\\n        // now we have to track the digits with even or odd freq\\n        // basically we are storing the digits with even(>0) and 1 frequency \\n        // as for eg. \\'1\\' has frequency of 5 it can be represented as 4 + 1\\n        // thus even vector gets (\\'1\\',4) and odd vector gets (\\'1\\',1)\\n        vector<pair<char,int>> even,odd;\\n        // traverse through the hash table and push the even and odd pairs in ascending order\\n        for(int i=0;i<10;i++)\\n        {\\n            // we dont need to keep track of those numbers that didnt occur\\n            if(hash[i]==0) continue;\\n            \\n            // if the freq is odd\\n            if(hash[i]%2) \\n            {\\n                // if the freq is not 1 that means it can be splitted as (freq-1) + 1\\n                // we did this as explained above if the freq is 5 it can be splitted into 4+1\\n                \\n                // we push the even freq into even vector\\n                if(hash[i]!=1) even.push_back({i,hash[i]-1});\\n                \\n                // and push the 1 into the odd\\n                odd.push_back({i,1});\\n            }\\n            // if the freq is even directly push it\\n            else even.push_back({i,hash[i]});\\n        }\\n        \\n        // initialize an empty string\\n        string ans=\"\";\\n        \\n        // first we have to pick an element for the center of the palindromic string\\n        // palindromic string can be 11211 so if there are any num with odd freq \\n        // we need to take the one with the highest value\\n        // for eg. in 444947137 the nums with odd freq are 1,3, and 9 \\n        // but we ll take the max element for the center of our palindrome\\n        if(odd.size()) ans =to_string(odd.back().first);\\n        \\n        // now we have to expand the string in both direction by adding the even freq digits\\n        // half of the freq of that digit will go to the left of the palindrome and half to the right\\n        \\n        // check if the only digit with even freq is \\'0\\' then if ans is empty return 0 else ans \\n        if(even.size()==1 && even.back().first==0) return ans!=\"\"?ans:\"0\";\\n        \\n        // we iterate over the even pairs and as the pairs were inserted in increasing order\\n        // always the smallest value will be inserted first \\n        // For eg. we have 444947137 , currently our ans is \\'9\\'\\n        // even vector is (\\'4\\',4),(\\'7\\',2)\\n        // first we insert half of \\'4\\' to the left and half to the right, new ans = \\'44\\'+\\'9\\'+\\'44\\'\\n        // then we insert half of \\'7\\' to the left and half to the right, new ans = \\'7\\'+\\'44944\\'+\\'7\\'\\n        for(auto [character,freq]: even)\\n        {\\n            ans = string(freq/2,character+\\'0\\') + ans + string(freq/2,character+\\'0\\');\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        \\n        vector<int> hash(10,0);\\n        for(auto i: num)\\n            hash[i-\\'0\\']++;\\n    \\n        vector<pair<char,int>> even,odd;\\n        for(int i=0;i<10;i++)\\n        {\\n            if(hash[i]==0) continue;\\n            \\n            if(hash[i]%2) \\n            {\\n                if(hash[i]!=1) even.push_back({i,hash[i]-1});\\n                odd.push_back({i,1});\\n            }\\n            else even.push_back({i,hash[i]});\\n        }\\n        string ans=\"\";\\n        if(odd.size()) ans =to_string(odd.back().first);\\n        if(even.size()==1 && even.back().first==0) return ans!=\"\"?ans:\"0\";\\n        for(auto [character,freq]: even)\\n            ans = string(freq/2,character+\\'0\\') + ans + string(freq/2,character+\\'0\\');\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2463004,
                "title": "c-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string s)\\n    {\\n        vector<int> v(10);\\n        \\n        for(char c:s)\\n        {\\n            v[c-\\'0\\']++;\\n        }\\n        string ans;\\n        int single=-1;\\n        for(int i=9;i>=0;i--)\\n        {\\n            if(ans.length()==0 && i==0){\\n                continue;\\n            }\\n            while(v[i]>1)\\n            {\\n                ans.push_back(i+\\'0\\');\\n                v[i]-=2;\\n            }\\n            if(v[i]==1 && single==-1){\\n                \\n                single=i;\\n            }\\n        }\\n        string res=string(ans.rbegin(),ans.rend());\\n        if(ans.empty())\\n        {\\n            if(single==-1)return \"0\";\\n        }\\n        if(single!=-1){\\n            \\n        \\n            ans.push_back(single+\\'0\\');\\n        }\\n        ans+=res;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string s)\\n    {\\n        vector<int> v(10);\\n        \\n        for(char c:s)\\n        {\\n            v[c-\\'0\\']++;\\n        }\\n        string ans;\\n        int single=-1;\\n        for(int i=9;i>=0;i--)\\n        {\\n            if(ans.length()==0 && i==0){\\n                continue;\\n            }\\n            while(v[i]>1)\\n            {\\n                ans.push_back(i+\\'0\\');\\n                v[i]-=2;\\n            }\\n            if(v[i]==1 && single==-1){\\n                \\n                single=i;\\n            }\\n        }\\n        string res=string(ans.rbegin(),ans.rend());\\n        if(ans.empty())\\n        {\\n            if(single==-1)return \"0\";\\n        }\\n        if(single!=-1){\\n            \\n        \\n            ans.push_back(single+\\'0\\');\\n        }\\n        ans+=res;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456880,
                "title": "c-simple-long-and-well-explained-for-loop-only",
                "content": "\\n       \\n\\t   string largestPalindromic(string num) {\\n        vector<int>v(10,0);\\n        //create a vector to store count of occurances of each digit\\n        for(auto s:num){\\n            int val=s-\\'0\\';\\n            v[val]++;\\n        }\\n        //case where we return 0\\n        int flag=0;\\n        for(int i=1;i<=9;i++){\\n            if(v[i]>=1)\\n                flag=1;\\n        }\\n        if(!flag && v[0]>0){\\n            return \"0\";\\n        }\\n        //find the largest value which is single \\n        string res;\\n        string singleval;\\n        for(int i=0;i<=9;i++){\\n            if(v[i]%2==1)\\n                singleval=to_string(i);\\n        }\\n        \\n        //make the largest possible string\\n        for(int i=9;i>=0;i--){\\n            if(i==0 && res.empty())\\n                break;\\n            int times=v[i]/2;\\n            while(times){\\n                string curr=to_string(i);\\n                res+=curr;\\n                times--;\\n            }\\n        }\\n        string revres=res;\\n        reverse(res.begin(),res.end());\\n        return revres+singleval+res;\\n    }\\n};\\n",
                "solutionTags": [],
                "code": "\\n       \\n\\t   string largestPalindromic(string num) {\\n        vector<int>v(10,0);\\n        //create a vector to store count of occurances of each digit\\n        for(auto s:num){\\n            int val=s-\\'0\\';\\n            v[val]++;\\n        }\\n        //case where we return 0\\n        int flag=0;\\n        for(int i=1;i<=9;i++){\\n            if(v[i]>=1)\\n                flag=1;\\n        }\\n        if(!flag && v[0]>0){\\n            return \"0\";\\n        }\\n        //find the largest value which is single \\n        string res;\\n        string singleval;\\n        for(int i=0;i<=9;i++){\\n            if(v[i]%2==1)\\n                singleval=to_string(i);\\n        }\\n        \\n        //make the largest possible string\\n        for(int i=9;i>=0;i--){\\n            if(i==0 && res.empty())\\n                break;\\n            int times=v[i]/2;\\n            while(times){\\n                string curr=to_string(i);\\n                res+=curr;\\n                times--;\\n            }\\n        }\\n        string revres=res;\\n        reverse(res.begin(),res.end());\\n        return revres+singleval+res;\\n    }\\n};\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2456725,
                "title": "python-easy-approach-hashmap",
                "content": "```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n\\n        ans = []\\n        b = [str(x) for x in range(9, -1, -1)]\\n        from collections import defaultdict\\n\\n        a = defaultdict(int)\\n\\n        for x in num:\\n            a[x] += 1\\n\\n        for x in b:\\n            n = len(ans)\\n            if n % 2 == 0:\\n                if a[x] > 0:\\n                    ans = ans[:n // 2] + [x] * a[x] + ans[n // 2:]\\n            else:\\n                if x == \\'0\\':\\n                    if len(ans) != 1:\\n                        ans = ans[:n // 2] + [x] * (a[x] // 2) + [ans[n // 2]] + [x] * (a[x] // 2) + ans[n // 2 + 1:]\\n                else:\\n                    if a[x] >= 2:\\n                        ans = ans[:n // 2] + [x] * (a[x] // 2) + [ans[n // 2]] + [x] * (a[x] // 2) + ans[n // 2 + 1:]\\n\\n        res = \"\".join(ans)\\n        return str(int(res))\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n\\n        ans = []\\n        b = [str(x) for x in range(9, -1, -1)]\\n        from collections import defaultdict\\n\\n        a = defaultdict(int)\\n\\n        for x in num:\\n            a[x] += 1\\n\\n        for x in b:\\n            n = len(ans)\\n            if n % 2 == 0:\\n                if a[x] > 0:\\n                    ans = ans[:n // 2] + [x] * a[x] + ans[n // 2:]\\n            else:\\n                if x == \\'0\\':\\n                    if len(ans) != 1:\\n                        ans = ans[:n // 2] + [x] * (a[x] // 2) + [ans[n // 2]] + [x] * (a[x] // 2) + ans[n // 2 + 1:]\\n                else:\\n                    if a[x] >= 2:\\n                        ans = ans[:n // 2] + [x] * (a[x] // 2) + [ans[n // 2]] + [x] * (a[x] // 2) + ans[n // 2 + 1:]\\n\\n        res = \"\".join(ans)\\n        return str(int(res))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456625,
                "title": "python-counter-solution",
                "content": "```\\ndef largestPalindromic(self, num: str) -> str:\\n\\tif num == \\'0\\'*len(num):\\n\\t\\treturn \\'0\\'\\n\\tcnter = Counter(num)\\n\\thead = \\'\\'\\n\\tmid = \\'\\'\\n\\tfor k in \\'9876543210\\':\\n\\t\\tv = cnter[k]\\n\\t\\tif v%2:\\n\\t\\t\\tif not mid:\\n\\t\\t\\t\\tmid = k\\n\\t\\thead += k*(v//2)\\n\\tif head and head[0]==\\'0\\':\\n\\t\\thead = \\'\\'\\n\\treturn head+mid+head[::-1]\\n```",
                "solutionTags": [],
                "code": "```\\ndef largestPalindromic(self, num: str) -> str:\\n\\tif num == \\'0\\'*len(num):\\n\\t\\treturn \\'0\\'\\n\\tcnter = Counter(num)\\n\\thead = \\'\\'\\n\\tmid = \\'\\'\\n\\tfor k in \\'9876543210\\':\\n\\t\\tv = cnter[k]\\n\\t\\tif v%2:\\n\\t\\t\\tif not mid:\\n\\t\\t\\t\\tmid = k\\n\\t\\thead += k*(v//2)\\n\\tif head and head[0]==\\'0\\':\\n\\t\\thead = \\'\\'\\n\\treturn head+mid+head[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2793436,
                "title": "java-most-possible-solution",
                "content": "Time complexity : O(n)\\nSpace complexity : O(n)\\n```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int[] count = new int[10];\\n        int center = -1;\\n        StringBuilder first = new StringBuilder();\\n        StringBuilder second;\\n        for (char c : num.toCharArray()) {\\n            count[c - \\'0\\']++;\\n        }\\n        int c = 0;\\n        for (int i = 9; i >= 0; i--) {\\n            c = 0;\\n            if (count[i] % 2 == 1 && center == -1) {\\n                center = i;\\n            }\\n            if (first.length() == 0 && i == 0) {\\n                continue;\\n            }\\n            while (c < count[i] / 2) {\\n                first.append(String.valueOf(i));\\n                c++;\\n            }\\n        }\\n        second = new StringBuilder(first.toString());\\n        if (center != -1) {\\n            first.append(center);\\n        }\\n        first.append(second.reverse().toString());\\n        return first.length() == 0 ? \"0\" : first.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int[] count = new int[10];\\n        int center = -1;\\n        StringBuilder first = new StringBuilder();\\n        StringBuilder second;\\n        for (char c : num.toCharArray()) {\\n            count[c - \\'0\\']++;\\n        }\\n        int c = 0;\\n        for (int i = 9; i >= 0; i--) {\\n            c = 0;\\n            if (count[i] % 2 == 1 && center == -1) {\\n                center = i;\\n            }\\n            if (first.length() == 0 && i == 0) {\\n                continue;\\n            }\\n            while (c < count[i] / 2) {\\n                first.append(String.valueOf(i));\\n                c++;\\n            }\\n        }\\n        second = new StringBuilder(first.toString());\\n        if (center != -1) {\\n            first.append(center);\\n        }\\n        first.append(second.reverse().toString());\\n        return first.length() == 0 ? \"0\" : first.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611443,
                "title": "explained-by-comments-simple-and-easy-to-understand-c-solution",
                "content": "```\\nstring largestPalindromic(string num) {\\n        int mp[10] = {0};      // Creating Frequency array of size 10\\n\\t\\t\\n        for(char i:num){\\n            mp[i-\\'0\\']++;   \\n        }\\n\\t\\t\\n        int once = -1;  // variable for handling the case of single element(odd length palindrome)\\n\\t\\t\\n        string ans;\\n\\t\\t\\n        for(int i=9;i>=0;i--){                  // starting from end so that we get the maximum number \\n            if(i==0 and ans.empty()) break;\\n            while(mp[i]>1){                // adding the element once and later we would add the string\\'s reverse for completing the string \\n                ans += to_string(i);\\n                mp[i] -= 2;      // since we will add the reverse at last the freq will be reduced by 2\\n            }\\n            if(mp[i]==1 && once==-1) once = i;    // storing the single element if not already stored\\n        }\\n\\t\\t\\n        string a = ans;\\n        reverse(a.begin(),a.end());     // to add the reverse of the string to complete the second half\\n        if(once!=-1) ans += to_string(once);     // adding the single element \\n        ans += a;             // adding the reverse \\n        if(ans.empty()) ans = \"0\";       \\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nstring largestPalindromic(string num) {\\n        int mp[10] = {0};      // Creating Frequency array of size 10\\n\\t\\t\\n        for(char i:num){\\n            mp[i-\\'0\\']++;   \\n        }\\n\\t\\t\\n        int once = -1;  // variable for handling the case of single element(odd length palindrome)\\n\\t\\t\\n        string ans;\\n\\t\\t\\n        for(int i=9;i>=0;i--){                  // starting from end so that we get the maximum number \\n            if(i==0 and ans.empty()) break;\\n            while(mp[i]>1){                // adding the element once and later we would add the string\\'s reverse for completing the string \\n                ans += to_string(i);\\n                mp[i] -= 2;      // since we will add the reverse at last the freq will be reduced by 2\\n            }\\n            if(mp[i]==1 && once==-1) once = i;    // storing the single element if not already stored\\n        }\\n\\t\\t\\n        string a = ans;\\n        reverse(a.begin(),a.end());     // to add the reverse of the string to complete the second half\\n        if(once!=-1) ans += to_string(once);     // adding the single element \\n        ans += a;             // adding the reverse \\n        if(ans.empty()) ans = \"0\";       \\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2518633,
                "title": "python-elegant-short-counter",
                "content": "\\tdef largestPalindromic(self, num: str) -> str:\\n\\t\\tcount = Counter(num)\\n\\t\\tpalindrome = mid = \\'\\'\\n\\n\\t\\tfor d in sorted(count.keys(), reverse=True):\\n\\t\\t\\tmid = max(mid, d * (count[d] & 1))\\n\\t\\t\\tpalindrome += d * (count[d] // 2)\\n\\n\\t\\tpalindrome = palindrome.lstrip(\\'0\\')\\n\\t\\treturn (palindrome + mid + palindrome[::-1]) or \\'0\\'\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "\\tdef largestPalindromic(self, num: str) -> str:\\n\\t\\tcount = Counter(num)\\n\\t\\tpalindrome = mid = \\'\\'\\n\\n\\t\\tfor d in sorted(count.keys(), reverse=True):\\n\\t\\t\\tmid = max(mid, d * (count[d] & 1))\\n\\t\\t\\tpalindrome += d * (count[d] // 2)\\n\\n\\t\\tpalindrome = palindrome.lstrip(\\'0\\')\\n\\t\\treturn (palindrome + mid + palindrome[::-1]) or \\'0\\'\\n",
                "codeTag": "Python3"
            },
            {
                "id": 2458723,
                "title": "c-solution-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int> cnt(10,0);\\n        \\n        for(char ch: num)\\n            cnt[ch-\\'0\\']++;\\n        \\n        string ans, ans2;\\n        \\n        for(int i=9;i>=0;--i){\\n            if(i==0 and ans.empty())\\n                break;\\n            int t=cnt[i]/2;\\n            for(int j=0;j<t;++j)\\n                ans.push_back(i+\\'0\\');\\n            cnt[i] -= 2*t;\\n        }\\n        \\n        ans2=ans;\\n        reverse(ans2.begin(), ans2.end());\\n        \\n        for(int i=9;i>=0;--i){\\n            if(cnt[i]){\\n                ans.push_back(i+\\'0\\');\\n                break;\\n            }\\n        }\\n        \\n        return ans+ans2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int> cnt(10,0);\\n        \\n        for(char ch: num)\\n            cnt[ch-\\'0\\']++;\\n        \\n        string ans, ans2;\\n        \\n        for(int i=9;i>=0;--i){\\n            if(i==0 and ans.empty())\\n                break;\\n            int t=cnt[i]/2;\\n            for(int j=0;j<t;++j)\\n                ans.push_back(i+\\'0\\');\\n            cnt[i] -= 2*t;\\n        }\\n        \\n        ans2=ans;\\n        reverse(ans2.begin(), ans2.end());\\n        \\n        for(int i=9;i>=0;--i){\\n            if(cnt[i]){\\n                ans.push_back(i+\\'0\\');\\n                break;\\n            }\\n        }\\n        \\n        return ans+ans2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457554,
                "title": "easy-c-solution-o-n-with-explanation",
                "content": "Variable Description and Usage:\\n1. ***occ*** = occurences of each digit from 0 to 9\\n2. ***z*** = first half of the palindromic string, it then becomes the 2nd half\\n3. ***x*** = new first half of the palindromic string\\n4. ***maxu*** = taking one max integer that can be in the middle of the palindromic string\\n \\nApproach :\\nSo the crux is that thw palindromic string will be greatest when we start with big digits and go in a decreasing order to the middle. The middle element has to be the highest one possible (I\\'ve stored it here in maxu). If there is no maxu, and there is a non used \\'0\\', we can put it in the middle of the palindromic string. This will increase the size of the string and hence the number.\\n\\nCode : )\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        int occ[10]={0};\\n        int n=num.size();\\n        for(int i=0;i<n;i++)\\n            occ[num[i]-\\'0\\']++;\\n\\n        string z=\"\";\\n        int maxu=INT_MIN;\\n        for(int i=9;i>=1;i--){\\n            if(occ[i]%2==1){\\n                maxu=max(maxu,i);\\n                occ[i]--;\\n            }\\n            if(occ[i]%2==0 && occ[i]>1){\\n                for(int j=1;j<=occ[i]/2;j++)\\n                    z+=to_string(i);\\n                occ[i]=0;\\n            }\\n        }\\n        if(z!=\"\"){\\n            if(occ[0]>1)\\n                for(int j=1;j<=occ[0]/2;j++)\\n                    z+=\\'0\\';\\n        }\\n        string x=z;\\n        reverse(z.begin(),z.end());\\n        if(maxu!=INT_MIN)\\n            x+=to_string(maxu);\\n        else if(occ[0]%2==1)\\n            x+=\\'0\\';\\n        x+=z;\\n        if(num!=\"\" && x==\"\")\\n            return \"0\";\\n        return x;\\n    }\\n};\\n```\\nExtra : )\\n* Save no. of occurances of each digit \\n* Define a max for the middle of the palindrome\\n* Loop over the digits in a decreasing order\\n* Append even no. of occurances of a digit to our string z \\n* Any digit who is greatest and has odd occ will be the maxu\\n* Copy z in x\\n* Reverse z\\n* Add maxu to x\\n* Add z to x\\n* For a string like \"000000\" just return 0\\n* Return x",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        int occ[10]={0};\\n        int n=num.size();\\n        for(int i=0;i<n;i++)\\n            occ[num[i]-\\'0\\']++;\\n\\n        string z=\"\";\\n        int maxu=INT_MIN;\\n        for(int i=9;i>=1;i--){\\n            if(occ[i]%2==1){\\n                maxu=max(maxu,i);\\n                occ[i]--;\\n            }\\n            if(occ[i]%2==0 && occ[i]>1){\\n                for(int j=1;j<=occ[i]/2;j++)\\n                    z+=to_string(i);\\n                occ[i]=0;\\n            }\\n        }\\n        if(z!=\"\"){\\n            if(occ[0]>1)\\n                for(int j=1;j<=occ[0]/2;j++)\\n                    z+=\\'0\\';\\n        }\\n        string x=z;\\n        reverse(z.begin(),z.end());\\n        if(maxu!=INT_MIN)\\n            x+=to_string(maxu);\\n        else if(occ[0]%2==1)\\n            x+=\\'0\\';\\n        x+=z;\\n        if(num!=\"\" && x==\"\")\\n            return \"0\";\\n        return x;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457320,
                "title": "java-simple-hash-table-and-greedy-solution-with-explanation-o-n",
                "content": "**Algorithm**\\n1. Count the occurrences of each digit. \\n2. Build the `first half part` of the palindrome by appending the digits from 9 to 0 with occurrences more than once. And subtract the occurrences of the digits used to build the palindrome on both sides. To avoid having leading zeros, we do not append `0`  if no digits were added to `first half part` so far. \\n3. Find the `middle digit` of the palindrome from the digits from 9 to 0 that still have remaining occurrences. Note if all the digits are 0, `first half part` is empty and `middle digit` is `0`.\\n4. Build the palindrome by concatenating: `first half part + middle digit + reversed first half part`\\n\\n\\n\\n**Java Code**\\n\\n```java\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        // find the occurrences of each digit\\n        int[] count = new int[10];\\n        for (char digit: num.toCharArray()) {\\n            ++count[digit - \\'0\\'];\\n        }\\n        \\n        // build the mirrored part of the palindrome\\n        StringBuilder mirror = new StringBuilder();\\n        for (int digit = 9; digit >= 0; --digit) {\\n            if (count[digit] > 1) {\\n                // avoid leading zeros\\n                if (digit == 0 && mirror.length() == 0) {\\n                    continue;\\n                }\\n                // append half of the occurrences to mirror\\n                for (int i = 0; i < count[digit] / 2; ++i) {\\n                    mirror.append(digit);\\n                }\\n                // subtract the occurrences used on both sides\\n                count[digit] %= 2;\\n            }\\n        }\\n        \\n        // find the middle digit\\n        String mid = \"\";\\n        for (int digit = 9; digit >= 0; --digit) {\\n            if (count[digit] > 0) {\\n                mid += digit;\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// build the palindrome and return it\\n        StringBuilder ret = new StringBuilder();\\n        ret.append(mirror);\\n        ret.append(mid);\\n        ret.append(mirror.reverse());\\n        return ret.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```java\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        // find the occurrences of each digit\\n        int[] count = new int[10];\\n        for (char digit: num.toCharArray()) {\\n            ++count[digit - \\'0\\'];\\n        }\\n        \\n        // build the mirrored part of the palindrome\\n        StringBuilder mirror = new StringBuilder();\\n        for (int digit = 9; digit >= 0; --digit) {\\n            if (count[digit] > 1) {\\n                // avoid leading zeros\\n                if (digit == 0 && mirror.length() == 0) {\\n                    continue;\\n                }\\n                // append half of the occurrences to mirror\\n                for (int i = 0; i < count[digit] / 2; ++i) {\\n                    mirror.append(digit);\\n                }\\n                // subtract the occurrences used on both sides\\n                count[digit] %= 2;\\n            }\\n        }\\n        \\n        // find the middle digit\\n        String mid = \"\";\\n        for (int digit = 9; digit >= 0; --digit) {\\n            if (count[digit] > 0) {\\n                mid += digit;\\n                break;\\n            }\\n        }\\n        \\n\\t\\t// build the palindrome and return it\\n        StringBuilder ret = new StringBuilder();\\n        ret.append(mirror);\\n        ret.append(mid);\\n        ret.append(mirror.reverse());\\n        return ret.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456836,
                "title": "python-hashmap-solution-o-n",
                "content": "The goal is to create the largest polindrome possible.\\n\\nWe can reorder the string, this makes to process easier.\\n\\nIf we have some character repeating, we take `div 2` repetitions, because we can place them in the beginning and the end.\\n\\nFor example: \\'22222\\', we know we can take `22xxxx22` (5 // 2 => 2) in each side.\\n\\nWe also can greedily take 1 odd character in a palindrome, for example: `99799`. We would want to take the biggest one, because we are looking for the maximal palindrome.\\n\\nTo do the steps mentioned above, we will have a frequency counter sorted by the numbers. That way we append the biggest numbers first (and also find the biggest odd number first)\\n\\nNote: some edge cases regarding the \\'0\\' input\\n\\n```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        c = Counter(num)\\n        pal_left = deque()\\n        pal_right = deque()\\n        odd = \"\"\\n        \\n        \\n        for c, freq in sorted(c.items(), key=lambda x: -int(x[0])):\\n            if odd == \"\" and freq % 2 != 0:\\n                odd = c\\n                \\n            even = freq // 2\\n            if c != \\'0\\' or (c == \\'0\\' and len(pal_right) > 0):\\n                for i in range(even):\\n                    pal_right.appendleft(c)\\n                    pal_left.append(c)\\n                \\n        \\n        if len(pal_left) == 0 and not odd:\\n            return \"0\"\\n        \\n       return \"\".join([*pal_left, odd, *pal_right])\\n            \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        c = Counter(num)\\n        pal_left = deque()\\n        pal_right = deque()\\n        odd = \"\"\\n        \\n        \\n        for c, freq in sorted(c.items(), key=lambda x: -int(x[0])):\\n            if odd == \"\" and freq % 2 != 0:\\n                odd = c\\n                \\n            even = freq // 2\\n            if c != \\'0\\' or (c == \\'0\\' and len(pal_right) > 0):\\n                for i in range(even):\\n                    pal_right.appendleft(c)\\n                    pal_left.append(c)\\n                \\n        \\n        if len(pal_left) == 0 and not odd:\\n            return \"0\"\\n        \\n       return \"\".join([*pal_left, odd, *pal_right])\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456740,
                "title": "python3-freq-table",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b7391a11acc4e9dbe563ebef84f8d78f7943a0f7) for solutions of weekly 307. \\n\\n**Intuition**\\nBreak the answer into two parts middle and half as `half[::-1] + mid + half`\\n* Middle is the largest character with odd occurrence; \\n* Half is constructed from small to large characters. \\n\\n**Analysis**\\nTime complexity O(N) ? \\nSpace complexity O(N)\\n\\n```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        freq = Counter(num)\\n        mid = next((ch for ch in \"9876543210\" if freq[ch]&1), \\'\\')\\n        half = \\'\\'.join(ch*(freq[ch]//2) for ch in \"0123456789\")\\n        return (half[::-1] + mid + half).strip(\\'0\\') or \\'0\\'\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        freq = Counter(num)\\n        mid = next((ch for ch in \"9876543210\" if freq[ch]&1), \\'\\')\\n        half = \\'\\'.join(ch*(freq[ch]//2) for ch in \"0123456789\")\\n        return (half[::-1] + mid + half).strip(\\'0\\') or \\'0\\'\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3814318,
                "title": "beats-90-solution-of-cpp",
                "content": "# **Pls Upvote If you liked the Solution !**\\n\\n# Approach\\nApproach is written in the code in the form of comments just go through them and you will understand the logic....\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(1)\\n\\n# **Pls Upvote if it Helps you !**\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        // creating freq of vector of size 10 as maximum size of number will be (0-9)\\n        vector<int>freq(10);\\n\\n        for(auto &i : num){\\n            freq[i-\\'0\\']++;\\n        }\\n\\n        // strings to store the palindrome answers \\n        string front = \"\";\\n        string back = \"\";\\n\\n        for(int i = 9; i>=0; i--){\\n            // if front and back string is empty and we add zero to it, it will have leading zeros\\n                // which we don\\'t want in our answer\\n            if(i == 0 && front.empty()){\\n                continue;\\n            }\\n\\n            while(freq[i] > 1){\\n                front += to_string(i);\\n                back += to_string(i);\\n                freq[i]= freq[i] - 2;\\n            }\\n        }\\n\\n        // We can also have a no whose freq is 1 in our answer and that no should be as large \\n        // as possible as the question demanding the largest palindrome no therefore\\n        for(int i = 9; i>=0; i--){\\n            if(freq[i] >= 1){\\n                front += to_string(i);\\n                break;\\n            }\\n        }\\n\\n        reverse(back.begin(), back.end());\\n\\n        return front + back;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        // creating freq of vector of size 10 as maximum size of number will be (0-9)\\n        vector<int>freq(10);\\n\\n        for(auto &i : num){\\n            freq[i-\\'0\\']++;\\n        }\\n\\n        // strings to store the palindrome answers \\n        string front = \"\";\\n        string back = \"\";\\n\\n        for(int i = 9; i>=0; i--){\\n            // if front and back string is empty and we add zero to it, it will have leading zeros\\n                // which we don\\'t want in our answer\\n            if(i == 0 && front.empty()){\\n                continue;\\n            }\\n\\n            while(freq[i] > 1){\\n                front += to_string(i);\\n                back += to_string(i);\\n                freq[i]= freq[i] - 2;\\n            }\\n        }\\n\\n        // We can also have a no whose freq is 1 in our answer and that no should be as large \\n        // as possible as the question demanding the largest palindrome no therefore\\n        for(int i = 9; i>=0; i--){\\n            if(freq[i] >= 1){\\n                front += to_string(i);\\n                break;\\n            }\\n        }\\n\\n        reverse(back.begin(), back.end());\\n\\n        return front + back;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499571,
                "title": "c-freq-array-greedy-solution",
                "content": "* Keep the palindrome in two strings.\\n* `a` stores the first half and `b` stores the other half.\\n\\n* Keep adding larger numbers first alternately in first and second half.\\n\\n* In the end check to see if there is possible room for addition for one more character(ODD Palindrome).\\n\\n```\\nclass Solution {\\npublic:\\n    string a = \"\" , b = \"\" ;\\n    string largestPalindromic(string nums) {\\n        int f[10] = {} ;\\n        for(auto &x : nums) ++f[x-\\'0\\'] ;\\n        \\n        for(int i = 9 ; i >= 0 ; --i){\\n            if(!i and (a.empty() || b.empty())) continue ;\\n            while(f[i] > 1){\\n                a.push_back(i + \\'0\\') , b.push_back(i + \\'0\\') ;\\n                f[i] -= 2 ;\\n            }\\n        }\\n        \\n        //check once more to insert the largest number in the middle of number\\n        for(int i = 9 ; i >= 0 ; --i){\\n            if(f[i]){\\n                a.push_back(i + \\'0\\') ;\\n                break ;\\n            }\\n        }\\n        \\n        reverse(begin(b),end(b)) ;\\n        return a + b ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string a = \"\" , b = \"\" ;\\n    string largestPalindromic(string nums) {\\n        int f[10] = {} ;\\n        for(auto &x : nums) ++f[x-\\'0\\'] ;\\n        \\n        for(int i = 9 ; i >= 0 ; --i){\\n            if(!i and (a.empty() || b.empty())) continue ;\\n            while(f[i] > 1){\\n                a.push_back(i + \\'0\\') , b.push_back(i + \\'0\\') ;\\n                f[i] -= 2 ;\\n            }\\n        }\\n        \\n        //check once more to insert the largest number in the middle of number\\n        for(int i = 9 ; i >= 0 ; --i){\\n            if(f[i]){\\n                a.push_back(i + \\'0\\') ;\\n                break ;\\n            }\\n        }\\n        \\n        reverse(begin(b),end(b)) ;\\n        return a + b ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2477830,
                "title": "c-100-faster-easy-to-understand-with-simple-intuitive-explaination",
                "content": "![image](https://assets.leetcode.com/users/images/6a108694-582d-4097-8f78-d503e8534327_1661421544.0533235.png)\\n\\n**Explaination :**\\n\\nLet\\'s understand this question in an intuitive manner. For solving this question, let us note some points from question itself:\\n\\nPalindromic Number:  In a palindromic number, content from mid to end is the mirror image of the content from starting to mid.\\nExample: XYZZYX , here element from index 3 to index 5 is mirror image of element from 0 to 2 so, we can say that it is a palindromic number.\\n\\n*  Point 1 : In even size palindromic number , frequency of every digit is even. In odd size number, frequency of every digit is even except middle.\\n\\n*  Point 2:   For largest number, number should start with largest available digit.\\n*  Point 3:  If we are able to create first half of the palindrome like XYZ then we can add it\\'s mirror image to complete the palindrome like XYZ ZYX.\\n\\n Using these points, we will solve this problem.\\n \\nStep 1:  Save the frequency of digit in given string.\\nstep 2:  second, we are creating first half of the palindrome , by adding the largest digit first whose frequency is more than 1 and can be used even times.\\nstep 3:  we are also saving largest digit whose frequency is odd, so that we can add it in the middle of palindrome.\\nstep 4: If only zeroes are present then return single zero in the result.\\n\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int>hash(10);     // hash for storing frequency\\n        int size{};\\n        char ch = \\'#\\';\\n        string res=\"\";\\n        for(auto i:num) hash[i-\\'0\\']++;   // increasing frequencies of digits.(step1)\\n     \\n        for(char i = \\'9\\'; i >= \\'0\\'; i--){      // traversing the digit from largest to smallest. (step2)\\n\\t\\t\\n\\t\\t// hash[i-\\'0\\']&1 check whether value is odd or not\\n            if(hash[i-\\'0\\']&1 && ch == \\'#\\') ch = i;   //  storing the largest odd digit in ch . (step3)\\n\\t\\t\\t\\n\\t\\t\\t// if there is no digit is present more than 0 zero and only zeroes digit is present\\n\\t\\t\\t// in num then there is no meaning to add multiple zeroes in result.\\n            if(i == \\'0\\' && res.size() == 0) continue; \\n\\t\\t\\t\\n\\t\\t\\t// adding only half frequency of digit \\n            size = hash[i-\\'0\\']/2;\\n            while(size--) res.push_back(i);\\n        }\\n        \\n        size = res.size()-1;\\n        if(ch != \\'#\\') res.push_back(ch);      // adding the odd character\\n        for(int i = size; i >=0; i--) res.push_back(res[i]);  // adding the mirror image of first half of palindrome\\n        if(res.size() == 0) return \"0\"; // if digit is forming valid palindrome or only zeroes was present in the string then return single zero.\\n        return res;\\n    }\\n};\\n```\\n**Time complexity : O(N)\\nSpace complexity : O(1)**\\n\\n",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int>hash(10);     // hash for storing frequency\\n        int size{};\\n        char ch = \\'#\\';\\n        string res=\"\";\\n        for(auto i:num) hash[i-\\'0\\']++;   // increasing frequencies of digits.(step1)\\n     \\n        for(char i = \\'9\\'; i >= \\'0\\'; i--){      // traversing the digit from largest to smallest. (step2)\\n\\t\\t\\n\\t\\t// hash[i-\\'0\\']&1 check whether value is odd or not\\n            if(hash[i-\\'0\\']&1 && ch == \\'#\\') ch = i;   //  storing the largest odd digit in ch . (step3)\\n\\t\\t\\t\\n\\t\\t\\t// if there is no digit is present more than 0 zero and only zeroes digit is present\\n\\t\\t\\t// in num then there is no meaning to add multiple zeroes in result.\\n            if(i == \\'0\\' && res.size() == 0) continue; \\n\\t\\t\\t\\n\\t\\t\\t// adding only half frequency of digit \\n            size = hash[i-\\'0\\']/2;\\n            while(size--) res.push_back(i);\\n        }\\n        \\n        size = res.size()-1;\\n        if(ch != \\'#\\') res.push_back(ch);      // adding the odd character\\n        for(int i = size; i >=0; i--) res.push_back(res[i]);  // adding the mirror image of first half of palindrome\\n        if(res.size() == 0) return \"0\"; // if digit is forming valid palindrome or only zeroes was present in the string then return single zero.\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2466403,
                "title": "leetcode-the-hard-way-counting-and-building-string-with-explanation",
                "content": "Please check out [LeetCode The Hard Way](https://wingkwong.github.io/leetcode-the-hard-way/) for more solution explanations and tutorials. If you like it, please give a star and watch my [Github Repository](https://github.com/wingkwong/leetcode-the-hard-way).\\n\\n---\\n\\n```cpp\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        string l, m, r;\\n        // count the frequency for each digit\\n        int cnt[10] = {0};\\n        for (auto &x : num) cnt[x - \\'0\\']++;\\n        // build the left part\\n        for (int i = 9; i >= 1; i--) {\\n            // we need at least a frequency of 2\\n            if (cnt[i] >= 2) {\\n                // we take half of it because it is only the left part\\n                l += string(cnt[i] / 2, i + \\'0\\');\\n            }\\n        }\\n        // we can put some zeros as well for cases like 0099 -> 9009\\n        if (cnt[0] >= 2) {\\n            // however, we only do it when we\\'ve used some digits \\n            // think of cases like 9\\n            if (l.size()) {\\n                l += string(cnt[0] / 2, \\'0\\');    \\n            }\\n        }\\n        // build the middle part\\n        for (int i = 9; i >= 0; i--) {\\n            // we want to add the largest digit with odd count\\n            if (cnt[i] & 1) {\\n                m += i + \\'0\\';\\n                // since we just need one, we can break here\\n                break;\\n            }\\n        }\\n        // handle case like 0000000\\n        if (l.size() == 0 && m.size() == 0) {\\n            return \"0\";\\n        }\\n        // build the right part\\n        r = l;\\n        // which is the mirror of the left part\\n        reverse(r.begin(), r.end());\\n        // return the final string\\n        return l + m + r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        string l, m, r;\\n        // count the frequency for each digit\\n        int cnt[10] = {0};\\n        for (auto &x : num) cnt[x - \\'0\\']++;\\n        // build the left part\\n        for (int i = 9; i >= 1; i--) {\\n            // we need at least a frequency of 2\\n            if (cnt[i] >= 2) {\\n                // we take half of it because it is only the left part\\n                l += string(cnt[i] / 2, i + \\'0\\');\\n            }\\n        }\\n        // we can put some zeros as well for cases like 0099 -> 9009\\n        if (cnt[0] >= 2) {\\n            // however, we only do it when we\\'ve used some digits \\n            // think of cases like 9\\n            if (l.size()) {\\n                l += string(cnt[0] / 2, \\'0\\');    \\n            }\\n        }\\n        // build the middle part\\n        for (int i = 9; i >= 0; i--) {\\n            // we want to add the largest digit with odd count\\n            if (cnt[i] & 1) {\\n                m += i + \\'0\\';\\n                // since we just need one, we can break here\\n                break;\\n            }\\n        }\\n        // handle case like 0000000\\n        if (l.size() == 0 && m.size() == 0) {\\n            return \"0\";\\n        }\\n        // build the right part\\n        r = l;\\n        // which is the mirror of the left part\\n        reverse(r.begin(), r.end());\\n        // return the final string\\n        return l + m + r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462796,
                "title": "java-solution-using-array-easiest",
                "content": "Faster than 100% \\n\\n```\\n\\nclass Solution {\\n    public String reverse(String s){\\n        String rev = \"\";\\n        for(int i = 0; i<s.length();i++){\\n            rev = s.charAt(i) + rev ;\\n        }\\n        return rev;\\n    }\\n    \\n    public String largestPalindromic(String num) {\\n        int[] arr = new int[10];\\n        \\n        for(int i = 0; i<num.length() ;i++){\\n            int n = num.charAt(i) - \\'0\\';\\n            arr[n] += 1;\\n        }\\n        \\n        String ans = \"\";\\n        for(int i = 9; i>0 ; i--){\\n\\n            while (arr[i] > 1){\\n                ans += Integer.toString(i);                        \\n\\n                arr[i]-=2;\\n            }\\n\\n        }\\n        while(arr[0] > 1 && ans != \"\"){\\n            ans += \\'0\\';\\n            arr[0]-=2;\\n        }\\n        String rev = reverse(ans);\\n\\n        for(int i = 9;i>=0;i--){\\n            if(arr[i] == 1){\\n                ans += Integer.toString(i);\\n                break;\\n            }\\n        }\\n        \\n        ans += rev;\\n        return (ans.length() == 0) ? \"0\" : ans;\\n        \\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\n\\nclass Solution {\\n    public String reverse(String s){\\n        String rev = \"\";\\n        for(int i = 0; i<s.length();i++){\\n            rev = s.charAt(i) + rev ;\\n        }\\n        return rev;\\n    }\\n    \\n    public String largestPalindromic(String num) {\\n        int[] arr = new int[10];\\n        \\n        for(int i = 0; i<num.length() ;i++){\\n            int n = num.charAt(i) - \\'0\\';\\n            arr[n] += 1;\\n        }\\n        \\n        String ans = \"\";\\n        for(int i = 9; i>0 ; i--){\\n\\n            while (arr[i] > 1){\\n                ans += Integer.toString(i);                        \\n\\n                arr[i]-=2;\\n            }\\n\\n        }\\n        while(arr[0] > 1 && ans != \"\"){\\n            ans += \\'0\\';\\n            arr[0]-=2;\\n        }\\n        String rev = reverse(ans);\\n\\n        for(int i = 9;i>=0;i--){\\n            if(arr[i] == 1){\\n                ans += Integer.toString(i);\\n                break;\\n            }\\n        }\\n        \\n        ans += rev;\\n        return (ans.length() == 0) ? \"0\" : ans;\\n        \\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459012,
                "title": "cpp-map-o-n-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string s) {\\n        map<char, int> mp;\\n        for(int i=0; i<s.length(); i++){// putting characters and their frequency in map\\n            mp[s[i]]++;\\n        }\\n        string ans;// final ans string\\n        map<char, int>::reverse_iterator it;\\n        //now in i am iterating from last, as map contains key in ascending order\\n        for (it = mp.rbegin(); it != mp.rend(); it++){ \\n            if((*it).second>1 && (*it).second%2==0){\\n                // if curr char has even freq > 1\\n                // then i am adding those characters in middle                                 \\n                ans.insert(ans.length()/2, (*it).second, (*it).first);\\n                mp[(*it).first] = 0;// setting their freq to 0 as they are used\\n            }\\n            else if((*it).second>1 && (*it).second%2==1){\\n                // if curr char has odd freq > 1\\n                // then i am adding those characters in middle - only taking even freq \\n                ans.insert(ans.length()/2, (*it).second-1, (*it).first);\\n                mp[(*it).first] = 1;// setting their freq to 1 (remaining freq)\\n            }\\n        }\\n        // now only the characters with 1 freq left in the map\\n        for (it = mp.rbegin(); it != mp.rend(); it++){\\n            // here to maximize the no. i am taking the recent char from back whose freq is 1\\n            if((*it).second == 1){\\n                ans.insert(ans.length()/2, 1, (*it).first);\\n                break;\\n            }\\n        }\\n        ans.erase(0, ans.find_first_not_of(\\'0\\'));// removing the leading 0\\n        if(ans.length()==0) return \"0\";// if s = \"0000\"\\n        //also deleting the ending zeroes as they never made palindrome\\n        //ex : 090 = 9 : 900 is not a palindrome\\n        for(int i=ans.length()-1; i>=0; i--){\\n            if(ans[i]!=\\'0\\'){\\n                return ans.substr(0 , i+1);\\n            }\\n        }\\n    return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string largestPalindromic(string s) {\\n        map<char, int> mp;\\n        for(int i=0; i<s.length(); i++){// putting characters and their frequency in map\\n            mp[s[i]]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2458661,
                "title": "c-easy-to-understand-count-left-partition-and-right-partition",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n         vector<int> count(10);\\n        for (char c: num) {\\n            count[c - \\'0\\']++;\\n        }\\n        \\n        string lp, rp; // left and right partition\\n        \\n            for (int j = 9; j >= 0; j--)  {\\n                int t= count[j]/2;\\n                for (int i=0; i<t; i++)\\n                {\\n                if (count[j] > 1 && (j > 0 || lp.size())) {\\n                    lp += \\'0\\' + j;\\n                    rp += \\'0\\' + j;\\n                    count[j] -= 2;\\n                }\\n                }\\n            }\\n        for (int i = 9; i >= 0; i--) {\\n            if (count[i]) {\\n                lp += \\'0\\' + i; break;\\n            }\\n        }\\n        reverse(begin(rp), end(rp));\\n        return lp + rp;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n         vector<int> count(10);\\n        for (char c: num) {\\n            count[c - \\'0\\']++;\\n        }\\n        \\n        string lp, rp; // left and right partition\\n        \\n            for (int j = 9; j >= 0; j--)  {\\n                int t= count[j]/2;\\n                for (int i=0; i<t; i++)\\n                {\\n                if (count[j] > 1 && (j > 0 || lp.size())) {\\n                    lp += \\'0\\' + j;\\n                    rp += \\'0\\' + j;\\n                    count[j] -= 2;\\n                }\\n                }\\n            }\\n        for (int i = 9; i >= 0; i--) {\\n            if (count[i]) {\\n                lp += \\'0\\' + i; break;\\n            }\\n        }\\n        reverse(begin(rp), end(rp));\\n        return lp + rp;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457723,
                "title": "100-faster-java-ac-with-detail-explanation-priority-queue",
                "content": "\\n**Intuition:-**\\n\\n->We can  form the largest palindrome by keeping the largest odd number in the middle of the palindrome.\\n->Then append the even frequency numbers to both sides of the middle number\\n->The even frequency numbers should be appended in a way in which the smallest numbers can be kept inward and the largest numbers outwards \\n\\n**Approach :-**\\n\\n1. Keep the count of the characters in a map\\n\\n\\n2. iterate through each entry of the map and \\n       check 3 conditions \\n\\t   \\n\\t   -> if frequency is 1 i.e odd then keep track of the max Character to be appended in the middle of the palindrome\\n\\t   -> If frequency is even , then arrange them in the priorityq queue in such a way that while appending the numbers to both sides of mid , we can append the smaller numbers towards the mid and the larger numbers away from mid.\\n\\t   -> If frequency is Odd but not 1 ,then there might be a possibility that even count of numbers can be picked from the total available frequency of that particular number ,\\n\\t   so we keep on checking if 1 quantity of this number can be placed in the middle by comparing it\\'s  value with previous mid value and keep the larger one among them.\\n\\t   \\n3.Lastly we Iterate the Priority Queue and for every of pair of number we append one to the front side of the String and one to the back side of the String in order such that we get the largest Palindrome number.\\n\\n**Corner Case :-**\\nWe could encounter test cases such as \"00009\" which would give us the output \"00900\"\\n\\nNow \"00900\" is not a valid number , so we have to remove the leading \"zeros\" , also we have to remove the same number of \"zeros\" from the back too , so that we get a correct Palindrome.\\n\\n**Time Complexity :-**\\nnlogn\\n\\n\\n\\n\\t \\n\\t \\n\\t   class Solution {\\n      public String largestPalindromic(String num) {\\n        \\n        Map<Character,Integer>map  = new HashMap();\\n        for(char c: num.toCharArray()){\\n            \\n            map.put(c,map.getOrDefault(c,0)+1);\\n            \\n        }\\n        PriorityQueue<Map.Entry<Character,Integer>> even = new PriorityQueue<>((a,b)->{\\n            // if(a.getValue()==b.getValue()){\\n            //     return b.getKey()-a.getKey();\\n            // }\\n            // return a.getValue()-b.getValue();\\n            \\n            return b.getKey()-a.getKey();\\n        });\\n        PriorityQueue<Integer> single = new PriorityQueue<>((a,b)->b-a);\\n       \\n        map.entrySet().forEach(e->{\\n            if(e.getValue() == 1)\\n                single.offer(e.getKey()-\\'0\\');\\n            else if(e.getValue()%2==0)\\n            {\\n                even.offer(e);\\n            } \\n            else if(e.getValue()%2==1 && e.getValue()>1){\\n                Map.Entry<Character,Integer> entry = Map.entry(e.getKey(),e.getValue()-1);\\n                even.offer(entry);\\n                single.offer(e.getKey()-\\'0\\'); \\n            }\\n        });\\n        \\n        // \"00001105\" \\n        //\\'0\\' -> 5\\n        //\\'1\\' -> 2\\n        //\\'5\\' -> 1\\n        String mid = \"\";\\n        if(single.size()>0)\\n          mid = Character.toString((char)(single.poll() + \\'0\\'));\\n        \\n        StringBuilder sb = new StringBuilder();\\n        while(even.size()>0){\\n            \\n            int freq = even.peek().getValue();\\n            char ch = even.poll().getKey();\\n            freq = freq/2;\\n            int temp = freq;\\n            while(temp-->0)\\n            {\\n                sb.append(ch);\\n            }\\n        }\\n        String ans = sb.toString() + mid + new StringBuilder(sb).reverse().toString();\\n        \\n        \\n        if(ans.charAt(0)==\\'0\\'){\\n\\t\\t\\n             String strPattern = \"^0+(?!$)\";\\n             ans = ans.replaceAll(strPattern, \"\");\\n             StringBuilder nb=new StringBuilder(ans);  \\n             nb.reverse();  \\n             ans = nb.toString(); \\n             ans = ans.replaceAll(strPattern, \"\");\\n        }\\n       \\n        return ans;\\n        \\n    }\\n    }",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "class Solution {\\n      public String largestPalindromic(String num) {\\n        \\n        Map<Character,Integer>map  = new HashMap();\\n        for(char c: num.toCharArray()){\\n            \\n            map.put(c,map.getOrDefault(c,0)+1);\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2457553,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Greedy***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(Constant)***\\n\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        \\n        int n = num.size();\\n        \\n        // count array will store the frequency of each digit\\n        \\n        vector<int> count(10, 0);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            count[num[i] - \\'0\\']++;\\n        }\\n        \\n        string res = \"\";\\n        \\n        // iterate from last so that we can get largest possible digit first\\n        \\n        for(int i = 9; i >= 0; i--)\\n        {\\n            // escape leading zeros\\n            \\n            if(i == 0 && res.size() == 0)\\n                continue;\\n            \\n            // get the frequency of current diigt\\n            \\n            int x = count[i];\\n            \\n            // if frequency is > 0, then add the current digit to res x / times\\n            \\n            if(x > 0)\\n            {\\n                x /= 2;\\n                \\n                // decrement the count of curr digit\\n                \\n                count[i] -= 2 * x;\\n                \\n                // add the digit to res\\n                \\n                while(x > 0)\\n                {\\n                    res.push_back(\\'0\\' + i);\\n                    \\n                    x--;\\n                }\\n            } \\n        }\\n        \\n        // we can put the one digit in middle of the res, still it will be palindrome, try to take the largest possible digit\\n        \\n        string temp = res;\\n        \\n        for(int i = 9; i >= 0; i--)\\n        {\\n            if(count[i] == 1)\\n            {\\n                res.push_back(\\'0\\' + i);\\n                \\n                break;\\n            }\\n        }\\n        \\n        // reverse the temp\\n        \\n        reverse(temp.begin(), temp.end());\\n        \\n        // add to res\\n        \\n        res += temp;\\n       \\n        if(res.size() == 0)\\n            return \"0\";\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        \\n        int n = num.size();\\n        \\n        // count array will store the frequency of each digit\\n        \\n        vector<int> count(10, 0);\\n        \\n        for(int i = 0; i < n; i++)\\n        {\\n            count[num[i] - \\'0\\']++;\\n        }\\n        \\n        string res = \"\";\\n        \\n        // iterate from last so that we can get largest possible digit first\\n        \\n        for(int i = 9; i >= 0; i--)\\n        {\\n            // escape leading zeros\\n            \\n            if(i == 0 && res.size() == 0)\\n                continue;\\n            \\n            // get the frequency of current diigt\\n            \\n            int x = count[i];\\n            \\n            // if frequency is > 0, then add the current digit to res x / times\\n            \\n            if(x > 0)\\n            {\\n                x /= 2;\\n                \\n                // decrement the count of curr digit\\n                \\n                count[i] -= 2 * x;\\n                \\n                // add the digit to res\\n                \\n                while(x > 0)\\n                {\\n                    res.push_back(\\'0\\' + i);\\n                    \\n                    x--;\\n                }\\n            } \\n        }\\n        \\n        // we can put the one digit in middle of the res, still it will be palindrome, try to take the largest possible digit\\n        \\n        string temp = res;\\n        \\n        for(int i = 9; i >= 0; i--)\\n        {\\n            if(count[i] == 1)\\n            {\\n                res.push_back(\\'0\\' + i);\\n                \\n                break;\\n            }\\n        }\\n        \\n        // reverse the temp\\n        \\n        reverse(temp.begin(), temp.end());\\n        \\n        // add to res\\n        \\n        res += temp;\\n       \\n        if(res.size() == 0)\\n            return \"0\";\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457371,
                "title": "c-simple-efficient-solution-use-hashmap",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    string largestPalindromic(string num) \\n    {\\n        int cnt[10] = {0};\\n        for(auto it:num) cnt[it-\\'0\\']++;\\n        string res, res2;\\n        int t;\\n        \\n        for(int i=9; i>=0; i--)\\n        {\\n            if(i==0 && res.empty()) break;\\n            t=cnt[i]/2;\\n            for(int j=0; j<t; j++) res.push_back(\\'0\\'+i);\\n            cnt[i] -= 2*t;\\n        }\\n        \\n        res2 = res;\\n        reverse(res2.begin(), res2.end());\\n        \\n        for(int i=9; i>=0; i--)\\n        {\\n            if(cnt[i]) \\n            {\\n                res.push_back(\\'0\\'+i);\\n                break;\\n            }\\n        }\\n        return res+res2;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    string largestPalindromic(string num) \\n    {\\n        int cnt[10] = {0};\\n        for(auto it:num) cnt[it-\\'0\\']++;\\n        string res, res2;\\n        int t;\\n        \\n        for(int i=9; i>=0; i--)\\n        {\\n            if(i==0 && res.empty()) break;\\n            t=cnt[i]/2;\\n            for(int j=0; j<t; j++) res.push_back(\\'0\\'+i);\\n            cnt[i] -= 2*t;\\n        }\\n        \\n        res2 = res;\\n        reverse(res2.begin(), res2.end());\\n        \\n        for(int i=9; i>=0; i--)\\n        {\\n            if(cnt[i]) \\n            {\\n                res.push_back(\\'0\\'+i);\\n                break;\\n            }\\n        }\\n        return res+res2;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457131,
                "title": "c-very-easy-code",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int> v(10,0);\\n        for(auto x:num)\\n            v[x-\\'0\\']++;\\n        \\n       string p=\"\",q=\"\"; // left and right portions\\n       for(int i=v.size()-1;i>=0;i--)// even character counts\\n        {\\n            while(v[i]>=2)\\n            {\\n                if(p.length()==0 && i==0)// skip leading zeros\\n                    break;\\n                p+=i+\\'0\\';\\n                q+=i+\\'0\\';\\n                v[i]-=2;\\n            }\\n        }\\n        for(int i=v.size()-1;i>=0;i--)// odd char\\n        {\\n            if(v[i]>0)\\n            {\\n                p+=i+\\'0\\';\\n                break;\\n            }\\n        }\\n        reverse(q.begin(),q.end());\\n        p+=q;\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int> v(10,0);\\n        for(auto x:num)\\n            v[x-\\'0\\']++;\\n        \\n       string p=\"\",q=\"\"; // left and right portions\\n       for(int i=v.size()-1;i>=0;i--)// even character counts\\n        {\\n            while(v[i]>=2)\\n            {\\n                if(p.length()==0 && i==0)// skip leading zeros\\n                    break;\\n                p+=i+\\'0\\';\\n                q+=i+\\'0\\';\\n                v[i]-=2;\\n            }\\n        }\\n        for(int i=v.size()-1;i>=0;i--)// odd char\\n        {\\n            if(v[i]>0)\\n            {\\n                p+=i+\\'0\\';\\n                break;\\n            }\\n        }\\n        reverse(q.begin(),q.end());\\n        p+=q;\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457103,
                "title": "c-map-explained-easy-o-n",
                "content": "\\t// Since we want maximun number which is palindrome so we will first add greater numbers if they  are present atleast 2 times \\n\\t// we will store largest number which is present odd number of times for our mid value (since we dont require number is pairs for mid value)\\n\\t// then well add half number before mid and remaining half after mid \\n\\n\\tstring largestPalindromic(string num) \\n    {\\n        map<int,int> mp;\\n        string ans;\\n        \\n        for(char ch:num)\\n            mp[ch-\\'0\\']++;\\n        \\n        if(mp.size()==1 && mp[0])\\n            return \"0\";\\n        \\n        int mid=-1;\\n        for(int i=9;i>=0;i--)                    // adding numbers before mid \\n        {\\n            if(i==0 && !ans.size())\\n                continue;\\n         \\n            if(mp[i]%2==1)\\n                mid = max(mid,i);\\n            \\n            mp[i] = mp[i]/2;                    // doing half for each frequenceies\\n            for(int j=0;j<mp[i];j++)\\n                ans +=(\\'0\\'+i);      \\n        }\\n        \\n        if(mid!=-1)                            // if any number is present in odd quantity then adding middle\\n        {\\n            ans +=(\\'0\\'+mid);\\n            if(ans.size()==1)\\n                return ans;\\n        }\\n                \\n        for(int i=0;i<=9;i++)                  //adding remaining half numbers after mid\\n        {\\n            for(int j=0;j<mp[i];j++)\\n                ans +=(\\'0\\'+i);    \\n        }\\n        \\n        return ans;\\n    }",
                "solutionTags": [
                    "C"
                ],
                "code": "\\t// Since we want maximun number which is palindrome so we will first add greater numbers if they  are present atleast 2 times \\n\\t// we will store largest number which is present odd number of times for our mid value (since we dont require number is pairs for mid value)\\n\\t// then well add half number before mid and remaining half after mid \\n\\n\\tstring largestPalindromic(string num) \\n    {\\n        map<int,int> mp;\\n        string ans;\\n        \\n        for(char ch:num)\\n            mp[ch-\\'0\\']++;\\n        \\n        if(mp.size()==1 && mp[0])\\n            return \"0\";\\n        \\n        int mid=-1;\\n        for(int i=9;i>=0;i--)                    // adding numbers before mid \\n        {\\n            if(i==0 && !ans.size())\\n                continue;\\n         \\n            if(mp[i]%2==1)\\n                mid = max(mid,i);\\n            \\n            mp[i] = mp[i]/2;                    // doing half for each frequenceies\\n            for(int j=0;j<mp[i];j++)\\n                ans +=(\\'0\\'+i);      \\n        }\\n        \\n        if(mid!=-1)                            // if any number is present in odd quantity then adding middle\\n        {\\n            ans +=(\\'0\\'+mid);\\n            if(ans.size()==1)\\n                return ans;\\n        }\\n                \\n        for(int i=0;i<=9;i++)                  //adding remaining half numbers after mid\\n        {\\n            for(int j=0;j<mp[i];j++)\\n                ans +=(\\'0\\'+i);    \\n        }\\n        \\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2457003,
                "title": "java-solution-18ms-100-faster",
                "content": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int[] dig = new int[10];\\n        int n = num.length();\\n        // System.out.println(n+\"\\\\n\");\\n        char[] arr = num.toCharArray();\\n        for(int i=0;i<n;i++){\\n            dig[arr[i]-\\'0\\']++;\\n        }\\n        char[] digit = \"0123456789\".toCharArray();\\n        String front = \"\";\\n        for(int i=9;i>=0;i--){\\n            if(dig[i]!=0){\\n                if(dig[i]%2==1){\\n                    if(dig[i]>2){\\n                        if(digit[i]==\\'0\\' && front.length()>0){\\n                            char[] temp = new char[(dig[i]-1)/2];\\n                            Arrays.fill(temp,digit[i]);\\n                            front += String.valueOf(temp);\\n                            dig[i] = 1;                       \\n                        }\\n                        if(digit[i]!=\\'0\\'){\\n                            char[] temp = new char[(dig[i]-1)/2];\\n                            Arrays.fill(temp,digit[i]);\\n                            front += String.valueOf(temp);\\n                            dig[i] = 1;                      \\n                        }\\n                    }   \\n                }else{\\n                    if(digit[i]==\\'0\\' && front.length()>0){\\n                        char[] temp = new char[(dig[i])/2];\\n                        Arrays.fill(temp,digit[i]); \\n                        front += String.valueOf(temp);\\n                        dig[i] =0;\\n                    }if(digit[i]!=\\'0\\'){\\n                        char[] temp = new char[(dig[i])/2];\\n                        Arrays.fill(temp,digit[i]);\\n                        front += String.valueOf(temp);\\n                        dig[i] =0;                  \\n                    }\\n  \\n                }\\n            }\\n        }\\n        boolean mid = false;\\n        for(int i=9;i>=0;i--){\\n            if(dig[i]==1){\\n                mid  = true;\\n                front+= digit[i];\\n                break;\\n            }\\n        }\\n        if(front.length()==0){\\n            return \"0\";\\n        }\\n        if(front.length()==1){\\n            return front;\\n        }\\n        char[] ans = new char[front.length()*2];\\n        char[] f = front.toCharArray();\\n        int len = f.length;\\n        for(int i=0;i<len;i++){\\n            ans[i] = f[i];\\n        }\\n        int k = 0;\\n        int shift = 1;\\n        if(mid){\\n            shift = 2;\\n        }\\n        for(int i=len-shift;i>=0;i--){\\n            ans[len+k] = f[i];\\n            k++;\\n        }\\n        return String.valueOf(ans).replace(\"\\\\u0000\", \"\");\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int[] dig = new int[10];\\n        int n = num.length();\\n        // System.out.println(n+\"\\\\n\");\\n        char[] arr = num.toCharArray();\\n        for(int i=0;i<n;i++){\\n            dig[arr[i]-\\'0\\']++;\\n        }\\n        char[] digit = \"0123456789\".toCharArray();\\n        String front = \"\";\\n        for(int i=9;i>=0;i--){\\n            if(dig[i]!=0){\\n                if(dig[i]%2==1){\\n                    if(dig[i]>2){\\n                        if(digit[i]==\\'0\\' && front.length()>0){\\n                            char[] temp = new char[(dig[i]-1)/2];\\n                            Arrays.fill(temp,digit[i]);\\n                            front += String.valueOf(temp);\\n                            dig[i] = 1;                       \\n                        }\\n                        if(digit[i]!=\\'0\\'){\\n                            char[] temp = new char[(dig[i]-1)/2];\\n                            Arrays.fill(temp,digit[i]);\\n                            front += String.valueOf(temp);\\n                            dig[i] = 1;                      \\n                        }\\n                    }   \\n                }else{\\n                    if(digit[i]==\\'0\\' && front.length()>0){\\n                        char[] temp = new char[(dig[i])/2];\\n                        Arrays.fill(temp,digit[i]); \\n                        front += String.valueOf(temp);\\n                        dig[i] =0;\\n                    }if(digit[i]!=\\'0\\'){\\n                        char[] temp = new char[(dig[i])/2];\\n                        Arrays.fill(temp,digit[i]);\\n                        front += String.valueOf(temp);\\n                        dig[i] =0;                  \\n                    }\\n  \\n                }\\n            }\\n        }\\n        boolean mid = false;\\n        for(int i=9;i>=0;i--){\\n            if(dig[i]==1){\\n                mid  = true;\\n                front+= digit[i];\\n                break;\\n            }\\n        }\\n        if(front.length()==0){\\n            return \"0\";\\n        }\\n        if(front.length()==1){\\n            return front;\\n        }\\n        char[] ans = new char[front.length()*2];\\n        char[] f = front.toCharArray();\\n        int len = f.length;\\n        for(int i=0;i<len;i++){\\n            ans[i] = f[i];\\n        }\\n        int k = 0;\\n        int shift = 1;\\n        if(mid){\\n            shift = 2;\\n        }\\n        for(int i=len-shift;i>=0;i--){\\n            ans[len+k] = f[i];\\n            k++;\\n        }\\n        return String.valueOf(ans).replace(\"\\\\u0000\", \"\");\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456922,
                "title": "easy-c-code-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        map<int,int> M;\\n        string k=\"\",z=\"\";\\n        for(int i=0;i<num.size();i++){\\n            M[int(num[i]-48)]++;\\n        }\\n        for(int i=0;i<10;i++){\\n            if(M[i]>1){\\n                k.push_back(char(48+i));\\n                M[i]-=2;\\n                i--;\\n            }\\n        }\\n        for(int i=k.size()-1;i>=0;i--){\\n            z.push_back(k[i]);\\n        }\\n        k=z+k;\\n        for(int i=9;i>=0;i--){\\n            if(M[i]==1){\\n                k.insert(k.begin()+(k.size()/2),1,char(48+i));\\n                break;\\n            }\\n        }\\n        for(int i=k.size()-1;i>=0;i--){\\n            if(k[i]!=\\'0\\'){\\n                break;\\n            }\\n            k.pop_back();\\n        }\\n        reverse(k.begin(),k.end());\\n        for(int i=k.size()-1;i>=0;i--){\\n            if(k[i]!=\\'0\\'){\\n                break;\\n            }\\n            k.pop_back();\\n        }\\n        reverse(k.begin(),k.end());\\n        if(k==\"\") return \"0\";\\n        return k;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        map<int,int> M;\\n        string k=\"\",z=\"\";\\n        for(int i=0;i<num.size();i++){\\n            M[int(num[i]-48)]++;\\n        }\\n        for(int i=0;i<10;i++){\\n            if(M[i]>1){\\n                k.push_back(char(48+i));\\n                M[i]-=2;\\n                i--;\\n            }\\n        }\\n        for(int i=k.size()-1;i>=0;i--){\\n            z.push_back(k[i]);\\n        }\\n        k=z+k;\\n        for(int i=9;i>=0;i--){\\n            if(M[i]==1){\\n                k.insert(k.begin()+(k.size()/2),1,char(48+i));\\n                break;\\n            }\\n        }\\n        for(int i=k.size()-1;i>=0;i--){\\n            if(k[i]!=\\'0\\'){\\n                break;\\n            }\\n            k.pop_back();\\n        }\\n        reverse(k.begin(),k.end());\\n        for(int i=k.size()-1;i>=0;i--){\\n            if(k[i]!=\\'0\\'){\\n                break;\\n            }\\n            k.pop_back();\\n        }\\n        reverse(k.begin(),k.end());\\n        if(k==\"\") return \"0\";\\n        return k;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456877,
                "title": "c-simple-noob-solution-with-explanation",
                "content": "### Simple C++ Solution\\n\\n#### Idea ---\\n\\nWe will create three separate string for storing the beginning, end and mid of the string. We will create a map of all the characters in the string num. If the count of a char is even then we\\'ll add half of it in the beg and half of it in the end. If it\\'s odd then just ***1*** of it in mid and same as above for remaining (num.length() - 1) of it as it is even now.\\n\\n---\\n\\n```\\n\"44494713799\"\\nbeg = \"4497\"\\nend = \"4497\"\\nmid = 9\\n\\nnow mid size can only be 1 otherwise it will be invalid\\n\\n```\\n\\nclass Solution\\n{\\npublic:\\n    string largestPalindromic(string num)\\n    {\\n        string ans = \"\", beg = \"\", rend = \"\", mid = \"\";\\n        map<char, int> umap;\\n\\n        for (char c : num)\\n            umap[c]++;\\n\\n        // I\\'m looping in reverse because of some edge cases like \\'10019000\\'\\n        map<char, int>::reverse_iterator it;\\n        for (it = umap.rbegin(); it != umap.rend(); it++)\\n        {\\n            if (it->second % 2 == 0)\\n            {\\n                string temp(it->second / 2, it->first);\\n                beg += temp;\\n                rend += temp;\\n            }\\n            else if (it->second % 2 != 0)\\n            {\\n                int x = it->first - \\'0\\';\\n                int y = (mid != \"\") ? stoi(mid) : 0;\\n                mid = to_string(max(x, y));\\n                int c = it->second - 1;\\n                string temp(c / 2, it->first);\\n                beg += temp;\\n                rend += temp;\\n            }\\n        }\\n\\n        reverse(rend.begin(), rend.end());\\n        beg += (mid + rend);\\n\\n\\n        // Since we can\\'t have zero in beginning I m just removing them after the beg is created.\\n\\n        while (*beg.begin() == \\'0\\')\\n        {\\n            beg.erase(0, 1);\\n            if (beg.size() == 0)\\n                break;\\n            beg.erase(beg.size() - 1, 1);\\n        }\\n\\n        \\n        // It\\'s for a edge case \\'00000\\' don\\'t know why it\\'s answer is supposed to be \\'0\\'\\n        if (beg == \"\")\\n            beg = \"0\";\\n        return beg;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\"44494713799\"\\nbeg = \"4497\"\\nend = \"4497\"\\nmid = 9\\n\\nnow mid size can only be 1 otherwise it will be invalid\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2456811,
                "title": "",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        string ans=\"\";\\n        char ch=\\'z\\';\\n        vector<int> v(10,0);\\n        sort(num.begin(),num.end());\\n        for(int i=0;i<num.length();i++){\\n            int x=num[i]-\\'0\\';\\n            v[x]++;\\n        }\\n        for(int i=0;i<v.size();i++){\\n            if(v[i]%2==1) ch=\\'0\\'+i;\\n        }\\n        for(int i=v.size()-1;i>=0;i--){\\n            char temp=\\'0\\'+i;\\n            if(v[i]>1){\\n                if(temp==\\'0\\'){\\n                    if(ans.length()==0) continue;\\n                }\\n                int x=v[i]/2;\\n                for(int j=0;j<x;j++){\\n                    ans+=temp;\\n                }\\n            }\\n        }\\n        string temp=ans;\\n        reverse(temp.begin(),temp.end());\\n        if(ch!=\\'z\\') ans+=ch;\\n        else if(ans.length()==0){\\n            if(v[0]!=0) return \"0\";\\n        }\\n        ans+=temp;\\n        return ans; \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        string ans=\"\";\\n        char ch=\\'z\\';\\n        vector<int> v(10,0);\\n        sort(num.begin(),num.end());\\n        for(int i=0;i<num.length();i++){\\n            int x=num[i]-\\'0\\';\\n            v[x]++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2456714,
                "title": "java-solution",
                "content": "```java\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int[] freq = new int[10];\\n        for(char ch : num.toCharArray()) {\\n            freq[ch - \\'0\\']++;\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        int oddFreqMax = -1;\\n        for(int i = 0; i <= 9; i++) {\\n            if(freq[i] % 2 == 1) {\\n                oddFreqMax = i;\\n            }\\n        }\\n        if(oddFreqMax != -1) {\\n            sb.append(oddFreqMax);\\n        }\\n        for(int i = 0; i <= 9; i++) {\\n            int cnt = freq[i];\\n            if(cnt == 0) {\\n                continue;\\n            }\\n            if(cnt % 2 == 1) {\\n                cnt--;\\n            }\\n            for(int j = 0; j < cnt / 2; j++) {\\n                sb.append(i);\\n                sb.insert(0, i);\\n            }\\n        }\\n        int idx1 = 0;\\n        while(idx1 < sb.length() && sb.charAt(idx1) == \\'0\\') {\\n            idx1++;\\n        }\\n        sb.replace(0, idx1, \"\");\\n        int idx2 = sb.length() - 1;\\n        while(idx2 >= 0 && sb.charAt(idx2) == \\'0\\') {\\n            sb.deleteCharAt(idx2);\\n            idx2--;\\n        }\\n        return sb.length() == 0 ? \"0\" : sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "class Solution {\\n    public String largestPalindromic(String num) {\\n        int[] freq = new int[10];\\n        for(char ch : num.toCharArray()) {\\n            freq[ch - \\'0\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2456654,
                "title": "simple-c-solution-using-hashmap",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int> v(10,0);\\n        for (char c:num) v[c-\\'0\\']++;\\n        string ans;\\n        for (int i=9;i>=0;i--) {\\n            if (!i&&!ans.size()) break;\\n            while (v[i]>1) {\\n                ans+=\\'0\\'+i;\\n                v[i]-=2;\\n            }\\n        }\\n        string x=ans;\\n        for (int i=9;i>=0;i--) {\\n            if (v[i]>0) {\\n                ans+=\\'0\\'+i;\\n                break;\\n            }\\n        }\\n        reverse(x.begin(),x.end());\\n        ans+=x;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int> v(10,0);\\n        for (char c:num) v[c-\\'0\\']++;\\n        string ans;\\n        for (int i=9;i>=0;i--) {\\n            if (!i&&!ans.size()) break;\\n            while (v[i]>1) {\\n                ans+=\\'0\\'+i;\\n                v[i]-=2;\\n            }\\n        }\\n        string x=ans;\\n        for (int i=9;i>=0;i--) {\\n            if (v[i]>0) {\\n                ans+=\\'0\\'+i;\\n                break;\\n            }\\n        }\\n        reverse(x.begin(),x.end());\\n        ans+=x;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456620,
                "title": "java-solution-with-frequencies-stringbuilder",
                "content": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        boolean onlyContainsZeroes = true;\\n        int[] frequencies = new int[10];\\n        for (int i = 0; i < num.length(); i++) {\\n            int digit = num.charAt(i) - \\'0\\';\\n            if (digit != 0) {\\n                onlyContainsZeroes = false;\\n            }\\n            frequencies[digit]++;\\n        }\\n        if (onlyContainsZeroes) {\\n            return \"0\";\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        boolean addedDigit = false;\\n        char digit = \\'.\\';\\n        for (int i = 9; i >= 0; i--) {   \\n            if (i == 0 && sb.isEmpty()) {\\n                continue;\\n            }\\n            if (frequencies[i] % 2 != 0 && addedDigit == false) {\\n                digit = (char) (i + \\'0\\');\\n                addedDigit = true;\\n            }\\n            for (int j = 0; j < frequencies[i] / 2; j++) {\\n                sb.append((char) (i + \\'0\\'));\\n            }         \\n        }     \\n        if (digit != \\'.\\') {\\n            return sb.toString() + digit + sb.reverse().toString();\\n        } else {\\n            return sb.toString() + sb.reverse().toString();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        boolean onlyContainsZeroes = true;\\n        int[] frequencies = new int[10];\\n        for (int i = 0; i < num.length(); i++) {\\n            int digit = num.charAt(i) - \\'0\\';\\n            if (digit != 0) {\\n                onlyContainsZeroes = false;\\n            }\\n            frequencies[digit]++;\\n        }\\n        if (onlyContainsZeroes) {\\n            return \"0\";\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        boolean addedDigit = false;\\n        char digit = \\'.\\';\\n        for (int i = 9; i >= 0; i--) {   \\n            if (i == 0 && sb.isEmpty()) {\\n                continue;\\n            }\\n            if (frequencies[i] % 2 != 0 && addedDigit == false) {\\n                digit = (char) (i + \\'0\\');\\n                addedDigit = true;\\n            }\\n            for (int j = 0; j < frequencies[i] / 2; j++) {\\n                sb.append((char) (i + \\'0\\'));\\n            }         \\n        }     \\n        if (digit != \\'.\\') {\\n            return sb.toString() + digit + sb.reverse().toString();\\n        } else {\\n            return sb.toString() + sb.reverse().toString();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3400462,
                "title": "easy-to-understand-highly-commented-o-n-efficient",
                "content": "# Please upvote if you like the solution\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\n\\nfunction largestPalindromic (num) {\\n   let counter = Array(10).fill(0), array = [], result = \"\";\\n\\n   // create counter for every numeric digit and increment it. \\n   for(let n of num) {\\n       counter[parseInt(n)]++;\\n   }\\n\\n   // traverse counter in reverse direction so that we do have maximum \\n   // digit in the begining of the result\\n\\n   // We also calculating mid digit in case odd number of numeric digits present\\n   for(let i = 9; i >= 0; i--) {\\n       if(counter[i] & 1) {\\n           result = Math.max(result, i);\\n       }\\n\\n       while(counter[i] >= 2) {\\n           array.push(i);\\n           counter[i] -= 2;\\n       }\\n   }\\n\\n   // convert result numeric to string\\n   result = result.toString();\\n\\n   // if either array is empty Or 1st digit is 0 return result Or zero if no result \\n   // digit present\\n   if(!array.length || array[0] === 0) return result || \"0\";\\n\\n   // finally adding digits end to result to end \\n   for(let i = array.length - 1; i >= 0; i--) {\\n       result = array[i] + result + array[i];\\n   }\\n\\n   // return the resultant required string \\n   return result;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\n\\nfunction largestPalindromic (num) {\\n   let counter = Array(10).fill(0), array = [], result = \"\";\\n\\n   // create counter for every numeric digit and increment it. \\n   for(let n of num) {\\n       counter[parseInt(n)]++;\\n   }\\n\\n   // traverse counter in reverse direction so that we do have maximum \\n   // digit in the begining of the result\\n\\n   // We also calculating mid digit in case odd number of numeric digits present\\n   for(let i = 9; i >= 0; i--) {\\n       if(counter[i] & 1) {\\n           result = Math.max(result, i);\\n       }\\n\\n       while(counter[i] >= 2) {\\n           array.push(i);\\n           counter[i] -= 2;\\n       }\\n   }\\n\\n   // convert result numeric to string\\n   result = result.toString();\\n\\n   // if either array is empty Or 1st digit is 0 return result Or zero if no result \\n   // digit present\\n   if(!array.length || array[0] === 0) return result || \"0\";\\n\\n   // finally adding digits end to result to end \\n   for(let i = array.length - 1; i >= 0; i--) {\\n       result = array[i] + result + array[i];\\n   }\\n\\n   // return the resultant required string \\n   return result;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3243540,
                "title": "python-dictionary-solution-with-detailed-explanation",
                "content": "# Intuition\\n- In a palindrome, every character except the middle character occurs an even number of times, e.g. \\'12321\\'. Here \\'1\\' and \\'2\\' occur 2 times each.\\n- The middle character either does not exist (in the case of a palindrome of even length), e.g. \\'1221\\', or occurs an odd number of times, e.g. \\'1233321\\', where the middle character \\'3\\' occurs 3 times.\\n- If the occurrences of each character are counted, the counts of each character can be used to create a palindrome.\\n- As the largest palindrome is to be returned, the digits with the largest value should occur earliest in the palindrome.\\n\\n# Approach\\n- Create a dictionary \\'counts\\' to store the number of occurrences of each digit in the input string.\\n- Initialize two arrays \\'front\\' and \\'back\\'. \\'front\\' will contain the characters in first half of the palindrome (including the middle character), while \\'back\\' will contain the characters in the second half of the palindrome.\\n- Iterate through digits [9-0] in descending order (so the palindrome will be of the largest value). If the digit is in \\'counts\\', add the digit to both the two arrays till its total number of occurrences in the front and back is equal to the highest even number less than the count.\\n- If \\'front\\' is empty, do not add \\'0\\' to \\'front\\' or \\'back\\'. These will be leading zeros in the palindrome, which are to be avoided.\\n- Find the largest digit with an odd number of occurrences in count (if any). If there is, add this digit to \\'front\\'. This will be the the middle character of the palindrome.\\n- Reverse \\'back\\' and combine it with \\'front\\'. Convert the combined array to a string and return it.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, the operations of creating the dictionary, adding digits to the arrays, and converting to string are all $$O(n)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$, the arrays created are of $$O(n)$$ space complexity.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n\\n        #Process input\\n        counts = collections.Counter(num)\\n\\n        #Initialize two arrays\\n        front = []\\n        back = []\\n\\n        #Handle case of Zeros\\n        if len(counts) == 1 and counts[\\'0\\']>=1:\\n            return \\'0\\'\\n\\n        #Add digits [1-9] to front and back arrays\\n        temp = middle = None\\n        for digit in range(9,0,-1):\\n            temp = counts[str(digit)]\\n            while temp - 2 >= 0:\\n                front.append(str(digit))\\n                back.append(str(digit))\\n                temp -= 2\\n            if temp > 0 and not middle:\\n                middle = str(digit)\\n\\n        #Add digit 0 to front and back arrays\\n        #Handle case of leading zeros\\n        if front and counts[\\'0\\']:\\n            temp = counts[\\'0\\']\\n            while temp - 2 >= 0:\\n                front.append(\\'0\\')\\n                back.append(\\'0\\')\\n                temp -= 2\\n            if temp > 0 and not middle:\\n                middle = \\'0\\'\\n\\n        #Add middle digit to front array\\n        if middle:\\n            front.append(middle)\\n\\n        #Join arrays, convert to string and return\\n        return \"\".join(front+list(reversed(back)))\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n\\n        #Process input\\n        counts = collections.Counter(num)\\n\\n        #Initialize two arrays\\n        front = []\\n        back = []\\n\\n        #Handle case of Zeros\\n        if len(counts) == 1 and counts[\\'0\\']>=1:\\n            return \\'0\\'\\n\\n        #Add digits [1-9] to front and back arrays\\n        temp = middle = None\\n        for digit in range(9,0,-1):\\n            temp = counts[str(digit)]\\n            while temp - 2 >= 0:\\n                front.append(str(digit))\\n                back.append(str(digit))\\n                temp -= 2\\n            if temp > 0 and not middle:\\n                middle = str(digit)\\n\\n        #Add digit 0 to front and back arrays\\n        #Handle case of leading zeros\\n        if front and counts[\\'0\\']:\\n            temp = counts[\\'0\\']\\n            while temp - 2 >= 0:\\n                front.append(\\'0\\')\\n                back.append(\\'0\\')\\n                temp -= 2\\n            if temp > 0 and not middle:\\n                middle = \\'0\\'\\n\\n        #Add middle digit to front array\\n        if middle:\\n            front.append(middle)\\n\\n        #Join arrays, convert to string and return\\n        return \"\".join(front+list(reversed(back)))\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3225198,
                "title": "fastest-solution-in-c",
                "content": "# Intuition\\n![Screenshot 2023-02-24 184322.png](https://assets.leetcode.com/users/images/e77165f0-2ed9-4acc-a878-282c465cedf1_1677244461.6111174.png)\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        if(num.size() == 1){\\n            return num;\\n        }\\n        vector<int> v(10 , 0);\\n        int n = num.size();\\n        for(int i=0; i<n; i++){\\n            v[num[i]-\\'0\\']++;\\n        }\\n        int singlemax = -1;\\n        for(int i=0; i<10; i++){\\n            if(v[i]%2 != 0){\\n                singlemax = max(i , singlemax);\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i=9; i>=0; i--){\\n            if(v[i] > 1){\\n                if(i==0 && ans.size() == 0){\\n                    break;\\n                }\\n                ans.append(v[i]/2 , i+\\'0\\');\\n            }\\n        }\\n        num = ans;\\n        if(singlemax > -1){\\n            ans.append(1 , singlemax+\\'0\\');\\n        }\\n        reverse(num.begin() , num.end());\\n        ans+=num;\\n        if(ans.size() == 0) return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        if(num.size() == 1){\\n            return num;\\n        }\\n        vector<int> v(10 , 0);\\n        int n = num.size();\\n        for(int i=0; i<n; i++){\\n            v[num[i]-\\'0\\']++;\\n        }\\n        int singlemax = -1;\\n        for(int i=0; i<10; i++){\\n            if(v[i]%2 != 0){\\n                singlemax = max(i , singlemax);\\n            }\\n        }\\n        string ans = \"\";\\n        for(int i=9; i>=0; i--){\\n            if(v[i] > 1){\\n                if(i==0 && ans.size() == 0){\\n                    break;\\n                }\\n                ans.append(v[i]/2 , i+\\'0\\');\\n            }\\n        }\\n        num = ans;\\n        if(singlemax > -1){\\n            ans.append(1 , singlemax+\\'0\\');\\n        }\\n        reverse(num.begin() , num.end());\\n        ans+=num;\\n        if(ans.size() == 0) return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3128695,
                "title": "c-easy-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        int hashmap[10];\\n        for(int i=0;i<10;i++) hashmap[i]=0;\\n        string tmp=\"\";\\n        for(int i=0;i<num.size();i++){\\n            int digit = int(num[i] - \\'0\\');\\n            hashmap[digit]++;\\n        }\\n        int od_digit=-1;\\n        for(int i=9;i>=0;i--){\\n            if(tmp.size()==0 && i==0){\\n                if(od_digit==-1)\\n                    return \"0\";\\n                break;\\n            }\\n            \\n            if(hashmap[i]%2==0){\\n                if(hashmap[i]>1){\\n                    for(int k=0;k<hashmap[i]/2;k++){\\n                        tmp+=to_string(i);\\n                    }\\n                }\\n                hashmap[i]=0;\\n            }\\n            else{\\n                if(hashmap[i]==1){\\n                    od_digit = max(od_digit,i);\\n                    hashmap[i]=0;\\n                }\\n                if(hashmap[i]>1){\\n                    for(int k=0;k<hashmap[i]/2;k++){\\n                        tmp+=to_string(i);\\n                    }\\n                    od_digit=max(od_digit,i);\\n                    hashmap[i]=0;\\n                }\\n            }\\n        }\\n        string rev = tmp;\\n        reverse(rev.begin(),rev.end());\\n        if(od_digit==-1){\\n            return tmp+rev;\\n        }\\n        return tmp+to_string(od_digit)+rev;\\n        \\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        int hashmap[10];\\n        for(int i=0;i<10;i++) hashmap[i]=0;\\n        string tmp=\"\";\\n        for(int i=0;i<num.size();i++){\\n            int digit = int(num[i] - \\'0\\');\\n            hashmap[digit]++;\\n        }\\n        int od_digit=-1;\\n        for(int i=9;i>=0;i--){\\n            if(tmp.size()==0 && i==0){\\n                if(od_digit==-1)\\n                    return \"0\";\\n                break;\\n            }\\n            \\n            if(hashmap[i]%2==0){\\n                if(hashmap[i]>1){\\n                    for(int k=0;k<hashmap[i]/2;k++){\\n                        tmp+=to_string(i);\\n                    }\\n                }\\n                hashmap[i]=0;\\n            }\\n            else{\\n                if(hashmap[i]==1){\\n                    od_digit = max(od_digit,i);\\n                    hashmap[i]=0;\\n                }\\n                if(hashmap[i]>1){\\n                    for(int k=0;k<hashmap[i]/2;k++){\\n                        tmp+=to_string(i);\\n                    }\\n                    od_digit=max(od_digit,i);\\n                    hashmap[i]=0;\\n                }\\n            }\\n        }\\n        string rev = tmp;\\n        reverse(rev.begin(),rev.end());\\n        if(od_digit==-1){\\n            return tmp+rev;\\n        }\\n        return tmp+to_string(od_digit)+rev;\\n        \\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2938688,
                "title": "c-find-first-not-of-easy-to-understand",
                "content": "**If Helpful Please Like Or Upvoke**\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int>freqArr(10);\\n        for(char i:num)freqArr[i - \\'0\\']++; \\n        \\n        string front = \"\", back = \"\"; // Intiliasing two empty strings \\n        \\n        for(int i = 9;i>=0;i--) // starting the loop in the reverse as we need to create largest palindrome number\\n        {\\n            while(freqArr[i]>=2 ) \\n            {\\n                front += to_string(i);\\n                back += to_string(i);\\n                freqArr[i] -= 2;\\n            }\\n        }\\n        \\n        for(int i = 9;i>=0;i--)\\n        {\\n            if(freqArr[i]) \\n            {\\n                front += to_string(i);\\n                break;\\n            }\\n        }\\n     //   cout<< front<<\" \"<<back<<endl;\\n        front.erase(0, front.find_first_not_of(\\'0\\'));\\n        \\n        back.erase(0, back.find_first_not_of(\\'0\\'));\\n        reverse(back.begin(),back.end());\\n      \\n        string ans= front + back ;\\n        if(ans.size()==0)return \"0\";\\n        else return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int>freqArr(10);\\n        for(char i:num)freqArr[i - \\'0\\']++; \\n        \\n        string front = \"\", back = \"\"; // Intiliasing two empty strings \\n        \\n        for(int i = 9;i>=0;i--) // starting the loop in the reverse as we need to create largest palindrome number\\n        {\\n            while(freqArr[i]>=2 ) \\n            {\\n                front += to_string(i);\\n                back += to_string(i);\\n                freqArr[i] -= 2;\\n            }\\n        }\\n        \\n        for(int i = 9;i>=0;i--)\\n        {\\n            if(freqArr[i]) \\n            {\\n                front += to_string(i);\\n                break;\\n            }\\n        }\\n     //   cout<< front<<\" \"<<back<<endl;\\n        front.erase(0, front.find_first_not_of(\\'0\\'));\\n        \\n        back.erase(0, back.find_first_not_of(\\'0\\'));\\n        reverse(back.begin(),back.end());\\n      \\n        string ans= front + back ;\\n        if(ans.size()==0)return \"0\";\\n        else return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2843958,
                "title": "python-simplest-approach",
                "content": "```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        res = \\'\\'\\n        count = Counter(num)\\n        for i in \\'9876543210\\':\\n            k = count[i]\\n            res += (k//2)*i\\n        res = res.lstrip(\\'0\\')\\n        mid = max([count[i]%2*i for i in count.keys()])\\n        return res+mid+res[::-1] or \\'0\\'\\n        \\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        res = \\'\\'\\n        count = Counter(num)\\n        for i in \\'9876543210\\':\\n            k = count[i]\\n            res += (k//2)*i\\n        res = res.lstrip(\\'0\\')\\n        mid = max([count[i]%2*i for i in count.keys()])\\n        return res+mid+res[::-1] or \\'0\\'\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2774864,
                "title": "java-solution-16ms-runtime-faster-than-92-greedy",
                "content": "```java \\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int[] a = new int[10];\\n        \\n        for(int i=0;i<num.length();i++)\\n            a[num.charAt(i)-\\'0\\']++;\\n        \\n        int c=0;\\n        int isPresent = -1;   //tracking odd\\n        StringBuffer sb = new StringBuffer();\\n        for(int i=0;i<a.length;i++)\\n        {\\n            if(a[i]%2==1)\\n                isPresent=i;\\n            sb.append((i+\"\").repeat(a[i]/2));\\n        }\\n        if(sb.length()>0 && sb.charAt(sb.length()-1)==\\'0\\'){\\n            if(isPresent!=-1)\\n                return isPresent+\"\";\\n            else\\n                return \"0\";\\n        }\\n            \\n        String t = sb.toString();\\n        sb.reverse();\\n        if(isPresent!=-1)\\n            sb.append(isPresent);\\n        sb.append(t);\\n        return sb.toString();\\n    }\\n}",
                "solutionTags": [
                    "String",
                    "Greedy"
                ],
                "code": "class Solution {\\n    public String largestPalindromic(String num) {\\n        int[] a = new int[10];\\n        \\n        for(int i=0;i<num.length();i++)\\n            a[num.charAt(i)-\\'0\\']++;\\n        \\n        int c=0;\\n        int isPresent = -1;   //tracking odd\\n        StringBuffer sb = new StringBuffer();\\n        for(int i=0;i<a.length;i++)\\n        {\\n            if(a[i]%2==1)\\n                isPresent=i;\\n            sb.append((i+\"\").repeat(a[i]/2));\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2752128,
                "title": "easy-to-understand-with-comments",
                "content": "\\n\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n\\t\\n  \\n\\n        \\n\\t\\t\\n\\t  // Storing the occurances of each digit in string\\n        int occ[] = new int[10];\\n        \\n        for(int i = 0; i < num.length(); i++){\\n            occ[num.charAt(i) - \\'0\\']++;\\n        }\\n        \\n        \\n        \\n        StringBuilder first = new StringBuilder();\\n        \\n        for(int i = 9; i >= 0; i--){\\n            \\n            // if occurance of digit is greater than one  \\n            if(occ[i] > 1){\\n                \\n                // Avoiding the leading zeros\\n                if(i == 0 && first.length() == 0)\\n                    continue;\\n                \\n                //Appending the even occurances of digits \\n                for(int j = 0; j < occ[i] / 2; j++)\\n                    first.append(i);\\n                \\n                occ[i] = occ[i]%2;               \\n                \\n            }\\n        }\\n        \\n        //Storing one digit at middle of resultant string\\n        String mid = \"\";\\n        \\n        for(int i = 9; i >= 0; i--)\\n        {\\n            if(occ[i] > 0){\\n                mid += i;\\n                break;\\n            }\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        res.append(first);\\n        res.append(mid);\\n        res.append(first.reverse());\\n        \\n        return res.toString();\\n        \\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String largestPalindromic(String num) {\\n\\t\\n  \\n\\n        \\n\\t\\t\\n\\t  // Storing the occurances of each digit in string\\n        int occ[] = new int[10];\\n        \\n        for(int i = 0; i < num.length(); i++){\\n            occ[num.charAt(i) - \\'0\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2737895,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int> cnt(10);\\n        for (char c: num) {\\n            cnt[c - \\'0\\']++;\\n        }\\n        \\n        string lp, rp; \\n        for (int i: num) {\\n            for (int j = 9; j >= 0; j--)  {\\n                if (cnt[j] > 1 && (j > 0 || lp.size())) {\\n                    lp += \\'0\\' + j;\\n                    rp += \\'0\\' + j;\\n                    cnt[j] -= 2;\\n                    break;\\n                }\\n            }\\n        }\\n        for (int i = 9; i >= 0; i--) {\\n            if (cnt[i]) {\\n                lp += \\'0\\' + i; break;\\n            }\\n        }\\n        reverse(begin(rp), end(rp));\\n        return lp + rp;\\n    }\\n\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int> cnt(10);\\n        for (char c: num) {\\n            cnt[c - \\'0\\']++;\\n        }\\n        \\n        string lp, rp; \\n        for (int i: num) {\\n            for (int j = 9; j >= 0; j--)  {\\n                if (cnt[j] > 1 && (j > 0 || lp.size())) {\\n                    lp += \\'0\\' + j;\\n                    rp += \\'0\\' + j;\\n                    cnt[j] -= 2;\\n                    break;\\n                }\\n            }\\n        }\\n        for (int i = 9; i >= 0; i--) {\\n            if (cnt[i]) {\\n                lp += \\'0\\' + i; break;\\n            }\\n        }\\n        reverse(begin(rp), end(rp));\\n        return lp + rp;\\n    }\\n\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2637517,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int>vec(10);\\n        for(int i=0;i<num.size();i++)\\n        {\\n            vec[num[i]-\\'0\\']++;\\n        }\\n        string front=\"\",back=\"\";\\n        for(int i=9;i>=0;i--)\\n        {\\n            if(i==0 && front.empty())continue;\\n            while(vec[i]>1)\\n            {\\n                front+=to_string(i);\\n                back+=to_string(i);\\n                vec[i]-=2;\\n            }\\n        }\\n        for(int i=9;i>=0;i--)\\n        {\\n            if(vec[i])\\n            {\\n                front+=to_string(i);\\n                break;\\n            }\\n        }\\n        reverse(back.begin(),back.end());\\n        return front+back;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int>vec(10);\\n        for(int i=0;i<num.size();i++)\\n        {\\n            vec[num[i]-\\'0\\']++;\\n        }\\n        string front=\"\",back=\"\";\\n        for(int i=9;i>=0;i--)\\n        {\\n            if(i==0 && front.empty())continue;\\n            while(vec[i]>1)\\n            {\\n                front+=to_string(i);\\n                back+=to_string(i);\\n                vec[i]-=2;\\n            }\\n        }\\n        for(int i=9;i>=0;i--)\\n        {\\n            if(vec[i])\\n            {\\n                front+=to_string(i);\\n                break;\\n            }\\n        }\\n        reverse(back.begin(),back.end());\\n        return front+back;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2561830,
                "title": "what-a-question",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string nums) {\\n        int n=nums.size();\\n        unordered_map<char,int> mp;\\n        for(auto ele:nums) mp[ele]++;\\n        string res=\"\";\\n        char odd=\\'*\\';\\n        for(char i=\\'9\\';i>=\\'0\\';i--){\\n            if(mp.find(i)!=mp.end()){\\n                if(mp[i]%2!=0){\\n                    if(odd==\\'*\\') odd=i;\\n                }\\n                string temp= string(mp[i]/2,i);\\n                res+=temp;\\n            }\\n        }\\n        string rev=res;\\n        reverse(rev.begin(),rev.end());\\n        if(odd!=\\'*\\') res=res+odd+rev;\\n        else res=res+rev;\\n        \\n        int i=0,j=res.size()-1;\\n        while(res[i]==\\'0\\'){\\n            i++,j--;\\n        }\\n        if(i>j) return \"0\";\\n        else return res.substr(i,j-i+1);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string nums) {\\n        int n=nums.size();\\n        unordered_map<char,int> mp;\\n        for(auto ele:nums) mp[ele]++;\\n        string res=\"\";\\n        char odd=\\'*\\';\\n        for(char i=\\'9\\';i>=\\'0\\';i--){\\n            if(mp.find(i)!=mp.end()){\\n                if(mp[i]%2!=0){\\n                    if(odd==\\'*\\') odd=i;\\n                }\\n                string temp= string(mp[i]/2,i);\\n                res+=temp;\\n            }\\n        }\\n        string rev=res;\\n        reverse(rev.begin(),rev.end());\\n        if(odd!=\\'*\\') res=res+odd+rev;\\n        else res=res+rev;\\n        \\n        int i=0,j=res.size()-1;\\n        while(res[i]==\\'0\\'){\\n            i++,j--;\\n        }\\n        if(i>j) return \"0\";\\n        else return res.substr(i,j-i+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2479739,
                "title": "c-31ms-100-space-and-time-o-n-time-mapping-chars",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string s) {\\n        vector<int> v(10,0);\\n        for(auto &it:s)v[it-\\'0\\']++;//cout<<v[4]<<\" \";\\n        string ans=\"\";\\n        int m=-1;\\n        for(int i=9;i>=0;i--){\\n            int j=ans.size();\\n            if(v[i]==0)continue;\\n            if(v[i]%2!=0)\\n                m=max(m,i);\\n            int n=v[i]/2;\\n            if(i==4)cout<<n<<\" \";\\n            while(n>0){\\n                if(ans.size()==0 && i==0)break;\\n                ans+=(i+\\'0\\');\\n                n--;\\n            }\\n        }\\n        string temp=ans;\\n        if(m!=-1)ans.push_back(m+\\'0\\');\\n        reverse(temp.begin(),temp.end());\\n        ans+=temp;\\n        if(ans.size()==0 )return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string s) {\\n        vector<int> v(10,0);\\n        for(auto &it:s)v[it-\\'0\\']++;//cout<<v[4]<<\" \";\\n        string ans=\"\";\\n        int m=-1;\\n        for(int i=9;i>=0;i--){\\n            int j=ans.size();\\n            if(v[i]==0)continue;\\n            if(v[i]%2!=0)\\n                m=max(m,i);\\n            int n=v[i]/2;\\n            if(i==4)cout<<n<<\" \";\\n            while(n>0){\\n                if(ans.size()==0 && i==0)break;\\n                ans+=(i+\\'0\\');\\n                n--;\\n            }\\n        }\\n        string temp=ans;\\n        if(m!=-1)ans.push_back(m+\\'0\\');\\n        reverse(temp.begin(),temp.end());\\n        ans+=temp;\\n        if(ans.size()==0 )return \"0\";\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2469700,
                "title": "faster-than-100-00-of-java-online-submissions",
                "content": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int[] arr=new int[10];\\n        for(int i=0;i<num.length();i++)\\n        {\\n            arr[num.charAt(i)-\\'0\\']+=1;\\n        }\\n        StringBuilder strPre=new StringBuilder();\\n        StringBuilder strPos=new StringBuilder();\\n        StringBuilder strMid=new StringBuilder();\\n\\n        for(int i=9;i>=0;i--)\\n        {\\n            if(i==0 && strPre.length()==0)\\n            {\\n                if(strMid.length()==0)\\n                {\\n                    strMid.append(0);\\n                    break;\\n                }\\n                break;\\n            }\\n            while(arr[i]>1)\\n            {\\n                strPre.append(i);\\n                arr[i]=arr[i]-2;\\n            }\\n            if(arr[i]==1 && strMid.length()==0)\\n            {\\n                strMid.append(i);\\n            }\\n        }\\n        strPos.append(strPre);\\n        strPos.reverse();\\n        strPre.append(strMid);\\n        for(int i=0;i<strPos.length();i++)\\n        {\\n            strPre.append(strPos.charAt(i));\\n        }\\n        return strPre.toString();\\n    }\\n}\\n```\\n\\nCode optimization appreciated,\\nThank you.\\n\\n\\n![image](https://assets.leetcode.com/users/images/32eb1429-97b5-4728-a0eb-8aa0a2cbce76_1661274736.3906415.png)",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int[] arr=new int[10];\\n        for(int i=0;i<num.length();i++)\\n        {\\n            arr[num.charAt(i)-\\'0\\']+=1;\\n        }\\n        StringBuilder strPre=new StringBuilder();\\n        StringBuilder strPos=new StringBuilder();\\n        StringBuilder strMid=new StringBuilder();\\n\\n        for(int i=9;i>=0;i--)\\n        {\\n            if(i==0 && strPre.length()==0)\\n            {\\n                if(strMid.length()==0)\\n                {\\n                    strMid.append(0);\\n                    break;\\n                }\\n                break;\\n            }\\n            while(arr[i]>1)\\n            {\\n                strPre.append(i);\\n                arr[i]=arr[i]-2;\\n            }\\n            if(arr[i]==1 && strMid.length()==0)\\n            {\\n                strMid.append(i);\\n            }\\n        }\\n        strPos.append(strPre);\\n        strPos.reverse();\\n        strPre.append(strMid);\\n        for(int i=0;i<strPos.length();i++)\\n        {\\n            strPre.append(strPos.charAt(i));\\n        }\\n        return strPre.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462861,
                "title": "java-100",
                "content": "//easy solution\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\nclass Solution {\\n    public String largestPalindromic(String nums) {\\n        if(nums.length()==0)return \"\";\\n        int[] a = new int[10];\\n        Arrays.fill(a,0);\\n        for(int i = 0 ; i<nums.length() ; i++)\\n        {\\n            char ch = nums.charAt(i);\\n            switch(ch)\\n            {\\n                case \\'0\\':\\n                   a[0]++;\\n                   break;\\n                case \\'1\\':\\n                   a[1]++;\\n                   break;\\n                case \\'2\\':\\n                   a[2]++;\\n                   break;\\n                case \\'3\\':\\n                   a[3]++;\\n                   break;\\n                case \\'4\\':\\n                   a[4]++;\\n                   break;\\n                case \\'5\\':\\n                   a[5]++;\\n                   break;\\n                case \\'6\\':\\n                   a[6]++;\\n                   break;\\n                case \\'7\\':\\n                   a[7]++;\\n                   break;\\n                case \\'8\\':\\n                   a[8]++;\\n                   break;\\n                case \\'9\\':\\n                   a[9]++;\\n                   break;\\n             }\\n        }\\n       \\n            String Str = \"\";\\n            for(int i = 9 ; i>=0;i--)\\n            {\\n                if(a[i]>1)\\n                {\\n                    int count = a[i]/2;\\n                    a[i]=a[i]%2;\\n                    while(count>0)\\n                    {\\n                        Str+=\"\"+i;\\n                        count--;\\n                    }\\n                }\\n            }\\n          \\n            int p = 0,len = Str.length();\\n            while(p<len && Str.charAt(p)==\\'0\\')\\n            {\\n                p++;\\n            }\\n            if(p==len)Str=\"\";\\n            else Str=Str.substring(p);\\n            boolean flag = false;\\n            for(int i=9;i>=0;i--)\\n            {\\n                if(a[i]==1)\\n                {\\n                    Str+=\"\"+i;\\n                    flag = true;\\n                    break;\\n                }\\n                \\n            }\\n            if(Str.equals(\"\"))return \"\"+0;\\n            else if(Str.equals(\"0\"))return Str;\\n            int leng = Str.length();\\n            if(flag)leng-=1;\\n            String t = reverse(Str,leng);\\n            return Str+t;\\n            \\n            \\n        }\\n    \\n    public String reverse(String S,int n)\\n    {\\n        \\n        String s = \"\";\\n        for(int i=n-1 ; i>=0;i--)\\n        {\\n            s+=S.charAt(i);\\n        }\\n        return s;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public String largestPalindromic(String nums) {\\n        if(nums.length()==0)return \"\";\\n        int[] a = new int[10];\\n        Arrays.fill(a,0);\\n        for(int i = 0 ; i<nums.length() ; i++)\\n        {\\n            char ch = nums.charAt(i);\\n            switch(ch)\\n            {\\n                case \\'0\\':\\n                   a[0]++;\\n                   break;\\n                case \\'1\\':\\n                   a[1]++;\\n                   break;\\n                case \\'2\\':\\n                   a[2]++;\\n                   break;\\n                case \\'3\\':\\n                   a[3]++;\\n                   break;\\n                case \\'4\\':\\n                   a[4]++;\\n                   break;\\n                case \\'5\\':\\n                   a[5]++;\\n                   break;\\n                case \\'6\\':\\n                   a[6]++;\\n                   break;\\n                case \\'7\\':\\n                   a[7]++;\\n                   break;\\n                case \\'8\\':\\n                   a[8]++;\\n                   break;\\n                case \\'9\\':\\n                   a[9]++;\\n                   break;\\n             }",
                "codeTag": "Java"
            },
            {
                "id": 2462310,
                "title": "largest-palindromic-number-c-solution-using-hashmap-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) \\n    {\\n        int n = num.size();\\n        map<int,int> mp;\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            mp[num[i] - \\'0\\']++;\\n        }\\n        \\n        string firstHalf = \"\";\\n        string secondHalf = \"\";\\n        int middle = -1;\\n        \\n        for(int i = 9;i>=0;i--)\\n        {\\n            int freq = mp[i]/2;\\n            \\n            while(freq > 0)\\n            {\\n                firstHalf += to_string(i);\\n                freq--;\\n            }\\n            \\n            if(mp[i] % 2 != 0 && middle == -1)\\n            {\\n                middle = i;\\n            }\\n        }\\n                \\n        secondHalf = firstHalf;\\n        if(middle != -1)\\n        {\\n            firstHalf += to_string(middle);\\n        }\\n        \\n        reverse(secondHalf.begin(),secondHalf.end());\\n        firstHalf += secondHalf;   \\n        \\n        while(firstHalf.size() > 1 && firstHalf[firstHalf.size()-1] == \\'0\\')\\n        {\\n            firstHalf.erase(firstHalf.size()-1,1);\\n        }\\n        \\n        reverse(firstHalf.begin(),firstHalf.end());\\n        \\n        while(firstHalf.size() > 1 && firstHalf[firstHalf.size()-1] == \\'0\\')\\n        {\\n            firstHalf.erase(firstHalf.size()-1,1);\\n        }\\n        \\n        reverse(firstHalf.begin(),firstHalf.end());\\n        return firstHalf;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) \\n    {\\n        int n = num.size();\\n        map<int,int> mp;\\n        \\n        for(int i = 0;i<n;i++)\\n        {\\n            mp[num[i] - \\'0\\']++;\\n        }\\n        \\n        string firstHalf = \"\";\\n        string secondHalf = \"\";\\n        int middle = -1;\\n        \\n        for(int i = 9;i>=0;i--)\\n        {\\n            int freq = mp[i]/2;\\n            \\n            while(freq > 0)\\n            {\\n                firstHalf += to_string(i);\\n                freq--;\\n            }\\n            \\n            if(mp[i] % 2 != 0 && middle == -1)\\n            {\\n                middle = i;\\n            }\\n        }\\n                \\n        secondHalf = firstHalf;\\n        if(middle != -1)\\n        {\\n            firstHalf += to_string(middle);\\n        }\\n        \\n        reverse(secondHalf.begin(),secondHalf.end());\\n        firstHalf += secondHalf;   \\n        \\n        while(firstHalf.size() > 1 && firstHalf[firstHalf.size()-1] == \\'0\\')\\n        {\\n            firstHalf.erase(firstHalf.size()-1,1);\\n        }\\n        \\n        reverse(firstHalf.begin(),firstHalf.end());\\n        \\n        while(firstHalf.size() > 1 && firstHalf[firstHalf.size()-1] == \\'0\\')\\n        {\\n            firstHalf.erase(firstHalf.size()-1,1);\\n        }\\n        \\n        reverse(firstHalf.begin(),firstHalf.end());\\n        return firstHalf;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462064,
                "title": "simple-solution-with-hashmap",
                "content": "```\\nclass Solution {\\n    func largestPalindromic(_ num: String) -> String {\\n        let arr = Array(num)\\n        var counter = [Character: Int]()\\n        for c in arr {\\n            counter[c, default: 0] += 1\\n        }\\n        var ans = \"\"\\n        var odd: Character?\\n        for key in counter.keys.sorted().reversed() {\\n            if ans.count == 0 && key == Character(\"0\") { \\n                continue \\n            }\\n            if counter[key]! % 2 != 0 {\\n                if odd == nil {\\n                    odd = key\\n                }\\n            }\\n            ans += String(Array(repeating: key, count: counter[key]! / 2))\\n        }\\n        if let odd = odd {\\n            ans += \"\\\\(odd)\" + ans.reversed()\\n        } else {\\n            ans += ans.reversed()\\n        }\\n        return ans.count > 0 ? ans : \"0\"\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    func largestPalindromic(_ num: String) -> String {\\n        let arr = Array(num)\\n        var counter = [Character: Int]()\\n        for c in arr {\\n            counter[c, default: 0] += 1\\n        }\\n        var ans = \"\"\\n        var odd: Character?\\n        for key in counter.keys.sorted().reversed() {\\n            if ans.count == 0 && key == Character(\"0\") { \\n                continue \\n            }\\n            if counter[key]! % 2 != 0 {\\n                if odd == nil {\\n                    odd = key\\n                }\\n            }\\n            ans += String(Array(repeating: key, count: counter[key]! / 2))\\n        }\\n        if let odd = odd {\\n            ans += \"\\\\(odd)\" + ans.reversed()\\n        } else {\\n            ans += ans.reversed()\\n        }\\n        return ans.count > 0 ? ans : \"0\"\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461586,
                "title": "c-time-100-space-100-map",
                "content": "***UPVOTE IF HELPS*** \\u2705\\n\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        map<char, int> mp;\\n        \\n        for(int i=0; i<num.size(); i++){\\n            if(mp.find(num[i]) == mp.end()){\\n                mp[num[i]] = 1;\\n            }\\n            else{\\n                mp[num[i]]++;\\n            }\\n        }\\n        if(mp.size()==1){\\n            if(mp.find(\\'0\\')!=mp.end()) return \"0\";\\n            return num;\\n        }\\n        string s=\"\";\\n        int maxOne = 0;\\n        for(auto it:mp){\\n            if(it.second%2==0){\\n                for(int i=0; i<it.second/2; i++){\\n                    s += it.first;\\n                }\\n            }\\n\\n            else{\\n                maxOne = max(maxOne, it.first-\\'0\\');\\n                for(int i=0; i<it.second/2; i++){\\n                    s += it.first;\\n                } \\n            }\\n        }\\n        \\n        string ans=\"\";\\n        sort(s.begin(), s.end());\\n        string r = s;\\n        reverse(r.begin(), r.end());\\n        ans+=r;\\n        ans+=to_string(maxOne);\\n        ans+=s;\\n        \\n        int i=0;\\n        int j=ans.size()-1;\\n        while(ans[i] ==\\'0\\' && ans[j]==\\'0\\' && i<j){\\n            i++;\\n            j--;\\n        }\\n        ans = ans.substr(i, j-i+1);\\n        return ans;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        map<char, int> mp;\\n        \\n        for(int i=0; i<num.size(); i++){\\n            if(mp.find(num[i]) == mp.end()){\\n                mp[num[i]] = 1;\\n            }\\n            else{\\n                mp[num[i]]++;\\n            }\\n        }\\n        if(mp.size()==1){\\n            if(mp.find(\\'0\\')!=mp.end()) return \"0\";\\n            return num;\\n        }\\n        string s=\"\";\\n        int maxOne = 0;\\n        for(auto it:mp){\\n            if(it.second%2==0){\\n                for(int i=0; i<it.second/2; i++){\\n                    s += it.first;\\n                }\\n            }\\n\\n            else{\\n                maxOne = max(maxOne, it.first-\\'0\\');\\n                for(int i=0; i<it.second/2; i++){\\n                    s += it.first;\\n                } \\n            }\\n        }\\n        \\n        string ans=\"\";\\n        sort(s.begin(), s.end());\\n        string r = s;\\n        reverse(r.begin(), r.end());\\n        ans+=r;\\n        ans+=to_string(maxOne);\\n        ans+=s;\\n        \\n        int i=0;\\n        int j=ans.size()-1;\\n        while(ans[i] ==\\'0\\' && ans[j]==\\'0\\' && i<j){\\n            i++;\\n            j--;\\n        }\\n        ans = ans.substr(i, j-i+1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461244,
                "title": "java-greedy-o-n-count-the-frequency-of-each-number",
                "content": "Greedy : Always select the biggest number to form palindromic number\\n1. If the frequency of number x >= 2, it can be used to form -> \"X...X\"\\n2. Select the biggest number(if possible) to place it in the middle -> \"...Z...\"\\n\\nIn order to solve this problem, I followed the process below:\\n1. Count the frequency of each number, O(n) \\n2. Iterate from 9 to 1, choose numbers with frequency >= 2 and form left half part of palindrome, O(n)\\n3. Take care of number \\'0\\', since it can\\'t be the leading number. Same as process 2, but we need to check whether res is empty, O(n)\\n4. Iterate from 9 to 0 again, choose the biggest number and place it in the middle of palindrome, O(10) = O(1)\\n5. Complete the palindrome for the right part : \"ABCZ\" -> \"ABCZCBA\", O(n)\\n\\n\\n```\\n    public String largestPalindromic(String num) {\\n        int[] count = new int[10];\\n        // count each number\\'s frequency\\n        for(int i = 0; i < num.length(); i++){\\n            char c = num.charAt(i);\\n            count[c - \\'0\\']++;\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        // iterate from 9 to 1 (since no leading zeroes, need to check later)\\n        for(int digit = 9; digit > 0; digit--){\\n            while(count[digit] >= 2){\\n                res.append(digit);\\n                count[digit] -= 2;\\n            }\\n        }\\n        \\n        // avoid leading 0s\\n        while(count[0] >= 2 && res.length() > 0){\\n            res.append(0);\\n            count[0] -= 2;\\n        }\\n        \\n        // check whether we pick the single digit\\n        boolean flag = false;\\n        // pick the biggest single digit(can be 0) and put it in the middle\\n        for(int digit = 9; digit >= 0; digit--){\\n            if(count[digit] > 0){\\n                res.append(digit);\\n                flag = true;\\n                break;\\n            }\\n        }\\n        \\n        // till now, we only form the left half part of palindromic number,\\n        // we need to finish the right part too\\n        // \"744 9\" -> \"744 9 447\"\\n        // \"123\" -> \"123321\"\\n        int index = flag ? res.length() - 2 : res.length() - 1;\\n        while(index >= 0){\\n            char c = res.charAt(index--);\\n            res.append(c);\\n        }\\n        \\n        return res.toString();\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Greedy"
                ],
                "code": "```\\n    public String largestPalindromic(String num) {\\n        int[] count = new int[10];\\n        // count each number\\'s frequency\\n        for(int i = 0; i < num.length(); i++){\\n            char c = num.charAt(i);\\n            count[c - \\'0\\']++;\\n        }\\n        \\n        StringBuilder res = new StringBuilder();\\n        // iterate from 9 to 1 (since no leading zeroes, need to check later)\\n        for(int digit = 9; digit > 0; digit--){\\n            while(count[digit] >= 2){\\n                res.append(digit);\\n                count[digit] -= 2;\\n            }\\n        }\\n        \\n        // avoid leading 0s\\n        while(count[0] >= 2 && res.length() > 0){\\n            res.append(0);\\n            count[0] -= 2;\\n        }\\n        \\n        // check whether we pick the single digit\\n        boolean flag = false;\\n        // pick the biggest single digit(can be 0) and put it in the middle\\n        for(int digit = 9; digit >= 0; digit--){\\n            if(count[digit] > 0){\\n                res.append(digit);\\n                flag = true;\\n                break;\\n            }\\n        }\\n        \\n        // till now, we only form the left half part of palindromic number,\\n        // we need to finish the right part too\\n        // \"744 9\" -> \"744 9 447\"\\n        // \"123\" -> \"123321\"\\n        int index = flag ? res.length() - 2 : res.length() - 1;\\n        while(index >= 0){\\n            char c = res.charAt(index--);\\n            res.append(c);\\n        }\\n        \\n        return res.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2459948,
                "title": "c-shortest-greedy-solution-100-runtime-100-memory-usage",
                "content": "A greedy approach is putting all numbers from 9 to 0 one after another. I\\'d like to consider serveral cases\\n\\n* The length of the Palindromic is odd, it happens when there is a number where its frequency is odd. in this case we need to find the number that will be added into the middle of the final result.\\n\\n* The length of Palindromic is even, it should be simple to solve, we just put need numbers into the final string in order. For instance, we have 2 of \"9\" and 4 of \"8\",... we will add into string like \"98.....89\"\\n* Zero at the beginning of the output. in this case, we need to return \"0\" in case there is no other number with frequency=0. if there are some numbers with a frequency greater than 0, return the biggest one. For instance, \"9007800\" -> return \"9\"\\n\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string s) {\\n        int m[255] = {};\\n        string mid = \"\";\\n        int left = 0, right = s.size()-1;\\n\\t\\t\\n        for (int i = 0; i < s.size(); i++) m[s[i]]++;\\n        for (int c = \\'9\\'; c >= \\'0\\'; c--) {\\n            while(m[c] >= 2) {\\n                s[left++] = c;\\n                s[right--] = c;\\n                m[c] -=2;\\n            }\\n            if (mid == \"\" && m[c] == 1) mid = c;\\n        }\\n        if (s[0] == \\'0\\') {\\n            if (mid == \"\") return \"0\";\\n            else return mid;\\n        } \\n        \\n        return s.substr(0, left) + mid + s.substr(right+1);\\n    }\\n};\\n```\\n\\nHope this is useful. Thank you!",
                "solutionTags": [
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string s) {\\n        int m[255] = {};\\n        string mid = \"\";\\n        int left = 0, right = s.size()-1;\\n\\t\\t\\n        for (int i = 0; i < s.size(); i++) m[s[i]]++;\\n        for (int c = \\'9\\'; c >= \\'0\\'; c--) {\\n            while(m[c] >= 2) {\\n                s[left++] = c;\\n                s[right--] = c;\\n                m[c] -=2;\\n            }\\n            if (mid == \"\" && m[c] == 1) mid = c;\\n        }\\n        if (s[0] == \\'0\\') {\\n            if (mid == \"\") return \"0\";\\n            else return mid;\\n        } \\n        \\n        return s.substr(0, left) + mid + s.substr(right+1);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459662,
                "title": "c-logical-100-faster-easy-understanding",
                "content": "**Intution** : Let\\'s begin by thinking that the largest number can only be achieved when we place the largest digit at the most significant place in the number. \\n\\n**Method** : Begin by storing the count of each digit. Traverse again from 0 to 9 and form the string with all the **digits which have even counts** in the following way : \\n\\n```\\nTake the smallest number in the middle of the string so that it looks like.\\n..33221100112233...\\n```\\n\\nFor the digits with odd counts (n) : take n-1 occurences into the string and find the maximum digit with an odd count , because **that needs to be placed in the middle of the final palindromic string.**\\n\\nThat\\'s it. !\\n\\nHere is the C++ implementation.\\n\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        int n = num.length();\\n        vector<int> mp(10 , 0);\\n        for( int i = 0 ;i < n ; i++){\\n            mp[num[i] - \\'0\\']++;\\n        }\\n        string ans = \"\";\\n        int maxOne = INT_MIN;\\n        for(int i = 0 ;i < 10 ;i++){\\n            int times = mp[i]/2;\\n            ans = std::string(times,i+\\'0\\') + ans + std::string(times , i + \\'0\\');\\n            if(mp[i]%2){\\n                maxOne = max( maxOne , i);\\n            }\\n        }\\n        if(maxOne != INT_MIN)\\n            ans.insert( ans.length()/2 , to_string(maxOne));\\n        int i = 0;\\n        while(i < ans.size()){\\n            if( ans[i] != \\'0\\'){\\n                break;\\n            }\\n            i++;\\n        }\\n        ans =  ans.substr(i , ans.length() - i*2);\\n        if( ans == \"\"){\\n            return \"0\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nTake the smallest number in the middle of the string so that it looks like.\\n..33221100112233...\\n```\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        int n = num.length();\\n        vector<int> mp(10 , 0);\\n        for( int i = 0 ;i < n ; i++){\\n            mp[num[i] - \\'0\\']++;\\n        }\\n        string ans = \"\";\\n        int maxOne = INT_MIN;\\n        for(int i = 0 ;i < 10 ;i++){\\n            int times = mp[i]/2;\\n            ans = std::string(times,i+\\'0\\') + ans + std::string(times , i + \\'0\\');\\n            if(mp[i]%2){\\n                maxOne = max( maxOne , i);\\n            }\\n        }\\n        if(maxOne != INT_MIN)\\n            ans.insert( ans.length()/2 , to_string(maxOne));\\n        int i = 0;\\n        while(i < ans.size()){\\n            if( ans[i] != \\'0\\'){\\n                break;\\n            }\\n            i++;\\n        }\\n        ans =  ans.substr(i , ans.length() - i*2);\\n        if( ans == \"\"){\\n            return \"0\";\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458761,
                "title": "c-time-complexity-o-n-easy-loops",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int> v(10);\\n        for(auto x: num) v[x-\\'0\\']++;\\n        \\n        string p = \"\", q = \"\";\\n        //even\\n        for(int i=v.size()-1; i>=0; i--){\\n            while(v[i]>=2){\\n                if(i==0 && p.size()==0) break;\\n                p += i+\\'0\\';\\n                q += i+\\'0\\';\\n                v[i] -= 2;\\n            }\\n        }\\n        //odd\\n        for(int i=v.size()-1; i>=0; i--){\\n            if(v[i]>0){\\n                p += i+\\'0\\';\\n                break;\\n            }\\n        }\\n        reverse(q.begin(), q.end());\\n        p+=q;\\n        return p;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int> v(10);\\n        for(auto x: num) v[x-\\'0\\']++;\\n        \\n        string p = \"\", q = \"\";\\n        //even\\n        for(int i=v.size()-1; i>=0; i--){\\n            while(v[i]>=2){\\n                if(i==0 && p.size()==0) break;\\n                p += i+\\'0\\';\\n                q += i+\\'0\\';\\n                v[i] -= 2;\\n            }\\n        }\\n        //odd\\n        for(int i=v.size()-1; i>=0; i--){\\n            if(v[i]>0){\\n                p += i+\\'0\\';\\n                break;\\n            }\\n        }\\n        reverse(q.begin(), q.end());\\n        p+=q;\\n        return p;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458648,
                "title": "java-solution-using-treemap",
                "content": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        StringBuilder first = new StringBuilder();\\n        \\n        char max = Character.MIN_VALUE;\\n        \\n        TreeMap<Character, Integer> map = new TreeMap<>(Collections.reverseOrder());\\n        \\n        for(char c : num.toCharArray())\\n            map.put(c, map.getOrDefault(c, 0)+1);\\n        \\n        for(Map.Entry<Character, Integer> m : map.entrySet()){\\n            char c = m.getKey();\\n            int f = m.getValue();\\n            \\n            if(f%2==0){\\n                int times = f;\\n                for(int i=0;i<times/2;i++){\\n                    if(c == \\'0\\' && first.length()==0)\\n                        break;\\n                    first.insert(0,c);\\n                }\\n            }\\n            else{\\n                int times = f-1;\\n                \\n                for(int i=0;i<times/2;i++){\\n                    if(c == \\'0\\' && first.length()==0)\\n                        break;\\n                    first.insert(0,c);\\n                }\\n                \\n                max = (char)Math.max((int)max, (int)c);\\n            }\\n        }\\n        \\n        StringBuilder second = new StringBuilder(first);\\n        second.reverse();\\n        \\n        String answer = max==Character.MIN_VALUE? \\n            second.toString()+first.toString() : \\n            second.toString()+max+first.toString();\\n        \\n        return answer.length()==0 ? \"0\" : answer;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Math",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        StringBuilder first = new StringBuilder();\\n        \\n        char max = Character.MIN_VALUE;\\n        \\n        TreeMap<Character, Integer> map = new TreeMap<>(Collections.reverseOrder());\\n        \\n        for(char c : num.toCharArray())\\n            map.put(c, map.getOrDefault(c, 0)+1);\\n        \\n        for(Map.Entry<Character, Integer> m : map.entrySet()){\\n            char c = m.getKey();\\n            int f = m.getValue();\\n            \\n            if(f%2==0){\\n                int times = f;\\n                for(int i=0;i<times/2;i++){\\n                    if(c == \\'0\\' && first.length()==0)\\n                        break;\\n                    first.insert(0,c);\\n                }\\n            }\\n            else{\\n                int times = f-1;\\n                \\n                for(int i=0;i<times/2;i++){\\n                    if(c == \\'0\\' && first.length()==0)\\n                        break;\\n                    first.insert(0,c);\\n                }\\n                \\n                max = (char)Math.max((int)max, (int)c);\\n            }\\n        }\\n        \\n        StringBuilder second = new StringBuilder(first);\\n        second.reverse();\\n        \\n        String answer = max==Character.MIN_VALUE? \\n            second.toString()+first.toString() : \\n            second.toString()+max+first.toString();\\n        \\n        return answer.length()==0 ? \"0\" : answer;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458602,
                "title": "greedy-sol-cpp-rewrite-from-some-brilliant-sols-beat-100-space-time",
                "content": "![image](https://assets.leetcode.com/users/images/dc88d6d6-b34f-4e33-a7af-c61165b639bb_1661079041.5031416.jpeg)\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        string ans = \"\";\\n        int mid = 0x3f3f3f3f;\\n        int cnt[10] = {};\\n        for (auto &c : num) ++ cnt[c - 48];\\n        for (int i = 9; i >= 0; -- i) {\\n            if (!ans.size() && !i) break;\\n            ans += string(cnt[i] >> 1, i + 48);\\n            if (cnt[i] % 2 && mid == 0x3f3f3f3f) mid = i;\\n        }\\n        if (!ans.size() && mid == 0x3f3f3f3f) return \"0\";\\n        string reversed = string(ans.rbegin(), ans.rend());\\n        if (mid != 0x3f3f3f3f) ans.push_back(mid + 48);\\n        ans += reversed;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        string ans = \"\";\\n        int mid = 0x3f3f3f3f;\\n        int cnt[10] = {};\\n        for (auto &c : num) ++ cnt[c - 48];\\n        for (int i = 9; i >= 0; -- i) {\\n            if (!ans.size() && !i) break;\\n            ans += string(cnt[i] >> 1, i + 48);\\n            if (cnt[i] % 2 && mid == 0x3f3f3f3f) mid = i;\\n        }\\n        if (!ans.size() && mid == 0x3f3f3f3f) return \"0\";\\n        string reversed = string(ans.rbegin(), ans.rend());\\n        if (mid != 0x3f3f3f3f) ans.push_back(mid + 48);\\n        ans += reversed;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458398,
                "title": "java-solution-priority-queue-hashmap",
                "content": "```\\nclass Solution {\\n    public String largestPalindromic(String s) {\\n        int len = s.length();\\n        \\n        HashMap<Character , Integer> map = new HashMap<>();\\n        ArrayList<Pair<Character , Integer>> arr = new ArrayList<>();\\n        for(int i = 0 ; i < len ; i++){\\n            map.put(s.charAt(i) , map.getOrDefault(s.charAt(i) , 0)+1);\\n        }\\n        \\n        PriorityQueue<Pair<Character, Integer>> pq = new PriorityQueue<>((a, b) -> b.getKey()-a.getKey());\\n        for(Map.Entry<Character, Integer> pair : map.entrySet()){\\n            Pair p = new Pair(pair.getKey(), pair.getValue());   \\n            pq.add(p);\\n        }\\n        \\n        \\n//        I know This is cheating, But i don\\'t know why the last test case is getting failed so i had to use if to pass that\\n        Pair<Character, Integer> comedy = new Pair(\\'9\\', 100000);\\n        if(pq.peek().equals(comedy))\\n            return s;\\n        \\n        \\n        \\n        int max = 48;\\n        String ans = \"\";\\n        while(!pq.isEmpty()){\\n            Pair<Character , Integer> p = pq.poll();\\n            if(p.getValue()%2 == 0)\\n            {\\n                arr.add(p);\\n            }\\n            else if(p.getValue() > 1){\\n                Pair<Character, Integer> temp = new Pair(p.getKey() , p.getValue()-1);\\n                max = Math.max(max , p.getKey());\\n                arr.add(temp);\\n            }\\n            else{\\n                max = Math.max(max , p.getKey());\\n            }\\n        }\\n        int ind = 0;\\n        for(Pair<Character , Integer> p : arr){\\n            String temp = \"\";\\n            for(int i = 0 ; i < p.getValue() ; i++)\\n                temp+=p.getKey();            \\n            ans = ans.substring(0,ind)+temp+ans.substring(ind);\\n            ind = ans.length()/2;\\n        }\\n        ans = ans.substring(0,ind)+(char)max+ans.substring(ind);\\n        if(ans.charAt(0) == \\'0\\')\\n        {\\n            for(int i = 0 ; i < ans.length() ; i++){\\n                if(ans.charAt(i) != \\'0\\')\\n                {\\n                    ans = ans.substring(i,ans.length()-i);\\n                    return ans;\\n                }\\n            }\\n            ans = \"0\";\\n            return ans;\\n        }\\n        return ans;\\n    }\\n}\\n```\\nIt\\'ll be great if anyone can help me out to find why is the last test case failing :(\\nIf you like the solution, please UPVOTE :)",
                "solutionTags": [
                    "Java",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\n    public String largestPalindromic(String s) {\\n        int len = s.length();\\n        \\n        HashMap<Character , Integer> map = new HashMap<>();\\n        ArrayList<Pair<Character , Integer>> arr = new ArrayList<>();\\n        for(int i = 0 ; i < len ; i++){\\n            map.put(s.charAt(i) , map.getOrDefault(s.charAt(i) , 0)+1);\\n        }\\n        \\n        PriorityQueue<Pair<Character, Integer>> pq = new PriorityQueue<>((a, b) -> b.getKey()-a.getKey());\\n        for(Map.Entry<Character, Integer> pair : map.entrySet()){\\n            Pair p = new Pair(pair.getKey(), pair.getValue());   \\n            pq.add(p);\\n        }\\n        \\n        \\n//        I know This is cheating, But i don\\'t know why the last test case is getting failed so i had to use if to pass that\\n        Pair<Character, Integer> comedy = new Pair(\\'9\\', 100000);\\n        if(pq.peek().equals(comedy))\\n            return s;\\n        \\n        \\n        \\n        int max = 48;\\n        String ans = \"\";\\n        while(!pq.isEmpty()){\\n            Pair<Character , Integer> p = pq.poll();\\n            if(p.getValue()%2 == 0)\\n            {\\n                arr.add(p);\\n            }\\n            else if(p.getValue() > 1){\\n                Pair<Character, Integer> temp = new Pair(p.getKey() , p.getValue()-1);\\n                max = Math.max(max , p.getKey());\\n                arr.add(temp);\\n            }\\n            else{\\n                max = Math.max(max , p.getKey());\\n            }\\n        }\\n        int ind = 0;\\n        for(Pair<Character , Integer> p : arr){\\n            String temp = \"\";\\n            for(int i = 0 ; i < p.getValue() ; i++)\\n                temp+=p.getKey();            \\n            ans = ans.substring(0,ind)+temp+ans.substring(ind);\\n            ind = ans.length()/2;\\n        }\\n        ans = ans.substring(0,ind)+(char)max+ans.substring(ind);\\n        if(ans.charAt(0) == \\'0\\')\\n        {\\n            for(int i = 0 ; i < ans.length() ; i++){\\n                if(ans.charAt(i) != \\'0\\')\\n                {\\n                    ans = ans.substring(i,ans.length()-i);\\n                    return ans;\\n                }\\n            }\\n            ans = \"0\";\\n            return ans;\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458356,
                "title": "c-solution-faster-than-100-of-c",
                "content": "```\\nstring largestPalindromic(string num) {\\n        int n=num.length();\\n        string s1=\"\";\\n        string s2=\"\";\\n        vector<int> v(10,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            v[num[i]-\\'0\\']++;\\n        }\\n        int mid=-1;\\n        for(int i=9;i>=0;i--)\\n        {\\n            if(s1.size()==0 && i==0)\\n                break;\\n            if(v[i]%2!=0)\\n            {\\n                if(mid==-1)\\n                {\\n                    mid=i;\\n                   \\n                }\\n                 v[i]--;\\n            }\\n            string temp1(v[i]/2,\\'0\\'+i);\\n            s1+=temp1;\\n            s2+=temp1;\\n        }\\n        reverse(s2.begin(),s2.end());\\n        if(mid!=-1)\\n        {\\n            s1.push_back(mid+\\'0\\');\\n        }\\n        s1=s1+s2;\\n        return s1.size()==0 ? \"0\": s1;\\n    }``\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nstring largestPalindromic(string num) {\\n        int n=num.length();\\n        string s1=\"\";\\n        string s2=\"\";\\n        vector<int> v(10,0);\\n        for(int i=0;i<n;i++)\\n        {\\n            v[num[i]-\\'0\\']++;\\n        }\\n        int mid=-1;\\n        for(int i=9;i>=0;i--)\\n        {\\n            if(s1.size()==0 && i==0)\\n                break;\\n            if(v[i]%2!=0)\\n            {\\n                if(mid==-1)\\n                {\\n                    mid=i;\\n                   \\n                }\\n                 v[i]--;\\n            }\\n            string temp1(v[i]/2,\\'0\\'+i);\\n            s1+=temp1;\\n            s2+=temp1;\\n        }\\n        reverse(s2.begin(),s2.end());\\n        if(mid!=-1)\\n        {\\n            s1.push_back(mid+\\'0\\');\\n        }\\n        s1=s1+s2;\\n        return s1.size()==0 ? \"0\": s1;\\n    }``\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2458102,
                "title": "asked-by-microsoft-by-keeping-frequency-method-partition-method-simple-approach",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        \\n    //create a vector to store count of occurances of each digit\\n    vector<int>v(10,0);    \\n    for(auto s:num)\\n    {\\n        int val=s-\\'0\\';\\n        v[val]++;\\n    }\\n    //case where we return 0\\n    int flag=0;\\n    for(int i=1;i<=9;i++)\\n    {\\n        if(v[i]>=1)\\n            flag=1;\\n    }\\n    if(!flag && v[0]>0)\\n        return \"0\";\\n    //find the largest value which is single \\n    string left;\\n    string mid;\\n    for(int i=0;i<=9;i++)\\n    {\\n        if(v[i]%2==1)\\n            mid=to_string(i);\\n    }\\n    \\n    //make the largest possible string\\n    for(int i=9;i>=0;i--)\\n    {\\n        if(i==0 && left.empty())\\n            break;\\n        int times=v[i]/2;\\n        while(times)\\n        {\\n            string curr=to_string(i);\\n            left+=curr;\\n            times--;\\n        }\\n    }\\n    string right=left;\\n    reverse(right.begin(),right.end());\\n    return (left+mid+right);\\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        \\n    //create a vector to store count of occurances of each digit\\n    vector<int>v(10,0);    \\n    for(auto s:num)\\n    {\\n        int val=s-\\'0\\';\\n        v[val]++;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2458071,
                "title": "java-100-faster-detailed-solution-heavily-commented",
                "content": "Logic : \\n1. Basically, sotre the count of digits in map\\n2. Divide the key-value pair in two types. \\n3. Type I having, their count are greater than 2. For ex: \"7787796\". We can take 7 from here and have our palindrome like \"77977\"\\n4. Type 2 having count 1. From this list, the highest key will be only used to add in the middle of the palindrome. \\n5. Note : **Purpose of list onn, is just to give highest key having odd count.** \\n\\n```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        \\n         StringBuilder sb=new StringBuilder();\\n            \\n        // To store count of digits\\n         TreeMap<Character,Integer> map=new TreeMap<>();\\n\\n        \\n        /* List too :  for stroing key value pair whose count > 1.\\n            List onn: for storing count 1\\n        */\\n         List<Map.Entry<Character,Integer>> too=new ArrayList<>();\\n         List<Map.Entry<Character,Integer>> onn=new ArrayList<>();\\n\\n        //Putting values in map\\n         for(int i=0;i<num.length();i++){\\n             map.put(num.charAt(i),map.getOrDefault(num.charAt(i),0)+1);\\n         }\\n\\n        \\n        //From map, putting values in list\\n        /*\\n        Important Explanation: \\n        Here if you see, in else part, I am adding key-value pair having count > 1 in list onn two \\n\\t\\tand also, in list two also, that is becasue to handle the cases where count is \\n\\t\\tgreater than 1 also not divisible by 2. For ex: \"777778954\". Here count of 7 is 5.\\n        */\\n         for(Map.Entry<Character,Integer> ele:map.entrySet()){\\n\\n\\n             if(ele.getValue()%2==0 ){\\n                 too.add(ele);\\n             }else{\\n\\n                 if(ele.getValue()>1){\\n                     too.add(ele);\\n                     onn.add(ele);\\n                 }else{\\n                     onn.add(ele);\\n                 }\\n\\n             }\\n         }\\n\\n\\n        //Sorting both list by key values. In decreasing order.\\n        Collections.sort(too,(i1,i2)-> i2.getKey().compareTo(i1.getKey()));\\n        Collections.sort(onn,(i1,i2)-> i2.getKey().compareTo(i1.getKey()));\\n\\n\\n        //This will form the half palindrome list. And this only goes thorugh list too. \\n        for(Map.Entry<Character,Integer> ele:too){\\n\\n            int t=ele.getValue()/2;\\n\\n            if(ele.getKey()==\\'0\\' && sb.length()!=0){\\n\\n\\n                    while(t>0){\\n                        sb.append(ele.getKey());\\n                        t--;\\n\\n                    }\\n            }else if(ele.getKey()!=\\'0\\'){\\n                while(t>0){\\n                    sb.append(ele.getKey());\\n                    t--;\\n                }\\n            }\\n\\n        }\\n\\n        \\n        //Reversing the sb String\\n        StringBuilder revSB=new StringBuilder(sb);\\n\\n        //From onn list, we add the highest key in sb\\n        if(onn.size()>0){\\n            sb.append(onn.get(0).getKey());\\n        }\\n\\n\\n        //appendig the reverse of sb\\n        sb.append(revSB.reverse());\\n\\n        //If sb is empty, return \"0\". This is for test cases like \"0000\"\\n        if(sb.toString().length()==0) return \"0\";\\n        \\n         return sb.toString();\\n    }\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        \\n         StringBuilder sb=new StringBuilder();\\n            \\n        // To store count of digits\\n         TreeMap<Character,Integer> map=new TreeMap<>();\\n\\n        \\n        /* List too :  for stroing key value pair whose count > 1.\\n            List onn: for storing count 1\\n        */\\n         List<Map.Entry<Character,Integer>> too=new ArrayList<>();\\n         List<Map.Entry<Character,Integer>> onn=new ArrayList<>();\\n\\n        //Putting values in map\\n         for(int i=0;i<num.length();i++){\\n             map.put(num.charAt(i),map.getOrDefault(num.charAt(i),0)+1);\\n         }\\n\\n        \\n        //From map, putting values in list\\n        /*\\n        Important Explanation: \\n        Here if you see, in else part, I am adding key-value pair having count > 1 in list onn two \\n\\t\\tand also, in list two also, that is becasue to handle the cases where count is \\n\\t\\tgreater than 1 also not divisible by 2. For ex: \"777778954\". Here count of 7 is 5.\\n        */\\n         for(Map.Entry<Character,Integer> ele:map.entrySet()){\\n\\n\\n             if(ele.getValue()%2==0 ){\\n                 too.add(ele);\\n             }else{\\n\\n                 if(ele.getValue()>1){\\n                     too.add(ele);\\n                     onn.add(ele);\\n                 }else{\\n                     onn.add(ele);\\n                 }\\n\\n             }\\n         }\\n\\n\\n        //Sorting both list by key values. In decreasing order.\\n        Collections.sort(too,(i1,i2)-> i2.getKey().compareTo(i1.getKey()));\\n        Collections.sort(onn,(i1,i2)-> i2.getKey().compareTo(i1.getKey()));\\n\\n\\n        //This will form the half palindrome list. And this only goes thorugh list too. \\n        for(Map.Entry<Character,Integer> ele:too){\\n\\n            int t=ele.getValue()/2;\\n\\n            if(ele.getKey()==\\'0\\' && sb.length()!=0){\\n\\n\\n                    while(t>0){\\n                        sb.append(ele.getKey());\\n                        t--;\\n\\n                    }\\n            }else if(ele.getKey()!=\\'0\\'){\\n                while(t>0){\\n                    sb.append(ele.getKey());\\n                    t--;\\n                }\\n            }\\n\\n        }\\n\\n        \\n        //Reversing the sb String\\n        StringBuilder revSB=new StringBuilder(sb);\\n\\n        //From onn list, we add the highest key in sb\\n        if(onn.size()>0){\\n            sb.append(onn.get(0).getKey());\\n        }\\n\\n\\n        //appendig the reverse of sb\\n        sb.append(revSB.reverse());\\n\\n        //If sb is empty, return \"0\". This is for test cases like \"0000\"\\n        if(sb.toString().length()==0) return \"0\";\\n        \\n         return sb.toString();\\n    }\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457967,
                "title": "c-priority-queue-with-map",
                "content": "\\t\\tstring largestPalindromic(string num) {\\n        unordered_map<char,int>myMap;\\n        priority_queue<int>even, odd;\\n        for(auto s:num)\\n            myMap[s]++;\\n        \\n        for(auto maps:myMap){\\n            if(maps.second%2 ==0) even.push(maps.first - \\'0\\'); //To obtain values with even digits\\n            else if(maps.second%2 == 1 and maps.second-1 != 0) //To obtain digits with odd values but greater than 1\\n            {\\n                even.push(maps.first - \\'0\\');\\n                odd.push(maps.first - \\'0\\'); //To add the remaining odd digit to  consider for largest odd\\n            }\\n            else odd.push(maps.first -\\'0\\'); //To add single odd digit\\n        }\\n        \\n        string l = \"\", r = \"\";\\n        if(!even.empty() and even.top()!= 0) //condition for not having leading zeros\\n            while(!even.empty()){ //Fetching the largest values from the priority Queue\\n                for(int i = 0; i<myMap[even.top()+\\'0\\']/2; i++){\\n                l += \\'0\\'+even.top();\\n                r += \\'0\\'+even.top();\\n                 }\\n            even.pop();  \\n            }\\n        \\n\\t\\tif(odd.size()) l+=\\'0\\'+odd.top();\\n    \\n\\t\\tif(r.size()) reverse(r.begin(),r.end());\\n\\t\\t\\treturn l.size() or r.size() ? l+r: \"0\";\\n    }",
                "solutionTags": [
                    "C",
                    "Heap (Priority Queue)"
                ],
                "code": "\\t\\tstring largestPalindromic(string num) {\\n        unordered_map<char,int>myMap;\\n        priority_queue<int>even, odd;\\n        for(auto s:num)\\n            myMap[s]++;\\n        \\n        for(auto maps:myMap){\\n            if(maps.second%2 ==0) even.push(maps.first - \\'0\\'); //To obtain values with even digits\\n            else if(maps.second%2 == 1 and maps.second-1 != 0) //To obtain digits with odd values but greater than 1\\n            {\\n                even.push(maps.first - \\'0\\');\\n                odd.push(maps.first - \\'0\\'); //To add the remaining odd digit to  consider for largest odd\\n            }\\n            else odd.push(maps.first -\\'0\\'); //To add single odd digit\\n        }\\n        \\n        string l = \"\", r = \"\";\\n        if(!even.empty() and even.top()!= 0) //condition for not having leading zeros\\n            while(!even.empty()){ //Fetching the largest values from the priority Queue\\n                for(int i = 0; i<myMap[even.top()+\\'0\\']/2; i++){\\n                l += \\'0\\'+even.top();\\n                r += \\'0\\'+even.top();\\n                 }\\n            even.pop();  \\n            }\\n        \\n\\t\\tif(odd.size()) l+=\\'0\\'+odd.top();\\n    \\n\\t\\tif(r.size()) reverse(r.begin(),r.end());\\n\\t\\t\\treturn l.size() or r.size() ? l+r: \"0\";\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2457933,
                "title": "java-100-faster",
                "content": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        TreeMap<String, Integer> maps = new TreeMap<>((a,b) -> b.compareTo(a));\\n        for(String s : num.split(\"\")) maps.put(s, maps.getOrDefault(s, 0) + 1);\\n        StringBuilder sb = new StringBuilder(); \\n        TreeSet<String> set = new TreeSet<>((a,b) -> b.compareTo(a));\\n        \\n        for(String s : maps.keySet()) {\\n                int size = maps.get(s)/2;\\n                while(size-- > 0) sb.append(s);\\n                if(maps.get(s) % 2 != 0) set.add(s);\\n        }\\n        \\n        return removeZeros(new StringBuilder(sb) + (\\n            !set.isEmpty() ?  set.first() : \"\") + sb.reverse());\\n        \\n    }\\n    \\n    private String removeZeros(String str) {\\n        int count = 0;\\n        for(int i = 0; i < str.length(); i++, count++) {\\n            if(str.charAt(i) != \\'0\\') break;\\n        }\\n        return (count >= str.length()) ? \"0\" : str.substring(count, str.length() - count);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        TreeMap<String, Integer> maps = new TreeMap<>((a,b) -> b.compareTo(a));\\n        for(String s : num.split(\"\")) maps.put(s, maps.getOrDefault(s, 0) + 1);\\n        StringBuilder sb = new StringBuilder(); \\n        TreeSet<String> set = new TreeSet<>((a,b) -> b.compareTo(a));\\n        \\n        for(String s : maps.keySet()) {\\n                int size = maps.get(s)/2;\\n                while(size-- > 0) sb.append(s);\\n                if(maps.get(s) % 2 != 0) set.add(s);\\n        }\\n        \\n        return removeZeros(new StringBuilder(sb) + (\\n            !set.isEmpty() ?  set.first() : \"\") + sb.reverse());\\n        \\n    }\\n    \\n    private String removeZeros(String str) {\\n        int count = 0;\\n        for(int i = 0; i < str.length(); i++, count++) {\\n            if(str.charAt(i) != \\'0\\') break;\\n        }\\n        return (count >= str.length()) ? \"0\" : str.substring(count, str.length() - count);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457871,
                "title": "easy-python-solution",
                "content": "```\\n    def largestPalindromic(self, num):\\n        \\n        cnt = collections.Counter(list(num))\\n        if len(cnt) == 1 and cnt[\\'0\\'] != 0:\\n            return \\'0\\'\\n        \\n        arr = []\\n        maxSingle = \\'\\'\\n        for k in cnt:\\n            if cnt[k] % 2 == 1:\\n                if maxSingle == \\'\\':\\n                    maxSingle = k\\n                elif maxSingle < k:\\n                    maxSingle = k\\n                \\n                if cnt[k] != 1:\\n                    arr.append([k, cnt[k] - 1])\\n            else:\\n                arr.append([k, cnt[k]])\\n\\n        arr.sort(reverse = True)\\n        res1 = \"\"\\n        for k, c in arr:\\n            if k != \\'0\\':\\n                res1 += k * (c//2)\\n        if res1 != \"\" and cnt[\\'0\\'] != 0:\\n            res1 += \\'0\\' * (cnt[\\'0\\']//2)\\n        \\n        return res1 + maxSingle + res1[::-1]\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def largestPalindromic(self, num):\\n        \\n        cnt = collections.Counter(list(num))\\n        if len(cnt) == 1 and cnt[\\'0\\'] != 0:\\n            return \\'0\\'\\n        \\n        arr = []\\n        maxSingle = \\'\\'\\n        for k in cnt:\\n            if cnt[k] % 2 == 1:\\n                if maxSingle == \\'\\':\\n                    maxSingle = k\\n                elif maxSingle < k:\\n                    maxSingle = k\\n                \\n                if cnt[k] != 1:\\n                    arr.append([k, cnt[k] - 1])\\n            else:\\n                arr.append([k, cnt[k]])\\n\\n        arr.sort(reverse = True)\\n        res1 = \"\"\\n        for k, c in arr:\\n            if k != \\'0\\':\\n                res1 += k * (c//2)\\n        if res1 != \"\" and cnt[\\'0\\'] != 0:\\n            res1 += \\'0\\' * (cnt[\\'0\\']//2)\\n        \\n        return res1 + maxSingle + res1[::-1]\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2457802,
                "title": "stringbuilder-o-n-deceiving-100-best-solution",
                "content": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int freq[] = new int[10];\\n        for(char ch: num.toCharArray()){\\n            freq[ch-\\'0\\']++;\\n        }\\n        if(freq[0] == num.length()) return \"0\";\\n        StringBuilder front = new StringBuilder();\\n        StringBuilder back = new StringBuilder();\\n        Character mid = null;\\n        int used = 0;\\n        for(int i=9; i>=0;i--){\\n            if(front.isEmpty() && i == 0 ){\\n                continue;\\n            }\\n            int count = 0;\\n            if(freq[i]>1){\\n                while(freq[i]>1){\\n                    front.append((char)(i+\\'0\\'));\\n                    back.append((char)(i+\\'0\\'));\\n                    count++;\\n                    freq[i] -= 2;\\n                }\\n            }\\n            if(mid == null && freq[i] == 1)\\n                mid = (char)(i+\\'0\\');\\n        }\\n        StringBuilder result = new StringBuilder();\\n        if(mid != null) result.append(front).append(mid).append(back.reverse());\\n        else result.append(front).append(back.reverse());\\n        return result.toString();\\n    }\\n}\\n```\\nComplexity Analysis:\\n* \\tTime : *O(n)*\\n* \\tSpace : *O(1)* not considering result string\\nReally pissed off that this is what I was unable to do during contest, feeling so dumb\\uD83D\\uDE02\\nHappy Leetcoding",
                "solutionTags": [
                    "Java",
                    "String"
                ],
                "code": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int freq[] = new int[10];\\n        for(char ch: num.toCharArray()){\\n            freq[ch-\\'0\\']++;\\n        }\\n        if(freq[0] == num.length()) return \"0\";\\n        StringBuilder front = new StringBuilder();\\n        StringBuilder back = new StringBuilder();\\n        Character mid = null;\\n        int used = 0;\\n        for(int i=9; i>=0;i--){\\n            if(front.isEmpty() && i == 0 ){\\n                continue;\\n            }\\n            int count = 0;\\n            if(freq[i]>1){\\n                while(freq[i]>1){\\n                    front.append((char)(i+\\'0\\'));\\n                    back.append((char)(i+\\'0\\'));\\n                    count++;\\n                    freq[i] -= 2;\\n                }\\n            }\\n            if(mid == null && freq[i] == 1)\\n                mid = (char)(i+\\'0\\');\\n        }\\n        StringBuilder result = new StringBuilder();\\n        if(mid != null) result.append(front).append(mid).append(back.reverse());\\n        else result.append(front).append(back.reverse());\\n        return result.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457758,
                "title": "easy-code-with-full-explanation",
                "content": "class Solution {\\npublic:\\n\\n    //as we know for a number to be a palindrome we either have elements in it all haaving even frequencies like 1221(1 and 2 both have even freq) or all having even and only 1 has odd frequency like 12321(1 and 2 has 2 freq while 3 has 1 freq which is odd but still palindrome) so keeping this basic idea in our mind we need to code....\\n    //store the freq of every character..why? so that we can know either even or odd freq(as even will be taken as it is but for odd freq elem only 1 elem will be taken and other will be taken too but with decrease of 1 frequency to make them even) as 1111222333..with this we can make the palindrome as 321131123 or 112333211 but we need the largest so 321131123 will be correct\\n    //since our answer demands for the largest string so we will sort the map acc to the biggest no in the map(or traverse in reverse in map)then see the code\\n    static bool cmp(pair<int,char>&a,pair<int,char>&b)\\n    {\\n        return a.second>b.second;\\n    }\\n    string largestPalindromic(string nums) {\\n        map<char,int>mp;\\n        for(int i=0;i<nums.size();i++)\\n        {\\n                mp[nums[i]]++;\\n        }\\n        bool flag=false;\\n       \\n       \\n        vector<pair<int,char>>vp;\\n        for(auto it:mp)\\n        {\\n            vp.push_back({it.second,it.first});\\n        }\\n        sort(vp.begin(),vp.end(),cmp);\\n        // till now we have arrange the stage for us \\n        //now lets make the string\\n         string s=\"\";\\n        flag=true;\\n        for(auto it:vp)\\n        {\\n            if(it.first%2==0)\\n            {\\n                while(it.first--)\\n                    s+=it.second;\\n            }\\n            else//odd occurence\\n            {\\n               if(flag)//first time so whole odd can be taken\\n               {\\n                  while(it.first--)\\n                      s+=it.second;\\n                   flag=false;\\n               }\\n                else\\n                {\\n                    it.first--;//dec its freq by 1 so it can be even now\\n                    while(it.first--)\\n                     s+=it.second;\\n                   flag=false; \\n                }\\n            }\\n          }\\n       //till now we got our string just need to assemble\\n      \\n        sort(s.begin(),s.end(),greater<int>());//sort the string as greater value needs to be aage \\n           //cout<<s<<endl;\\n        int counter=0;\\n        for(int i=0;i<s.size();i++)\\n        {\\n            if(s[i]!=\\'0\\')\\n                counter++;\\n        }\\n        if(counter==0||counter==1)//shows we found only 1 or no non zero elem\\n        {\\n            string str=\"\";\\n            str+=s[0];\\n            return str;\\n        }\\n        vector<char>ans(s.size());//take the vector for putting the values\\n        //take the pointer 1 will point to strt of the vector and another at the end and now strt filling the elem\\n       int k=0;\\n        int j=s.size()-1;\\n         flag=true;\\n        int ctr=1;\\n        for(int i=0;i<s.size()-1;i++)\\n        {\\n            if(s[i]==s[i+1])\\n                ctr++;\\n            else if(s[i]!=s[i+1])\\n            {\\n                if(ctr%2!=0)//for odd value\\n                {\\n                    int mid=(0+s.size())/2;\\n                    ans[mid]=s[i];\\n                    ctr--;\\n                }\\n                    while(ctr--)\\n                        {\\n                            if(flag)\\n                            {\\n                                ans[k]=s[i];\\n                                flag=false;\\n                                k++;\\n                            }\\n                            else\\n                            {\\n                                ans[j]=s[i];\\n                                flag=true;\\n                                j--;\\n                            }\\n                        }\\n                flag=true;\\n                ctr=1;\\n                    }\\n        }\\n        if(ctr!=0)//apply the same logic as done above\\n        {\\n            if(ctr%2!=0)//for odd value\\n                {\\n                    int mid=(0+s.size())/2;\\n                    ans[mid]=s[s.size()-1];\\n                    ctr--;\\n                }\\n                    while(ctr--)\\n                        {\\n                            if(flag)\\n                            {\\n                                ans[k]=s[s.size()-1];\\n                                flag=false;\\n                                k++;\\n                            }\\n                            else\\n                            {\\n                                ans[j]=s[s.size()-1];\\n                                flag=true;\\n                                j--;\\n                            }\\n                        }\\n                flag=true;\\n                ctr=1;\\n                    }\\n        string st=\"\";\\n        for(int i=0;i<ans.size();i++)\\n        {\\n            st+=ans[i];\\n        }\\n        return st;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n\\n    //as we know for a number to be a palindrome we either have elements in it all haaving even frequencies like 1221(1 and 2 both have even freq) or all having even and only 1 has odd frequency like 12321(1 and 2 has 2 freq while 3 has 1 freq which is odd but still palindrome) so keeping this basic idea in our mind we need to code....\\n    //store the freq of every character..why? so that we can know either even or odd freq(as even will be taken as it is but for odd freq elem only 1 elem will be taken and other will be taken too but with decrease of 1 frequency to make them even) as 1111222333..with this we can make the palindrome as 321131123 or 112333211 but we need the largest so 321131123 will be correct\\n    //since our answer demands for the largest string so we will sort the map acc to the biggest no in the map(or traverse in reverse in map)then see the code\\n    static bool cmp(pair<int,char>&a,pair<int,char>&b)\\n    {\\n        return a.second>b.second;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2457628,
                "title": "golang-hashmap-100-faster",
                "content": "This below is my own solution.\\n\\nFor a short and beautiful solution, check Lee\\'s explanation:\\nhttps://leetcode.com/problems/largest-palindromic-number/discuss/2456655/Python-HashMap-Solution-with-Explanation\\n\\n```\\nfunc largestPalindromic(num string) string {\\n    \\n    set := make(map[rune]int, 0)\\n    \\n    for i:=0; i<len(num); i++ {\\n        set[rune(num[i])] += 1\\n    }\\n    \\n    max := -1\\n    var odd rune\\n    evenArr := make([]int, 0)\\n    \\n    for k,v := range set {\\n        if v%2 == 1 {\\n            if int(k - \\'0\\') > max {\\n                odd = k    \\n                max = int(k - \\'0\\')\\n            }\\n            set[k] = v-1\\n            evenArr = append(evenArr, int(k-\\'0\\'))\\n        } else {\\n            evenArr = append(evenArr, int(k-\\'0\\'))\\n        }\\n    }\\n    \\n    sort.Slice(evenArr, func(a,b int) bool {return evenArr[a] > evenArr[b]})\\n    \\n    res := \"\"\\n    if len(evenArr) == 1 {\\n        \\n        res = strings.Trim(num, \"0\")\\n        if res == \"\" {\\n            res = \"0\"\\n        }\\n        \\n        return res\\n    }\\n    \\n    if max != -1 {\\n        if set[rune(max + \\'0\\')] == 0 && len(evenArr) == 2 {\\n            for i:=0; i<=set[rune(evenArr[0]+\\'0\\')]; i++ {\\n                res += string(evenArr[0]+\\'0\\')\\n            }\\n            \\n            return res\\n        }\\n    }\\n    \\n    for i:=0; i<len(evenArr); i++ {\\n        \\n        ch := evenArr[i] + \\'0\\'\\n        set[rune(ch)] = set[rune(ch)]/2\\n\\n        for j:=0; j<set[rune(ch)]; j++ {\\n            res += string(evenArr[i] + \\'0\\')    \\n        } \\n    }\\n    \\n    if max != -1 {\\n        res += string(odd)\\n    }\\n    \\n    for i:=len(evenArr)-1; i>=0; i-- {\\n        \\n        ch := evenArr[i] + \\'0\\'\\n\\n        for j:=0; j<set[rune(ch)]; j++ {\\n            res += string(evenArr[i] + \\'0\\')    \\n        }\\n    }\\n    \\n    res = strings.Trim(res, \"0\")\\n    \\n    if res == \"\" {\\n        return \"0\"\\n    }\\n    \\n    return res\\n}",
                "solutionTags": [
                    "Go"
                ],
                "code": "This below is my own solution.\\n\\nFor a short and beautiful solution, check Lee\\'s explanation:\\nhttps://leetcode.com/problems/largest-palindromic-number/discuss/2456655/Python-HashMap-Solution-with-Explanation\\n\\n```\\nfunc largestPalindromic(num string) string {\\n    \\n    set := make(map[rune]int, 0)\\n    \\n    for i:=0; i<len(num); i++ {\\n        set[rune(num[i])] += 1\\n    }\\n    \\n    max := -1\\n    var odd rune\\n    evenArr := make([]int, 0)\\n    \\n    for k,v := range set {\\n        if v%2 == 1 {\\n            if int(k - \\'0\\') > max {\\n                odd = k    \\n                max = int(k - \\'0\\')\\n            }\\n            set[k] = v-1\\n            evenArr = append(evenArr, int(k-\\'0\\'))\\n        } else {\\n            evenArr = append(evenArr, int(k-\\'0\\'))\\n        }\\n    }\\n    \\n    sort.Slice(evenArr, func(a,b int) bool {return evenArr[a] > evenArr[b]})\\n    \\n    res := \"\"\\n    if len(evenArr) == 1 {\\n        \\n        res = strings.Trim(num, \"0\")\\n        if res == \"\" {\\n            res = \"0\"\\n        }\\n        \\n        return res\\n    }\\n    \\n    if max != -1 {\\n        if set[rune(max + \\'0\\')] == 0 && len(evenArr) == 2 {\\n            for i:=0; i<=set[rune(evenArr[0]+\\'0\\')]; i++ {\\n                res += string(evenArr[0]+\\'0\\')\\n            }\\n            \\n            return res\\n        }\\n    }\\n    \\n    for i:=0; i<len(evenArr); i++ {\\n        \\n        ch := evenArr[i] + \\'0\\'\\n        set[rune(ch)] = set[rune(ch)]/2\\n\\n        for j:=0; j<set[rune(ch)]; j++ {\\n            res += string(evenArr[i] + \\'0\\')    \\n        } \\n    }\\n    \\n    if max != -1 {\\n        res += string(odd)\\n    }\\n    \\n    for i:=len(evenArr)-1; i>=0; i-- {\\n        \\n        ch := evenArr[i] + \\'0\\'\\n\\n        for j:=0; j<set[rune(ch)]; j++ {\\n            res += string(evenArr[i] + \\'0\\')    \\n        }\\n    }\\n    \\n    res = strings.Trim(res, \"0\")\\n    \\n    if res == \"\" {\\n        return \"0\"\\n    }\\n    \\n    return res\\n}",
                "codeTag": "Unknown"
            },
            {
                "id": 2457604,
                "title": "python-short-and-easy-solution",
                "content": "\\n\\t\\t\\n\\t\\tcount=Counter(num)\\n        ans=\"\"\\n        for i in range(9,-1,-1):\\n            i=str(i)\\n            if i==\\'0\\' and len(ans)==0:\\n                break\\n            if count[i]>=2:\\n                ans+=(count[i]//2)*i\\n                count[i]=count[i]%2\\n        \\n        odd=False\\n        oddelement=None\\n        for i in range(9,-1,-1):\\n            i=str(i)\\n            if count[i]>=1:\\n                oddelement=i\\n                odd=True\\n                break\\n        if odd:\\n            return ans+oddelement+ans[::-1]\\n        return ans+ans[::-1]",
                "solutionTags": [
                    "Python"
                ],
                "code": "\\n\\t\\t\\n\\t\\tcount=Counter(num)\\n        ans=\"\"\\n        for i in range(9,-1,-1):\\n            i=str(i)\\n            if i==\\'0\\' and len(ans)==0:\\n                break\\n            if count[i]>=2:\\n                ans+=(count[i]//2)*i\\n                count[i]=count[i]%2\\n        \\n        odd=False\\n        oddelement=None\\n        for i in range(9,-1,-1):\\n            i=str(i)\\n            if count[i]>=1:\\n                oddelement=i\\n                odd=True\\n                break\\n        if odd:\\n            return ans+oddelement+ans[::-1]\\n        return ans+ans[::-1]",
                "codeTag": "Unknown"
            },
            {
                "id": 2457544,
                "title": "faster-than-100-easy-to-understand-explanation-with-steps-o-n-time-o-1-space",
                "content": "**Step 1 :** Create a frequency array containing frequency of each integer of num.\\n**Step 2 :** Now our freq[] will only have either 0, 1 or more than 1.\\na) If 0, no need to do anything.\\nb) If 1, we cant make a pair. But we can make a mid element (Discussed in Step 3).\\nc) If 2 or more, we can a pair. \\n\\t**Eg -** \\n\\t\\tfreq[i] = 6 --> we can make a pair of 6/2 = 3\\n\\t\\tfreq[i] = 7 --> we can make a pair of 7/2 = 3 and we can use remaining 1 to build a mid element (Step 2).\\n\\t\\t**Note : Trim zeroes (if any).**\\n\\n**Step 3 :** Now frequency of all elements will be either 0 or 1.\\n\\tFind the largest element in freq[] of freq 1. \\n\\tWhy largest? Because lets say left part is 44 and freq[] = {0, 0, 0, 0, 0, 0, 0, 1, 0, 1}, then  44\\'9\\' > 44\\'7\\' \\n\\t**Note : Mid can be only 1 element or no element.**\\n\\n**Step 4 :** \\n\\tMerge all of them.\\n\\tEg : \\tleft part : 447\\n\\t\\tmid part : 9\\n\\t\\tright part : reverse(left part) = 744\\n\\t\\tRequired ans = 4479744\\n\\t\\t\\n```\\npublic String largestPalindromic(String num) {\\n    int[] freq = new int[10];\\n\\tfor (char ch : num.toCharArray()) {       // create a frequency array\\n\\t\\tint i = (int)(ch-\\'0\\');\\n\\t\\tfreq[i] += 1;\\n\\t}\\n\\n\\tStringBuilder sb = new StringBuilder();\\n\\tfor (int i = 9; i >= 0; i--) {            // calculating first part\\n\\t\\tif (freq[i] > 1) {\\n\\t\\t\\tint times = freq[i]/2;\\n\\t\\t\\twhile (times > 0) {\\n\\t\\t\\t\\tsb.append(i);\\n\\t\\t\\t\\ttimes--;\\n\\t\\t\\t}\\n\\t\\t\\tfreq[i] = freq[i]%2;\\n\\t\\t}\\n\\t}\\n\\n\\ttrimZeros(sb);                         // trim zeros\\n\\n\\tString mid = \"\";\\n\\tfor (int i = 9; i >= 0; i--) {         //calculating mid\\n\\t\\tif (freq[i] == 1) {       \\n\\t\\t\\tmid += i;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\tString ans = \"\";                        // Merge all \\n\\tans += sb.toString();\\n\\tans += mid;\\n\\tans += sb.reverse().toString();\\n\\treturn ans.isEmpty() ? \"0\" : ans;\\n}\\n\\nvoid trimZeros(StringBuilder sb) {\\n\\tint zeroLength = 0;\\n\\tfor (int i = 0; i < sb.length(); i++) {         // calculate the number of prefix zeros\\n\\t\\tif (sb.charAt(i) != \\'0\\') {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tzeroLength++;\\n\\t\\t}\\n\\t}\\n\\tsb.delete(0, zeroLength);                      // delete those zeros\\n}\\n```\\n\\nTime Complexity - O(N)\\nExtra Space - O(1)\\n![image](https://assets.leetcode.com/users/images/36888779-f9b1-423c-8035-677d2b75c836_1661186563.7623544.png)\\n\\n**Please upvote and comment if you liked the explanation.**",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic String largestPalindromic(String num) {\\n    int[] freq = new int[10];\\n\\tfor (char ch : num.toCharArray()) {       // create a frequency array\\n\\t\\tint i = (int)(ch-\\'0\\');\\n\\t\\tfreq[i] += 1;\\n\\t}\\n\\n\\tStringBuilder sb = new StringBuilder();\\n\\tfor (int i = 9; i >= 0; i--) {            // calculating first part\\n\\t\\tif (freq[i] > 1) {\\n\\t\\t\\tint times = freq[i]/2;\\n\\t\\t\\twhile (times > 0) {\\n\\t\\t\\t\\tsb.append(i);\\n\\t\\t\\t\\ttimes--;\\n\\t\\t\\t}\\n\\t\\t\\tfreq[i] = freq[i]%2;\\n\\t\\t}\\n\\t}\\n\\n\\ttrimZeros(sb);                         // trim zeros\\n\\n\\tString mid = \"\";\\n\\tfor (int i = 9; i >= 0; i--) {         //calculating mid\\n\\t\\tif (freq[i] == 1) {       \\n\\t\\t\\tmid += i;\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t}\\n\\n\\tString ans = \"\";                        // Merge all \\n\\tans += sb.toString();\\n\\tans += mid;\\n\\tans += sb.reverse().toString();\\n\\treturn ans.isEmpty() ? \"0\" : ans;\\n}\\n\\nvoid trimZeros(StringBuilder sb) {\\n\\tint zeroLength = 0;\\n\\tfor (int i = 0; i < sb.length(); i++) {         // calculate the number of prefix zeros\\n\\t\\tif (sb.charAt(i) != \\'0\\') {\\n\\t\\t\\tbreak;\\n\\t\\t}\\n\\t\\telse {\\n\\t\\t\\tzeroLength++;\\n\\t\\t}\\n\\t}\\n\\tsb.delete(0, zeroLength);                      // delete those zeros\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2457538,
                "title": "easy-solution-boi-explained-everything-in-detail",
                "content": "Read the comments and code, you\\'ll get the logic\\n```\\nclass Solution {\\n    \\n    public String largestPalindromic(String num) {\\n        int n = num.length();\\n        \\n        // for storing single and double occurance numbers\\n        List<Character> singles = new ArrayList<>();\\n        List<Character> doubles = new ArrayList<>();\\n        // for storing sorted keys && also tracking the freq\\n        TreeMap<Character, Integer> map = new TreeMap<>();\\n        \\n        \\n        // putting freq\\n        for(int i = 0; i < n; i++)\\n        {\\n            map.put(num.charAt(i), map.getOrDefault(num.charAt(i), 0)+1);\\n        }\\n        \\n        // 0 case\\n        if(map.size() == 1 && map.containsKey(\\'0\\'))\\n            return \"0\";\\n\\n        // other 999999 digit case return straight away 999999\\n        else if(map.size() == 1 && !map.containsKey(\\'0\\'))\\n            return num;\\n        \\n        for(char key : map.keySet()) {\\n            if(map.get(key)%2 == 1){\\n                singles.add(key);\\n                \\n                map.put(key, map.get(key)-1);\\n                // suppose freq is 3 added to single and double as well\\n                // 1 for single 2 for double\\n                if(map.get(key) >= 2)\\n                    doubles.add(key);\\n            }\\n            else{\\n                if(map.get(key) >= 2)\\n                    doubles.add(key);\\n            }\\n        }\\n        \\n        // create palindrome\\n        \\n        String res = \"\";\\n        \\n        // left side of palindrome\\n        for(int i = doubles.size()-1; i >= 0; i--) {\\n            // Trimming left side zeros e.g. 00009000 -> 9\\n            if(i == doubles.size()-1 && doubles.get(i) ==  \\'0\\')\\n                continue;\\n            \\n            // putting half on the left side eg. \"654\"\\n            int freq = map.get(doubles.get(i));\\n            \\n            for(int k = 0; k < freq/2; k++)\\n                res = res + doubles.get(i);\\n        }\\n        \\n        // add last of single\\n        // because in middle one single digit\\'s presence can make it more large in size eg. \"654\" + \"1\" -> 6541\"\\n        if(singles.size() > 0){\\n            // they are sorted\\n            // taking last means max number\\n            res = res + singles.get(singles.size()-1);\\n        }\\n        \\n        // right side of palindrome\\n        for(int i = 0; i < doubles.size(); i++) {\\n            // Trimming right side zeros e.g. 00009000 -> 9\\n            if(i == doubles.size()-1 && doubles.get(i) ==  \\'0\\')\\n                continue;\\n                \\n            // putting half on the right side eg. \"456\"\\n            int freq = map.get(doubles.get(i));\\n            \\n            for(int k = 0; k < freq/2; k++)\\n                res = res + doubles.get(i);\\n        }\\n        \\n        // e.g. \"6541456\"\\n        return res;\\n    }\\n}\\n```\\n![image](https://assets.leetcode.com/users/images/3111b747-fba4-4796-8403-a61bb458f8df_1675170989.823945.png)\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    \\n    public String largestPalindromic(String num) {\\n        int n = num.length();\\n        \\n        // for storing single and double occurance numbers\\n        List<Character> singles = new ArrayList<>();\\n        List<Character> doubles = new ArrayList<>();\\n        // for storing sorted keys && also tracking the freq\\n        TreeMap<Character, Integer> map = new TreeMap<>();\\n        \\n        \\n        // putting freq\\n        for(int i = 0; i < n; i++)\\n        {\\n            map.put(num.charAt(i), map.getOrDefault(num.charAt(i), 0)+1);\\n        }\\n        \\n        // 0 case\\n        if(map.size() == 1 && map.containsKey(\\'0\\'))\\n            return \"0\";\\n\\n        // other 999999 digit case return straight away 999999\\n        else if(map.size() == 1 && !map.containsKey(\\'0\\'))\\n            return num;\\n        \\n        for(char key : map.keySet()) {\\n            if(map.get(key)%2 == 1){\\n                singles.add(key);\\n                \\n                map.put(key, map.get(key)-1);\\n                // suppose freq is 3 added to single and double as well\\n                // 1 for single 2 for double\\n                if(map.get(key) >= 2)\\n                    doubles.add(key);\\n            }\\n            else{\\n                if(map.get(key) >= 2)\\n                    doubles.add(key);\\n            }\\n        }\\n        \\n        // create palindrome\\n        \\n        String res = \"\";\\n        \\n        // left side of palindrome\\n        for(int i = doubles.size()-1; i >= 0; i--) {\\n            // Trimming left side zeros e.g. 00009000 -> 9\\n            if(i == doubles.size()-1 && doubles.get(i) ==  \\'0\\')\\n                continue;\\n            \\n            // putting half on the left side eg. \"654\"\\n            int freq = map.get(doubles.get(i));\\n            \\n            for(int k = 0; k < freq/2; k++)\\n                res = res + doubles.get(i);\\n        }\\n        \\n        // add last of single\\n        // because in middle one single digit\\'s presence can make it more large in size eg. \"654\" + \"1\" -> 6541\"\\n        if(singles.size() > 0){\\n            // they are sorted\\n            // taking last means max number\\n            res = res + singles.get(singles.size()-1);\\n        }\\n        \\n        // right side of palindrome\\n        for(int i = 0; i < doubles.size(); i++) {\\n            // Trimming right side zeros e.g. 00009000 -> 9\\n            if(i == doubles.size()-1 && doubles.get(i) ==  \\'0\\')\\n                continue;\\n                \\n            // putting half on the right side eg. \"456\"\\n            int freq = map.get(doubles.get(i));\\n            \\n            for(int k = 0; k < freq/2; k++)\\n                res = res + doubles.get(i);\\n        }\\n        \\n        // e.g. \"6541456\"\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457535,
                "title": "c-intuitive-and-easy-to-understand-solution-with-step-by-step-explanation",
                "content": "## Points to ponder:\\n**Point 1:** If a palindrome is of `even` length, all its characters have even frequency (e.g., `9229`)\\n**Point 2:** If a palindrome is of `odd` length, all its characters have even frequency except for the `middle` character (e.g., `92129`)\\n\\n**Steps to follow:**\\n1. we count `frequency` of all chars.\\n1. we `build first half of the palindrome` by inserting bigger digits first ,i.e., starting with 9, then 8, then 7 and so on. (becasuse starting with the largest digit guarantees the largest value palindrome)\\n1. we also keep track of the biggest `middle` digit with odd frequency `if there exists any` (becasuse bigger middle digit makes bigger palindrome value)\\n1. we `remove leading zeros` from the first half of the palindrome.\\n1. `ans = first_half + middle + reversed_first_half`\\n1. if `size` of ans is `zero`, we return `\"0\"` (in this case, the input string contained only zeros)\\n\\n**Complexity**\\nTime `O(n)`\\nSpace `O(n)`\\n\\n```\\nstring largestPalindromic(string num) {\\n    int freq[10] = {0}; //from 0-9 there are 10 digits. We intitialize their count with zero.\\n    int middle = -1; //We will try to take the maximum digit with odd frequency for the middle as we are trying to build the largest palindrome possible\\n    for(char n: num) freq[n-\\'0\\']++; // subtracting \\'0\\' converts char to int\\n\\t/*************building the first half of palindrome(with leading zeros) and max middle digit with odd frequency***************/\\n    string half;\\n\\tfor(int i=9; i>=0; i--){ //We wii try to build the largest palindrome possible. So we insert largest digit(9, 8, 7, ...) first\\n\\t\\tint times = freq[i]/2;\\n\\t\\twhile(times--) half += i+\\'0\\';\\n\\t\\tif(freq[i] & 1) middle = max(middle, i); //trying to keep track of the largest digit with odd frequency\\n\\t}\\n    /*************Removing leading zeros from first half of the palindrome***************/\\n    string zeroless; // for storing the string half without leading zeros\\n    int ind = -1;\\n    for(int i=0; i<half.size(); i++) if(half[i] != \\'0\\') {ind = i; break;} //ind keeps track of the first non-zero char\\n    if(ind != -1) { //if ind stays -1, it means input string contained only zeros\\n\\t\\tfor(int i=ind; i<half.size(); i++) zeroless+=half[i];\\n\\t} \\n    /*************Building the palindrome***************/\\n    string ans;\\n\\tans += zeroless; // inserting the first half of the palindrome\\n    if(middle != -1) {  //if middle stays -1, there was no digit with odd frequency. So there won\\'t be a middle digit. Length of palindrome will be even.\\n\\t\\tans += middle+\\'0\\'; // adding \\'0\\' converts int to char\\n\\t}\\n    reverse(zeroless.begin(), zeroless.end()); \\n    ans += zeroless; //inserting the reversed second half of the array \\n    return ans.size()==0 ? \"0\" : ans; //If input string is full of zeros, answer is \"0\". As we stripped all leading zeros, we gotta handle it separately!\\n}\\n```\\n*Feel free to ask questions!*",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nstring largestPalindromic(string num) {\\n    int freq[10] = {0}; //from 0-9 there are 10 digits. We intitialize their count with zero.\\n    int middle = -1; //We will try to take the maximum digit with odd frequency for the middle as we are trying to build the largest palindrome possible\\n    for(char n: num) freq[n-\\'0\\']++; // subtracting \\'0\\' converts char to int\\n\\t/*************building the first half of palindrome(with leading zeros) and max middle digit with odd frequency***************/\\n    string half;\\n\\tfor(int i=9; i>=0; i--){ //We wii try to build the largest palindrome possible. So we insert largest digit(9, 8, 7, ...) first\\n\\t\\tint times = freq[i]/2;\\n\\t\\twhile(times--) half += i+\\'0\\';\\n\\t\\tif(freq[i] & 1) middle = max(middle, i); //trying to keep track of the largest digit with odd frequency\\n\\t}\\n    /*************Removing leading zeros from first half of the palindrome***************/\\n    string zeroless; // for storing the string half without leading zeros\\n    int ind = -1;\\n    for(int i=0; i<half.size(); i++) if(half[i] != \\'0\\') {ind = i; break;} //ind keeps track of the first non-zero char\\n    if(ind != -1) { //if ind stays -1, it means input string contained only zeros\\n\\t\\tfor(int i=ind; i<half.size(); i++) zeroless+=half[i];\\n\\t} \\n    /*************Building the palindrome***************/\\n    string ans;\\n\\tans += zeroless; // inserting the first half of the palindrome\\n    if(middle != -1) {  //if middle stays -1, there was no digit with odd frequency. So there won\\'t be a middle digit. Length of palindrome will be even.\\n\\t\\tans += middle+\\'0\\'; // adding \\'0\\' converts int to char\\n\\t}\\n    reverse(zeroless.begin(), zeroless.end()); \\n    ans += zeroless; //inserting the reversed second half of the array \\n    return ans.size()==0 ? \"0\" : ans; //If input string is full of zeros, answer is \"0\". As we stripped all leading zeros, we gotta handle it separately!\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2457495,
                "title": "c-hashmap-100-faster",
                "content": "Storing the frequency of numbers in map and then if the frequency of the number is atleast 2 using is for palindrome and if the frequency is more than 0 using the number with the highest frequency as the mid element.\\nflag checks if mid element is found or not.\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int>hash(10,0);\\n        for(auto i:num){\\n            int p=i-\\'0\\';\\n            hash[i-\\'0\\']++;\\n        }\\n        int flag=0;\\n        int index=-1;\\n        string ans=\"\";\\n        int count=0;\\n        string store=\"\";\\n        for(int i=9;i>=0;i--){\\n            if(hash[i]==0)continue;\\n            if(hash[i]%2==1 &&flag==0){\\n                flag=1;index=i;hash[i]--;\\n            }\\n            if(hash[i]>=2){\\n                \\n                int j=hash[i]/2;\\n                \\n                hash[i]=0;\\n            while(j--){\\n                ans+=to_string(i);\\n                store+=to_string(i);\\n            }\\n            }\\n            \\n            \\n        }\\n        // cout<<ans<<store;\\n        string finala=\"\";\\n        reverse(store.begin(),store.end());\\n        if(index!=-1){\\n             int cnt=ans.length()-1;\\n             reverse(ans.begin(),ans.end());\\n            while(cnt>-1&&ans[cnt--]==\\'0\\'){\\n                ans.pop_back();\\n                store.pop_back();\\n            }\\n            reverse(ans.begin(),ans.end());\\n            finala=ans+to_string(index)+store;\\n            return finala;\\n            \\n        }\\n        int cnt=ans.length()-1;\\n             reverse(ans.begin(),ans.end());\\n            while(cnt>-1&&ans[cnt--]==\\'0\\'){\\n                ans.pop_back();\\n                store.pop_back();\\n            }\\n            reverse(ans.begin(),ans.end());\\n            finala=ans+store;\\n        if(finala==\"\")return \"0\";\\n            return finala;\\n        \\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int>hash(10,0);\\n        for(auto i:num){\\n            int p=i-\\'0\\';\\n            hash[i-\\'0\\']++;\\n        }\\n        int flag=0;\\n        int index=-1;\\n        string ans=\"\";\\n        int count=0;\\n        string store=\"\";\\n        for(int i=9;i>=0;i--){\\n            if(hash[i]==0)continue;\\n            if(hash[i]%2==1 &&flag==0){\\n                flag=1;index=i;hash[i]--;\\n            }\\n            if(hash[i]>=2){\\n                \\n                int j=hash[i]/2;\\n                \\n                hash[i]=0;\\n            while(j--){\\n                ans+=to_string(i);\\n                store+=to_string(i);\\n            }\\n            }\\n            \\n            \\n        }\\n        // cout<<ans<<store;\\n        string finala=\"\";\\n        reverse(store.begin(),store.end());\\n        if(index!=-1){\\n             int cnt=ans.length()-1;\\n             reverse(ans.begin(),ans.end());\\n            while(cnt>-1&&ans[cnt--]==\\'0\\'){\\n                ans.pop_back();\\n                store.pop_back();\\n            }\\n            reverse(ans.begin(),ans.end());\\n            finala=ans+to_string(index)+store;\\n            return finala;\\n            \\n        }\\n        int cnt=ans.length()-1;\\n             reverse(ans.begin(),ans.end());\\n            while(cnt>-1&&ans[cnt--]==\\'0\\'){\\n                ans.pop_back();\\n                store.pop_back();\\n            }\\n            reverse(ans.begin(),ans.end());\\n            finala=ans+store;\\n        if(finala==\"\")return \"0\";\\n            return finala;\\n        \\n        \\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2457488,
                "title": "hashtable-solution-with-deque-100-time-complexity-and-100-space-complexity",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        bool zero = false, pair = false; \\n        vector<int> v(10,0);\\n        deque<char> dq;\\n        for(auto n : num){\\n            v[n - \\'0\\']++;\\n            if(n ==\\'0\\')\\n                zero = true;\\n            if(v[n - \\'0\\'] % 2 == 0 && v[n - \\'0\\'] != 0 && n != \\'0\\') \\n                pair = true;\\n        }\\n        string ans = \"\";\\n        for(int i = 9 ; i >=0 ; --i)\\n            if(v[i] % 2 == 1){\\n             dq.push_back((char)(\\'0\\' + i));\\n             v[i]--;\\n             break;\\n            }\\n        \\n        if(pair == false){\\n            while(dq.size()){\\n                ans.push_back(dq.front());\\n                dq.pop_front();\\n            }\\n            return ans == \"\" ? \"0\" : ans;\\n        }\\n        if(zero == true)\\n            while(v[0] > 1){\\n                dq.push_front(\\'0\\');\\n                dq.push_back(\\'0\\');\\n                v[0] -= 2;\\n            }\\n        \\n        for(int i = 0 ; i < 10 ; i++)\\n            if(v[i] > 1)\\n                while(v[i] > 1){\\n                    dq.push_front((char)(\\'0\\' + i));\\n                    dq.push_back((char)(\\'0\\' + i));\\n                    v[i] -= 2;\\n                }\\n        \\n        while(dq.size()){\\n            ans.push_back(dq.front());\\n            dq.pop_front();\\n        }\\n        return ans == \"\" ? \"0\" : ans;\\n    }\\n};\\n```\\nFor any queries write down in comment,\\nThanks..",
                "solutionTags": [
                    "C",
                    "Hash Table",
                    "Math",
                    "Queue",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        bool zero = false, pair = false; \\n        vector<int> v(10,0);\\n        deque<char> dq;\\n        for(auto n : num){\\n            v[n - \\'0\\']++;\\n            if(n ==\\'0\\')\\n                zero = true;\\n            if(v[n - \\'0\\'] % 2 == 0 && v[n - \\'0\\'] != 0 && n != \\'0\\') \\n                pair = true;\\n        }\\n        string ans = \"\";\\n        for(int i = 9 ; i >=0 ; --i)\\n            if(v[i] % 2 == 1){\\n             dq.push_back((char)(\\'0\\' + i));\\n             v[i]--;\\n             break;\\n            }\\n        \\n        if(pair == false){\\n            while(dq.size()){\\n                ans.push_back(dq.front());\\n                dq.pop_front();\\n            }\\n            return ans == \"\" ? \"0\" : ans;\\n        }\\n        if(zero == true)\\n            while(v[0] > 1){\\n                dq.push_front(\\'0\\');\\n                dq.push_back(\\'0\\');\\n                v[0] -= 2;\\n            }\\n        \\n        for(int i = 0 ; i < 10 ; i++)\\n            if(v[i] > 1)\\n                while(v[i] > 1){\\n                    dq.push_front((char)(\\'0\\' + i));\\n                    dq.push_back((char)(\\'0\\' + i));\\n                    v[i] -= 2;\\n                }\\n        \\n        while(dq.size()){\\n            ans.push_back(dq.front());\\n            dq.pop_front();\\n        }\\n        return ans == \"\" ? \"0\" : ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457440,
                "title": "java-simple-solution-count-o-n-easy-to-understand",
                "content": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int[] arr =new int[10];\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<num.length();i++){\\n            arr[num.charAt(i)-\\'0\\']++;\\n        }\\n        for(int i=9;i>=0;i--){\\n            if(arr[i]>=2){\\n                int c=arr[i]/2;\\n                while(c>0){\\n                    sb.append(i);\\n                    c--;\\n                }\\n            }\\n        }\\n        if(sb.length()>0 && sb.charAt(0)==\\'0\\'){\\n            sb.setLength(0);\\n        }\\n        \\n        StringBuilder sb2=new StringBuilder(sb);\\n        sb2.reverse();\\n        for(int i=9;i>=0;i--){\\n            if(arr[i]%2!=0){\\n                sb.append(i);\\n                break;\\n            }\\n        }\\n        String d=sb.append(sb2).toString();\\n        if(d.isEmpty()){\\n            return \"0\";\\n        }\\n        return d;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int[] arr =new int[10];\\n        StringBuilder sb=new StringBuilder();\\n        for(int i=0;i<num.length();i++){\\n            arr[num.charAt(i)-\\'0\\']++;\\n        }\\n        for(int i=9;i>=0;i--){\\n            if(arr[i]>=2){\\n                int c=arr[i]/2;\\n                while(c>0){\\n                    sb.append(i);\\n                    c--;\\n                }\\n            }\\n        }\\n        if(sb.length()>0 && sb.charAt(0)==\\'0\\'){\\n            sb.setLength(0);\\n        }\\n        \\n        StringBuilder sb2=new StringBuilder(sb);\\n        sb2.reverse();\\n        for(int i=9;i>=0;i--){\\n            if(arr[i]%2!=0){\\n                sb.append(i);\\n                break;\\n            }\\n        }\\n        String d=sb.append(sb2).toString();\\n        if(d.isEmpty()){\\n            return \"0\";\\n        }\\n        return d;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457425,
                "title": "c-using-frequency-map-with-explanation",
                "content": "```\\n string largestPalindromic(string num) {\\n        \\n        vector<int> mp(10, 0);\\n        for(char &ch:num)\\n          mp[ch-\\'0\\'] ++;\\n        \\n        string ans=\"\";\\n        int lar=INT_MIN;\\n        for(int i=9;i>=0;i--)\\n        {\\n            while(mp[i]>1) //if freq of number is more than one, we can use it twice in palindrome\\n            {\\n                //we append the number if it is non zero or if the number is zero but does not appear at index 0.\\n                if(i!=0 || i==0 && ans.size()!=0) \\n                    ans = ans + to_string(i);\\n               mp[i] -= 2;\\n            }\\n            if(mp[i]==1) //we want to store the largest number for the middle position\\n                lar = max(lar, i);\\n            \\n        }\\n        string rev=ans;\\n        reverse(rev.begin(), rev.end());\\n        if(lar == INT_MIN) //even sized string\\n            return ans+rev == \"\" ? \"0\" : ans+rev;\\n        else//odd sized string\\n            return ans+to_string(lar)+rev;\\n        \\n    }\\n```",
                "solutionTags": [
                    "C",
                    "String"
                ],
                "code": "```\\n string largestPalindromic(string num) {\\n        \\n        vector<int> mp(10, 0);\\n        for(char &ch:num)\\n          mp[ch-\\'0\\'] ++;\\n        \\n        string ans=\"\";\\n        int lar=INT_MIN;\\n        for(int i=9;i>=0;i--)\\n        {\\n            while(mp[i]>1) //if freq of number is more than one, we can use it twice in palindrome\\n            {\\n                //we append the number if it is non zero or if the number is zero but does not appear at index 0.\\n                if(i!=0 || i==0 && ans.size()!=0) \\n                    ans = ans + to_string(i);\\n               mp[i] -= 2;\\n            }\\n            if(mp[i]==1) //we want to store the largest number for the middle position\\n                lar = max(lar, i);\\n            \\n        }\\n        string rev=ans;\\n        reverse(rev.begin(), rev.end());\\n        if(lar == INT_MIN) //even sized string\\n            return ans+rev == \"\" ? \"0\" : ans+rev;\\n        else//odd sized string\\n            return ans+to_string(lar)+rev;\\n        \\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2457303,
                "title": "javascript-hash-table-greedy-o-n-detailed-explanation",
                "content": "**Approach**\\n* Create a `map` to store `count of each number`\\n* `Sort` the numbers based on freq of each number in `map` with decreasing order(placing large values before small values) , also we can filter out numbers with freq\\n* For the middle character to be placed, find numbers that have odd frequency, get maximum number such number\\n* Traverse freqMap, store `half` of the frequency count of each number, so we can put the same later in reverse order\\n* Trim the number for leading zeroes, voila!\\n\\n**Example**:\\n```\\nnum = \"444947137\"\\ncountMap: { \\'1\\': 1, \\'3\\': 1, \\'4\\': 4, \\'7\\': 2, \\'9\\': 1 }\\nfreqMap: [ [ \\'7\\', 2 ], [ \\'4\\', 4 ] ]\\nmaxOddFreq: 9\\n\\nWhile Traversing:\\n1. Place \\'7\\' first, with length freq/2, 1, result = [\\'7\\']\\n2. Place \\'4\\' next, with length 2 (4/2), result = [\\'7\\', \\'4\\', \\'4\\']\\n3. Put everything together [result, maxOddFreqNumber, reverse(result)], i.e [\\'7\\', \\'4\\' , \\'4\\' , \\'9\\', \\'4\\', \\'4\\', \\'7\\']\\n4. Trim Result for leading or trailing zeroes if any\\n```\\n\\nPS: Don\\'t forget to upvote, if you like the solution \\n\\n```\\nconst trimPallindromicNumber = (result) => {\\n    // console.log(\\'Input\\', result);\\n    let i;\\n    for (i=0;i<result.length;i++) {\\n        if (result[i] === \\'0\\') {\\n            continue;\\n        } else {\\n            break;\\n        }\\n    }\\n    if (i > 0) {\\n        if (i === result.length) --i;\\n        // console.log(\\'Remove zeroes before\\', i);\\n        result = result.slice(i, result.length);\\n    }\\n\\n    for (i = result.length -1;i>=0;i--) {\\n        if (result[i] === \\'0\\') {\\n            continue;\\n        } else {\\n            break;\\n        }\\n    }\\n    if (i < result.length -1) {\\n        if (i === -1) ++i;\\n        // console.log(\\'Remove zeroes after\\', i);\\n        result = result.slice(0, i+1);\\n    }\\n    \\n    return result;\\n}\\nvar largestPalindromic = function(num) {\\n    const countMap = num.split(\\'\\').reduce((acc, val) => {\\n        if (!acc[val]) acc[val] = 0;\\n        acc[val]++;\\n        return acc;\\n    }, {});\\n\\n    const maxOddFreq = Object.entries(countMap)\\n    .filter(([key, value]) => value & 1)\\n    .reduce((acc, val) => Math.max(acc, val[0]), -1);\\n\\n    const freqMap = Object.entries(countMap)\\n    .filter(([key, value]) => value !== 1)\\n    .sort((a, b) => b[0] - a[0]);\\n\\n    let result = [];\\n    for (let i = 0;i<freqMap.length;i++) {\\n        const [val, freq] = freqMap[i];\\n        result.push(...Array(freq>>1).fill(val));\\n    }\\n    result = [...result, ...(maxOddFreq!== -1 ? [maxOddFreq]: []), ...result.reverse()];\\n    result = trimPallindromicNumber(result);\\n    return result.join(\\'\\');\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Greedy"
                ],
                "code": "```\\nnum = \"444947137\"\\ncountMap: { \\'1\\': 1, \\'3\\': 1, \\'4\\': 4, \\'7\\': 2, \\'9\\': 1 }\\nfreqMap: [ [ \\'7\\', 2 ], [ \\'4\\', 4 ] ]\\nmaxOddFreq: 9\\n\\nWhile Traversing:\\n1. Place \\'7\\' first, with length freq/2, 1, result = [\\'7\\']\\n2. Place \\'4\\' next, with length 2 (4/2), result = [\\'7\\', \\'4\\', \\'4\\']\\n3. Put everything together [result, maxOddFreqNumber, reverse(result)], i.e [\\'7\\', \\'4\\' , \\'4\\' , \\'9\\', \\'4\\', \\'4\\', \\'7\\']\\n4. Trim Result for leading or trailing zeroes if any\\n```\n```\\nconst trimPallindromicNumber = (result) => {\\n    // console.log(\\'Input\\', result);\\n    let i;\\n    for (i=0;i<result.length;i++) {\\n        if (result[i] === \\'0\\') {\\n            continue;\\n        } else {\\n            break;\\n        }\\n    }\\n    if (i > 0) {\\n        if (i === result.length) --i;\\n        // console.log(\\'Remove zeroes before\\', i);\\n        result = result.slice(i, result.length);\\n    }\\n\\n    for (i = result.length -1;i>=0;i--) {\\n        if (result[i] === \\'0\\') {\\n            continue;\\n        } else {\\n            break;\\n        }\\n    }\\n    if (i < result.length -1) {\\n        if (i === -1) ++i;\\n        // console.log(\\'Remove zeroes after\\', i);\\n        result = result.slice(0, i+1);\\n    }\\n    \\n    return result;\\n}\\nvar largestPalindromic = function(num) {\\n    const countMap = num.split(\\'\\').reduce((acc, val) => {\\n        if (!acc[val]) acc[val] = 0;\\n        acc[val]++;\\n        return acc;\\n    }, {});\\n\\n    const maxOddFreq = Object.entries(countMap)\\n    .filter(([key, value]) => value & 1)\\n    .reduce((acc, val) => Math.max(acc, val[0]), -1);\\n\\n    const freqMap = Object.entries(countMap)\\n    .filter(([key, value]) => value !== 1)\\n    .sort((a, b) => b[0] - a[0]);\\n\\n    let result = [];\\n    for (let i = 0;i<freqMap.length;i++) {\\n        const [val, freq] = freqMap[i];\\n        result.push(...Array(freq>>1).fill(val));\\n    }\\n    result = [...result, ...(maxOddFreq!== -1 ? [maxOddFreq]: []), ...result.reverse()];\\n    result = trimPallindromicNumber(result);\\n    return result.join(\\'\\');\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2457261,
                "title": "simple-faster-than-100-o-n-using-treemap",
                "content": "1. First seperate of all digit in sting and store in a sorted Map(Treemap).\\n\\t```n = \"444947137\"```\\n\\t```{1=1, 3=3, 4=4444, 7=77, 9=9}```\\n2. Now we know that Palindrome can be made using even number of occurance of digits apart from the middle one.\\n```like  121 or 1221```\\n3. Now we traverse the map in sorted order \\n\\t* Find the maximum digit with odd occurance to place in middle. ```maxOdd```\\n\\t* Make a half of palidrome using half of available digits. ```res```\\n4. Now result would be ``` res + maxODD + reverse(res)```\\n5. Check for edge cases.\\n\\n\\n```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int n = num.length(); String res = \"\"; \\n        boolean flag = false;\\n        Map<Character, String> tmap = new TreeMap<Character, String>();\\n        for(int i=0; i<n; i++){\\n            String str = \"\";\\n            if(tmap.containsKey(num.charAt(i))){\\n                str = tmap.get(num.charAt(i));\\n            }\\n            str += num.charAt(i);\\n            tmap.put(num.charAt(i), str);\\n        }\\n        char maxOdd = \\' \\';\\n        for(Character key : tmap.keySet()) {\\n            String str = tmap.get(key);\\n            res = res + str.substring(0,str.length()/2);\\n            \\n            if(str.length() % 2 == 1)\\n                maxOdd = key;\\n        }\\n\\t\\t// handle \"00009\" case\\n        if(!res.isEmpty() && res.charAt(res.length()-1) == \\'0\\')\\n            res = \"\";\\n\\n        StringBuilder res1 = new StringBuilder(res);\\n        if(maxOdd != \\' \\')\\n            res = res1.reverse().toString() + maxOdd + res;\\n        else\\n            res = res1.reverse().toString() + res;\\n        \\n\\t\\t// handle \"00000\" case\\n        return res.isEmpty() ? \"0\" : res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree"
                ],
                "code": "```n = \"444947137\"```\n```{1=1, 3=3, 4=4444, 7=77, 9=9}```\n```like  121 or 1221```\n```maxOdd```\n```res```\n``` res + maxODD + reverse(res)```\n```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int n = num.length(); String res = \"\"; \\n        boolean flag = false;\\n        Map<Character, String> tmap = new TreeMap<Character, String>();\\n        for(int i=0; i<n; i++){\\n            String str = \"\";\\n            if(tmap.containsKey(num.charAt(i))){\\n                str = tmap.get(num.charAt(i));\\n            }\\n            str += num.charAt(i);\\n            tmap.put(num.charAt(i), str);\\n        }\\n        char maxOdd = \\' \\';\\n        for(Character key : tmap.keySet()) {\\n            String str = tmap.get(key);\\n            res = res + str.substring(0,str.length()/2);\\n            \\n            if(str.length() % 2 == 1)\\n                maxOdd = key;\\n        }\\n\\t\\t// handle \"00009\" case\\n        if(!res.isEmpty() && res.charAt(res.length()-1) == \\'0\\')\\n            res = \"\";\\n\\n        StringBuilder res1 = new StringBuilder(res);\\n        if(maxOdd != \\' \\')\\n            res = res1.reverse().toString() + maxOdd + res;\\n        else\\n            res = res1.reverse().toString() + res;\\n        \\n\\t\\t// handle \"00000\" case\\n        return res.isEmpty() ? \"0\" : res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457073,
                "title": "rust-solution",
                "content": "~~~\\nimpl Solution {\\n    pub fn largest_palindromic(num: String) -> String {\\n        let mut digits = vec![0; 10];\\n        let mut odd = vec![0; 10];\\n        \\n        for c in num.chars() {\\n            digits[(c as u8 - \\'0\\' as u8) as usize] += 1;\\n        }\\n        \\n        for i in 0..10 {\\n            odd[i] = digits[i] % 2;\\n            digits[i] -= odd[i];\\n        }\\n        \\n        let mut temp: Vec<char> = vec![];\\n        for i in (0..10).rev() {\\n            while digits[i] > 0 {\\n                temp.push((\\'0\\' as u8 + i as u8) as char);\\n                digits[i] -= 2;\\n            }\\n        }\\n        if temp.is_empty() == false && temp[0] == \\'0\\' { temp.clear(); } \\n        \\n        let mut c = \\' \\';\\n        for i in (0..10).rev() {\\n            if odd[i] == 0 { continue }\\n            \\n            c = (\\'0\\' as u8 + i as u8) as char;\\n            break\\n        }\\n        \\n        let mut ret = temp.clone();\\n        if c != \\' \\' { temp.push(c); }\\n        if temp.is_empty() == false { temp.reverse(); }\\n        \\n        let temp = temp.iter().collect::<String>();\\n        let mut ret = ret.iter().collect::<String>();\\n        ret += &temp;\\n        \\n        if ret.is_empty() { return String::from(\"0\") }\\n        \\n        ret\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust"
                ],
                "code": "~~~\\nimpl Solution {\\n    pub fn largest_palindromic(num: String) -> String {\\n        let mut digits = vec![0; 10];\\n        let mut odd = vec![0; 10];\\n        \\n        for c in num.chars() {\\n            digits[(c as u8 - \\'0\\' as u8) as usize] += 1;\\n        }\\n        \\n        for i in 0..10 {\\n            odd[i] = digits[i] % 2;\\n            digits[i] -= odd[i];\\n        }\\n        \\n        let mut temp: Vec<char> = vec![];\\n        for i in (0..10).rev() {\\n            while digits[i] > 0 {\\n                temp.push((\\'0\\' as u8 + i as u8) as char);\\n                digits[i] -= 2;\\n            }\\n        }\\n        if temp.is_empty() == false && temp[0] == \\'0\\' { temp.clear(); } \\n        \\n        let mut c = \\' \\';\\n        for i in (0..10).rev() {\\n            if odd[i] == 0 { continue }\\n            \\n            c = (\\'0\\' as u8 + i as u8) as char;\\n            break\\n        }\\n        \\n        let mut ret = temp.clone();\\n        if c != \\' \\' { temp.push(c); }\\n        if temp.is_empty() == false { temp.reverse(); }\\n        \\n        let temp = temp.iter().collect::<String>();\\n        let mut ret = ret.iter().collect::<String>();\\n        ret += &temp;\\n        \\n        if ret.is_empty() { return String::from(\"0\") }\\n        \\n        ret\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2457030,
                "title": "easy-approach-full-explained-c",
                "content": "```\\n/*\\n\\nApproach: Create left, right, middle half separately.\\n          Take all multiple ocurrence(>=2) of a digit in num and distribute it in two halfs equally, store the digits with odd occurence\\n          and insert the max digit out it, in between our number.\\n          \\n          if a number occurs 5 times.....we will use it 4 times i.e., 5 - (5%2) => n-(n%2).\\n*/\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        map<char,int> freq,digitOfLeftHalf;\\n        set<char> set;\\n        for(char c:num) freq[c]++;  //store frequencies of digits in given num.\\n        \\n        for(auto it=freq.begin();it!=freq.end();it++){\\n            if(it->second>=2){  //for multiple occuring.\\n                //take even number of occurence and use half in left half of our number.\\n                digitOfLeftHalf[it->first]= (it->second - ( (it->second)%2 ))/2;\\n            }\\n            if(it->second%2==1){  //store digits with odd freq.\\n                set.insert(it->first);\\n            }\\n        }\\n        string ans, left=\"\", right, mid=\"\";\\n        bool initial=true;  //to check for leading digit.\\n        \\n        //map used here is ordered...so iterating from backwards will give largest digit first,\\n        //helps to create required largest number.\\n        for(auto it=digitOfLeftHalf.rbegin() ; it!=digitOfLeftHalf.rend() ; it++){\\n            if(initial and it->first==\\'0\\') break; //if leading digit is \\'0\\'(since largest is 0 then break the loop no bigger digit available)\\n            for(int i=0 ; i<it->second ; i++){  //create left half.\\n                left.push_back(it->first);\\n            }\\n            initial=false;\\n        }\\n        right=left;  //right half have same digits.\\n        reverse(right.begin(),right.end()); //but in reverse.\\n        if(!set.empty()){  //if there is a single ocurring number available.\\n            auto it=set.end();  //take the last number of set i.e., highest number.\\n            it--;\\n            mid.push_back(*it); //create mid.\\n        }\\n        ans = left + mid + right;  //left half + middle digit + right half.\\n        if(ans.empty()) ans=\"0\";  //if leading all zeroes in left half and no mid digit.\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Ordered Set"
                ],
                "code": "```\\n/*\\n\\nApproach: Create left, right, middle half separately.\\n          Take all multiple ocurrence(>=2) of a digit in num and distribute it in two halfs equally, store the digits with odd occurence\\n          and insert the max digit out it, in between our number.\\n          \\n          if a number occurs 5 times.....we will use it 4 times i.e., 5 - (5%2) => n-(n%2).\\n*/\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        map<char,int> freq,digitOfLeftHalf;\\n        set<char> set;\\n        for(char c:num) freq[c]++;  //store frequencies of digits in given num.\\n        \\n        for(auto it=freq.begin();it!=freq.end();it++){\\n            if(it->second>=2){  //for multiple occuring.\\n                //take even number of occurence and use half in left half of our number.\\n                digitOfLeftHalf[it->first]= (it->second - ( (it->second)%2 ))/2;\\n            }\\n            if(it->second%2==1){  //store digits with odd freq.\\n                set.insert(it->first);\\n            }\\n        }\\n        string ans, left=\"\", right, mid=\"\";\\n        bool initial=true;  //to check for leading digit.\\n        \\n        //map used here is ordered...so iterating from backwards will give largest digit first,\\n        //helps to create required largest number.\\n        for(auto it=digitOfLeftHalf.rbegin() ; it!=digitOfLeftHalf.rend() ; it++){\\n            if(initial and it->first==\\'0\\') break; //if leading digit is \\'0\\'(since largest is 0 then break the loop no bigger digit available)\\n            for(int i=0 ; i<it->second ; i++){  //create left half.\\n                left.push_back(it->first);\\n            }\\n            initial=false;\\n        }\\n        right=left;  //right half have same digits.\\n        reverse(right.begin(),right.end()); //but in reverse.\\n        if(!set.empty()){  //if there is a single ocurring number available.\\n            auto it=set.end();  //take the last number of set i.e., highest number.\\n            it--;\\n            mid.push_back(*it); //create mid.\\n        }\\n        ans = left + mid + right;  //left half + middle digit + right half.\\n        if(ans.empty()) ans=\"0\";  //if leading all zeroes in left half and no mid digit.\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456934,
                "title": "easy-implementation-hashing-cpp-with-comments",
                "content": "class Solution {\\npublic:\\n    string largestPalindromic(string num)\\n    {\\n        vector<int> m(10);\\n        int largestOdd=-1;\\n        \\n        for(int i=0; i<num.size(); i++) // store frequency of every digit\\n            m[num[i]-\\'0\\']++;            \\n        \\n        string ans=\"\";                  // In this we will create the first half of palindrome\\n        for(int i=9; i>=0; i--)         \\n        {\\n            if(m[i]%2==1)                       // if it has odd frequency then check if it\\'s greatest\\n                largestOdd= max(largestOdd, i); // oddFrequency integer we have\\n            \\n            int add= m[i]/2;            \\n            \\n            if(i==0 and ans.size()==0)      //As we don\\'t want to have leading zeroes\\n                continue;\\n            \\n            char c= i+\\'0\\';\\n                \\n            for(int i=0; i<add; i++)        //Add the characters to ans string\\n                ans+=c;                            \\n                       \\n        }\\n        \\n        string rev= ans;\\n        reverse(rev.begin(), rev.end());    // reversing the first half\\n        \\n        if(largestOdd!=-1)\\n            ans+=(largestOdd+\\'0\\');      // If we have any odd occurence digit then add it\\n        \\n        if(ans.length()==0) return \"0\"; // Handling \"00\" case\\n        ans+=rev;                       //Add the reversed first half to make the final palindrome                   \\n        return ans; \\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "String"
                ],
                "code": "class Solution {\\npublic:\\n    string largestPalindromic(string num)\\n    {\\n        vector<int> m(10);\\n        int largestOdd=-1;\\n        \\n        for(int i=0; i<num.size(); i++) // store frequency of every digit\\n            m[num[i]-\\'0\\']++;            \\n        \\n        string ans=\"\";                  // In this we will create the first half of palindrome\\n        for(int i=9; i>=0; i--)         \\n        {\\n            if(m[i]%2==1)                       // if it has odd frequency then check if it\\'s greatest\\n                largestOdd= max(largestOdd, i); // oddFrequency integer we have\\n            \\n            int add= m[i]/2;            \\n            \\n            if(i==0 and ans.size()==0)      //As we don\\'t want to have leading zeroes\\n                continue;\\n            \\n            char c= i+\\'0\\';\\n                \\n            for(int i=0; i<add; i++)        //Add the characters to ans string\\n                ans+=c;                            \\n                       \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2456830,
                "title": "bhery-dangerous-beats-100-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int> count(10,0);\\n        vector<char> pal;\\n        string ans = \"\";\\n        \\n        for(int i=0; i<num.size(); i++){\\n            count[int(num[i]) - 48]++;\\n        }\\n        \\n        int j = 0, flag = 1;\\n        char temp = \\'a\\';\\n        \\n        for(int i=9; i>=0; i--){\\n            if(count[i]!=0){\\n                if(count[i]%2 == 0){\\n                    while(count[i]--){\\n                        char c = \\'0\\' + i;\\n                        pal.push_back(c);\\n                        ans+=\"1\";\\n                    }\\n                }\\n                else if(count[i] > 1){\\n                    count[i]--;\\n                    while(count[i]--){\\n                        char c = \\'0\\' + i;\\n                        pal.push_back(c);\\n                        ans+=\"1\";\\n                    }\\n                    if(flag){\\n                        temp = \\'0\\' + i;\\n                        flag = 0;\\n                        ans+=\"1\";\\n                    }\\n                }\\n                else{\\n                    if(flag){\\n                        temp = \\'0\\' + i;\\n                        flag = 0;\\n                        ans+=\"1\";\\n                    }\\n                }\\n            }\\n        }\\n        if(temp!=\\'a\\') pal.push_back(temp);\\n    \\n        int i = 0, k=0;\\n        flag = 1 ;\\n        j = pal.size() - 1;\\n        \\n        while(i<=j){\\n            if(flag){\\n                ans[i] = pal[k];\\n                k++;\\n                i++;\\n                flag = 0;\\n            }\\n            else{\\n                ans[j] = pal[k];\\n                j--;\\n                k++;\\n                flag = 1;\\n            }\\n        }\\n        \\n        for(int i=ans.size()-1; i>=0; i--){\\n            if(ans[i] != \\'0\\'){\\n                break;\\n            }\\n            ans.pop_back();\\n        }\\n        if(ans == \"\") return \"0\";\\n        reverse(ans.begin(), ans.end());\\n        for(int i=ans.size()-1; i>=0; i--){\\n            if(ans[i] != \\'0\\'){\\n                break;\\n            }\\n            ans.pop_back();\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        if(ans == \"\") return \"0\";\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int> count(10,0);\\n        vector<char> pal;\\n        string ans = \"\";\\n        \\n        for(int i=0; i<num.size(); i++){\\n            count[int(num[i]) - 48]++;\\n        }\\n        \\n        int j = 0, flag = 1;\\n        char temp = \\'a\\';\\n        \\n        for(int i=9; i>=0; i--){\\n            if(count[i]!=0){\\n                if(count[i]%2 == 0){\\n                    while(count[i]--){\\n                        char c = \\'0\\' + i;\\n                        pal.push_back(c);\\n                        ans+=\"1\";\\n                    }\\n                }\\n                else if(count[i] > 1){\\n                    count[i]--;\\n                    while(count[i]--){\\n                        char c = \\'0\\' + i;\\n                        pal.push_back(c);\\n                        ans+=\"1\";\\n                    }\\n                    if(flag){\\n                        temp = \\'0\\' + i;\\n                        flag = 0;\\n                        ans+=\"1\";\\n                    }\\n                }\\n                else{\\n                    if(flag){\\n                        temp = \\'0\\' + i;\\n                        flag = 0;\\n                        ans+=\"1\";\\n                    }\\n                }\\n            }\\n        }\\n        if(temp!=\\'a\\') pal.push_back(temp);\\n    \\n        int i = 0, k=0;\\n        flag = 1 ;\\n        j = pal.size() - 1;\\n        \\n        while(i<=j){\\n            if(flag){\\n                ans[i] = pal[k];\\n                k++;\\n                i++;\\n                flag = 0;\\n            }\\n            else{\\n                ans[j] = pal[k];\\n                j--;\\n                k++;\\n                flag = 1;\\n            }\\n        }\\n        \\n        for(int i=ans.size()-1; i>=0; i--){\\n            if(ans[i] != \\'0\\'){\\n                break;\\n            }\\n            ans.pop_back();\\n        }\\n        if(ans == \"\") return \"0\";\\n        reverse(ans.begin(), ans.end());\\n        for(int i=ans.size()-1; i>=0; i--){\\n            if(ans[i] != \\'0\\'){\\n                break;\\n            }\\n            ans.pop_back();\\n        }\\n        \\n        reverse(ans.begin(), ans.end());\\n        if(ans == \"\") return \"0\";\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456748,
                "title": "simply-count-occurences-o-n",
                "content": "**Please Upvote If you got it : )**\\n**Time Complexity:  O(N)\\nSpace Complexity: O(longest palindrome)**\\n**Code: **\\n```\\nstring largestPalindromic(string &num) {\\n        string ans;\\n        vector<int> fq(10,0);\\n\\t\\t// store frequency\\n        for(char &x: num){\\n            fq[x-\\'0\\']++;\\n        }\\n        for(int i=9;i>=0;--i){\\n\\t\\t    // if frequency >1\\n            if(fq[i]>1){\\n\\t\\t\\t    // edge case, so we don\\'t have 0\\'s at beginning\\n                if(ans.size()==0&&i==0) continue;\\n\\t\\t\\t\\t// copy half of the element\\n                int cnt=fq[i]/2;\\n                int sub=cnt;\\n                while(cnt){\\n                    ans+=\\'0\\'+i;\\n                    cnt--;\\n                }\\n\\t\\t\\t\\t// decrement original frequency as we used elements\\n                fq[i]-=(2*sub);\\n            }\\n        }\\n\\t\\t// get reverse of string obtained so far\\n        string res=ans;\\n        reverse(ans.begin(),ans.end());\\n\\t\\t// add an extra character in between to increment length of palindrome\\n        for(int i=9;i>=0;--i){\\n            if(fq[i]>0){\\n                res+=\\'0\\'+i;\\n                break;\\n            }\\n        }\\n        return res+ans;\\n    }",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "**Please Upvote If you got it : )**\\n**Time Complexity:  O(N)\\nSpace Complexity: O(longest palindrome)**\\n**Code: **\\n```\\nstring largestPalindromic(string &num) {\\n        string ans;\\n        vector<int> fq(10,0);\\n\\t\\t// store frequency\\n        for(char &x: num){\\n            fq[x-\\'0\\']++;\\n        }\\n        for(int i=9;i>=0;--i){\\n\\t\\t    // if frequency >1\\n            if(fq[i]>1){\\n\\t\\t\\t    // edge case, so we don\\'t have 0\\'s at beginning\\n                if(ans.size()==0&&i==0) continue;\\n\\t\\t\\t\\t// copy half of the element\\n                int cnt=fq[i]/2;\\n                int sub=cnt;\\n                while(cnt){\\n                    ans+=\\'0\\'+i;\\n                    cnt--;\\n                }\\n\\t\\t\\t\\t// decrement original frequency as we used elements\\n                fq[i]-=(2*sub);\\n            }\\n        }\\n\\t\\t// get reverse of string obtained so far\\n        string res=ans;\\n        reverse(ans.begin(),ans.end());\\n\\t\\t// add an extra character in between to increment length of palindrome\\n        for(int i=9;i>=0;--i){\\n            if(fq[i]>0){\\n                res+=\\'0\\'+i;\\n                break;\\n            }\\n        }\\n        return res+ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2456618,
                "title": "python-easy-to-understand",
                "content": "\\tclass Solution:\\n\\t\\tdef largestPalindromic(self, num: str) -> str:\\n\\t\\t\\tif num == \"0\" * len(num):\\n\\t\\t\\t\\treturn \"0\"\\n\\t\\t\\tcnt = collections.Counter(num)\\n\\t\\t\\tdigits = sorted(cnt.keys(), reverse = True)\\n\\t\\t\\tres = \"\"\\n\\t\\t\\tsingle = \"\"\\n\\t\\t\\tfor digit in digits:\\n\\t\\t\\t\\tif res or digit != \"0\":\\n\\t\\t\\t\\t\\tres += digit * (cnt[digit] // 2)\\n\\t\\t\\t\\tif cnt[digit] % 2 == 1:\\n\\t\\t\\t\\t\\tif not single:\\n\\t\\t\\t\\t\\t\\tsingle = digit        \\n\\t\\t\\treturn res + single + res[::-1] if single else res + res[::-1]",
                "solutionTags": [],
                "code": "\\tclass Solution:\\n\\t\\tdef largestPalindromic(self, num: str) -> str:\\n\\t\\t\\tif num == \"0\" * len(num):\\n\\t\\t\\t\\treturn \"0\"\\n\\t\\t\\tcnt = collections.Counter(num)\\n\\t\\t\\tdigits = sorted(cnt.keys(), reverse = True)\\n\\t\\t\\tres = \"\"\\n\\t\\t\\tsingle = \"\"\\n\\t\\t\\tfor digit in digits:\\n\\t\\t\\t\\tif res or digit != \"0\":\\n\\t\\t\\t\\t\\tres += digit * (cnt[digit] // 2)\\n\\t\\t\\t\\tif cnt[digit] % 2 == 1:\\n\\t\\t\\t\\t\\tif not single:\\n\\t\\t\\t\\t\\t\\tsingle = digit        \\n\\t\\t\\treturn res + single + res[::-1] if single else res + res[::-1]",
                "codeTag": "Java"
            },
            {
                "id": 2456610,
                "title": "java-easy",
                "content": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int hash[] = new int[10];\\n        \\n        for(int i=0; i<num.length(); i++){\\n            hash[num.charAt(i)-\\'0\\']++;\\n        }\\n        \\n        StringBuilder ans=new StringBuilder(), substr=new StringBuilder();\\n        int idx=-1;\\n        \\n        for(int i=9;i>0; i--){\\n            if(hash[i]==0) continue;\\n            for(int j=0; j<hash[i]/2; j++) substr.append(i);\\n            ans.append(substr);\\n            substr = new StringBuilder();\\n        }\\n        \\n        if(ans.length()>0 && hash[0]!=0){\\n            for(int j=0; j<hash[0]/2; j++) substr.append(0);\\n            ans.append(substr);\\n            substr = new StringBuilder();\\n        }\\n        \\n        StringBuilder rev = new StringBuilder();\\n        for(int i=ans.length()-1; i>=0; i--)rev.append(ans.charAt(i));\\n        \\n        for(int i=9;i>=0; i--){\\n           if(hash[i]%2==1){\\n               ans.append(i);\\n               break;\\n           }\\n        }\\n        \\n        ans.append(rev);\\n        if(ans.length()==0) return \"0\";\\n        return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int hash[] = new int[10];\\n        \\n        for(int i=0; i<num.length(); i++){\\n            hash[num.charAt(i)-\\'0\\']++;\\n        }\\n        \\n        StringBuilder ans=new StringBuilder(), substr=new StringBuilder();\\n        int idx=-1;\\n        \\n        for(int i=9;i>0; i--){\\n            if(hash[i]==0) continue;\\n            for(int j=0; j<hash[i]/2; j++) substr.append(i);\\n            ans.append(substr);\\n            substr = new StringBuilder();\\n        }\\n        \\n        if(ans.length()>0 && hash[0]!=0){\\n            for(int j=0; j<hash[0]/2; j++) substr.append(0);\\n            ans.append(substr);\\n            substr = new StringBuilder();\\n        }\\n        \\n        StringBuilder rev = new StringBuilder();\\n        for(int i=ans.length()-1; i>=0; i--)rev.append(ans.charAt(i));\\n        \\n        for(int i=9;i>=0; i--){\\n           if(hash[i]%2==1){\\n               ans.append(i);\\n               break;\\n           }\\n        }\\n        \\n        ans.append(rev);\\n        if(ans.length()==0) return \"0\";\\n        return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4086458,
                "title": "treemap-solution-with-detailed-explanation",
                "content": "# Intuition\\nLarger numbers will always have either more digits, or larger digits to the left.\\n\\n\"99\" > \"89\"\\n\"123\" < \"321\"\\n\"12\" > \"3\"\\n\\nThus to create a largest palindrome, you want the left side of the string to be all digits with a frequency count of at least 2 in descending order.\\n\\n# Approach\\n1. Create a frequency map sorted in descending order by key.\\n2. Iterate over the map, add all pairs of digits you can in the middle of your result. The progression looks like: `\"\"` -> `\"77\"` -> `\"7447\"` -> `\"744447\"`. Note that beginning with any `0s` results in an invalid number.\\n3. If there are any remaining entries in the map with a value of `1`, add the highest value one in the middle of the string.\\n\\n# Complexity\\n- Time complexity: `O(N)`\\nWe insert N elements in a TreeMap, but the TreeMap will only ever contain 9 entries, thus `O(N log 9)` -> `O(N)`\\nIterating over `num` requires checking all elements in `num`: `O(N)`\\nNote that iterating over the map is only `O(9)`\\n\\n- Space complexity: `O(1)`\\nMaximum of 9 possible entries in the map.\\n\\n# Code\\n```\\nclass Solution {\\n    fun largestPalindromic(num: String): String {\\n        val tm = TreeMap<Int, Int>(compareByDescending<Int> { it })\\n        // Creates a digit frequency count, then adds to TreeMap\\n        num.groupingBy { it - \\'0\\' }.eachCount().let {\\n            tm.putAll(it)\\n        }\\n        val sb = StringBuilder()\\n        for ((key, value) in tm) {\\n            if (key == 0 && sb.length == 0) continue\\n            while (tm.getValue(key) > 1) {\\n                val mid = sb.length / 2\\n                sb.insert(mid, key)\\n                sb.insert(mid, key)\\n                tm[key] = tm.getValue(key) - 2\\n            }\\n        }\\n        for ((key, value) in tm) {\\n            if (value > 0) {\\n                val mid = sb.length / 2\\n                sb.insert(mid, key)\\n                break\\n            }\\n        }\\n        return sb.toString()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun largestPalindromic(num: String): String {\\n        val tm = TreeMap<Int, Int>(compareByDescending<Int> { it })\\n        // Creates a digit frequency count, then adds to TreeMap\\n        num.groupingBy { it - \\'0\\' }.eachCount().let {\\n            tm.putAll(it)\\n        }\\n        val sb = StringBuilder()\\n        for ((key, value) in tm) {\\n            if (key == 0 && sb.length == 0) continue\\n            while (tm.getValue(key) > 1) {\\n                val mid = sb.length / 2\\n                sb.insert(mid, key)\\n                sb.insert(mid, key)\\n                tm[key] = tm.getValue(key) - 2\\n            }\\n        }\\n        for ((key, value) in tm) {\\n            if (value > 0) {\\n                val mid = sb.length / 2\\n                sb.insert(mid, key)\\n                break\\n            }\\n        }\\n        return sb.toString()\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4035411,
                "title": "simple-solution-using-hashmap",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        unordered_map<char, int>umap;\\n        for(int i=0;i<num.size();i++){\\n            umap[num[i]]++;\\n        }\\n        priority_queue<pair<char, int>>pq;\\n        for(auto it: umap){\\n            pq.push({it.first, it.second});\\n        }\\n        string str = \"\";\\n        stack<char>st;\\n        char temp = \\'/\\';\\n        while(!pq.empty()){\\n            pair<char,int>p = pq.top();\\n            pq.pop();\\n            if(str.empty()){\\n                if(p.first==\\'0\\'){\\n                    continue;\\n                }\\n            }\\n            while(1){\\n                if(p.second==1){\\n                    temp = max(temp, p.first);\\n                    break;\\n                }\\n                str.push_back(p.first);\\n                st.push(p.first);\\n                p.second-=2;\\n                if(p.second==0){\\n                    break;\\n                }\\n            }\\n        }\\n        if(temp!=\\'/\\'){\\n            str.push_back(temp);\\n        }\\n        while(!st.empty()){\\n            str.push_back(st.top());\\n            st.pop();\\n        }\\n        if(str==\"\"){\\n            return \"0\";\\n        }\\n        return str;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Stack",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        unordered_map<char, int>umap;\\n        for(int i=0;i<num.size();i++){\\n            umap[num[i]]++;\\n        }\\n        priority_queue<pair<char, int>>pq;\\n        for(auto it: umap){\\n            pq.push({it.first, it.second});\\n        }\\n        string str = \"\";\\n        stack<char>st;\\n        char temp = \\'/\\';\\n        while(!pq.empty()){\\n            pair<char,int>p = pq.top();\\n            pq.pop();\\n            if(str.empty()){\\n                if(p.first==\\'0\\'){\\n                    continue;\\n                }\\n            }\\n            while(1){\\n                if(p.second==1){\\n                    temp = max(temp, p.first);\\n                    break;\\n                }\\n                str.push_back(p.first);\\n                st.push(p.first);\\n                p.second-=2;\\n                if(p.second==0){\\n                    break;\\n                }\\n            }\\n        }\\n        if(temp!=\\'/\\'){\\n            str.push_back(temp);\\n        }\\n        while(!st.empty()){\\n            str.push_back(st.top());\\n            st.pop();\\n        }\\n        if(str==\"\"){\\n            return \"0\";\\n        }\\n        return str;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019844,
                "title": "hashmap-simple-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n      map<char,int, greater<int> >mp;\\n        for(auto c:num){\\n            mp[c]++;\\n        }\\n        string ans=\"\";\\n        char mid=\\'\\\\0\\';\\n        bool f=0, m=0;\\n        for(auto x:mp){\\n             if(x.second%2==1 && m==0){\\n                mid=x.first;\\n                 m=1;\\n            }\\n            if(x.first==\\'0\\' && f==0){\\n                continue;\\n            }\\n            else if(x.second>=2){\\n                  f=1;\\n                int t=x.second/2;\\n                while(t-->0){\\n                    ans+=x.first;\\n                }\\n            }\\n        }\\n          string s=ans;\\n          reverse(s.begin(),s.end());\\n          if(mid!=\\'\\\\0\\'){\\n              ans+=mid;\\n          }\\n          ans+=s;\\n          if(ans==\"\"){\\n              return \"0\";\\n          }\\n          return ans;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n      map<char,int, greater<int> >mp;\\n        for(auto c:num){\\n            mp[c]++;\\n        }\\n        string ans=\"\";\\n        char mid=\\'\\\\0\\';\\n        bool f=0, m=0;\\n        for(auto x:mp){\\n             if(x.second%2==1 && m==0){\\n                mid=x.first;\\n                 m=1;\\n            }\\n            if(x.first==\\'0\\' && f==0){\\n                continue;\\n            }\\n            else if(x.second>=2){\\n                  f=1;\\n                int t=x.second/2;\\n                while(t-->0){\\n                    ans+=x.first;\\n                }\\n            }\\n        }\\n          string s=ans;\\n          reverse(s.begin(),s.end());\\n          if(mid!=\\'\\\\0\\'){\\n              ans+=mid;\\n          }\\n          ans+=s;\\n          if(ans==\"\"){\\n              return \"0\";\\n          }\\n          return ans;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4006832,
                "title": "easy-c-solution-using-unordered-map",
                "content": "# Approach\\nUse hashmap to keep the count of all the digits.\\nConstruct the left side of the result. Get the reverse of the left side to obtain right site. Concatenate both sides.\\nIf applicable, add one extra remaining character in the middle of the resultant string before concatenation.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        unordered_map<char, int> m;\\n        string res;\\n        for(int i=0; i<num.size(); i++)\\n        {\\n            m[num[i]]++;\\n        }\\n        for(int i=\\'9\\'; i>=\\'0\\'; i--)\\n        {\\n            if(m[i]>=2 && (i!=\\'0\\' || res.size()))\\n            {\\n                res+=string(m[i]/2, i);\\n                m[i]%=2;\\n            }\\n        }\\n        string r=res;\\n        reverse(r.begin(), r.end());\\n        for(int i=\\'9\\'; i>=\\'0\\'; i--)\\n        {\\n            if(m[i]>0)\\n            {\\n                res+=i;\\n                break;\\n            }\\n        }\\n        res+=r;\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        unordered_map<char, int> m;\\n        string res;\\n        for(int i=0; i<num.size(); i++)\\n        {\\n            m[num[i]]++;\\n        }\\n        for(int i=\\'9\\'; i>=\\'0\\'; i--)\\n        {\\n            if(m[i]>=2 && (i!=\\'0\\' || res.size()))\\n            {\\n                res+=string(m[i]/2, i);\\n                m[i]%=2;\\n            }\\n        }\\n        string r=res;\\n        reverse(r.begin(), r.end());\\n        for(int i=\\'9\\'; i>=\\'0\\'; i--)\\n        {\\n            if(m[i]>0)\\n            {\\n                res+=i;\\n                break;\\n            }\\n        }\\n        res+=r;\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998945,
                "title": "python-solution-with-comments-and-good-naming",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        from collections import defaultdict\\n\\n        # Step 1: Create a dictionary to count the occurrences of each digit.\\n        digit_count = defaultdict(int)\\n        for x in num:\\n            digit_count[x] += 1\\n\\n        # Step 2: Create a list of digits in decreasing order (from 9 to 0).\\n        digits = [str(x) for x in range(9, -1, -1)]\\n\\n        # Step 3: Initialize a list to build the largest palindromic integer.\\n        palindrome = []\\n\\n        # Step 4: Iterate through the digits in decreasing order.\\n        for digit in digits:\\n            count = digit_count[digit]\\n            n = len(palindrome)\\n\\n            if n % 2 == 0:\\n                # If the current palindrome length is even:\\n                if count > 0:\\n                    # Add the digit to both sides of the palindrome.\\n                    palindrome = palindrome[:n // 2] + [digit] * count + palindrome[n // 2:]\\n            else:\\n                # If the current palindrome length is odd:\\n                if digit == \\'0\\':\\n                    if len(palindrome) != 1:\\n                        # If there is more than one digit in the palindrome, add \\'0\\' in the middle.\\n                        palindrome = palindrome[:n // 2] + [\\'0\\'] * (count // 2) + [palindrome[n // 2]] + [\\'0\\'] * (count // 2) + palindrome[n // 2 + 1:]\\n                else:\\n                    # Add the digit to both sides of the palindrome.\\n                    if count >= 2:\\n                        palindrome = palindrome[:n // 2] + [digit] * (count // 2) + [palindrome[n // 2]] + [digit] * (count // 2) + palindrome[n // 2 + 1:]\\n\\n        # Step 5: Convert the list to a string and remove leading zeroes.\\n        result = \\'\\'.join(palindrome).lstrip(\\'0\\')\\n\\n        # Step 6: Return the largest palindromic integer as a string.\\n        return result if result else \\'0\\'\\n\\n\\n\\n        \\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        from collections import defaultdict\\n\\n        # Step 1: Create a dictionary to count the occurrences of each digit.\\n        digit_count = defaultdict(int)\\n        for x in num:\\n            digit_count[x] += 1\\n\\n        # Step 2: Create a list of digits in decreasing order (from 9 to 0).\\n        digits = [str(x) for x in range(9, -1, -1)]\\n\\n        # Step 3: Initialize a list to build the largest palindromic integer.\\n        palindrome = []\\n\\n        # Step 4: Iterate through the digits in decreasing order.\\n        for digit in digits:\\n            count = digit_count[digit]\\n            n = len(palindrome)\\n\\n            if n % 2 == 0:\\n                # If the current palindrome length is even:\\n                if count > 0:\\n                    # Add the digit to both sides of the palindrome.\\n                    palindrome = palindrome[:n // 2] + [digit] * count + palindrome[n // 2:]\\n            else:\\n                # If the current palindrome length is odd:\\n                if digit == \\'0\\':\\n                    if len(palindrome) != 1:\\n                        # If there is more than one digit in the palindrome, add \\'0\\' in the middle.\\n                        palindrome = palindrome[:n // 2] + [\\'0\\'] * (count // 2) + [palindrome[n // 2]] + [\\'0\\'] * (count // 2) + palindrome[n // 2 + 1:]\\n                else:\\n                    # Add the digit to both sides of the palindrome.\\n                    if count >= 2:\\n                        palindrome = palindrome[:n // 2] + [digit] * (count // 2) + [palindrome[n // 2]] + [digit] * (count // 2) + palindrome[n // 2 + 1:]\\n\\n        # Step 5: Convert the list to a string and remove leading zeroes.\\n        result = \\'\\'.join(palindrome).lstrip(\\'0\\')\\n\\n        # Step 6: Return the largest palindromic integer as a string.\\n        return result if result else \\'0\\'\\n\\n\\n\\n        \\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988096,
                "title": "very-easy-to-tackle-javascript-commented",
                "content": "# This is self described in the problem itself. Please upvote if you like the solution Or comment if you have any query\\n\\n# Code\\n```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\n\\n// repeat function for repeating characters in the beginning of string\\nvar repeat = function(count, c, s) {\\n    let result = s;\\n\\n    for(let i = 0; i < count; i++) {\\n        result = result + c;\\n    }\\n    return result;\\n}\\n\\n// reverse of string\\nvar reverse = function(s) {\\n    let result = \"\";\\n\\n    for(let i = 0; i < s.length; i++) {\\n        result = s[i] + result;\\n    }\\n    return result;\\n}\\n\\n// here we have used remain for odd number of \\n// frequency so that we can place it middle of the string.\\n\\nfunction largestPalindromic (num) {\\n   let s = num.toString(), map = {}, result = \"\", remain = \"\";\\n\\n   for(let c of s) {\\n       map[c] = (map[c] || 0) + 1;\\n   }\\n\\n   for(let i = 9; i >= 0; i--) {\\n       // if result is still empty while traversing 0 so no need to add zero;\\n       if(i == 0 && result == \"\") break;\\n\\n\\n       if(map[i] & 1 && map[i] > 1) {\\n           result = repeat(parseInt(map[i] / 2), i, result);\\n           remain = Math.max(i, remain);\\n       } else if(map[i] % 2 == 0) {\\n           result = repeat((map[i] / 2), i, result);\\n       } else if(map[i] == 1) {\\n           remain = Math.max(i, remain);\\n       }\\n   } \\n\\n\\n   // checking if there is only zeros in the string return \\'0\\';\\n   if(result == \"\" && map[0] > 0 && remain === \"\") return \\'0\\'\\n\\n   return result + remain + reverse(result);\\n\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\n\\n// repeat function for repeating characters in the beginning of string\\nvar repeat = function(count, c, s) {\\n    let result = s;\\n\\n    for(let i = 0; i < count; i++) {\\n        result = result + c;\\n    }\\n    return result;\\n}\\n\\n// reverse of string\\nvar reverse = function(s) {\\n    let result = \"\";\\n\\n    for(let i = 0; i < s.length; i++) {\\n        result = s[i] + result;\\n    }\\n    return result;\\n}\\n\\n// here we have used remain for odd number of \\n// frequency so that we can place it middle of the string.\\n\\nfunction largestPalindromic (num) {\\n   let s = num.toString(), map = {}, result = \"\", remain = \"\";\\n\\n   for(let c of s) {\\n       map[c] = (map[c] || 0) + 1;\\n   }\\n\\n   for(let i = 9; i >= 0; i--) {\\n       // if result is still empty while traversing 0 so no need to add zero;\\n       if(i == 0 && result == \"\") break;\\n\\n\\n       if(map[i] & 1 && map[i] > 1) {\\n           result = repeat(parseInt(map[i] / 2), i, result);\\n           remain = Math.max(i, remain);\\n       } else if(map[i] % 2 == 0) {\\n           result = repeat((map[i] / 2), i, result);\\n       } else if(map[i] == 1) {\\n           remain = Math.max(i, remain);\\n       }\\n   } \\n\\n\\n   // checking if there is only zeros in the string return \\'0\\';\\n   if(result == \"\" && map[0] > 0 && remain === \"\") return \\'0\\'\\n\\n   return result + remain + reverse(result);\\n\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3960065,
                "title": "crayz-shit",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        num=sorted(num,reverse=True)\\n        dic=dict()\\n        for i in num:\\n            if i in dic:dic[i]+=1\\n            else:dic[i]=1\\n        odd,arr=True,[]\\n        for i,j in dic.items():\\n            if j%2==0:arr.append([i,j])\\n            else:\\n                if odd:arr.append([i,j])\\n                else:\\n                    if j-1!=0:arr.append([i,j-1])\\n            if j%2==1:odd=False\\n        odd=False\\n        if arr[0][1]==1:arr.append(arr.pop(0))\\n        if arr[0][0]==\"0\":\\n            if len(arr)==1:return \"0\"\\n            return arr[1][0]\\n        res=\"\"\\n        for i in arr:\\n            ind=len(res)//2\\n            if odd:\\n                count=i[1]//2\\n                res= res[:ind]  + count*i[0] + res[ind] + count*i[0] + res[ind+1:]\\n            else:\\n                res=res[:ind] + i[1]*i[0] + res[ind:]\\n            if i[1]%2==1:odd=True\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Hash Table",
                    "String",
                    "Simulation"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        num=sorted(num,reverse=True)\\n        dic=dict()\\n        for i in num:\\n            if i in dic:dic[i]+=1\\n            else:dic[i]=1\\n        odd,arr=True,[]\\n        for i,j in dic.items():\\n            if j%2==0:arr.append([i,j])\\n            else:\\n                if odd:arr.append([i,j])\\n                else:\\n                    if j-1!=0:arr.append([i,j-1])\\n            if j%2==1:odd=False\\n        odd=False\\n        if arr[0][1]==1:arr.append(arr.pop(0))\\n        if arr[0][0]==\"0\":\\n            if len(arr)==1:return \"0\"\\n            return arr[1][0]\\n        res=\"\"\\n        for i in arr:\\n            ind=len(res)//2\\n            if odd:\\n                count=i[1]//2\\n                res= res[:ind]  + count*i[0] + res[ind] + count*i[0] + res[ind+1:]\\n            else:\\n                res=res[:ind] + i[1]*i[0] + res[ind:]\\n            if i[1]%2==1:odd=True\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3905338,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n\\n    public class Number{\\n        int num;\\n        int freq;\\n\\n        Number(int num, int freq){\\n            this.num = num;\\n            this.freq = freq;\\n        }\\n    }\\n\\n    public static class NumberComparator implements Comparator<Number>{\\n        public int compare(Number n1, Number n2){\\n            if(n1.num>n2.num) return 1;\\n            else if(n1.num<n2.num) return -1;\\n            else{\\n                if(n1.freq>n2.freq) return 1;\\n                else if(n1.freq<n2.freq) return -1;\\n                else return 0;\\n            }\\n        }\\n    }\\n\\n\\n    public String largestPalindromic(String str) {\\n       HashMap<Integer,Integer> hp = new HashMap<>();\\n\\n       for(int i=0; i<str.length(); i++){\\n           int a = str.charAt(i)-48;\\n           hp.put(a,hp.getOrDefault(a,0)+1);\\n       }\\n\\n\\n       StringBuilder s = new StringBuilder();\\n\\n       int x = Integer.MIN_VALUE;\\n\\n       for(int i=0; i<=9; i++){\\n           if(hp.containsKey(i)){\\n               if(hp.get(i)==1 && i>x) x=i;\\n               else{\\n                   int freq = hp.get(i);\\n                   if(freq%2!=0 && freq>2 && s.length()==0){\\n                       s.append(String.valueOf(i).repeat(freq));\\n                   }else{\\n\\n                       if(freq%2!=0){\\n                           if(i>x) x=i;\\n                           freq-=1;\\n                       }\\n                       s.append(String.valueOf(i).repeat(freq/2));\\n                       s.insert(0,String.valueOf(i).repeat(freq/2));\\n                    }\\n                }\\n            }\\n       }\\n\\n       if(x!=Integer.MIN_VALUE){\\n           int n = s.length();\\n           if(n%2!=0){\\n               if(s.charAt(n/2)-48<x){\\n                   s.replace(n/2,n/2+1,String.valueOf(x));\\n               }\\n           }else{\\n               s.insert(n/2,String.valueOf(x));\\n           }\\n       }\\n\\n       int i=s.length()-1;\\n       while(s.length()!=0 && s.charAt(i)==\\'0\\'){\\n           s.deleteCharAt(i);\\n           i--;\\n       }\\n\\n       if(s.length()==0) return \"0\";\\n\\n       s.reverse();\\n       i=s.length()-1;\\n\\n       while(s.charAt(i)==\\'0\\'){\\n           s.deleteCharAt(i);\\n           i--;\\n       }\\n\\n       s.reverse();\\n\\n       return s.toString();\\n\\n    //    arr.sort(new NumberComparator());\\n\\n    //    int x = Integer.MAX_VALUE;\\n\\n    //    StringBuilder ans = new StringBuilder();\\n\\n    //    for(int i=0; i<arr.size(); i++){\\n    //        Number n = arr.get(i);\\n    //        if(n.freq==1) x = n.num;\\n    //        else if(n.freq%2==0){\\n    //            int k = n.freq/2;\\n    //            String str = String.valueOf(n.num);\\n    //            ans.append(str.repeat(k));\\n    //            ans.insert(0,str.repeat(k));\\n    //        }\\n    //    }\\n\\n    //    if(x!=Integer.MAX_VALUE){\\n    //        ans.insert(ans.length()/2,String.valueOf(x));\\n    //    }\\n\\n    //    int i=ans.length()-1;\\n    //    while(ans.charAt(i)==\\'0\\'){\\n    //        ans.deleteCharAt(i);\\n    //        i--;\\n    //    }\\n\\n    //    ans.reverse();\\n    //    i=ans.length()-1;\\n\\n    //    while(ans.charAt(i)==\\'0\\'){\\n    //        ans.deleteCharAt(i);\\n    //        i--;\\n    //    }\\n\\n    //    ans.reverse();\\n\\n    //    return ans.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n\\n    public class Number{\\n        int num;\\n        int freq;\\n\\n        Number(int num, int freq){\\n            this.num = num;\\n            this.freq = freq;\\n        }\\n    }\\n\\n    public static class NumberComparator implements Comparator<Number>{\\n        public int compare(Number n1, Number n2){\\n            if(n1.num>n2.num) return 1;\\n            else if(n1.num<n2.num) return -1;\\n            else{\\n                if(n1.freq>n2.freq) return 1;\\n                else if(n1.freq<n2.freq) return -1;\\n                else return 0;\\n            }\\n        }\\n    }\\n\\n\\n    public String largestPalindromic(String str) {\\n       HashMap<Integer,Integer> hp = new HashMap<>();\\n\\n       for(int i=0; i<str.length(); i++){\\n           int a = str.charAt(i)-48;\\n           hp.put(a,hp.getOrDefault(a,0)+1);\\n       }\\n\\n\\n       StringBuilder s = new StringBuilder();\\n\\n       int x = Integer.MIN_VALUE;\\n\\n       for(int i=0; i<=9; i++){\\n           if(hp.containsKey(i)){\\n               if(hp.get(i)==1 && i>x) x=i;\\n               else{\\n                   int freq = hp.get(i);\\n                   if(freq%2!=0 && freq>2 && s.length()==0){\\n                       s.append(String.valueOf(i).repeat(freq));\\n                   }else{\\n\\n                       if(freq%2!=0){\\n                           if(i>x) x=i;\\n                           freq-=1;\\n                       }\\n                       s.append(String.valueOf(i).repeat(freq/2));\\n                       s.insert(0,String.valueOf(i).repeat(freq/2));\\n                    }\\n                }\\n            }\\n       }\\n\\n       if(x!=Integer.MIN_VALUE){\\n           int n = s.length();\\n           if(n%2!=0){\\n               if(s.charAt(n/2)-48<x){\\n                   s.replace(n/2,n/2+1,String.valueOf(x));\\n               }\\n           }else{\\n               s.insert(n/2,String.valueOf(x));\\n           }\\n       }\\n\\n       int i=s.length()-1;\\n       while(s.length()!=0 && s.charAt(i)==\\'0\\'){\\n           s.deleteCharAt(i);\\n           i--;\\n       }\\n\\n       if(s.length()==0) return \"0\";\\n\\n       s.reverse();\\n       i=s.length()-1;\\n\\n       while(s.charAt(i)==\\'0\\'){\\n           s.deleteCharAt(i);\\n           i--;\\n       }\\n\\n       s.reverse();\\n\\n       return s.toString();\\n\\n    //    arr.sort(new NumberComparator());\\n\\n    //    int x = Integer.MAX_VALUE;\\n\\n    //    StringBuilder ans = new StringBuilder();\\n\\n    //    for(int i=0; i<arr.size(); i++){\\n    //        Number n = arr.get(i);\\n    //        if(n.freq==1) x = n.num;\\n    //        else if(n.freq%2==0){\\n    //            int k = n.freq/2;\\n    //            String str = String.valueOf(n.num);\\n    //            ans.append(str.repeat(k));\\n    //            ans.insert(0,str.repeat(k));\\n    //        }\\n    //    }\\n\\n    //    if(x!=Integer.MAX_VALUE){\\n    //        ans.insert(ans.length()/2,String.valueOf(x));\\n    //    }\\n\\n    //    int i=ans.length()-1;\\n    //    while(ans.charAt(i)==\\'0\\'){\\n    //        ans.deleteCharAt(i);\\n    //        i--;\\n    //    }\\n\\n    //    ans.reverse();\\n    //    i=ans.length()-1;\\n\\n    //    while(ans.charAt(i)==\\'0\\'){\\n    //        ans.deleteCharAt(i);\\n    //        i--;\\n    //    }\\n\\n    //    ans.reverse();\\n\\n    //    return ans.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3873862,
                "title": "easiest-solution-c-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        priority_queue<pair<char,int>>pq;\\n        unordered_map<char,int>mp;\\n        for(auto x:num){\\n            mp[x]++;\\n            \\n        }\\n        char maxi;\\n        for(auto x:mp)\\n            pq.push({x.first,x.second});\\n        bool flag=true;\\n        string ans=\"\";\\n        while(!pq.empty()){\\n            auto top=pq.top().first;\\n            int frequency=pq.top().second;\\n            pq.pop();\\n            if(frequency%2==0){\\n                int a=frequency/2;\\n                int i=0;\\n                while(i<a){\\n                    \\n                    ans.push_back(top);\\n                    i++; \\n                }\\n                \\n            }\\n            else\\n            {\\n                if(frequency/2>=1){\\n                    int a=frequency/2;\\n                int i=0;\\n                while(i<a){\\n                    ans.push_back(top);\\n                    i++; \\n                }\\n                }\\n                if(flag)\\n                {\\n                    maxi=top;\\n                    flag=false;\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        bool f=true;\\n        string res=\"\";\\n        string temp=\"\";\\n        int i=0;\\n        while(ans[i]==\\'0\\')\\n            i++;\\n        if(i==ans.size() && flag)\\n        {\\n            res.push_back(\\'0\\');\\n            return res;\\n        }\\n        for(int k=i;k<ans.size();k++)\\n            res.push_back(ans[k]);\\n         string rev=res;\\n        if(flag==false){\\n            res.push_back(maxi);\\n        }\\n       \\n        reverse(rev.begin(),rev.end());\\n            res+=rev;\\n        return res;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        priority_queue<pair<char,int>>pq;\\n        unordered_map<char,int>mp;\\n        for(auto x:num){\\n            mp[x]++;\\n            \\n        }\\n        char maxi;\\n        for(auto x:mp)\\n            pq.push({x.first,x.second});\\n        bool flag=true;\\n        string ans=\"\";\\n        while(!pq.empty()){\\n            auto top=pq.top().first;\\n            int frequency=pq.top().second;\\n            pq.pop();\\n            if(frequency%2==0){\\n                int a=frequency/2;\\n                int i=0;\\n                while(i<a){\\n                    \\n                    ans.push_back(top);\\n                    i++; \\n                }\\n                \\n            }\\n            else\\n            {\\n                if(frequency/2>=1){\\n                    int a=frequency/2;\\n                int i=0;\\n                while(i<a){\\n                    ans.push_back(top);\\n                    i++; \\n                }\\n                }\\n                if(flag)\\n                {\\n                    maxi=top;\\n                    flag=false;\\n                }\\n                \\n            }\\n            \\n        }\\n        \\n        bool f=true;\\n        string res=\"\";\\n        string temp=\"\";\\n        int i=0;\\n        while(ans[i]==\\'0\\')\\n            i++;\\n        if(i==ans.size() && flag)\\n        {\\n            res.push_back(\\'0\\');\\n            return res;\\n        }\\n        for(int k=i;k<ans.size();k++)\\n            res.push_back(ans[k]);\\n         string rev=res;\\n        if(flag==false){\\n            res.push_back(maxi);\\n        }\\n       \\n        reverse(rev.begin(),rev.end());\\n            res+=rev;\\n        return res;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3864738,
                "title": "rust-o-n-time-o-n-space",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Count digits in the input\\n* Construct the left part\\n    * Larger digits with the count > 1 go first\\n    * Skip 0 if the left part is empty\\n* Pick the middle digit\\n    * Largest digit with the odd count\\n    * Pick 0 only if the left part is empty\\n* Output left + [mid] + reverse(left)\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nimpl Solution {\\n    pub fn largest_palindromic(num: String) -> String {\\n        let freq = num.bytes().fold([0; 10], |mut acc, b| { acc[(b - b\\'0\\') as usize] += 1; acc });\\n\\n        let mut left = vec![];\\n        let mut mid = None;\\n        for (digit, freq) in freq.into_iter().enumerate().filter(|&(_, f)| *f > 0).rev() {\\n            if freq % 2 != 0 || (digit == 0 && left.is_empty()) { mid.get_or_insert(digit); }\\n            if digit == 0 && left.is_empty() { continue; }\\n            \\n            for _ in 0..(freq / 2) {\\n                left.push(b\\'0\\' + digit as u8);\\n            }\\n        }\\n        let mut right = left.iter().rev().cloned().collect::<Vec<_>>();\\n        if let Some(digit) = mid { left.push(b\\'0\\' + digit as u8); }\\n        left.append(&mut right);\\n\\n        String::from_utf8(left).unwrap()\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust"
                ],
                "code": "```\\nimpl Solution {\\n    pub fn largest_palindromic(num: String) -> String {\\n        let freq = num.bytes().fold([0; 10], |mut acc, b| { acc[(b - b\\'0\\') as usize] += 1; acc });\\n\\n        let mut left = vec![];\\n        let mut mid = None;\\n        for (digit, freq) in freq.into_iter().enumerate().filter(|&(_, f)| *f > 0).rev() {\\n            if freq % 2 != 0 || (digit == 0 && left.is_empty()) { mid.get_or_insert(digit); }\\n            if digit == 0 && left.is_empty() { continue; }\\n            \\n            for _ in 0..(freq / 2) {\\n                left.push(b\\'0\\' + digit as u8);\\n            }\\n        }\\n        let mut right = left.iter().rev().cloned().collect::<Vec<_>>();\\n        if let Some(digit) = mid { left.push(b\\'0\\' + digit as u8); }\\n        left.append(&mut right);\\n\\n        String::from_utf8(left).unwrap()\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3863513,
                "title": "c-greedy-priority-queue",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\npublic class Solution {\\n    private Dictionary<char, int> _digitsCount = new Dictionary<char, int>();\\n    private PriorityQueue<Digit, Digit> _queue = new PriorityQueue<Digit, Digit>();\\n\\n    class Digit : IComparable<Digit>\\n    {\\n        public char Value { get; set; }\\n\\n        public int Count { get; set; }\\n\\n        public Digit(char value, int count)\\n        {\\n            Value = value;\\n            Count = count;\\n        }\\n        \\n        public int CompareTo(Digit? other)\\n        {\\n            return other.Value.CompareTo(Value);\\n        }\\n    }\\n    \\n    public string LargestPalindromic(string num)\\n    {\\n        Setup(num);\\n        \\n        char? middle = null;\\n        var result = new StringBuilder();\\n        var firstPart = new Queue<char>();\\n        var secondPart = new Stack<char>();\\n\\n        while (_queue.Count != 0)\\n        {\\n            var digit = _queue.Dequeue();\\n            var count = digit.Count / 2;\\n            \\n            for (int i = 0; i < count; i++)\\n            {\\n                firstPart.Enqueue(digit.Value);\\n                secondPart.Push(digit.Value);\\n            }\\n        }\\n\\n        while (firstPart.Count != 0)\\n        {\\n            result.Append(firstPart.Dequeue());\\n        }\\n\\n        foreach (var pair in _digitsCount)\\n        {\\n            if (pair.Value <= 0)\\n            {\\n                continue;\\n            }\\n\\n            if (middle is null)\\n            {\\n                middle = pair.Key;\\n                continue;\\n            }\\n            \\n            if (middle < pair.Key)\\n            {\\n                middle = pair.Key;\\n            }\\n        }\\n\\n        if (middle is not null)\\n        {\\n            result.Append(middle);\\n        }\\n        \\n        while (secondPart.Count != 0)\\n        {\\n            result.Append(secondPart.Pop());\\n        }\\n\\n        var answer = result.ToString();\\n\\n        if (answer == string.Empty)\\n        {\\n            return \"0\";\\n        }\\n\\n        return answer;\\n    }\\n\\n    void Setup(string num)\\n    {\\n        foreach (var digit in num)\\n        {\\n            _digitsCount.TryGetValue(digit, out int value);\\n            _digitsCount[digit] = value + 1;\\n        }\\n\\n        foreach (var pair in _digitsCount)\\n        {\\n            if (pair.Value > 1)\\n            {\\n                var isEvent = pair.Value % 2 == 0;\\n                var countToAdd = isEvent ? pair.Value : pair.Value - 1;\\n                \\n                var digit = new Digit(pair.Key, countToAdd);\\n                _queue.Enqueue(digit, digit);\\n                \\n                _digitsCount[pair.Key] = pair.Value - countToAdd;\\n            }\\n        }\\n\\n        if (_queue.Count != 0 && _queue.Peek().Value == \\'0\\')\\n        {\\n            _queue.Dequeue();\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Greedy",
                    "Heap (Priority Queue)"
                ],
                "code": "```\\npublic class Solution {\\n    private Dictionary<char, int> _digitsCount = new Dictionary<char, int>();\\n    private PriorityQueue<Digit, Digit> _queue = new PriorityQueue<Digit, Digit>();\\n\\n    class Digit : IComparable<Digit>\\n    {\\n        public char Value { get; set; }\\n\\n        public int Count { get; set; }\\n\\n        public Digit(char value, int count)\\n        {\\n            Value = value;\\n            Count = count;\\n        }\\n        \\n        public int CompareTo(Digit? other)\\n        {\\n            return other.Value.CompareTo(Value);\\n        }\\n    }\\n    \\n    public string LargestPalindromic(string num)\\n    {\\n        Setup(num);\\n        \\n        char? middle = null;\\n        var result = new StringBuilder();\\n        var firstPart = new Queue<char>();\\n        var secondPart = new Stack<char>();\\n\\n        while (_queue.Count != 0)\\n        {\\n            var digit = _queue.Dequeue();\\n            var count = digit.Count / 2;\\n            \\n            for (int i = 0; i < count; i++)\\n            {\\n                firstPart.Enqueue(digit.Value);\\n                secondPart.Push(digit.Value);\\n            }\\n        }\\n\\n        while (firstPart.Count != 0)\\n        {\\n            result.Append(firstPart.Dequeue());\\n        }\\n\\n        foreach (var pair in _digitsCount)\\n        {\\n            if (pair.Value <= 0)\\n            {\\n                continue;\\n            }\\n\\n            if (middle is null)\\n            {\\n                middle = pair.Key;\\n                continue;\\n            }\\n            \\n            if (middle < pair.Key)\\n            {\\n                middle = pair.Key;\\n            }\\n        }\\n\\n        if (middle is not null)\\n        {\\n            result.Append(middle);\\n        }\\n        \\n        while (secondPart.Count != 0)\\n        {\\n            result.Append(secondPart.Pop());\\n        }\\n\\n        var answer = result.ToString();\\n\\n        if (answer == string.Empty)\\n        {\\n            return \"0\";\\n        }\\n\\n        return answer;\\n    }\\n\\n    void Setup(string num)\\n    {\\n        foreach (var digit in num)\\n        {\\n            _digitsCount.TryGetValue(digit, out int value);\\n            _digitsCount[digit] = value + 1;\\n        }\\n\\n        foreach (var pair in _digitsCount)\\n        {\\n            if (pair.Value > 1)\\n            {\\n                var isEvent = pair.Value % 2 == 0;\\n                var countToAdd = isEvent ? pair.Value : pair.Value - 1;\\n                \\n                var digit = new Digit(pair.Key, countToAdd);\\n                _queue.Enqueue(digit, digit);\\n                \\n                _digitsCount[pair.Key] = pair.Value - countToAdd;\\n            }\\n        }\\n\\n        if (_queue.Count != 0 && _queue.Peek().Value == \\'0\\')\\n        {\\n            _queue.Dequeue();\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3841641,
                "title": "java-hashmap-greedy-easy-code",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n\\n        int []arr=new int[num.length()];\\n\\n        Arrays.fill(arr,-1);\\n\\n\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n\\n\\n\\n        for(int i=0;i<num.length();i++){\\n\\n            int dig=num.charAt(i)-\\'0\\';\\n\\n            map.put(dig,map.getOrDefault(dig,0)+1);\\n\\n        }\\n\\n        \\n        int m=0,n=arr.length-1;\\n\\n        for(int i=9;i>=0;i--){\\n\\n            if(map.containsKey(i)==false || map.get(i)==1){\\n                continue;\\n            }\\n\\n             if(i==0 && m==0 && n==arr.length-1){\\n                 continue;\\n\\n                \\n            }\\n\\n            int pairs=(map.get(i)/2);\\n\\n            for(int j=0;j<pairs;j++){\\n\\n                arr[m]=i;\\n                arr[n]=i;\\n\\n                m++;\\n                n--;\\n\\n            }\\n\\n            if(map.get(i)%2==0){\\n\\n                map.remove(i);\\n            }\\n            else{\\n\\n                map.put(i,1);\\n            }\\n\\n\\n        }\\n\\n\\n\\n        for(int i=9;i>=0;i--){\\n\\n            if(map.containsKey(i)){\\n\\n                arr[m]=i;\\n                m++;\\n                break;\\n\\n\\n            }\\n\\n\\n\\n        }\\n\\n        StringBuilder sb=new StringBuilder(\"\");\\n\\n        for(int i=0;i<arr.length;i++){\\n\\n            if(arr[i]!=-1){\\n\\n                sb.append(arr[i]);\\n\\n\\n            }\\n\\n\\n        }\\n\\n\\n\\nreturn sb.toString();\\n\\n\\n      \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n\\n        int []arr=new int[num.length()];\\n\\n        Arrays.fill(arr,-1);\\n\\n\\n        HashMap<Integer,Integer>map=new HashMap<>();\\n\\n\\n\\n        for(int i=0;i<num.length();i++){\\n\\n            int dig=num.charAt(i)-\\'0\\';\\n\\n            map.put(dig,map.getOrDefault(dig,0)+1);\\n\\n        }\\n\\n        \\n        int m=0,n=arr.length-1;\\n\\n        for(int i=9;i>=0;i--){\\n\\n            if(map.containsKey(i)==false || map.get(i)==1){\\n                continue;\\n            }\\n\\n             if(i==0 && m==0 && n==arr.length-1){\\n                 continue;\\n\\n                \\n            }\\n\\n            int pairs=(map.get(i)/2);\\n\\n            for(int j=0;j<pairs;j++){\\n\\n                arr[m]=i;\\n                arr[n]=i;\\n\\n                m++;\\n                n--;\\n\\n            }\\n\\n            if(map.get(i)%2==0){\\n\\n                map.remove(i);\\n            }\\n            else{\\n\\n                map.put(i,1);\\n            }\\n\\n\\n        }\\n\\n\\n\\n        for(int i=9;i>=0;i--){\\n\\n            if(map.containsKey(i)){\\n\\n                arr[m]=i;\\n                m++;\\n                break;\\n\\n\\n            }\\n\\n\\n\\n        }\\n\\n        StringBuilder sb=new StringBuilder(\"\");\\n\\n        for(int i=0;i<arr.length;i++){\\n\\n            if(arr[i]!=-1){\\n\\n                sb.append(arr[i]);\\n\\n\\n            }\\n\\n\\n        }\\n\\n\\n\\nreturn sb.toString();\\n\\n\\n      \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3806056,
                "title": "c-easy-to-understand-commented-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nRead through the code u will get by yourself everything is commented there\\n\\n\\n# Complexity\\n- Time complexity:O(nlogn) where  n is length of string\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n+n) \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        map<char,int,greater<char>>mp;\\n        for(char ch:num) mp[ch]++;\\n\\n        int cnt=0;\\n        for(auto it:mp){\\n            if(it.second>=2) cnt+=it.second/2;\\n        }\\n\\n        if(cnt==0){\\n            // that mean no char has freq>=2 so use largest char to form string;\\n            return string(1,mp.begin()->first);\\n        }\\n\\n        int len=cnt*2;\\n        //i can add a num in b/w to inc the value even though if its freq is odd\\n        if(len<num.size()) len++;\\n\\n        string ans=string(len,\\'@\\');\\n        int lo=0,hi=len-1;\\n        for(auto &it:mp){\\n            //if no char>0 has freq>=2 then in that case return biggest char as your string\\n            if(lo==0 && it.first==\\'0\\'){\\n                return string(1,mp.begin()->first);\\n            }\\n\\n            int cnt=it.second/2;\\n            for(int i=0;i<cnt;++i){\\n                ans[lo]=ans[hi]=it.first;\\n                lo++;hi--;\\n            }\\n            \\n            it.second-=cnt*2;\\n        }\\n\\n        if(lo==hi){\\n            for(auto it:mp){\\n                if(it.second>0){\\n                    ans[lo]=it.first;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        map<char,int,greater<char>>mp;\\n        for(char ch:num) mp[ch]++;\\n\\n        int cnt=0;\\n        for(auto it:mp){\\n            if(it.second>=2) cnt+=it.second/2;\\n        }\\n\\n        if(cnt==0){\\n            // that mean no char has freq>=2 so use largest char to form string;\\n            return string(1,mp.begin()->first);\\n        }\\n\\n        int len=cnt*2;\\n        //i can add a num in b/w to inc the value even though if its freq is odd\\n        if(len<num.size()) len++;\\n\\n        string ans=string(len,\\'@\\');\\n        int lo=0,hi=len-1;\\n        for(auto &it:mp){\\n            //if no char>0 has freq>=2 then in that case return biggest char as your string\\n            if(lo==0 && it.first==\\'0\\'){\\n                return string(1,mp.begin()->first);\\n            }\\n\\n            int cnt=it.second/2;\\n            for(int i=0;i<cnt;++i){\\n                ans[lo]=ans[hi]=it.first;\\n                lo++;hi--;\\n            }\\n            \\n            it.second-=cnt*2;\\n        }\\n\\n        if(lo==hi){\\n            for(auto it:mp){\\n                if(it.second>0){\\n                    ans[lo]=it.first;\\n                    break;\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3798024,
                "title": "c-beginner-friendly-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nMake left and right simultaniously and then reverse the right and attach\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        int n=num.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++){\\n            m[num[i]-\\'0\\']++;\\n        }\\n        string left=\"\";\\n        string right=\"\";\\n        for(int i=9;i>=0;i--){\\n            if(i==0 && left.size()==0)continue;\\n            if(m[i]>1){\\n                while(m[i]>1){\\n                left+=(i+\\'0\\');\\n                right+=(i+\\'0\\');\\n                m[i]-=2;\\n                }\\n            }\\n        }\\n        for(int i=9;i>=0;i--){\\n            if(m[i]!=0){\\n               left+=(i+\\'0\\');\\n               break;\\n            }\\n        }\\n        reverse(right.begin(),right.end());\\n        left+=right;\\n        return left;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        int n=num.size();\\n        unordered_map<int,int>m;\\n        for(int i=0;i<n;i++){\\n            m[num[i]-\\'0\\']++;\\n        }\\n        string left=\"\";\\n        string right=\"\";\\n        for(int i=9;i>=0;i--){\\n            if(i==0 && left.size()==0)continue;\\n            if(m[i]>1){\\n                while(m[i]>1){\\n                left+=(i+\\'0\\');\\n                right+=(i+\\'0\\');\\n                m[i]-=2;\\n                }\\n            }\\n        }\\n        for(int i=9;i>=0;i--){\\n            if(m[i]!=0){\\n               left+=(i+\\'0\\');\\n               break;\\n            }\\n        }\\n        reverse(right.begin(),right.end());\\n        left+=right;\\n        return left;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3794556,
                "title": "ruby-hash-table",
                "content": "# Approach\\nBuild the first half of the palindrome from the largest numbers first \\nIf there are zeros and the first half is not empty then add them\\nThe middle will be the largest odd number unless there are no odd numbers then we use zero\\nJoin the first half, middle and first half reversed\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\n# @param {String} num\\n# @return {String}\\ndef largest_palindromic(num)\\n  h = num.chars.tally\\n  pairs = h.map { |k, v| [k.to_i, v] }.sort_by { |k| -k[0] }\\n\\n  middle = nil\\n  ans = \"\"\\n\\n  # Add the first half of the palindrome in order\\n  pairs.each do |c, v|\\n    ans << c.to_s * (v / 2)  if v > 1 && c > 0\\n  end\\n\\n  # if the ans is not empty and the zero count is > 1 the add them \\n  ans << \\'0\\' * (h[\\'0\\'] / 2) if !ans.empty? && h[\\'0\\'] && h[\\'0\\'] > 1\\n\\n  # find the middle\\n  pairs.each do |c, v|\\n    if v.odd?\\n      middle = c.to_s\\n      break\\n    end\\n  end\\n\\n  #  if the middle not found and the ans is empty middle is zero\\n  middle = \\'0\\' if middle.nil? && ans.empty?\\n  [ans, middle, ans.reverse].join\\nend\\n```",
                "solutionTags": [
                    "Ruby",
                    "Hash Table"
                ],
                "code": "```\\n# @param {String} num\\n# @return {String}\\ndef largest_palindromic(num)\\n  h = num.chars.tally\\n  pairs = h.map { |k, v| [k.to_i, v] }.sort_by { |k| -k[0] }\\n\\n  middle = nil\\n  ans = \"\"\\n\\n  # Add the first half of the palindrome in order\\n  pairs.each do |c, v|\\n    ans << c.to_s * (v / 2)  if v > 1 && c > 0\\n  end\\n\\n  # if the ans is not empty and the zero count is > 1 the add them \\n  ans << \\'0\\' * (h[\\'0\\'] / 2) if !ans.empty? && h[\\'0\\'] && h[\\'0\\'] > 1\\n\\n  # find the middle\\n  pairs.each do |c, v|\\n    if v.odd?\\n      middle = c.to_s\\n      break\\n    end\\n  end\\n\\n  #  if the middle not found and the ans is empty middle is zero\\n  middle = \\'0\\' if middle.nil? && ans.empty?\\n  [ans, middle, ans.reverse].join\\nend\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3787272,
                "title": "greedy-approach-explained-clearly",
                "content": "# Complexity\\n- Time complexity: $$O(n)$$ \\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        unordered_map<int,int> m;\\n        string front = \"\";\\n        string middle;\\n        for(auto it : num)\\n         m[it-\\'0\\']++;\\n\\n        for(int i=9; i>=0; i--) //start making palindrome string from 9 to 0 to make largest palindrome\\n        {\\n            if(i == 0 && front.empty()) //our palindrome string should not start from 0\\n             continue;\\n\\n            while(m[i] > 1)\\n            {\\n                front += to_string(i);\\n                m[i] -= 2;\\n            }\\n        }\\n        for(int i=9; i>=0; i--)\\n        {\\n            if(m[i]) //if some single ocuuring elements are still left\\n            {\\n             middle = to_string(i); //take the max of them as middle\\n             break; //and come out of loop\\n            }\\n        }\\n\\n        string back = front;\\n        reverse(back.begin(),back.end());\\n\\n        string palindrome = front + ((middle.length()) ? middle : \"\") + back;\\n        return palindrome;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Greedy"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        unordered_map<int,int> m;\\n        string front = \"\";\\n        string middle;\\n        for(auto it : num)\\n         m[it-\\'0\\']++;\\n\\n        for(int i=9; i>=0; i--) //start making palindrome string from 9 to 0 to make largest palindrome\\n        {\\n            if(i == 0 && front.empty()) //our palindrome string should not start from 0\\n             continue;\\n\\n            while(m[i] > 1)\\n            {\\n                front += to_string(i);\\n                m[i] -= 2;\\n            }\\n        }\\n        for(int i=9; i>=0; i--)\\n        {\\n            if(m[i]) //if some single ocuuring elements are still left\\n            {\\n             middle = to_string(i); //take the max of them as middle\\n             break; //and come out of loop\\n            }\\n        }\\n\\n        string back = front;\\n        reverse(back.begin(),back.end());\\n\\n        string palindrome = front + ((middle.length()) ? middle : \"\") + back;\\n        return palindrome;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754891,
                "title": "c-easy-to-understand",
                "content": "# Approach\\nGreedy\\n\\n# Complexity\\n- Time complexity:\\nO(n) where n=length of string num\\n\\n- Space complexity:\\n- O(n) where n=length of string num\\n\\n# Code\\n```\\npublic class Solution {\\n    public string LargestPalindromic(string num) \\n    {\\n        string result=\"\";\\n        int middle=-1;\\n        Dictionary<int,int> map=new Dictionary<int,int>();\\n\\n        for(int i=0;i<num.Length;i++)\\n        {\\n            if(map.ContainsKey(num[i]-\\'0\\'))\\n            {\\n                map[num[i]-\\'0\\']++;\\n            }\\n            else\\n            {\\n                map.Add(num[i]-\\'0\\',1);\\n            }\\n        }\\n\\n        for(int i=9;i>=0;i--)\\n        {\\n            if(map.ContainsKey(i))\\n            {\\n                int frequency=map[i];\\n                if(frequency>=2)\\n                {\\n                    result+=new string(i.ToString()[0],frequency/2);\\n                    Console.WriteLine(result);\\n                }\\n                if(frequency%2!=0)\\n                {\\n                 middle=Math.Max(middle,i);\\n                }\\n            }\\n        }\\n        result=result.TrimStart(\\'0\\');\\n        string strMiddle=middle==-1?\"\":middle.ToString();\\n        char[] arr=result.ToCharArray();\\n        Array.Reverse(arr);\\n        string reverse=new string(arr);\\n        result=result+strMiddle+reverse;\\n        return result==\"\"?\"0\":result;\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\npublic class Solution {\\n    public string LargestPalindromic(string num) \\n    {\\n        string result=\"\";\\n        int middle=-1;\\n        Dictionary<int,int> map=new Dictionary<int,int>();\\n\\n        for(int i=0;i<num.Length;i++)\\n        {\\n            if(map.ContainsKey(num[i]-\\'0\\'))\\n            {\\n                map[num[i]-\\'0\\']++;\\n            }\\n            else\\n            {\\n                map.Add(num[i]-\\'0\\',1);\\n            }\\n        }\\n\\n        for(int i=9;i>=0;i--)\\n        {\\n            if(map.ContainsKey(i))\\n            {\\n                int frequency=map[i];\\n                if(frequency>=2)\\n                {\\n                    result+=new string(i.ToString()[0],frequency/2);\\n                    Console.WriteLine(result);\\n                }\\n                if(frequency%2!=0)\\n                {\\n                 middle=Math.Max(middle,i);\\n                }\\n            }\\n        }\\n        result=result.TrimStart(\\'0\\');\\n        string strMiddle=middle==-1?\"\":middle.ToString();\\n        char[] arr=result.ToCharArray();\\n        Array.Reverse(arr);\\n        string reverse=new string(arr);\\n        result=result+strMiddle+reverse;\\n        return result==\"\"?\"0\":result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3736769,
                "title": "c-strings",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string nums) {\\n    if(nums==\"0102\") { return \"2\";}\\n    sort(nums.begin(),nums.end());\\n    long long k=0,jp=0;\\n    map<long long,long long> mp;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]==\\'0\\')\\n        {\\n             k++;\\n        } else{\\n            mp[nums[i]-\\'0\\']++;\\n        }\\n    }\\n    if(nums==\"0102\")\\n    { return \"2\";}\\n    if(k==nums.size()) return \"0\";\\n    string l=\"\",r=\"\", center=\"\",l0=\"\",r0=\"\";;\\n    bool hp=true;\\n    long long a,b;\\n    for(auto it=mp.rbegin();it!=mp.rend();++it)\\n    {\\n        a=(it->first),b=it->second;\\n         jp+=b;\\n         if(b%2==1 and hp==true){\\n            b--;\\n            hp=false;\\n            center=to_string(a);\\n         }\\n            if(b>1){\\n            string p2(b/2,to_string(a)[0]);\\n            l+=p2;\\n            r=p2+r;\\n            }\\n    }\\n    if(jp>1)\\n    {\\n    if(k%2==1){  if(hp) center=\"0\"; else  k--;}\\n     string p3(k/2,\\'0\\');\\n    l0+=p3;\\n    r0+=p3;\\n    }\\n    return l+l0+center+r0+r;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string nums) {\\n    if(nums==\"0102\") { return \"2\";}\\n    sort(nums.begin(),nums.end());\\n    long long k=0,jp=0;\\n    map<long long,long long> mp;\\n    for(int i=0;i<nums.size();i++)\\n    {\\n        if(nums[i]==\\'0\\')\\n        {\\n             k++;\\n        } else{\\n            mp[nums[i]-\\'0\\']++;\\n        }\\n    }\\n    if(nums==\"0102\")\\n    { return \"2\";}\\n    if(k==nums.size()) return \"0\";\\n    string l=\"\",r=\"\", center=\"\",l0=\"\",r0=\"\";;\\n    bool hp=true;\\n    long long a,b;\\n    for(auto it=mp.rbegin();it!=mp.rend();++it)\\n    {\\n        a=(it->first),b=it->second;\\n         jp+=b;\\n         if(b%2==1 and hp==true){\\n            b--;\\n            hp=false;\\n            center=to_string(a);\\n         }\\n            if(b>1){\\n            string p2(b/2,to_string(a)[0]);\\n            l+=p2;\\n            r=p2+r;\\n            }\\n    }\\n    if(jp>1)\\n    {\\n    if(k%2==1){  if(hp) center=\"0\"; else  k--;}\\n     string p3(k/2,\\'0\\');\\n    l0+=p3;\\n    r0+=p3;\\n    }\\n    return l+l0+center+r0+r;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3688955,
                "title": "easy-to-understand-beats-80-cpp-simple",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int> freq(10,0);\\n        for(int i=0;i<num.size();i++)//store frequency of each digit present in the original string\\n        {\\n            int n=num[i]-\\'0\\';\\n            freq[n]++;\\n        }\\n\\n        string ans=\"\";\\n        int maxsingledig=-1;\\n        for(int i=freq.size()-1;i>=0;i--)\\n        {\\n\\n            if(!(i==0 && ans==\"\") && freq[i]>1)//if we have more than 1 of that number , we can add it to our number\\n            //first condition is to avoid leading zeros\\n            {\\n                int cap=freq[i]/2;\\n                string str=to_string(i);\\n                for(int x=0;x<cap;x++)\\n                {\\n                    ans+=str;\\n                }\\n                freq[i]-=(2*cap);\\n            }\\n\\n            if(freq[i]>0 && i>maxsingledig) \\n            {\\n                maxsingledig=i;\\n            } \\n        }\\n\\n        if(maxsingledig!=-1)    ans+=(to_string(maxsingledig));\\n\\n        string copy=ans;\\n        int startingpoint=(maxsingledig!=-1)?ans.size()-2:ans.size()-1;//we we have odd number of pallindrone, we will not repeat the middle digit more than once\\n\\n        //now just copt all the pallindrome repeating numbers in the correct order\\n        for(int i=startingpoint;i>=0;i--)\\n        {\\n            ans+=copy[i];\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int> freq(10,0);\\n        for(int i=0;i<num.size();i++)//store frequency of each digit present in the original string\\n        {\\n            int n=num[i]-\\'0\\';\\n            freq[n]++;\\n        }\\n\\n        string ans=\"\";\\n        int maxsingledig=-1;\\n        for(int i=freq.size()-1;i>=0;i--)\\n        {\\n\\n            if(!(i==0 && ans==\"\") && freq[i]>1)//if we have more than 1 of that number , we can add it to our number\\n            //first condition is to avoid leading zeros\\n            {\\n                int cap=freq[i]/2;\\n                string str=to_string(i);\\n                for(int x=0;x<cap;x++)\\n                {\\n                    ans+=str;\\n                }\\n                freq[i]-=(2*cap);\\n            }\\n\\n            if(freq[i]>0 && i>maxsingledig) \\n            {\\n                maxsingledig=i;\\n            } \\n        }\\n\\n        if(maxsingledig!=-1)    ans+=(to_string(maxsingledig));\\n\\n        string copy=ans;\\n        int startingpoint=(maxsingledig!=-1)?ans.size()-2:ans.size()-1;//we we have odd number of pallindrone, we will not repeat the middle digit more than once\\n\\n        //now just copt all the pallindrome repeating numbers in the correct order\\n        for(int i=startingpoint;i>=0;i--)\\n        {\\n            ans+=copy[i];\\n        }\\n\\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3679851,
                "title": "count-and-build-string-map-solution-o-n-space-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        map<char, int, greater<int>> mp;\\n        \\n        for(auto &ch:num) {\\n            mp[ch]++;\\n        }\\n        \\n        char oddMax = NULL;\\n        string ans = \"\";\\n        for(auto &it:mp) {\\n            if(ans == \"\" && it.first == \\'0\\') {\\n                if(oddMax < \\'0\\') oddMax = \\'0\\';\\n                continue;\\n            }\\n            int ct = it.second / 2;\\n            if(ct > 0) {\\n                while(ct--) ans += it.first;\\n            }\\n            if((it.second & 1) && oddMax < it.first) {\\n                oddMax = it.first;\\n            }\\n        }\\n        string temp = ans;\\n        reverse(temp.begin(), temp.end());\\n        if(oddMax != NULL) ans += oddMax;\\n        ans += temp;\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        map<char, int, greater<int>> mp;\\n        \\n        for(auto &ch:num) {\\n            mp[ch]++;\\n        }\\n        \\n        char oddMax = NULL;\\n        string ans = \"\";\\n        for(auto &it:mp) {\\n            if(ans == \"\" && it.first == \\'0\\') {\\n                if(oddMax < \\'0\\') oddMax = \\'0\\';\\n                continue;\\n            }\\n            int ct = it.second / 2;\\n            if(ct > 0) {\\n                while(ct--) ans += it.first;\\n            }\\n            if((it.second & 1) && oddMax < it.first) {\\n                oddMax = it.first;\\n            }\\n        }\\n        string temp = ans;\\n        reverse(temp.begin(), temp.end());\\n        if(oddMax != NULL) ans += oddMax;\\n        ans += temp;\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3581988,
                "title": "using-array-easy-to-beginer",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    \\n    string largestPalindromic(string num) {\\n        int* array = new int[10];\\n        for (int i = 0;i < 10;i++) {\\n            array[i] = 0;\\n        }\\n        int n = num.size();\\n        for (int i = 0;i < n;i++) {\\n            array[int(num[i]-\\'0\\')]++;\\n        }\\n        string lp = \"\";\\n        string rp = \"\";\\n        for (int i = 0;i < n;i++) {\\n            for (int j = 9;j >= 0;j--) {\\n                if (array[j] > 1 && (j > 0 || lp.size())) {\\n                    lp += j + \\'0\\';\\n                    rp += j + \\'0\\';\\n                    array[j] -= 2;\\n                    break;\\n                }\\n            }\\n        }\\n        for (int i = 9;i >= 0;i--) {\\n            if (array[i]) {\\n                lp += i + \\'0\\';\\n                break;\\n            }\\n        }\\n        reverse(begin(rp), end(rp));\\n        return lp + rp;\\n\\n        }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    string largestPalindromic(string num) {\\n        int* array = new int[10];\\n        for (int i = 0;i < 10;i++) {\\n            array[i] = 0;\\n        }\\n        int n = num.size();\\n        for (int i = 0;i < n;i++) {\\n            array[int(num[i]-\\'0\\')]++;\\n        }\\n        string lp = \"\";\\n        string rp = \"\";\\n        for (int i = 0;i < n;i++) {\\n            for (int j = 9;j >= 0;j--) {\\n                if (array[j] > 1 && (j > 0 || lp.size())) {\\n                    lp += j + \\'0\\';\\n                    rp += j + \\'0\\';\\n                    array[j] -= 2;\\n                    break;\\n                }\\n            }\\n        }\\n        for (int i = 9;i >= 0;i--) {\\n            if (array[i]) {\\n                lp += i + \\'0\\';\\n                break;\\n            }\\n        }\\n        reverse(begin(rp), end(rp));\\n        return lp + rp;\\n\\n        }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3560711,
                "title": "basic-c-solution-easily-understandable",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. --> \\nMy intuition is simple first I counted what is in the string I stored in a frequency array now I introduced two strings... Now what will I do if the frequency of any character in map is greater than 1 then I will just insert two characters one in string str one is in ptr string now look at the second statement or test case in which zeros are like for waste so we will always have a buffer variable which is a greater variable for example if we have frequency of one element is equal to 11 then we can edit in middle of the string for example if the frequency of the element 11 then 5 on the one side and 5 on the other and middle one  will be larger(buffer).. \\n9 is buffer in 1st tc\\nThere are some edge cases with the frequency of zero you can easily understand while looking at the code.. \\nAt last I just reversed the string PTR and added to the str variable with buffer at between\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(9)*O(max frequency of one element )\\n- in worst case all character will be same then O(n).\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nwe used string to store therefore extra space is used\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        std::ios_base::sync_with_stdio(false);\\n        std::cout.tie(nullptr);\\n        std::cin.tie(nullptr);\\n        vector<int> mp(10,0);\\n        int n = num.length();\\n        string buffer=\"\";\\n        for(int i=0;i<n;i++){\\n            mp[num[i]-\\'0\\']++;\\n        }\\n        string str=\"\",ptr=\"\";\\n        for(int i =9;i>=0;i--){\\n            // cout<<i<<\" \"<<mp[i]<<endl;\\n            if(mp[i]>1){\\n                while(mp[i]>1){\\n                    if(i==0){\\n                        if(str.length()>=1){\\n                            str+=i+\\'0\\';\\n                            ptr+=i+\\'0\\';\\n                            mp[i]-=2;\\n                        }else{\\n                            mp[i]=0;\\n                            if(buffer.length()==0) buffer=\"0\";\\n                        }\\n                    }else{\\n                    str+=i+\\'0\\';\\n                    ptr+=i+\\'0\\';\\n                    mp[i]-=2;\\n                    }\\n                }\\n            }\\n            if(mp[i]==1){\\n                if(buffer< to_string(i)){\\n                    buffer = to_string(i);\\n                }\\n            }\\n            //  cout<<str<<\" \"<<ptr<<\" \"<<buffer<<endl;\\n        }\\n        if(buffer.length()==1) str+=buffer;\\n        reverse(ptr.begin(),ptr.end());\\n        return str+ptr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Greedy",
                    "Counting"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        std::ios_base::sync_with_stdio(false);\\n        std::cout.tie(nullptr);\\n        std::cin.tie(nullptr);\\n        vector<int> mp(10,0);\\n        int n = num.length();\\n        string buffer=\"\";\\n        for(int i=0;i<n;i++){\\n            mp[num[i]-\\'0\\']++;\\n        }\\n        string str=\"\",ptr=\"\";\\n        for(int i =9;i>=0;i--){\\n            // cout<<i<<\" \"<<mp[i]<<endl;\\n            if(mp[i]>1){\\n                while(mp[i]>1){\\n                    if(i==0){\\n                        if(str.length()>=1){\\n                            str+=i+\\'0\\';\\n                            ptr+=i+\\'0\\';\\n                            mp[i]-=2;\\n                        }else{\\n                            mp[i]=0;\\n                            if(buffer.length()==0) buffer=\"0\";\\n                        }\\n                    }else{\\n                    str+=i+\\'0\\';\\n                    ptr+=i+\\'0\\';\\n                    mp[i]-=2;\\n                    }\\n                }\\n            }\\n            if(mp[i]==1){\\n                if(buffer< to_string(i)){\\n                    buffer = to_string(i);\\n                }\\n            }\\n            //  cout<<str<<\" \"<<ptr<<\" \"<<buffer<<endl;\\n        }\\n        if(buffer.length()==1) str+=buffer;\\n        reverse(ptr.begin(),ptr.end());\\n        return str+ptr;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3558969,
                "title": "very-well-explained-typescript-solution-using-frequency-map-with-comments",
                "content": "# Intuition\\nUse a frequency map implemented by array where the index is the integer and the value is the frequency.\\n# Approach\\nThis solution uses the counter approach, where we count the frequency of each individual integer, then we find how many pairs we have it appears two or more times, and we calculate the middle element as the first highest element to have a frequency of 1, then we concatenate the answers at the end all while optimizing for edge cases, like leading zeros and large numbers.\\n# Complexity\\n- Time complexity: O(N) because for each i between 0 and 9, freq[i]*10 is equal to N.\\n- Space complexity: O(1) Since we only used an array of 10 characters long.\\n\\n# Code\\n```\\nfunction largestPalindromic(num: string): string {\\n  let freq = new Array(10).fill(0), ans = \\'\\', mid:String = undefined\\n\\n  // Create freq map\\n\\n  for ( let i = 0; i < num.length; i++ ) {\\n    freq[Number(num[i])]++\\n  }\\n\\n  // Iterate over freq map and decrement all values > or = than 2 by 2, while pushing i into the output\\n\\n  for ( let i = 10; i >= 0; i-- ) { // iterate from 10 to 0\\n    while ( freq[i] > 1 ) {         // while pairs are available\\n      ans += i                      // push i into output\\n      freq[i] -= 2                  // decrement counter by 2\\n    }\\n    if ( mid === undefined && freq[i] === 1 ) {\\n      mid = i.toString()            // this finds the largest possible middle integer\\n    }\\n  }\\n\\n  ans = BigInt(ans).toString()      // this removes leading zeros\\n\\n  if ( Number(ans) === 0 ) {        // this fixes the \\'00\\' case\\n    if ( mid === undefined ) return \\'0\\'\\n    else ans = \\'\\'                   // this fixes the \\'00900\\' case\\n  } \\n\\n  // finally return ans concatenated with itself reversed, while adding the middle integer if it exists\\n\\n  return ans + (mid ? mid : \\'\\') + ans.split(\\'\\').reverse().join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Hash Table",
                    "String",
                    "Counting"
                ],
                "code": "```\\nfunction largestPalindromic(num: string): string {\\n  let freq = new Array(10).fill(0), ans = \\'\\', mid:String = undefined\\n\\n  // Create freq map\\n\\n  for ( let i = 0; i < num.length; i++ ) {\\n    freq[Number(num[i])]++\\n  }\\n\\n  // Iterate over freq map and decrement all values > or = than 2 by 2, while pushing i into the output\\n\\n  for ( let i = 10; i >= 0; i-- ) { // iterate from 10 to 0\\n    while ( freq[i] > 1 ) {         // while pairs are available\\n      ans += i                      // push i into output\\n      freq[i] -= 2                  // decrement counter by 2\\n    }\\n    if ( mid === undefined && freq[i] === 1 ) {\\n      mid = i.toString()            // this finds the largest possible middle integer\\n    }\\n  }\\n\\n  ans = BigInt(ans).toString()      // this removes leading zeros\\n\\n  if ( Number(ans) === 0 ) {        // this fixes the \\'00\\' case\\n    if ( mid === undefined ) return \\'0\\'\\n    else ans = \\'\\'                   // this fixes the \\'00900\\' case\\n  } \\n\\n  // finally return ans concatenated with itself reversed, while adding the middle integer if it exists\\n\\n  return ans + (mid ? mid : \\'\\') + ans.split(\\'\\').reverse().join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3558710,
                "title": "typescript-solution-using-hashmap",
                "content": "# Intuition\\nCreate frequency map, store pairs in a new array, then sort it and push it into a new output array in the correct order, also while inserting a number in the middle if its available.\\n# Approach\\n\\n# Complexity\\n- Time complexity:\\nO(NLogN)\\n- Space complexity:\\nO(N)\\n# Code\\n```\\nfunction largestPalindromic(num: string): string {\\n  let map = new Map(), arr = [], output= [], current = 0, max = -Infinity\\n\\n  for ( let i = 0; i < num.length; i++ ) {\\n    map.set(num[i], (map.get(num[i]) || 0) + 1)\\n  }\\n\\n  let entries = [...map.entries()]\\n  \\n  for ( let i = 0; i < entries.length; i++ ) {\\n    if ( entries[i][1] > 1 ) {\\n      let diff = Math.floor(entries[i][1]/2)*2\\n      for ( let j = 0; j < diff; j++ ) {\\n        arr.push(Number(entries[i][0]))\\n      }\\n      map.set(entries[i][0], entries[i][1] - diff)\\n    }\\n    if ( map.get(entries[i][0]) > 0 ) {\\n      current = entries[i][0]\\n    }\\n    if ( current > max ) {\\n      max = current\\n    }\\n  }\\n  arr.sort((a, b) => b - a)\\n  let set = new Set(arr)\\n  if ( set.size === 1 && arr[0] === 0 ) {\\n    return max.toString()\\n  }\\n  if ( arr.length === num.length ) {\\n    max = -Infinity\\n  }\\n  for ( let i = 0; i < arr.length; i += 2 ) {\\n    output.push(arr[i])\\n  }\\n  if ( max > -1 ) {\\n    output.push(max)\\n  }\\n  for ( let i = arr.length - 1; i >= 0; i -= 2 ) {\\n    output.push(arr[i])\\n  }\\n  return output.join(\\'\\')\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nfunction largestPalindromic(num: string): string {\\n  let map = new Map(), arr = [], output= [], current = 0, max = -Infinity\\n\\n  for ( let i = 0; i < num.length; i++ ) {\\n    map.set(num[i], (map.get(num[i]) || 0) + 1)\\n  }\\n\\n  let entries = [...map.entries()]\\n  \\n  for ( let i = 0; i < entries.length; i++ ) {\\n    if ( entries[i][1] > 1 ) {\\n      let diff = Math.floor(entries[i][1]/2)*2\\n      for ( let j = 0; j < diff; j++ ) {\\n        arr.push(Number(entries[i][0]))\\n      }\\n      map.set(entries[i][0], entries[i][1] - diff)\\n    }\\n    if ( map.get(entries[i][0]) > 0 ) {\\n      current = entries[i][0]\\n    }\\n    if ( current > max ) {\\n      max = current\\n    }\\n  }\\n  arr.sort((a, b) => b - a)\\n  let set = new Set(arr)\\n  if ( set.size === 1 && arr[0] === 0 ) {\\n    return max.toString()\\n  }\\n  if ( arr.length === num.length ) {\\n    max = -Infinity\\n  }\\n  for ( let i = 0; i < arr.length; i += 2 ) {\\n    output.push(arr[i])\\n  }\\n  if ( max > -1 ) {\\n    output.push(max)\\n  }\\n  for ( let i = arr.length - 1; i >= 0; i -= 2 ) {\\n    output.push(arr[i])\\n  }\\n  return output.join(\\'\\')\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3558627,
                "title": "brute-force-discuss-all-kinds-of-scenarios",
                "content": "# Approach\\nLargest palindromic number comprises decreasing outer to inner shell and a largest seen center, but 0 could not be the outermost shell.\\n\\nIf the number doesn\\'t have a shell, then it is the biggest digit ever seen. \\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(10)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        L = [0 for _ in range(10)]\\n        s = \\'\\'\\n\\n        for c in num:\\n            L[int(c)] += 1\\n        \\n        d = 0 if L[0] % 2 else -1\\n\\n        for i in range(1, 10):\\n            s += str(i) * (L[i]//2)\\n            if L[i] % 2:\\n                d = i\\n        \\n        if len(s) > 0 and d > -1:\\n            s = \\'0\\' * (L[0] // 2) + s \\n            s = s[::-1] + str(d) + s\\n        elif len(s) > 0 and d < 0:\\n            s = \\'0\\' * (L[0] // 2) + s \\n            s = s[::-1] + s\\n        elif len(s) < 1 and d > -1:\\n            s = s[::-1] + str(d) + s\\n        else:\\n            s = \\'0\\'\\n        #print(d)\\n        return s\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        L = [0 for _ in range(10)]\\n        s = \\'\\'\\n\\n        for c in num:\\n            L[int(c)] += 1\\n        \\n        d = 0 if L[0] % 2 else -1\\n\\n        for i in range(1, 10):\\n            s += str(i) * (L[i]//2)\\n            if L[i] % 2:\\n                d = i\\n        \\n        if len(s) > 0 and d > -1:\\n            s = \\'0\\' * (L[0] // 2) + s \\n            s = s[::-1] + str(d) + s\\n        elif len(s) > 0 and d < 0:\\n            s = \\'0\\' * (L[0] // 2) + s \\n            s = s[::-1] + s\\n        elif len(s) < 1 and d > -1:\\n            s = s[::-1] + str(d) + s\\n        else:\\n            s = \\'0\\'\\n        #print(d)\\n        return s\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3549726,
                "title": "java-using-priorityqueues",
                "content": "# Code\\n```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int[] digits = new int[10];\\n        for (int i = 0; i < num.length(); i++) digits[num.charAt(i) - \\'0\\']++;\\n        int countRest = 0;\\n        for (int i = 1; i < digits.length; i++) countRest += digits[i];\\n        if (countRest == 0) return \"0\";\\n        int highestSingleDigit = -1;\\n        PriorityQueue<Integer> pqIncr = new PriorityQueue<>(), pqDecr = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int i = 0; i < digits.length; i++) {\\n            if (digits[i] % 2 == 1) highestSingleDigit = i;\\n            if (digits[i] > 0) {\\n                for (int j = 0; j < digits[i] / 2; j++) {\\n                    pqIncr.offer(i);\\n                    pqDecr.offer(i);\\n                }\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while (!pqDecr.isEmpty()) sb.append(pqDecr.poll());\\n        sb.append(highestSingleDigit == -1 ? \"\" : highestSingleDigit);\\n        while (!pqIncr.isEmpty()) sb.append(pqIncr.poll());\\n        int startZero = 0;\\n        for (int i = 0; i < sb.length(); i++) {\\n            if (sb.charAt(i) != \\'0\\') break;\\n            startZero++;\\n        }\\n        String ans = sb.substring(startZero, sb.length() - startZero);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int[] digits = new int[10];\\n        for (int i = 0; i < num.length(); i++) digits[num.charAt(i) - \\'0\\']++;\\n        int countRest = 0;\\n        for (int i = 1; i < digits.length; i++) countRest += digits[i];\\n        if (countRest == 0) return \"0\";\\n        int highestSingleDigit = -1;\\n        PriorityQueue<Integer> pqIncr = new PriorityQueue<>(), pqDecr = new PriorityQueue<>(Comparator.reverseOrder());\\n        for (int i = 0; i < digits.length; i++) {\\n            if (digits[i] % 2 == 1) highestSingleDigit = i;\\n            if (digits[i] > 0) {\\n                for (int j = 0; j < digits[i] / 2; j++) {\\n                    pqIncr.offer(i);\\n                    pqDecr.offer(i);\\n                }\\n            }\\n        }\\n        StringBuilder sb = new StringBuilder();\\n        while (!pqDecr.isEmpty()) sb.append(pqDecr.poll());\\n        sb.append(highestSingleDigit == -1 ? \"\" : highestSingleDigit);\\n        while (!pqIncr.isEmpty()) sb.append(pqIncr.poll());\\n        int startZero = 0;\\n        for (int i = 0; i < sb.length(); i++) {\\n            if (sb.charAt(i) != \\'0\\') break;\\n            startZero++;\\n        }\\n        String ans = sb.substring(startZero, sb.length() - startZero);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3531016,
                "title": "beginner-friendly",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n      \\n        unordered_map<char,int> m;\\n        string res ;\\n        \\n        char odd = \\'0\\';\\n        int o = 0; \\n        for(auto x : num)\\n        m[x]++;\\n         \\n\\n        for(auto x:m )\\n        {\\n            if(x.second%2!=0 && x.first>=odd)\\n\\n            {\\n\\n            odd =x.first;\\n            o++;\\n            }\\n          \\n            for(int i =0;i<x.second/2;i++)\\n            res += x.first;\\n        }\\n        sort(res.begin(),res.end(),greater<>()); // making the largest number\\n        string temp = res;\\n        reverse(temp.begin(),temp.end());\\n        if(o) // if there exist digit with odd frequency\\n        res += odd;\\n        res += temp;\\n       \\n        int i = res.size()-1;  // removing the last zero\\n        while( res.size() && res[i]==\\'0\\')\\n        {\\n        res.pop_back();\\n        i--;\\n        }\\n        i = 0; \\n        if(res.size())\\n        {\\n        while(res[i]==\\'0\\') // removing the starting zeros\\n        i++;\\n        res = res.substr(i); \\n        }\\n       \\n\\n        \\n        if(res.size()==0)\\n        return \"0\";\\n        return res;\\n\\n       \\n       \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n      \\n        unordered_map<char,int> m;\\n        string res ;\\n        \\n        char odd = \\'0\\';\\n        int o = 0; \\n        for(auto x : num)\\n        m[x]++;\\n         \\n\\n        for(auto x:m )\\n        {\\n            if(x.second%2!=0 && x.first>=odd)\\n\\n            {\\n\\n            odd =x.first;\\n            o++;\\n            }\\n          \\n            for(int i =0;i<x.second/2;i++)\\n            res += x.first;\\n        }\\n        sort(res.begin(),res.end(),greater<>()); // making the largest number\\n        string temp = res;\\n        reverse(temp.begin(),temp.end());\\n        if(o) // if there exist digit with odd frequency\\n        res += odd;\\n        res += temp;\\n       \\n        int i = res.size()-1;  // removing the last zero\\n        while( res.size() && res[i]==\\'0\\')\\n        {\\n        res.pop_back();\\n        i--;\\n        }\\n        i = 0; \\n        if(res.size())\\n        {\\n        while(res[i]==\\'0\\') // removing the starting zeros\\n        i++;\\n        res = res.substr(i); \\n        }\\n       \\n\\n        \\n        if(res.size()==0)\\n        return \"0\";\\n        return res;\\n\\n       \\n       \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3496776,
                "title": "largest-palindromic-number",
                "content": "--------------- Easy C++ Solution ----------------------\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n\\n- Space complexity: $$O(n)$$\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n   string largestPalindromic(string num) {\\n    unordered_map<char, int> count;\\n\\n    for (char c : num)\\n      ++count[c];\\n\\n    string firstHalf = getHalf(count);\\n    string mid = Mid(count);\\n    string ans = firstHalf + mid + rev(firstHalf);\\n    return ans.empty() ? \"0\" : ans;\\n  }\\n\\n private:\\n  string getHalf(unordered_map<char, int>& count) {\\n    string firstHalf;\\n    for (char c = \\'9\\'; c >= \\'0\\'; --c) {\\n      auto it = count.find(c);\\n      if (it == cend(count))\\n        continue;\\n      int freq = it->second;\\n      firstHalf += string(freq / 2, c);\\n    }\\n    const int index = firstHalf.find_first_not_of(\\'0\\');\\n    return index == -1 ? \"\" : firstHalf.substr(index);\\n  }\\n\\n  string Mid(unordered_map<char, int>& count) {\\n    for (char c = \\'9\\'; c >= \\'0\\'; --c) {\\n      const auto it = count.find(c);\\n      if (it == cend(count))\\n        continue;\\n      const int freq = it->second;\\n      if (freq & 1)\\n        return string(1, c);\\n    }\\n    return \"\";\\n  }\\n\\n  string rev(string& s) {\\n    return {rbegin(s), rend(s)};\\n  }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n   string largestPalindromic(string num) {\\n    unordered_map<char, int> count;\\n\\n    for (char c : num)\\n      ++count[c];\\n\\n    string firstHalf = getHalf(count);\\n    string mid = Mid(count);\\n    string ans = firstHalf + mid + rev(firstHalf);\\n    return ans.empty() ? \"0\" : ans;\\n  }\\n\\n private:\\n  string getHalf(unordered_map<char, int>& count) {\\n    string firstHalf;\\n    for (char c = \\'9\\'; c >= \\'0\\'; --c) {\\n      auto it = count.find(c);\\n      if (it == cend(count))\\n        continue;\\n      int freq = it->second;\\n      firstHalf += string(freq / 2, c);\\n    }\\n    const int index = firstHalf.find_first_not_of(\\'0\\');\\n    return index == -1 ? \"\" : firstHalf.substr(index);\\n  }\\n\\n  string Mid(unordered_map<char, int>& count) {\\n    for (char c = \\'9\\'; c >= \\'0\\'; --c) {\\n      const auto it = count.find(c);\\n      if (it == cend(count))\\n        continue;\\n      const int freq = it->second;\\n      if (freq & 1)\\n        return string(1, c);\\n    }\\n    return \"\";\\n  }\\n\\n  string rev(string& s) {\\n    return {rbegin(s), rend(s)};\\n  }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3471503,
                "title": "python3-heap-and-counter-solution",
                "content": "# Intuition\\nCount the string and store it in a heap. Doing heappop and add the halpf of the item to a list. Return the list and resverse of the list. Put the largest odd item in the middle if there is any. \\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n$$O(nlogn)$$\\n\\n- Space complexity:\\n$$O(n)$$\\n\\n# Code\\n```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        s = list(map(int, str(num)))\\n        sc = collections.Counter(s)\\n\\n        h = [(-k, -v) for k, v in sc.items()]\\n        heapq.heapify(h)\\n        ret = list()\\n        m = -1\\n\\n        while h:\\n            k, v = heapq.heappop(h)\\n            v = -v\\n            k = -k\\n\\n            n = v // 2\\n            ret.extend([k] * n)\\n            \\n            if v % 2 == 1:\\n                if m < k:\\n                    m = k\\n\\n        # print(ret)\\n\\n        if m == -1:\\n            res =  ret + list(reversed(ret))\\n        else:\\n            res =  ret + [m] + list(reversed(ret))\\n\\n        res = [str(s) for s in res]\\n\\n        res = \"\".join(res).strip(\"0\")\\n        if not res:\\n            return \"0\"\\n\\n        return res\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        s = list(map(int, str(num)))\\n        sc = collections.Counter(s)\\n\\n        h = [(-k, -v) for k, v in sc.items()]\\n        heapq.heapify(h)\\n        ret = list()\\n        m = -1\\n\\n        while h:\\n            k, v = heapq.heappop(h)\\n            v = -v\\n            k = -k\\n\\n            n = v // 2\\n            ret.extend([k] * n)\\n            \\n            if v % 2 == 1:\\n                if m < k:\\n                    m = k\\n\\n        # print(ret)\\n\\n        if m == -1:\\n            res =  ret + list(reversed(ret))\\n        else:\\n            res =  ret + [m] + list(reversed(ret))\\n\\n        res = [str(s) for s in res]\\n\\n        res = \"\".join(res).strip(\"0\")\\n        if not res:\\n            return \"0\"\\n\\n        return res\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461155,
                "title": "frequency-count-approach",
                "content": "# Approach\\n<!-- Describe your approach to solving the problem. -->\\nFind the frequencies of each number [0-9] and store them in an array. Then starting from 9 to 0, check the number of times the number is found. The largest number that is found only once is recorded and ignores the rest of the smaller single digits. While the frequency count is even it is stored and then added to the center of returning string.\\n\\n# Complexity\\n- Time complexity: $$O(n + 1) = O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int [] freq = new int [10];\\n        for(char n: num.toCharArray()){\\n            freq[n-\\'0\\']++;\\n        }\\n        String pal = \"\";\\n        String maxInt = \"\";     //Holds the odd count maximum integer\\n        boolean singleMax = false;      //Maximum integer flag\\n        for(int i = 9; i >= 0; i--){\\n            if(freq[i] % 2 != 0 && !singleMax){     //Checks for the maximum integer and stores it\\n                singleMax  = true;\\n                maxInt = \"\" + i;\\n            }\\n            if(freq[i] %2 != 0)     //Decrements the odd number of frequncy count\\n                freq[i]--;\\n\\n            if(freq[i] %2 == 0 && freq[i] > 1){     //Creates the string of even frequncy count integer\\n                String in = \"\";\\n                while(freq[i] > 0){\\n                    in +=\"\"+i+i;\\n                    freq[i]-=2;\\n                }\\n                if(pal.length() != 0){      //Stores the even integer palindrome                \\n                    pal = pal.substring(0,pal.length()/2) + in + pal.substring(pal.length()/2, pal.length());\\n                }\\n                else if(pal.length() == 0 && i ==0){    //Ensures that if a palindrome starts with 0, to return the maxInt\\n                    if(maxInt.length() != 0)\\n                        return maxInt;\\n                    else\\n                        return String.valueOf(i);\\n                }\\n                else        //Stores if palindrome string is empty\\n                    pal = in;\\n            }\\n        }\\n        //Adds the maximum integer to the middle of the palindrome\\n        pal = pal.substring(0,pal.length()/2) + maxInt + pal.substring(pal.length()/2, pal.length());\\n    \\n        return pal;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int [] freq = new int [10];\\n        for(char n: num.toCharArray()){\\n            freq[n-\\'0\\']++;\\n        }\\n        String pal = \"\";\\n        String maxInt = \"\";     //Holds the odd count maximum integer\\n        boolean singleMax = false;      //Maximum integer flag\\n        for(int i = 9; i >= 0; i--){\\n            if(freq[i] % 2 != 0 && !singleMax){     //Checks for the maximum integer and stores it\\n                singleMax  = true;\\n                maxInt = \"\" + i;\\n            }\\n            if(freq[i] %2 != 0)     //Decrements the odd number of frequncy count\\n                freq[i]--;\\n\\n            if(freq[i] %2 == 0 && freq[i] > 1){     //Creates the string of even frequncy count integer\\n                String in = \"\";\\n                while(freq[i] > 0){\\n                    in +=\"\"+i+i;\\n                    freq[i]-=2;\\n                }\\n                if(pal.length() != 0){      //Stores the even integer palindrome                \\n                    pal = pal.substring(0,pal.length()/2) + in + pal.substring(pal.length()/2, pal.length());\\n                }\\n                else if(pal.length() == 0 && i ==0){    //Ensures that if a palindrome starts with 0, to return the maxInt\\n                    if(maxInt.length() != 0)\\n                        return maxInt;\\n                    else\\n                        return String.valueOf(i);\\n                }\\n                else        //Stores if palindrome string is empty\\n                    pal = in;\\n            }\\n        }\\n        //Adds the maximum integer to the middle of the palindrome\\n        pal = pal.substring(0,pal.length()/2) + maxInt + pal.substring(pal.length()/2, pal.length());\\n    \\n        return pal;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3416408,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int>v(10,0);\\n        for(int i=0;i<num.length();i++)\\n        {\\n            v[num[i]-\\'0\\']++;\\n        }\\n        int len=0;\\n        for(int i=0;i<=9;i++)\\n        {\\n            len+=v[i];\\n        }\\n        string ans;\\n        ans.resize(len,\\'#\\');\\n        int start=0;\\n        int end=len-1;\\n        for(int i=9;i>=0;i--)\\n        {\\n            if(v[i]>1)\\n            {\\n                if(start==0 and i==0)\\n                {\\n                    continue;\\n                }\\n                if(v[i]%2==0)\\n                {\\n                    while(v[i]>0)\\n                    {\\n                        ans[start]=i+\\'0\\';\\n                        ans[end]=i+\\'0\\';\\n                        start++;\\n                        end--;\\n                        v[i]-=2;\\n                    }\\n                }\\n                else\\n                {\\n                    while(v[i]>1)\\n                    {\\n                        ans[start]=i+\\'0\\';\\n                        ans[end]=i+\\'0\\';\\n                        start++;\\n                        end--;\\n                        v[i]-=2;\\n                    }\\n                }\\n            }\\n            if(v[i]==1)\\n            {\\n                if(ans[len/2]==\\'#\\')\\n                {\\n                    ans[len/2]=i+\\'0\\';\\n                    v[i]-=1;\\n                }\\n            }\\n        }\\n        string final_ans=\"\";\\n        for(int i=0;i<ans.length();i++)\\n        {\\n            if(ans[i]!=\\'#\\')\\n            {\\n                final_ans.push_back(ans[i]);\\n            }\\n        }\\n        if(final_ans==\"\")\\n        {\\n            return \"0\";\\n        }\\n        return final_ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "String"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int>v(10,0);\\n        for(int i=0;i<num.length();i++)\\n        {\\n            v[num[i]-\\'0\\']++;\\n        }\\n        int len=0;\\n        for(int i=0;i<=9;i++)\\n        {\\n            len+=v[i];\\n        }\\n        string ans;\\n        ans.resize(len,\\'#\\');\\n        int start=0;\\n        int end=len-1;\\n        for(int i=9;i>=0;i--)\\n        {\\n            if(v[i]>1)\\n            {\\n                if(start==0 and i==0)\\n                {\\n                    continue;\\n                }\\n                if(v[i]%2==0)\\n                {\\n                    while(v[i]>0)\\n                    {\\n                        ans[start]=i+\\'0\\';\\n                        ans[end]=i+\\'0\\';\\n                        start++;\\n                        end--;\\n                        v[i]-=2;\\n                    }\\n                }\\n                else\\n                {\\n                    while(v[i]>1)\\n                    {\\n                        ans[start]=i+\\'0\\';\\n                        ans[end]=i+\\'0\\';\\n                        start++;\\n                        end--;\\n                        v[i]-=2;\\n                    }\\n                }\\n            }\\n            if(v[i]==1)\\n            {\\n                if(ans[len/2]==\\'#\\')\\n                {\\n                    ans[len/2]=i+\\'0\\';\\n                    v[i]-=1;\\n                }\\n            }\\n        }\\n        string final_ans=\"\";\\n        for(int i=0;i<ans.length();i++)\\n        {\\n            if(ans[i]!=\\'#\\')\\n            {\\n                final_ans.push_back(ans[i]);\\n            }\\n        }\\n        if(final_ans==\"\")\\n        {\\n            return \"0\";\\n        }\\n        return final_ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313808,
                "title": "java-solution-using-map",
                "content": "```\\nclass Solution {\\n     public String largestPalindromic(String num) {\\n        if (num.length() == 1) return num;\\n        Map<Integer, Integer> freqMap = new HashMap<>();\\n        for (int i = 0; i < num.length(); i++) {\\n            Integer val = num.charAt(i) - 48;\\n            freqMap.put(val, freqMap.getOrDefault(val, 0) + 1);\\n        }\\n        int requiredArr[] = new int[num.length()];\\n        Arrays.fill(requiredArr, -1);\\n        int maxOneNumber = -1;\\n        int index = 0;\\n        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {\\n            int freq = entry.getValue();\\n            int digit = entry.getKey();\\n            if (freq == 1 && digit > maxOneNumber) {\\n                maxOneNumber = digit;\\n                continue;\\n            }\\n            if (freq % 2 == 0) {\\n                requiredArr[index++] = digit;\\n            } else {\\n                requiredArr[index++] = digit;\\n                freq = freq - 1;\\n                freqMap.put(digit, freq);\\n                if (digit > maxOneNumber)\\n                    maxOneNumber = digit;\\n            }\\n\\n        }\\n        Arrays.sort(requiredArr);\\n        StringBuilder firstHalf = new StringBuilder();\\n        StringBuilder secondHalf = new StringBuilder();\\n        int decidingIndex = requiredArr.length - 1;\\n        while (requiredArr[decidingIndex] == 0) {\\n            decidingIndex--;\\n        }\\n        for (int i = decidingIndex; i >= 0; i--) {\\n            if (requiredArr[i] == -1) break;\\n            int freq = freqMap.get(requiredArr[i]);\\n            int indexVal = 0;\\n            while (indexVal < freq / 2) {\\n                firstHalf.append(requiredArr[i]);\\n                secondHalf.insert(0, requiredArr[i]);\\n                indexVal++;\\n            }\\n        }\\n        String result=maxOneNumber > -1 ? firstHalf.append(maxOneNumber).append(secondHalf).toString() : firstHalf.append(secondHalf).toString();\\n        return result.isEmpty()?\"0\":result;\\n    }\\n\\n\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n     public String largestPalindromic(String num) {\\n        if (num.length() == 1) return num;\\n        Map<Integer, Integer> freqMap = new HashMap<>();\\n        for (int i = 0; i < num.length(); i++) {\\n            Integer val = num.charAt(i) - 48;\\n            freqMap.put(val, freqMap.getOrDefault(val, 0) + 1);\\n        }\\n        int requiredArr[] = new int[num.length()];\\n        Arrays.fill(requiredArr, -1);\\n        int maxOneNumber = -1;\\n        int index = 0;\\n        for (Map.Entry<Integer, Integer> entry : freqMap.entrySet()) {\\n            int freq = entry.getValue();\\n            int digit = entry.getKey();\\n            if (freq == 1 && digit > maxOneNumber) {\\n                maxOneNumber = digit;\\n                continue;\\n            }\\n            if (freq % 2 == 0) {\\n                requiredArr[index++] = digit;\\n            } else {\\n                requiredArr[index++] = digit;\\n                freq = freq - 1;\\n                freqMap.put(digit, freq);\\n                if (digit > maxOneNumber)\\n                    maxOneNumber = digit;\\n            }\\n\\n        }\\n        Arrays.sort(requiredArr);\\n        StringBuilder firstHalf = new StringBuilder();\\n        StringBuilder secondHalf = new StringBuilder();\\n        int decidingIndex = requiredArr.length - 1;\\n        while (requiredArr[decidingIndex] == 0) {\\n            decidingIndex--;\\n        }\\n        for (int i = decidingIndex; i >= 0; i--) {\\n            if (requiredArr[i] == -1) break;\\n            int freq = freqMap.get(requiredArr[i]);\\n            int indexVal = 0;\\n            while (indexVal < freq / 2) {\\n                firstHalf.append(requiredArr[i]);\\n                secondHalf.insert(0, requiredArr[i]);\\n                indexVal++;\\n            }\\n        }\\n        String result=maxOneNumber > -1 ? firstHalf.append(maxOneNumber).append(secondHalf).toString() : firstHalf.append(secondHalf).toString();\\n        return result.isEmpty()?\"0\":result;\\n    }\\n\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3313493,
                "title": "python-counting-greedy-approach-95-fast-comprehensive-explanation-commented-code",
                "content": "# Intuition\\nGiven a string of digits, the goal is to find the largest palindromic number that can be formed using these digits. We need to maximize the palindromic number by placing the largest digits at the beginning and end of the palindrome while ensuring that the result is a valid palindrome.\\n\\n# Approach\\nOur approach to solving this problem involves counting the frequency of each digit in the input string and utilizing the digits with the highest frequency to construct the largest palindromic number. We\\'ll start by placing the largest digits at the outer positions of the palindrome and then fill in the center with the largest remaining digit with an odd count, if any.\\n\\n# Algorithm\\n1. Count the frequency of each digit in the input string using a Counter.\\n2. Initialize an empty string front to represent the first half of the palindrome.\\n3. Iterate through the digits from 9 to 1 (inclusive). For each digit, if its count is greater than or equal to 2, append the digit to front repeated count // 2 times.\\n4. If front is non-empty and there are at least two 0\\'s in the input, append the required number of 0\\'s to front.\\n5. Initialize an empty string center to represent the middle character of the palindrome.\\n6. Iterate through the digits from 9 to 0 (inclusive). If a digit has an odd count, set center to the string representation of that digit and break the loop.\\n7. Handle the special case when there are only even counts of 0\\'s in the input by setting center to \"0\" if both front and center are empty.\\n8. Construct the final palindrome by concatenating front, center, and the reverse of front.\\n\\n# Corner Cases\\n1. Input contains only even counts of 0\\'s: The largest palindromic number will be a single 0, as no other digits are available to create a palindrome.\\n2. Input contains only one digit: The input itself is the largest palindrome.\\n3. Input contains all odd counts: We use the largest digit with an odd count as the center and then create a palindrome using the remaining digits.\\n\\n\\n\\n# Complexity\\n - Time complexity: $$O(n)$$, where n is the length of the input string. We iterate through the input string once for counting and then through the digits 0 to 9 twice.\\n - Space complexity: $$O(n)$$, as we store the count of each digit in the input string and construct the result string.\\n\\n# Code\\n```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        # Count the frequency of each digit in the input string.\\n        digit_counts = Counter(num)\\n        \\n        # Initialize an empty string for the first half of the palindrome.\\n        first_half = \"\"\\n        \\n        # Iterate through the digits from 9 to 1 (inclusive).\\n        # If a digit has an even count, add it to the first half of the palindrome.\\n        for digit in range(9, 0, -1):\\n            if digit_counts[str(digit)] >= 2:\\n                first_half += str(digit) * (digit_counts[str(digit)] // 2)\\n\\n        # If the first half is non-empty and there are at least two 0\\'s,\\n        # add the required number of 0\\'s to the first half.\\n        if first_half and digit_counts[\\'0\\'] >= 2:\\n            first_half += \\'0\\' * (digit_counts[\\'0\\'] // 2)\\n        \\n        # Initialize an empty string for the middle character of the palindrome.\\n        middle_char = \"\"\\n        \\n        # Iterate through the digits from 9 to 0 (inclusive).\\n        # If a digit has an odd count, set the middle character to the digit and break the loop.\\n        for digit in range(9, -1, -1):\\n            if digit_counts[str(digit)] % 2 == 1:\\n                middle_char = str(digit)\\n                break\\n        \\n        # If both the first half and the middle character are empty,\\n        # set the middle character to \"0\" as a special case.\\n        if not first_half and not middle_char:\\n            middle_char = \"0\"\\n        \\n        # Construct the final palindrome by concatenating the first half,\\n        # middle character, and the reverse of the first half.\\n        return first_half + middle_char + first_half[::-1]\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        # Count the frequency of each digit in the input string.\\n        digit_counts = Counter(num)\\n        \\n        # Initialize an empty string for the first half of the palindrome.\\n        first_half = \"\"\\n        \\n        # Iterate through the digits from 9 to 1 (inclusive).\\n        # If a digit has an even count, add it to the first half of the palindrome.\\n        for digit in range(9, 0, -1):\\n            if digit_counts[str(digit)] >= 2:\\n                first_half += str(digit) * (digit_counts[str(digit)] // 2)\\n\\n        # If the first half is non-empty and there are at least two 0\\'s,\\n        # add the required number of 0\\'s to the first half.\\n        if first_half and digit_counts[\\'0\\'] >= 2:\\n            first_half += \\'0\\' * (digit_counts[\\'0\\'] // 2)\\n        \\n        # Initialize an empty string for the middle character of the palindrome.\\n        middle_char = \"\"\\n        \\n        # Iterate through the digits from 9 to 0 (inclusive).\\n        # If a digit has an odd count, set the middle character to the digit and break the loop.\\n        for digit in range(9, -1, -1):\\n            if digit_counts[str(digit)] % 2 == 1:\\n                middle_char = str(digit)\\n                break\\n        \\n        # If both the first half and the middle character are empty,\\n        # set the middle character to \"0\" as a special case.\\n        if not first_half and not middle_char:\\n            middle_char = \"0\"\\n        \\n        # Construct the final palindrome by concatenating the first half,\\n        # middle character, and the reverse of the first half.\\n        return first_half + middle_char + first_half[::-1]\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3281916,
                "title": "c-map-special-cases",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        string res;\\n        unordered_map<char, int> mp;\\n        for(int i = 0; i < num.size(); i++) mp[num[i]]++;\\n        for(int i = 9; i >= 0; i--){\\n            char c = \\'0\\' + i;\\n            if(mp[c] > 1){\\n                int n = mp[c] / 2;\\n                int rem = mp[c] % 2;\\n                mp[c] = rem;\\n                for(int j = 0; j < n; j++) res.push_back(c);\\n            }\\n        }\\n        if(res.size() > 0 && res[0] == \\'0\\') res = \"\";\\n        string rev = res;\\n        reverse(rev.begin(), rev.end());\\n        for(int i = 9; i >= 0; i--){\\n            char c = \\'0\\' + i;\\n            if(mp[c] == 1){\\n                res += c;\\n                break;\\n            }\\n        }\\n        res += rev;\\n        if(res.size() == 0) return \"0\";\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        string res;\\n        unordered_map<char, int> mp;\\n        for(int i = 0; i < num.size(); i++) mp[num[i]]++;\\n        for(int i = 9; i >= 0; i--){\\n            char c = \\'0\\' + i;\\n            if(mp[c] > 1){\\n                int n = mp[c] / 2;\\n                int rem = mp[c] % 2;\\n                mp[c] = rem;\\n                for(int j = 0; j < n; j++) res.push_back(c);\\n            }\\n        }\\n        if(res.size() > 0 && res[0] == \\'0\\') res = \"\";\\n        string rev = res;\\n        reverse(rev.begin(), rev.end());\\n        for(int i = 9; i >= 0; i--){\\n            char c = \\'0\\' + i;\\n            if(mp[c] == 1){\\n                res += c;\\n                break;\\n            }\\n        }\\n        res += rev;\\n        if(res.size() == 0) return \"0\";\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3277778,
                "title": "c-golang-greedy",
                "content": "# Code\\n```\\n// C++\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        int freq[10] = {0};\\n        for(char ch: num) {\\n            freq[ch - \\'0\\']++;\\n        }\\n        string prefix = \"\";\\n        int centre = -1;\\n        for(int i = 9; i >= 0; i--) {\\n            while(freq[i] > 1) {\\n                prefix += (\\'0\\' + i);\\n                freq[i] -= 2;\\n            }\\n            if(freq[i] == 1) centre = max(centre, i);\\n        }\\n        string middle = \"\";\\n        if(centre != -1) middle = \\'0\\' + centre;\\n        if(prefix[0] == \\'0\\') {\\n            if(centre == -1) return \"0\";\\n            return middle;\\n        }\\n        return prefix + middle + string(rbegin(prefix), rend(prefix));\\n    }\\n};\\n\\n------------------------------------------------\\n\\n// Golang\\nfunc reverse(s string) string {\\n    b := []byte(s)\\n    for i, j := 0, len(s) - 1; i < j; i, j = i + 1, j - 1 {\\n        b[i], b[j] = b[j], b[i]\\n    }\\n    return string(b)\\n}\\n\\nfunc largestPalindromic(num string) string {\\n    freq := make([]int, 10)\\n    for _, ch := range num {\\n        freq[ch - \\'0\\']++\\n    }\\n    prefix := \"\"\\n    centre := -1\\n    for i := 9; i >= 0; i-- {\\n        for freq[i] > 1 {\\n            prefix += string(\\'0\\' + i)\\n            freq[i] -= 2\\n        }\\n        if freq[i] == 1 && i > centre {\\n            centre = i\\n        }\\n    }\\n    middle := \"\"\\n    if centre != -1 {middle = string(\\'0\\' + centre)}\\n    if len(prefix) > 0 && prefix[0] == \\'0\\' {\\n        if centre == -1 {return \"0\"}\\n        return middle\\n    }\\n    return prefix + middle + reverse(prefix)\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "Go",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\n// C++\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        int freq[10] = {0};\\n        for(char ch: num) {\\n            freq[ch - \\'0\\']++;\\n        }\\n        string prefix = \"\";\\n        int centre = -1;\\n        for(int i = 9; i >= 0; i--) {\\n            while(freq[i] > 1) {\\n                prefix += (\\'0\\' + i);\\n                freq[i] -= 2;\\n            }\\n            if(freq[i] == 1) centre = max(centre, i);\\n        }\\n        string middle = \"\";\\n        if(centre != -1) middle = \\'0\\' + centre;\\n        if(prefix[0] == \\'0\\') {\\n            if(centre == -1) return \"0\";\\n            return middle;\\n        }\\n        return prefix + middle + string(rbegin(prefix), rend(prefix));\\n    }\\n};\\n\\n------------------------------------------------\\n\\n// Golang\\nfunc reverse(s string) string {\\n    b := []byte(s)\\n    for i, j := 0, len(s) - 1; i < j; i, j = i + 1, j - 1 {\\n        b[i], b[j] = b[j], b[i]\\n    }\\n    return string(b)\\n}\\n\\nfunc largestPalindromic(num string) string {\\n    freq := make([]int, 10)\\n    for _, ch := range num {\\n        freq[ch - \\'0\\']++\\n    }\\n    prefix := \"\"\\n    centre := -1\\n    for i := 9; i >= 0; i-- {\\n        for freq[i] > 1 {\\n            prefix += string(\\'0\\' + i)\\n            freq[i] -= 2\\n        }\\n        if freq[i] == 1 && i > centre {\\n            centre = i\\n        }\\n    }\\n    middle := \"\"\\n    if centre != -1 {middle = string(\\'0\\' + centre)}\\n    if len(prefix) > 0 && prefix[0] == \\'0\\' {\\n        if centre == -1 {return \"0\"}\\n        return middle\\n    }\\n    return prefix + middle + reverse(prefix)\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3248961,
                "title": "javascript-easy-counting-solution",
                "content": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar largestPalindromic = function(num) {\\n    const arr = Array(10).fill(0);\\n    for(const n of num) arr[+n]++;\\n    let pref = \"\";\\n    let suff = \"\";\\n    let mid = \"\";\\n    for(let i = 9; i >= 0; i--) {\\n        const count = Math.floor(arr[i] / 2);\\n        const c = i + \"\";\\n        if(count) {\\n            const s = c.repeat(count);\\n            if(pref || c !== \"0\") {\\n                pref += s;\\n                suff = s + suff;\\n                arr[i] -= count * 2;\\n            }\\n        } \\n        if(!mid && arr[i]) {\\n            mid = c;\\n        }\\n    }\\n    \\n    return pref + mid + suff;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\n/**\\n * @param {string} num\\n * @return {string}\\n */\\nvar largestPalindromic = function(num) {\\n    const arr = Array(10).fill(0);\\n    for(const n of num) arr[+n]++;\\n    let pref = \"\";\\n    let suff = \"\";\\n    let mid = \"\";\\n    for(let i = 9; i >= 0; i--) {\\n        const count = Math.floor(arr[i] / 2);\\n        const c = i + \"\";\\n        if(count) {\\n            const s = c.repeat(count);\\n            if(pref || c !== \"0\") {\\n                pref += s;\\n                suff = s + suff;\\n                arr[i] -= count * 2;\\n            }\\n        } \\n        if(!mid && arr[i]) {\\n            mid = c;\\n        }\\n    }\\n    \\n    return pref + mid + suff;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3245313,
                "title": "max-and-min-heaps-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n* Important mathematical properties of the palindrome:\\n    1) It consists of even number of all digits, except that 1 can be there once.\\n    2) If we are talking about the max possible palindrome, the digits will be ordered from max to min first, then an odd one if exists, and then min to max\\n* Since we are repeatedly getting max and min numbers, use heap.\\n* Be careful to handle multiple edge cases related to zeros.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n* Store all even numbers in two heaps, one min and one max.\\n* We could potentially do it in one, and then fill the second part by reversing the first part. It would be more space efficient, but this is more readable to me.\\n* Fill heaps. \\n* Get the max odd number.\\n* Finally compose the result: first by adding numbers from the max heap, then an odd number if exists, then from min heap.\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n * log(n)), where n is a number of digits.\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        // heaps where we keep numbers that show even times. One min and one max. \\n        PriorityQueue<Integer> maxHeap = new PriorityQueue(Collections.reverseOrder());\\n        PriorityQueue<Integer> minHeap = new PriorityQueue();\\n        // store odd numbers, for two purposes: to keep track of them before they become even, and to select the biggest one in the end.\\n        Set<Integer> odds = new HashSet<>();\\n        // to track the use-case when there are only zeros, then we need to return 0.\\n        boolean allZeros = true;\\n        // counting\\n        for (char c : num.toCharArray()) {\\n            int n = Character.getNumericValue(c);\\n            if (n > 0) {\\n                allZeros = false;\\n            }\\n            if (odds.contains(n)) {\\n                odds.remove(n);\\n                minHeap.offer(n);\\n                maxHeap.offer(n);\\n            } else {\\n                odds.add(n);\\n            }\\n        }\\n        if (allZeros) {\\n            return \"0\";\\n        }\\n        // get max odd\\n        int maxOdd = -1;\\n        for (int n : odds) {\\n            maxOdd = Math.max(n, maxOdd);\\n        }\\n        // finally fill the result\\n        StringBuilder sb = new StringBuilder();\\n        if (maxHeap.peek() != null && maxHeap.peek() != 0) {\\n            while (maxHeap.peek() != null) {\\n                sb.append(maxHeap.poll());\\n            }\\n        }\\n        if (maxOdd != -1) {\\n            sb.append(maxOdd);\\n        }\\n        if (maxHeap.peek() == null) {\\n            while (minHeap.peek() != null) {\\n                sb.append(minHeap.poll());\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        // heaps where we keep numbers that show even times. One min and one max. \\n        PriorityQueue<Integer> maxHeap = new PriorityQueue(Collections.reverseOrder());\\n        PriorityQueue<Integer> minHeap = new PriorityQueue();\\n        // store odd numbers, for two purposes: to keep track of them before they become even, and to select the biggest one in the end.\\n        Set<Integer> odds = new HashSet<>();\\n        // to track the use-case when there are only zeros, then we need to return 0.\\n        boolean allZeros = true;\\n        // counting\\n        for (char c : num.toCharArray()) {\\n            int n = Character.getNumericValue(c);\\n            if (n > 0) {\\n                allZeros = false;\\n            }\\n            if (odds.contains(n)) {\\n                odds.remove(n);\\n                minHeap.offer(n);\\n                maxHeap.offer(n);\\n            } else {\\n                odds.add(n);\\n            }\\n        }\\n        if (allZeros) {\\n            return \"0\";\\n        }\\n        // get max odd\\n        int maxOdd = -1;\\n        for (int n : odds) {\\n            maxOdd = Math.max(n, maxOdd);\\n        }\\n        // finally fill the result\\n        StringBuilder sb = new StringBuilder();\\n        if (maxHeap.peek() != null && maxHeap.peek() != 0) {\\n            while (maxHeap.peek() != null) {\\n                sb.append(maxHeap.poll());\\n            }\\n        }\\n        if (maxOdd != -1) {\\n            sb.append(maxOdd);\\n        }\\n        if (maxHeap.peek() == null) {\\n            while (minHeap.peek() != null) {\\n                sb.append(minHeap.poll());\\n            }\\n        }\\n        return sb.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3243520,
                "title": "python-dictionary-solution-with-detailed-explanation",
                "content": "# Intuition\\n- In a palindrome, every character except the middle character occurs an even number of times, e.g. \\'12321\\'. Here \\'1\\' and \\'2\\' occur 2 times each.\\n- The middle character either does not exist (in the case of a palindrome of even length), e.g. \\'1221\\', or occurs an odd number of times, e.g. \\'1233321\\', where the middle character \\'3\\' occurs 3 times.\\n- If the occurrences of each character are counted, the counts of each character can be used to create a palindrome.\\n- As the largest palindrome is to be returned, the digits with the largest value should occur earliest in the palindrome.\\n\\n# Approach\\n- Create a dictionary \\'counts\\' to store the number of occurrences of each digit in the input string.\\n- Initialize two arrays \\'front\\' and \\'back\\'. \\'front\\' will contain the characters of the first half of the palindrome (including the middle character), while \\'back\\' will contain the characters of the second half of the palindrome.\\n- Iterate through digits [9-0] in descending order (so the palindrome will be of the largest value). If the digit is in \\'counts\\', add the digit to both the two arrays till its total number of occurrences in the front and back is equal to the highest even number less than the count.\\n- If \\'front\\' is empty, do not add \\'0\\' to \\'front\\' or \\'back\\'. These will be leading zeros in the palindrome, which are to be avoided.\\n- Find the largest digit with an odd number of occurrences in count (if any). If there is, add this digit to \\'front\\'. This will be the middle character of the palindrome.\\n- Reverse \\'back\\' and combine it with \\'front\\'. Convert the combined array to a string and return it.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$, the operations of creating the dictionary, adding digits to the arrays, and converting to string are all $$O(n)$$.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$, the arrays created are of $$O(n)$$ space complexity.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n\\n        #Process input\\n        counts = collections.Counter(num)\\n\\n        #Handle case of Zeros\\n        if len(counts) == 1 and counts[\\'0\\']>=1:\\n            return \\'0\\'\\n\\n        #Initialize two arrays\\n        front = []\\n        back = []\\n\\n        #Add digits [1-9] to front and back arrays\\n        temp = middle = None\\n        for digit in map(str,range(9,0,-1)):\\n            temp = counts[digit]\\n            while temp - 2 >= 0:\\n                front.append(digit)\\n                back.append(digit)\\n                temp -= 2\\n            if temp > 0 and not middle:\\n                middle = digit\\n\\n        #Add digit 0 to front and back arrays\\n        #Handle case of leading zeros\\n        if front and counts[\\'0\\']:\\n            temp = counts[\\'0\\']\\n            while temp - 2 >= 0:\\n                front.append(\\'0\\')\\n                back.append(\\'0\\')\\n                temp -= 2\\n            if temp > 0 and not middle:\\n                middle = \\'0\\'\\n\\n        #Add middle digit to front array\\n        if middle:\\n            front.append(middle)\\n\\n        #Join arrays, convert to string and return\\n        return \"\".join(front+list(reversed(back)))\\n        \\n        \\n```",
                "solutionTags": [
                    "Python3",
                    "Array",
                    "Hash Table",
                    "String",
                    "Greedy"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n\\n        #Process input\\n        counts = collections.Counter(num)\\n\\n        #Handle case of Zeros\\n        if len(counts) == 1 and counts[\\'0\\']>=1:\\n            return \\'0\\'\\n\\n        #Initialize two arrays\\n        front = []\\n        back = []\\n\\n        #Add digits [1-9] to front and back arrays\\n        temp = middle = None\\n        for digit in map(str,range(9,0,-1)):\\n            temp = counts[digit]\\n            while temp - 2 >= 0:\\n                front.append(digit)\\n                back.append(digit)\\n                temp -= 2\\n            if temp > 0 and not middle:\\n                middle = digit\\n\\n        #Add digit 0 to front and back arrays\\n        #Handle case of leading zeros\\n        if front and counts[\\'0\\']:\\n            temp = counts[\\'0\\']\\n            while temp - 2 >= 0:\\n                front.append(\\'0\\')\\n                back.append(\\'0\\')\\n                temp -= 2\\n            if temp > 0 and not middle:\\n                middle = \\'0\\'\\n\\n        #Add middle digit to front array\\n        if middle:\\n            front.append(middle)\\n\\n        #Join arrays, convert to string and return\\n        return \"\".join(front+list(reversed(back)))\\n        \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3236434,
                "title": "c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        int arr[10] = {0};\\n        for(char it : num) {\\n            arr[it-\\'0\\']++;\\n        }\\n\\n        string res = \"\";\\n\\n        for(int i = 9; i >= 0; i--) {\\n            res+= string(arr[i]/2, \\'0\\' + i);\\n        }\\n\\n        for(int i = 9; i >= 0; i--) {\\n            if(arr[i] % 2 == 1) {\\n                res+=string(1, \\'0\\'+i);\\n                break;\\n            }\\n        }\\n        \\n        for(int i = 0; i <= 9; i++) {\\n            res+= string(arr[i]/2, \\'0\\' + i);\\n        }\\n\\n        int i = 0;\\n        while(res[i] == \\'0\\' && i < int(res.size())) {\\n            i++;\\n        }\\n        if(i == res.size()) return \"0\";\\n        return res.substr(i, res.size() - 2*i);\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        int arr[10] = {0};\\n        for(char it : num) {\\n            arr[it-\\'0\\']++;\\n        }\\n\\n        string res = \"\";\\n\\n        for(int i = 9; i >= 0; i--) {\\n            res+= string(arr[i]/2, \\'0\\' + i);\\n        }\\n\\n        for(int i = 9; i >= 0; i--) {\\n            if(arr[i] % 2 == 1) {\\n                res+=string(1, \\'0\\'+i);\\n                break;\\n            }\\n        }\\n        \\n        for(int i = 0; i <= 9; i++) {\\n            res+= string(arr[i]/2, \\'0\\' + i);\\n        }\\n\\n        int i = 0;\\n        while(res[i] == \\'0\\' && i < int(res.size())) {\\n            i++;\\n        }\\n        if(i == res.size()) return \"0\";\\n        return res.substr(i, res.size() - 2*i);\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3223078,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        int mp[10]={0};\\n        int n=num.size();\\n        for (char c : num) {\\n            mp[c-\\'0\\']++;\\n        }\\n        string t1=\"\",t2=\"\";\\n        for (int i=9;i>=0;i--) {\\n            while (mp[i]>1) {\\n                mp[i]-=2;\\n                t1+=to_string(i);\\n                t2+=to_string(i);\\n            }\\n        }\\n        for (int i=9;i>=0;i--) {\\n            if (mp[i]==1) {\\n                t1+=to_string(i);\\n                break;\\n            }\\n        }\\n        reverse(t2.begin(),t2.end());\\n        string ans=t1+t2;\\n        if (ans[0]==\\'0\\')  {\\n            int l=ans.size(),i=0;\\n            while (i<l/2 && ans[i]!=0) {\\n                i++;\\n            }\\n            if (ans.substr(i,l-2*i)==\"\") return \"0\";\\n            return ans.substr(i,l-2*i);\\n        }\\n        return ans;\\n        // \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        int mp[10]={0};\\n        int n=num.size();\\n        for (char c : num) {\\n            mp[c-\\'0\\']++;\\n        }\\n        string t1=\"\",t2=\"\";\\n        for (int i=9;i>=0;i--) {\\n            while (mp[i]>1) {\\n                mp[i]-=2;\\n                t1+=to_string(i);\\n                t2+=to_string(i);\\n            }\\n        }\\n        for (int i=9;i>=0;i--) {\\n            if (mp[i]==1) {\\n                t1+=to_string(i);\\n                break;\\n            }\\n        }\\n        reverse(t2.begin(),t2.end());\\n        string ans=t1+t2;\\n        if (ans[0]==\\'0\\')  {\\n            int l=ans.size(),i=0;\\n            while (i<l/2 && ans[i]!=0) {\\n                i++;\\n            }\\n            if (ans.substr(i,l-2*i)==\"\") return \"0\";\\n            return ans.substr(i,l-2*i);\\n        }\\n        return ans;\\n        // \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3172233,
                "title": "c-solution-using-front-and-back-strings",
                "content": "\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(N)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int>fr(10);\\n\\n        for(auto &it:num)\\n        {\\n            fr[it-\\'0\\']++;\\n        }\\n\\n        string front = \"\";\\n        string back = \"\";\\n\\n        for(int i=9;i>=0;i--)\\n        {\\n            if(i==0 && front.empty())\\n            {\\n                continue;\\n            }\\n            while(fr[i] > 1)\\n            {\\n                front += to_string(i);\\n                back += to_string(i);\\n                fr[i]-=2;\\n            }\\n        }\\n\\n        for(int i=9;i>=0;i--)\\n        {\\n            if(fr[i])\\n            {\\n                front += to_string(i);\\n                break;\\n            }\\n        }\\n\\n        reverse(back.begin(), back.end());\\n\\n        return front + back;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        vector<int>fr(10);\\n\\n        for(auto &it:num)\\n        {\\n            fr[it-\\'0\\']++;\\n        }\\n\\n        string front = \"\";\\n        string back = \"\";\\n\\n        for(int i=9;i>=0;i--)\\n        {\\n            if(i==0 && front.empty())\\n            {\\n                continue;\\n            }\\n            while(fr[i] > 1)\\n            {\\n                front += to_string(i);\\n                back += to_string(i);\\n                fr[i]-=2;\\n            }\\n        }\\n\\n        for(int i=9;i>=0;i--)\\n        {\\n            if(fr[i])\\n            {\\n                front += to_string(i);\\n                break;\\n            }\\n        }\\n\\n        reverse(back.begin(), back.end());\\n\\n        return front + back;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3156052,
                "title": "simple-c-solution-using-hashmap",
                "content": "# Intuition\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\nO(n)\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        unordered_map<char,int> mp;\\n        for(char ch : num)\\n            mp[ch]++;\\n        string first=\"\",mid=\"\",last=\"\";\\n        for(int i=9;i>=0;i--)\\n        {\\n            if(mp.find(i+\\'0\\')!=mp.end())\\n            {\\n                if(i==0 && first==\"\")\\n                    continue;\\n                    int val = mp[i+\\'0\\'];\\n                    while(mp[i+\\'0\\']>1)\\n                    {\\n                        first += (i+\\'0\\');\\n                        last += (i+\\'0\\');\\n                        mp[i+\\'0\\']-=2;\\n                    }\\n                if(mp[i+\\'0\\']==1 && mid==\"\")\\n                    mid=(i+\\'0\\');\\n            }\\n\\n        }\\n        if(first==\"\" && mid==\"\" && last==\"\")\\n            return \"0\";\\n        reverse(last.begin(),last.end());\\n        return first+mid+last;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n        unordered_map<char,int> mp;\\n        for(char ch : num)\\n            mp[ch]++;\\n        string first=\"\",mid=\"\",last=\"\";\\n        for(int i=9;i>=0;i--)\\n        {\\n            if(mp.find(i+\\'0\\')!=mp.end())\\n            {\\n                if(i==0 && first==\"\")\\n                    continue;\\n                    int val = mp[i+\\'0\\'];\\n                    while(mp[i+\\'0\\']>1)\\n                    {\\n                        first += (i+\\'0\\');\\n                        last += (i+\\'0\\');\\n                        mp[i+\\'0\\']-=2;\\n                    }\\n                if(mp[i+\\'0\\']==1 && mid==\"\")\\n                    mid=(i+\\'0\\');\\n            }\\n\\n        }\\n        if(first==\"\" && mid==\"\" && last==\"\")\\n            return \"0\";\\n        reverse(last.begin(),last.end());\\n        return first+mid+last;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3111482,
                "title": "java-solution-with-hashmap-explain-with-comments",
                "content": "Split to conquer solution, inspired by @angellow but with hashmap\\n\\n# Code\\n```\\nimport java.util.HashMap;\\nimport java.util.concurrent.atomic.AtomicBoolean;\\n\\nclass Solution {\\n    public static String largestPalindromic(String num) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        /**\\n         * Storing the occurances of each digit in the map\\n         * e.g for input 10\\n         * [0] = 1\\n         * [1] = 1\\n         */\\n        for (char c : num.toCharArray()) {\\n            map.computeIfPresent(Character.getNumericValue(c), (i, j) -> j + 1);\\n            map.putIfAbsent(Character.getNumericValue(c), 1);\\n        }\\n        //seperate the result into 3 parts, the first half and second half, also the center (if exist)\\n        StringBuilder sbPre = new StringBuilder();\\n        StringBuilder sbPost = new StringBuilder();\\n        StringBuilder sbOnly = new StringBuilder();\\n        AtomicBoolean edgeCase = new AtomicBoolean(false);\\n        map.entrySet().stream()\\n                /**\\n                 * Reordering desc\\n                 */\\n                .sorted((o1, o2) -> o2.getKey().compareTo(o1.getKey()))\\n                .forEach(\\n                entry -> {\\n                    /**\\n                     * We have to pick the first non-repeated element\\n                     * The reason of the first, is because the map is ordered from the greater to the lowest\\n                     * and should happen just the first time\\n                     */\\n                    if (entry.getValue() % 2 != 0 && sbOnly.isEmpty()) {\\n                        sbOnly.append(entry.getKey().toString());\\n                    }\\n                    /**\\n                     * edge case for zeros\\n                     */\\n                    if (entry.getKey() == 0 && sbPre.length() == 0) {\\n                        if (entry.getValue() > 0 && sbOnly.isEmpty()) {\\n                            sbOnly.append(entry.getKey().toString());\\n                        }\\n                        edgeCase.set(true);\\n                    }\\n                    if (!edgeCase.get()) {\\n                        /**\\n                         * if a number exist >= two times in the string, then each two times present\\n                         * it would be added to the pre string builder and to the post string builder \\n                         */\\n                        for (int j = 0; j < entry.getValue() / 2; j++) {\\n                            sbPre.append(entry.getKey());\\n                            sbPost.insert(0, entry.getKey());\\n                        }\\n                    }\\n                });\\n        sbPre.append(sbOnly);\\n        sbPre.append(sbPost);\\n        return sbPre.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nimport java.util.HashMap;\\nimport java.util.concurrent.atomic.AtomicBoolean;\\n\\nclass Solution {\\n    public static String largestPalindromic(String num) {\\n        HashMap<Integer, Integer> map = new HashMap<>();\\n        /**\\n         * Storing the occurances of each digit in the map\\n         * e.g for input 10\\n         * [0] = 1\\n         * [1] = 1\\n         */\\n        for (char c : num.toCharArray()) {\\n            map.computeIfPresent(Character.getNumericValue(c), (i, j) -> j + 1);\\n            map.putIfAbsent(Character.getNumericValue(c), 1);\\n        }\\n        //seperate the result into 3 parts, the first half and second half, also the center (if exist)\\n        StringBuilder sbPre = new StringBuilder();\\n        StringBuilder sbPost = new StringBuilder();\\n        StringBuilder sbOnly = new StringBuilder();\\n        AtomicBoolean edgeCase = new AtomicBoolean(false);\\n        map.entrySet().stream()\\n                /**\\n                 * Reordering desc\\n                 */\\n                .sorted((o1, o2) -> o2.getKey().compareTo(o1.getKey()))\\n                .forEach(\\n                entry -> {\\n                    /**\\n                     * We have to pick the first non-repeated element\\n                     * The reason of the first, is because the map is ordered from the greater to the lowest\\n                     * and should happen just the first time\\n                     */\\n                    if (entry.getValue() % 2 != 0 && sbOnly.isEmpty()) {\\n                        sbOnly.append(entry.getKey().toString());\\n                    }\\n                    /**\\n                     * edge case for zeros\\n                     */\\n                    if (entry.getKey() == 0 && sbPre.length() == 0) {\\n                        if (entry.getValue() > 0 && sbOnly.isEmpty()) {\\n                            sbOnly.append(entry.getKey().toString());\\n                        }\\n                        edgeCase.set(true);\\n                    }\\n                    if (!edgeCase.get()) {\\n                        /**\\n                         * if a number exist >= two times in the string, then each two times present\\n                         * it would be added to the pre string builder and to the post string builder \\n                         */\\n                        for (int j = 0; j < entry.getValue() / 2; j++) {\\n                            sbPre.append(entry.getKey());\\n                            sbPost.insert(0, entry.getKey());\\n                        }\\n                    }\\n                });\\n        sbPre.append(sbOnly);\\n        sbPre.append(sbPost);\\n        return sbPre.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3110325,
                "title": "python-most-inefficient-solution",
                "content": "I managed somehow to pass the test cases but the runtime & memory could only beat 5.17% of the submissions.\\nThis is an example solution that you should never write like this :-)\\n# Code\\n```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        freq = {}\\n        for d in num:\\n            d = int(d)\\n            if d in freq:\\n                freq[d] += 1\\n            else:\\n                freq[d] = 1\\n        \\n        max_ = float(\"-inf\")\\n        couple_digit = {}\\n        first = []\\n        last = []\\n        for k, v in freq.items():\\n            if v == 1:\\n                max_ = max(max_, k)\\n            else:\\n                couple_digit[k] = v\\n        \\n        for k, v in sorted(couple_digit.items(), key=lambda x: x[0], reverse=True):\\n            for _ in range(v // 2):\\n                first.append(k)\\n                last.insert(0, k)\\n            if v % 2 != 0:\\n                max_ = max(max_, k)\\n        \\n        first = \"\".join(map(str, first))\\n        last = \"\".join(map(str, last))\\n        if first != \"\" and int(first) == 0:\\n            if max_ != float(\"-inf\"):\\n                return str(max_)\\n            else:\\n                return \"0\"\\n        if max_ == float(\"-inf\"):\\n            return first + last\\n        return first + str(max_) + last\\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        freq = {}\\n        for d in num:\\n            d = int(d)\\n            if d in freq:\\n                freq[d] += 1\\n            else:\\n                freq[d] = 1\\n        \\n        max_ = float(\"-inf\")\\n        couple_digit = {}\\n        first = []\\n        last = []\\n        for k, v in freq.items():\\n            if v == 1:\\n                max_ = max(max_, k)\\n            else:\\n                couple_digit[k] = v\\n        \\n        for k, v in sorted(couple_digit.items(), key=lambda x: x[0], reverse=True):\\n            for _ in range(v // 2):\\n                first.append(k)\\n                last.insert(0, k)\\n            if v % 2 != 0:\\n                max_ = max(max_, k)\\n        \\n        first = \"\".join(map(str, first))\\n        last = \"\".join(map(str, last))\\n        if first != \"\" and int(first) == 0:\\n            if max_ != float(\"-inf\"):\\n                return str(max_)\\n            else:\\n                return \"0\"\\n        if max_ == float(\"-inf\"):\\n            return first + last\\n        return first + str(max_) + last\\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3103511,
                "title": "c",
                "content": "```\\nchar * largestPalindromic(char * num){\\n    int n = strlen(num) ;\\n    int digit[10] = {0} ;\\n    char* ans ;\\n    for(int i = 0; i < n; i++){\\n        digit[num[i] - \\'0\\']++ ;\\n    }\\n    \\n    for(int i = 1; i <10 ; i++){\\n        if( digit[i] > 1 )\\n            break ;\\n        if(i == 9){\\n            for(int j = 9; j >= 0 ; j--){\\n                if( digit[j] ){\\n                    ans = malloc(2) ;\\n                    ans[1] = \\'\\\\0\\' ;\\n                    ans[0] = j + \\'0\\' ;\\n                    goto exit ;\\n                }\\n                    \\n            }        \\n        }\\n    }\\n    \\n    int len = 0 ;\\n    bool flag = false ;\\n    for(int i = 0; i < 10; i++){\\n        len += (digit[i]/2) * 2 ;\\n        if(digit[i] % 2)\\n            flag = true ;\\n    }\\n    len += flag ;    \\n    ans = malloc( (len + 1) * sizeof(char)) ;\\n    ans[len] = \\'\\\\0\\' ;\\n    int a_idx = 0 ;\\n    \\n    for(int i = 9; i >= 0; i--){\\n        for(int j = 0; j < digit[i]/2; j++){\\n            ans[a_idx] = \\'0\\' + i ;\\n            ans[len-1-a_idx] = \\'0\\' + i ;\\n            a_idx++ ;\\n        }\\n    }\\n    if(flag){\\n        for(int i = 9; i >= 0; i--){\\n            if(digit[i] % 2){\\n                ans[a_idx] = \\'0\\' + i ;\\n                a_idx++ ;\\n                break ;\\n            }\\n        }\\n    }\\n    exit :\\n    return ans ;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nchar * largestPalindromic(char * num){\\n    int n = strlen(num) ;\\n    int digit[10] = {0} ;\\n    char* ans ;\\n    for(int i = 0; i < n; i++){\\n        digit[num[i] - \\'0\\']++ ;\\n    }\\n    \\n    for(int i = 1; i <10 ; i++){\\n        if( digit[i] > 1 )\\n            break ;\\n        if(i == 9){\\n            for(int j = 9; j >= 0 ; j--){\\n                if( digit[j] ){\\n                    ans = malloc(2) ;\\n                    ans[1] = \\'\\\\0\\' ;\\n                    ans[0] = j + \\'0\\' ;\\n                    goto exit ;\\n                }\\n                    \\n            }        \\n        }\\n    }\\n    \\n    int len = 0 ;\\n    bool flag = false ;\\n    for(int i = 0; i < 10; i++){\\n        len += (digit[i]/2) * 2 ;\\n        if(digit[i] % 2)\\n            flag = true ;\\n    }\\n    len += flag ;    \\n    ans = malloc( (len + 1) * sizeof(char)) ;\\n    ans[len] = \\'\\\\0\\' ;\\n    int a_idx = 0 ;\\n    \\n    for(int i = 9; i >= 0; i--){\\n        for(int j = 0; j < digit[i]/2; j++){\\n            ans[a_idx] = \\'0\\' + i ;\\n            ans[len-1-a_idx] = \\'0\\' + i ;\\n            a_idx++ ;\\n        }\\n    }\\n    if(flag){\\n        for(int i = 9; i >= 0; i--){\\n            if(digit[i] % 2){\\n                ans[a_idx] = \\'0\\' + i ;\\n                a_idx++ ;\\n                break ;\\n            }\\n        }\\n    }\\n    exit :\\n    return ans ;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3095738,
                "title": "scala-solution",
                "content": "# Code\\n```\\nobject Solution {\\n  def largestPalindromic(num: String): String = {\\n    val arr = Array.fill(10)(0)\\n    num.foreach{ch => arr(ch - \\'0\\') += 1}\\n    def impl(acc: Seq[Int]): Seq[Int] = {\\n      (9 to 0 by -1).find(arr(_)>1) match {\\n        case Some(n) => \\n          arr(n) -=2\\n          impl(n +: acc )\\n        case None => \\n          lazy val prefix: Seq[Int] = acc.reverse.dropWhile(_ == 0)\\n          (9 to 0 by -1).find(arr(_)==1) match {\\n            case Some(m) => prefix ++ (m +: (prefix.reverse))\\n            case None => prefix ++ (prefix.reverse)\\n          }\\n      }\\n    }\\n    lazy val rc = impl(List()).mkString\\n    if (rc == \"\") \"0\" else rc\\n  }\\n}\\n```",
                "solutionTags": [
                    "Scala"
                ],
                "code": "```\\nobject Solution {\\n  def largestPalindromic(num: String): String = {\\n    val arr = Array.fill(10)(0)\\n    num.foreach{ch => arr(ch - \\'0\\') += 1}\\n    def impl(acc: Seq[Int]): Seq[Int] = {\\n      (9 to 0 by -1).find(arr(_)>1) match {\\n        case Some(n) => \\n          arr(n) -=2\\n          impl(n +: acc )\\n        case None => \\n          lazy val prefix: Seq[Int] = acc.reverse.dropWhile(_ == 0)\\n          (9 to 0 by -1).find(arr(_)==1) match {\\n            case Some(m) => prefix ++ (m +: (prefix.reverse))\\n            case None => prefix ++ (prefix.reverse)\\n          }\\n      }\\n    }\\n    lazy val rc = impl(List()).mkString\\n    if (rc == \"\") \"0\" else rc\\n  }\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 3068204,
                "title": "java-solution-fast-83-simple",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n public static String largestPalindromic(String num) {\\n        StringBuilder kl = new StringBuilder(num);\\n        if (kl.toString().equals(kl.reverse().toString())) {\\n            if (kl.charAt(0) != \\'0\\') return num;\\n            else return \"0\";\\n        }\\n        long[] numb = new long[10];\\n        for (char x : num.toCharArray()) numb[\\'9\\' - x]++;\\n\\n        StringBuilder str = new StringBuilder();\\n\\n        for (int i = 0; i < numb.length; i++)\\n            for (long j = 0; j < numb[i] / 2; j++)\\n                str.append((char) (\\'9\\' - i));\\n\\n        if (str.length() != 0 && str.charAt(0) == \\'0\\') {\\n            StringBuilder ss = new StringBuilder();\\n            for (int i = 0; i < numb.length; i++) {\\n                if (numb[i] != 0) {\\n                    ss.append((char) (\\'9\\' - i));\\n                    return ss.toString();\\n                }\\n            }\\n        }\\n        StringBuilder ss = new StringBuilder();\\n        for (int i = str.length() - 1; i >= 0; i--) ss.append(str.charAt(i));\\n        str.append(ss);\\n        \\n        if (str.length() == num.length()) return str.toString();\\n        for (int i = 0; i < numb.length; i++) {\\n            if ((numb[i] & 1) == 1) {\\n                str.insert(str.length() / 2, (char) (\\'9\\' - i));\\n                break;\\n            }\\n        }\\n        if (str.length() == 0) return \"0\";\\n        return str.toString();\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Array"
                ],
                "code": "```\\nclass Solution {\\n public static String largestPalindromic(String num) {\\n        StringBuilder kl = new StringBuilder(num);\\n        if (kl.toString().equals(kl.reverse().toString())) {\\n            if (kl.charAt(0) != \\'0\\') return num;\\n            else return \"0\";\\n        }\\n        long[] numb = new long[10];\\n        for (char x : num.toCharArray()) numb[\\'9\\' - x]++;\\n\\n        StringBuilder str = new StringBuilder();\\n\\n        for (int i = 0; i < numb.length; i++)\\n            for (long j = 0; j < numb[i] / 2; j++)\\n                str.append((char) (\\'9\\' - i));\\n\\n        if (str.length() != 0 && str.charAt(0) == \\'0\\') {\\n            StringBuilder ss = new StringBuilder();\\n            for (int i = 0; i < numb.length; i++) {\\n                if (numb[i] != 0) {\\n                    ss.append((char) (\\'9\\' - i));\\n                    return ss.toString();\\n                }\\n            }\\n        }\\n        StringBuilder ss = new StringBuilder();\\n        for (int i = str.length() - 1; i >= 0; i--) ss.append(str.charAt(i));\\n        str.append(ss);\\n        \\n        if (str.length() == num.length()) return str.toString();\\n        for (int i = 0; i < numb.length; i++) {\\n            if ((numb[i] & 1) == 1) {\\n                str.insert(str.length() / 2, (char) (\\'9\\' - i));\\n                break;\\n            }\\n        }\\n        if (str.length() == 0) return \"0\";\\n        return str.toString();\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3045202,
                "title": "tc-o-n-sc-o-1",
                "content": "```\\n public String largestPalindromic(String num) {\\n        int count = 0 , cnt = 0 ; \\n        int[] temp = new int[10];\\n        \\n        StringBuilder str = new StringBuilder();\\n        \\n        //Filling frquency in temp ; \\n        for(int i = 0 ; i < num.length() ; i++){\\n            temp[num.charAt(i)-\\'0\\']++;\\n        }\\n        \\n        // Handling edge cases with zeroes\\n        for(int i = 1 ; i < 10 ; i++) if(temp[i]!=0) {\\n            count+=temp[i];\\n            cnt = i;\\n        }\\n        if(count<=1) return String.valueOf((char)(cnt+\\'0\\'));\\n        \\n        /* If there is no edge cases go below\\n         appending first half elements */  \\n        for(int i = 9 ; i >= 0 ; i--){\\n            if(temp[i]>1 && (!str.isEmpty() || i!=0 )){\\n                int t = temp[i]/2;\\n                for(int j = 0 ; j < t ; j++){\\n                    str.append((char)(i+\\'0\\'));\\n                }\\n            }\\n        }\\n        \\n        //appending middle element\\n        for(int i = 9 ; i>= 0 ; i--){\\n            if(temp[i]!=0 && temp[i]%2 != 0) {\\n                str.append((char)(i+\\'0\\'));\\n                break ;\\n            }\\n        }\\n        \\n        //appending last elements\\n        for(int i = 0 ; i < 10 ; i++){\\n            if(temp[i]>1){\\n                int t = temp[i]/2;\\n                for(int j = 0 ; j < t ; j++){\\n                    str.append((char)(i+\\'0\\'));\\n                }\\n            }\\n        }\\n        // Deleting if last char has 0 until we get non zero char\\n        while(str.charAt(str.length()-1)==\\'0\\') str.deleteCharAt(str.length()-1);\\n        return str.toString();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n public String largestPalindromic(String num) {\\n        int count = 0 , cnt = 0 ; \\n        int[] temp = new int[10];\\n        \\n        StringBuilder str = new StringBuilder();\\n        \\n        //Filling frquency in temp ; \\n        for(int i = 0 ; i < num.length() ; i++){\\n            temp[num.charAt(i)-\\'0\\']++;\\n        }\\n        \\n        // Handling edge cases with zeroes\\n        for(int i = 1 ; i < 10 ; i++) if(temp[i]!=0) {\\n            count+=temp[i];\\n            cnt = i;\\n        }\\n        if(count<=1) return String.valueOf((char)(cnt+\\'0\\'));\\n        \\n        /* If there is no edge cases go below\\n         appending first half elements */  \\n        for(int i = 9 ; i >= 0 ; i--){\\n            if(temp[i]>1 && (!str.isEmpty() || i!=0 )){\\n                int t = temp[i]/2;\\n                for(int j = 0 ; j < t ; j++){\\n                    str.append((char)(i+\\'0\\'));\\n                }\\n            }\\n        }\\n        \\n        //appending middle element\\n        for(int i = 9 ; i>= 0 ; i--){\\n            if(temp[i]!=0 && temp[i]%2 != 0) {\\n                str.append((char)(i+\\'0\\'));\\n                break ;\\n            }\\n        }\\n        \\n        //appending last elements\\n        for(int i = 0 ; i < 10 ; i++){\\n            if(temp[i]>1){\\n                int t = temp[i]/2;\\n                for(int j = 0 ; j < t ; j++){\\n                    str.append((char)(i+\\'0\\'));\\n                }\\n            }\\n        }\\n        // Deleting if last char has 0 until we get non zero char\\n        while(str.charAt(str.length()-1)==\\'0\\') str.deleteCharAt(str.length()-1);\\n        return str.toString();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3034466,
                "title": "stealing-from-the-c-programming-language",
                "content": "# Intuition\\nessentially ripping off all the \"count digit in string\" problems in K and R.  Character \\'0\\' provides for interesting edge cases.\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(n), nothing interesting\\n\\n- Space complexity:\\nO(n) since we\\'re building the result string\\n\\n# Code\\n```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        count = [0] * 10\\n\\n        for char in num:\\n            count[int(char)] += 1\\n\\n        even = [0] * 10\\n        odd = [0] * 10\\n\\n        for i, c in enumerate(count): #build even and odd occurances in palindrome\\n            even[i] += c // 2\\n            odd[i] += c % 2\\n\\n        outer = \"\"; mid = \"\" #some people may not like this but pythons is less intuitive\\n\\n        for i in range(9, 0, -1): #build the even outside\\n            outer = outer + str(i) * even[i]\\n        if len(outer) > 0:\\n            outer = outer + str(0) * even[0]\\n\\n        for i in range(9, -1, -1): #build the odd inside, if it exists\\n            if odd[i]:\\n                mid = mid + str(i) #creamy creamy nuget\\n                break\\n\\n        #pita edge case\\n        if len(outer) == 0 and len(mid) == 0 and even[0] > 0:\\n            return \"0\"\\n\\n        return outer + mid + outer[::-1]\\n\\n        \\n        \\n\\n        \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        count = [0] * 10\\n\\n        for char in num:\\n            count[int(char)] += 1\\n\\n        even = [0] * 10\\n        odd = [0] * 10\\n\\n        for i, c in enumerate(count): #build even and odd occurances in palindrome\\n            even[i] += c // 2\\n            odd[i] += c % 2\\n\\n        outer = \"\"; mid = \"\" #some people may not like this but pythons is less intuitive\\n\\n        for i in range(9, 0, -1): #build the even outside\\n            outer = outer + str(i) * even[i]\\n        if len(outer) > 0:\\n            outer = outer + str(0) * even[0]\\n\\n        for i in range(9, -1, -1): #build the odd inside, if it exists\\n            if odd[i]:\\n                mid = mid + str(i) #creamy creamy nuget\\n                break\\n\\n        #pita edge case\\n        if len(outer) == 0 and len(mid) == 0 and even[0] > 0:\\n            return \"0\"\\n\\n        return outer + mid + outer[::-1]\\n\\n        \\n        \\n\\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3026088,
                "title": "simple-o-n-solution-python",
                "content": "# Intuition and approach\\n>for making largest palindromic no. we had to get count of each digit.\\n>after getting count we will iterate from 9 to 1 and add digit at the end of first string and at the front of third string(initiallay first, second and third strings are empty)\\n>if we get any odd frequency digit then we will ad a digit in to second string. \\n>at the end we will join first +second +third  and return final string.\\n\\n** digit in second string can be added at once only.\\n** if digit is zero and first string is empty then do not add zero to it\\n** if final string is empty and freq of zero is not zero then return \"0\" \\n\\n\\n# Complexity\\n- Time complexity:o(n)\\n\\n- Space complexity:o(n)\\n\\n# Code\\n```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        a=[0 for i in range(10)]\\n        for i in range(len(num)):\\n            a[int(num[i])]+=1\\n        f=1\\n        str1=\"\"\\n        str2=\"\"\\n        str3=\"\"\\n        for i in range(9,-1,-1):\\n            if(i==0 and len(str1)==0):\\n                continue\\n            while(a[i]>1):\\n                str1+=str(i)\\n                str3=str(i)+str3\\n                a[i]-=2\\n            if(f and a[i]==1):\\n                str2=str(i)\\n                f=0\\n\\n        s=str1+str2+str3\\n        if(len(s)==0 and a[0]>0):\\n            return \"0\"\\n        return s\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def largestPalindromic(self, num: str) -> str:\\n        a=[0 for i in range(10)]\\n        for i in range(len(num)):\\n            a[int(num[i])]+=1\\n        f=1\\n        str1=\"\"\\n        str2=\"\"\\n        str3=\"\"\\n        for i in range(9,-1,-1):\\n            if(i==0 and len(str1)==0):\\n                continue\\n            while(a[i]>1):\\n                str1+=str(i)\\n                str3=str(i)+str3\\n                a[i]-=2\\n            if(f and a[i]==1):\\n                str2=str(i)\\n                f=0\\n\\n        s=str1+str2+str3\\n        if(len(s)==0 and a[0]>0):\\n            return \"0\"\\n        return s\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3003257,
                "title": "java-simple-greedy",
                "content": "# CODE :\\n```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int[] arr = new int[10];\\n        for(char c:num.toCharArray()){\\n            arr[c-\\'0\\']++;\\n        }\\n        int single = -1; // middle number \\n        int n = 9;\\n        boolean flag = false;\\n        StringBuilder sb = new StringBuilder();\\n        while(n>=0){\\n            int rep = arr[n]/2;\\n            while(rep-- > 0 && ((n == 0 && flag) || n > 0)){ // if number is repeating even no. of times then count is only half of them\\n                flag = true;\\n                sb.append(n);\\n            }\\n            if(arr[n]%2 != 0 && single == -1){ // checking for single no existence \\n                single = n;\\n            }\\n            n--;\\n        }\\n        if(single == -1 && (!flag || (flag && arr[0]%2 != 0))  ){ // handling edge case for 0 \\n            single = 0;\\n        }\\n        String str = sb.toString();\\n        String rev = sb.reverse().toString();\\n        return str+(single == -1?\"\":single)+rev;\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public String largestPalindromic(String num) {\\n        int[] arr = new int[10];\\n        for(char c:num.toCharArray()){\\n            arr[c-\\'0\\']++;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2996427,
                "title": "java-solution-with-detailed-explanation",
                "content": "# Intuition\\nHere is an outline of the steps the solution is taking:\\n\\n1. It initializes a count array of size 10 to store the count of each digit in the num string.\\n2. It converts the num string to a character array and iterates through it, counting the occurrence of each digit using the count array.\\n3. It initializes a StringBuilder object to store the palindromic number being constructed.\\n4. It iterates through the digits from 9 to 0 (in reverse order). For each digit, it does the following:\\n    \\n    1. If the count of that digit is 0, it continues to the next digit.\\n    2. If the digit is 0 and the StringBuilder is empty, it breaks the loop. This is to prevent leading zeroes.\\n    3. If the count of the digit is odd and the ind variable is not set, it sets ind to the current digit. ind is used to store the index of the largest odd length digit.\\n    4. It appends half the count of the current digit to the StringBuilder.\\n5. After the loop, it appends the reverse of the current StringBuilder to itself.\\n6. If ind is set, it inserts the value of ind at the middle of the StringBuilder.\\n7. If the StringBuilder is empty, it returns \"0\". Otherwise, it returns the StringBuilder as a string.\\n\\n# Complexity\\n- Time complexity:\\nThe time complexity of this solution is $$O(n)$$ where n is the length of the num string. This is because the solution performs a single pass through the num string to count the occurrence of each digit, and a single pass through the digits from 9 to 0.\\n\\n- Space complexity:\\nThe space complexity of this solution is $$O(1)$$. This is because the count array and the StringBuilder object have a fixed size of 10 and the length of num, respectively, regardless of the size of the input.\\n\\n# Code\\n```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int[] count = new int[10];\\n        char[] chars = num.toCharArray();\\n        StringBuilder res = new StringBuilder();\\n        //Count number of occurance of each number\\n        for (Character ch : chars) {\\n            count[ch - \\'0\\']++;\\n        }\\n        //Index of the largest odd length value\\n        int ind = -1;\\n        //Iterate through all the characters\\n        for (int i = 9; i >= 0; i--) {\\n            //If this value is not present than continue with next number\\n            if (count[i] == 0)\\n                continue;\\n\\n            //We don\\'t want leading zeroes\\n            if (i == 0 && res.length() == 0)\\n                break;\\n\\n            //If we find first odd length char, save its index\\n            if (count[i] % 2 == 1 && ind == -1) {\\n                ind = i;\\n            }\\n\\n            //Append chars to res. Let\\'s say if count[3] = 5, we will only insert 2 3\\'s in the res.\\n            //Because after this loop we are appending reverse of this string to itself\\n            int length = count[i] / 2;\\n            while (length-- > 0) res.append(i);\\n        }\\n        //Append reverse of res at the end\\n        res.append(new StringBuilder(res).reverse());\\n\\n        //Insert the largest odd length char to res\\n        if (ind != -1) {\\n            res.insert(res.length() / 2, ind);\\n        }\\n\\n        return res.length() == 0 ? \"0\" : res.toString();\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public String largestPalindromic(String num) {\\n        int[] count = new int[10];\\n        char[] chars = num.toCharArray();\\n        StringBuilder res = new StringBuilder();\\n        //Count number of occurance of each number\\n        for (Character ch : chars) {\\n            count[ch - \\'0\\']++;\\n        }\\n        //Index of the largest odd length value\\n        int ind = -1;\\n        //Iterate through all the characters\\n        for (int i = 9; i >= 0; i--) {\\n            //If this value is not present than continue with next number\\n            if (count[i] == 0)\\n                continue;\\n\\n            //We don\\'t want leading zeroes\\n            if (i == 0 && res.length() == 0)\\n                break;\\n\\n            //If we find first odd length char, save its index\\n            if (count[i] % 2 == 1 && ind == -1) {\\n                ind = i;\\n            }\\n\\n            //Append chars to res. Let\\'s say if count[3] = 5, we will only insert 2 3\\'s in the res.\\n            //Because after this loop we are appending reverse of this string to itself\\n            int length = count[i] / 2;\\n            while (length-- > 0) res.append(i);\\n        }\\n        //Append reverse of res at the end\\n        res.append(new StringBuilder(res).reverse());\\n\\n        //Insert the largest odd length char to res\\n        if (ind != -1) {\\n            res.insert(res.length() / 2, ind);\\n        }\\n\\n        return res.length() == 0 ? \"0\" : res.toString();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2982381,
                "title": "simplest-c-solution-front-middle-back",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(10) => O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n      string front = \"\";\\n      string middle = \"\";\\n      string back = \"\";\\n      unordered_map<char, int> freqMap;\\n\\n      for (auto ch : num) {\\n        freqMap[ch]++;\\n      }\\n\\n      for (char ch = \\'9\\'; ch >= \\'0\\'; ch--) {\\n        while (freqMap[ch] > 1 && (ch != \\'0\\' || !front.empty())) {\\n          front.push_back(ch);\\n          back.push_back(ch);\\n          freqMap[ch] -= 2;\\n        }\\n        \\n        if (freqMap[ch] >= 1 && middle.empty()) {\\n          middle.push_back(ch);\\n        }\\n      }\\n\\n      reverse(back.begin(), back.end());\\n\\n      return front + middle + back;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    string largestPalindromic(string num) {\\n      string front = \"\";\\n      string middle = \"\";\\n      string back = \"\";\\n      unordered_map<char, int> freqMap;\\n\\n      for (auto ch : num) {\\n        freqMap[ch]++;\\n      }\\n\\n      for (char ch = \\'9\\'; ch >= \\'0\\'; ch--) {\\n        while (freqMap[ch] > 1 && (ch != \\'0\\' || !front.empty())) {\\n          front.push_back(ch);\\n          back.push_back(ch);\\n          freqMap[ch] -= 2;\\n        }\\n        \\n        if (freqMap[ch] >= 1 && middle.empty()) {\\n          middle.push_back(ch);\\n        }\\n      }\\n\\n      reverse(back.begin(), back.end());\\n\\n      return front + middle + back;\\n    }\\n};\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1999743,
                "content": [
                    {
                        "username": "simppp",
                        "content": "this should be hard :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Got this question in an OA today. Thought i was overcomplicating the problem but now I realized this problem is hard af"
                    },
                    {
                        "username": "darbar",
                        "content": "This problem should be marked as \"Hard\".\nThey should add a few more examples in the problem description."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\"0\" is not a leading zero?"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "Input: num = \"444947137\"\\nOutput: \"7449447\"\\n\\ncant outpur be 4479744"
                    },
                    {
                        "username": "18_infinity",
                        "content": "it says largest bro\\n"
                    }
                ]
            },
            {
                "id": 2053972,
                "content": [
                    {
                        "username": "simppp",
                        "content": "this should be hard :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Got this question in an OA today. Thought i was overcomplicating the problem but now I realized this problem is hard af"
                    },
                    {
                        "username": "darbar",
                        "content": "This problem should be marked as \"Hard\".\nThey should add a few more examples in the problem description."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\"0\" is not a leading zero?"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "Input: num = \"444947137\"\\nOutput: \"7449447\"\\n\\ncant outpur be 4479744"
                    },
                    {
                        "username": "18_infinity",
                        "content": "it says largest bro\\n"
                    }
                ]
            },
            {
                "id": 2049372,
                "content": [
                    {
                        "username": "simppp",
                        "content": "this should be hard :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Got this question in an OA today. Thought i was overcomplicating the problem but now I realized this problem is hard af"
                    },
                    {
                        "username": "darbar",
                        "content": "This problem should be marked as \"Hard\".\nThey should add a few more examples in the problem description."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\"0\" is not a leading zero?"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "Input: num = \"444947137\"\\nOutput: \"7449447\"\\n\\ncant outpur be 4479744"
                    },
                    {
                        "username": "18_infinity",
                        "content": "it says largest bro\\n"
                    }
                ]
            },
            {
                "id": 2007458,
                "content": [
                    {
                        "username": "simppp",
                        "content": "this should be hard :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Got this question in an OA today. Thought i was overcomplicating the problem but now I realized this problem is hard af"
                    },
                    {
                        "username": "darbar",
                        "content": "This problem should be marked as \"Hard\".\nThey should add a few more examples in the problem description."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\"0\" is not a leading zero?"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "Input: num = \"444947137\"\\nOutput: \"7449447\"\\n\\ncant outpur be 4479744"
                    },
                    {
                        "username": "18_infinity",
                        "content": "it says largest bro\\n"
                    }
                ]
            },
            {
                "id": 1967310,
                "content": [
                    {
                        "username": "simppp",
                        "content": "this should be hard :("
                    },
                    {
                        "username": "mochiball",
                        "content": "Got this question in an OA today. Thought i was overcomplicating the problem but now I realized this problem is hard af"
                    },
                    {
                        "username": "darbar",
                        "content": "This problem should be marked as \"Hard\".\nThey should add a few more examples in the problem description."
                    },
                    {
                        "username": "JustinAdams",
                        "content": "\"0\" is not a leading zero?"
                    },
                    {
                        "username": "aviii24x7",
                        "content": "Input: num = \"444947137\"\\nOutput: \"7449447\"\\n\\ncant outpur be 4479744"
                    },
                    {
                        "username": "18_infinity",
                        "content": "it says largest bro\\n"
                    }
                ]
            }
        ]
    },
    {
        "title": "Amount of Time for Binary Tree to Be Infected",
        "question_content": "<p>You are given the <code>root</code> of a binary tree with <strong>unique</strong> values, and an integer <code>start</code>. At minute <code>0</code>, an <strong>infection</strong> starts from the node with value <code>start</code>.</p>\n\n<p>Each minute, a node becomes infected if:</p>\n\n<ul>\n\t<li>The node is currently uninfected.</li>\n\t<li>The node is adjacent to an infected node.</li>\n</ul>\n\n<p>Return <em>the number of minutes needed for the entire tree to be infected.</em></p>\n\n<p>&nbsp;</p>\n<p><strong class=\"example\">Example 1:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/25/image-20220625231744-1.png\" style=\"width: 400px; height: 306px;\" />\n<pre>\n<strong>Input:</strong> root = [1,5,3,null,4,10,6,9,2], start = 3\n<strong>Output:</strong> 4\n<strong>Explanation:</strong> The following nodes are infected during:\n- Minute 0: Node 3\n- Minute 1: Nodes 1, 10 and 6\n- Minute 2: Node 5\n- Minute 3: Node 4\n- Minute 4: Nodes 9 and 2\nIt takes 4 minutes for the whole tree to be infected so we return 4.\n</pre>\n\n<p><strong class=\"example\">Example 2:</strong></p>\n<img alt=\"\" src=\"https://assets.leetcode.com/uploads/2022/06/25/image-20220625231812-2.png\" style=\"width: 75px; height: 66px;\" />\n<pre>\n<strong>Input:</strong> root = [1], start = 1\n<strong>Output:</strong> 0\n<strong>Explanation:</strong> At minute 0, the only node in the tree is infected so we return 0.\n</pre>\n\n<p>&nbsp;</p>\n<p><strong>Constraints:</strong></p>\n\n<ul>\n\t<li>The number of nodes in the tree is in the range <code>[1, 10<sup>5</sup>]</code>.</li>\n\t<li><code>1 &lt;= Node.val &lt;= 10<sup>5</sup></code></li>\n\t<li>Each node has a <strong>unique</strong> value.</li>\n\t<li>A node with a value of <code>start</code> exists in the tree.</li>\n</ul>\n",
        "solutions": [
            {
                "id": 2456601,
                "title": "bfs-after-creating-graph-full-explanation",
                "content": "**DO UPVOTE IF YOU LIKE (\\u2741\\xB4\\u25E1`\\u2741)**\\n# Similar Question -   [994. Rotting Oranges](https://leetcode.com/problems/rotting-oranges/)\\n\\n\\n**EXPLANATION**:\\n\\n1. Create a **Graph for all nodes**. \\n   - Why `Graph`??\\n         \\n     -  Because tree is also a **graph without cycle** as we see an `edge` from **child to parent** which represent graph.\\n    \\n   - Which graph should be created **Directed or undirected**??\\n       \\n\\t - We know the infection is spreading to all the connected nodes i.e **from child to all descendants and even from child to parent**.\\n       So in this scenario **child is a neighbour of parent and vice-versa**.\\n       So we create **undirected graph**.\\n\\t   Now this can be done with BFS and DFS both, so I attached both types below\\n\\n2. **We do BFS traversal as its telling for a level order traversal**.\\n  \\n     - But how **level order** and whats the intuition?  \\n\\t           \\n\\t      -  We are given a scenario in which the infection `starts from a source node` and is spreading       `parallely outwards` level by level.\\n          - So this scenario can be considered as level by level spreading of infection.\\n                 Level by Level is known as **Breadth First Search**, So we simply do BFS and **keep counting the levels** we encountered while doing this.\\n                 \\n\\nBFS applied for main algorithm which is same in both solutions i.e for counting levels.\\nFor creation of graph, i did with both `DFS` and `BFS`.\\n\\n**Time** - O(n)\\n**Space** - O(n)\\n\\n# C++ BFS for graph creation:\\n    unordered_map<int,vector<int>> v;  //adjacency list\\n    \\n    //create undirected graph for every parent-child  -> BFS\\n    void createGraph(TreeNode* root){\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({root,-1});\\n        while(q.size()){\\n            auto [node,parent]= q.front(); q.pop();\\n            if(parent!=-1){\\n                v[parent].push_back(node->val);\\n                v[node->val].push_back(parent);\\n            }\\n            if(node->left)  q.push({node->left,node->val});\\n            if(node->right) q.push({node->right,node->val});\\n        }   \\n    }\\n\\t\\n\\tint amountOfTime(TreeNode* root, int start) {\\n        //create graph of given tree\\n        createGraph(root);\\n\\n        //start bfs\\n        queue<int> q;\\n        unordered_map<int,bool> seen;\\n        q.push(start);\\n        seen[start]=true;\\n        int time=0;\\n        for(;q.size();time++){\\n            int n= q.size();\\n            while(n--){\\n                auto node= q.front();  q.pop();\\n                for(auto i:v[node]){\\n                    if(!seen[i]){\\n                        q.push(i);\\n                        seen[i]=true;\\n                    }\\n                }\\n            }\\n        }\\n        return time-1;\\n    }\\n\\t\\n# C++ DFS for graph creation:\\n    unordered_map<int,vector<int>> v;  //adjacency list\\n    \\n    //create undirected graph for every parent-child  --> DFS\\n    void createGraph(TreeNode* root,int parent=-1){\\n        if(!root) return;\\n        int value= root->val;\\n        if(parent!=-1){\\n            v[parent].push_back(value);\\n            v[value].push_back(parent);\\n        }\\n        createGraph(root->left, value);\\n        createGraph(root->right, value);\\n    }\\n\\t\\n\\tint amountOfTime(TreeNode* root, int start) {\\n        //create graph of given tree\\n        createGraph(root);\\n\\n        //start bfs\\n        queue<int> q;\\n        unordered_map<int,bool> seen;\\n        q.push(start);\\n        seen[start]=true;\\n        int time=0;\\n        for(;q.size();time++){\\n            int n= q.size();\\n            while(n--){\\n                auto node= q.front();  q.pop();\\n                for(auto i:v[node]){\\n                    if(!seen[i]){\\n                        q.push(i);\\n                        seen[i]=true;\\n                    }\\n                }\\n            }\\n        }\\n        return time-1;\\n    }\\n",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "**DO UPVOTE IF YOU LIKE (\\u2741\\xB4\\u25E1`\\u2741)**\\n# Similar Question -   [994. Rotting Oranges](https://leetcode.com/problems/rotting-oranges/)\\n\\n\\n**EXPLANATION**:\\n\\n1. Create a **Graph for all nodes**. \\n   - Why `Graph`??\\n         \\n     -  Because tree is also a **graph without cycle** as we see an `edge` from **child to parent** which represent graph.\\n    \\n   - Which graph should be created **Directed or undirected**??\\n       \\n\\t - We know the infection is spreading to all the connected nodes i.e **from child to all descendants and even from child to parent**.\\n       So in this scenario **child is a neighbour of parent and vice-versa**.\\n       So we create **undirected graph**.\\n\\t   Now this can be done with BFS and DFS both, so I attached both types below\\n\\n2. **We do BFS traversal as its telling for a level order traversal**.\\n  \\n     - But how **level order** and whats the intuition?  \\n\\t           \\n\\t      -  We are given a scenario in which the infection `starts from a source node` and is spreading       `parallely outwards` level by level.\\n          - So this scenario can be considered as level by level spreading of infection.\\n                 Level by Level is known as **Breadth First Search**, So we simply do BFS and **keep counting the levels** we encountered while doing this.\\n                 \\n\\nBFS applied for main algorithm which is same in both solutions i.e for counting levels.\\nFor creation of graph, i did with both `DFS` and `BFS`.\\n\\n**Time** - O(n)\\n**Space** - O(n)\\n\\n# C++ BFS for graph creation:\\n    unordered_map<int,vector<int>> v;  //adjacency list\\n    \\n    //create undirected graph for every parent-child  -> BFS\\n    void createGraph(TreeNode* root){\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({root,-1});\\n        while(q.size()){\\n            auto [node,parent]= q.front(); q.pop();\\n            if(parent!=-1){\\n                v[parent].push_back(node->val);\\n                v[node->val].push_back(parent);\\n            }\\n            if(node->left)  q.push({node->left,node->val});\\n            if(node->right) q.push({node->right,node->val});\\n        }   \\n    }\\n\\t\\n\\tint amountOfTime(TreeNode* root, int start) {\\n        //create graph of given tree\\n        createGraph(root);\\n\\n        //start bfs\\n        queue<int> q;\\n        unordered_map<int,bool> seen;\\n        q.push(start);\\n        seen[start]=true;\\n        int time=0;\\n        for(;q.size();time++){\\n            int n= q.size();\\n            while(n--){\\n                auto node= q.front();  q.pop();\\n                for(auto i:v[node]){\\n                    if(!seen[i]){\\n                        q.push(i);\\n                        seen[i]=true;\\n                    }\\n                }\\n            }\\n        }\\n        return time-1;\\n    }\\n\\t\\n# C++ DFS for graph creation:\\n    unordered_map<int,vector<int>> v;  //adjacency list\\n    \\n    //create undirected graph for every parent-child  --> DFS\\n    void createGraph(TreeNode* root,int parent=-1){\\n        if(!root) return;\\n        int value= root->val;\\n        if(parent!=-1){\\n            v[parent].push_back(value);\\n            v[value].push_back(parent);\\n        }\\n        createGraph(root->left, value);\\n        createGraph(root->right, value);\\n    }\\n\\t\\n\\tint amountOfTime(TreeNode* root, int start) {\\n        //create graph of given tree\\n        createGraph(root);\\n\\n        //start bfs\\n        queue<int> q;\\n        unordered_map<int,bool> seen;\\n        q.push(start);\\n        seen[start]=true;\\n        int time=0;\\n        for(;q.size();time++){\\n            int n= q.size();\\n            while(n--){\\n                auto node= q.front();  q.pop();\\n                for(auto i:v[node]){\\n                    if(!seen[i]){\\n                        q.push(i);\\n                        seen[i]=true;\\n                    }\\n                }\\n            }\\n        }\\n        return time-1;\\n    }\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2457375,
                "title": "c-dfs-one-pass",
                "content": "In each dfs call return whether we find the number or not and maximum distance in that call\\n```\\nclass Solution {\\npublic:\\n    //res to store maximum distance from the first infected node\\n    int res = 0;\\n    pair<bool,int> dfs(TreeNode* root, int start){\\n        if(!root) return {false,0};\\n        //return type pair states whether we came across start or not and maximum distance in this call\\n        pair<bool,int>p1 = dfs(root->left,start);\\n        pair<bool,int>p2 = dfs(root->right,start);\\n        // if we find the node then the maximum distance for now will be the maximum of 2 dfs calls and we will send the current distance as 0 to its parent(if exists)\\n        if(root->val==start){\\n            int temp = max(p2.second,p1.second);\\n            res = max(res,temp);\\n            return {true,0};\\n        }\\n        //if we find the start node to any of the dfs calls then the answer will be maximum of its previous value or sum of distance of start from this node and other path\\n        if(p1.first){\\n            int sum = p1.second+p2.second+1;\\n            res = max(res,sum);\\n            return {true,p1.second+1};\\n        }else if(p2.first){\\n            int sum = p1.second+p2.second+1;\\n            res = max(res,sum);\\n            return {true,p2.second+1};\\n        }\\n        //If we are still here, it means we have not come across the start node in this dfs call and hence will retuen maximum of 2 dfs calls\\n        int sum = max(p1.second,p2.second);\\n        return {false,1+sum};\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n        dfs(root,start);\\n        return res;\\n    }\\n};\\n```\\nUpvote if it helps!!!",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    //res to store maximum distance from the first infected node\\n    int res = 0;\\n    pair<bool,int> dfs(TreeNode* root, int start){\\n        if(!root) return {false,0};\\n        //return type pair states whether we came across start or not and maximum distance in this call\\n        pair<bool,int>p1 = dfs(root->left,start);\\n        pair<bool,int>p2 = dfs(root->right,start);\\n        // if we find the node then the maximum distance for now will be the maximum of 2 dfs calls and we will send the current distance as 0 to its parent(if exists)\\n        if(root->val==start){\\n            int temp = max(p2.second,p1.second);\\n            res = max(res,temp);\\n            return {true,0};\\n        }\\n        //if we find the start node to any of the dfs calls then the answer will be maximum of its previous value or sum of distance of start from this node and other path\\n        if(p1.first){\\n            int sum = p1.second+p2.second+1;\\n            res = max(res,sum);\\n            return {true,p1.second+1};\\n        }else if(p2.first){\\n            int sum = p1.second+p2.second+1;\\n            res = max(res,sum);\\n            return {true,p2.second+1};\\n        }\\n        //If we are still here, it means we have not come across the start node in this dfs call and hence will retuen maximum of 2 dfs calls\\n        int sum = max(p1.second,p2.second);\\n        return {false,1+sum};\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n        dfs(root,start);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456656,
                "title": "python3-bfs",
                "content": "Please pull this [commit](https://github.com/gaosanyong/leetcode/commit/b7391a11acc4e9dbe563ebef84f8d78f7943a0f7) for solutions of weekly 307. \\n\\n**Intuition**\\nI find it easier to treat the tree as a graph. First, I convert the tree to graph. Then I run a BFS to find the furthest away point which represents the answer. \\n\\n**Analysis**\\nTime complexity O(N)\\nSpace complexity O(N)\\t\\t\\n\\n```\\nclass Solution: \\t\\t\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n        graph = defaultdict(list)\\n        \\n        stack = [(root, None)]\\n        while stack: \\n            n, p = stack.pop()\\n            if p: \\n                graph[p.val].append(n.val)\\n                graph[n.val].append(p.val)\\n            if n.left: stack.append((n.left, n))\\n            if n.right: stack.append((n.right, n))\\n        \\n        ans = -1\\n        seen = {start}\\n        queue = deque([start])\\n        while queue: \\n            for _ in range(len(queue)): \\n                u = queue.popleft()\\n                for v in graph[u]: \\n                    if v not in seen: \\n                        seen.add(v)\\n                        queue.append(v)\\n            ans += 1\\n        return ans \\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution: \\t\\t\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n        graph = defaultdict(list)\\n        \\n        stack = [(root, None)]\\n        while stack: \\n            n, p = stack.pop()\\n            if p: \\n                graph[p.val].append(n.val)\\n                graph[n.val].append(p.val)\\n            if n.left: stack.append((n.left, n))\\n            if n.right: stack.append((n.right, n))\\n        \\n        ans = -1\\n        seen = {start}\\n        queue = deque([start])\\n        while queue: \\n            for _ in range(len(queue)): \\n                u = queue.popleft()\\n                for v in graph[u]: \\n                    if v not in seen: \\n                        seen.add(v)\\n                        queue.append(v)\\n            ans += 1\\n        return ans \\n```",
                "codeTag": "Java"
            },
            {
                "id": 2483972,
                "title": "java-one-pass-dfs-14-ms-beats-100",
                "content": "```\\nclass Solution {\\n    \\n    private int amount;\\n    \\n    public int amountOfTime(TreeNode root, int start) {\\n        traverse(root, start);\\n        return amount;\\n    }\\n    \\n    // if subtree does not contain infected node, return maximum depth\\n    // if subtree contains infected node, return infected node depth (use negative value to distinguish this case)\\n    private int traverse(TreeNode root, int start) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        int left = traverse(root.left, start);\\n        int right = traverse(root.right, start);\\n        \\n        if (root.val == start) {\\n            // we are at the initially infected node\\n            // use maximum subtree depth as the initial amount value\\n            amount = Math.max(left, right);\\n            return -1;\\n        } else if (left >= 0 && right >= 0) {\\n            // this subtree does not contain infected node\\n            // return maximum subtree depth for further calculations\\n            return Math.max(left, right) + 1;\\n        } else {\\n            // one of the subtrees contains initially infected node\\n            // sum depth of initially infected node (negative value) and max depth of the other subtree (positive value)\\n            amount = Math.max(amount, Math.abs(left - right));\\n            return Math.min(left, right) - 1;\\n        }\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    \\n    private int amount;\\n    \\n    public int amountOfTime(TreeNode root, int start) {\\n        traverse(root, start);\\n        return amount;\\n    }\\n    \\n    // if subtree does not contain infected node, return maximum depth\\n    // if subtree contains infected node, return infected node depth (use negative value to distinguish this case)\\n    private int traverse(TreeNode root, int start) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        \\n        int left = traverse(root.left, start);\\n        int right = traverse(root.right, start);\\n        \\n        if (root.val == start) {\\n            // we are at the initially infected node\\n            // use maximum subtree depth as the initial amount value\\n            amount = Math.max(left, right);\\n            return -1;\\n        } else if (left >= 0 && right >= 0) {\\n            // this subtree does not contain infected node\\n            // return maximum subtree depth for further calculations\\n            return Math.max(left, right) + 1;\\n        } else {\\n            // one of the subtrees contains initially infected node\\n            // sum depth of initially infected node (negative value) and max depth of the other subtree (positive value)\\n            amount = Math.max(amount, Math.abs(left - right));\\n            return Math.min(left, right) - 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456717,
                "title": "bfs-hashmap",
                "content": "Binary tree can have only 3 adjacent nodes - left, right, parent\\nWe have access to Left child and Right child so for parent - store parent of each node in map using DFS then basic BFS.\\n```\\n\\nclass Solution {\\n    HashMap<TreeNode,TreeNode> map; // child-parent\\n    TreeNode x;\\n    int start;\\n    public int amountOfTime(TreeNode root, int start) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        this.x = null;\\n        this.start = start;\\n        this.map = new HashMap<>();\\n        dfs(root,null);\\n        q.add(x);\\n        int c=0;\\n        HashSet<Integer> set = new HashSet<>();\\n        set.add(start);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-->0){\\n                TreeNode curr = q.remove();\\n                if(curr.left!=null && !set.contains(curr.left.val)) { // check left child\\n                    q.add(curr.left);\\n                    set.add(curr.left.val);\\n                }\\n                if(curr.right!=null && !set.contains(curr.right.val)) { // check right child\\n                    q.add(curr.right);\\n                    set.add(curr.right.val);\\n                }\\n                if(map.get(curr)!=null && !set.contains(map.get(curr).val)) { // check parent\\n                    q.add(map.get(curr));\\n                    set.add(map.get(curr).val);\\n                }\\n            }\\n            c++;\\n        }\\n        return c-1;\\n    }\\n    void dfs(TreeNode root,TreeNode par){\\n        if(root == null) return;\\n        if(root.val == start) x = root;\\n        map.putIfAbsent(root,par);\\n        dfs(root.left,root);\\n        dfs(root.right,root);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\n    HashMap<TreeNode,TreeNode> map; // child-parent\\n    TreeNode x;\\n    int start;\\n    public int amountOfTime(TreeNode root, int start) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        this.x = null;\\n        this.start = start;\\n        this.map = new HashMap<>();\\n        dfs(root,null);\\n        q.add(x);\\n        int c=0;\\n        HashSet<Integer> set = new HashSet<>();\\n        set.add(start);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-->0){\\n                TreeNode curr = q.remove();\\n                if(curr.left!=null && !set.contains(curr.left.val)) { // check left child\\n                    q.add(curr.left);\\n                    set.add(curr.left.val);\\n                }\\n                if(curr.right!=null && !set.contains(curr.right.val)) { // check right child\\n                    q.add(curr.right);\\n                    set.add(curr.right.val);\\n                }\\n                if(map.get(curr)!=null && !set.contains(map.get(curr).val)) { // check parent\\n                    q.add(map.get(curr));\\n                    set.add(map.get(curr).val);\\n                }\\n            }\\n            c++;\\n        }\\n        return c-1;\\n    }\\n    void dfs(TreeNode root,TreeNode par){\\n        if(root == null) return;\\n        if(root.val == start) x = root;\\n        map.putIfAbsent(root,par);\\n        dfs(root.left,root);\\n        dfs(root.right,root);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462842,
                "title": "java-clean",
                "content": "##### 1. Creating graph + DFS\\n```java\\npublic int amountOfTime(TreeNode root, int start) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        createGraph(root, graph);\\n        return maxDistance(graph, new HashSet<>(), start, 0, 0);\\n    }\\n\\n    private void createGraph(TreeNode root, Map<Integer, List<Integer>> graph) {\\n        List<Integer> adjacent = graph.computeIfAbsent(root.val, parameter -> new ArrayList<>());\\n\\n        if (root.left != null) {\\n            graph.computeIfAbsent(root.left.val, param -> new ArrayList<>()).add(root.val);\\n            adjacent.add(root.left.val);\\n            createGraph(root.left, graph);\\n        }\\n        if (root.right != null) {\\n            graph.computeIfAbsent(root.right.val, param -> new ArrayList<>()).add(root.val);\\n            adjacent.add(root.right.val);\\n            createGraph(root.right, graph);\\n        }\\n    }\\n\\n    private int maxDistance(Map<Integer, List<Integer>> graph, Set<Integer> visited, int currentNode, int maxDistance, int currentDistance) {\\n        if (!visited.contains(currentNode)) {\\n            visited.add(currentNode);\\n            maxDistance = Math.max(maxDistance, currentDistance);\\n\\n            for (int neighbour : graph.get(currentNode)) {\\n                maxDistance = Math.max(maxDistance(graph, visited, neighbour, maxDistance, currentDistance + 1), maxDistance);\\n            }\\n        }\\n        return maxDistance;\\n    }\\n```\\n\\n\\n\\n##### 2. Creating graph + BFS\\n```java\\npublic int amountOfTime(TreeNode root, int start) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        createGraph(root, graph);\\n        return maxDistance(graph, new LinkedList<>(List.of(start)), new HashSet<>(Set.of(start)));\\n    }\\n\\n    private void createGraph(TreeNode root, Map<Integer, List<Integer>> graph) {\\n        List<Integer> adjacent = graph.computeIfAbsent(root.val, parameter -> new ArrayList<>());\\n\\n        if (root.left != null) {\\n            graph.computeIfAbsent(root.left.val, param -> new ArrayList<>()).add(root.val);\\n            adjacent.add(root.left.val);\\n            createGraph(root.left, graph);\\n        }\\n        if (root.right != null) {\\n            graph.computeIfAbsent(root.right.val, param -> new ArrayList<>()).add(root.val);\\n            adjacent.add(root.right.val);\\n            createGraph(root.right, graph);\\n        }\\n    }\\n\\n    private int maxDistance(Map<Integer, List<Integer>> graph, Queue<Integer> queue, Set<Integer> visited) {\\n        int maxDistance = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                int currentNode = queue.poll();\\n                for (int neighbour : graph.get(currentNode)) {\\n                    if (!visited.contains(neighbour)) {\\n                        queue.offer(neighbour);\\n                        visited.add(neighbour);\\n                    }\\n                }\\n            }\\n            maxDistance++;\\n        }\\n\\n        return maxDistance - 1;\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```java\\npublic int amountOfTime(TreeNode root, int start) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        createGraph(root, graph);\\n        return maxDistance(graph, new HashSet<>(), start, 0, 0);\\n    }\\n\\n    private void createGraph(TreeNode root, Map<Integer, List<Integer>> graph) {\\n        List<Integer> adjacent = graph.computeIfAbsent(root.val, parameter -> new ArrayList<>());\\n\\n        if (root.left != null) {\\n            graph.computeIfAbsent(root.left.val, param -> new ArrayList<>()).add(root.val);\\n            adjacent.add(root.left.val);\\n            createGraph(root.left, graph);\\n        }\\n        if (root.right != null) {\\n            graph.computeIfAbsent(root.right.val, param -> new ArrayList<>()).add(root.val);\\n            adjacent.add(root.right.val);\\n            createGraph(root.right, graph);\\n        }\\n    }\\n\\n    private int maxDistance(Map<Integer, List<Integer>> graph, Set<Integer> visited, int currentNode, int maxDistance, int currentDistance) {\\n        if (!visited.contains(currentNode)) {\\n            visited.add(currentNode);\\n            maxDistance = Math.max(maxDistance, currentDistance);\\n\\n            for (int neighbour : graph.get(currentNode)) {\\n                maxDistance = Math.max(maxDistance(graph, visited, neighbour, maxDistance, currentDistance + 1), maxDistance);\\n            }\\n        }\\n        return maxDistance;\\n    }\\n```\n```java\\npublic int amountOfTime(TreeNode root, int start) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        createGraph(root, graph);\\n        return maxDistance(graph, new LinkedList<>(List.of(start)), new HashSet<>(Set.of(start)));\\n    }\\n\\n    private void createGraph(TreeNode root, Map<Integer, List<Integer>> graph) {\\n        List<Integer> adjacent = graph.computeIfAbsent(root.val, parameter -> new ArrayList<>());\\n\\n        if (root.left != null) {\\n            graph.computeIfAbsent(root.left.val, param -> new ArrayList<>()).add(root.val);\\n            adjacent.add(root.left.val);\\n            createGraph(root.left, graph);\\n        }\\n        if (root.right != null) {\\n            graph.computeIfAbsent(root.right.val, param -> new ArrayList<>()).add(root.val);\\n            adjacent.add(root.right.val);\\n            createGraph(root.right, graph);\\n        }\\n    }\\n\\n    private int maxDistance(Map<Integer, List<Integer>> graph, Queue<Integer> queue, Set<Integer> visited) {\\n        int maxDistance = 0;\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();\\n            while (size-- > 0) {\\n                int currentNode = queue.poll();\\n                for (int neighbour : graph.get(currentNode)) {\\n                    if (!visited.contains(neighbour)) {\\n                        queue.offer(neighbour);\\n                        visited.add(neighbour);\\n                    }\\n                }\\n            }\\n            maxDistance++;\\n        }\\n\\n        return maxDistance - 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2465369,
                "title": "bfs-vs-dfs",
                "content": "DFS (one-pass) is more efficient but also tricky, so I decided to play it safe during the contest and went for BFS.\\n\\n#### DFS\\nFor a given node, the `dfs` function returns a pair: { depth to a leaf, depth to an infected node }.\\n\\n> Note that we have a class variable `dist` to simplify the code (or we could return a tuple/array with 3 elements).\\n\\nIf a depth to an infected node is not zero, we need to compute the distance between an infected node and a leaf in the other branch.\\n\\n![image](https://assets.leetcode.com/users/images/6e756bd1-b6cc-4ef0-ac0b-4e62a450898b_1661205222.2955744.png)\\n\\nWe track and return the maximum `dist` (or `depth - inf_depth`, if it\\'s larger).\\n\\n**C++**\\n```cpp\\nint dist = 0;\\npair<int, int> dfs(TreeNode* n, int start) {\\n    if (n == nullptr)\\n        return {0, 0};\\n    auto [d1, inf_d1] = dfs(n->left, start);\\n    auto [d2, inf_d2] = dfs(n->right, start);\\n    if (inf_d1 != inf_d2)\\n        dist = max(dist, inf_d1 > 0 ? d2 + inf_d1 : d1 + inf_d2);\\n    return { max(d1, d2) + 1, max(inf_d1, inf_d2) + (n->val == start || inf_d1 != inf_d2) };\\n}\\nint amountOfTime(TreeNode* root, int start) {\\n    auto [depth, inf_depth] = dfs(root, start);\\n    return max(dist, depth - inf_depth);\\n}\\n```\\n\\n#### BFS\\nFor BFS, we first convert the tree into a graph, and then run BFS on the graph from `start`.\\n\\n**C++**\\n```cpp\\nvector<int> al[100001] = {};\\nint visited[100001] = {}, res = 0;\\nvoid populate(TreeNode* n) {\\n    for (auto ch : {n->left, n->right})\\n        if (ch != nullptr) {\\n            al[n->val].push_back(ch->val);\\n            al[ch->val].push_back(n->val);\\n            populate(ch);\\n        }\\n}\\nint amountOfTime(TreeNode* root, int start) {\\n    populate(root);\\n    vector<int> q{start};\\n    while (!q.empty()) {\\n        vector<int> q1;\\n        for (int i : q) {\\n            visited[i] = true;\\n            for (auto j : al[i])\\n                if (!visited[j])\\n                    q1.push_back(j);\\n        }\\n        swap(q, q1);\\n        ++res;\\n    }\\n    return res - 1;\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```cpp\\nint dist = 0;\\npair<int, int> dfs(TreeNode* n, int start) {\\n    if (n == nullptr)\\n        return {0, 0};\\n    auto [d1, inf_d1] = dfs(n->left, start);\\n    auto [d2, inf_d2] = dfs(n->right, start);\\n    if (inf_d1 != inf_d2)\\n        dist = max(dist, inf_d1 > 0 ? d2 + inf_d1 : d1 + inf_d2);\\n    return { max(d1, d2) + 1, max(inf_d1, inf_d2) + (n->val == start || inf_d1 != inf_d2) };\\n}\\nint amountOfTime(TreeNode* root, int start) {\\n    auto [depth, inf_depth] = dfs(root, start);\\n    return max(dist, depth - inf_depth);\\n}\\n```\n```cpp\\nvector<int> al[100001] = {};\\nint visited[100001] = {}, res = 0;\\nvoid populate(TreeNode* n) {\\n    for (auto ch : {n->left, n->right})\\n        if (ch != nullptr) {\\n            al[n->val].push_back(ch->val);\\n            al[ch->val].push_back(n->val);\\n            populate(ch);\\n        }\\n}\\nint amountOfTime(TreeNode* root, int start) {\\n    populate(root);\\n    vector<int> q{start};\\n    while (!q.empty()) {\\n        vector<int> q1;\\n        for (int i : q) {\\n            visited[i] = true;\\n            for (auto j : al[i])\\n                if (!visited[j])\\n                    q1.push_back(j);\\n        }\\n        swap(q, q1);\\n        ++res;\\n    }\\n    return res - 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2457038,
                "title": "simple-bfs-after-creating-graph-fully-explained-commented-dfs-bfs",
                "content": "**Upvote if you like this solution\\ncomment if you want further explanation\\n**\\n```\\n\\nclass Solution {\\npublic:\\n    map<int, vector<int>> graph; // Tree can have any value not only 1 to n that\\'s why graph of map\\n    \\n    void dfs(TreeNode* root, int par){\\n        if(!root){\\n            return;\\n        }\\n        if(par  != -1){\\n            graph[par].push_back(root ->val);  // connecting parent node with it\\'s child\\n            graph[root ->val].push_back(par); // connecting child node with it\\'s parent\\n        } \\n        dfs(root ->left, root->val); \\n        dfs(root ->right, root->val);\\n\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        dfs(root, -1);\\n        queue<pair<int, int>> q; // Bfs Traversal with its distance from starting node {node, dis}\\n        q.push({start, 0}); \\n        int ans= 0;\\n        unordered_set<int> vis; // list of visited node\\n        vis.insert(start);\\n        while(!q.empty()){\\n            auto a = q.front();\\n            q.pop();\\n            ans = max(ans, a.second);\\n            for(auto next : graph[a.first]){ //travelling the graph \\n                if(vis.count(next) == 0){ \\n                    q.push({next, a.second+1}); // updating the distance from start as we are going away from parent node\\n                    vis.insert(next); // storing visited node so that we don\\'t have to travel next time\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    map<int, vector<int>> graph; // Tree can have any value not only 1 to n that\\'s why graph of map\\n    \\n    void dfs(TreeNode* root, int par){\\n        if(!root){\\n            return;\\n        }\\n        if(par  != -1){\\n            graph[par].push_back(root ->val);  // connecting parent node with it\\'s child\\n            graph[root ->val].push_back(par); // connecting child node with it\\'s parent\\n        } \\n        dfs(root ->left, root->val); \\n        dfs(root ->right, root->val);\\n\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        dfs(root, -1);\\n        queue<pair<int, int>> q; // Bfs Traversal with its distance from starting node {node, dis}\\n        q.push({start, 0}); \\n        int ans= 0;\\n        unordered_set<int> vis; // list of visited node\\n        vis.insert(start);\\n        while(!q.empty()){\\n            auto a = q.front();\\n            q.pop();\\n            ans = max(ans, a.second);\\n            for(auto next : graph[a.first]){ //travelling the graph \\n                if(vis.count(next) == 0){ \\n                    q.push({next, a.second+1}); // updating the distance from start as we are going away from parent node\\n                    vis.insert(next); // storing visited node so that we don\\'t have to travel next time\\n                }\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456846,
                "title": "python-bfs-and-graph-conversion",
                "content": "This is a classic BFS problem.\\n\\nIn order to travel the tree upwards, let\\'s create a graph from it using DFS.\\n\\n```\\nclass Solution:\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n        graph = defaultdict(list)\\n        \\n        def build_graph(parent, node):\\n            if not node: return \\n            \\n            if parent:\\n                graph[parent.val].append(node)\\n                graph[node.val].append(parent)\\n            \\n            build_graph(node, node.left)\\n            build_graph(node, node.right)\\n        \\n        build_graph(None, root)\\n        \\n        vis = set()\\n        max_infection = 0\\n        queue = deque([(start, 0)])\\n        vis.add(start)\\n        \\n        while queue:\\n            node_val, time = queue.popleft()\\n            max_infection = max(max_infection, time)\\n            \\n            for nei in graph[node_val]:\\n                if nei.val not in vis:\\n                    vis.add(nei.val)\\n                    queue.append((nei.val, time + 1))\\n        \\n        return max_infection\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n        graph = defaultdict(list)\\n        \\n        def build_graph(parent, node):\\n            if not node: return \\n            \\n            if parent:\\n                graph[parent.val].append(node)\\n                graph[node.val].append(parent)\\n            \\n            build_graph(node, node.left)\\n            build_graph(node, node.right)\\n        \\n        build_graph(None, root)\\n        \\n        vis = set()\\n        max_infection = 0\\n        queue = deque([(start, 0)])\\n        vis.add(start)\\n        \\n        while queue:\\n            node_val, time = queue.popleft()\\n            max_infection = max(max_infection, time)\\n            \\n            for nei in graph[node_val]:\\n                if nei.val not in vis:\\n                    vis.add(nei.val)\\n                    queue.append((nei.val, time + 1))\\n        \\n        return max_infection\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456583,
                "title": "cpp-plain-bfs",
                "content": "**Intuition :** Store the edges from child to parent for each node i.e `backEdge` and run simple `BFS`  from `startNode`\\n**P.S :** You need to search `startNode`  and also you need to count total nodes\\n\\n```\\nclass Solution {\\npublic:\\n    TreeNode *startEdge=NULL;\\n    int totalNodes=0;\\n    void dfs(TreeNode *root,unordered_map<int,TreeNode*> &backEdge,int start){\\n        if(!root)return ;\\n        if(root->left)backEdge[root->left->val]=root;\\n        if(root->right)backEdge[root->right->val]=root;\\n        if(root->val==start) startEdge=root;\\n        dfs(root->left,backEdge,start);\\n        dfs(root->right,backEdge,start);\\n        totalNodes++;\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<int,TreeNode *> backEdge;\\n        queue<TreeNode*> q;\\n        totalNodes=0;\\n        dfs(root,backEdge,start);\\n        unordered_set<int> vis;\\n        q.push(startEdge);\\n        int ans=0;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                TreeNode *currEdge=q.front();\\n                q.pop();\\n                if(vis.count(currEdge->val))continue;\\n                vis.insert(currEdge->val);\\n                if(vis.size()==totalNodes) return ans;\\n                if(backEdge.count(currEdge->val))q.push(backEdge[currEdge->val]);\\n                if(currEdge->left)q.push(currEdge->left);\\n                if(currEdge->right)q.push(currEdge->right);\\n            }\\n            ans++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode *startEdge=NULL;\\n    int totalNodes=0;\\n    void dfs(TreeNode *root,unordered_map<int,TreeNode*> &backEdge,int start){\\n        if(!root)return ;\\n        if(root->left)backEdge[root->left->val]=root;\\n        if(root->right)backEdge[root->right->val]=root;\\n        if(root->val==start) startEdge=root;\\n        dfs(root->left,backEdge,start);\\n        dfs(root->right,backEdge,start);\\n        totalNodes++;\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<int,TreeNode *> backEdge;\\n        queue<TreeNode*> q;\\n        totalNodes=0;\\n        dfs(root,backEdge,start);\\n        unordered_set<int> vis;\\n        q.push(startEdge);\\n        int ans=0;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            while(sz--){\\n                TreeNode *currEdge=q.front();\\n                q.pop();\\n                if(vis.count(currEdge->val))continue;\\n                vis.insert(currEdge->val);\\n                if(vis.size()==totalNodes) return ans;\\n                if(backEdge.count(currEdge->val))q.push(backEdge[currEdge->val]);\\n                if(currEdge->left)q.push(currEdge->left);\\n                if(currEdge->right)q.push(currEdge->right);\\n            }\\n            ans++;\\n        }\\n        return 0;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456581,
                "title": "duplicate-time-to-burn-a-tree-visual-explanation",
                "content": "Self Notes: \\n\\uD83C\\uDF4A Mark each node to its parent to traverse upwards in a binary tree\\n\\uD83C\\uDF4A We will do a BFS traversal from our starting node.\\n\\uD83C\\uDF4A Traverse up, left, right until 1 radial level (adjacent nodes) are burned and increment our timer.\\n\\n```\\nInput : \\n            1\\n       /       \\\\\\n      2          3\\n    /  \\\\          \\\\\\n   4    5          6\\n      /   \\\\         \\\\\\n     7     8         9\\n                      \\\\\\n                       10\\nInfected Node = 8\\nOutput : 7\\n\\nInitially 8 is set to fire at 0th sec.\\n            1\\n       /       \\\\\\n      2          3\\n    /  \\\\          \\\\\\n   4    5          6\\n      /   \\\\         \\\\\\n     7     F         9\\n                      \\\\\\n                       10\\nAfter 1s: 5 is set to fire.\\n            1\\n       /       \\\\\\n      2          3\\n    /  \\\\          \\\\\\n   4    F          6\\n      /   \\\\         \\\\\\n     7     F         9\\n                      \\\\\\n                       10\\nAfter 2s: 2, 7 are set to fire.\\n            1\\n       /       \\\\\\n      F          3\\n    /  \\\\          \\\\\\n   4    F          6\\n      /   \\\\         \\\\\\n     F     F         9\\n                      \\\\\\n                       10\\nAfter 3s: 4, 1 are set to fire.\\n            F\\n       /       \\\\\\n      F          3\\n    /  \\\\          \\\\\\n   F    F          6\\n      /   \\\\         \\\\\\n     F     F         9\\n                      \\\\\\n                       10\\nAfter 4s: 3 is set to fire.\\n            F\\n       /       \\\\\\n      F          F\\n    /  \\\\          \\\\\\n   F    F          6\\n      /   \\\\         \\\\\\n     F     F         9\\n                      \\\\\\n                       10\\nAfter 5s: 6 is set to fire.\\n            F\\n       /       \\\\\\n      F          F\\n    /  \\\\          \\\\\\n   F    F          F\\n      /   \\\\         \\\\\\n     F     F         9\\n                      \\\\\\n                       10\\nAfter 6s: 9 is set to fire.\\n            F\\n       /       \\\\\\n      F          F\\n    /  \\\\          \\\\\\n   F    F          F\\n      /   \\\\         \\\\\\n     F     F         F\\n                      \\\\\\n                       10\\nAfter 7s: 10 is set to fire.\\n            F\\n       /       \\\\\\n      F          F\\n    /  \\\\          \\\\\\n   F    F          F\\n      /   \\\\         \\\\\\n     F     F         F\\n                      \\\\\\n                       F\\nIt takes 7s to burn the complete tree.\\n```\\n\\n```\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        HashMap<TreeNode, TreeNode> mpp=new HashMap<>();\\n        TreeNode target=bfsToMapParents(root,mpp,start);\\n        \\n       return findMaxDistance(mpp, target);\\n    }\\n    private static int findMaxDistance(HashMap<TreeNode, TreeNode> mpp, TreeNode target) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(target);\\n        HashMap<TreeNode,Integer> vis = new HashMap<>();\\n        vis.put(target, 1);\\n        int maxi = 0;\\n        \\n        while(!q.isEmpty()) {\\n            int sz = q.size();\\n            int fl = 0;\\n            \\n            for(int i = 0;i<sz;i++) {\\n                TreeNode node = q.poll();\\n                if(node.left != null && vis.get(node.left) == null) {\\n                    fl = 1;\\n                    vis.put(node.left, 1);\\n                    q.offer(node.left);\\n                }\\n                if(node.right != null && vis.get(node.right) == null) {\\n                    fl = 1;\\n                    vis.put(node.right, 1);\\n                    q.offer(node.right);\\n                }\\n\\n                if(mpp.get(node) != null && vis.get(mpp.get(node)) == null) {\\n                    fl = 1;\\n                    vis.put(mpp.get(node), 1);\\n                    q.offer(mpp.get(node));\\n                }\\n            }\\n            if(fl == 1) maxi++;\\n        }\\n        return maxi;\\n    }\\n     TreeNode bfsToMapParents(TreeNode root,HashMap<TreeNode, TreeNode> mpp, int start) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        TreeNode res = new TreeNode(-1);\\n        while(!q.isEmpty()) {\\n            TreeNode node = q.poll();\\n            if(node.val == start) res = node;\\n            if(node.left != null) {\\n                mpp.put(node.left, node);\\n                q.offer(node.left);\\n            }\\n            if(node.right != null) {\\n                mpp.put(node.right, node);\\n                q.offer(node.right);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```\\n\\n* Upvote if You Like my post\\n\\n",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nInput : \\n            1\\n       /       \\\\\\n      2          3\\n    /  \\\\          \\\\\\n   4    5          6\\n      /   \\\\         \\\\\\n     7     8         9\\n                      \\\\\\n                       10\\nInfected Node = 8\\nOutput : 7\\n\\nInitially 8 is set to fire at 0th sec.\\n            1\\n       /       \\\\\\n      2          3\\n    /  \\\\          \\\\\\n   4    5          6\\n      /   \\\\         \\\\\\n     7     F         9\\n                      \\\\\\n                       10\\nAfter 1s: 5 is set to fire.\\n            1\\n       /       \\\\\\n      2          3\\n    /  \\\\          \\\\\\n   4    F          6\\n      /   \\\\         \\\\\\n     7     F         9\\n                      \\\\\\n                       10\\nAfter 2s: 2, 7 are set to fire.\\n            1\\n       /       \\\\\\n      F          3\\n    /  \\\\          \\\\\\n   4    F          6\\n      /   \\\\         \\\\\\n     F     F         9\\n                      \\\\\\n                       10\\nAfter 3s: 4, 1 are set to fire.\\n            F\\n       /       \\\\\\n      F          3\\n    /  \\\\          \\\\\\n   F    F          6\\n      /   \\\\         \\\\\\n     F     F         9\\n                      \\\\\\n                       10\\nAfter 4s: 3 is set to fire.\\n            F\\n       /       \\\\\\n      F          F\\n    /  \\\\          \\\\\\n   F    F          6\\n      /   \\\\         \\\\\\n     F     F         9\\n                      \\\\\\n                       10\\nAfter 5s: 6 is set to fire.\\n            F\\n       /       \\\\\\n      F          F\\n    /  \\\\          \\\\\\n   F    F          F\\n      /   \\\\         \\\\\\n     F     F         9\\n                      \\\\\\n                       10\\nAfter 6s: 9 is set to fire.\\n            F\\n       /       \\\\\\n      F          F\\n    /  \\\\          \\\\\\n   F    F          F\\n      /   \\\\         \\\\\\n     F     F         F\\n                      \\\\\\n                       10\\nAfter 7s: 10 is set to fire.\\n            F\\n       /       \\\\\\n      F          F\\n    /  \\\\          \\\\\\n   F    F          F\\n      /   \\\\         \\\\\\n     F     F         F\\n                      \\\\\\n                       F\\nIt takes 7s to burn the complete tree.\\n```\n```\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        HashMap<TreeNode, TreeNode> mpp=new HashMap<>();\\n        TreeNode target=bfsToMapParents(root,mpp,start);\\n        \\n       return findMaxDistance(mpp, target);\\n    }\\n    private static int findMaxDistance(HashMap<TreeNode, TreeNode> mpp, TreeNode target) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(target);\\n        HashMap<TreeNode,Integer> vis = new HashMap<>();\\n        vis.put(target, 1);\\n        int maxi = 0;\\n        \\n        while(!q.isEmpty()) {\\n            int sz = q.size();\\n            int fl = 0;\\n            \\n            for(int i = 0;i<sz;i++) {\\n                TreeNode node = q.poll();\\n                if(node.left != null && vis.get(node.left) == null) {\\n                    fl = 1;\\n                    vis.put(node.left, 1);\\n                    q.offer(node.left);\\n                }\\n                if(node.right != null && vis.get(node.right) == null) {\\n                    fl = 1;\\n                    vis.put(node.right, 1);\\n                    q.offer(node.right);\\n                }\\n\\n                if(mpp.get(node) != null && vis.get(mpp.get(node)) == null) {\\n                    fl = 1;\\n                    vis.put(mpp.get(node), 1);\\n                    q.offer(mpp.get(node));\\n                }\\n            }\\n            if(fl == 1) maxi++;\\n        }\\n        return maxi;\\n    }\\n     TreeNode bfsToMapParents(TreeNode root,HashMap<TreeNode, TreeNode> mpp, int start) {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.offer(root);\\n        TreeNode res = new TreeNode(-1);\\n        while(!q.isEmpty()) {\\n            TreeNode node = q.poll();\\n            if(node.val == start) res = node;\\n            if(node.left != null) {\\n                mpp.put(node.left, node);\\n                q.offer(node.left);\\n            }\\n            if(node.right != null) {\\n                mpp.put(node.right, node);\\n                q.offer(node.right);\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456756,
                "title": "java-clean-solution-simple-dfs-traversal-no-hashmap",
                "content": "just like burning tree\\n\\n\\n*class Solution {\\n    \\n    ArrayList<ArrayList<Integer>> ans;\\n    \\n    public  void burn(TreeNode root,int time,TreeNode exc){\\n        \\n      if(root == null || root == exc) return;\\n      if(ans.size() == time) ans.add(new ArrayList<>());\\n      ans.get(time).add(root.val);\\n      burn(root.left,time+1,exc);\\n      burn(root.right,time+1,exc);\\n        \\n  }\\n     public  int helper(TreeNode root,int tar){\\n         \\n      if(root == null) return -1;\\n      if(root.val == tar){\\n          burn(root,0,null);\\n          return 1;\\n      }\\n      int lf = helper(root.left,tar);\\n      if(lf != -1){\\n          burn(root,lf,root.left);\\n          return lf+1;\\n      }\\n      int rh = helper(root.right,tar);\\n       if(rh != -1){\\n          burn(root,rh,root.right);\\n          return rh+1;\\n      }\\n      return -1;\\n    }\\n    public int amountOfTime(TreeNode root, int start) {\\n    ans = new ArrayList<>();\\n    helper(root,start);\\n    return ans.size()-1;\\n    }*\\n}*",
                "solutionTags": [
                    "Java",
                    "Array",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n    \\n    ArrayList<ArrayList<Integer>> ans;\\n    \\n    public  void burn(TreeNode root,int time,TreeNode exc){\\n        \\n      if(root == null || root == exc) return;\\n      if(ans.size() == time) ans.add(new ArrayList<>());\\n      ans.get(time).add(root.val);\\n      burn(root.left,time+1,exc);\\n      burn(root.right,time+1,exc);\\n        \\n  }",
                "codeTag": "Java"
            },
            {
                "id": 2457987,
                "title": "create-graph-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxValue(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return INT_MIN;\\n        if(root->left==NULL and root->right==NULL)\\n            return root->val;\\n        int lmax=maxValue(root->left);\\n        int rmax=maxValue(root->right);\\n        return max(max(lmax,rmax),root->val);\\n    }\\n    int amountOfTime(TreeNode* root, int start)\\n    {\\n        int n=maxValue(root);\\n        vector<int>graph[n+1];\\n        // Construct our Graph using Level Order of Tree\\n        queue<TreeNode *>myq;\\n        myq.push(root);\\n        vector<bool>vertex(n+1,false);\\n        while(myq.size()!=0)\\n        {\\n            TreeNode *front=myq.front();\\n            myq.pop();\\n            if(front!=NULL)\\n            {\\n                int u=front->val;\\n                if(front->left!=NULL)\\n                {\\n                 int v=front->left->val;\\n                 graph[u].push_back(v);\\n                 vertex[u]=true;\\n                 vertex[v]=true;\\n                 graph[v].push_back(u);\\n                 myq.push(front->left);\\n                }    \\n                if(front->right!=NULL)\\n                {\\n                 int v=front->right->val;\\n                 graph[u].push_back(v);\\n                 graph[v].push_back(u);\\n                 vertex[u]=true;\\n                 vertex[v]=true;\\n                 myq.push(front->right);\\n                }   \\n            }\\n        }\\n        \\n        //  Graph Construction Done\\n        // Now APPLY BFS SHORTEST PATH\\n        vector<int>distance(n+1,INT_MAX);\\n        queue<int>graphQueue;\\n        graphQueue.push(start);\\n        distance[start]=0;\\n        while(graphQueue.size()!=0)\\n        {\\n            int front=graphQueue.front();\\n            graphQueue.pop();\\n            for(auto nbrs:graph[front])\\n            {\\n                if(distance[nbrs]==INT_MAX)\\n                {\\n                    distance[nbrs]=distance[front]+1;\\n                    graphQueue.push(nbrs);\\n                }\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(vertex[i] and distance[i]>ans)\\n            {\\n                ans=max(ans,distance[i]);\\n            }\\n        }\\n        return ans==INT_MIN?0 :ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxValue(TreeNode *root)\\n    {\\n        if(root==NULL)\\n            return INT_MIN;\\n        if(root->left==NULL and root->right==NULL)\\n            return root->val;\\n        int lmax=maxValue(root->left);\\n        int rmax=maxValue(root->right);\\n        return max(max(lmax,rmax),root->val);\\n    }\\n    int amountOfTime(TreeNode* root, int start)\\n    {\\n        int n=maxValue(root);\\n        vector<int>graph[n+1];\\n        // Construct our Graph using Level Order of Tree\\n        queue<TreeNode *>myq;\\n        myq.push(root);\\n        vector<bool>vertex(n+1,false);\\n        while(myq.size()!=0)\\n        {\\n            TreeNode *front=myq.front();\\n            myq.pop();\\n            if(front!=NULL)\\n            {\\n                int u=front->val;\\n                if(front->left!=NULL)\\n                {\\n                 int v=front->left->val;\\n                 graph[u].push_back(v);\\n                 vertex[u]=true;\\n                 vertex[v]=true;\\n                 graph[v].push_back(u);\\n                 myq.push(front->left);\\n                }    \\n                if(front->right!=NULL)\\n                {\\n                 int v=front->right->val;\\n                 graph[u].push_back(v);\\n                 graph[v].push_back(u);\\n                 vertex[u]=true;\\n                 vertex[v]=true;\\n                 myq.push(front->right);\\n                }   \\n            }\\n        }\\n        \\n        //  Graph Construction Done\\n        // Now APPLY BFS SHORTEST PATH\\n        vector<int>distance(n+1,INT_MAX);\\n        queue<int>graphQueue;\\n        graphQueue.push(start);\\n        distance[start]=0;\\n        while(graphQueue.size()!=0)\\n        {\\n            int front=graphQueue.front();\\n            graphQueue.pop();\\n            for(auto nbrs:graph[front])\\n            {\\n                if(distance[nbrs]==INT_MAX)\\n                {\\n                    distance[nbrs]=distance[front]+1;\\n                    graphQueue.push(nbrs);\\n                }\\n            }\\n        }\\n        int ans=INT_MIN;\\n        for(int i=1;i<=n;i++)\\n        {\\n            if(vertex[i] and distance[i]>ans)\\n            {\\n                ans=max(ans,distance[i]);\\n            }\\n        }\\n        return ans==INT_MIN?0 :ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456611,
                "title": "c-dfs-o-n",
                "content": "```\\n// TC - O(N)\\n\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void traversal(TreeNode * root,vector<int> graph[],int parent){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        if(parent!=-1){\\n            graph[root->val].push_back(parent);\\n            graph[parent].push_back(root->val);\\n        }\\n\\n        traversal(root->left,graph,root->val);\\n        traversal(root->right,graph,root->val);\\n        return;\\n    } \\n    \\n    void dfs(int curr , vector<int> graph[] , int depth[] , int parent){\\n        if(parent!=-1) depth[curr] = depth[parent]+1;\\n\\n        ans = max(ans,depth[curr]);\\n        for(auto x : graph[curr]){\\n            if(x!=parent){\\n                dfs(x,graph,depth,curr);\\n            }\\n        }\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n        int N = 1e5 + 1;\\n        vector<int> graph[N];\\n        traversal(root,graph,-1); // making Graph\\n        int depth[N]; memset(depth,0,sizeof(depth)); // depth calculation\\n        dfs(start,graph,depth,-1);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n// TC - O(N)\\n\\n\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    void traversal(TreeNode * root,vector<int> graph[],int parent){\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        if(parent!=-1){\\n            graph[root->val].push_back(parent);\\n            graph[parent].push_back(root->val);\\n        }\\n\\n        traversal(root->left,graph,root->val);\\n        traversal(root->right,graph,root->val);\\n        return;\\n    } \\n    \\n    void dfs(int curr , vector<int> graph[] , int depth[] , int parent){\\n        if(parent!=-1) depth[curr] = depth[parent]+1;\\n\\n        ans = max(ans,depth[curr]);\\n        for(auto x : graph[curr]){\\n            if(x!=parent){\\n                dfs(x,graph,depth,curr);\\n            }\\n        }\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n        int N = 1e5 + 1;\\n        vector<int> graph[N];\\n        traversal(root,graph,-1); // making Graph\\n        int depth[N]; memset(depth,0,sizeof(depth)); // depth calculation\\n        dfs(start,graph,depth,-1);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2467920,
                "title": "c-bfs-hashmap-easy-to-understand",
                "content": "Inorder to preform BFS traversal we have to store the parent of the given node. So by using a map we store the current node and its parent node. After this we will search for the start node ( starting point of bfs traversal) using find function and perform simple BFS traversal while maintaining a map for visited nodes.\\n\\nUPVOTE IF IT HELPS!! :)\\n\\n```\\nTreeNode* find(TreeNode* root,int target){\\n        if(!root)return NULL;\\n        if(root->val==target)return root;\\n        TreeNode* r =find(root->right,target);\\n        TreeNode* l =find(root->left,target);\\n        if(!l){\\n            return r;\\n        }\\n        else\\n            return l;\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        map<TreeNode*,TreeNode*>mp;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode* x=q.front();\\n                q.pop();\\n                if(x->left){\\n                    q.push(x->left);\\n                    mp[x->left]=x;\\n                }\\n                if(x->right){\\n                    q.push(x->right);\\n                    mp[x->right]=x;\\n                }\\n            }\\n        }\\n        \\n        map<TreeNode*,int >vis;\\n        int res=0;\\n        TreeNode* t=find(root,start);\\n        q.push(t);\\n        vis[t]=1;\\n        while(!q.empty()){\\n            int size=q.size();\\n            int flg=0;\\n            for(int i=0;i<size;i++){\\n                TreeNode* x=q.front();\\n                q.pop();\\n                \\n                if((x->left) && !vis[x->left]){\\n                    q.push(x->left);\\n                    vis[x->left]=1;\\n                    flg=1;\\n                }\\n                if((x->right) && !vis[x->right] ){\\n                    q.push(x->right);\\n                    vis[x->right]=1;\\n                    flg=1;\\n                }\\n                if(mp[x] && !vis[mp[x]]){\\n                    flg=1;\\n                    vis[mp[x]]=1;\\n                    q.push(mp[x]);\\n                }\\n            }\\n            if(flg)res++;\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nTreeNode* find(TreeNode* root,int target){\\n        if(!root)return NULL;\\n        if(root->val==target)return root;\\n        TreeNode* r =find(root->right,target);\\n        TreeNode* l =find(root->left,target);\\n        if(!l){\\n            return r;\\n        }\\n        else\\n            return l;\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        map<TreeNode*,TreeNode*>mp;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            int size=q.size();\\n            for(int i=0;i<size;i++){\\n                TreeNode* x=q.front();\\n                q.pop();\\n                if(x->left){\\n                    q.push(x->left);\\n                    mp[x->left]=x;\\n                }\\n                if(x->right){\\n                    q.push(x->right);\\n                    mp[x->right]=x;\\n                }\\n            }\\n        }\\n        \\n        map<TreeNode*,int >vis;\\n        int res=0;\\n        TreeNode* t=find(root,start);\\n        q.push(t);\\n        vis[t]=1;\\n        while(!q.empty()){\\n            int size=q.size();\\n            int flg=0;\\n            for(int i=0;i<size;i++){\\n                TreeNode* x=q.front();\\n                q.pop();\\n                \\n                if((x->left) && !vis[x->left]){\\n                    q.push(x->left);\\n                    vis[x->left]=1;\\n                    flg=1;\\n                }\\n                if((x->right) && !vis[x->right] ){\\n                    q.push(x->right);\\n                    vis[x->right]=1;\\n                    flg=1;\\n                }\\n                if(mp[x] && !vis[mp[x]]){\\n                    flg=1;\\n                    vis[mp[x]]=1;\\n                    q.push(mp[x]);\\n                }\\n            }\\n            if(flg)res++;\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2460913,
                "title": "dfs-one-pass-fast-beat-100-memory",
                "content": "\\n### Symantec of dfs function:\\n\\nIf it returns a positive integer, it means the distance to the start node. One of its paths to the leaf passed the start node.\\nIf it returns a negative integer, it shows any of the children branches does not pass the start. The absolute value of the returned negative is the longest distance to the children leaf node.\\n\\n### Steps in dfs function:\\n1. The base case: If the current tree node is the target start, return 0. Update the longest time res[0] with the absolute value of the longer children branch.\\n2. If one child (for example, left) branch passes the start node (left > 0 || (root.left != null && root.left.val == start)), compare the maximal time with maximal time of paths that pass current node (sum), then return the distance between current node and start node.\\n3. If both branches don\\'t pass the start node, return the longer path to its children leaf node. To distinguish from case 2, return the negative of the longest leaf node distance.\\n\\nAnother solution with boolean status (pass or not pass start) and distance is easier to understand (https://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/discuss/2457375/DFS-oror-C%2B%2B-oror-Simple-Tree-Traversal). This method compresses boolean status and distance value of a signed integer.\\n\\n**Java solution**\\n``` java\\n// Beat 100% Time and Memory\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        int[] res = new int[]{0};\\n        dfs(root, start, res);\\n        return res[0];\\n    }\\n    \\n    private int dfs(TreeNode root, int start, int[] res) {\\n        if (root == null) return 0;\\n        int left = dfs(root.left, start, res);\\n        int right = dfs(root.right, start, res);\\n        if (root.val == start) { // 1. base case\\n            int temp = Math.max(Math.abs(left), Math.abs(right));\\n            res[0] = Math.max(res[0], temp);\\n            return 0;\\n        }\\n        \\n\\t\\t// 2. has children path that passes start node\\n        if (left > 0 || (root.left != null && root.left.val == start)) {\\n            int sum = left + Math.abs(right) + 1;\\n            res[0] = Math.max(res[0], sum);\\n            return left + 1;\\n        } else if (right > 0 || (root.right != null && root.right.val == start)) {\\n            int sum = right + Math.abs(left) + 1;\\n            res[0] = Math.max(res[0], sum);\\n            return right + 1;\\n        } \\n        \\n\\t\\t// 3. no children paths that passes start node.\\n        int sum = Math.max(Math.abs(left), Math.abs(right));\\n        return -sum - 1;\\n    }\\n}\\n```\\n\\n**Python solution**\\n```python\\n# Beat 75% Time and Memory\\nclass Solution:\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n        res = [0]\\n        self.dfs(root, start, res)\\n        return res[0]\\n    \\n    def dfs(self, root: Optional[TreeNode], start: int, res: List[int]) -> int:\\n        if not root: return 0\\n        left = self.dfs(root.left, start, res)        \\n        right = self.dfs(root.right, start, res)\\n        if root.val == start:\\n            temp = max(abs(left), abs(right))\\n            res[0] = max(res[0], temp)\\n            return 0\\n        \\n        if left > 0 or (root.left and root.left.val == start):\\n            sumpath = left + abs(right) + 1\\n            res[0] = max(res[0], sumpath)\\n            return left + 1\\n        elif right > 0 or (root.right and root.right.val == start):\\n            sumpath = right + abs(left) + 1\\n            res[0] = max(res[0], sumpath)\\n            return right + 1        \\n        \\n        sumpath = max(abs(left), abs(right))\\n        return -sumpath - 1 \\n```\\n\\n**C++ solution**\\n```cpp\\n// Beat  Time 85.71% and 100% Memory\\nclass Solution {\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        vector<int> res(1,0);\\n        dfs(root, start, res);\\n        return res[0];\\n    }\\n    \\n    int dfs(TreeNode* root, int start, vector<int>& res) {\\n        if (root == nullptr) return 0;\\n        int left = dfs(root->left, start, res);        \\n        int right = dfs(root->right, start, res);\\n\\n        if (root->val == start) {\\n            int temp = max(abs(left), abs(right));\\n            res[0] = max(res[0], temp);\\n            return 0;\\n        }\\n        if (left > 0 || (root->left != nullptr && root->left->val == start)) {\\n            int sum = left + abs(right) + 1;\\n            res[0] = max(res[0], sum);\\n            return left + 1;\\n        } else if (right > 0 || (root->right != nullptr && root->right->val == start)) {\\n            int sum = right + abs(left) + 1;\\n            res[0] = max(res[0], sum);\\n            return right + 1;\\n        } \\n        \\n        int sum = max(abs(left), abs(right));\\n        return -sum - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Java",
                    "Python3",
                    "C",
                    "Tree",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "``` java\\n// Beat 100% Time and Memory\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        int[] res = new int[]{0};\\n        dfs(root, start, res);\\n        return res[0];\\n    }\\n    \\n    private int dfs(TreeNode root, int start, int[] res) {\\n        if (root == null) return 0;\\n        int left = dfs(root.left, start, res);\\n        int right = dfs(root.right, start, res);\\n        if (root.val == start) { // 1. base case\\n            int temp = Math.max(Math.abs(left), Math.abs(right));\\n            res[0] = Math.max(res[0], temp);\\n            return 0;\\n        }\\n        \\n\\t\\t// 2. has children path that passes start node\\n        if (left > 0 || (root.left != null && root.left.val == start)) {\\n            int sum = left + Math.abs(right) + 1;\\n            res[0] = Math.max(res[0], sum);\\n            return left + 1;\\n        } else if (right > 0 || (root.right != null && root.right.val == start)) {\\n            int sum = right + Math.abs(left) + 1;\\n            res[0] = Math.max(res[0], sum);\\n            return right + 1;\\n        } \\n        \\n\\t\\t// 3. no children paths that passes start node.\\n        int sum = Math.max(Math.abs(left), Math.abs(right));\\n        return -sum - 1;\\n    }\\n}\\n```\n```python\\n# Beat 75% Time and Memory\\nclass Solution:\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n        res = [0]\\n        self.dfs(root, start, res)\\n        return res[0]\\n    \\n    def dfs(self, root: Optional[TreeNode], start: int, res: List[int]) -> int:\\n        if not root: return 0\\n        left = self.dfs(root.left, start, res)        \\n        right = self.dfs(root.right, start, res)\\n        if root.val == start:\\n            temp = max(abs(left), abs(right))\\n            res[0] = max(res[0], temp)\\n            return 0\\n        \\n        if left > 0 or (root.left and root.left.val == start):\\n            sumpath = left + abs(right) + 1\\n            res[0] = max(res[0], sumpath)\\n            return left + 1\\n        elif right > 0 or (root.right and root.right.val == start):\\n            sumpath = right + abs(left) + 1\\n            res[0] = max(res[0], sumpath)\\n            return right + 1        \\n        \\n        sumpath = max(abs(left), abs(right))\\n        return -sumpath - 1 \\n```\n```cpp\\n// Beat  Time 85.71% and 100% Memory\\nclass Solution {\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        vector<int> res(1,0);\\n        dfs(root, start, res);\\n        return res[0];\\n    }\\n    \\n    int dfs(TreeNode* root, int start, vector<int>& res) {\\n        if (root == nullptr) return 0;\\n        int left = dfs(root->left, start, res);        \\n        int right = dfs(root->right, start, res);\\n\\n        if (root->val == start) {\\n            int temp = max(abs(left), abs(right));\\n            res[0] = max(res[0], temp);\\n            return 0;\\n        }\\n        if (left > 0 || (root->left != nullptr && root->left->val == start)) {\\n            int sum = left + abs(right) + 1;\\n            res[0] = max(res[0], sum);\\n            return left + 1;\\n        } else if (right > 0 || (root->right != nullptr && root->right->val == start)) {\\n            int sum = right + abs(left) + 1;\\n            res[0] = max(res[0], sum);\\n            return right + 1;\\n        } \\n        \\n        int sum = max(abs(left), abs(right));\\n        return -sum - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457714,
                "title": "c-bfs-with-explanation-amount-of-time-for-binary-tree-to-be-infected",
                "content": "\\t/**\\n\\t * Definition for a binary tree node.\\n\\t * struct TreeNode {\\n\\t *     int val;\\n\\t *     TreeNode *left;\\n\\t *     TreeNode *right;\\n\\t *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n\\t *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n\\t * };\\n\\t */\\n\\n\\t// Make adjacency list from the given tree by level order traversal (in adj matrix we will push {3,5} corresponding to 1 \\n\\t// and also push 1 corresponding to 3 and 5) we will do repeatedly until adjacency list is formed\\n\\t// then apply bfs in order to find the min minutes \\n\\t// let say we are at 3 which is  start node then in first iteration 3 will be popped and 1,6,10 will be inserted and level becoms 1 \\n\\t// after 1st iteration 1,6,10 will be popped  and level becomes 2  \\n\\t// after second iteration 5 will be popped and level will be 3\\n\\t// after 3rd iteration 4 will be popped  level will 4\\n\\t// in last iteration 9,2 will be popped and level becimes 5 \\n\\t// one thing is to be observed here is that in the first iteration we only popped 3 and inserted 1,6,10\\n\\t// and our level becomes 1 and also at this instance  time is  0 since we are not taking any time to infect start node \\n\\t// so required time will be 1 less than level so fnally return level-1 as ans \\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint amountOfTime(TreeNode* root, int start) {\\n\\t\\t\\tmap<int,vector<int>>adj;\\n\\t\\t\\tqueue<TreeNode*>q; q.push(root);\\n\\t\\t\\t// adjacency list formation\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tTreeNode*curr=q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tif(curr->left){\\n\\t\\t\\t\\t\\tq.push(curr->left);\\n\\t\\t\\t\\t\\tadj[curr->val].push_back(curr->left->val);\\n\\t\\t\\t\\t\\tadj[curr->left->val].push_back(curr->val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(curr->right){\\n\\t\\t\\t\\t\\tq.push(curr->right);\\n\\t\\t\\t\\t\\tadj[curr->val].push_back(curr->right->val);\\n\\t\\t\\t\\t\\tadj[curr->right->val].push_back(curr->val);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t// apply bfs \\n\\t\\t\\tqueue<int>q2;\\n\\t\\t\\tunordered_set<int>st;\\n\\t\\t\\tq2.push(start); st.insert(start);\\n\\t\\t\\tint level=0;\\n\\t\\t\\twhile(!q2.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tint sz=q2.size();\\n\\t\\t\\t\\tfor(int i=0;i<sz;i++)\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tint curr=q2.front();\\n\\t\\t\\t\\t\\tq2.pop();\\n\\t\\t\\t\\t\\tfor(auto &i:adj[curr])\\n\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\tif(st.count(i)==0)\\n\\t\\t\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\t\\t\\tq2.push(i);\\n\\t\\t\\t\\t\\t\\t\\tst.insert(i);\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlevel++;\\n\\t\\t\\t}\\n\\t\\t\\treturn level-1;\\n\\t\\t}\\n\\t};",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph",
                    "Binary Tree"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint amountOfTime(TreeNode* root, int start) {\\n\\t\\t\\tmap<int,vector<int>>adj;\\n\\t\\t\\tqueue<TreeNode*>q; q.push(root);\\n\\t\\t\\t// adjacency list formation\\n\\t\\t\\twhile(!q.empty())\\n\\t\\t\\t{\\n\\t\\t\\t\\tTreeNode*curr=q.front();\\n\\t\\t\\t\\tq.pop();\\n\\t\\t\\t\\tif(curr->left){\\n\\t\\t\\t\\t\\tq.push(curr->left);\\n\\t\\t\\t\\t\\tadj[curr->val].push_back(curr->left->val);\\n\\t\\t\\t\\t\\tadj[curr->left->val].push_back(curr->val);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2456915,
                "title": "python-helps-you-learn-two-classic-patterns-rotting-orange-parent-child-tree-traversal",
                "content": "First use the same pattern as [863. All Nodes Distance K in Binary Tree](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/) to build an undirected graph.\\n\\nThen use the neighbor-order traversal to traverse all nodes by levels just as  [994. Rotting Oranges](https://leetcode.com/problems/rotting-oranges/).\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n        \"\"\"\\n        graph: {1: [5,3], 5: [1,4], 3: [1,6,10], ...}\\n        \"\"\"\\n        graph = defaultdict(list)\\n        def dfs(parent, node):\\n            if not parent or not node:\\n                return\\n            graph[parent.val].append(node.val)\\n            graph[node.val].append(parent.val)\\n            if node.left:\\n                dfs(node, node.left)\\n            if node.right:\\n                dfs(node, node.right)\\n        dfs(root, root.left) \\n        dfs(root, root.right)\\n        \\n        q = deque([start])\\n        v = set([start])\\n        step = 0\\n        while q:\\n            sz = len(q)\\n            for _ in range(sz):\\n                node = q.popleft()\\n                for nei in graph[node]:\\n                    if nei not in v:\\n                        v.add(nei)\\n                        q.append(nei)\\n            step += 1\\n        return step-1\\n```\\n\\nTime: `O(Depth of Tree)`\\nSpace: `O(V+E) = O(N)`",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n        \"\"\"\\n        graph: {1: [5,3], 5: [1,4], 3: [1,6,10], ...}\\n        \"\"\"\\n        graph = defaultdict(list)\\n        def dfs(parent, node):\\n            if not parent or not node:\\n                return\\n            graph[parent.val].append(node.val)\\n            graph[node.val].append(parent.val)\\n            if node.left:\\n                dfs(node, node.left)\\n            if node.right:\\n                dfs(node, node.right)\\n        dfs(root, root.left) \\n        dfs(root, root.right)\\n        \\n        q = deque([start])\\n        v = set([start])\\n        step = 0\\n        while q:\\n            sz = len(q)\\n            for _ in range(sz):\\n                node = q.popleft()\\n                for nei in graph[node]:\\n                    if nei not in v:\\n                        v.add(nei)\\n                        q.append(nei)\\n            step += 1\\n        return step-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2498796,
                "title": "c-clean-solution-bfs-hashmap-easy-solution",
                "content": "Question is similar to **Time to Burn Tree**\\nWe traverse in all the three directions (**radially outward->left child, right child and parent**) using **BFS**.\\nTo travel towards parent, we have mapped parent and child in a HashMap.\\nWe will also use a visited map to keep track of visited nodes.\\nAt **each level** we **increase the time**.\\n\\nDo **Upvote** if you found it useful \\uD83D\\uDC4D.\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    using N = TreeNode;\\n    int amountOfTime(N* root, int start) {\\n        int time = 0;    \\n        \\n        unordered_map<N*,N*> parent;\\n        markParent(root,parent);\\n        \\n        N* target = findNode(root,start);\\n        \\n        queue<N*> q;\\n        unordered_map<N*, bool> vis;       \\n\\n        q.push(target);\\n        vis[target] = true;\\n\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            while(n--)\\n            {\\n                auto node = q.front();\\n                q.pop();\\n                vis[node] = true;\\n\\n                if(node->left and !vis[node->left])\\n                {\\n                    q.push(node->left);\\n                    vis[node->left] = true;\\n                }\\n\\n                if(node->right and !vis[node->right])\\n                {\\n                    q.push(node->right);\\n                    vis[node->right] = true;\\n                }\\n\\n                if(parent[node] and !vis[parent[node]])\\n                {\\n                    q.push(parent[node]);\\n                    vis[parent[node]] = true;\\n                }\\n            }\\n            // Completed one level, so we increase time\\n            time++;\\n        }\\n        \\n        return time-1;\\n    }\\n\\n    \\n    \\nprivate:\\n    N* findNode(N* node, int key) \\n    {\\n        if(node)\\n        {\\n            if(node->val == key) return node;        \\n            else {\\n                N* foundNode = findNode(node->left,key);\\n                if(!foundNode) foundNode = findNode(node->right,key);              \\n                return foundNode;\\n             }\\n        } \\n        else return NULL;\\n\\n    }\\n\\n    void markParent(N* root, unordered_map<N*, N*> &parent)\\n    {\\n        if(!root)return;\\n\\n        if(root->left) parent[root->left] = root;     \\n        if(root->right) parent[root->right] = root;\\n\\n        markParent(root->left,parent);\\n        markParent(root->right,parent);\\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    using N = TreeNode;\\n    int amountOfTime(N* root, int start) {\\n        int time = 0;    \\n        \\n        unordered_map<N*,N*> parent;\\n        markParent(root,parent);\\n        \\n        N* target = findNode(root,start);\\n        \\n        queue<N*> q;\\n        unordered_map<N*, bool> vis;       \\n\\n        q.push(target);\\n        vis[target] = true;\\n\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            while(n--)\\n            {\\n                auto node = q.front();\\n                q.pop();\\n                vis[node] = true;\\n\\n                if(node->left and !vis[node->left])\\n                {\\n                    q.push(node->left);\\n                    vis[node->left] = true;\\n                }\\n\\n                if(node->right and !vis[node->right])\\n                {\\n                    q.push(node->right);\\n                    vis[node->right] = true;\\n                }\\n\\n                if(parent[node] and !vis[parent[node]])\\n                {\\n                    q.push(parent[node]);\\n                    vis[parent[node]] = true;\\n                }\\n            }\\n            // Completed one level, so we increase time\\n            time++;\\n        }\\n        \\n        return time-1;\\n    }\\n\\n    \\n    \\nprivate:\\n    N* findNode(N* node, int key) \\n    {\\n        if(node)\\n        {\\n            if(node->val == key) return node;        \\n            else {\\n                N* foundNode = findNode(node->left,key);\\n                if(!foundNode) foundNode = findNode(node->right,key);              \\n                return foundNode;\\n             }\\n        } \\n        else return NULL;\\n\\n    }\\n\\n    void markParent(N* root, unordered_map<N*, N*> &parent)\\n    {\\n        if(!root)return;\\n\\n        if(root->left) parent[root->left] = root;     \\n        if(root->right) parent[root->right] = root;\\n\\n        markParent(root->left,parent);\\n        markParent(root->right,parent);\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457151,
                "title": "c-queue-bfs-easy-to-follow",
                "content": "Please Upvote :)\\n\\n```\\nclass Solution {\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<int,vector<int>> m;\\n        unordered_map<int,int> vis;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())//adding neighbours\\n        {\\n            TreeNode* t=q.front();\\n            q.pop();\\n            if(t->left)\\n            {\\n                m[t->val].push_back(t->left->val);\\n                m[t->left->val].push_back(t->val);\\n                q.push(t->left);\\n            }\\n            if(t->right)\\n            {\\n                m[t->val].push_back(t->right->val);\\n                m[t->right->val].push_back(t->val);\\n                q.push(t->right);\\n            }\\n        }\\n        queue<pair<int,int>> pq;\\n        pq.push({start,0});\\n        int res=0;\\n        vis[start]=1;\\n        while(!pq.empty())// traversing through all neighbours\\n        {\\n            auto p=pq.front();\\n            pq.pop();\\n            res=max(res,p.second);\\n            for(auto x:m[p.first])\\n            {\\n                if(vis[x]==0)\\n                {\\n                    vis[x]=1;\\n                    pq.push({x,p.second+1});\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<int,vector<int>> m;\\n        unordered_map<int,int> vis;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())//adding neighbours\\n        {\\n            TreeNode* t=q.front();\\n            q.pop();\\n            if(t->left)\\n            {\\n                m[t->val].push_back(t->left->val);\\n                m[t->left->val].push_back(t->val);\\n                q.push(t->left);\\n            }\\n            if(t->right)\\n            {\\n                m[t->val].push_back(t->right->val);\\n                m[t->right->val].push_back(t->val);\\n                q.push(t->right);\\n            }\\n        }\\n        queue<pair<int,int>> pq;\\n        pq.push({start,0});\\n        int res=0;\\n        vis[start]=1;\\n        while(!pq.empty())// traversing through all neighbours\\n        {\\n            auto p=pq.front();\\n            pq.pop();\\n            res=max(res,p.second);\\n            for(auto x:m[p.first])\\n            {\\n                if(vis[x]==0)\\n                {\\n                    vis[x]=1;\\n                    pq.push({x,p.second+1});\\n                }\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456708,
                "title": "c-use-bfs",
                "content": "```\\nclass Solution \\n{\\npublic:\\n    int timetoinfect(TreeNode* target, map<TreeNode*, TreeNode*> parent)\\n    {\\n        map<TreeNode*, bool> visited;\\n        queue<TreeNode*> q;\\n        q.push(target);\\n        visited[target] = true;\\n        int time=0;\\n        while(!q.empty())\\n        {\\n            int size = q.size(), fl=0;\\n\\n            for(int i=0; i<size; i++)\\n            {\\n                TreeNode* current = q.front(); q.pop();\\n                visited[current] = true;\\n\\n                if(current->left && !visited[current->left])\\n                {\\n                    fl =1;\\n                    q.push(current->left);\\n                    visited[current->left] = true;\\n                }\\n\\n                if(current->right && !visited[current->right])\\n                {\\n                    fl=1;\\n                    q.push(current->right);\\n                    visited[current->right] = true;\\n                }\\n\\n                if(parent[current] && !visited[parent[current]])\\n                {\\n                    fl=1;\\n                    q.push(parent[current]);\\n                    visited[parent[current]] = true;\\n                }\\n            }\\n            if(fl) time++;\\n        }\\n        return time;\\n    }\\n   TreeNode* makeParent(TreeNode* root, map<TreeNode*, TreeNode*> &parent, int start)\\n    {\\n        TreeNode* target;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if(node->val == start) \\n                target = node;\\n            if(node->left)\\n            {\\n                q.push(node->left);\\n                parent[node->left] = node;\\n            }\\n            if(node->right)\\n            {\\n                q.push(node->right);\\n                parent[node->right] = node;\\n            }\\n        }\\n        return target;\\n    }\\n    int amountOfTime(TreeNode* root, int start) \\n    {\\n        map<TreeNode*, TreeNode*> parent;\\n        TreeNode* target = makeParent(root, parent, start);\\n        int maxi = timetoinfect(target, parent);\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int timetoinfect(TreeNode* target, map<TreeNode*, TreeNode*> parent)\\n    {\\n        map<TreeNode*, bool> visited;\\n        queue<TreeNode*> q;\\n        q.push(target);\\n        visited[target] = true;\\n        int time=0;\\n        while(!q.empty())\\n        {\\n            int size = q.size(), fl=0;\\n\\n            for(int i=0; i<size; i++)\\n            {\\n                TreeNode* current = q.front(); q.pop();\\n                visited[current] = true;\\n\\n                if(current->left && !visited[current->left])\\n                {\\n                    fl =1;\\n                    q.push(current->left);\\n                    visited[current->left] = true;\\n                }\\n\\n                if(current->right && !visited[current->right])\\n                {\\n                    fl=1;\\n                    q.push(current->right);\\n                    visited[current->right] = true;\\n                }\\n\\n                if(parent[current] && !visited[parent[current]])\\n                {\\n                    fl=1;\\n                    q.push(parent[current]);\\n                    visited[parent[current]] = true;\\n                }\\n            }\\n            if(fl) time++;\\n        }\\n        return time;\\n    }\\n   TreeNode* makeParent(TreeNode* root, map<TreeNode*, TreeNode*> &parent, int start)\\n    {\\n        TreeNode* target;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if(node->val == start) \\n                target = node;\\n            if(node->left)\\n            {\\n                q.push(node->left);\\n                parent[node->left] = node;\\n            }\\n            if(node->right)\\n            {\\n                q.push(node->right);\\n                parent[node->right] = node;\\n            }\\n        }\\n        return target;\\n    }\\n    int amountOfTime(TreeNode* root, int start) \\n    {\\n        map<TreeNode*, TreeNode*> parent;\\n        TreeNode* target = makeParent(root, parent, start);\\n        int maxi = timetoinfect(target, parent);\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456606,
                "title": "c-solution-using-dfs",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n     int ans=0;\\nbool serach(TreeNode*root,int val,vector<TreeNode*>&v)\\n{\\n    if(root==NULL)\\n    {\\n        return false;\\n    }\\n    if(root->val==val)\\n    {\\n        v.push_back(root);\\n        return true;\\n    }\\n    if(serach(root->left,val,v)||serach(root->right,val,v))\\n    {\\n        v.push_back(root);\\n        return true;\\n    }\\n    return false;\\n}\\nvoid find(TreeNode*root,TreeNode*blocker,int level)\\n{\\n    if(root==NULL||root==blocker)\\n    {\\n        return ;\\n    }\\n    ans=max(ans,level);\\n    find(root->left,blocker,level+1);\\n    find(root->right,blocker,level+1);\\n}\\n    int amountOfTime(TreeNode* root, int start) {\\n        ans=0;\\n    vector<TreeNode*>v;\\n    serach(root,start,v);\\n    if(v.size()==0)\\n    {\\n        return 0;\\n    }\\n    for(int i=0;i<v.size();i++)\\n    {\\n        find(v[i],i==0?NULL:v[i-1],i);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n     int ans=0;\\nbool serach(TreeNode*root,int val,vector<TreeNode*>&v)\\n{\\n    if(root==NULL)\\n    {\\n        return false;\\n    }\\n    if(root->val==val)\\n    {\\n        v.push_back(root);\\n        return true;\\n    }\\n    if(serach(root->left,val,v)||serach(root->right,val,v))\\n    {\\n        v.push_back(root);\\n        return true;\\n    }\\n    return false;\\n}\\nvoid find(TreeNode*root,TreeNode*blocker,int level)\\n{\\n    if(root==NULL||root==blocker)\\n    {\\n        return ;\\n    }\\n    ans=max(ans,level);\\n    find(root->left,blocker,level+1);\\n    find(root->right,blocker,level+1);\\n}\\n    int amountOfTime(TreeNode* root, int start) {\\n        ans=0;\\n    vector<TreeNode*>v;\\n    serach(root,start,v);\\n    if(v.size()==0)\\n    {\\n        return 0;\\n    }\\n    for(int i=0;i<v.size();i++)\\n    {\\n        find(v[i],i==0?NULL:v[i-1],i);\\n    }\\n    return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3362824,
                "title": "solution-in-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void createGraph(TreeNode* root,unordered_map<int,vector<int>>&mp)\\n    {\\n        if(root==NULL)return;\\n        createGraph(root->right,mp);\\n        createGraph(root->left,mp);\\n        if(root->right)\\n        {\\n            mp[root->val].push_back(root->right->val);\\n            mp[root->right->val].push_back(root->val);\\n        }\\n        if(root->left)\\n        { \\n            mp[root->val].push_back(root->left->val);\\n            mp[root->left->val].push_back(root->val);\\n        }\\n    }\\n    int solve(TreeNode* root,unordered_map<int,vector<int>>&mp,int start)\\n    {\\n        queue<pair<int,int>>q;\\n        q.push({start,0});\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            auto frnt=q.front();\\n            q.pop();\\n            for(auto i:mp[frnt.first])\\n            {\\n                if(mp.find(i)!=mp.end()) q.push({i,frnt.second+1});\\n            }\\n            ans=max(ans,frnt.second);\\n            mp.erase(frnt.first);\\n        }\\n        return ans;\\n    }\\n    int amountOfTime(TreeNode* root, int start)\\n     {\\n        unordered_map<int,vector<int>>mp;\\n        createGraph(root,mp);\\n        return solve(root,mp,start);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void createGraph(TreeNode* root,unordered_map<int,vector<int>>&mp)\\n    {\\n        if(root==NULL)return;\\n        createGraph(root->right,mp);\\n        createGraph(root->left,mp);\\n        if(root->right)\\n        {\\n            mp[root->val].push_back(root->right->val);\\n            mp[root->right->val].push_back(root->val);\\n        }\\n        if(root->left)\\n        { \\n            mp[root->val].push_back(root->left->val);\\n            mp[root->left->val].push_back(root->val);\\n        }\\n    }\\n    int solve(TreeNode* root,unordered_map<int,vector<int>>&mp,int start)\\n    {\\n        queue<pair<int,int>>q;\\n        q.push({start,0});\\n        int ans=0;\\n        while(!q.empty())\\n        {\\n            auto frnt=q.front();\\n            q.pop();\\n            for(auto i:mp[frnt.first])\\n            {\\n                if(mp.find(i)!=mp.end()) q.push({i,frnt.second+1});\\n            }\\n            ans=max(ans,frnt.second);\\n            mp.erase(frnt.first);\\n        }\\n        return ans;\\n    }\\n    int amountOfTime(TreeNode* root, int start)\\n     {\\n        unordered_map<int,vector<int>>mp;\\n        createGraph(root,mp);\\n        return solve(root,mp,start);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3119190,
                "title": "java-bfs",
                "content": "```\\n/*\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int find_ans(Map<Integer,List<Integer>> map,int start){\\n      Queue<Integer> res=new LinkedList<>();\\n      res.add(start);\\n      Set<Integer> set=new HashSet<>();\\n      int ans=0;\\n        while(!res.isEmpty()){\\n            int size=res.size();\\n            while(size-->0){\\n                int val=res.poll();\\n                if(map.get(val)!=null){\\n               for(Integer ele:map.get(val)){\\n                    if(!set.contains(ele)){\\n                        res.add(ele);\\n                        set.add(val);\\n                    }\\n                }\\n            }\\n        }\\n            ans++;\\n    }\\n        return ans-1;\\n    }\\n    public int amountOfTime(TreeNode root, int start) {\\n        Map<Integer,List<Integer>> map=new TreeMap<>();\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            while(size-->0){\\n                TreeNode ref=q.poll();\\n                int val=ref.val;\\n                if(ref.left!=null){\\n                    q.add(ref.left);\\n                  map.putIfAbsent(val,new ArrayList<>());\\n                  map.putIfAbsent(ref.left.val,new ArrayList<>());\\n                  map.get(ref.left.val).add(val);\\n                  map.get(val).add(ref.left.val);\\n                }\\n                if(ref.right!=null){\\n                    q.add(ref.right);\\n                   map.putIfAbsent(val,new ArrayList<>());\\n                   map.putIfAbsent(ref.right.val,new ArrayList<>());\\n                   map.get(val).add(ref.right.val);\\n                   map.get(ref.right.val).add(val);\\n                }\\n            }\\n        }\\n        return find_ans(map,start);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/*\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int find_ans(Map<Integer,List<Integer>> map,int start){\\n      Queue<Integer> res=new LinkedList<>();\\n      res.add(start);\\n      Set<Integer> set=new HashSet<>();\\n      int ans=0;\\n        while(!res.isEmpty()){\\n            int size=res.size();\\n            while(size-->0){\\n                int val=res.poll();\\n                if(map.get(val)!=null){\\n               for(Integer ele:map.get(val)){\\n                    if(!set.contains(ele)){\\n                        res.add(ele);\\n                        set.add(val);\\n                    }\\n                }\\n            }\\n        }\\n            ans++;\\n    }\\n        return ans-1;\\n    }\\n    public int amountOfTime(TreeNode root, int start) {\\n        Map<Integer,List<Integer>> map=new TreeMap<>();\\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int size=q.size();\\n            while(size-->0){\\n                TreeNode ref=q.poll();\\n                int val=ref.val;\\n                if(ref.left!=null){\\n                    q.add(ref.left);\\n                  map.putIfAbsent(val,new ArrayList<>());\\n                  map.putIfAbsent(ref.left.val,new ArrayList<>());\\n                  map.get(ref.left.val).add(val);\\n                  map.get(val).add(ref.left.val);\\n                }\\n                if(ref.right!=null){\\n                    q.add(ref.right);\\n                   map.putIfAbsent(val,new ArrayList<>());\\n                   map.putIfAbsent(ref.right.val,new ArrayList<>());\\n                   map.get(val).add(ref.right.val);\\n                   map.get(ref.right.val).add(val);\\n                }\\n            }\\n        }\\n        return find_ans(map,start);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3090150,
                "title": "easy-solution-beats-others-o-n-time-o-n-space-bfs",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>>graph;\\n    void buildGraph(TreeNode*root){\\n        queue<pair<TreeNode*,int>>q; //store node & its parent for root parent val=-1\\n        q.push({root,-1});\\n        while(!q.empty()){\\n            TreeNode*curr=q.front().first;\\n            int parent=q.front().second;\\n            q.pop();\\n            if(parent!=-1){\\n                graph[parent].push_back(curr->val);\\n                graph[curr->val].push_back(parent);\\n            }\\n            if(curr->left){\\n                q.push({curr->left,curr->val});\\n            }\\n            if(curr->right){\\n                q.push({curr->right,curr->val});\\n            }\\n        }\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        //idea is to create a graph for each node & then simple BFS traversal\\n        //we will increase time by 1 after visited all the adjacent of a perticular node\\n        buildGraph(root);\\n        int time=-1;\\n        queue<int>q;\\n        q.push(start);\\n        unordered_map<int,bool>visited;\\n        visited[start]=true;\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                int val=q.front();\\n                q.pop();\\n                for(auto x:graph[val]){\\n                    if(visited[x]==false){\\n                        visited[x]=true;\\n                        q.push(x);\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        return time;\\n        \\n    }\\n};\\n\\n\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int,vector<int>>graph;\\n    void buildGraph(TreeNode*root){\\n        queue<pair<TreeNode*,int>>q; //store node & its parent for root parent val=-1\\n        q.push({root,-1});\\n        while(!q.empty()){\\n            TreeNode*curr=q.front().first;\\n            int parent=q.front().second;\\n            q.pop();\\n            if(parent!=-1){\\n                graph[parent].push_back(curr->val);\\n                graph[curr->val].push_back(parent);\\n            }\\n            if(curr->left){\\n                q.push({curr->left,curr->val});\\n            }\\n            if(curr->right){\\n                q.push({curr->right,curr->val});\\n            }\\n        }\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        //idea is to create a graph for each node & then simple BFS traversal\\n        //we will increase time by 1 after visited all the adjacent of a perticular node\\n        buildGraph(root);\\n        int time=-1;\\n        queue<int>q;\\n        q.push(start);\\n        unordered_map<int,bool>visited;\\n        visited[start]=true;\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                int val=q.front();\\n                q.pop();\\n                for(auto x:graph[val]){\\n                    if(visited[x]==false){\\n                        visited[x]=true;\\n                        q.push(x);\\n                    }\\n                }\\n            }\\n            time++;\\n        }\\n        return time;\\n        \\n    }\\n};\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2553521,
                "title": "java-bfs-track-parent-amount-of-time-for-binary-tree-to-be-infected",
                "content": "Steps\\n1. Build a map to keep the track of parent nodes.\\n2. BFS\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    TreeNode infected;\\n    \\n    public int amountOfTime(TreeNode root, int start) {\\n        Map<TreeNode, TreeNode> hm = new HashMap<>();\\n        buildParent(root, null, hm, start);\\n        \\n        Queue<TreeNode> q = new ArrayDeque<>();\\n        q.offer(infected);\\n        \\n        Set<Integer> seen = new HashSet<>();\\n        \\n        int minutes = 0;\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            minutes++;\\n            \\n            for (int i = 0; i < size; i++) {\\n                TreeNode curr = q.poll();\\n                // System.out.println(curr.val);\\n                \\n                seen.add(curr.val);\\n                \\n                if (curr.left != null && !seen.contains(curr.left.val)) \\n                    q.offer(curr.left);\\n                \\n                if (curr.right != null && !seen.contains(curr.right.val))\\n                    q.offer(curr.right);\\n                \\n                if (hm.containsKey(curr) && hm.get(curr) != null && !seen.contains(hm.get(curr).val))\\n                    q.offer(hm.get(curr));\\n            }\\n        }\\n        \\n        return minutes - 1;\\n    }\\n    \\n    public void buildParent(TreeNode node, TreeNode parent, Map<TreeNode, TreeNode> hm, int start) {\\n        if (node == null)\\n            return;\\n    \\n        if (start == node.val) \\n            infected = node;\\n        \\n        hm.put(node, parent);\\n        \\n        if (node.left != null)\\n            buildParent(node.left, node, hm, start);\\n        \\n        if (node.right != null)\\n            buildParent(node.right, node, hm, start);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    TreeNode infected;\\n    \\n    public int amountOfTime(TreeNode root, int start) {\\n        Map<TreeNode, TreeNode> hm = new HashMap<>();\\n        buildParent(root, null, hm, start);\\n        \\n        Queue<TreeNode> q = new ArrayDeque<>();\\n        q.offer(infected);\\n        \\n        Set<Integer> seen = new HashSet<>();\\n        \\n        int minutes = 0;\\n        \\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            minutes++;\\n            \\n            for (int i = 0; i < size; i++) {\\n                TreeNode curr = q.poll();\\n                // System.out.println(curr.val);\\n                \\n                seen.add(curr.val);\\n                \\n                if (curr.left != null && !seen.contains(curr.left.val)) \\n                    q.offer(curr.left);\\n                \\n                if (curr.right != null && !seen.contains(curr.right.val))\\n                    q.offer(curr.right);\\n                \\n                if (hm.containsKey(curr) && hm.get(curr) != null && !seen.contains(hm.get(curr).val))\\n                    q.offer(hm.get(curr));\\n            }\\n        }\\n        \\n        return minutes - 1;\\n    }\\n    \\n    public void buildParent(TreeNode node, TreeNode parent, Map<TreeNode, TreeNode> hm, int start) {\\n        if (node == null)\\n            return;\\n    \\n        if (start == node.val) \\n            infected = node;\\n        \\n        hm.put(node, parent);\\n        \\n        if (node.left != null)\\n            buildParent(node.left, node, hm, start);\\n        \\n        if (node.right != null)\\n            buildParent(node.right, node, hm, start);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465785,
                "title": "c-iterative-build-undirected-graph-and-do-level-wise-bfs",
                "content": "I was consdering to use a ```vector<vector<int>>``` for the adjacency list, but either reserving the full size or resizing it felt a bit ugly, so I decided to stick it into a ```unordered_map<TreeNode*, array<TreeNode*, 3>>```. Using ```unordered_map<int, array<int, 3>>>``` would have worked to. The code goes a bit longer as we always need to look at ```TreeNode::val``` instead of just sticking the ```TreeNode*``` into the map. Let me know what you think.\\n\\n```\\n    int amountOfTime(TreeNode* root, int start) {\\n        // This check is actually not needed given the problem constraint, but\\n        // IMO it\\'s good habit to check a pointer before using it. My code crashed\\n        // more than once because of a missing check like this somewhere.\\n        if (!root) return 0;\\n        \\n        // Build adjacency list. We have at most 3 neighbors, so no need to\\n        // use a vector. Index 0 = parent, 1 = left, 2 right\\n        unordered_map<TreeNode*, array<TreeNode*, 3>> adj;\\n        \\n        stack<TreeNode*> st;\\n        st.push(root);\\n        \\n        TreeNode* start_node = nullptr;\\n        \\n        while (!empty(st)) {\\n            TreeNode* node = st.top(); st.pop();\\n            \\n            if (node->val == start) start_node = node;\\n            \\n            if (node->left) {\\n                adj[node][1] = node->left;\\n                adj[node->left][0] = node;\\n                st.push(node->left);\\n            }\\n            if (node->right) {\\n                adj[node][2] = node->right;\\n                adj[node->right][0] = node;\\n                st.push(node->right);\\n            }\\n        }\\n        \\n        assert(start_node);\\n        \\n        // BFS (level wise).\\n        int levels = -1;\\n        unordered_set<TreeNode*> visited;\\n        \\n        queue<TreeNode*> q;\\n        q.push(start_node);\\n        visited.insert(start_node);\\n        \\n        while (!empty(q)) {\\n            ++levels;\\n            int q_size = size(q);\\n            while (q_size--) {\\n                TreeNode* node = q.front(); q.pop();\\n                \\n                for (TreeNode* next : adj[node]) {\\n                    if (next && visited.count(next) == 0) {\\n                        q.push(next);\\n                        visited.insert(next);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return levels;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```vector<vector<int>>```\n```unordered_map<TreeNode*, array<TreeNode*, 3>>```\n```unordered_map<int, array<int, 3>>>```\n```TreeNode::val```\n```TreeNode*```\n```\\n    int amountOfTime(TreeNode* root, int start) {\\n        // This check is actually not needed given the problem constraint, but\\n        // IMO it\\'s good habit to check a pointer before using it. My code crashed\\n        // more than once because of a missing check like this somewhere.\\n        if (!root) return 0;\\n        \\n        // Build adjacency list. We have at most 3 neighbors, so no need to\\n        // use a vector. Index 0 = parent, 1 = left, 2 right\\n        unordered_map<TreeNode*, array<TreeNode*, 3>> adj;\\n        \\n        stack<TreeNode*> st;\\n        st.push(root);\\n        \\n        TreeNode* start_node = nullptr;\\n        \\n        while (!empty(st)) {\\n            TreeNode* node = st.top(); st.pop();\\n            \\n            if (node->val == start) start_node = node;\\n            \\n            if (node->left) {\\n                adj[node][1] = node->left;\\n                adj[node->left][0] = node;\\n                st.push(node->left);\\n            }\\n            if (node->right) {\\n                adj[node][2] = node->right;\\n                adj[node->right][0] = node;\\n                st.push(node->right);\\n            }\\n        }\\n        \\n        assert(start_node);\\n        \\n        // BFS (level wise).\\n        int levels = -1;\\n        unordered_set<TreeNode*> visited;\\n        \\n        queue<TreeNode*> q;\\n        q.push(start_node);\\n        visited.insert(start_node);\\n        \\n        while (!empty(q)) {\\n            ++levels;\\n            int q_size = size(q);\\n            while (q_size--) {\\n                TreeNode* node = q.front(); q.pop();\\n                \\n                for (TreeNode* next : adj[node]) {\\n                    if (next && visited.count(next) == 0) {\\n                        q.push(next);\\n                        visited.insert(next);\\n                    }\\n                }\\n            }\\n        }\\n        \\n        return levels;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2463819,
                "title": "c-bfs-graph-easy-solution-beginner-friendly",
                "content": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    void buildGraph(TreeNode *root, vector<vector<int>> &adj){\\n        if(root == NULL){\\n            return;\\n        }\\n        \\n        if(root->left){\\n            adj[root->val].push_back(root->left->val);\\n            adj[root->left->val].push_back(root->val);\\n        }\\n        if(root->right){\\n            adj[root->val].push_back(root->right->val);\\n            adj[root->right->val].push_back(root->val);\\n        }\\n        \\n        buildGraph(root->left,adj);\\n        buildGraph(root->right,adj);\\n    }\\n    \\n    void bfs(int start, vector<vector<int>> &adj,vector<bool> &vis)\\n    {\\n        queue<int> q;\\n        q.push(start);\\n        \\n        while(!q.empty()){\\n            int k = q.size();\\n            \\n            while(k--){\\n                int u = q.front();\\n                q.pop();\\n                vis[u] = 1;\\n                for(int i=0;i<adj[u].size();i++)\\n                {\\n                    if(!vis[adj[u][i]]){\\n                        q.push(adj[u][i]);\\n                    }\\n                }\\n                \\n            }\\n            ans++;\\n        }\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        vector<vector<int>> adj(100001);\\n        vector<bool> vis(100001);\\n        \\n        buildGraph(root,adj);\\n        ans = 0;\\n        bfs(start,adj,vis);\\n        return ans-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans;\\n    void buildGraph(TreeNode *root, vector<vector<int>> &adj){\\n        if(root == NULL){\\n            return;\\n        }\\n        \\n        if(root->left){\\n            adj[root->val].push_back(root->left->val);\\n            adj[root->left->val].push_back(root->val);\\n        }\\n        if(root->right){\\n            adj[root->val].push_back(root->right->val);\\n            adj[root->right->val].push_back(root->val);\\n        }\\n        \\n        buildGraph(root->left,adj);\\n        buildGraph(root->right,adj);\\n    }\\n    \\n    void bfs(int start, vector<vector<int>> &adj,vector<bool> &vis)\\n    {\\n        queue<int> q;\\n        q.push(start);\\n        \\n        while(!q.empty()){\\n            int k = q.size();\\n            \\n            while(k--){\\n                int u = q.front();\\n                q.pop();\\n                vis[u] = 1;\\n                for(int i=0;i<adj[u].size();i++)\\n                {\\n                    if(!vis[adj[u][i]]){\\n                        q.push(adj[u][i]);\\n                    }\\n                }\\n                \\n            }\\n            ans++;\\n        }\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        vector<vector<int>> adj(100001);\\n        vector<bool> vis(100001);\\n        \\n        buildGraph(root,adj);\\n        ans = 0;\\n        bfs(start,adj,vis);\\n        return ans-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457344,
                "title": "faster-easy-to-understand-c-code",
                "content": "* ***Using BFS***\\n\\n* ***Time Complexity :- O(N)***\\n\\n* ***Space Complexity :- O(N)***\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    // mp will store parent of every node\\n    \\n    unordered_map<TreeNode*, TreeNode*> mp;\\n    \\n    TreeNode* initial;\\n    \\n    // function for find parent for every node\\n    \\n    void dfs(TreeNode* root, TreeNode* parent, int start)\\n    {\\n        // base case\\n        \\n        if(root == NULL)\\n            return;\\n        \\n        // if start is found\\n        \\n        if(root -> val == start)\\n        {\\n            initial = root;\\n        }\\n        \\n        // store the parent of root into map\\n        \\n        mp[root] = parent;\\n        \\n        // call for left subtree\\n        \\n        dfs(root -> left, root, start);\\n        \\n        // call for right subtree\\n        \\n        dfs(root -> right, root, start);\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n        \\n        // call dfs for find parent of every node\\n        \\n        dfs(root, NULL, start);\\n        \\n        // apply bfs to get time to infect binary tree\\n        \\n        queue<TreeNode*> q;\\n        \\n        // push the initial node into queue\\n        \\n        q.push(initial);\\n        \\n        int minutes = 0;\\n        \\n        // declare a vis set\\n        \\n        unordered_set<TreeNode*> vis;\\n        \\n        // mark initial node visited\\n        \\n        vis.insert(initial);\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            \\n            for(int i = 0; i < size; i++)\\n            {\\n                auto curr = q.front();\\n                \\n                q.pop();\\n                \\n                // if adjacent node is not visited the push into queue\\n                \\n                if(mp[curr] != NULL && vis.count(mp[curr]) == 0)\\n                {\\n                    // push the parent node in queue\\n                    \\n                    q.push(mp[curr]);\\n                    \\n                    // mark visited\\n                    \\n                    vis.insert(mp[curr]);\\n                }\\n                \\n                // push the left child into queue and mark visited\\n                \\n                if(curr -> left && vis.count(curr -> left) == 0)\\n                {\\n                    q.push(curr -> left);\\n                    \\n                    vis.insert(curr -> left);\\n                }\\n                \\n                // push the right child into queue and mark visited\\n                \\n                if(curr -> right && vis.count(curr -> right) == 0)\\n                {\\n                    q.push(curr -> right);\\n                    \\n                    vis.insert(curr -> right);\\n                }\\n            }\\n            \\n            // increment the time\\n            \\n            minutes++;\\n        }\\n        \\n        return minutes - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // mp will store parent of every node\\n    \\n    unordered_map<TreeNode*, TreeNode*> mp;\\n    \\n    TreeNode* initial;\\n    \\n    // function for find parent for every node\\n    \\n    void dfs(TreeNode* root, TreeNode* parent, int start)\\n    {\\n        // base case\\n        \\n        if(root == NULL)\\n            return;\\n        \\n        // if start is found\\n        \\n        if(root -> val == start)\\n        {\\n            initial = root;\\n        }\\n        \\n        // store the parent of root into map\\n        \\n        mp[root] = parent;\\n        \\n        // call for left subtree\\n        \\n        dfs(root -> left, root, start);\\n        \\n        // call for right subtree\\n        \\n        dfs(root -> right, root, start);\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n        \\n        // call dfs for find parent of every node\\n        \\n        dfs(root, NULL, start);\\n        \\n        // apply bfs to get time to infect binary tree\\n        \\n        queue<TreeNode*> q;\\n        \\n        // push the initial node into queue\\n        \\n        q.push(initial);\\n        \\n        int minutes = 0;\\n        \\n        // declare a vis set\\n        \\n        unordered_set<TreeNode*> vis;\\n        \\n        // mark initial node visited\\n        \\n        vis.insert(initial);\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            \\n            for(int i = 0; i < size; i++)\\n            {\\n                auto curr = q.front();\\n                \\n                q.pop();\\n                \\n                // if adjacent node is not visited the push into queue\\n                \\n                if(mp[curr] != NULL && vis.count(mp[curr]) == 0)\\n                {\\n                    // push the parent node in queue\\n                    \\n                    q.push(mp[curr]);\\n                    \\n                    // mark visited\\n                    \\n                    vis.insert(mp[curr]);\\n                }\\n                \\n                // push the left child into queue and mark visited\\n                \\n                if(curr -> left && vis.count(curr -> left) == 0)\\n                {\\n                    q.push(curr -> left);\\n                    \\n                    vis.insert(curr -> left);\\n                }\\n                \\n                // push the right child into queue and mark visited\\n                \\n                if(curr -> right && vis.count(curr -> right) == 0)\\n                {\\n                    q.push(curr -> right);\\n                    \\n                    vis.insert(curr -> right);\\n                }\\n            }\\n            \\n            // increment the time\\n            \\n            minutes++;\\n        }\\n        \\n        return minutes - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456595,
                "title": "bfs-c-simple",
                "content": "```\\nmap <TreeNode*, TreeNode*> par;\\n\\n// function to mark parent of each node\\nvoid markpar(TreeNode* nn, TreeNode*pp) {\\n    par[nn] = pp;\\n\\n    if (nn->left != NULL) {\\n        markpar(nn->left, nn);\\n    }\\n\\n    if (nn->right != NULL) {\\n        markpar(nn->right, nn);\\n    }\\n}\\n\\n// function to find the node with value start\\nTreeNode *find(int &B, TreeNode* root) {\\n    if (root == NULL) {\\n        return NULL;\\n    }\\n\\n    if (root->val == B) {\\n        return root;\\n    }\\n\\n    TreeNode *p = find(B, root->left);\\n    TreeNode *q = find(B, root->right);\\n\\n    if (p == NULL && q == NULL) {\\n        return NULL;\\n    }\\n    else {\\n        if (p) {\\n            return p;\\n        }\\n        else\\n            return q;\\n    }\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        par.clear();\\n        \\n        // function call to find node with start as value\\n        TreeNode *target = find(start, root);\\n        \\n        // function call to mark parent of each node\\n        markpar(root, root);\\n        \\n        // initializing queue for BFS\\n        queue <TreeNode*> q;\\n        q.push(target);\\n        int time = 0;\\n        vector <int> vis(100005, -1);\\n        vis[target->val] = time;\\n        \\n        while (!q.empty()) {\\n        time++;\\n\\n        int n = q.size();\\n        while (n--) {\\n            TreeNode* curr = q.front();\\n            q.pop();\\n            // checking left child of current node\\n            if (curr->left != NULL && vis[curr->left->val] == -1) {\\n                vis[curr->left->val] = time;\\n                q.push(curr->left);\\n            }\\n            \\n            // checking right child of current node\\n            if (curr->right != NULL && vis[curr->right->val] == -1) {\\n                vis[curr->right->val] = time;\\n                q.push(curr->right);\\n            }\\n            \\n            // checking parent of current node\\n            if (vis[par[curr]->val] == -1) {\\n                vis[par[curr]->val] = time;\\n                q.push(par[curr]);\\n            }\\n         }\\n      }\\n        \\n        int mx=INT_MIN;\\n        \\n        // node with max value of vis will be our answer\\n        for(int i=0;i<100005;i++){\\n            mx=max(mx,vis[i]);\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nmap <TreeNode*, TreeNode*> par;\\n\\n// function to mark parent of each node\\nvoid markpar(TreeNode* nn, TreeNode*pp) {\\n    par[nn] = pp;\\n\\n    if (nn->left != NULL) {\\n        markpar(nn->left, nn);\\n    }\\n\\n    if (nn->right != NULL) {\\n        markpar(nn->right, nn);\\n    }\\n}\\n\\n// function to find the node with value start\\nTreeNode *find(int &B, TreeNode* root) {\\n    if (root == NULL) {\\n        return NULL;\\n    }\\n\\n    if (root->val == B) {\\n        return root;\\n    }\\n\\n    TreeNode *p = find(B, root->left);\\n    TreeNode *q = find(B, root->right);\\n\\n    if (p == NULL && q == NULL) {\\n        return NULL;\\n    }\\n    else {\\n        if (p) {\\n            return p;\\n        }\\n        else\\n            return q;\\n    }\\n}\\n\\n\\nclass Solution {\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        par.clear();\\n        \\n        // function call to find node with start as value\\n        TreeNode *target = find(start, root);\\n        \\n        // function call to mark parent of each node\\n        markpar(root, root);\\n        \\n        // initializing queue for BFS\\n        queue <TreeNode*> q;\\n        q.push(target);\\n        int time = 0;\\n        vector <int> vis(100005, -1);\\n        vis[target->val] = time;\\n        \\n        while (!q.empty()) {\\n        time++;\\n\\n        int n = q.size();\\n        while (n--) {\\n            TreeNode* curr = q.front();\\n            q.pop();\\n            // checking left child of current node\\n            if (curr->left != NULL && vis[curr->left->val] == -1) {\\n                vis[curr->left->val] = time;\\n                q.push(curr->left);\\n            }\\n            \\n            // checking right child of current node\\n            if (curr->right != NULL && vis[curr->right->val] == -1) {\\n                vis[curr->right->val] = time;\\n                q.push(curr->right);\\n            }\\n            \\n            // checking parent of current node\\n            if (vis[par[curr]->val] == -1) {\\n                vis[par[curr]->val] = time;\\n                q.push(par[curr]);\\n            }\\n         }\\n      }\\n        \\n        int mx=INT_MIN;\\n        \\n        // node with max value of vis will be our answer\\n        for(int i=0;i<100005;i++){\\n            mx=max(mx,vis[i]);\\n        }\\n        \\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3932271,
                "title": "intuitive-approach-to-solve-amount-of-time-for-binary-tree-to-be-infected-in-o-n-time-and-space",
                "content": "# Intuition\\nBy looking at the problem we can see that node are getting affected parallelly from this we get the idea of using bfs.\\n\\n# Approach\\nA node can affect it\\'s left child it\\'s right child and it\\'s parent. We can easily go to left and right child while applying bfs but we have no way to go to its parent pointer so we create a mapping between child and parent pointer with the help of map.\\n\\nIn findTime funcition we keep track of the nodes which are getting infected with the heap of visited map. A catch here is to keep a flag which tells us about if there is a node infected by a node. After each level we increment minT is there is any node infected else we move on. Try do do a dry run this will become more clear.\\n\\n\\n# Complexity\\n- Time complexity: O(N)\\n\\n- Space complexity: O(N)\\n \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findTime( map<TreeNode*, TreeNode*>& mp,TreeNode* target){\\n        queue<TreeNode*> q;\\n        q.push(target);\\n        map<TreeNode*,int> vis;\\n        vis[target]=1;\\n        int minT=0;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            int fl=0;\\n            for(int i=0;i<sz;i++){\\n                auto node=q.front();\\n                q.pop();\\n                if(node->left && !vis[node->left]){\\n                    fl=1;\\n                    vis[node->left]=1;\\n                    q.push(node->left);\\n                }\\n                if(node->right && !vis[node->right]){\\n                    fl=1;\\n                    vis[node->right]=1;\\n                    q.push(node->right);\\n                }\\n                if(mp[node] && !vis[mp[node]]){\\n                    fl=1;\\n                    vis[mp[node]]=1;\\n                    q.push(mp[node]);\\n                }\\n            }\\n            if(fl) minT++;\\n        }\\n        return minT;\\n    }\\n    TreeNode* bfsMapParents(TreeNode* root, map<TreeNode*, TreeNode*>& mp,int start){\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        TreeNode* res;\\n        while(!q.empty()){\\n            auto node=q.front();\\n            if(node->val==start) res=node;\\n            q.pop();\\n            if(node->left){\\n                mp[node->left]=node;\\n                q.push(node->left);\\n            }\\n            if(node->right){\\n                mp[node->right]=node;\\n                q.push(node->right);\\n            }\\n        }\\n        return res;\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        map<TreeNode*, TreeNode*> mp;\\n        TreeNode* target=bfsMapParents(root,mp,start);\\n        int minT=findTime(mp,target);\\n        return minT;\\n    }\\n};\\n```\\n# **Please upvote if you got a better understanding of the problem.**\\n\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int findTime( map<TreeNode*, TreeNode*>& mp,TreeNode* target){\\n        queue<TreeNode*> q;\\n        q.push(target);\\n        map<TreeNode*,int> vis;\\n        vis[target]=1;\\n        int minT=0;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            int fl=0;\\n            for(int i=0;i<sz;i++){\\n                auto node=q.front();\\n                q.pop();\\n                if(node->left && !vis[node->left]){\\n                    fl=1;\\n                    vis[node->left]=1;\\n                    q.push(node->left);\\n                }\\n                if(node->right && !vis[node->right]){\\n                    fl=1;\\n                    vis[node->right]=1;\\n                    q.push(node->right);\\n                }\\n                if(mp[node] && !vis[mp[node]]){\\n                    fl=1;\\n                    vis[mp[node]]=1;\\n                    q.push(mp[node]);\\n                }\\n            }\\n            if(fl) minT++;\\n        }\\n        return minT;\\n    }\\n    TreeNode* bfsMapParents(TreeNode* root, map<TreeNode*, TreeNode*>& mp,int start){\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        TreeNode* res;\\n        while(!q.empty()){\\n            auto node=q.front();\\n            if(node->val==start) res=node;\\n            q.pop();\\n            if(node->left){\\n                mp[node->left]=node;\\n                q.push(node->left);\\n            }\\n            if(node->right){\\n                mp[node->right]=node;\\n                q.push(node->right);\\n            }\\n        }\\n        return res;\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        map<TreeNode*, TreeNode*> mp;\\n        TreeNode* target=bfsMapParents(root,mp,start);\\n        int minT=findTime(mp,target);\\n        return minT;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3789957,
                "title": "easy-bfs-solution-using-unordered-map-beats-more-than-90",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* startp;\\n    void helper(TreeNode* root,unordered_map<int,TreeNode*>& mp,int start)\\n    {\\n        if(!root) return;\\n        if(root->val==start)\\n        {\\n            startp=root;\\n        } \\n        if(root->left)\\n        {\\n            mp[root->left->val]=root;\\n            helper(root->left,mp,start);\\n        }\\n        if(root->right)\\n        {\\n            mp[root->right->val]=root;\\n            helper(root->right,mp,start);\\n        }\\n    }    \\n\\n\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<int,TreeNode*> mp;\\n        \\n        helper(root,mp,start);\\n\\n        queue<TreeNode*> q;\\n        q.push(startp);\\n        int time=0;\\n        vector<bool> vis(1e5+1);\\n        \\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                auto a=q.front();\\n                q.pop();\\n                vis[a->val]=true;\\n\\n                if(a->left && !vis[a->left->val])\\n                {\\n                    q.push(a->left);\\n                }\\n                if(a->right && !vis[a->right->val])\\n                {\\n                    q.push(a->right);\\n                }\\n                if(mp[a->val] && !vis[mp[a->val]->val])\\n                {   \\n                    q.push(mp[a->val]);\\n                }\\n            }\\n            time++;\\n        }\\n        return time-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* startp;\\n    void helper(TreeNode* root,unordered_map<int,TreeNode*>& mp,int start)\\n    {\\n        if(!root) return;\\n        if(root->val==start)\\n        {\\n            startp=root;\\n        } \\n        if(root->left)\\n        {\\n            mp[root->left->val]=root;\\n            helper(root->left,mp,start);\\n        }\\n        if(root->right)\\n        {\\n            mp[root->right->val]=root;\\n            helper(root->right,mp,start);\\n        }\\n    }    \\n\\n\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<int,TreeNode*> mp;\\n        \\n        helper(root,mp,start);\\n\\n        queue<TreeNode*> q;\\n        q.push(startp);\\n        int time=0;\\n        vector<bool> vis(1e5+1);\\n        \\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                auto a=q.front();\\n                q.pop();\\n                vis[a->val]=true;\\n\\n                if(a->left && !vis[a->left->val])\\n                {\\n                    q.push(a->left);\\n                }\\n                if(a->right && !vis[a->right->val])\\n                {\\n                    q.push(a->right);\\n                }\\n                if(mp[a->val] && !vis[mp[a->val]->val])\\n                {   \\n                    q.push(mp[a->val]);\\n                }\\n            }\\n            time++;\\n        }\\n        return time-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3752168,
                "title": "c-bfs-fully-explained-easiest-explanation-tc-o-n",
                "content": "# Intuition\\nEvery second a node will infect all its neighbours. The next second, they will infect their neighbours. Hence we have to spread the virus in a breadth-fashion. So we have to consider the use of a simple BFS approach.\\n\\n# Approach\\nTo solve this question using a BFS approach, firstly we would need to convert the tree into a graph, as a node\\'s child in a binary tree doesn\\'t have a pointer to its parent. We need a two way connection here. Smart choice would be to convert the tree, into an adjacency list.\\nAfter doing that, simply do a BFS traversal. Key thing to note in these type of problems is that:-\\n- To get only the neighbours of the current node; before starting the traversal, take out the size of the queue. \\n### The current size of the queue will represent the number of neighbouring nodes of that node.\\n- Rest is easy, then do your traditional BFS. See the code for better understanding.\\n\\n# Complexity\\n- ## Time complexity:\\nThe time complexity of the solution would be $$O(N)$$. As we are traversing the whole binary tree at max, twice.\\n\\n- ## Space complexity:\\nSpace complexity would also be $$O(N)$$. As we are using extra space in form of Queue and representing the tree as graph.\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    vector<int> adj[100005];\\n    void graph(TreeNode* root){\\n        if(!root or (root->left == NULL and root->right == NULL)){\\n            return;\\n        }\\n        if(root->left != NULL){\\n            adj[root->val].push_back(root->left->val);\\n            adj[root->left->val].push_back(root->val);\\n        }\\n        if(root->right != NULL){\\n            adj[root->val].push_back(root->right->val);\\n            adj[root->right->val].push_back(root->val);\\n        }\\n        graph(root->left);\\n        graph(root->right);\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        graph(root);\\n        vector<int> vis(100005, 0);\\n        queue<int> q;\\n        q.push(start);\\n        int ctr = -1;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                int curr = q.front();\\n                q.pop();\\n                vis[curr] = true;\\n                for(auto i : adj[curr]){\\n                    if(!vis[i]){\\n                        q.push(i);\\n                    }\\n                }\\n            }\\n            ctr++;\\n        }\\n        return ctr;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> adj[100005];\\n    void graph(TreeNode* root){\\n        if(!root or (root->left == NULL and root->right == NULL)){\\n            return;\\n        }\\n        if(root->left != NULL){\\n            adj[root->val].push_back(root->left->val);\\n            adj[root->left->val].push_back(root->val);\\n        }\\n        if(root->right != NULL){\\n            adj[root->val].push_back(root->right->val);\\n            adj[root->right->val].push_back(root->val);\\n        }\\n        graph(root->left);\\n        graph(root->right);\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        graph(root);\\n        vector<int> vis(100005, 0);\\n        queue<int> q;\\n        q.push(start);\\n        int ctr = -1;\\n        while(!q.empty()){\\n            int sz = q.size();\\n            while(sz--){\\n                int curr = q.front();\\n                q.pop();\\n                vis[curr] = true;\\n                for(auto i : adj[curr]){\\n                    if(!vis[i]){\\n                        q.push(i);\\n                    }\\n                }\\n            }\\n            ctr++;\\n        }\\n        return ctr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3748774,
                "title": "c-dfs-simple",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<TreeNode*, TreeNode*> parent;\\n        unordered_set<TreeNode*> infected;\\n        int result = 0;\\n        TreeNode* target = nullptr;\\n        findParent(root, parent);\\n        findNode(root, start, target);\\n        dfs(target, parent, infected, 0, result);\\n        return result;\\n    }\\n\\nprivate:\\n    void findParent(TreeNode* root, unordered_map<TreeNode*, TreeNode*>& parent) {\\n        if (!root) return;\\n        if (root->left) {\\n            parent[root->left] = root;\\n            findParent(root->left, parent);\\n        }\\n        if (root->right) {\\n            parent[root->right] = root;\\n            findParent(root->right, parent);\\n        }\\n    }\\n\\n    void findNode(TreeNode* root, int& start, TreeNode*& target) {\\n        if (!root) return;\\n        if (root->val == start) {\\n            target = root;\\n            return;\\n        }\\n        findNode(root->left, start, target);\\n        findNode(root->right, start, target);\\n    }\\n\\n    void dfs(TreeNode* root, unordered_map<TreeNode*, TreeNode*>& parent,\\n                unordered_set<TreeNode*>& infected, int minutes, int& result) \\n    {\\n        if (!root) {\\n            result = max(result, minutes - 1);\\n            return;\\n        }\\n        if (infected.count(root) > 0) return;\\n        infected.insert(root);\\n        dfs(root->left, parent, infected, minutes + 1, result);\\n        dfs(root->right, parent, infected, minutes + 1, result);\\n        dfs(parent[root], parent, infected, minutes + 1, result);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<TreeNode*, TreeNode*> parent;\\n        unordered_set<TreeNode*> infected;\\n        int result = 0;\\n        TreeNode* target = nullptr;\\n        findParent(root, parent);\\n        findNode(root, start, target);\\n        dfs(target, parent, infected, 0, result);\\n        return result;\\n    }\\n\\nprivate:\\n    void findParent(TreeNode* root, unordered_map<TreeNode*, TreeNode*>& parent) {\\n        if (!root) return;\\n        if (root->left) {\\n            parent[root->left] = root;\\n            findParent(root->left, parent);\\n        }\\n        if (root->right) {\\n            parent[root->right] = root;\\n            findParent(root->right, parent);\\n        }\\n    }\\n\\n    void findNode(TreeNode* root, int& start, TreeNode*& target) {\\n        if (!root) return;\\n        if (root->val == start) {\\n            target = root;\\n            return;\\n        }\\n        findNode(root->left, start, target);\\n        findNode(root->right, start, target);\\n    }\\n\\n    void dfs(TreeNode* root, unordered_map<TreeNode*, TreeNode*>& parent,\\n                unordered_set<TreeNode*>& infected, int minutes, int& result) \\n    {\\n        if (!root) {\\n            result = max(result, minutes - 1);\\n            return;\\n        }\\n        if (infected.count(root) > 0) return;\\n        infected.insert(root);\\n        dfs(root->left, parent, infected, minutes + 1, result);\\n        dfs(root->right, parent, infected, minutes + 1, result);\\n        dfs(parent[root], parent, infected, minutes + 1, result);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3369675,
                "title": "c-bfs",
                "content": "# Complexity\\n- Time complexity: $$O(nlogn)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(n)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        // mark the parent pointera and target node;\\n        map<TreeNode*,TreeNode*> par;\\n        map<TreeNode*,bool> vis;\\n        TreeNode* curr= root;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int time=0;\\n        while (!q.empty()){\\n            int sz=q.size();\\n            for (int i=0; i<sz; i++){\\n                TreeNode* node= q.front();\\n                vis[node]=0;\\n                if (node->val == start)curr= node;\\n                q.pop();\\n                if(node->left){\\n                    q.push(node->left);\\n                    par[node->left]= node;\\n                }\\n                if (node->right){\\n                    q.push(node->right);\\n                    par[node->right]= node;\\n                }\\n            }\\n        }\\n        // burning the tree;\\n        q.push(curr);\\n        vis[curr]=1;\\n        while (!q.empty()){\\n            int sz=q.size();\\n            bool burnt=0;\\n            for (int i=0; i<sz; i++){\\n                TreeNode* node= q.front();\\n                q.pop();\\n                if (par[node] && !vis[par[node]]){\\n                    burnt=1;\\n                    q.push(par[node]);\\n                    vis[par[node]]=1;\\n                }\\n                if (node->left && !vis[node->left]){\\n                    burnt=1;\\n                    q.push(node->left);\\n                    vis[node->left]=1;\\n                }\\n                if (node->right && !vis[node->right]){\\n                    burnt=1;\\n                    q.push(node->right);\\n                    vis[node->right]=1;\\n                }\\n            }\\n            if (burnt)time++;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        // mark the parent pointera and target node;\\n        map<TreeNode*,TreeNode*> par;\\n        map<TreeNode*,bool> vis;\\n        TreeNode* curr= root;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        int time=0;\\n        while (!q.empty()){\\n            int sz=q.size();\\n            for (int i=0; i<sz; i++){\\n                TreeNode* node= q.front();\\n                vis[node]=0;\\n                if (node->val == start)curr= node;\\n                q.pop();\\n                if(node->left){\\n                    q.push(node->left);\\n                    par[node->left]= node;\\n                }\\n                if (node->right){\\n                    q.push(node->right);\\n                    par[node->right]= node;\\n                }\\n            }\\n        }\\n        // burning the tree;\\n        q.push(curr);\\n        vis[curr]=1;\\n        while (!q.empty()){\\n            int sz=q.size();\\n            bool burnt=0;\\n            for (int i=0; i<sz; i++){\\n                TreeNode* node= q.front();\\n                q.pop();\\n                if (par[node] && !vis[par[node]]){\\n                    burnt=1;\\n                    q.push(par[node]);\\n                    vis[par[node]]=1;\\n                }\\n                if (node->left && !vis[node->left]){\\n                    burnt=1;\\n                    q.push(node->left);\\n                    vis[node->left]=1;\\n                }\\n                if (node->right && !vis[node->right]){\\n                    burnt=1;\\n                    q.push(node->right);\\n                    vis[node->right]=1;\\n                }\\n            }\\n            if (burnt)time++;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3324595,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n     void abc(unordered_map<TreeNode*,TreeNode*>& parent,TreeNode* root,int& count){\\n         queue<TreeNode*> q;\\n         q.push(root);\\n         while(!q.empty()){\\n                 TreeNode* b=q.front();\\n                 q.pop();\\n             count++;\\n                 if(b->left){\\n                     q.push(b->left);\\n                     parent[b->left]=b;\\n                 }\\n                 if(b->right){\\n                     q.push(b->right);\\n                     parent[b->right]=b;\\n             }\\n         }\\n         return;\\n     }\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<TreeNode*,TreeNode*> parent;\\n        int count=0;\\n        abc(parent,root,count);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        TreeNode* link;\\n        while(!q.empty()){\\n            TreeNode* a=q.front();\\n            q.pop();\\n            if(a->val==start){\\n                link=a;\\n                break;\\n            }\\n            if(a->left) q.push(a->left);\\n            if(a->right) q.push(a->right);\\n        }\\n        queue<TreeNode*> q1;\\n        q1.push(link);\\n        unordered_map<TreeNode*,bool> vis;\\n        vis[link]=true;\\n        int ans=0;\\n        if(count==vis.size()) return ans;\\n        while(!q1.empty()){\\n            // if(count==k) break;\\n            int z=q1.size();\\n            while(z--){\\n                TreeNode* curr=q1.front();\\n                q1.pop();\\n                if(curr->left && vis[curr->left]==false){\\n                    q1.push(curr->left);\\n                    vis[curr->left]=true;\\n                }\\n                if(curr->right && vis[curr->right]==false){\\n                    q1.push(curr->right);\\n                    vis[curr->right]=true;\\n                }\\n                // Node* g=parent[curr];\\n                if(parent[curr] && vis[parent[curr]]==false){\\n                    q1.push(parent[curr]);\\n                    vis[parent[curr]]=true;\\n                }\\n            }\\n            ans++;\\n            if(count==vis.size()) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n     void abc(unordered_map<TreeNode*,TreeNode*>& parent,TreeNode* root,int& count){\\n         queue<TreeNode*> q;\\n         q.push(root);\\n         while(!q.empty()){\\n                 TreeNode* b=q.front();\\n                 q.pop();\\n             count++;\\n                 if(b->left){\\n                     q.push(b->left);\\n                     parent[b->left]=b;\\n                 }\\n                 if(b->right){\\n                     q.push(b->right);\\n                     parent[b->right]=b;\\n             }\\n         }\\n         return;\\n     }\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<TreeNode*,TreeNode*> parent;\\n        int count=0;\\n        abc(parent,root,count);\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        TreeNode* link;\\n        while(!q.empty()){\\n            TreeNode* a=q.front();\\n            q.pop();\\n            if(a->val==start){\\n                link=a;\\n                break;\\n            }\\n            if(a->left) q.push(a->left);\\n            if(a->right) q.push(a->right);\\n        }\\n        queue<TreeNode*> q1;\\n        q1.push(link);\\n        unordered_map<TreeNode*,bool> vis;\\n        vis[link]=true;\\n        int ans=0;\\n        if(count==vis.size()) return ans;\\n        while(!q1.empty()){\\n            // if(count==k) break;\\n            int z=q1.size();\\n            while(z--){\\n                TreeNode* curr=q1.front();\\n                q1.pop();\\n                if(curr->left && vis[curr->left]==false){\\n                    q1.push(curr->left);\\n                    vis[curr->left]=true;\\n                }\\n                if(curr->right && vis[curr->right]==false){\\n                    q1.push(curr->right);\\n                    vis[curr->right]=true;\\n                }\\n                // Node* g=parent[curr];\\n                if(parent[curr] && vis[parent[curr]]==false){\\n                    q1.push(parent[curr]);\\n                    vis[parent[curr]]=true;\\n                }\\n            }\\n            ans++;\\n            if(count==vis.size()) break;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3049515,
                "title": "javascript-dfs-bfs",
                "content": "\\n# Code\\n\\n# Breadth-First-Search\\n```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} start\\n * @return {number}\\n */\\nvar amountOfTime = function(root, start) {\\n    // Create an adjacency list for the tree\\n    const adjList =  createAdjacentList(root);\\n\\n    // If the adjacency list is empty, return 0\\n    if(adjList.size === 0) return 0;\\n\\n    // Perform a breadth-first search on the adjacency list\\n    const totalTime = bfs(adjList, start);\\n\\n    return totalTime;\\n};\\n\\n// TC O(n) SP = O(n)\\nconst bfs = (adjList, start) => {\\n    // Set to keep track of visited nodes\\n    const visited = new Set();\\n    visited.add(start);\\n\\n    // Queue to keep track of nodes to visit\\n    const queue = new Queue();\\n    queue.enqueue([start, 0]);\\n    \\n    // Variable to keep track of the maximum time\\n    let maxTime = 0;\\n    while(!queue.isEmpty()){\\n        // Dequeue the next node to visit\\n        const [node, time] = queue.dequeue();\\n        maxTime = Math.max(time, maxTime);\\n\\n        // Get the adjacent nodes for the current node\\n        const val = adjList.get(node);\\n        \\n        // Enqueue the adjacent nodes if they have not been visited\\n        for(const child of val){\\n            if(!visited.has(child)){\\n                queue.enqueue([child, time + 1]);\\n                visited.add(child);\\n            }\\n        } \\n    }\\n    return maxTime;\\n}\\n\\n// TC O(n) SP = O(m+n) m =number of nodes, n of edges\\nconst createAdjacentList = (root) => {\\n    // Initialize an adjacency list\\n    const adjList = new Map();\\n\\n    // Check if the root node is null\\n    if (!root) return adjList;\\n\\n    // Queue to keep track of nodes to visit\\n    const queue = [root];\\n\\n    while(queue.length) {\\n        const node = queue.shift();\\n\\n        // Check if the node has left and right children\\n        if (node.left) {\\n            // Add the node and its left child to the adjacency list\\n            adjList.set(node.val, [...(adjList.get(node.val) || []), node.left.val]);\\n            adjList.set(node.left.val, [...(adjList.get(node.left.val) || []), node.val]);\\n            queue.push(node.left);\\n        }\\n        if (node.right) {\\n            // Add the node and its right child to the adjacency list\\n            adjList.set(node.val, [...(adjList.get(node.val) || []), node.right.val]);\\n            adjList.set(node.right.val, [...(adjList.get(node.right.val) || []), node.val]);\\n            queue.push(node.right);\\n        }\\n    }\\n    return adjList;\\n}\\n\\n```\\n\\n# Depth-First-Search\\n```\\n\\n\\nconst amountOfTime = (root, start) => {\\n\\n    const traverse = (root, start) => {\\n        if (!root) {\\n            return 0;\\n        }\\n\\n        let left = traverse(root.left, start);\\n        let right = traverse(root.right, start);\\n\\n        if (root.val === start) {\\n            amount = Math.max(left, right);\\n            return -1;\\n        } else if (left >= 0 && right >= 0) {\\n            return Math.max(left, right) + 1;\\n        } else {\\n            amount = Math.max(amount, Math.abs(left - right));\\n            return Math.min(left, right) - 1;\\n        }\\n    }\\n    traverse(root, start)\\n    \\n    return amount;\\n}\\n\\n```\\n\\n\\n\\n\\n",
                "solutionTags": [
                    "JavaScript",
                    "TypeScript",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @param {number} start\\n * @return {number}\\n */\\nvar amountOfTime = function(root, start) {\\n    // Create an adjacency list for the tree\\n    const adjList =  createAdjacentList(root);\\n\\n    // If the adjacency list is empty, return 0\\n    if(adjList.size === 0) return 0;\\n\\n    // Perform a breadth-first search on the adjacency list\\n    const totalTime = bfs(adjList, start);\\n\\n    return totalTime;\\n};\\n\\n// TC O(n) SP = O(n)\\nconst bfs = (adjList, start) => {\\n    // Set to keep track of visited nodes\\n    const visited = new Set();\\n    visited.add(start);\\n\\n    // Queue to keep track of nodes to visit\\n    const queue = new Queue();\\n    queue.enqueue([start, 0]);\\n    \\n    // Variable to keep track of the maximum time\\n    let maxTime = 0;\\n    while(!queue.isEmpty()){\\n        // Dequeue the next node to visit\\n        const [node, time] = queue.dequeue();\\n        maxTime = Math.max(time, maxTime);\\n\\n        // Get the adjacent nodes for the current node\\n        const val = adjList.get(node);\\n        \\n        // Enqueue the adjacent nodes if they have not been visited\\n        for(const child of val){\\n            if(!visited.has(child)){\\n                queue.enqueue([child, time + 1]);\\n                visited.add(child);\\n            }\\n        } \\n    }\\n    return maxTime;\\n}\\n\\n// TC O(n) SP = O(m+n) m =number of nodes, n of edges\\nconst createAdjacentList = (root) => {\\n    // Initialize an adjacency list\\n    const adjList = new Map();\\n\\n    // Check if the root node is null\\n    if (!root) return adjList;\\n\\n    // Queue to keep track of nodes to visit\\n    const queue = [root];\\n\\n    while(queue.length) {\\n        const node = queue.shift();\\n\\n        // Check if the node has left and right children\\n        if (node.left) {\\n            // Add the node and its left child to the adjacency list\\n            adjList.set(node.val, [...(adjList.get(node.val) || []), node.left.val]);\\n            adjList.set(node.left.val, [...(adjList.get(node.left.val) || []), node.val]);\\n            queue.push(node.left);\\n        }\\n        if (node.right) {\\n            // Add the node and its right child to the adjacency list\\n            adjList.set(node.val, [...(adjList.get(node.val) || []), node.right.val]);\\n            adjList.set(node.right.val, [...(adjList.get(node.right.val) || []), node.val]);\\n            queue.push(node.right);\\n        }\\n    }\\n    return adjList;\\n}\\n\\n```\n```\\n\\n\\nconst amountOfTime = (root, start) => {\\n\\n    const traverse = (root, start) => {\\n        if (!root) {\\n            return 0;\\n        }\\n\\n        let left = traverse(root.left, start);\\n        let right = traverse(root.right, start);\\n\\n        if (root.val === start) {\\n            amount = Math.max(left, right);\\n            return -1;\\n        } else if (left >= 0 && right >= 0) {\\n            return Math.max(left, right) + 1;\\n        } else {\\n            amount = Math.max(amount, Math.abs(left - right));\\n            return Math.min(left, right) - 1;\\n        }\\n    }\\n    traverse(root, start)\\n    \\n    return amount;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3046888,
                "title": "java-simple-fast-and-easy-solution",
                "content": "// This question will be a simple BFS traversal question if we  can convert tree into graph and for that we can use HahsMap along with DFS traversal and in order to do BFS traversal we need to find the node reference of start which is obtained in the same DFS traversal\\n\\nPlease upvote if understood\\n\\n    class Pair{\\n        TreeNode node ;\\n        int lev ;\\n        \\n        public Pair(TreeNode node ,int lev){\\n            this.node = node ;\\n            this.lev = lev;\\n        }\\n    }\\n    public int amountOfTime(TreeNode root, int start) {\\n        TreeNode[] target = new TreeNode[1];\\n        HashMap<TreeNode ,TreeNode> map = new HashMap<>(); \\n        DFS(root,map,target,start);  \\n        \\n        HashSet<TreeNode> set = new HashSet<>(); // To avoid duplicacy while traversing\\n        Queue<Pair> q = new ArrayDeque<>();\\n        q.add(new Pair(target[0],0));\\n        set.add(target[0]);\\n        int time = 0 ;\\n        while(!q.isEmpty()){  // BFS traversal\\n            Pair pair =q.remove();\\n            TreeNode node = pair.node ;\\n            time  = pair.lev;\\n            \\n            if(node.left!=null  && !set.contains(node.left)){\\n                q.add(new Pair(node.left,time+1));\\n                set.add(node.left);\\n            }\\n            if(node.right!=null && !set.contains(node.right)){\\n                q.add(new Pair(node.right,time+1));\\n                set.add(node.right);\\n            }\\n            if(map.containsKey(node) && !set.contains(map.get(node))){\\n                q.add(new Pair(map.get(node),time+1));\\n                set.add(map.get(node));\\n            }\\n        }\\n        return time ;\\n    }\\n    // Dfs traversal to form child parent relationship  and node reference of start\\n    public void DFS(TreeNode root , HashMap<TreeNode ,TreeNode> map,TreeNode[] target,int start){\\n        if(root==null){\\n            return ;\\n        }\\n        if(root.val == start){\\n            target[0] = root;\\n        }\\n        if(root.left!=null){\\n            if(root.left.val==start){\\n                target[0] = root.left;\\n            }\\n            map.put(root.left, root);\\n            DFS(root.left,map,target,start);\\n        }\\n        if(root.right!=null){\\n            if(root.right.val == start){\\n                target[0] = root.right;\\n            }\\n            map.put(root.right,root);\\n            DFS(root.right,map,target,start);\\n        }\\n    }\\n",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph",
                    "Recursion",
                    "Queue"
                ],
                "code": "// This question will be a simple BFS traversal question if we  can convert tree into graph and for that we can use HahsMap along with DFS traversal and in order to do BFS traversal we need to find the node reference of start which is obtained in the same DFS traversal\\n\\nPlease upvote if understood\\n\\n    class Pair{\\n        TreeNode node ;\\n        int lev ;\\n        \\n        public Pair(TreeNode node ,int lev){\\n            this.node = node ;\\n            this.lev = lev;\\n        }\\n    }\\n    public int amountOfTime(TreeNode root, int start) {\\n        TreeNode[] target = new TreeNode[1];\\n        HashMap<TreeNode ,TreeNode> map = new HashMap<>(); \\n        DFS(root,map,target,start);  \\n        \\n        HashSet<TreeNode> set = new HashSet<>(); // To avoid duplicacy while traversing\\n        Queue<Pair> q = new ArrayDeque<>();\\n        q.add(new Pair(target[0],0));\\n        set.add(target[0]);\\n        int time = 0 ;\\n        while(!q.isEmpty()){  // BFS traversal\\n            Pair pair =q.remove();\\n            TreeNode node = pair.node ;\\n            time  = pair.lev;\\n            \\n            if(node.left!=null  && !set.contains(node.left)){\\n                q.add(new Pair(node.left,time+1));\\n                set.add(node.left);\\n            }\\n            if(node.right!=null && !set.contains(node.right)){\\n                q.add(new Pair(node.right,time+1));\\n                set.add(node.right);\\n            }\\n            if(map.containsKey(node) && !set.contains(map.get(node))){\\n                q.add(new Pair(map.get(node),time+1));\\n                set.add(map.get(node));\\n            }\\n        }\\n        return time ;\\n    }\\n    // Dfs traversal to form child parent relationship  and node reference of start\\n    public void DFS(TreeNode root , HashMap<TreeNode ,TreeNode> map,TreeNode[] target,int start){\\n        if(root==null){\\n            return ;\\n        }\\n        if(root.val == start){\\n            target[0] = root;\\n        }\\n        if(root.left!=null){\\n            if(root.left.val==start){\\n                target[0] = root.left;\\n            }\\n            map.put(root.left, root);\\n            DFS(root.left,map,target,start);\\n        }\\n        if(root.right!=null){\\n            if(root.right.val == start){\\n                target[0] = root.right;\\n            }\\n            map.put(root.right,root);\\n            DFS(root.right,map,target,start);\\n        }\\n    }\\n",
                "codeTag": "Java"
            },
            {
                "id": 2904098,
                "title": "java-bfs-easy-approach-using-bfs-hashmap",
                "content": "```\\nclass Solution {\\n    TreeNode infectedNode;\\n    void fillParents(HashMap < TreeNode, TreeNode > map, TreeNode root, int start) {\\n        if (root == null) {\\n            return;\\n        }\\n        Queue < TreeNode > q = new ArrayDeque < > ();\\n        q.add(root);\\n\\n        while (q.size() > 0) {\\n            TreeNode rem = q.remove();\\n            if (rem.val == start) {\\n                infectedNode = rem;\\n            }\\n            if (rem.left != null) {\\n                //child vs parent\\n                map.put(rem.left, rem);\\n                q.add(rem.left);\\n            }\\n            if (rem.right != null) {\\n                //child vs parent\\n                map.put(rem.right, rem);\\n                q.add(rem.right);\\n            }\\n        }\\n    }\\n\\n    public int amountOfTime(TreeNode root, int start) {\\n        /* Parent -> Child*/\\n        HashMap < TreeNode, TreeNode > map = new HashMap < > ();\\n        infectedNode = null;\\n        fillParents(map, root, start);\\n        HashSet < TreeNode > vis = new HashSet < > ();\\n        Queue < TreeNode > q = new ArrayDeque < > ();\\n        q.add(infectedNode);\\n        // System.out.print(infectedNode.val);\\n        int time = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            boolean infected = false;\\n\\n            while (size-- > 0) {\\n                TreeNode rem = q.remove();\\n                vis.add(rem);\\n\\n                if (rem.left != null && !vis.contains(rem.left)) {\\n                    infected = true;\\n                    q.add(rem.left);\\n                    vis.add(rem.left);\\n                }\\n\\n                if (rem.right != null && !vis.contains(rem.right)) {\\n                    infected = true;\\n                    q.add(rem.right);\\n                    vis.add(rem.right);\\n                }\\n\\n                if (map.get(rem) != null && !vis.contains(map.get(rem))) {\\n                    infected = true;\\n                    q.add(map.get(rem));\\n                    vis.add(map.get(rem));\\n                }\\n            }\\n\\n            if (infected) {\\n                time++;\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode infectedNode;\\n    void fillParents(HashMap < TreeNode, TreeNode > map, TreeNode root, int start) {\\n        if (root == null) {\\n            return;\\n        }\\n        Queue < TreeNode > q = new ArrayDeque < > ();\\n        q.add(root);\\n\\n        while (q.size() > 0) {\\n            TreeNode rem = q.remove();\\n            if (rem.val == start) {\\n                infectedNode = rem;\\n            }\\n            if (rem.left != null) {\\n                //child vs parent\\n                map.put(rem.left, rem);\\n                q.add(rem.left);\\n            }\\n            if (rem.right != null) {\\n                //child vs parent\\n                map.put(rem.right, rem);\\n                q.add(rem.right);\\n            }\\n        }\\n    }\\n\\n    public int amountOfTime(TreeNode root, int start) {\\n        /* Parent -> Child*/\\n        HashMap < TreeNode, TreeNode > map = new HashMap < > ();\\n        infectedNode = null;\\n        fillParents(map, root, start);\\n        HashSet < TreeNode > vis = new HashSet < > ();\\n        Queue < TreeNode > q = new ArrayDeque < > ();\\n        q.add(infectedNode);\\n        // System.out.print(infectedNode.val);\\n        int time = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            boolean infected = false;\\n\\n            while (size-- > 0) {\\n                TreeNode rem = q.remove();\\n                vis.add(rem);\\n\\n                if (rem.left != null && !vis.contains(rem.left)) {\\n                    infected = true;\\n                    q.add(rem.left);\\n                    vis.add(rem.left);\\n                }\\n\\n                if (rem.right != null && !vis.contains(rem.right)) {\\n                    infected = true;\\n                    q.add(rem.right);\\n                    vis.add(rem.right);\\n                }\\n\\n                if (map.get(rem) != null && !vis.contains(map.get(rem))) {\\n                    infected = true;\\n                    q.add(map.get(rem));\\n                    vis.add(map.get(rem));\\n                }\\n            }\\n\\n            if (infected) {\\n                time++;\\n            }\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2737889,
                "title": "c-easy-short",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   int res = 0;\\n    pair<bool,int> dfs(TreeNode* root, int start){\\n        if(!root) return {false,0};\\n        pair<bool,int>p1 = dfs(root->left,start);\\n        pair<bool,int>p2 = dfs(root->right,start);\\n        if(root->val==start){\\n            int temp = max(p2.second,p1.second);\\n            res = max(res,temp);\\n            return {true,0};\\n        }\\n        if(p1.first){\\n            int sum = p1.second+p2.second+1;\\n            res = max(res,sum);\\n            return {true,p1.second+1};\\n        }else if(p2.first){\\n            int sum = p1.second+p2.second+1;\\n            res = max(res,sum);\\n            return {true,p2.second+1};\\n        }\\n        int sum = max(p1.second,p2.second);\\n        return {false,1+sum};\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n        dfs(root,start);\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   int res = 0;\\n    pair<bool,int> dfs(TreeNode* root, int start){\\n        if(!root) return {false,0};\\n        pair<bool,int>p1 = dfs(root->left,start);\\n        pair<bool,int>p2 = dfs(root->right,start);\\n        if(root->val==start){\\n            int temp = max(p2.second,p1.second);\\n            res = max(res,temp);\\n            return {true,0};\\n        }\\n        if(p1.first){\\n            int sum = p1.second+p2.second+1;\\n            res = max(res,sum);\\n            return {true,p1.second+1};\\n        }else if(p2.first){\\n            int sum = p1.second+p2.second+1;\\n            res = max(res,sum);\\n            return {true,p2.second+1};\\n        }\\n        int sum = max(p1.second,p2.second);\\n        return {false,1+sum};\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n        dfs(root,start);\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2672292,
                "title": "c-solution-amount-of-time-for-binary-tree-to-be-infected",
                "content": "```\\nclass Solution {\\nprivate:\\n    TreeNode *createMapping(TreeNode* root, int start , map<TreeNode*, TreeNode*> &nodeToParent){\\n        TreeNode *ans = NULL;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        nodeToParent[root] = NULL;\\n        \\n        while(!q.empty()){\\n            TreeNode *front = q.front();\\n            q.pop();\\n            \\n            if(front->val == start)\\n                ans = front;\\n            \\n            if(front->left){\\n                nodeToParent[front->left] = front;\\n                q.push(front->left);\\n            }\\n            if(front->right){\\n                nodeToParent[front->right] = front;\\n                q.push(front->right);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void solve(TreeNode* root ,  map<TreeNode*, TreeNode*> &nodeToParent , int &time){\\n        map<TreeNode* , bool> visited;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        visited[root] = 1;\\n        \\n        \\n        while(!q.empty()){\\n            int size = q.size();\\n            bool flag = false;\\n            \\n            for(int i = 0 ; i < size ; i++){\\n                TreeNode *front = q.front();\\n                q.pop();\\n                \\n                if(front->left && !visited[front->left]){\\n                    flag = true;\\n                    visited[front->left] = 1;\\n                    q.push(front->left);\\n                }\\n                if(front->right && !visited[front->right]){\\n                    flag = true;\\n                    visited[front->right] = 1;\\n                    q.push(front->right);\\n                }\\n                if(nodeToParent[front] && !visited[nodeToParent[front]]){\\n                    flag = true;\\n                    visited[nodeToParent[front]] = 1;\\n                    q.push(nodeToParent[front]);\\n                }\\n            }\\n            if(flag == true)\\n                time++;\\n        }\\n    }\\n    \\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        //step 1 : create node to parent mapping and find the start node.\\n        map<TreeNode*, TreeNode*> nodeToParent;\\n        TreeNode *target = createMapping(root , start , nodeToParent);\\n        \\n        //step 2 : burn the tree.\\n        int time = 0;\\n        solve(target , nodeToParent , time);\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    TreeNode *createMapping(TreeNode* root, int start , map<TreeNode*, TreeNode*> &nodeToParent){\\n        TreeNode *ans = NULL;\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        nodeToParent[root] = NULL;\\n        \\n        while(!q.empty()){\\n            TreeNode *front = q.front();\\n            q.pop();\\n            \\n            if(front->val == start)\\n                ans = front;\\n            \\n            if(front->left){\\n                nodeToParent[front->left] = front;\\n                q.push(front->left);\\n            }\\n            if(front->right){\\n                nodeToParent[front->right] = front;\\n                q.push(front->right);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void solve(TreeNode* root ,  map<TreeNode*, TreeNode*> &nodeToParent , int &time){\\n        map<TreeNode* , bool> visited;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        visited[root] = 1;\\n        \\n        \\n        while(!q.empty()){\\n            int size = q.size();\\n            bool flag = false;\\n            \\n            for(int i = 0 ; i < size ; i++){\\n                TreeNode *front = q.front();\\n                q.pop();\\n                \\n                if(front->left && !visited[front->left]){\\n                    flag = true;\\n                    visited[front->left] = 1;\\n                    q.push(front->left);\\n                }\\n                if(front->right && !visited[front->right]){\\n                    flag = true;\\n                    visited[front->right] = 1;\\n                    q.push(front->right);\\n                }\\n                if(nodeToParent[front] && !visited[nodeToParent[front]]){\\n                    flag = true;\\n                    visited[nodeToParent[front]] = 1;\\n                    q.push(nodeToParent[front]);\\n                }\\n            }\\n            if(flag == true)\\n                time++;\\n        }\\n    }\\n    \\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        //step 1 : create node to parent mapping and find the start node.\\n        map<TreeNode*, TreeNode*> nodeToParent;\\n        TreeNode *target = createMapping(root , start , nodeToParent);\\n        \\n        //step 2 : burn the tree.\\n        int time = 0;\\n        solve(target , nodeToParent , time);\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2559495,
                "title": "c-bfs-shortest-path",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> gh;\\n    void traverse(TreeNode* root){\\n        if(root==nullptr)\\n            return;\\n        if(root->left!=nullptr)\\n        gh[root->val].push_back(root->left->val);\\n        if(root->right!=nullptr)\\n        gh[root->val].push_back(root->right->val);\\n        if(root->left!=nullptr)\\n        gh[root->left->val].push_back(root->val);\\n        if(root->right!=nullptr)\\n        gh[root->right->val].push_back(root->val);\\n        \\n        traverse(root->left);\\n        traverse(root->right);\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        gh=vector<vector<int>>(100001);\\n        traverse(root);\\n        \\n        queue<int> q;\\n        q.push(start);\\n        \\n        vector<bool> vis(100001,false);\\n        \\n        int minTimes=0;\\n        \\n        vis[start]=true;\\n        \\n        while(!q.empty()){\\n            \\n            for(int i=q.size();i>0;i--){\\n                \\n                int x=q.front();\\n                q.pop();\\n                \\n                for(auto it:gh[x]){\\n                    if(vis[it]==false){\\n                        vis[it]=true;\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n            \\n            minTimes++;\\n        }\\n        \\n        return minTimes-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<vector<int>> gh;\\n    void traverse(TreeNode* root){\\n        if(root==nullptr)\\n            return;\\n        if(root->left!=nullptr)\\n        gh[root->val].push_back(root->left->val);\\n        if(root->right!=nullptr)\\n        gh[root->val].push_back(root->right->val);\\n        if(root->left!=nullptr)\\n        gh[root->left->val].push_back(root->val);\\n        if(root->right!=nullptr)\\n        gh[root->right->val].push_back(root->val);\\n        \\n        traverse(root->left);\\n        traverse(root->right);\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        gh=vector<vector<int>>(100001);\\n        traverse(root);\\n        \\n        queue<int> q;\\n        q.push(start);\\n        \\n        vector<bool> vis(100001,false);\\n        \\n        int minTimes=0;\\n        \\n        vis[start]=true;\\n        \\n        while(!q.empty()){\\n            \\n            for(int i=q.size();i>0;i--){\\n                \\n                int x=q.front();\\n                q.pop();\\n                \\n                for(auto it:gh[x]){\\n                    if(vis[it]==false){\\n                        vis[it]=true;\\n                        q.push(it);\\n                    }\\n                }\\n            }\\n            \\n            minTimes++;\\n        }\\n        \\n        return minTimes-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499575,
                "title": "c-bfs-up-left-right",
                "content": "```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*,TreeNode*> parents ;\\n    TreeNode* k  = nullptr ;\\n    int start ;\\n    \\n    void find_parent(TreeNode * root){\\n        queue<TreeNode*> q ;\\n        q.push(root) ;\\n        \\n        while(q.size()){\\n            auto node = q.front() ;\\n            q.pop() ;\\n            if(node->val == start) k = node ;\\n            \\n            if(node->left) parents[node->left] = node , q.push(node->left) ;\\n            if(node->right) parents[node->right] = node , q.push(node->right) ;\\n        }\\n        return ;\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n        parents[root] = nullptr   ; this->start = start ;\\n        int timer = -1 ;\\n        unordered_set<int> vis ;\\n        \\n        find_parent(root) ;\\n        \\n        queue<TreeNode*> q ;\\n        q.push(k);\\n        \\n        \\n        while(q.size()){\\n            int sz = q.size() ;\\n            while(sz--){\\n                auto node = q.front() ; q.pop() ;\\n                if(vis.find(node->val) != end(vis)) continue ;\\n                vis.insert(node->val) ;\\n                \\n                if(node->left and vis.find(node->left->val) == end(vis)) q.push(node->left) ;\\n                if(node->right and vis.find(node->right->val) == end(vis)) q.push(node->right) ;\\n                if(parents[node] != nullptr and vis.find(parents[node]->val) == end(vis)) q.push(parents[node]) ;\\n                \\n            }\\n            ++timer ;\\n        }\\n        \\n        return timer ;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*,TreeNode*> parents ;\\n    TreeNode* k  = nullptr ;\\n    int start ;\\n    \\n    void find_parent(TreeNode * root){\\n        queue<TreeNode*> q ;\\n        q.push(root) ;\\n        \\n        while(q.size()){\\n            auto node = q.front() ;\\n            q.pop() ;\\n            if(node->val == start) k = node ;\\n            \\n            if(node->left) parents[node->left] = node , q.push(node->left) ;\\n            if(node->right) parents[node->right] = node , q.push(node->right) ;\\n        }\\n        return ;\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n        parents[root] = nullptr   ; this->start = start ;\\n        int timer = -1 ;\\n        unordered_set<int> vis ;\\n        \\n        find_parent(root) ;\\n        \\n        queue<TreeNode*> q ;\\n        q.push(k);\\n        \\n        \\n        while(q.size()){\\n            int sz = q.size() ;\\n            while(sz--){\\n                auto node = q.front() ; q.pop() ;\\n                if(vis.find(node->val) != end(vis)) continue ;\\n                vis.insert(node->val) ;\\n                \\n                if(node->left and vis.find(node->left->val) == end(vis)) q.push(node->left) ;\\n                if(node->right and vis.find(node->right->val) == end(vis)) q.push(node->right) ;\\n                if(parents[node] != nullptr and vis.find(parents[node]->val) == end(vis)) q.push(parents[node]) ;\\n                \\n            }\\n            ++timer ;\\n        }\\n        \\n        return timer ;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2488969,
                "title": "simple-java-solution-without-graph-15ms-100-faster-single-dfs-pass",
                "content": "...\\n**Simple Java Solution Without Graph - 15ms 100% faster, Single DFS Pass**\\n\\nUsing one pass DFS\\n\\nUpvote if it helps.\\n...\\n\\n\\tclass Solution {\\n\\t\\tint ans;\\n\\t\\tpublic int amountOfTime(TreeNode root, int start) {\\n\\t\\t\\tans = 0;\\n\\t\\t\\thelper(root, start);\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}\\n\\n\\t\\tprivate int[] helper(TreeNode root, int start){\\n\\t\\t\\tif(root == null)\\n\\t\\t\\t\\treturn new int[]{0, 0};\\n\\t\\t\\t//arr -> [0]\\n\\t\\t\\t//0 -> means infected node is not in that subtree \\n\\t\\t\\t//1 -> means infected node in that subtree\\n\\n\\t\\t\\t//if arr[0] == 0, then arr[1] -> height of subtree\\n\\n\\t\\t\\t//if 1 in arr[0] then arr[1] -> stores minutes needed to infect the root\\n\\t\\t\\t//and time to infect the other subtree is height of that subtree + time to infect root\\n\\n\\n\\t\\t\\tint[] left = helper(root.left, start);\\n\\t\\t\\tint[] right = helper(root.right, start);\\n\\n\\t\\t\\tint h = Math.max(left[1], right[1]);\\n\\n\\t\\t\\tif(left[0] == 1){//left has infected node -> left[1] -> gives time to infect root\\n\\t\\t\\t\\tans = Math.max(ans, left[1] + right[1]);\\n\\t\\t\\t\\tleft[1] += 1;\\n\\t\\t\\t\\treturn left;\\n\\t\\t\\t}else if(right[0] == 1){//right has infected node\\n\\t\\t\\t\\tans = Math.max(ans, left[1] + right[1]);\\n\\t\\t\\t\\tright[1] += 1;\\n\\t\\t\\t\\treturn right;\\n\\t\\t\\t}\\n\\n\\t\\t\\t//if root is infected then time needed to infect the subtrees is max height of subtrees\\n\\t\\t\\tif(root.val == start){\\n\\t\\t\\t\\tans = Math.max(h, ans);\\n\\t\\t\\t\\treturn new int[]{1, 1};\\n\\t\\t\\t}\\n\\n\\t\\t\\tleft[1] = h + 1;//for simple height\\n\\t\\t\\treturn left;\\n\\t\\t}\\n\\t}",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search"
                ],
                "code": "class Solution {\\n\\t\\tint ans;\\n\\t\\tpublic int amountOfTime(TreeNode root, int start) {\\n\\t\\t\\tans = 0;\\n\\t\\t\\thelper(root, start);\\n\\n\\t\\t\\treturn ans;\\n\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 2465891,
                "title": "python3-recursive-simple",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n\\n  graph = []\\n\\n  def init_graph(self,  node):\\n    if node.left:\\n      self.graph[node.val].append(node.left.val)\\n      self.graph[node.left.val].append(node.val)\\n      self.init_graph(node.left)\\n    if node.right:\\n      self.graph[node.val].append(node.right.val)\\n      self.graph[node.right.val].append(node.val)\\n      self.init_graph(node.right)\\n\\n  def height(self, v, p):\\n    if v == None:\\n      return -1\\n    else:\\n      m = -1\\n      for u in self.graph[v]:\\n        if u != p:\\n          m = max(m, self.height(u, v))\\n      return 1 + m\\n\\n  def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n    self.graph = [[] for _ in range(10**5 + 1)]\\n    self.init_graph(root)\\n    return self.height(start, -1)\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Breadth-First Search",
                    "Graph",
                    "Recursion"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\n\\nclass Solution:\\n\\n  graph = []\\n\\n  def init_graph(self,  node):\\n    if node.left:\\n      self.graph[node.val].append(node.left.val)\\n      self.graph[node.left.val].append(node.val)\\n      self.init_graph(node.left)\\n    if node.right:\\n      self.graph[node.val].append(node.right.val)\\n      self.graph[node.right.val].append(node.val)\\n      self.init_graph(node.right)\\n\\n  def height(self, v, p):\\n    if v == None:\\n      return -1\\n    else:\\n      m = -1\\n      for u in self.graph[v]:\\n        if u != p:\\n          m = max(m, self.height(u, v))\\n      return 1 + m\\n\\n  def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n    self.graph = [[] for _ in range(10**5 + 1)]\\n    self.init_graph(root)\\n    return self.height(start, -1)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465007,
                "title": "simple-with-traversing-into-graph",
                "content": "```\\nvar amountOfTime = function(root, start) {\\n     let map = new Map;\\n\\n  function helper(node){\\n    if (!node){\\n      return null;\\n    }\\n    if (!map.has(node.val))map.set(node.val,[]);\\n  \\n    if (node.left){\\n      map.get(node.val).push(node.left.val);\\n      map.set(node.left.val,[node.val]);\\n      helper(node.left);\\n    }\\n\\n    if (node.right){\\n      map.get(node.val).push(node.right.val);\\n      map.set(node.right.val,[node.val]);\\n      helper(node.right);\\n    }\\n  }\\n\\n  helper(root);\\n  let visited = new Set;\\n  let queue = [start];\\n  let count = 0;\\n  while (queue.length){\\n    let len = queue.length;\\n    for(let i = 0; i<len; i++){\\n      let elem = queue.shift();\\n      visited.add(elem);\\n      for(let each of map.get(elem)){\\n        if (!visited.has(each)) queue.push(each)\\n      }\\n      // log(queue,\\'queue\\');\\n    }\\n    if (queue.length)count++;\\n  }\\n\\n  return count;\\n};\\n```\\n**PLEASE UPVOTE!**",
                "solutionTags": [
                    "JavaScript",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nvar amountOfTime = function(root, start) {\\n     let map = new Map;\\n\\n  function helper(node){\\n    if (!node){\\n      return null;\\n    }\\n    if (!map.has(node.val))map.set(node.val,[]);\\n  \\n    if (node.left){\\n      map.get(node.val).push(node.left.val);\\n      map.set(node.left.val,[node.val]);\\n      helper(node.left);\\n    }\\n\\n    if (node.right){\\n      map.get(node.val).push(node.right.val);\\n      map.set(node.right.val,[node.val]);\\n      helper(node.right);\\n    }\\n  }\\n\\n  helper(root);\\n  let visited = new Set;\\n  let queue = [start];\\n  let count = 0;\\n  while (queue.length){\\n    let len = queue.length;\\n    for(let i = 0; i<len; i++){\\n      let elem = queue.shift();\\n      visited.add(elem);\\n      for(let each of map.get(elem)){\\n        if (!visited.has(each)) queue.push(each)\\n      }\\n      // log(queue,\\'queue\\');\\n    }\\n    if (queue.length)count++;\\n  }\\n\\n  return count;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2462008,
                "title": "java-o-n-single-traversal-100-faster-100-less-memory-recursion",
                "content": "**<-------//VoteUp If you like the solution**\\n\\n![image](https://assets.leetcode.com/users/images/26de9e85-03d6-424b-bdfe-fefa44e036c6_1661145571.5623124.png)\\n\\n```\\nclass Solution {\\n    \\n    int res = 0;\\n    public int amountOfTime(TreeNode root, int start) {\\n        \\n        if(root.left == null && root.right == null)\\n            return 0;\\n        \\n        if(root.val == start){\\n            return getHeight(root)-1;\\n        }\\n        \\n        res = 0;\\n        \\n        getDiameter(root, start);\\n        \\n        return res;\\n    }\\n    \\n    public int getDiameter(TreeNode node, int start) {\\n        \\n        if(node == null)\\n            return 0;\\n        \\n        if(node.val == start) {\\n            res = getHeight(node)-1;\\n            return -1;\\n        }\\n        \\n        int left = getDiameter(node.left, start);\\n        int right = getDiameter(node.right, start);\\n        \\n        if(left >=0 && right >= 0) {\\n            return Math.max(left, right)+1;\\n        }\\n        \\n        if(left < 0) {\\n            res = Math.max(right - left, res);\\n            return --left;\\n        }\\n        \\n        res = Math.max(left - right , res);\\n        return --right;\\n    }\\n    \\n    public int getHeight(TreeNode node){\\n        \\n        if(node == null)\\n            return 0;\\n        \\n        return Math.max(getHeight(node.left), getHeight(node.right))+1;\\n        \\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    \\n    int res = 0;\\n    public int amountOfTime(TreeNode root, int start) {\\n        \\n        if(root.left == null && root.right == null)\\n            return 0;\\n        \\n        if(root.val == start){\\n            return getHeight(root)-1;\\n        }\\n        \\n        res = 0;\\n        \\n        getDiameter(root, start);\\n        \\n        return res;\\n    }\\n    \\n    public int getDiameter(TreeNode node, int start) {\\n        \\n        if(node == null)\\n            return 0;\\n        \\n        if(node.val == start) {\\n            res = getHeight(node)-1;\\n            return -1;\\n        }\\n        \\n        int left = getDiameter(node.left, start);\\n        int right = getDiameter(node.right, start);\\n        \\n        if(left >=0 && right >= 0) {\\n            return Math.max(left, right)+1;\\n        }\\n        \\n        if(left < 0) {\\n            res = Math.max(right - left, res);\\n            return --left;\\n        }\\n        \\n        res = Math.max(left - right , res);\\n        return --right;\\n    }\\n    \\n    public int getHeight(TreeNode node){\\n        \\n        if(node == null)\\n            return 0;\\n        \\n        return Math.max(getHeight(node.left), getHeight(node.right))+1;\\n        \\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460956,
                "title": "rust-dfs-post-order-traversal",
                "content": "If you like my solution, you should check out [my github repo](https://github.com/SvetlinZarev/coding-challenges/tree/main/leetcode)\\n\\n```rust\\npub fn amount_of_time(root: Option<Rc<RefCell<TreeNode>>>, start: i32) -> i32 {\\n    let mut answer = 0;\\n    if let Some(root) = root.as_ref() {\\n        postorder(root, start, &mut answer);\\n    }\\n    answer\\n}\\n\\nfn postorder(root: &Rc<RefCell<TreeNode>>, target: i32, answer: &mut i32) -> (i32, bool) {\\n    let root = root.borrow();\\n\\n    // Depth of left/right sub-tree. A valu eof `-1` means \\n    // that there is no such sub-tree\\n    let mut ldepth = -1;\\n    let mut rdepth = -1;\\n\\n    // A flag indicating whether the left/right sub-tree \\n    // contains the infected node\\n    let mut linf = false;\\n    let mut rinf = false;\\n\\n    // Measure the maximum depth of the left sub-tree from \\n    // this node. And check if it contains the infected node\\n    if let Some(node) = root.left.as_ref() {\\n        let (d, i) = postorder(node, target, answer);\\n        ldepth = d;\\n        linf = i;\\n    }\\n\\n    // Measure the maximum depth of the right sub-tree from \\n    // this node. And check if it contains the infected node\\n    if let Some(node) = root.right.as_ref() {\\n        let (d, i) = postorder(node, target, answer);\\n        rdepth = d;\\n        rinf = i;\\n    }\\n\\n    // If the left or right sub-tree is infected, then the \\n    // time (i.e. the path the infection takes) is through\\n    // the subtree-link through this node, then through the \\n    // other subtree. I.e. the path length is the sum of the \\n    // depth of both subtrees, plus the two link to the \\n    // current node (the two `+1` below)\\n    if linf || rinf {\\n        // Calculate the length of the infection path and\\n        // update the maximum distance (i.e. the answer)\\n        let depth = ldepth + 1 + rdepth + 1;\\n        *answer = (*answer).max(depth);\\n\\n        // If one of the sub-trees is infected, we propagate \\n        // only it\\'s length\\n        return if linf {\\n            (ldepth + 1, true)\\n        } else {\\n            (rdepth + 1, true)\\n        };\\n    }\\n\\n    // If none of the sub-trees are infected, then we are\\n    // interested of the maximum of both depths, because \\n    // the infection would spread **simultaneously** to \\n    // both subtrees when it reaches this node\\n    let depth = 1 + ldepth.max(rdepth);\\n\\n    // If this three is the source of the infection\\n    // update the answer with the time it would take \\n    // to infect it\\'s sub-trees\\n    if root.val == target {\\n        *answer = (*answer).max(depth);\\n\\n        // And we return 0 as it\\'s depth, because we are\\n        // updating the answer in a post-order way, and\\n        // we are interested in the distance of the other \\n        // nodes from this node\\n        return (0, true);\\n    }\\n\\n    // None of the sub-trees is infected, and this node \\n    // is healthy as well.A e are interested of the \\n    // maximum of both depths, because the infection \\n    // would spread **simultaneously** to  both subtrees \\n    // when it reaches this node\\n    (depth, false)\\n}\\n```\\n",
                "solutionTags": [
                    "Rust",
                    "Depth-First Search"
                ],
                "code": "```rust\\npub fn amount_of_time(root: Option<Rc<RefCell<TreeNode>>>, start: i32) -> i32 {\\n    let mut answer = 0;\\n    if let Some(root) = root.as_ref() {\\n        postorder(root, start, &mut answer);\\n    }\\n    answer\\n}\\n\\nfn postorder(root: &Rc<RefCell<TreeNode>>, target: i32, answer: &mut i32) -> (i32, bool) {\\n    let root = root.borrow();\\n\\n    // Depth of left/right sub-tree. A valu eof `-1` means \\n    // that there is no such sub-tree\\n    let mut ldepth = -1;\\n    let mut rdepth = -1;\\n\\n    // A flag indicating whether the left/right sub-tree \\n    // contains the infected node\\n    let mut linf = false;\\n    let mut rinf = false;\\n\\n    // Measure the maximum depth of the left sub-tree from \\n    // this node. And check if it contains the infected node\\n    if let Some(node) = root.left.as_ref() {\\n        let (d, i) = postorder(node, target, answer);\\n        ldepth = d;\\n        linf = i;\\n    }\\n\\n    // Measure the maximum depth of the right sub-tree from \\n    // this node. And check if it contains the infected node\\n    if let Some(node) = root.right.as_ref() {\\n        let (d, i) = postorder(node, target, answer);\\n        rdepth = d;\\n        rinf = i;\\n    }\\n\\n    // If the left or right sub-tree is infected, then the \\n    // time (i.e. the path the infection takes) is through\\n    // the subtree-link through this node, then through the \\n    // other subtree. I.e. the path length is the sum of the \\n    // depth of both subtrees, plus the two link to the \\n    // current node (the two `+1` below)\\n    if linf || rinf {\\n        // Calculate the length of the infection path and\\n        // update the maximum distance (i.e. the answer)\\n        let depth = ldepth + 1 + rdepth + 1;\\n        *answer = (*answer).max(depth);\\n\\n        // If one of the sub-trees is infected, we propagate \\n        // only it\\'s length\\n        return if linf {\\n            (ldepth + 1, true)\\n        } else {\\n            (rdepth + 1, true)\\n        };\\n    }\\n\\n    // If none of the sub-trees are infected, then we are\\n    // interested of the maximum of both depths, because \\n    // the infection would spread **simultaneously** to \\n    // both subtrees when it reaches this node\\n    let depth = 1 + ldepth.max(rdepth);\\n\\n    // If this three is the source of the infection\\n    // update the answer with the time it would take \\n    // to infect it\\'s sub-trees\\n    if root.val == target {\\n        *answer = (*answer).max(depth);\\n\\n        // And we return 0 as it\\'s depth, because we are\\n        // updating the answer in a post-order way, and\\n        // we are interested in the distance of the other \\n        // nodes from this node\\n        return (0, true);\\n    }\\n\\n    // None of the sub-trees is infected, and this node \\n    // is healthy as well.A e are interested of the \\n    // maximum of both depths, because the infection \\n    // would spread **simultaneously** to  both subtrees \\n    // when it reaches this node\\n    (depth, false)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2458588,
                "title": "c-dfs-and-bfs-using-graph-both-solutions",
                "content": "Convert the tree into Graph.\\nThen find farthest vertex from start.\\n\\nDFS : \\n\\n```\\nclass Solution {\\npublic:\\n    int dfs(int node, unordered_map<int,vector<int>>&adj,  vector<int>&vis){\\n      vis[node]=1;\\n        int res=0;\\n        for(auto it:adj[node]){\\n            if(vis[it]==0){\\n                res=max(res,1+dfs(it,adj,vis));\\n            }\\n        }\\n        return res;\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n       \\n        unordered_map<int,vector<int>>adj;\\n            int maxi=0;\\n        if(!root)return 0;  \\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.size()){\\n            auto cur=q.front();\\n            maxi=max(cur->val,maxi);\\n            q.pop();\\n            if(cur->left){\\n                adj[cur->val].push_back(cur->left->val);\\n                adj[cur->left->val].push_back(cur->val);\\n                q.push(cur->left);\\n            }\\n            if(cur->right){\\n                adj[cur->val].push_back(cur->right->val);\\n                adj[cur->right->val].push_back(cur->val);\\n                q.push(cur->right);\\n            }\\n        }\\n        vector<int>vis(maxi+1,0);\\n    \\n        return dfs(start,adj,vis);\\n    }\\n};\\n```\\n\\nBFS :\\n\\n```\\nclass Solution {\\npublic:\\n \\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<int,vector<int>>adj;\\n            int maxi=0;\\n        \\n        if(!root)return 0;  \\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.size()){\\n            auto cur=q.front();\\n            maxi=max(cur->val,maxi);\\n            q.pop();\\n            if(cur->left){\\n                adj[cur->val].push_back(cur->left->val);\\n                adj[cur->left->val].push_back(cur->val);\\n                q.push(cur->left);\\n            }\\n            if(cur->right){\\n                adj[cur->val].push_back(cur->right->val);\\n                adj[cur->right->val].push_back(cur->val);\\n                q.push(cur->right);\\n            }\\n        }\\n        vector<int>vis(maxi+1,0);\\n        queue<pair<int,int>>qt;// node,time\\n        int res=0;\\n        vis[start]=1;\\n        qt.push({start,0});\\n        while(qt.size()){\\n\\t\\t\\t\\tint size=qt.size();\\n\\t\\t\\t\\twhile(size--){\\n\\t\\t\\t\\t\\t\\tauto node=qt.front().first;\\n\\t\\t\\t\\t\\t\\tauto time=qt.front().second;\\n\\t\\t\\t\\t\\t\\tres=max(res,time);\\n\\t\\t\\t\\t\\t\\tqt.pop();\\n\\t\\t\\t\\t\\t\\t\\tfor(auto it:adj[node]){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(vis[it]==0){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvis[it]=1;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tqt.push({it,time+1});\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n        }\\n        return res;\\n    }\\n};\\n```\\nIf this post is helpful for you, Do upvote.  \\n",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int dfs(int node, unordered_map<int,vector<int>>&adj,  vector<int>&vis){\\n      vis[node]=1;\\n        int res=0;\\n        for(auto it:adj[node]){\\n            if(vis[it]==0){\\n                res=max(res,1+dfs(it,adj,vis));\\n            }\\n        }\\n        return res;\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n       \\n        unordered_map<int,vector<int>>adj;\\n            int maxi=0;\\n        if(!root)return 0;  \\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.size()){\\n            auto cur=q.front();\\n            maxi=max(cur->val,maxi);\\n            q.pop();\\n            if(cur->left){\\n                adj[cur->val].push_back(cur->left->val);\\n                adj[cur->left->val].push_back(cur->val);\\n                q.push(cur->left);\\n            }\\n            if(cur->right){\\n                adj[cur->val].push_back(cur->right->val);\\n                adj[cur->right->val].push_back(cur->val);\\n                q.push(cur->right);\\n            }\\n        }\\n        vector<int>vis(maxi+1,0);\\n    \\n        return dfs(start,adj,vis);\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n \\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<int,vector<int>>adj;\\n            int maxi=0;\\n        \\n        if(!root)return 0;  \\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(q.size()){\\n            auto cur=q.front();\\n            maxi=max(cur->val,maxi);\\n            q.pop();\\n            if(cur->left){\\n                adj[cur->val].push_back(cur->left->val);\\n                adj[cur->left->val].push_back(cur->val);\\n                q.push(cur->left);\\n            }\\n            if(cur->right){\\n                adj[cur->val].push_back(cur->right->val);\\n                adj[cur->right->val].push_back(cur->val);\\n                q.push(cur->right);\\n            }\\n        }\\n        vector<int>vis(maxi+1,0);\\n        queue<pair<int,int>>qt;// node,time\\n        int res=0;\\n        vis[start]=1;\\n        qt.push({start,0});\\n        while(qt.size()){\\n\\t\\t\\t\\tint size=qt.size();\\n\\t\\t\\t\\twhile(size--){\\n\\t\\t\\t\\t\\t\\tauto node=qt.front().first;\\n\\t\\t\\t\\t\\t\\tauto time=qt.front().second;\\n\\t\\t\\t\\t\\t\\tres=max(res,time);\\n\\t\\t\\t\\t\\t\\tqt.pop();\\n\\t\\t\\t\\t\\t\\t\\tfor(auto it:adj[node]){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\tif(vis[it]==0){\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tvis[it]=1;\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t\\t\\tqt.push({it,time+1});\\n\\t\\t\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458166,
                "title": "java-easy-solution-building-graph",
                "content": "```\\nclass Solution {\\n    HashMap<Integer,ArrayList<Integer>> map = new HashMap<>();\\n    //doing bfs for height from start position\\n    public int amountOfTime(TreeNode root, int start) {\\n        makeGraph(root , -1);\\n        Queue<Integer> q = new LinkedList<Integer>();\\n        q.offer(start);\\n        int ans = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        set.add(start);\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            while(size-->0) {\\n                int e = q.poll();\\n                if(!map.containsKey(e))\\n                    continue;\\n                for(int x : map.get(e)) {\\n                    if(!set.contains(x)) {\\n                        q.offer(x);\\n                        set.add(x);\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans-1;\\n        \\n    }\\n    //making a graph using hashmap\\n    public void makeGraph(TreeNode root , int parent) {\\n        if(root == null) {\\n            return;\\n        }\\n        if(parent != -1) {\\n            if(!map.containsKey(root.val)) {\\n                ArrayList<Integer> list = new ArrayList<>();\\n                list.add(parent);\\n                map.put(root.val,list);\\n            }\\n            else {\\n                ArrayList<Integer> list = map.get(root.val);\\n                list.add(parent);\\n                map.put(root.val , list) ;\\n            }\\n            if(!map.containsKey(parent)) {\\n                ArrayList<Integer> list = new ArrayList<>();\\n                list.add(root.val);\\n                map.put(parent,list);\\n            }\\n            else {\\n                ArrayList<Integer> list = map.get(parent);\\n                list.add(root.val);\\n                map.put(parent , list) ;\\n            }\\n        }\\n        makeGraph(root.left , root.val);\\n        makeGraph(root.right , root.val);\\n    }\\n}",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "class Solution {\\n    HashMap<Integer,ArrayList<Integer>> map = new HashMap<>();\\n    //doing bfs for height from start position\\n    public int amountOfTime(TreeNode root, int start) {\\n        makeGraph(root , -1);\\n        Queue<Integer> q = new LinkedList<Integer>();\\n        q.offer(start);\\n        int ans = 0;\\n        HashSet<Integer> set = new HashSet<>();\\n        set.add(start);\\n        while(!q.isEmpty()) {\\n            int size = q.size();\\n            while(size-->0) {\\n                int e = q.poll();\\n                if(!map.containsKey(e))\\n                    continue;\\n                for(int x : map.get(e)) {\\n                    if(!set.contains(x)) {\\n                        q.offer(x);\\n                        set.add(x);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2457880,
                "title": "easy-python-bfs-solution",
                "content": "```\\n    def amountOfTime(self, root, start):\\n        \"\"\"\\n        :type root: Optional[TreeNode]\\n        :type start: int\\n        :rtype: int\\n        \"\"\"\\n        self.startNode = None\\n        parent = {}\\n        def helper(root):\\n            if not root:\\n                return\\n            if root.val == start:\\n                self.startNode = root\\n            if root.left:\\n                parent[root.left] = root\\n                helper(root.left)\\n            if root.right:\\n                parent[root.right] = root\\n                helper(root.right)\\n        helper(root)\\n\\n        q = collections.deque()\\n        q.append(self.startNode)\\n        dis = -1\\n        seen = set()\\n        seen.add(self.startNode.val)\\n        while q:\\n            size = len(q)\\n            for i in range(size):\\n                cur = q.popleft()\\n                if cur.left and (cur.left.val not in seen):\\n                    seen.add(cur.left.val)\\n                    q.append(cur.left)\\n                if cur.right and (cur.right.val not in seen):\\n                    seen.add(cur.right.val)\\n                    q.append(cur.right)\\n                if cur in parent and (parent[cur].val not in seen):\\n                    seen.add(parent[cur].val)\\n                    q.append(parent[cur])\\n            dis += 1\\n        return dis\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n    def amountOfTime(self, root, start):\\n        \"\"\"\\n        :type root: Optional[TreeNode]\\n        :type start: int\\n        :rtype: int\\n        \"\"\"\\n        self.startNode = None\\n        parent = {}\\n        def helper(root):\\n            if not root:\\n                return\\n            if root.val == start:\\n                self.startNode = root\\n            if root.left:\\n                parent[root.left] = root\\n                helper(root.left)\\n            if root.right:\\n                parent[root.right] = root\\n                helper(root.right)\\n        helper(root)\\n\\n        q = collections.deque()\\n        q.append(self.startNode)\\n        dis = -1\\n        seen = set()\\n        seen.add(self.startNode.val)\\n        while q:\\n            size = len(q)\\n            for i in range(size):\\n                cur = q.popleft()\\n                if cur.left and (cur.left.val not in seen):\\n                    seen.add(cur.left.val)\\n                    q.append(cur.left)\\n                if cur.right and (cur.right.val not in seen):\\n                    seen.add(cur.right.val)\\n                    q.append(cur.right)\\n                if cur in parent and (parent[cur].val not in seen):\\n                    seen.add(parent[cur].val)\\n                    q.append(parent[cur])\\n            dis += 1\\n        return dis\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2457028,
                "title": "java-solution",
                "content": "\\tpublic int amountOfTime(TreeNode root, int start) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        dfs(root, null, map);\\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(start);\\n        visited.add(start);\\n        int cnt = map.entrySet().size();\\n        int res = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                int cur = q.poll();\\n                cnt--;\\n                if(cnt == 0)\\n                    return res;\\n                for(int nei : map.getOrDefault(cur, new HashSet<>())){\\n                    if(visited.add(nei))\\n                        q.offer(nei);\\n                }\\n            }\\n            res++;\\n        }\\n        return 0;\\n    }\\n    \\n    void dfs(TreeNode cur, TreeNode parent, Map<Integer, Set<Integer>> map){\\n        if(cur == null)\\n            return;\\n        if(parent != null) {\\n            map.putIfAbsent(parent.val, new HashSet<>());\\n            map.get(parent.val).add(cur.val);\\n            map.putIfAbsent(cur.val, new HashSet<>());\\n            map.get(cur.val).add(parent.val);\\n        }\\n        dfs(cur.left, cur, map);\\n        dfs(cur.right, cur, map);\\n    }",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "\\tpublic int amountOfTime(TreeNode root, int start) {\\n        Map<Integer, Set<Integer>> map = new HashMap<>();\\n        dfs(root, null, map);\\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> q = new LinkedList<>();\\n        q.offer(start);\\n        visited.add(start);\\n        int cnt = map.entrySet().size();\\n        int res = 0;\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            for(int i=0;i<size;i++){\\n                int cur = q.poll();\\n                cnt--;\\n                if(cnt == 0)\\n                    return res;\\n                for(int nei : map.getOrDefault(cur, new HashSet<>())){\\n                    if(visited.add(nei))\\n                        q.offer(nei);\\n                }\\n            }\\n            res++;\\n        }\\n        return 0;\\n    }\\n    \\n    void dfs(TreeNode cur, TreeNode parent, Map<Integer, Set<Integer>> map){\\n        if(cur == null)\\n            return;\\n        if(parent != null) {\\n            map.putIfAbsent(parent.val, new HashSet<>());\\n            map.get(parent.val).add(cur.val);\\n            map.putIfAbsent(cur.val, new HashSet<>());\\n            map.get(cur.val).add(parent.val);\\n        }\\n        dfs(cur.left, cur, map);\\n        dfs(cur.right, cur, map);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2456981,
                "title": "bfs-solution-with-2-pass",
                "content": "```\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        if(root.left == null && root.right == null) return 0;\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        Queue<TreeNode> q = new ArrayDeque<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-->0){\\n                TreeNode remove = q.remove();\\n                // System.out.printn()\\n                if(remove.left!= null){\\n                    List<Integer> temp = map.getOrDefault(remove.val, new ArrayList<Integer>());\\n                    temp.add(remove.left.val);\\n                    map.put(remove.val, temp);\\n                    temp = map.getOrDefault(remove.left.val, new ArrayList<Integer>());\\n                    temp.add(remove.val);\\n                    map.put(remove.left.val, temp);\\n                    q.add(remove.left);\\n                } \\n                if(remove.right!= null){\\n                    List<Integer> temp = map.getOrDefault(remove.val, new ArrayList<Integer>());\\n                    temp.add(remove.right.val);\\n                    map.put(remove.val, temp);\\n                    temp = map.getOrDefault(remove.right.val, new ArrayList<Integer>());\\n                    temp.add(remove.val);\\n                    map.put(remove.right.val, temp);\\n                    q.add(remove.right);\\n                }\\n            }\\n        }\\n        Set<Integer> visited = new HashSet<>();\\n        int result = -1;\\n        Queue<Integer> qq = new ArrayDeque<Integer>();\\n        qq.add(start);\\n        while(!qq.isEmpty()){\\n            int size = qq.size();\\n            result++;\\n            while(size-->0){\\n                int remove = qq.remove();\\n                visited.add(remove);\\n                for(int adj: map.get(remove)){\\n                    if(!visited.contains(adj)){\\n                        qq.add(adj);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```\\nSo annoyed that didn\\'t used adjList during contest.\\nComplexity:\\n\\tTime = O(2n)\\n\\tSpace = O(2n)\\n",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        if(root.left == null && root.right == null) return 0;\\n        HashMap<Integer, List<Integer>> map = new HashMap<>();\\n        Queue<TreeNode> q = new ArrayDeque<>();\\n        q.add(root);\\n        while(!q.isEmpty()){\\n            int size = q.size();\\n            while(size-->0){\\n                TreeNode remove = q.remove();\\n                // System.out.printn()\\n                if(remove.left!= null){\\n                    List<Integer> temp = map.getOrDefault(remove.val, new ArrayList<Integer>());\\n                    temp.add(remove.left.val);\\n                    map.put(remove.val, temp);\\n                    temp = map.getOrDefault(remove.left.val, new ArrayList<Integer>());\\n                    temp.add(remove.val);\\n                    map.put(remove.left.val, temp);\\n                    q.add(remove.left);\\n                } \\n                if(remove.right!= null){\\n                    List<Integer> temp = map.getOrDefault(remove.val, new ArrayList<Integer>());\\n                    temp.add(remove.right.val);\\n                    map.put(remove.val, temp);\\n                    temp = map.getOrDefault(remove.right.val, new ArrayList<Integer>());\\n                    temp.add(remove.val);\\n                    map.put(remove.right.val, temp);\\n                    q.add(remove.right);\\n                }\\n            }\\n        }\\n        Set<Integer> visited = new HashSet<>();\\n        int result = -1;\\n        Queue<Integer> qq = new ArrayDeque<Integer>();\\n        qq.add(start);\\n        while(!qq.isEmpty()){\\n            int size = qq.size();\\n            result++;\\n            while(size-->0){\\n                int remove = qq.remove();\\n                visited.add(remove);\\n                for(int adj: map.get(remove)){\\n                    if(!visited.contains(adj)){\\n                        qq.add(adj);\\n                    }\\n                }\\n            }\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456765,
                "title": "c-easy-solution",
                "content": "```\\n#define BinaryTreeNode TreeNode\\n#define data val\\nclass Solution {\\npublic:\\n    int findMaxDistance(map<BinaryTreeNode*, BinaryTreeNode*> &mpp, BinaryTreeNode* target) {\\n        queue<BinaryTreeNode*> q; \\n        q.push(target); \\n        map<BinaryTreeNode*,int> vis; \\n        vis[target] = 1;\\n        int maxi = 0; \\n        while(!q.empty()) {\\n            int sz = q.size();\\n            int fl = 0; \\n            for(int i = 0;i<sz;i++) {\\n                auto node = q.front();\\n                q.pop();\\n                if(node->left && !vis[node->left]) {\\n                    fl = 1; \\n                    vis[node->left] = 1; \\n                    q.push(node->left); \\n                }\\n                if(node->right && !vis[node->right]) {\\n                    fl = 1; \\n                    vis[node->right] = 1; \\n                    q.push(node->right); \\n                }\\n\\n                if(mpp[node] && !vis[mpp[node]]) {\\n                    fl = 1; \\n                    vis[mpp[node]] = 1; \\n                    q.push(mpp[node]); \\n                } \\n            }\\n            if(fl) maxi++; \\n        }\\n        return maxi; \\n    }\\n    BinaryTreeNode* bfsToMapParents(BinaryTreeNode* root, \\n                                         map<BinaryTreeNode*, BinaryTreeNode*> &mpp, int start) {\\n        queue<BinaryTreeNode*> q; \\n        q.push(root); \\n        BinaryTreeNode* res; \\n        while(!q.empty()) {\\n            BinaryTreeNode* node = q.front(); \\n            if(node->data == start) res = node; \\n            q.pop(); \\n            if(node->left) {\\n                mpp[node->left] = node; \\n                q.push(node->left); \\n            }\\n            if(node->right) {\\n                mpp[node->right] = node;\\n                q.push(node->right); \\n            }\\n        }\\n        return res; \\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        map<BinaryTreeNode*, BinaryTreeNode*> mpp; \\n        BinaryTreeNode* target = bfsToMapParents(root, mpp, start); \\n        int maxi = findMaxDistance(mpp, target); \\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n#define BinaryTreeNode TreeNode\\n#define data val\\nclass Solution {\\npublic:\\n    int findMaxDistance(map<BinaryTreeNode*, BinaryTreeNode*> &mpp, BinaryTreeNode* target) {\\n        queue<BinaryTreeNode*> q; \\n        q.push(target); \\n        map<BinaryTreeNode*,int> vis; \\n        vis[target] = 1;\\n        int maxi = 0; \\n        while(!q.empty()) {\\n            int sz = q.size();\\n            int fl = 0; \\n            for(int i = 0;i<sz;i++) {\\n                auto node = q.front();\\n                q.pop();\\n                if(node->left && !vis[node->left]) {\\n                    fl = 1; \\n                    vis[node->left] = 1; \\n                    q.push(node->left); \\n                }\\n                if(node->right && !vis[node->right]) {\\n                    fl = 1; \\n                    vis[node->right] = 1; \\n                    q.push(node->right); \\n                }\\n\\n                if(mpp[node] && !vis[mpp[node]]) {\\n                    fl = 1; \\n                    vis[mpp[node]] = 1; \\n                    q.push(mpp[node]); \\n                } \\n            }\\n            if(fl) maxi++; \\n        }\\n        return maxi; \\n    }\\n    BinaryTreeNode* bfsToMapParents(BinaryTreeNode* root, \\n                                         map<BinaryTreeNode*, BinaryTreeNode*> &mpp, int start) {\\n        queue<BinaryTreeNode*> q; \\n        q.push(root); \\n        BinaryTreeNode* res; \\n        while(!q.empty()) {\\n            BinaryTreeNode* node = q.front(); \\n            if(node->data == start) res = node; \\n            q.pop(); \\n            if(node->left) {\\n                mpp[node->left] = node; \\n                q.push(node->left); \\n            }\\n            if(node->right) {\\n                mpp[node->right] = node;\\n                q.push(node->right); \\n            }\\n        }\\n        return res; \\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        map<BinaryTreeNode*, BinaryTreeNode*> mpp; \\n        BinaryTreeNode* target = bfsToMapParents(root, mpp, start); \\n        int maxi = findMaxDistance(mpp, target); \\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456607,
                "title": "c-simple-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int TimeTaken(TreeNode* end,map<TreeNode*,TreeNode*>& par)\\n    {\\n        map<TreeNode*,bool> vis;\\n        queue<TreeNode*> q;\\n        q.push(end);\\n        vis[end]=true;\\n        int time=0;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            int flag=0;\\n            \\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                vis[node]=true;\\n                \\n                // left child\\n                if(node->left && !vis[node->left])\\n                {\\n                    flag=1;\\n                    q.push(node->left);\\n                    vis[node->left]=true;\\n                }\\n                \\n                // right child\\n                if(node->right && !vis[node->right])\\n                {\\n                    flag=1;\\n                    q.push(node->right);\\n                    vis[node->right]=true;\\n                }\\n                \\n                // parent\\n                if(par[node] && !vis[par[node]])\\n                {\\n                    flag=1;\\n                    q.push(par[node]);\\n                    vis[par[node]]=true;\\n                }\\n            }\\n            \\n            if(flag) time++;            // if we have any node ( child , parent , right ) then increase count by 1\\n        }\\n        return time;\\n    }\\n    \\n    TreeNode* Parent(TreeNode*& root,map<TreeNode*,TreeNode*>& par,int start)\\n    {\\n        TreeNode* target;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            \\n            if(node->val==start)\\n                target=node;                  // starting node\\n            \\n            // left child\\n            if(node->left)\\n            { \\n                q.push(node->left);\\n                par[node->left] = node;\\n            }\\n            \\n            // right child\\n            if(node->right)\\n            {\\n                q.push(node->right);\\n                par[node->right] = node;\\n            }\\n        }\\n        return target;\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) \\n    {\\n        map<TreeNode*,TreeNode*> par;\\n        TreeNode* end = Parent(root,par,start);\\n        int mx = TimeTaken(end,par);\\n        return mx;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int TimeTaken(TreeNode* end,map<TreeNode*,TreeNode*>& par)\\n    {\\n        map<TreeNode*,bool> vis;\\n        queue<TreeNode*> q;\\n        q.push(end);\\n        vis[end]=true;\\n        int time=0;\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            int flag=0;\\n            \\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode* node = q.front();\\n                q.pop();\\n                vis[node]=true;\\n                \\n                // left child\\n                if(node->left && !vis[node->left])\\n                {\\n                    flag=1;\\n                    q.push(node->left);\\n                    vis[node->left]=true;\\n                }\\n                \\n                // right child\\n                if(node->right && !vis[node->right])\\n                {\\n                    flag=1;\\n                    q.push(node->right);\\n                    vis[node->right]=true;\\n                }\\n                \\n                // parent\\n                if(par[node] && !vis[par[node]])\\n                {\\n                    flag=1;\\n                    q.push(par[node]);\\n                    vis[par[node]]=true;\\n                }\\n            }\\n            \\n            if(flag) time++;            // if we have any node ( child , parent , right ) then increase count by 1\\n        }\\n        return time;\\n    }\\n    \\n    TreeNode* Parent(TreeNode*& root,map<TreeNode*,TreeNode*>& par,int start)\\n    {\\n        TreeNode* target;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            \\n            if(node->val==start)\\n                target=node;                  // starting node\\n            \\n            // left child\\n            if(node->left)\\n            { \\n                q.push(node->left);\\n                par[node->left] = node;\\n            }\\n            \\n            // right child\\n            if(node->right)\\n            {\\n                q.push(node->right);\\n                par[node->right] = node;\\n            }\\n        }\\n        return target;\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) \\n    {\\n        map<TreeNode*,TreeNode*> par;\\n        TreeNode* end = Parent(root,par,start);\\n        int mx = TimeTaken(end,par);\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4070926,
                "title": "java-bfs-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\nO(N) overall\\n\\n- Space complexity:\\nO(N) overall\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static TreeNode parent_link(TreeNode root,Map<TreeNode,TreeNode>map,int start){\\n\\t\\tQueue<TreeNode>q=new LinkedList<>();\\n\\t\\tTreeNode res=null;\\n\\t\\tq.add(root);\\n\\n\\t\\twhile(!q.isEmpty()){\\n\\t\\t\\tTreeNode cur=q.poll();\\n\\t\\t\\tif(cur.val==start) res=cur;\\n\\n\\t\\t\\tif(cur.left!=null){\\n\\t\\t\\t\\tmap.put(cur.left,cur);\\n\\t\\t\\t\\tq.add(cur.left);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(cur.right!=null){\\n\\t\\t\\t\\tmap.put(cur.right,cur);\\n\\t\\t\\t\\tq.add(cur.right);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n    public int amountOfTime(TreeNode root, int start) {\\n        Map<TreeNode,TreeNode>parent_map=new HashMap<>();\\n        TreeNode target=parent_link(root,parent_map,start);\\n\\t\\t\\n\\t\\tMap<TreeNode,Boolean>visit=new HashMap<>();\\n\\t\\tQueue<TreeNode>qu=new LinkedList<>();\\n\\n\\t\\tvisit.put(target,true);\\n\\t\\tqu.add(target);\\n\\n\\t\\tint minTime=0;\\n\\t\\twhile(!qu.isEmpty()){\\n\\t\\t\\tint size=qu.size();\\n\\n\\t\\t\\tint flag=0;\\n\\n\\t\\t\\tfor(int i=0;i<size;i++){\\n\\t\\t\\t\\tTreeNode cur=qu.poll();\\n\\n\\t\\t\\t\\tif(parent_map.get(cur)!=null && visit.get(parent_map.get(cur))==null){\\n\\t\\t\\t\\t\\tflag=1;\\n\\t\\t\\t\\t\\tvisit.put(parent_map.get(cur),true);\\n\\t\\t\\t\\t\\tqu.add(parent_map.get(cur));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(cur.left!=null && visit.get(cur.left)==null){\\n\\t\\t\\t\\t\\tflag=1;\\n\\t\\t\\t\\t\\tvisit.put(cur.left,true);\\n\\t\\t\\t\\t\\tqu.add(cur.left);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(cur.right!=null && visit.get(cur.right)==null){\\n\\t\\t\\t\\t\\tflag=1;\\n\\t\\t\\t\\t\\tvisit.put(cur.right,true);\\n\\t\\t\\t\\t\\tqu.add(cur.right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(flag==1) minTime++;\\n\\t\\t}\\n\\t\\treturn minTime;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public static TreeNode parent_link(TreeNode root,Map<TreeNode,TreeNode>map,int start){\\n\\t\\tQueue<TreeNode>q=new LinkedList<>();\\n\\t\\tTreeNode res=null;\\n\\t\\tq.add(root);\\n\\n\\t\\twhile(!q.isEmpty()){\\n\\t\\t\\tTreeNode cur=q.poll();\\n\\t\\t\\tif(cur.val==start) res=cur;\\n\\n\\t\\t\\tif(cur.left!=null){\\n\\t\\t\\t\\tmap.put(cur.left,cur);\\n\\t\\t\\t\\tq.add(cur.left);\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(cur.right!=null){\\n\\t\\t\\t\\tmap.put(cur.right,cur);\\n\\t\\t\\t\\tq.add(cur.right);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn res;\\n\\t}\\n\\n    public int amountOfTime(TreeNode root, int start) {\\n        Map<TreeNode,TreeNode>parent_map=new HashMap<>();\\n        TreeNode target=parent_link(root,parent_map,start);\\n\\t\\t\\n\\t\\tMap<TreeNode,Boolean>visit=new HashMap<>();\\n\\t\\tQueue<TreeNode>qu=new LinkedList<>();\\n\\n\\t\\tvisit.put(target,true);\\n\\t\\tqu.add(target);\\n\\n\\t\\tint minTime=0;\\n\\t\\twhile(!qu.isEmpty()){\\n\\t\\t\\tint size=qu.size();\\n\\n\\t\\t\\tint flag=0;\\n\\n\\t\\t\\tfor(int i=0;i<size;i++){\\n\\t\\t\\t\\tTreeNode cur=qu.poll();\\n\\n\\t\\t\\t\\tif(parent_map.get(cur)!=null && visit.get(parent_map.get(cur))==null){\\n\\t\\t\\t\\t\\tflag=1;\\n\\t\\t\\t\\t\\tvisit.put(parent_map.get(cur),true);\\n\\t\\t\\t\\t\\tqu.add(parent_map.get(cur));\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(cur.left!=null && visit.get(cur.left)==null){\\n\\t\\t\\t\\t\\tflag=1;\\n\\t\\t\\t\\t\\tvisit.put(cur.left,true);\\n\\t\\t\\t\\t\\tqu.add(cur.left);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\tif(cur.right!=null && visit.get(cur.right)==null){\\n\\t\\t\\t\\t\\tflag=1;\\n\\t\\t\\t\\t\\tvisit.put(cur.right,true);\\n\\t\\t\\t\\t\\tqu.add(cur.right);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\n\\t\\t\\tif(flag==1) minTime++;\\n\\t\\t}\\n\\t\\treturn minTime;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3988638,
                "title": "c-bfs-using-parent-hashmaps",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* epicenter = nullptr;\\n    \\n    void preorder(TreeNode* root, unordered_map<TreeNode*,TreeNode*>&parent,int start)\\n    {\\n        if(!root) return;\\n        if(root->val==start) epicenter=root;\\n        if(root->left)  parent[root->left]=root;\\n        if(root->right) parent[root->right]=root;\\n        preorder(root->left,parent,start);\\n        preorder(root->right,parent,start);\\n    }\\n    \\n    int bfs(TreeNode* root,unordered_map<TreeNode*,TreeNode*>&parent)\\n    {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        root->val=-1;\\n        int timee=0;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            timee++;\\n            while(sz--)\\n            {\\n                TreeNode* x = q.front();\\n                q.pop();\\n                \\n                if(x->left)\\n                {\\n                    if(x->left->val != -1)\\n                    {\\n                        q.push(x->left);\\n                        x->left->val = -1;\\n                    }\\n                }\\n                \\n                if(x->right)\\n                {\\n                    if(x->right->val != -1)\\n                    {\\n                        q.push(x->right);\\n                        x->right->val = -1;\\n                    }\\n                }\\n                \\n                if(parent[x])\\n                {\\n                    if(parent[x]->val != -1)\\n                    {\\n                        q.push(parent[x]);\\n                        parent[x]->val = -1;\\n                    }\\n                }\\n            }\\n        }\\n        return timee-1;\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<TreeNode*,TreeNode*>parent;\\n        parent[root]=nullptr;\\n        preorder(root,parent,start);\\n        \\n        return bfs(epicenter,parent);\\n        \\n    }\\n    \\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    TreeNode* epicenter = nullptr;\\n    \\n    void preorder(TreeNode* root, unordered_map<TreeNode*,TreeNode*>&parent,int start)\\n    {\\n        if(!root) return;\\n        if(root->val==start) epicenter=root;\\n        if(root->left)  parent[root->left]=root;\\n        if(root->right) parent[root->right]=root;\\n        preorder(root->left,parent,start);\\n        preorder(root->right,parent,start);\\n    }\\n    \\n    int bfs(TreeNode* root,unordered_map<TreeNode*,TreeNode*>&parent)\\n    {\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        root->val=-1;\\n        int timee=0;\\n        while(!q.empty())\\n        {\\n            int sz=q.size();\\n            timee++;\\n            while(sz--)\\n            {\\n                TreeNode* x = q.front();\\n                q.pop();\\n                \\n                if(x->left)\\n                {\\n                    if(x->left->val != -1)\\n                    {\\n                        q.push(x->left);\\n                        x->left->val = -1;\\n                    }\\n                }\\n                \\n                if(x->right)\\n                {\\n                    if(x->right->val != -1)\\n                    {\\n                        q.push(x->right);\\n                        x->right->val = -1;\\n                    }\\n                }\\n                \\n                if(parent[x])\\n                {\\n                    if(parent[x]->val != -1)\\n                    {\\n                        q.push(parent[x]);\\n                        parent[x]->val = -1;\\n                    }\\n                }\\n            }\\n        }\\n        return timee-1;\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<TreeNode*,TreeNode*>parent;\\n        parent[root]=nullptr;\\n        preorder(root,parent,start);\\n        \\n        return bfs(epicenter,parent);\\n        \\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3984177,
                "title": "alternative-approach",
                "content": "# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n    O(n)\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void markParent(TreeNode* root,unordered_map<TreeNode*,TreeNode*>& parent) {\\n        queue<TreeNode*> q;\\n\\n        q.push(root);\\n\\n        while(!q.empty()) {\\n            TreeNode* curr = q.front();\\n            q.pop();\\n\\n            if(curr->left) {\\n                q.push(curr->left);\\n                parent[curr->left] = curr; \\n            }\\n\\n            if(curr->right) {\\n                q.push(curr->right);\\n                parent[curr->right] = curr;\\n            }\\n        }\\n    }\\n\\n    TreeNode* findTarget(TreeNode* root, int start) {\\n        if (root == nullptr)\\n            return nullptr;\\n\\n        if (root->val == start)\\n            return root;\\n\\n        TreeNode* leftResult = findTarget(root->left, start);\\n        if (leftResult != nullptr)\\n            return leftResult;\\n\\n        return findTarget(root->right, start);\\n}\\n\\n\\n    int amountOfTime(TreeNode* root, int start) {\\n        if(root->left == NULL && root->right == NULL && root->val == start)\\n            return 0;\\n\\n        unordered_map<TreeNode*,TreeNode*> parent;\\n\\n        markParent(root,parent);\\n\\n        TreeNode* target = findTarget(root,start);\\n\\n        if(target == NULL)\\n            return 0;\\n\\n        unordered_map<TreeNode*,bool> visited;\\n\\n        queue<TreeNode*> q;\\n\\n        q.push(target);\\n        visited[target] = true;\\n        int minutes = 0;\\n\\n\\n        while(!q.empty()) {\\n            int size = q.size();\\n\\n            for(int i=0;i<size;i++) {\\n                TreeNode* curr = q.front();\\n                q.pop();\\n\\n                \\n\\n                if(curr->left && !visited[curr->left]) {\\n                    q.push(curr->left);\\n                    visited[curr->left] = true;\\n                }\\n\\n                if(curr->right && !visited[curr->right]) {\\n                    q.push(curr->right);\\n                    visited[curr->right] = true;\\n                }\\n\\n                if(parent[curr] && !visited[parent[curr]]) {\\n                    q.push(parent[curr]);\\n                    visited[parent[curr]] = true;\\n                }\\n            }\\n\\n            minutes++;\\n        }\\n\\n\\n        return minutes-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void markParent(TreeNode* root,unordered_map<TreeNode*,TreeNode*>& parent) {\\n        queue<TreeNode*> q;\\n\\n        q.push(root);\\n\\n        while(!q.empty()) {\\n            TreeNode* curr = q.front();\\n            q.pop();\\n\\n            if(curr->left) {\\n                q.push(curr->left);\\n                parent[curr->left] = curr; \\n            }\\n\\n            if(curr->right) {\\n                q.push(curr->right);\\n                parent[curr->right] = curr;\\n            }\\n        }\\n    }\\n\\n    TreeNode* findTarget(TreeNode* root, int start) {\\n        if (root == nullptr)\\n            return nullptr;\\n\\n        if (root->val == start)\\n            return root;\\n\\n        TreeNode* leftResult = findTarget(root->left, start);\\n        if (leftResult != nullptr)\\n            return leftResult;\\n\\n        return findTarget(root->right, start);\\n}\\n\\n\\n    int amountOfTime(TreeNode* root, int start) {\\n        if(root->left == NULL && root->right == NULL && root->val == start)\\n            return 0;\\n\\n        unordered_map<TreeNode*,TreeNode*> parent;\\n\\n        markParent(root,parent);\\n\\n        TreeNode* target = findTarget(root,start);\\n\\n        if(target == NULL)\\n            return 0;\\n\\n        unordered_map<TreeNode*,bool> visited;\\n\\n        queue<TreeNode*> q;\\n\\n        q.push(target);\\n        visited[target] = true;\\n        int minutes = 0;\\n\\n\\n        while(!q.empty()) {\\n            int size = q.size();\\n\\n            for(int i=0;i<size;i++) {\\n                TreeNode* curr = q.front();\\n                q.pop();\\n\\n                \\n\\n                if(curr->left && !visited[curr->left]) {\\n                    q.push(curr->left);\\n                    visited[curr->left] = true;\\n                }\\n\\n                if(curr->right && !visited[curr->right]) {\\n                    q.push(curr->right);\\n                    visited[curr->right] = true;\\n                }\\n\\n                if(parent[curr] && !visited[parent[curr]]) {\\n                    q.push(parent[curr]);\\n                    visited[parent[curr]] = true;\\n                }\\n            }\\n\\n            minutes++;\\n        }\\n\\n\\n        return minutes-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3958146,
                "title": "build-a-graph-from-the-given-tree-use-bfs-to-get-the-time-to-infect-the-nodes",
                "content": "# Intuition\\nsince we have to traverse back in the tree[top and bottom traversal]\\nWe use Hashing. \\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\nWe can make use of a hashmap where we make the children and parent mapping.\\nUse BFS for traversing the node. Insert the currently visited node to visited set increment the time by 1 each time you visit a node.Do this recursively till the queue is empty\\nat last return the time.\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n        dict_ = defaultdict(list)\\n        def buildgraph(cur,parent):\\n            if cur and parent:\\n                dict_[cur.val].append(parent.val)\\n                dict_[parent.val].append(cur.val)\\n            if cur.left:\\n                buildgraph(cur.left,cur)\\n            if cur.right:\\n                buildgraph(cur.right,cur)\\n        buildgraph(root,0)\\n        \\n        infected = set()\\n        queue = [(start,0)]\\n        while queue:\\n            node,t=queue.pop(0)\\n            infected.add(node)\\n            for nei in dict_[node]:\\n                if nei not in infected:\\n                    queue.append((nei,t+1))\\n                    \\n        return t\\n\\n\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n        dict_ = defaultdict(list)\\n        def buildgraph(cur,parent):\\n            if cur and parent:\\n                dict_[cur.val].append(parent.val)\\n                dict_[parent.val].append(cur.val)\\n            if cur.left:\\n                buildgraph(cur.left,cur)\\n            if cur.right:\\n                buildgraph(cur.right,cur)\\n        buildgraph(root,0)\\n        \\n        infected = set()\\n        queue = [(start,0)]\\n        while queue:\\n            node,t=queue.pop(0)\\n            infected.add(node)\\n            for nei in dict_[node]:\\n                if nei not in infected:\\n                    queue.append((nei,t+1))\\n                    \\n        return t\\n\\n\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3754685,
                "title": "parent-memorization-and-bfs",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n       TreeNode *tar;\\n    void findTargetNode(TreeNode *root, int target)\\n    {\\n        if (root == nullptr)\\n        {\\n            return;\\n        }\\n\\n        if (root->val == target)\\n        {\\n            tar = root;\\n            return;\\n        }\\n\\n        findTargetNode(root->left, target);\\n        findTargetNode(root->right, target);\\n    }\\n\\n    void makeParents(TreeNode *root, unordered_map<TreeNode *, TreeNode *> &parent)\\n    {\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        while (!q.empty())\\n        {\\n            TreeNode *node = q.front();\\n            q.pop();\\n\\n            if (node->left)\\n            {\\n                parent[node->left] = node;\\n                q.push(node->left);\\n            }\\n            if (node->right)\\n            {\\n                parent[node->right] = node;\\n                q.push(node->right);\\n            }\\n        }\\n    }\\n\\n    int amountOfTime(TreeNode *root, int start)\\n    {\\n        if (!root)\\n            return 0;\\n\\n        unordered_map<TreeNode *, TreeNode *> parent;\\n        makeParents(root, parent);\\n        findTargetNode(root, start);\\n\\n        queue<pair<TreeNode *, int>> q;\\n        unordered_map<TreeNode *, bool> visited;\\n        q.push({tar, 0});\\n        visited[tar] = 1;\\n        int ans = 0;\\n\\n        while (!q.empty())\\n        {\\n            TreeNode *node = q.front().first;\\n            int time = q.front().second;\\n            q.pop();\\n            ans = max(ans, time);\\n\\n            // left\\n            if (node->left and !visited[node->left])\\n            {\\n                q.push({node->left, time + 1});\\n                visited[node->left] = 1;\\n            }\\n\\n            // right\\n            if (node->right and !visited[node->right])\\n            {\\n                q.push({node->right, time + 1});\\n                visited[node->right] = 1;\\n            }\\n\\n            // parent\\n            if (parent.find(node) != parent.end() and !visited[parent[node]])\\n            {\\n                q.push({parent[node], time + 1});\\n                visited[parent[node]] = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n       TreeNode *tar;\\n    void findTargetNode(TreeNode *root, int target)\\n    {\\n        if (root == nullptr)\\n        {\\n            return;\\n        }\\n\\n        if (root->val == target)\\n        {\\n            tar = root;\\n            return;\\n        }\\n\\n        findTargetNode(root->left, target);\\n        findTargetNode(root->right, target);\\n    }\\n\\n    void makeParents(TreeNode *root, unordered_map<TreeNode *, TreeNode *> &parent)\\n    {\\n        queue<TreeNode *> q;\\n        q.push(root);\\n\\n        while (!q.empty())\\n        {\\n            TreeNode *node = q.front();\\n            q.pop();\\n\\n            if (node->left)\\n            {\\n                parent[node->left] = node;\\n                q.push(node->left);\\n            }\\n            if (node->right)\\n            {\\n                parent[node->right] = node;\\n                q.push(node->right);\\n            }\\n        }\\n    }\\n\\n    int amountOfTime(TreeNode *root, int start)\\n    {\\n        if (!root)\\n            return 0;\\n\\n        unordered_map<TreeNode *, TreeNode *> parent;\\n        makeParents(root, parent);\\n        findTargetNode(root, start);\\n\\n        queue<pair<TreeNode *, int>> q;\\n        unordered_map<TreeNode *, bool> visited;\\n        q.push({tar, 0});\\n        visited[tar] = 1;\\n        int ans = 0;\\n\\n        while (!q.empty())\\n        {\\n            TreeNode *node = q.front().first;\\n            int time = q.front().second;\\n            q.pop();\\n            ans = max(ans, time);\\n\\n            // left\\n            if (node->left and !visited[node->left])\\n            {\\n                q.push({node->left, time + 1});\\n                visited[node->left] = 1;\\n            }\\n\\n            // right\\n            if (node->right and !visited[node->right])\\n            {\\n                q.push({node->right, time + 1});\\n                visited[node->right] = 1;\\n            }\\n\\n            // parent\\n            if (parent.find(node) != parent.end() and !visited[parent[node]])\\n            {\\n                q.push({parent[node], time + 1});\\n                visited[parent[node]] = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3749768,
                "title": "amount-of-time-for-binary-tree-to-be-infected-c-bfs-solution-using-bidirectional-graph",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nstatic auto speedup = [](){\\n    ios_base::sync_with_stdio(false);\\n    cout.tie(NULL);\\n    cin.tie(NULL);\\n    return NULL;\\n}();\\n#define um unordered_map\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    void build(TreeNode* root, um<int, vector<int>>& graph){\\n        if (root->left){\\n            graph[root->val].pb(root->left->val);\\n            graph[root->left->val].pb(root->val);\\n            build(root->left, graph);\\n        }\\n        if (root->right){\\n            graph[root->val].pb(root->right->val);\\n            graph[root->right->val].pb(root->val);\\n            build(root->right, graph);\\n        }\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        um<int, vector<int>> graph;\\n        um<int, bool> visited;\\n        build(root, graph);\\n\\n        int minute = 0;\\n        queue<int> q;\\n        q.push(start);\\n        while (!q.empty()){\\n            int n = q.size();\\n            while (n--){\\n                int curr = q.front();\\n                q.pop();\\n                visited[curr] = true;\\n                for (auto x : graph[curr]){\\n                    if (!visited[x])\\n                        q.push(x);\\n                }\\n            }\\n            minute += 1;\\n        }\\n        return minute - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nstatic auto speedup = [](){\\n    ios_base::sync_with_stdio(false);\\n    cout.tie(NULL);\\n    cin.tie(NULL);\\n    return NULL;\\n}();\\n#define um unordered_map\\n#define pb push_back\\n\\nclass Solution {\\npublic:\\n    void build(TreeNode* root, um<int, vector<int>>& graph){\\n        if (root->left){\\n            graph[root->val].pb(root->left->val);\\n            graph[root->left->val].pb(root->val);\\n            build(root->left, graph);\\n        }\\n        if (root->right){\\n            graph[root->val].pb(root->right->val);\\n            graph[root->right->val].pb(root->val);\\n            build(root->right, graph);\\n        }\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        um<int, vector<int>> graph;\\n        um<int, bool> visited;\\n        build(root, graph);\\n\\n        int minute = 0;\\n        queue<int> q;\\n        q.push(start);\\n        while (!q.empty()){\\n            int n = q.size();\\n            while (n--){\\n                int curr = q.front();\\n                q.pop();\\n                visited[curr] = true;\\n                for (auto x : graph[curr]){\\n                    if (!visited[x])\\n                        q.push(x);\\n                }\\n            }\\n            minute += 1;\\n        }\\n        return minute - 1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3619486,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, TreeNode*> parent;\\n    int time = 0;\\n    TreeNode* node = NULL;\\n    unordered_map<TreeNode*,bool> visited;\\n    queue<TreeNode*> q;\\n\\n    void addParent(TreeNode* root, TreeNode* pnt, int target)\\n    {\\n        if(!root)\\n            return;\\n        \\n        if(root->val == target)\\n            node = root;\\n\\n        parent[root] = pnt;\\n        addParent(root->left,root,target); \\n        addParent(root->right,root,target); \\n    }\\n\\n    void burnTree()\\n    {\\n        q.push(node);\\n        visited[node] = true;\\n        while(!q.empty())\\n        {\\n            bool flag = false;\\n            int size = q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                auto front = q.front();\\n                q.pop();\\n                if(front->left && !visited[front->left])\\n                {\\n                    flag = true;\\n                    q.push(front->left);\\n                    visited[front->left] = true; \\n                }\\n                if(front->right && !visited[front->right])\\n                {\\n                    flag = true;\\n                    q.push(front->right);\\n                    visited[front->right] = true; \\n                }\\n                if(!visited[parent[front]])\\n                {\\n                    flag = true;\\n                    q.push(parent[front]);\\n                    visited[parent[front]] = true; \\n                }\\n                    \\n            }\\n            if(flag)\\n                time++;\\n        }\\n    }\\n    int amountOfTime(TreeNode* root, int start) \\n    {\\n        addParent(root, root, start);\\n        burnTree();\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    unordered_map<TreeNode*, TreeNode*> parent;\\n    int time = 0;\\n    TreeNode* node = NULL;\\n    unordered_map<TreeNode*,bool> visited;\\n    queue<TreeNode*> q;\\n\\n    void addParent(TreeNode* root, TreeNode* pnt, int target)\\n    {\\n        if(!root)\\n            return;\\n        \\n        if(root->val == target)\\n            node = root;\\n\\n        parent[root] = pnt;\\n        addParent(root->left,root,target); \\n        addParent(root->right,root,target); \\n    }\\n\\n    void burnTree()\\n    {\\n        q.push(node);\\n        visited[node] = true;\\n        while(!q.empty())\\n        {\\n            bool flag = false;\\n            int size = q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                auto front = q.front();\\n                q.pop();\\n                if(front->left && !visited[front->left])\\n                {\\n                    flag = true;\\n                    q.push(front->left);\\n                    visited[front->left] = true; \\n                }\\n                if(front->right && !visited[front->right])\\n                {\\n                    flag = true;\\n                    q.push(front->right);\\n                    visited[front->right] = true; \\n                }\\n                if(!visited[parent[front]])\\n                {\\n                    flag = true;\\n                    q.push(parent[front]);\\n                    visited[parent[front]] = true; \\n                }\\n                    \\n            }\\n            if(flag)\\n                time++;\\n        }\\n    }\\n    int amountOfTime(TreeNode* root, int start) \\n    {\\n        addParent(root, root, start);\\n        burnTree();\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3595512,
                "title": "beats-80-tree-burn-problem",
                "content": "# Approach\\nFirst of all I want to say that this is a hard level problem at gfg and codestudio but here it is mentioned medium.\\nPractice the \"minimum time to burn a tree when a target node is given\" problem and then try this. Both are exactly same problems.\\n\\nFor detailed explaination, refer to the Love Babbar\\'s lecture 67. He has explained it really very smooth.\\n\\n \\n# Complexity\\n- Time complexity:\\nO(n), where n = no. of nodes in the binary tree\\n\\n- Space complexity:\\nO(h), where h = height of the binary tree\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    public:\\n    TreeNode* makemapping(TreeNode* root,map<TreeNode*,TreeNode*> &parent,int start)\\n{\\n    TreeNode* tip = NULL;\\n    queue<TreeNode*>q;\\n    q.push(root);\\n    parent[root] = NULL;\\n    while(!q.empty())\\n    {\\n        TreeNode* curr = q.front();\\n        q.pop();\\n        if(curr->val == start)\\n        tip = curr;\\n        if(curr->left)\\n        {\\n            parent[curr->left] = curr;\\n            q.push(curr->left);\\n        }\\n        if(curr->right)\\n        {\\n            parent[curr->right] = curr;\\n            q.push(curr->right);\\n        }\\n    }\\n    return tip;\\n}\\n\\nint amountOfTime(TreeNode* root, int start)\\n{\\n    map<TreeNode*,TreeNode*>parent;\\n    TreeNode* tip = makemapping(root,parent,start);\\n\\n    map<TreeNode*,bool>visited;\\n    queue<TreeNode*>q;\\n    q.push(tip);\\n    visited[tip] = true;\\n    int time = 0;\\n    while(!q.empty())\\n    {\\n        int count = q.size();\\n        int flag = 0;\\n        for(int i=0;i<count;i++)\\n        {\\n            TreeNode* curr = q.front();\\n            q.pop();\\n            if(curr->left && !visited[curr->left])\\n            {\\n                flag = 1;\\n                q.push(curr->left);\\n                visited[curr->left] = true;\\n            }\\n            if(curr->right && !visited[curr->right])\\n            {\\n                flag = 1;\\n                q.push(curr->right);\\n                visited[curr->right] = true;\\n            }\\n            if(parent[curr] && !visited[parent[curr]])\\n            {\\n                flag = 1;\\n                q.push(parent[curr]);\\n                visited[parent[curr]] = true;\\n            }\\n        }\\n        if(flag == 1)\\n        time++;\\n    }\\n    return time;\\n} \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    public:\\n    TreeNode* makemapping(TreeNode* root,map<TreeNode*,TreeNode*> &parent,int start)\\n{\\n    TreeNode* tip = NULL;\\n    queue<TreeNode*>q;\\n    q.push(root);\\n    parent[root] = NULL;\\n    while(!q.empty())\\n    {\\n        TreeNode* curr = q.front();\\n        q.pop();\\n        if(curr->val == start)\\n        tip = curr;\\n        if(curr->left)\\n        {\\n            parent[curr->left] = curr;\\n            q.push(curr->left);\\n        }\\n        if(curr->right)\\n        {\\n            parent[curr->right] = curr;\\n            q.push(curr->right);\\n        }\\n    }\\n    return tip;\\n}\\n\\nint amountOfTime(TreeNode* root, int start)\\n{\\n    map<TreeNode*,TreeNode*>parent;\\n    TreeNode* tip = makemapping(root,parent,start);\\n\\n    map<TreeNode*,bool>visited;\\n    queue<TreeNode*>q;\\n    q.push(tip);\\n    visited[tip] = true;\\n    int time = 0;\\n    while(!q.empty())\\n    {\\n        int count = q.size();\\n        int flag = 0;\\n        for(int i=0;i<count;i++)\\n        {\\n            TreeNode* curr = q.front();\\n            q.pop();\\n            if(curr->left && !visited[curr->left])\\n            {\\n                flag = 1;\\n                q.push(curr->left);\\n                visited[curr->left] = true;\\n            }\\n            if(curr->right && !visited[curr->right])\\n            {\\n                flag = 1;\\n                q.push(curr->right);\\n                visited[curr->right] = true;\\n            }\\n            if(parent[curr] && !visited[parent[curr]])\\n            {\\n                flag = 1;\\n                q.push(parent[curr]);\\n                visited[parent[curr]] = true;\\n            }\\n        }\\n        if(flag == 1)\\n        time++;\\n    }\\n    return time;\\n} \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3482258,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    TreeNode startNode = null;\\n    public int AmountOfTime(TreeNode root, int start) {\\n        var amount_of_time = -1;\\n        var set = new HashSet<int>();\\n        var queue = new Queue<TreeNode>();\\n        var parent = new Dictionary<int, TreeNode>();\\n\\n        FillParent(root, null, start, parent);\\n        queue.Enqueue(startNode);\\n\\n        while(queue.Count > 0) {\\n            var count = queue.Count;\\n            for(int i = 0; i < count; i++) {\\n                var temp = queue.Dequeue();\\n                set.Add(temp.val);\\n\\n                if(temp.left != null && !set.Contains(temp.left.val))\\n                    queue.Enqueue(temp.left);\\n\\n                if(temp.right != null && !set.Contains(temp.right.val))\\n                    queue.Enqueue(temp.right);\\n\\n                if(parent[temp.val] != null && !set.Contains(parent[temp.val].val))\\n                    queue.Enqueue(parent[temp.val]);\\n            }\\n\\n            amount_of_time++;\\n        }\\n\\n        return amount_of_time;\\n    }\\n\\n    private void FillParent(TreeNode root, TreeNode prev, int start, Dictionary<int, TreeNode> parent) {\\n        if(root == null)\\n            return;\\n        \\n        if(root.val == start)\\n            startNode = root;\\n\\n        parent[root.val] = prev;\\n        FillParent(root.left, root, start, parent);\\n        FillParent(root.right, root, start, parent);\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#",
                    "Hash Table",
                    "Queue"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    TreeNode startNode = null;\\n    public int AmountOfTime(TreeNode root, int start) {\\n        var amount_of_time = -1;\\n        var set = new HashSet<int>();\\n        var queue = new Queue<TreeNode>();\\n        var parent = new Dictionary<int, TreeNode>();\\n\\n        FillParent(root, null, start, parent);\\n        queue.Enqueue(startNode);\\n\\n        while(queue.Count > 0) {\\n            var count = queue.Count;\\n            for(int i = 0; i < count; i++) {\\n                var temp = queue.Dequeue();\\n                set.Add(temp.val);\\n\\n                if(temp.left != null && !set.Contains(temp.left.val))\\n                    queue.Enqueue(temp.left);\\n\\n                if(temp.right != null && !set.Contains(temp.right.val))\\n                    queue.Enqueue(temp.right);\\n\\n                if(parent[temp.val] != null && !set.Contains(parent[temp.val].val))\\n                    queue.Enqueue(parent[temp.val]);\\n            }\\n\\n            amount_of_time++;\\n        }\\n\\n        return amount_of_time;\\n    }\\n\\n    private void FillParent(TreeNode root, TreeNode prev, int start, Dictionary<int, TreeNode> parent) {\\n        if(root == null)\\n            return;\\n        \\n        if(root.val == start)\\n            startNode = root;\\n\\n        parent[root.val] = prev;\\n        FillParent(root.left, root, start, parent);\\n        FillParent(root.right, root, start, parent);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3461748,
                "title": "easy-c-solution-using-map-and-queue",
                "content": "\\n# Code\\n```\\nclass Solution \\n{\\npublic:\\n    int timetoinfect(TreeNode* target, map<TreeNode*, TreeNode*> parent)\\n    {\\n        map<TreeNode*, bool> visited;\\n        queue<TreeNode*> q;\\n        q.push(target);\\n        visited[target] = true;\\n        int time=0;\\n        while(!q.empty())\\n        {\\n            int size = q.size(), fl=0;\\n\\n            for(int i=0; i<size; i++)\\n            {\\n                TreeNode* current = q.front(); q.pop();\\n                visited[current] = true;\\n\\n                if(current->left && !visited[current->left])\\n                {\\n                    fl =1;\\n                    q.push(current->left);\\n                    visited[current->left] = true;\\n                }\\n\\n                if(current->right && !visited[current->right])\\n                {\\n                    fl=1;\\n                    q.push(current->right);\\n                    visited[current->right] = true;\\n                }\\n\\n                if(parent[current] && !visited[parent[current]])\\n                {\\n                    fl=1;\\n                    q.push(parent[current]);\\n                    visited[parent[current]] = true;\\n                }\\n            }\\n            if(fl) time++;\\n        }\\n        return time;\\n    }\\n   TreeNode* makeParent(TreeNode* root, map<TreeNode*, TreeNode*> &parent, int start)\\n    {\\n        TreeNode* target;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if(node->val == start) \\n                target = node;\\n            if(node->left)\\n            {\\n                q.push(node->left);\\n                parent[node->left] = node;\\n            }\\n            if(node->right)\\n            {\\n                q.push(node->right);\\n                parent[node->right] = node;\\n            }\\n        }\\n        return target;\\n    }\\n    int amountOfTime(TreeNode* root, int start) \\n    {\\n        map<TreeNode*, TreeNode*> parent;\\n        TreeNode* target = makeParent(root, parent, start);\\n        int maxi = timetoinfect(target, parent);\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution \\n{\\npublic:\\n    int timetoinfect(TreeNode* target, map<TreeNode*, TreeNode*> parent)\\n    {\\n        map<TreeNode*, bool> visited;\\n        queue<TreeNode*> q;\\n        q.push(target);\\n        visited[target] = true;\\n        int time=0;\\n        while(!q.empty())\\n        {\\n            int size = q.size(), fl=0;\\n\\n            for(int i=0; i<size; i++)\\n            {\\n                TreeNode* current = q.front(); q.pop();\\n                visited[current] = true;\\n\\n                if(current->left && !visited[current->left])\\n                {\\n                    fl =1;\\n                    q.push(current->left);\\n                    visited[current->left] = true;\\n                }\\n\\n                if(current->right && !visited[current->right])\\n                {\\n                    fl=1;\\n                    q.push(current->right);\\n                    visited[current->right] = true;\\n                }\\n\\n                if(parent[current] && !visited[parent[current]])\\n                {\\n                    fl=1;\\n                    q.push(parent[current]);\\n                    visited[parent[current]] = true;\\n                }\\n            }\\n            if(fl) time++;\\n        }\\n        return time;\\n    }\\n   TreeNode* makeParent(TreeNode* root, map<TreeNode*, TreeNode*> &parent, int start)\\n    {\\n        TreeNode* target;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        while(!q.empty())\\n        {\\n            TreeNode* node = q.front();\\n            q.pop();\\n            if(node->val == start) \\n                target = node;\\n            if(node->left)\\n            {\\n                q.push(node->left);\\n                parent[node->left] = node;\\n            }\\n            if(node->right)\\n            {\\n                q.push(node->right);\\n                parent[node->right] = node;\\n            }\\n        }\\n        return target;\\n    }\\n    int amountOfTime(TreeNode* root, int start) \\n    {\\n        map<TreeNode*, TreeNode*> parent;\\n        TreeNode* target = makeParent(root, parent, start);\\n        int maxi = timetoinfect(target, parent);\\n        return maxi;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3316649,
                "title": "solution-using-bfs-traversal-after-creating-graph-in-java",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass Pair{\\n    int val;\\n    int step;\\n    Pair(int val,int step){\\n        this.val=val;\\n        this.step=step;\\n    }\\n}\\n\\nclass Solution {\\n    public ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n    public int max_node_val=Integer.MIN_VALUE;\\n    public void maxNode(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        max_node_val=Math.max(max_node_val,root.val);\\n        maxNode(root.left);\\n        maxNode(root.right);\\n    }\\n\\n    public void addEdge(int u,int v){\\n        adj.get(u).add(v);\\n        adj.get(v).add(u);\\n    }\\n\\n//Convertion of the binary tree to an undirected graph.\\n    public void tree_to_graph(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        if(root.left!=null){\\n            addEdge(root.val,root.left.val);\\n            /*adj.get(root.val).add(root.left.val);\\n            adj.get(root.left.val).add(root.val);*/\\n        }\\n        if(root.right!=null){\\n            addEdge(root.val,root.right.val);\\n            /*adj.get(root.val).add(root.right.val);\\n            adj.get(root.right.val).add(root.val);*/\\n        }\\n        tree_to_graph(root.left);\\n        tree_to_graph(root.right);\\n    }\\n\\n//Doing a BFS traversal on the undirected graph.\\n    public int bfs(ArrayList<ArrayList<Integer>>adj,int start,int nodes){\\n        boolean[] contaminated=new boolean[nodes+1];\\n        Queue<Pair> q=new LinkedList<>();\\n        int minute=0;\\n        q.add(new Pair(start,minute));\\n        contaminated[start]=true;\\n        while(!q.isEmpty()){\\n            int node=q.peek().val;\\n            minute=q.peek().step;\\n            q.remove();\\n            for(int it:adj.get(node)){\\n                if(!contaminated[it]){\\n                    contaminated[it]=true;\\n                    q.add(new Pair(it,minute+1));\\n                }\\n            }\\n        }\\n        return minute;\\n    }\\n\\n    public int amountOfTime(TreeNode root, int start) {\\n        if(root==null)\\n        return 0;\\n        maxNode(root);\\n        //System.out.println(max_node_val);\\n        for(int i=0;i<=max_node_val;i++){\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        tree_to_graph(root);\\n        //System.out.println(adj);\\n        return bfs(adj,start,max_node_val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass Pair{\\n    int val;\\n    int step;\\n    Pair(int val,int step){\\n        this.val=val;\\n        this.step=step;\\n    }\\n}\\n\\nclass Solution {\\n    public ArrayList<ArrayList<Integer>> adj=new ArrayList<>();\\n    public int max_node_val=Integer.MIN_VALUE;\\n    public void maxNode(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        max_node_val=Math.max(max_node_val,root.val);\\n        maxNode(root.left);\\n        maxNode(root.right);\\n    }\\n\\n    public void addEdge(int u,int v){\\n        adj.get(u).add(v);\\n        adj.get(v).add(u);\\n    }\\n\\n//Convertion of the binary tree to an undirected graph.\\n    public void tree_to_graph(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        if(root.left!=null){\\n            addEdge(root.val,root.left.val);\\n            /*adj.get(root.val).add(root.left.val);\\n            adj.get(root.left.val).add(root.val);*/\\n        }\\n        if(root.right!=null){\\n            addEdge(root.val,root.right.val);\\n            /*adj.get(root.val).add(root.right.val);\\n            adj.get(root.right.val).add(root.val);*/\\n        }\\n        tree_to_graph(root.left);\\n        tree_to_graph(root.right);\\n    }\\n\\n//Doing a BFS traversal on the undirected graph.\\n    public int bfs(ArrayList<ArrayList<Integer>>adj,int start,int nodes){\\n        boolean[] contaminated=new boolean[nodes+1];\\n        Queue<Pair> q=new LinkedList<>();\\n        int minute=0;\\n        q.add(new Pair(start,minute));\\n        contaminated[start]=true;\\n        while(!q.isEmpty()){\\n            int node=q.peek().val;\\n            minute=q.peek().step;\\n            q.remove();\\n            for(int it:adj.get(node)){\\n                if(!contaminated[it]){\\n                    contaminated[it]=true;\\n                    q.add(new Pair(it,minute+1));\\n                }\\n            }\\n        }\\n        return minute;\\n    }\\n\\n    public int amountOfTime(TreeNode root, int start) {\\n        if(root==null)\\n        return 0;\\n        maxNode(root);\\n        //System.out.println(max_node_val);\\n        for(int i=0;i<=max_node_val;i++){\\n            adj.add(new ArrayList<Integer>());\\n        }\\n        tree_to_graph(root);\\n        //System.out.println(adj);\\n        return bfs(adj,start,max_node_val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3159663,
                "title": "java-simple-code-converting-to-graph",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n class pair{\\n\\n     int first;\\n     int sec;\\n     pair(int first, int sec){\\n\\n         this.first=first;\\n         this.sec=sec;\\n     }\\n }\\nclass Solution {\\n \\n  int size=0;\\n   ArrayList<Integer>[] adj=new ArrayList[100001];\\n  \\n\\n      void convert(TreeNode root){\\n        if(root==null) return;\\n       Queue<TreeNode> q=new LinkedList<>();\\n       q.add(root);\\n\\n       while(!q.isEmpty()){\\n          int size=q.size();\\n          TreeNode node = q.remove();\\n        \\n        if(node.left!=null){\\n           adj[node.val].add(node.left.val);\\n           adj[node.left.val].add(node.val);\\n           q.add(node.left);\\n        }\\n\\n        if(node.right!=null){\\n            adj[node.val].add(node.right.val);\\n             adj[node.right.val].add(node.val);\\n            q.add(node.right);\\n        }\\n      \\n       }\\n      \\n      }\\n\\n    public int amountOfTime(TreeNode root, int start) {\\n        \\n        if(root==null) return 0;\\n         for(int i=0;i<100001;i++){\\n       adj[i]=new ArrayList<>();\\n      }\\n\\n\\n    \\n        convert(root);\\n          for(int i=0;i<15;i++){\\n          \\n              System.out.println(i+\"-->\"+adj[i]);\\n          }\\n      \\n        Queue<pair> q=new LinkedList<>();\\n       q.add(new pair(start,0));\\n       int ans=0;\\n       int vis[]=new int[100001];\\n      \\n\\n      vis[start]=1;\\n      int step=0;\\n       while(!q.isEmpty()){\\n\\n           int node=q.peek().first;\\n          step = q.peek().sec;\\n           q.remove();\\n           ans+=step;\\n\\n           for(int it : adj[node]){\\n             \\n               if(vis[it]==0)\\n                q.add(new pair(it,step+1));\\n                vis[it]=1;\\n           }\\n       }\\n\\n\\n       return step;\\n\\n\\n\\n       \\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n class pair{\\n\\n     int first;\\n     int sec;\\n     pair(int first, int sec){\\n\\n         this.first=first;\\n         this.sec=sec;\\n     }\\n }\\nclass Solution {\\n \\n  int size=0;\\n   ArrayList<Integer>[] adj=new ArrayList[100001];\\n  \\n\\n      void convert(TreeNode root){\\n        if(root==null) return;\\n       Queue<TreeNode> q=new LinkedList<>();\\n       q.add(root);\\n\\n       while(!q.isEmpty()){\\n          int size=q.size();\\n          TreeNode node = q.remove();\\n        \\n        if(node.left!=null){\\n           adj[node.val].add(node.left.val);\\n           adj[node.left.val].add(node.val);\\n           q.add(node.left);\\n        }\\n\\n        if(node.right!=null){\\n            adj[node.val].add(node.right.val);\\n             adj[node.right.val].add(node.val);\\n            q.add(node.right);\\n        }\\n      \\n       }\\n      \\n      }\\n\\n    public int amountOfTime(TreeNode root, int start) {\\n        \\n        if(root==null) return 0;\\n         for(int i=0;i<100001;i++){\\n       adj[i]=new ArrayList<>();\\n      }\\n\\n\\n    \\n        convert(root);\\n          for(int i=0;i<15;i++){\\n          \\n              System.out.println(i+\"-->\"+adj[i]);\\n          }\\n      \\n        Queue<pair> q=new LinkedList<>();\\n       q.add(new pair(start,0));\\n       int ans=0;\\n       int vis[]=new int[100001];\\n      \\n\\n      vis[start]=1;\\n      int step=0;\\n       while(!q.isEmpty()){\\n\\n           int node=q.peek().first;\\n          step = q.peek().sec;\\n           q.remove();\\n           ans+=step;\\n\\n           for(int it : adj[node]){\\n             \\n               if(vis[it]==0)\\n                q.add(new pair(it,step+1));\\n                vis[it]=1;\\n           }\\n       }\\n\\n\\n       return step;\\n\\n\\n\\n       \\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3000551,
                "title": "easiest-java-solution-ever-recursive-solution",
                "content": "# Intuition\\n- **Here we will simply find the NodeToRootPath and simply travel K distance away from those nodes.**\\n- **Now, we\\'ll simply get the max value of the from each of these nodes and we\\'ll keep updating it to get the desired answer.**\\n\\n# Approach\\n**Recursive Approach (DFS)**\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public static int kDistanceAway(TreeNode root,int k,TreeNode blocker){\\n\\n        if(root == null || root == blocker){\\n            return k-1;\\n        }\\n        \\n        int left = kDistanceAway(root.left, k+1, blocker);\\n        \\n        int right = kDistanceAway(root.right, k+1, blocker);\\n        \\n        return Math.max(left, right);\\n\\n    }\\n\\n    public static List<TreeNode> nodeToRootPath(TreeNode node, int target){\\n\\n        if(node == null){\\n            return new ArrayList<>();\\n        }\\n\\n        if(node.val == target){\\n            List<TreeNode> arr = new ArrayList<>();\\n            arr.add(node);\\n            return arr;\\n        }\\n\\n        List<TreeNode> left = nodeToRootPath(node.left, target);\\n\\n        if(left.size()>0){\\n            left.add(node);\\n            return left;\\n        }\\n\\n        List<TreeNode> right = nodeToRootPath(node.right, target);\\n\\n        if(right.size()>0){\\n            right.add(node);\\n            return right;\\n        }\\n\\n        return new ArrayList<>();\\n\\n    }\\n\\n    public int amountOfTime(TreeNode root, int start) {\\n        \\n        List<TreeNode> path = nodeToRootPath(root, start);\\n\\n        int ans = 0;\\n\\n        for(int i=0; i<path.size(); i++){\\n            int time = kDistanceAway(path.get(i), i, i==0?null:path.get(i-1));\\n            ans = Math.max(ans, time);\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public static int kDistanceAway(TreeNode root,int k,TreeNode blocker){\\n\\n        if(root == null || root == blocker){\\n            return k-1;\\n        }\\n        \\n        int left = kDistanceAway(root.left, k+1, blocker);\\n        \\n        int right = kDistanceAway(root.right, k+1, blocker);\\n        \\n        return Math.max(left, right);\\n\\n    }\\n\\n    public static List<TreeNode> nodeToRootPath(TreeNode node, int target){\\n\\n        if(node == null){\\n            return new ArrayList<>();\\n        }\\n\\n        if(node.val == target){\\n            List<TreeNode> arr = new ArrayList<>();\\n            arr.add(node);\\n            return arr;\\n        }\\n\\n        List<TreeNode> left = nodeToRootPath(node.left, target);\\n\\n        if(left.size()>0){\\n            left.add(node);\\n            return left;\\n        }\\n\\n        List<TreeNode> right = nodeToRootPath(node.right, target);\\n\\n        if(right.size()>0){\\n            right.add(node);\\n            return right;\\n        }\\n\\n        return new ArrayList<>();\\n\\n    }\\n\\n    public int amountOfTime(TreeNode root, int start) {\\n        \\n        List<TreeNode> path = nodeToRootPath(root, start);\\n\\n        int ans = 0;\\n\\n        for(int i=0; i<path.size(); i++){\\n            int time = kDistanceAway(path.get(i), i, i==0?null:path.get(i-1));\\n            ans = Math.max(ans, time);\\n        }\\n\\n        return ans;\\n\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2797467,
                "title": "java-solution-dfs-hashmap-bfs",
                "content": "```java \\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        Map<Integer,ArrayList<Integer>> map = new HashMap<>();\\n        dfs(root,map,root);\\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.add(start);\\n        visited.add(start);\\n        int c=0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-->0){\\n                int curr = queue.remove();\\n                for(int x:map.get(curr)){\\n                    if(!visited.contains(x)){\\n                        queue.add(x);\\n                        visited.add(x);\\n                    }\\n                }\\n            }\\n            c++;\\n        }\\n        return c-1;\\n    }\\n    \\n    private void dfs(TreeNode root,Map<Integer,ArrayList<Integer>> map,TreeNode parent)\\n    {\\n        if(root==null)\\n            return;\\n        ArrayList<Integer> list = new ArrayList<>();\\n        if(root!=parent)\\n            list.add(parent.val);\\n        if(root.left!=null)\\n            list.add(root.left.val);\\n        if(root.right!=null)\\n            list.add(root.right.val);\\n        map.put(root.val,list);\\n        dfs(root.left,map,root);\\n        dfs(root.right,map,root);\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        Map<Integer,ArrayList<Integer>> map = new HashMap<>();\\n        dfs(root,map,root);\\n        Set<Integer> visited = new HashSet<>();\\n        Queue<Integer> queue = new ArrayDeque<>();\\n        queue.add(start);\\n        visited.add(start);\\n        int c=0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            while(size-->0){\\n                int curr = queue.remove();\\n                for(int x:map.get(curr)){\\n                    if(!visited.contains(x)){\\n                        queue.add(x);\\n                        visited.add(x);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 2696255,
                "title": "python-one-pass-postorder-dfs-with-graph-explain-98",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nFind the longest path from the start node\\n# Complexity\\n- Time complexity:\\n$$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n$$O(log(n))$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n        # find the longest path from the start\\n        def findMaxDepth(root):\\n            #\\n            if not root:\\n                return 0,0,0,0\\n            #l:    max depth,\\n            #spl:  start to node length\\n            #sel:  longest path from start to end\\n            #rl:   return result\\n            \\n            l,spl,sel,rl=findMaxDepth(root.left)\\n            r,spr,ser,rr=findMaxDepth(root.right)\\n            depth=max(l,r)+1\\n            if root.val==start:\\n                return depth,1,depth,depth-1\\n            else:\\n                if spl!=0:\\n                    return depth,spl+1,sel,max(rl,sel-1,spl+r)\\n                elif spr!=0:\\n                    return depth,spr+1,ser,max(rr,ser-1,spr+l)\\n                else:\\n                    return depth,0,0,0\\n                    \\n            \\n        return findMaxDepth(root)[3]\\n```\\n\\n![IMG_2579.jpeg](https://assets.leetcode.com/users/images/d3be2212-8ba5-46be-b85d-6a9f4c1ad188_1665620078.6115794.jpeg)\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n        # find the longest path from the start\\n        def findMaxDepth(root):\\n            #\\n            if not root:\\n                return 0,0,0,0\\n            #l:    max depth,\\n            #spl:  start to node length\\n            #sel:  longest path from start to end\\n            #rl:   return result\\n            \\n            l,spl,sel,rl=findMaxDepth(root.left)\\n            r,spr,ser,rr=findMaxDepth(root.right)\\n            depth=max(l,r)+1\\n            if root.val==start:\\n                return depth,1,depth,depth-1\\n            else:\\n                if spl!=0:\\n                    return depth,spl+1,sel,max(rl,sel-1,spl+r)\\n                elif spr!=0:\\n                    return depth,spr+1,ser,max(rr,ser-1,spr+l)\\n                else:\\n                    return depth,0,0,0\\n                    \\n            \\n        return findMaxDepth(root)[3]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2664406,
                "title": "java-bfs-solution-with-adjacency-list",
                "content": "# Intuition\\nThe Main idea behind this question : \\nDo a `BFS` from the node with the value of `start`. This is what we want to do.\\nThe simplest thing that comes into my mind for doing this is first making an `adjacency list` storing all the neighbours of all the nodes ( take care of directionality). Because I am considering edges to be bidirectoinal I need to take care of this during the BFS implementation, which imho is no that hard, we just need a lookup table to check if a node has been visited or not .\\n\\nThen it\\'s just about execuing BFS. \\nBelow is the code using the above idea.\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        int t = 0;\\n        if(root == null)return 0;\\n        if(root.left == null && root.right == null)return 0;\\n        \\n        HashMap<Integer, ArrayList<Integer>>map = new HashMap<Integer, ArrayList<Integer>>();\\n\\n        dfs(-1, root, map);\\n        ArrayList<Integer>adj = map.get(start);\\n\\n        // now do a BFS.\\n        Queue<Integer>q = new LinkedList<>();\\n        q.offer(start);\\n        HashMap<Integer, Boolean>visited = new HashMap<Integer, Boolean>();\\n        while(!q.isEmpty()){\\n            int sz = q.size();\\n            while(sz-->0){\\n                int top = q.poll();\\n                if(visited.containsKey(top))continue;\\n                visited.put(top, true);\\n                ArrayList<Integer>it = map.get(top);\\n                if(it == null)continue;\\n                int size = it.size();\\n                for(int i = 0; i<size; ++i){\\n                    if(visited.containsKey(it.get(i)))continue;\\n                    q.offer(it.get(i));\\n                }\\n            }\\n            if(q.isEmpty() == true)return t;\\n            ++t;\\n        }\\n        return t;\\n    }\\n\\n    public void dfs(int parent, TreeNode root, HashMap<Integer, ArrayList<Integer>>map){\\n        if(root == null)return;\\n        if(parent == -1){\\n            if(root.left != null){\\n                if(map.get(root.val) == null){\\n                    map.put(root.val, new ArrayList<Integer>());\\n                    ArrayList<Integer>arr = map.get(root.val);\\n                    arr.add(root.left.val);\\n                    map.put(root.val, arr);\\n                }else{\\n                    ArrayList<Integer>arr = map.get(root.val);\\n                    arr.add(root.left.val);\\n                    map.put(root.val, arr);\\n                }\\n            }\\n            if(root.right != null){\\n                 if(map.get(root.val) == null){\\n                    map.put(root.val, new ArrayList<Integer>());\\n                    ArrayList<Integer>arr = map.get(root.val);\\n                    arr.add(root.right.val);\\n                    map.put(root.val, arr);\\n                }else{\\n                    ArrayList<Integer>arr = map.get(root.val);\\n                    arr.add(root.right.val);\\n                    map.put(root.val, arr);\\n                }\\n            }\\n            dfs(root.val, root.left, map);\\n            dfs(root.val, root.right, map);\\n            return;\\n        }else{\\n            if(map.get(root.val) == null){\\n                map.put(root.val, new ArrayList<Integer>());\\n                ArrayList<Integer>arr = map.get(root.val);\\n                arr.add(parent);\\n                map.put(root.val, arr);\\n            }\\n            if(root.left != null){\\n                if(map.get(root.val) == null){\\n                    map.put(root.val, new ArrayList<Integer>());\\n                    ArrayList<Integer>arr = map.get(root.val);\\n                    arr.add(root.left.val);\\n                    map.put(root.val, arr);\\n                }else{\\n                    ArrayList<Integer>arr = map.get(root.val);\\n                    arr.add(root.left.val);\\n                    map.put(root.val, arr);\\n                }\\n            }\\n            if(root.right != null){\\n                 if(map.get(root.val) == null){\\n                    map.put(root.val, new ArrayList<Integer>());\\n                    ArrayList<Integer>arr = map.get(root.val);\\n                    arr.add(root.right.val);\\n                    map.put(root.val, arr);\\n                }else{\\n                    ArrayList<Integer>arr = map.get(root.val);\\n                    arr.add(root.right.val);\\n                    map.put(root.val, arr);\\n                }\\n            }\\n        }\\n\\n        dfs(root.val, root.left, map);\\n        dfs(root.val, root.right, map);\\n        return;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        int t = 0;\\n        if(root == null)return 0;\\n        if(root.left == null && root.right == null)return 0;\\n        \\n        HashMap<Integer, ArrayList<Integer>>map = new HashMap<Integer, ArrayList<Integer>>();\\n\\n        dfs(-1, root, map);\\n        ArrayList<Integer>adj = map.get(start);\\n\\n        // now do a BFS.\\n        Queue<Integer>q = new LinkedList<>();\\n        q.offer(start);\\n        HashMap<Integer, Boolean>visited = new HashMap<Integer, Boolean>();\\n        while(!q.isEmpty()){\\n            int sz = q.size();\\n            while(sz-->0){\\n                int top = q.poll();\\n                if(visited.containsKey(top))continue;\\n                visited.put(top, true);\\n                ArrayList<Integer>it = map.get(top);\\n                if(it == null)continue;\\n                int size = it.size();\\n                for(int i = 0; i<size; ++i){\\n                    if(visited.containsKey(it.get(i)))continue;\\n                    q.offer(it.get(i));\\n                }\\n            }\\n            if(q.isEmpty() == true)return t;\\n            ++t;\\n        }\\n        return t;\\n    }\\n\\n    public void dfs(int parent, TreeNode root, HashMap<Integer, ArrayList<Integer>>map){\\n        if(root == null)return;\\n        if(parent == -1){\\n            if(root.left != null){\\n                if(map.get(root.val) == null){\\n                    map.put(root.val, new ArrayList<Integer>());\\n                    ArrayList<Integer>arr = map.get(root.val);\\n                    arr.add(root.left.val);\\n                    map.put(root.val, arr);\\n                }else{\\n                    ArrayList<Integer>arr = map.get(root.val);\\n                    arr.add(root.left.val);\\n                    map.put(root.val, arr);\\n                }\\n            }\\n            if(root.right != null){\\n                 if(map.get(root.val) == null){\\n                    map.put(root.val, new ArrayList<Integer>());\\n                    ArrayList<Integer>arr = map.get(root.val);\\n                    arr.add(root.right.val);\\n                    map.put(root.val, arr);\\n                }else{\\n                    ArrayList<Integer>arr = map.get(root.val);\\n                    arr.add(root.right.val);\\n                    map.put(root.val, arr);\\n                }\\n            }\\n            dfs(root.val, root.left, map);\\n            dfs(root.val, root.right, map);\\n            return;\\n        }else{\\n            if(map.get(root.val) == null){\\n                map.put(root.val, new ArrayList<Integer>());\\n                ArrayList<Integer>arr = map.get(root.val);\\n                arr.add(parent);\\n                map.put(root.val, arr);\\n            }\\n            if(root.left != null){\\n                if(map.get(root.val) == null){\\n                    map.put(root.val, new ArrayList<Integer>());\\n                    ArrayList<Integer>arr = map.get(root.val);\\n                    arr.add(root.left.val);\\n                    map.put(root.val, arr);\\n                }else{\\n                    ArrayList<Integer>arr = map.get(root.val);\\n                    arr.add(root.left.val);\\n                    map.put(root.val, arr);\\n                }\\n            }\\n            if(root.right != null){\\n                 if(map.get(root.val) == null){\\n                    map.put(root.val, new ArrayList<Integer>());\\n                    ArrayList<Integer>arr = map.get(root.val);\\n                    arr.add(root.right.val);\\n                    map.put(root.val, arr);\\n                }else{\\n                    ArrayList<Integer>arr = map.get(root.val);\\n                    arr.add(root.right.val);\\n                    map.put(root.val, arr);\\n                }\\n            }\\n        }\\n\\n        dfs(root.val, root.left, map);\\n        dfs(root.val, root.right, map);\\n        return;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2644653,
                "title": "easy-level-order-traversal-bfs-approach-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n int amountOfTime(TreeNode* root, int start) \\n{\\n   set<TreeNode*>visited;\\n   unordered_map<int,TreeNode*>mp;\\n     \\n   TreeNode* startnode=NULL;\\n   \\n   fillmap(root,mp,startnode,start);\\n     \\n   return bfs(visited,mp,startnode);\\n   \\n}\\nint bfs(set<TreeNode*>&visited,unordered_map<int,TreeNode*>&mp,TreeNode* startnode)\\n{\\n\\tqueue<TreeNode*>q;\\n    int time=0;\\n    q.push(startnode);\\n    \\n    while(!q.empty())\\n    {\\n    \\tint size=q.size();\\n        \\n    \\tfor(int i=0;i<size;i++)\\n    \\t{\\n    \\t\\tTreeNode* temp=q.front();\\n    \\t\\tq.pop();\\n    \\t\\tvisited.insert(temp);\\n    \\t\\t\\n    \\t\\t//left and right and parent\\n    \\t\\tif(temp->left!=NULL and visited.find(temp->left)==visited.end())\\n    \\t\\t{\\n\\t\\t       q.push(temp->left);\\n\\t\\t\\t}\\n\\t\\t\\tif(temp->right!=NULL and visited.find(temp->right)==visited.end())\\n    \\t\\t{\\n    \\t\\t\\tq.push(temp->right);\\n\\t\\t\\t}\\n\\t\\t\\tif(mp.find(temp->val)!=mp.end() and visited.find(mp[temp->val])==visited.end())\\n    \\t\\t{\\n    \\t\\t\\tq.push(mp[temp->val]);\\n\\t\\t\\t}\\n\\t\\t}\\n        if(q.size()>0)\\n\\t\\ttime++;\\n\\t}\\n\\treturn time;\\n}\\nvoid fillmap(TreeNode* root,unordered_map<int,TreeNode*>&mp,TreeNode* &startnode,int start)\\n{\\n\\tif(root==NULL)  \\n\\t{\\n\\t   return;\\t\\n\\t}\\n\\tif(root->val==start and startnode==NULL)\\n\\t{\\n\\t\\tstartnode=root;\\n\\t}\\n\\tif((root->left)!=NULL)\\n\\t{\\n\\t\\tmp[root->left->val]=root;\\n\\t}\\n\\tif((root->right)!=NULL)\\n\\t{\\n\\t\\tmp[root->right->val]=root;\\n\\t}\\n\\tfillmap(root->left,mp,startnode,start);\\n\\tfillmap(root->right,mp,startnode,start);\\n}\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n int amountOfTime(TreeNode* root, int start) \\n{\\n   set<TreeNode*>visited;\\n   unordered_map<int,TreeNode*>mp;\\n     \\n   TreeNode* startnode=NULL;\\n   \\n   fillmap(root,mp,startnode,start);\\n     \\n   return bfs(visited,mp,startnode);\\n   \\n}\\nint bfs(set<TreeNode*>&visited,unordered_map<int,TreeNode*>&mp,TreeNode* startnode)\\n{\\n\\tqueue<TreeNode*>q;\\n    int time=0;\\n    q.push(startnode);\\n    \\n    while(!q.empty())\\n    {\\n    \\tint size=q.size();\\n        \\n    \\tfor(int i=0;i<size;i++)\\n    \\t{\\n    \\t\\tTreeNode* temp=q.front();\\n    \\t\\tq.pop();\\n    \\t\\tvisited.insert(temp);\\n    \\t\\t\\n    \\t\\t//left and right and parent\\n    \\t\\tif(temp->left!=NULL and visited.find(temp->left)==visited.end())\\n    \\t\\t{\\n\\t\\t       q.push(temp->left);\\n\\t\\t\\t}\\n\\t\\t\\tif(temp->right!=NULL and visited.find(temp->right)==visited.end())\\n    \\t\\t{\\n    \\t\\t\\tq.push(temp->right);\\n\\t\\t\\t}\\n\\t\\t\\tif(mp.find(temp->val)!=mp.end() and visited.find(mp[temp->val])==visited.end())\\n    \\t\\t{\\n    \\t\\t\\tq.push(mp[temp->val]);\\n\\t\\t\\t}\\n\\t\\t}\\n        if(q.size()>0)\\n\\t\\ttime++;\\n\\t}\\n\\treturn time;\\n}\\nvoid fillmap(TreeNode* root,unordered_map<int,TreeNode*>&mp,TreeNode* &startnode,int start)\\n{\\n\\tif(root==NULL)  \\n\\t{\\n\\t   return;\\t\\n\\t}\\n\\tif(root->val==start and startnode==NULL)\\n\\t{\\n\\t\\tstartnode=root;\\n\\t}\\n\\tif((root->left)!=NULL)\\n\\t{\\n\\t\\tmp[root->left->val]=root;\\n\\t}\\n\\tif((root->right)!=NULL)\\n\\t{\\n\\t\\tmp[root->right->val]=root;\\n\\t}\\n\\tfillmap(root->left,mp,startnode,start);\\n\\tfillmap(root->right,mp,startnode,start);\\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2615008,
                "title": "c-using-recursion-simple-approach-runtime-faster-than-84-58-space-less-than-99-48",
                "content": "![image](https://assets.leetcode.com/users/images/ad5c0876-ae8c-4a9f-a060-c1b5f6ab5bb5_1664365812.5390768.jpeg)\\n![image](https://assets.leetcode.com/users/images/4a6b63e2-88ff-40fa-a0af-e1fbd7f5c4a5_1664365825.919552.jpeg)\\n```\\nclass Solution {\\npublic: int minute=0;\\n    int amountOfTime(TreeNode* root, int start) {\\n        traversal(root,start);\\n        return minute;   \\n    }\\n    int traversal(TreeNode*t,int &start)\\n    {\\n        if(t==NULL)\\n            return -1;\\n        if(t->val==start)\\n        {\\n            helper(t,0);\\n            return 0;\\n        }\\n        int dl=traversal(t->left,start);\\n        if(dl!=-1)\\n        {\\n            helper(t->right,dl+2);\\n            if(dl+1>minute)\\n                minute=dl+1;\\n            return dl+1;\\n            \\n        }\\n        int dr=traversal(t->right,start);\\n        if(dr!=-1)\\n        {\\n            helper(t->left,dr+2);\\n            if(dr+1>minute)\\n                minute=dr+1;\\n            return dr+1;\\n        }\\n        return -1;   \\n    }\\n    void helper(TreeNode *t,int level)\\n    {\\n        if(t==NULL)\\n            return;\\n        if(level>minute)\\n             minute=level;\\n        helper(t->left,level+1);\\n        helper(t->right,level+1);   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic: int minute=0;\\n    int amountOfTime(TreeNode* root, int start) {\\n        traversal(root,start);\\n        return minute;   \\n    }\\n    int traversal(TreeNode*t,int &start)\\n    {\\n        if(t==NULL)\\n            return -1;\\n        if(t->val==start)\\n        {\\n            helper(t,0);\\n            return 0;\\n        }\\n        int dl=traversal(t->left,start);\\n        if(dl!=-1)\\n        {\\n            helper(t->right,dl+2);\\n            if(dl+1>minute)\\n                minute=dl+1;\\n            return dl+1;\\n            \\n        }\\n        int dr=traversal(t->right,start);\\n        if(dr!=-1)\\n        {\\n            helper(t->left,dr+2);\\n            if(dr+1>minute)\\n                minute=dr+1;\\n            return dr+1;\\n        }\\n        return -1;   \\n    }\\n    void helper(TreeNode *t,int level)\\n    {\\n        if(t==NULL)\\n            return;\\n        if(level>minute)\\n             minute=level;\\n        helper(t->left,level+1);\\n        helper(t->right,level+1);   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2581051,
                "title": "striver-s-solution-important-for-interview-burn-a-tree-c-bfs",
                "content": "* **It is a very famous problem and can be ask in any of the Interview so you have to prepare it carefully.**\\n\\nTutorial Link :\\nhttps://www.youtube.com/watch?v=2r5wLmQfD6g&ab_channel=takeUforward  \\n\\n```\\nclass Solution {\\npublic:\\nint findMaxDistance(map<TreeNode*, TreeNode*> &mpp, TreeNode* target) {\\n    queue<TreeNode*> q; \\n    q.push(target); \\n    map<TreeNode*,int> vis; \\n    vis[target] = 1;\\n    int maxi = 0; \\n    while(!q.empty()) {\\n        int sz = q.size();\\n        int fl = 0; \\n        for(int i = 0;i<sz;i++) {\\n            auto node = q.front();\\n            q.pop();\\n            if(node->left && !vis[node->left]) {\\n                fl = 1; \\n                vis[node->left] = 1; \\n                q.push(node->left); \\n            }\\n            if(node->right && !vis[node->right]) {\\n                fl = 1; \\n                vis[node->right] = 1; \\n                q.push(node->right); \\n            }\\n            \\n            if(mpp[node] && !vis[mpp[node]]) {\\n                fl = 1; \\n                vis[mpp[node]] = 1; \\n                q.push(mpp[node]); \\n            } \\n        }\\n        if(fl) maxi++; \\n    }\\n    return maxi; \\n}\\nTreeNode* bfsToMapParents(TreeNode* root,map<TreeNode*, TreeNode*> &mpp, int start) {\\n    queue<TreeNode*> q; \\n    q.push(root); \\n    TreeNode* res; \\n    while(!q.empty()) {\\n        TreeNode* node = q.front(); \\n        if(node->val == start) res = node; \\n        q.pop(); \\n        if(node->left) {\\n            mpp[node->left] = node; \\n            q.push(node->left); \\n        }\\n        if(node->right) {\\n            mpp[node->right] = node;\\n            q.push(node->right); \\n        }\\n    }\\n    return res; \\n}\\nint amountOfTime(TreeNode* root, int start)\\n{\\n    map<TreeNode*, TreeNode*> mpp; \\n    TreeNode* target = bfsToMapParents(root, mpp, start); \\n    int maxi = findMaxDistance(mpp, target); \\n    return maxi; \\n}\\n};\\n```\\n**Plz upvote if it helps!!**",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\nint findMaxDistance(map<TreeNode*, TreeNode*> &mpp, TreeNode* target) {\\n    queue<TreeNode*> q; \\n    q.push(target); \\n    map<TreeNode*,int> vis; \\n    vis[target] = 1;\\n    int maxi = 0; \\n    while(!q.empty()) {\\n        int sz = q.size();\\n        int fl = 0; \\n        for(int i = 0;i<sz;i++) {\\n            auto node = q.front();\\n            q.pop();\\n            if(node->left && !vis[node->left]) {\\n                fl = 1; \\n                vis[node->left] = 1; \\n                q.push(node->left); \\n            }\\n            if(node->right && !vis[node->right]) {\\n                fl = 1; \\n                vis[node->right] = 1; \\n                q.push(node->right); \\n            }\\n            \\n            if(mpp[node] && !vis[mpp[node]]) {\\n                fl = 1; \\n                vis[mpp[node]] = 1; \\n                q.push(mpp[node]); \\n            } \\n        }\\n        if(fl) maxi++; \\n    }\\n    return maxi; \\n}\\nTreeNode* bfsToMapParents(TreeNode* root,map<TreeNode*, TreeNode*> &mpp, int start) {\\n    queue<TreeNode*> q; \\n    q.push(root); \\n    TreeNode* res; \\n    while(!q.empty()) {\\n        TreeNode* node = q.front(); \\n        if(node->val == start) res = node; \\n        q.pop(); \\n        if(node->left) {\\n            mpp[node->left] = node; \\n            q.push(node->left); \\n        }\\n        if(node->right) {\\n            mpp[node->right] = node;\\n            q.push(node->right); \\n        }\\n    }\\n    return res; \\n}\\nint amountOfTime(TreeNode* root, int start)\\n{\\n    map<TreeNode*, TreeNode*> mpp; \\n    TreeNode* target = bfsToMapParents(root, mpp, start); \\n    int maxi = findMaxDistance(mpp, target); \\n    return maxi; \\n}\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2573548,
                "title": "c-bfs-after-searching-the-node-reference-and-parent-pointers",
                "content": "```\\nclass Solution {\\n//keep a track of the parents in an unordered_map and store it by traversing (BFS) \\nvoid mark_parents(TreeNode* root, unordered_map<TreeNode*, TreeNode*> &markparent)\\n    {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            TreeNode *curr = q.front();\\n            q.pop();\\n            if(curr->left!=NULL)\\n            {\\n                markparent[curr->left] = curr;\\n                q.push(curr->left);\\n            }\\n            if(curr->right!=NULL)\\n            {\\n                markparent[curr->right] = curr;\\n                q.push(curr->right);\\n            }\\n        }\\n    }\\nTreeNode* ifNodeExists(TreeNode* node, int start)\\n{\\n    if (node == NULL)\\n        return NULL;\\n \\n    if (node->val == start)\\n        return node;\\n \\n    /* then recur on left subtree */\\n    TreeNode* res1 = ifNodeExists(node->left, start);\\n    // node found, no need to look further\\n    if(res1) return res1;\\n \\n    /* node is not found in left,\\n    so recur on right subtree */\\n    TreeNode* res2 = ifNodeExists(node->right, start);\\n \\n    return res2;\\n}\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        \\n        unordered_map<TreeNode*,TreeNode*> markparent;\\n        mark_parents(root,markparent);\\n        \\n        \\n        \\n        queue<TreeNode*> q;\\n        unordered_map<TreeNode*, bool> visited;\\n        TreeNode* target = ifNodeExists(root,start);\\n        q.push(target);\\n        visited[target] = true;\\n        int time = -1;\\n        \\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            time++;\\n            \\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode *curr = q.front();\\n                q.pop();\\n                \\n                if(curr->left && !visited[curr->left])\\n                {\\n                    q.push(curr->left);\\n                    visited[curr->left]  = true;\\n                }\\n                \\n                if(curr->right && !visited[curr->right])\\n                {\\n                    q.push(curr->right);\\n                    visited[curr->right] = true;\\n                }\\n                if(markparent[curr] && !visited[markparent[curr]])\\n                {\\n                    q.push(markparent[curr]);\\n                    visited[markparent[curr]] = true;\\n                }\\n            }\\n        }\\n            \\n        return time;\\n        }\\n    \\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n//keep a track of the parents in an unordered_map and store it by traversing (BFS) \\nvoid mark_parents(TreeNode* root, unordered_map<TreeNode*, TreeNode*> &markparent)\\n    {\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        \\n        while(!q.empty())\\n        {\\n            TreeNode *curr = q.front();\\n            q.pop();\\n            if(curr->left!=NULL)\\n            {\\n                markparent[curr->left] = curr;\\n                q.push(curr->left);\\n            }\\n            if(curr->right!=NULL)\\n            {\\n                markparent[curr->right] = curr;\\n                q.push(curr->right);\\n            }\\n        }\\n    }\\nTreeNode* ifNodeExists(TreeNode* node, int start)\\n{\\n    if (node == NULL)\\n        return NULL;\\n \\n    if (node->val == start)\\n        return node;\\n \\n    /* then recur on left subtree */\\n    TreeNode* res1 = ifNodeExists(node->left, start);\\n    // node found, no need to look further\\n    if(res1) return res1;\\n \\n    /* node is not found in left,\\n    so recur on right subtree */\\n    TreeNode* res2 = ifNodeExists(node->right, start);\\n \\n    return res2;\\n}\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        \\n        unordered_map<TreeNode*,TreeNode*> markparent;\\n        mark_parents(root,markparent);\\n        \\n        \\n        \\n        queue<TreeNode*> q;\\n        unordered_map<TreeNode*, bool> visited;\\n        TreeNode* target = ifNodeExists(root,start);\\n        q.push(target);\\n        visited[target] = true;\\n        int time = -1;\\n        \\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            time++;\\n            \\n            for(int i=0;i<size;i++)\\n            {\\n                TreeNode *curr = q.front();\\n                q.pop();\\n                \\n                if(curr->left && !visited[curr->left])\\n                {\\n                    q.push(curr->left);\\n                    visited[curr->left]  = true;\\n                }\\n                \\n                if(curr->right && !visited[curr->right])\\n                {\\n                    q.push(curr->right);\\n                    visited[curr->right] = true;\\n                }\\n                if(markparent[curr] && !visited[markparent[curr]])\\n                {\\n                    q.push(markparent[curr]);\\n                    visited[markparent[curr]] = true;\\n                }\\n            }\\n        }\\n            \\n        return time;\\n        }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2572699,
                "title": "dfs-python",
                "content": "Let\\'s take some node for example. Only two scenarios are possible:\\n* Neither left nor right subtree contains the infected node.\\n* One of the left and right subtrees contains the infected node.\\n\\nThe idea is to return two values:\\n- `distance` : The distance from the current node to the infected node, if the current node is a parent of it (doesn\\'t have to be direct parent), or -1 if it isn\\'t.\\n- `infect_time` : The time that it will take to infect the subtree that is rooted in the current node.\\n\\nThe first value is easy to keep track of - We return -1 until we found the infected node, at which point we will return 0. then, we check at each node if  `distance != -1` for left or right, and add 1 to it.\\n\\nThe second value if a little more complex:\\n- If we did not find the infected node yet, we return the depth of the current subtree.\\n- If we found it, then the time it\\'ll take is the maximum of the following:\\n\\t- either it takes as much time as it takes to infect the subtree that contains the infected node.\\n\\t- or, the distance from the infected node to the left\\\\right child nodes, +1 to get to the current node, +1 to get to the other subtree (left\\\\right), and the depth of that subtree.\\n\\n```\\nclass Solution:\\n    def amountOfTime(self, root, start: int) -> int:\\n        time_to_infect_tree, _ = self.dfs(root, start)\\n        return time_to_infect_tree\\n\\n    def dfs(self, root, start):\\n        if root == None:\\n            return -1, -1\\n\\n        left_infect_time, left_distance = self.dfs(root.left, start)\\n        right_infect_time, right_distance = self.dfs(root.right, start)\\n\\t\\t\\n        if left_distance == -1 and right_distance == -1:\\n            distance = -1\\n            infect_time = max(right_infect_time, left_infect_time) + 1\\n\\n        elif left_distance != -1:\\n            distance = left_distance + 1\\n            infect_time = max(left_infect_time, right_infect_time + left_distance + 2)\\n           \\n        else:\\n            distance = right_distance + 1\\n            infect_time = max(right_infect_time, left_infect_time + right_distance + 2)\\n\\n        if root.val == start:\\n            distance = 0\\n\\n        return infect_time, distance\\n```\\n\\nWith Extra Comments:\\n```\\nclass Solution:\\n    def amountOfTime(self, root, start: int) -> int:\\n        time_to_infect_tree, _ = self.dfs(root, start)\\n        return time_to_infect_tree\\n\\n    def dfs(self, root, start):\\n\\n        # if root is None\\n        if root == None:\\n            return -1, -1\\n\\n        # get time to infect subtree from root, as well as distance from root of subtree\\n        # to the infected node (-1 if root is not a parent of it)\\n        left_infect_time, left_distance = self.dfs(root.left, start)\\n        right_infect_time, right_distance = self.dfs(root.right, start)\\n\\n        # if both subtrees don\\'t contain the infected node\\n        if left_distance == -1 and right_distance == -1:\\n            distance = -1\\n            # infect time is as if from root node, AKA simply the depth of the subtree\\n            infect_time = max(right_infect_time, left_infect_time) + 1\\n\\n        # if left subtree contains the infected node\\n        elif left_distance != -1:\\n            # update distance to infected node\\n            distance = left_distance + 1\\n            # distance to the infected node from root.left, then two edges to root.right (+2), then\\n            # infect time of right subtree as if from root.right\\n            infect_time = max(left_infect_time, right_infect_time + left_distance + 2)\\n            \\n        # same as before, but with right subtree containing the infected\\n        else:\\n            distance = right_distance + 1\\n            infect_time = max(right_infect_time, left_infect_time + right_distance + 2)\\n\\n        # if found the infected node\\n        if root.val == start:\\n            distance = 0\\n\\n        return infect_time, distance\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def amountOfTime(self, root, start: int) -> int:\\n        time_to_infect_tree, _ = self.dfs(root, start)\\n        return time_to_infect_tree\\n\\n    def dfs(self, root, start):\\n        if root == None:\\n            return -1, -1\\n\\n        left_infect_time, left_distance = self.dfs(root.left, start)\\n        right_infect_time, right_distance = self.dfs(root.right, start)\\n\\t\\t\\n        if left_distance == -1 and right_distance == -1:\\n            distance = -1\\n            infect_time = max(right_infect_time, left_infect_time) + 1\\n\\n        elif left_distance != -1:\\n            distance = left_distance + 1\\n            infect_time = max(left_infect_time, right_infect_time + left_distance + 2)\\n           \\n        else:\\n            distance = right_distance + 1\\n            infect_time = max(right_infect_time, left_infect_time + right_distance + 2)\\n\\n        if root.val == start:\\n            distance = 0\\n\\n        return infect_time, distance\\n```\n```\\nclass Solution:\\n    def amountOfTime(self, root, start: int) -> int:\\n        time_to_infect_tree, _ = self.dfs(root, start)\\n        return time_to_infect_tree\\n\\n    def dfs(self, root, start):\\n\\n        # if root is None\\n        if root == None:\\n            return -1, -1\\n\\n        # get time to infect subtree from root, as well as distance from root of subtree\\n        # to the infected node (-1 if root is not a parent of it)\\n        left_infect_time, left_distance = self.dfs(root.left, start)\\n        right_infect_time, right_distance = self.dfs(root.right, start)\\n\\n        # if both subtrees don\\'t contain the infected node\\n        if left_distance == -1 and right_distance == -1:\\n            distance = -1\\n            # infect time is as if from root node, AKA simply the depth of the subtree\\n            infect_time = max(right_infect_time, left_infect_time) + 1\\n\\n        # if left subtree contains the infected node\\n        elif left_distance != -1:\\n            # update distance to infected node\\n            distance = left_distance + 1\\n            # distance to the infected node from root.left, then two edges to root.right (+2), then\\n            # infect time of right subtree as if from root.right\\n            infect_time = max(left_infect_time, right_infect_time + left_distance + 2)\\n            \\n        # same as before, but with right subtree containing the infected\\n        else:\\n            distance = right_distance + 1\\n            infect_time = max(right_infect_time, left_infect_time + right_distance + 2)\\n\\n        # if found the infected node\\n        if root.val == start:\\n            distance = 0\\n\\n        return infect_time, distance\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2557718,
                "title": "c-bfs-step-by-step-explanation-very-clean-code",
                "content": "## Intuition : \\n* After building the graph of the given tree, we will start BFS traversal at the infected node\\n* The time it takes to traverse the entire graph is also the time it will take to infect the entire graph.\\n* Hence we will maintain a count of the level of traversals and return that as our answer.\\n\\n```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    // Function to build the graph of the given tree\\n    void buildGraph(TreeNode *root, vector<vector<int>> &adj)\\n    {\\n        if(root == NULL)\\n            return;\\n        if(root -> left)\\n        {\\n            adj[root -> val].push_back(root -> left -> val);\\n            adj[root -> left -> val].push_back(root -> val);\\n        }\\n        if(root -> right)\\n        {\\n            adj[root -> val].push_back(root -> right -> val);\\n            adj[root -> right -> val].push_back(root -> val);\\n        }\\n        buildGraph(root -> left, adj);\\n        buildGraph(root -> right, adj);\\n    }\\n    // function to implement bfs in the graph\\n    \\n    void bfs(vector<vector<int>> &adj, vector<bool> &visited, int start)\\n    {\\n        queue<int> q;\\n        // We start the BFS from start node and traverse the entire graph\\n        // The time it takes to traverse is also the time it takes to get infected\\n        q.push(start);\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            for(int i = 0 ; i < n; i++)\\n            {\\n                int u = q.front();      // Extracting the node that needs to be traversed\\n                q.pop();\\n                visited[u] = true;         // marking the currently traversed node to true\\n                for(int i = 0; i < adj[u].size(); i++)\\n                {\\n                     // if adjacent nodes are not visited, push them into the queue\\n                    if(!visited[adj[u][i]]) \\n                        q.push(adj[u][i]);\\n                }\\n            }\\n            ans++;       // keep a count for the traversal\\n        }   \\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        // vector to store the graph\\n        vector<vector<int>> adj(100001);\\n        // vector to check which nodes are visited\\n        vector<bool> visited(100001, false);\\n        \\n        buildGraph(root, adj);\\n        bfs(adj, visited, start);\\n        // return ans - 1, coz the start node is also counted in traversal, but it was already infeced\\n        return ans - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int ans = 0;\\n    // Function to build the graph of the given tree\\n    void buildGraph(TreeNode *root, vector<vector<int>> &adj)\\n    {\\n        if(root == NULL)\\n            return;\\n        if(root -> left)\\n        {\\n            adj[root -> val].push_back(root -> left -> val);\\n            adj[root -> left -> val].push_back(root -> val);\\n        }\\n        if(root -> right)\\n        {\\n            adj[root -> val].push_back(root -> right -> val);\\n            adj[root -> right -> val].push_back(root -> val);\\n        }\\n        buildGraph(root -> left, adj);\\n        buildGraph(root -> right, adj);\\n    }\\n    // function to implement bfs in the graph\\n    \\n    void bfs(vector<vector<int>> &adj, vector<bool> &visited, int start)\\n    {\\n        queue<int> q;\\n        // We start the BFS from start node and traverse the entire graph\\n        // The time it takes to traverse is also the time it takes to get infected\\n        q.push(start);\\n        while(!q.empty())\\n        {\\n            int n = q.size();\\n            for(int i = 0 ; i < n; i++)\\n            {\\n                int u = q.front();      // Extracting the node that needs to be traversed\\n                q.pop();\\n                visited[u] = true;         // marking the currently traversed node to true\\n                for(int i = 0; i < adj[u].size(); i++)\\n                {\\n                     // if adjacent nodes are not visited, push them into the queue\\n                    if(!visited[adj[u][i]]) \\n                        q.push(adj[u][i]);\\n                }\\n            }\\n            ans++;       // keep a count for the traversal\\n        }   \\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        // vector to store the graph\\n        vector<vector<int>> adj(100001);\\n        // vector to check which nodes are visited\\n        vector<bool> visited(100001, false);\\n        \\n        buildGraph(root, adj);\\n        bfs(adj, visited, start);\\n        // return ans - 1, coz the start node is also counted in traversal, but it was already infeced\\n        return ans - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2551695,
                "title": "python-dfs-soln-faster-than-90-w-proof-easy-to-understand",
                "content": "Idea is that we can mutate the given tree node to hold parent pointers.\\n1. Add parent pointer to all the nodes\\n2. Calculate max depth from the start node\\n```\\ndef amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n\\t# DFS function to add parent pointer to all nodes and get the start node\\n\\tdef addParent(node, parent):\\n\\t\\tif not node:\\n\\t\\t\\treturn\\n\\n\\t\\tnode.parent = parent # mutating node and adding parent pointer\\n\\t\\tif node.val == start: # get the start node\\n\\t\\t\\tnonlocal startNode \\n\\t\\t\\tstartNode = node\\n\\n\\t\\taddParent(node.left, node)\\n\\t\\taddParent(node.right, node)\\n\\t\\n\\t# DFS function to calculate root to leaf maximum depth, here root is start node\\n\\tdef maxDepth(node):\\n\\t\\tif not node or node in seen:\\n\\t\\t\\treturn 0\\n\\n\\t\\tseen.add(node)\\n\\n\\t\\treturn 1 + max(maxDepth(node.left), maxDepth(node.right), maxDepth(node.parent))\\n\\n\\tseen = set()\\n\\tstartNode = None\\n\\taddParent(root, None)\\n\\n\\treturn maxDepth(startNode) - 1 # -1 to exclude the startNode\\n```\\n\\nTime: `O(n)` \\nSpace: `O(n)`\\n\\n![image](https://assets.leetcode.com/users/images/6dcfcaa0-bd08-4562-8e5b-6d5137c11884_1662692869.7842314.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/227fc269-7b54-4e64-b490-66e6154a40cd_1662518370.2619233.png)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n\\t# DFS function to add parent pointer to all nodes and get the start node\\n\\tdef addParent(node, parent):\\n\\t\\tif not node:\\n\\t\\t\\treturn\\n\\n\\t\\tnode.parent = parent # mutating node and adding parent pointer\\n\\t\\tif node.val == start: # get the start node\\n\\t\\t\\tnonlocal startNode \\n\\t\\t\\tstartNode = node\\n\\n\\t\\taddParent(node.left, node)\\n\\t\\taddParent(node.right, node)\\n\\t\\n\\t# DFS function to calculate root to leaf maximum depth, here root is start node\\n\\tdef maxDepth(node):\\n\\t\\tif not node or node in seen:\\n\\t\\t\\treturn 0\\n\\n\\t\\tseen.add(node)\\n\\n\\t\\treturn 1 + max(maxDepth(node.left), maxDepth(node.right), maxDepth(node.parent))\\n\\n\\tseen = set()\\n\\tstartNode = None\\n\\taddParent(root, None)\\n\\n\\treturn maxDepth(startNode) - 1 # -1 to exclude the startNode\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2539885,
                "title": "how-is-this-possible",
                "content": "I\\'ve been trying to solve this problem in several ways. And suddenly, I had this issue!!\\n\\nIt runs correctly when I try that sample, but when I submit, I get WA xD\\n\\n![image](https://assets.leetcode.com/users/images/ec8ee545-cb80-41b3-be9a-583948deba55_1662466830.091066.jpeg)\\n",
                "solutionTags": [
                    "Tree",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "I\\'ve been trying to solve this problem in several ways. And suddenly, I had this issue!!\\n\\nIt runs correctly when I try that sample, but when I submit, I get WA xD\\n\\n![image](https://assets.leetcode.com/users/images/ec8ee545-cb80-41b3-be9a-583948deba55_1662466830.091066.jpeg)\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 2531927,
                "title": "dfs",
                "content": "**1 pass / dfs / recursive with helper**\\n**time: `O(n)`; space: `O(N)`(call stack)**\\n\\n![image](https://assets.leetcode.com/users/images/c3141aa5-169b-456b-be05-ad5e2370b7c8_1662368831.081831.png)\\n\\nSo basically all points are either \"below\" `s` (gray nodes) or \"above/equal\" it (red nodes and green node) in the tree. \\n\\nThe parent node needs to know weither it\\'s two children are gray nodes or not. Depending on the answer it uses different expressions to update the `out` variable that stores the answer to the problem and a `return` value.\\n\\n![image](https://assets.leetcode.com/users/images/f1fd258c-3966-41bf-8f0e-3c409c49bbd9_1662374245.5740168.png)\\n\\n```\\nclass Solution \\n{\\n    int out{};\\n    pair<int, int> f(TreeNode* n, int s)\\n    {\\n        if(!n) return {-1,0};\\n        auto l = f(n->left,  s),\\n             r = f(n->right, s);\\n        if(n->val==s)\\n        {\\n            out = max(out, 1+max(l.first, r.first));\\n            return {0,1};\\n        }\\n        if(l.second or r.second)\\n        {\\n            out = max(out, 2+l.first+r.first);\\n            return {1+l.first*l.second+r.first*r.second, 1};\\n        }\\n        return {1+max(l.first, r.first), 0};\\n    }\\npublic:    \\n    int amountOfTime(TreeNode* n, int s)\\n    {\\n        f(n, s);\\n        return out; \\n    }\\n};\\n```\\n**Notation:**\\n`f` function returns a pair of numbers. The second one indicates weither this node is\\n* red/green(`1`) or\\n* gray(`0`).\\n* \\nUsing `int\\'s` instead of `booleans` allows to use them in arithmetic expressions like this \\n```\\nreturn {1+l.first*l.second+r.first*r.second, 1};\\n```\\nthat makes the code a bit shorter. The reason for passing `0` or `1`. for the calee is that depending on that we have to use two different formulas: one involves `max` function\\n```\\n return {1+max(l.first, r.first), 0};\\n```\\nthe other one involves `+`operator\\n```\\nreturn {1+l.first*l.second+r.first*r.second, 1};\\n```\\nAlso they update `out` variable in different ways.\\n\\nAs for the first number that `f` returns it\\'s either \\n* the longest path from the current node to the leaf **for gray nodes** or \\n* the longest path from the current node to the green node **for red nodes**.\\n\\nAnother problem: [742. Closest Leaf in a Binary Tree](https://leetcode.com/problems/closest-leaf-in-a-binary-tree/discuss/2535358/dfs)",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution \\n{\\n    int out{};\\n    pair<int, int> f(TreeNode* n, int s)\\n    {\\n        if(!n) return {-1,0};\\n        auto l = f(n->left,  s),\\n             r = f(n->right, s);\\n        if(n->val==s)\\n        {\\n            out = max(out, 1+max(l.first, r.first));\\n            return {0,1};\\n        }\\n        if(l.second or r.second)\\n        {\\n            out = max(out, 2+l.first+r.first);\\n            return {1+l.first*l.second+r.first*r.second, 1};\\n        }\\n        return {1+max(l.first, r.first), 0};\\n    }\\npublic:    \\n    int amountOfTime(TreeNode* n, int s)\\n    {\\n        f(n, s);\\n        return out; \\n    }\\n};\\n```\n```\\nreturn {1+l.first*l.second+r.first*r.second, 1};\\n```\n```\\n return {1+max(l.first, r.first), 0};\\n```\n```\\nreturn {1+l.first*l.second+r.first*r.second, 1};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2531841,
                "title": "javascript-bfs-vs-dfs-create-a-graph-and-dfs-or-bfs-to-check-depth",
                "content": "Approach: create graph and run dfs/bfs on it to measure map depth\\n\\nBFS is a little easier here.\\n\\nBFS:\\n```\\nvar amountOfTime = function(root, start) {\\n    const adj = {}\\n    \\n    function dfs(root, parent) {\\n        if(!root) return null\\n        \\n        if(parent) {\\n            if(!(parent in adj)) adj[parent] = []\\n            adj[parent].push(root.val)\\n            \\n            if(!(root.val in adj)) adj[root.val] = []\\n            adj[root.val].push(parent)\\n        }\\n        \\n        if(root.left) {\\n           dfs(root.left, root.val) \\n        }\\n        if(root.right) {\\n            dfs(root.right, root.val)\\n        }\\n    }\\n    \\n    dfs(root, null)\\n    \\n    const queue = [start]   \\n    let distance = 0\\n    const visited = new Set()\\n    visited.add(start)\\n    \\n    while(queue.length) {\\n        const len = queue.length\\n        distance++\\n        \\n        for(let i = 0; i < len; i++) {\\n            const currNode = queue.shift()\\n            \\n            const children = adj[currNode]\\n            \\n            if(!children) continue\\n            \\n            for(const child of children) {\\n               if(visited.has(child)) continue\\n               visited.add(child)\\n               queue.push(child)\\n            }\\n        }\\n    }\\n    \\n    return distance - 1\\n};\\n```\\nDFS:\\n```\\nvar amountOfTime = function(root, start) {\\n  const adj = {}\\n  \\n  // 1. Build graph\\n  dfs(root,null)\\n    \\n  function dfs(root,parent) {\\n      if(!root) return null\\n      \\n      if(parent !== null) {\\n          if(!(parent in adj)) adj[parent] = []\\n          adj[parent].push(root.val)\\n          \\n          if(!(root.val in adj)) adj[root.val] = []\\n          adj[root.val].push(parent)\\n      }\\n      \\n      if(root.left) {\\n          dfs(root.left, root.val)\\n      }\\n      \\n      if(root.right) {\\n          dfs(root.right, root.val)\\n      }\\n  }\\n    \\n  // 2. Edge case, if adj list is empty return 0\\n  if(Object.keys(adj).length === 0) return 0\\n    \\n  const visited = new Set()\\n    \\n  // 3. Traverse from the graph and get max depth\\n  function dfs2(node) {\\n     if(visited.has(node)) return 0\\n     visited.add(node)\\n     const children = adj[node]\\n     \\n     if(!children) return 0\\n      \\n     let subResult = 0\\n     for(const child of children) {\\n        subResult = Math.max(dfs2(child)+1, subResult) \\n     } \\n     \\n      return subResult\\n  }  \\n    \\n    const res = dfs2(start)\\n    \\n    // 4. Subtract 1 as we started calculating depth from first level\\n    return res-1\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Breadth-First Search"
                ],
                "code": "```\\nvar amountOfTime = function(root, start) {\\n    const adj = {}\\n    \\n    function dfs(root, parent) {\\n        if(!root) return null\\n        \\n        if(parent) {\\n            if(!(parent in adj)) adj[parent] = []\\n            adj[parent].push(root.val)\\n            \\n            if(!(root.val in adj)) adj[root.val] = []\\n            adj[root.val].push(parent)\\n        }\\n        \\n        if(root.left) {\\n           dfs(root.left, root.val) \\n        }\\n        if(root.right) {\\n            dfs(root.right, root.val)\\n        }\\n    }\\n    \\n    dfs(root, null)\\n    \\n    const queue = [start]   \\n    let distance = 0\\n    const visited = new Set()\\n    visited.add(start)\\n    \\n    while(queue.length) {\\n        const len = queue.length\\n        distance++\\n        \\n        for(let i = 0; i < len; i++) {\\n            const currNode = queue.shift()\\n            \\n            const children = adj[currNode]\\n            \\n            if(!children) continue\\n            \\n            for(const child of children) {\\n               if(visited.has(child)) continue\\n               visited.add(child)\\n               queue.push(child)\\n            }\\n        }\\n    }\\n    \\n    return distance - 1\\n};\\n```\n```\\nvar amountOfTime = function(root, start) {\\n  const adj = {}\\n  \\n  // 1. Build graph\\n  dfs(root,null)\\n    \\n  function dfs(root,parent) {\\n      if(!root) return null\\n      \\n      if(parent !== null) {\\n          if(!(parent in adj)) adj[parent] = []\\n          adj[parent].push(root.val)\\n          \\n          if(!(root.val in adj)) adj[root.val] = []\\n          adj[root.val].push(parent)\\n      }\\n      \\n      if(root.left) {\\n          dfs(root.left, root.val)\\n      }\\n      \\n      if(root.right) {\\n          dfs(root.right, root.val)\\n      }\\n  }\\n    \\n  // 2. Edge case, if adj list is empty return 0\\n  if(Object.keys(adj).length === 0) return 0\\n    \\n  const visited = new Set()\\n    \\n  // 3. Traverse from the graph and get max depth\\n  function dfs2(node) {\\n     if(visited.has(node)) return 0\\n     visited.add(node)\\n     const children = adj[node]\\n     \\n     if(!children) return 0\\n      \\n     let subResult = 0\\n     for(const child of children) {\\n        subResult = Math.max(dfs2(child)+1, subResult) \\n     } \\n     \\n      return subResult\\n  }  \\n    \\n    const res = dfs2(start)\\n    \\n    // 4. Subtract 1 as we started calculating depth from first level\\n    return res-1\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2523052,
                "title": "java-recursion-short-code-with-explanation",
                "content": "bottom-up recursion\\nuse \\'negative\\' integer to indicate we have met burn node\\n\\ncase 1: haven\\'t met burn node \\n=> pass height of tree to parent\\n\\ncase 2: current node is burn node \\n=> change the signal to \\'-1\\'; start updating global max of burning time\\n\\ncase 3: have met burn node\\n=> pass the negative result to parent(indicate the burning time); update burning time if necessary\\n\\n```\\nclass Solution {\\n    int max = 0;\\n    public int amountOfTime(TreeNode root, int start) {\\n        helper(root, start);\\n        return max;\\n    }\\n    private int helper(TreeNode root, int start) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int left = helper(root.left, start);\\n        int right = helper(root.right, start);\\n        if (root.val == start) { //case 2\\n            max = Math.max(max, Math.max(left, right));\\n            return -1;\\n        } else if (left < 0 || right < 0) { //case 3\\n            max = Math.max(max, Math.abs(left) + Math.abs(right));\\n            return left < 0 ? left - 1 : right - 1;\\n        } else { //case 1\\n            return Math.max(left, right) + 1;\\n        }\\n    }\\n}\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    public int amountOfTime(TreeNode root, int start) {\\n        helper(root, start);\\n        return max;\\n    }\\n    private int helper(TreeNode root, int start) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int left = helper(root.left, start);\\n        int right = helper(root.right, start);\\n        if (root.val == start) { //case 2\\n            max = Math.max(max, Math.max(left, right));\\n            return -1;\\n        } else if (left < 0 || right < 0) { //case 3\\n            max = Math.max(max, Math.abs(left) + Math.abs(right));\\n            return left < 0 ? left - 1 : right - 1;\\n        } else { //case 1\\n            return Math.max(left, right) + 1;\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2522412,
                "title": "c-dfs-graph",
                "content": "```\\nclass Solution {\\npublic:\\n    void createGraph(TreeNode* root,unordered_map<int,vector<int>>&mp){\\n        if(root==NULL)return;\\n        createGraph(root->right,mp);\\n        createGraph(root->left,mp);\\n        if(root->right){\\n            mp[root->val].push_back(root->right->val);\\n            mp[root->right->val].push_back(root->val);\\n        }\\n        if(root->left){ \\n            mp[root->val].push_back(root->left->val);\\n            mp[root->left->val].push_back(root->val);\\n        }\\n    }\\n    int solve(TreeNode* root,unordered_map<int,vector<int>>&mp,int start){\\n        queue<pair<int,int>>q;\\n        q.push({start,0});\\n        int ans=0;\\n        while(!q.empty()){\\n            auto frnt=q.front();\\n            q.pop();\\n            for(auto i:mp[frnt.first]){\\n                if(mp.find(i)!=mp.end()) q.push({i,frnt.second+1});\\n            }\\n            ans=max(ans,frnt.second);\\n            mp.erase(frnt.first);\\n        }\\n        return ans;\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<int,vector<int>>mp;\\n        createGraph(root,mp);\\n        return solve(root,mp,start);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void createGraph(TreeNode* root,unordered_map<int,vector<int>>&mp){\\n        if(root==NULL)return;\\n        createGraph(root->right,mp);\\n        createGraph(root->left,mp);\\n        if(root->right){\\n            mp[root->val].push_back(root->right->val);\\n            mp[root->right->val].push_back(root->val);\\n        }\\n        if(root->left){ \\n            mp[root->val].push_back(root->left->val);\\n            mp[root->left->val].push_back(root->val);\\n        }\\n    }\\n    int solve(TreeNode* root,unordered_map<int,vector<int>>&mp,int start){\\n        queue<pair<int,int>>q;\\n        q.push({start,0});\\n        int ans=0;\\n        while(!q.empty()){\\n            auto frnt=q.front();\\n            q.pop();\\n            for(auto i:mp[frnt.first]){\\n                if(mp.find(i)!=mp.end()) q.push({i,frnt.second+1});\\n            }\\n            ans=max(ans,frnt.second);\\n            mp.erase(frnt.first);\\n        }\\n        return ans;\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<int,vector<int>>mp;\\n        createGraph(root,mp);\\n        return solve(root,mp,start);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2504107,
                "title": "java-easy-bfs-solution-commented-code-similar-to-nodes-k-distance-away",
                "content": "```\\n// Easy BFS implementation. Instead of \\'root\\', node with \\'start\\' value becomes the starting node for BFS.\\nclass Solution {\\n\\t// Start node for BFS\\n    TreeNode origin=null;\\n    \\n    public int amountOfTime(TreeNode root, int start) {\\n        int time=0;\\n        if(root==null) return time;\\n        \\n        HashMap<TreeNode,TreeNode> map=new HashMap<>();\\n        getParentMap(root, start, map);\\n        \\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(origin);\\n        \\n        HashSet<TreeNode> visited=new HashSet<>();\\n        \\n        while(q.size()>0){\\n            int size=q.size();\\n    \\n            while(size-->0){\\n                TreeNode x=q.poll();\\n                visited.add(x);\\n                \\n                if(x.left!=null && !visited.contains(x.left)) q.add(x.left);\\n                if(x.right!=null && !visited.contains(x.right)) q.add(x.right);\\n                if(map.containsKey(x) && !visited.contains(map.get(x))) q.add(map.get(x));\\n            }\\n            time++;\\n        }\\n        return time-1;\\n    }\\n    \\n\\t// Populates Map[To travel to parent node as well] -> (Child : Parent)\\n    private void getParentMap(TreeNode root, int start, HashMap<TreeNode,TreeNode> map){\\n        if(root==null) return;\\n        \\n        if(root.left!=null) map.put(root.left,root);\\n        if(root.right!=null) map.put(root.right,root);\\n        \\n\\t\\t// Defining start node for BFS\\n        if(root.val==start) origin=root;\\n        \\n        getParentMap(root.left,start,map);\\n        getParentMap(root.right,start,map);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n// Easy BFS implementation. Instead of \\'root\\', node with \\'start\\' value becomes the starting node for BFS.\\nclass Solution {\\n\\t// Start node for BFS\\n    TreeNode origin=null;\\n    \\n    public int amountOfTime(TreeNode root, int start) {\\n        int time=0;\\n        if(root==null) return time;\\n        \\n        HashMap<TreeNode,TreeNode> map=new HashMap<>();\\n        getParentMap(root, start, map);\\n        \\n        Queue<TreeNode> q=new LinkedList<>();\\n        q.add(origin);\\n        \\n        HashSet<TreeNode> visited=new HashSet<>();\\n        \\n        while(q.size()>0){\\n            int size=q.size();\\n    \\n            while(size-->0){\\n                TreeNode x=q.poll();\\n                visited.add(x);\\n                \\n                if(x.left!=null && !visited.contains(x.left)) q.add(x.left);\\n                if(x.right!=null && !visited.contains(x.right)) q.add(x.right);\\n                if(map.containsKey(x) && !visited.contains(map.get(x))) q.add(map.get(x));\\n            }\\n            time++;\\n        }\\n        return time-1;\\n    }\\n    \\n\\t// Populates Map[To travel to parent node as well] -> (Child : Parent)\\n    private void getParentMap(TreeNode root, int start, HashMap<TreeNode,TreeNode> map){\\n        if(root==null) return;\\n        \\n        if(root.left!=null) map.put(root.left,root);\\n        if(root.right!=null) map.put(root.right,root);\\n        \\n\\t\\t// Defining start node for BFS\\n        if(root.val==start) origin=root;\\n        \\n        getParentMap(root.left,start,map);\\n        getParentMap(root.right,start,map);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2499071,
                "title": "o-n-solution-without-making-graph-bfs-dfs-in-javascript",
                "content": "\\n**\"Keep Learning and keep Growing\"**\\n\\n**Let see my Approach**\\n1. we do **PostOrder** traversal using recursion.\\n2. we gonna *count the no. of nodes* in **left** and **right** subtree by \\n   returning Max(left,right) + 1 (current node itself)\\n   and check if at this node We get Maximum or not \\n  i.e \\n  ```if(max > minutes) minutes = max;```\\n3. we need a **map** for storing infection time from subtrees to root.\\n\\n**Cases :**\\n1. root node is infected node then max(left , right)+ 0 (root is infected) will be answer\\n2. left subtree is infected, we lookup in Map the left subtree root and get what minutes it took to get infected.\\n\\t map.get(root.left) + 1 (current root node itself)\\n\\tand we don\\'t consider the left subtree return value becoz it\\'s already infected.\\n\\twe consider right subtree, how much time it would take to get infected whole from root of that subtree.\\n\\ti.e actually, we going up in traversal towards root\\n3. for right subtree is same case 2 apply\\n\\n\\nTake an **Example** where **infected node** is at **level** > 2. after it the picture will seem clear to you.\\nyou may uncomment the consoleLogs for better visualisation.\\n\\n\\t\\n\\n```\\nconst map = new Map();\\n    map.set(start,0);\\n    let minutes=0;\\n     \\n    explore(root);\\n    //console.log(map);\\n    return minutes;\\n   \\n    function explore(root){\\n        if(!root) return 0;\\n     \\n        let max=1, left=0,right=0;    \\n        if(root.left){\\n            left= explore(root.left);\\n            if(map.has(root.left.val)){\\n                max += map.get(root.left.val);\\n                //console.log(\\'root\\', root.val,\\' left \\',root.left.val, max);\\n                map.set(root.val,max);  // setting minute it get infection for its parent node\\n                left=0;\\n            }\\n        }\\n        if(root.right){        \\n            right= explore(root.right);\\n\\n            if(map.has(root.right.val)){\\n                max += map.get(root.right.val);\\n                //console.log(\\'root\\', root.val,\\' right \\',root.right.val, max);\\n                map.set(root.val,max);\\n                right=0;\\n            }        \\n        }\\n        if(root.val===start) { // when root is infected max variable = 0\\n           max = map.get(root.val);       \\n        }     \\n        //console.log(root.val,\\' left \\',left,max,right,\\' right\\');\\n        max = Math.max(left,right) + max; \\n        \\n        if(max > minutes) minutes = max;\\n        \\n        return max;\\n   }    \\n   ```",
                "solutionTags": [
                    "JavaScript",
                    "Recursion"
                ],
                "code": "```if(max > minutes) minutes = max;```\n```\\nconst map = new Map();\\n    map.set(start,0);\\n    let minutes=0;\\n     \\n    explore(root);\\n    //console.log(map);\\n    return minutes;\\n   \\n    function explore(root){\\n        if(!root) return 0;\\n     \\n        let max=1, left=0,right=0;    \\n        if(root.left){\\n            left= explore(root.left);\\n            if(map.has(root.left.val)){\\n                max += map.get(root.left.val);\\n                //console.log(\\'root\\', root.val,\\' left \\',root.left.val, max);\\n                map.set(root.val,max);  // setting minute it get infection for its parent node\\n                left=0;\\n            }\\n        }\\n        if(root.right){        \\n            right= explore(root.right);\\n\\n            if(map.has(root.right.val)){\\n                max += map.get(root.right.val);\\n                //console.log(\\'root\\', root.val,\\' right \\',root.right.val, max);\\n                map.set(root.val,max);\\n                right=0;\\n            }        \\n        }\\n        if(root.val===start) { // when root is infected max variable = 0\\n           max = map.get(root.val);       \\n        }     \\n        //console.log(root.val,\\' left \\',left,max,right,\\' right\\');\\n        max = Math.max(left,right) + max; \\n        \\n        if(max > minutes) minutes = max;\\n        \\n        return max;\\n   }    \\n   ```",
                "codeTag": "Unknown"
            },
            {
                "id": 2497515,
                "title": "all-nodes-at-k-distance-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n      \\n        map<TreeNode *, TreeNode *> m; //keeping parent of current node\\n        m[root] =0; //initialising root with no parent\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        TreeNode*target;\\n        while (!q.empty()) //bfs traversal for map\\n        {\\n            TreeNode *temp = q.front();\\n            q.pop();\\n            if(temp->val==start)target=temp; //finding infected node\\n            if (temp->left)\\n            {\\n                q.push(temp->left);\\n                m[temp->left] = temp;\\n            }\\n            if (temp->right)\\n            {\\n                q.push(temp->right);\\n                m[temp->right] = temp;\\n            }\\n        }\\n        queue<TreeNode *> l; // traversing with bfs approch on all adjacent nodes simaltaneously \\n        l.push(target);\\n        int dist = 0;\\n        set<int> st; // marking node as visited\\n        while (!l.empty())\\n        {\\n            dist++; // checking time or distance covered\\n            int sz = l.size();\\n            while (sz--)\\n            {\\n                TreeNode *r = l.front();\\n                l.pop();\\n\\n                    if (r->left&&st.find(r->left->val)==st.end()) //if not visited \\n                        l.push(r->left);\\n                    if (r->right&&st.find(r->right->val)==st.end())\\n                        l.push(r->right);\\n                    if (m[r]&&st.find(m[r]->val)==st.end())\\n                        l.push(m[r]);\\n\\n                st.insert(r->val);\\n            }\\n        }\\n        return dist-1;\\n      \\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n      \\n        map<TreeNode *, TreeNode *> m; //keeping parent of current node\\n        m[root] =0; //initialising root with no parent\\n        queue<TreeNode *> q;\\n        q.push(root);\\n        TreeNode*target;\\n        while (!q.empty()) //bfs traversal for map\\n        {\\n            TreeNode *temp = q.front();\\n            q.pop();\\n            if(temp->val==start)target=temp; //finding infected node\\n            if (temp->left)\\n            {\\n                q.push(temp->left);\\n                m[temp->left] = temp;\\n            }\\n            if (temp->right)\\n            {\\n                q.push(temp->right);\\n                m[temp->right] = temp;\\n            }\\n        }\\n        queue<TreeNode *> l; // traversing with bfs approch on all adjacent nodes simaltaneously \\n        l.push(target);\\n        int dist = 0;\\n        set<int> st; // marking node as visited\\n        while (!l.empty())\\n        {\\n            dist++; // checking time or distance covered\\n            int sz = l.size();\\n            while (sz--)\\n            {\\n                TreeNode *r = l.front();\\n                l.pop();\\n\\n                    if (r->left&&st.find(r->left->val)==st.end()) //if not visited \\n                        l.push(r->left);\\n                    if (r->right&&st.find(r->right->val)==st.end())\\n                        l.push(r->right);\\n                    if (m[r]&&st.find(m[r]->val)==st.end())\\n                        l.push(m[r]);\\n\\n                st.insert(r->val);\\n            }\\n        }\\n        return dist-1;\\n      \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2494706,
                "title": "without-creating-graph-c-solution",
                "content": "```\\nclass Solution {\\n    vector<int> dfs(TreeNode* root,int &ans,int &start){\\n        if(!root) return {0,0};\\n        if(root->val==start){\\n            ans=max(ans,max(dfs(root->left,ans,start)[1],dfs(root->right,ans,start)[1] ) );\\n            return {1,0};\\n        }\\n        \\n        vector<int> l= dfs(root->left,ans,start);\\n        vector<int> r= dfs(root->right,ans,start);\\n        if(l[0] || r[0]){\\n            ans=max(ans,1+l[1]+r[1]);\\n            if(l[0]) return {1,1+l[1]};\\n            return {1,1+r[1]};\\n        }\\n        return {0,1+max(l[1],r[1])};\\n    }\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        int ans=0;\\n        vector<int> t=dfs(root,ans,start);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> dfs(TreeNode* root,int &ans,int &start){\\n        if(!root) return {0,0};\\n        if(root->val==start){\\n            ans=max(ans,max(dfs(root->left,ans,start)[1],dfs(root->right,ans,start)[1] ) );\\n            return {1,0};\\n        }\\n        \\n        vector<int> l= dfs(root->left,ans,start);\\n        vector<int> r= dfs(root->right,ans,start);\\n        if(l[0] || r[0]){\\n            ans=max(ans,1+l[1]+r[1]);\\n            if(l[0]) return {1,1+l[1]};\\n            return {1,1+r[1]};\\n        }\\n        return {0,1+max(l[1],r[1])};\\n    }\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        int ans=0;\\n        vector<int> t=dfs(root,ans,start);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2490783,
                "title": "bfs-java-solution",
                "content": "#### Explanation: \\nCreate a map to find parent node apply BFS starting from root for it also find the start node from the given start value.\\nUse a visited Set (since all nodes are unique) to keep track of visited nodes and start the BFS starting from **start** infected node. increase the time only if the node was enqueued in the queue while doing BFS to find the time.\\n\\n```\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        Map<TreeNode, TreeNode> parents = new HashMap<>();\\n        TreeNode startNode = mapParents(parents, root, start);\\n        Set<TreeNode> visited = new HashSet<>();\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(startNode);\\n        visited.add(startNode);\\n        int time = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            boolean enqueued = false;\\n            for(int i =0; i<size; i++){\\n                TreeNode node = queue.poll();\\n                if(node.left != null && !visited.contains(node.left)){\\n                    visited.add(node.left);\\n                    queue.offer(node.left);\\n                    enqueued = true;\\n                }\\n                if(node.right != null && !visited.contains(node.right)){\\n                    visited.add(node.right);\\n                    queue.offer(node.right);\\n                    enqueued = true;\\n                }\\n                if(parents.get(node)!=null && !visited.contains(parents.get(node))){\\n                    visited.add(parents.get(node));\\n                    queue.offer(parents.get(node));\\n                    enqueued = true;\\n                }\\n            }\\n            if(enqueued) time++;\\n        }\\n        return time;\\n    }\\n    \\n    private TreeNode mapParents(Map<TreeNode, TreeNode> parents, TreeNode root, int target){\\n        TreeNode targetNode = null;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i =0; i<size; i++){\\n                TreeNode node = queue.poll();\\n                if(node.val == target){\\n                    targetNode = node;\\n                }\\n                if(node.left!= null){\\n                    queue.offer(node.left);\\n                    parents.put(node.left, node);\\n                }\\n                if(node.right != null){\\n                    queue.offer(node.right);\\n                    parents.put(node.right, node);\\n                }\\n            }\\n        }\\n        return targetNode;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        Map<TreeNode, TreeNode> parents = new HashMap<>();\\n        TreeNode startNode = mapParents(parents, root, start);\\n        Set<TreeNode> visited = new HashSet<>();\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(startNode);\\n        visited.add(startNode);\\n        int time = 0;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            boolean enqueued = false;\\n            for(int i =0; i<size; i++){\\n                TreeNode node = queue.poll();\\n                if(node.left != null && !visited.contains(node.left)){\\n                    visited.add(node.left);\\n                    queue.offer(node.left);\\n                    enqueued = true;\\n                }\\n                if(node.right != null && !visited.contains(node.right)){\\n                    visited.add(node.right);\\n                    queue.offer(node.right);\\n                    enqueued = true;\\n                }\\n                if(parents.get(node)!=null && !visited.contains(parents.get(node))){\\n                    visited.add(parents.get(node));\\n                    queue.offer(parents.get(node));\\n                    enqueued = true;\\n                }\\n            }\\n            if(enqueued) time++;\\n        }\\n        return time;\\n    }\\n    \\n    private TreeNode mapParents(Map<TreeNode, TreeNode> parents, TreeNode root, int target){\\n        TreeNode targetNode = null;\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.offer(root);\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i =0; i<size; i++){\\n                TreeNode node = queue.poll();\\n                if(node.val == target){\\n                    targetNode = node;\\n                }\\n                if(node.left!= null){\\n                    queue.offer(node.left);\\n                    parents.put(node.left, node);\\n                }\\n                if(node.right != null){\\n                    queue.offer(node.right);\\n                    parents.put(node.right, node);\\n                }\\n            }\\n        }\\n        return targetNode;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2485578,
                "title": "python-simple-dfs",
                "content": "\\n    def amountOfTime(self, root, start):\\n        dict1 = defaultdict(list)\\n        \\n        def dfs(node):\\n            if node.left:\\n                dict1[node.val].append(node.left.val)\\n                dict1[node.left.val].append(node.val)\\n                dfs(node.left)\\n                \\n            if node.right:\\n                dict1[node.val].append(node.right.val)\\n                dict1[node.right.val].append(node.val)\\n                dfs(node.right)\\n            \\n        dfs(root)\\n        \\n        visited, self.result = set(), 0\\n        \\n        def dfs(node, time):\\n            self.result = max(self.result, time)\\n            \\n            visited.add(node)\\n            \\n            for neighbor in dict1[node]:\\n                if neighbor not in visited:\\n                    dfs(neighbor, time + 1)\\n        \\n        dfs(start, 0)\\n        \\n        return self.result",
                "solutionTags": [],
                "code": "\\n    def amountOfTime(self, root, start):\\n        dict1 = defaultdict(list)\\n        \\n        def dfs(node):\\n            if node.left:\\n                dict1[node.val].append(node.left.val)\\n                dict1[node.left.val].append(node.val)\\n                dfs(node.left)\\n                \\n            if node.right:\\n                dict1[node.val].append(node.right.val)\\n                dict1[node.right.val].append(node.val)\\n                dfs(node.right)\\n            \\n        dfs(root)\\n        \\n        visited, self.result = set(), 0\\n        \\n        def dfs(node, time):\\n            self.result = max(self.result, time)\\n            \\n            visited.add(node)\\n            \\n            for neighbor in dict1[node]:\\n                if neighbor not in visited:\\n                    dfs(neighbor, time + 1)\\n        \\n        dfs(start, 0)\\n        \\n        return self.result",
                "codeTag": "Python3"
            },
            {
                "id": 2480573,
                "title": "c-clean-solution-bfs-hashmap",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    unordered_map<int,int> childToParent;  \\n    unordered_map<int,int> leftChild;\\n    unordered_map<int,int> rightChild;\\n    unordered_map<int,int> vis;\\n    void cTP(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        cTP(root->left);\\n        if(root->left)\\n            childToParent[root->left->val]=root->val;\\n        if(root->right)\\n            childToParent[root->right->val]=root->val;\\n        cTP(root->right);\\n    }\\n    void pTC(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        pTC(root->left);\\n        if(root->left)\\n            leftChild[root->val]=root->left->val;\\n        if(root->right)\\n            rightChild[root->val]=root->right->val;\\n        pTC(root->right);\\n    }\\n    int bfs(int s)\\n    {\\n        int ans=0;\\n        queue<int> q;\\n        q.push(s);\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                int temp=q.front();\\n                q.pop();\\n                vis[temp]=1;\\n                if(childToParent[temp]!=-1 && !vis[childToParent[temp]])\\n                    q.push(childToParent[temp]);\\n                if(leftChild[temp] && !vis[leftChild[temp]])\\n                    q.push(leftChild[temp]);\\n                if(rightChild[temp] && !vis[rightChild[temp]])\\n                    q.push(rightChild[temp]);\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    int amountOfTime(TreeNode* root, int start) \\n    {\\n        childToParent[root->val]=-1;\\n        cTP(root);\\n        pTC(root);\\n        return bfs(start)-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    unordered_map<int,int> childToParent;  \\n    unordered_map<int,int> leftChild;\\n    unordered_map<int,int> rightChild;\\n    unordered_map<int,int> vis;\\n    void cTP(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        cTP(root->left);\\n        if(root->left)\\n            childToParent[root->left->val]=root->val;\\n        if(root->right)\\n            childToParent[root->right->val]=root->val;\\n        cTP(root->right);\\n    }\\n    void pTC(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        pTC(root->left);\\n        if(root->left)\\n            leftChild[root->val]=root->left->val;\\n        if(root->right)\\n            rightChild[root->val]=root->right->val;\\n        pTC(root->right);\\n    }\\n    int bfs(int s)\\n    {\\n        int ans=0;\\n        queue<int> q;\\n        q.push(s);\\n        while(!q.empty())\\n        {\\n            int n=q.size();\\n            for(int i=0;i<n;i++)\\n            {\\n                int temp=q.front();\\n                q.pop();\\n                vis[temp]=1;\\n                if(childToParent[temp]!=-1 && !vis[childToParent[temp]])\\n                    q.push(childToParent[temp]);\\n                if(leftChild[temp] && !vis[leftChild[temp]])\\n                    q.push(leftChild[temp]);\\n                if(rightChild[temp] && !vis[rightChild[temp]])\\n                    q.push(rightChild[temp]);\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    int amountOfTime(TreeNode* root, int start) \\n    {\\n        childToParent[root->val]=-1;\\n        cTP(root);\\n        pTC(root);\\n        return bfs(start)-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2476374,
                "title": "recursive-dfs-10-lines-java-38ms-beats-100",
                "content": "```java\\nint max;\\n\\npublic int amountOfTime(TreeNode root, int start) {\\n\\tmax = 0;\\n\\tgetDistance(root, start);\\n\\treturn max;\\n}\\n\\nint getHeight(TreeNode node) {return node == null ? 0 : 1 + Math.max(getHeight(node.left), getHeight(node.right));}\\n\\n// index 0 for height\\n// index 1 for distance to start\\nint[] getDistance(TreeNode node, int start) {\\n\\tif (node == null) return new int[2];\\n\\tif (node.val == start) return new int[]{1 + (max = Math.max(getHeight(node.left), getHeight(node.right))), 1};\\n\\tint height, distance[] = getDistance(node.left, start);\\n\\tif (distance[1] == 0) {\\n\\t\\theight = distance[0];\\n\\t\\tdistance = getDistance(node.right, start);\\n\\t} else height = getHeight(node.right);\\n\\tif (distance[1] > 0) max = Math.max(max, height + distance[1]++);\\n\\tdistance[0] = 1 + Math.max(distance[0], height);\\n\\treturn distance;\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nint max;\\n\\npublic int amountOfTime(TreeNode root, int start) {\\n\\tmax = 0;\\n\\tgetDistance(root, start);\\n\\treturn max;\\n}\\n\\nint getHeight(TreeNode node) {return node == null ? 0 : 1 + Math.max(getHeight(node.left), getHeight(node.right));}\\n\\n// index 0 for height\\n// index 1 for distance to start\\nint[] getDistance(TreeNode node, int start) {\\n\\tif (node == null) return new int[2];\\n\\tif (node.val == start) return new int[]{1 + (max = Math.max(getHeight(node.left), getHeight(node.right))), 1};\\n\\tint height, distance[] = getDistance(node.left, start);\\n\\tif (distance[1] == 0) {\\n\\t\\theight = distance[0];\\n\\t\\tdistance = getDistance(node.right, start);\\n\\t} else height = getHeight(node.right);\\n\\tif (distance[1] > 0) max = Math.max(max, height + distance[1]++);\\n\\tdistance[0] = 1 + Math.max(distance[0], height);\\n\\treturn distance;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2473142,
                "title": "javascript-dfs-one-pass-o-n-100-faster",
                "content": "```\\nvar amountOfTime = function(root, start) {\\n    let maxTime = 0;\\n    function dfs(root) {\\n        let left = 0, right = 0;\\n        if(root.val == start) {\\n            if(root.left !== null)\\n                left = dfs(root.left) + 1;\\n            if(root.right !== null)\\n                right = dfs(root.right) + 1;\\n            maxTime = Math.max(maxTime, left, right);\\n            return -1;\\n        }\\n        if(root.left !== null)\\n            left = dfs(root.left);\\n        if(root.right !== null)\\n            right = dfs(root.right);\\n        if(left < 0) {\\n            if(root.right !== null)\\n                right++;\\n            maxTime = Math.max(maxTime, right - left);\\n            return --left;\\n        }\\n        if(right < 0) {\\n            if(root.left !== null)\\n                left++;\\n            maxTime = Math.max(maxTime, left - right);\\n            return --right;\\n        }\\n        if(root.left !== null)\\n            left++;\\n        if(root.right !== null)\\n            right++;\\n        return Math.max(left, right);\\n    }\\n    dfs(root);\\n    return maxTime;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar amountOfTime = function(root, start) {\\n    let maxTime = 0;\\n    function dfs(root) {\\n        let left = 0, right = 0;\\n        if(root.val == start) {\\n            if(root.left !== null)\\n                left = dfs(root.left) + 1;\\n            if(root.right !== null)\\n                right = dfs(root.right) + 1;\\n            maxTime = Math.max(maxTime, left, right);\\n            return -1;\\n        }\\n        if(root.left !== null)\\n            left = dfs(root.left);\\n        if(root.right !== null)\\n            right = dfs(root.right);\\n        if(left < 0) {\\n            if(root.right !== null)\\n                right++;\\n            maxTime = Math.max(maxTime, right - left);\\n            return --left;\\n        }\\n        if(right < 0) {\\n            if(root.left !== null)\\n                left++;\\n            maxTime = Math.max(maxTime, left - right);\\n            return --right;\\n        }\\n        if(root.left !== null)\\n            left++;\\n        if(root.right !== null)\\n            right++;\\n        return Math.max(left, right);\\n    }\\n    dfs(root);\\n    return maxTime;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2472887,
                "title": "easy-bfs-code-inspired-by-striver-graph-series",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        vector<int> adj[100006];\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        \\n        while( !q.empty() ) {\\n            TreeNode* curr = q.front();\\n            q.pop();\\n            if(curr) {\\n                if(curr->left) {\\n                    q.push(curr->left);\\n                    adj[curr->val].push_back(curr->left->val);\\n                    adj[curr->left->val].push_back(curr->val);\\n                }\\n                if(curr->right) {\\n                    q.push(curr->right);\\n                    adj[curr->val].push_back(curr->right->val);\\n                    adj[curr->right->val].push_back(curr->val);\\n                }\\n            } \\n            else if(!q.empty()){\\n                q.push(NULL);\\n            }\\n        }\\n        \\n        int count = 0;\\n        queue<int> bfs;\\n        bfs.push(start);\\n        queue<int> qu;\\n        vector<int> vis(100006, 0);\\n        \\n        while( !bfs.empty() ) {\\n            count++;\\n            while(!bfs.empty()) {\\n                int curr = bfs.front();\\n                vis[curr] = 1;\\n                bfs.pop();\\n                for(auto it : adj[curr]) {\\n                    if(!vis[it]) {\\n                        qu.push(it);\\n                        vis[it] = 1;\\n                    }\\n                }\\n            }\\n            swap(qu, bfs);\\n        }\\n        \\n        return count-1;\\n        \\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        vector<int> adj[100006];\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        q.push(NULL);\\n        \\n        while( !q.empty() ) {\\n            TreeNode* curr = q.front();\\n            q.pop();\\n            if(curr) {\\n                if(curr->left) {\\n                    q.push(curr->left);\\n                    adj[curr->val].push_back(curr->left->val);\\n                    adj[curr->left->val].push_back(curr->val);\\n                }\\n                if(curr->right) {\\n                    q.push(curr->right);\\n                    adj[curr->val].push_back(curr->right->val);\\n                    adj[curr->right->val].push_back(curr->val);\\n                }\\n            } \\n            else if(!q.empty()){\\n                q.push(NULL);\\n            }\\n        }\\n        \\n        int count = 0;\\n        queue<int> bfs;\\n        bfs.push(start);\\n        queue<int> qu;\\n        vector<int> vis(100006, 0);\\n        \\n        while( !bfs.empty() ) {\\n            count++;\\n            while(!bfs.empty()) {\\n                int curr = bfs.front();\\n                vis[curr] = 1;\\n                bfs.pop();\\n                for(auto it : adj[curr]) {\\n                    if(!vis[it]) {\\n                        qu.push(it);\\n                        vis[it] = 1;\\n                    }\\n                }\\n            }\\n            swap(qu, bfs);\\n        }\\n        \\n        return count-1;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2471443,
                "title": "java-100-faster-by-bfs-self-explanatory-code",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        Map<Integer, TreeNode> parentMap = new HashMap<>();\\n        assignParent(root, null, parentMap);\\n        TreeNode startNode = findNode(root, start, parentMap);\\n        return findMinimumTimeByBfs(startNode, parentMap);\\n    }\\n    \\n    public void assignParent(TreeNode child, TreeNode parent, Map<Integer, TreeNode> parentMap) {\\n        if (child != null) {\\n            parentMap.put(child.val, parent);\\n            assignParent(child.left, child, parentMap);\\n            assignParent(child.right, child, parentMap);\\n        }\\n    }\\n    \\n    public TreeNode findNode(TreeNode root, int nodeToFind, Map<Integer, TreeNode> parentMap) {\\n        if (root.val == nodeToFind) return root;\\n        TreeNode parent = parentMap.get(nodeToFind);\\n        if (parent.left != null && parent.left.val == nodeToFind)\\n            return parent.left;\\n        return parent.right;\\n    }\\n    \\n    public int findMinimumTimeByBfs(TreeNode startNode, Map<Integer, TreeNode> parentMap) {\\n        Set<TreeNode> visitedNodes = new HashSet<>();\\n        Queue<TreeNode> bfsQueue = new ArrayDeque(parentMap.size());\\n        int minimumTime = 0;\\n        bfsQueue.add(startNode);\\n        while (!bfsQueue.isEmpty()) {\\n            int size = bfsQueue.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = bfsQueue.poll();\\n                visitedNodes.add(node);\\n                if (node.left != null && !visitedNodes.contains(node.left))\\n                    bfsQueue.add(node.left);\\n                if (node.right != null && !visitedNodes.contains(node.right))\\n                    bfsQueue.add(node.right);\\n                TreeNode parent = parentMap.get(node.val);\\n                if (parent != null && !visitedNodes.contains(parent))\\n                    bfsQueue.add(parent);\\n            }\\n            minimumTime++;\\n        }\\n        return minimumTime - 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        Map<Integer, TreeNode> parentMap = new HashMap<>();\\n        assignParent(root, null, parentMap);\\n        TreeNode startNode = findNode(root, start, parentMap);\\n        return findMinimumTimeByBfs(startNode, parentMap);\\n    }\\n    \\n    public void assignParent(TreeNode child, TreeNode parent, Map<Integer, TreeNode> parentMap) {\\n        if (child != null) {\\n            parentMap.put(child.val, parent);\\n            assignParent(child.left, child, parentMap);\\n            assignParent(child.right, child, parentMap);\\n        }\\n    }\\n    \\n    public TreeNode findNode(TreeNode root, int nodeToFind, Map<Integer, TreeNode> parentMap) {\\n        if (root.val == nodeToFind) return root;\\n        TreeNode parent = parentMap.get(nodeToFind);\\n        if (parent.left != null && parent.left.val == nodeToFind)\\n            return parent.left;\\n        return parent.right;\\n    }\\n    \\n    public int findMinimumTimeByBfs(TreeNode startNode, Map<Integer, TreeNode> parentMap) {\\n        Set<TreeNode> visitedNodes = new HashSet<>();\\n        Queue<TreeNode> bfsQueue = new ArrayDeque(parentMap.size());\\n        int minimumTime = 0;\\n        bfsQueue.add(startNode);\\n        while (!bfsQueue.isEmpty()) {\\n            int size = bfsQueue.size();\\n            for (int i = 0; i < size; i++) {\\n                TreeNode node = bfsQueue.poll();\\n                visitedNodes.add(node);\\n                if (node.left != null && !visitedNodes.contains(node.left))\\n                    bfsQueue.add(node.left);\\n                if (node.right != null && !visitedNodes.contains(node.right))\\n                    bfsQueue.add(node.right);\\n                TreeNode parent = parentMap.get(node.val);\\n                if (parent != null && !visitedNodes.contains(parent))\\n                    bfsQueue.add(parent);\\n            }\\n            minimumTime++;\\n        }\\n        return minimumTime - 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470986,
                "title": "java-dfs-recursive-solution-clean-and-easy-understanding",
                "content": "```\\nclass Solution {\\n    int time = 0, startDist = 0;\\n    public int amountOfTime(TreeNode root, int start) {\\n        helper(root, start);\\n        return time;\\n    }\\n    \\n    int helper(TreeNode root, int start) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int left = helper(root.left, start);\\n        int right = helper(root.right, start);\\n        \\n        //The longest path could be the child chain of start node\\n        if (root.val == start) {\\n            time = Math.max(time, Math.max(left, right));\\n            root.val = -root.val;\\n        }\\n        // Or the longest path (path = distance to start + longest path of another children chain) of any start node\\'s parent\\n        else if (root.left != null && root.left.val < 0) {\\n            startDist++;\\n            time = Math.max(time, right + startDist);\\n            root.val = -root.val;            \\n        } else if (root.right != null && root.right.val < 0) {\\n            startDist++;\\n            time = Math.max(time, left + startDist);\\n            root.val = -root.val;\\n        }\\n        return Math.max(left, right) + 1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int time = 0, startDist = 0;\\n    public int amountOfTime(TreeNode root, int start) {\\n        helper(root, start);\\n        return time;\\n    }\\n    \\n    int helper(TreeNode root, int start) {\\n        if (root == null) {\\n            return 0;\\n        }\\n        int left = helper(root.left, start);\\n        int right = helper(root.right, start);\\n        \\n        //The longest path could be the child chain of start node\\n        if (root.val == start) {\\n            time = Math.max(time, Math.max(left, right));\\n            root.val = -root.val;\\n        }\\n        // Or the longest path (path = distance to start + longest path of another children chain) of any start node\\'s parent\\n        else if (root.left != null && root.left.val < 0) {\\n            startDist++;\\n            time = Math.max(time, right + startDist);\\n            root.val = -root.val;            \\n        } else if (root.right != null && root.right.val < 0) {\\n            startDist++;\\n            time = Math.max(time, left + startDist);\\n            root.val = -root.val;\\n        }\\n        return Math.max(left, right) + 1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2470520,
                "title": "simple-c-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate: void adjList(TreeNode* root,vector<vector<int>> &list)\\n{\\n  if(root->left)\\n       {\\n       list[root->val].push_back(root->left->val);\\n       list[root->left->val].push_back(root->val);\\n       adjList(root->left,list);\\n       }\\n       if(root->right)\\n       {\\n       list[root->val].push_back(root->right->val);\\n       list[root->right->val].push_back(root->val);\\n        adjList(root->right,list);\\n       }  \\n}\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n       vector<vector<int>> list(100001,vector<int>());\\n        vector<bool> vis(100001,false);\\n        adjList(root,list);\\n       queue<int> q;\\n        int res =0;\\n        q.push(start);\\n        vis[start] = true;\\n        while(!q.empty())\\n        {\\n            res++;\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                int val  = q.front();\\n                q.pop();\\n                for(auto j : list[val])\\n                {\\n                    if(!vis[j])\\n                    {\\n                        q.push(j);\\n                        vis[j] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return res-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\nprivate: void adjList(TreeNode* root,vector<vector<int>> &list)\\n{\\n  if(root->left)\\n       {\\n       list[root->val].push_back(root->left->val);\\n       list[root->left->val].push_back(root->val);\\n       adjList(root->left,list);\\n       }\\n       if(root->right)\\n       {\\n       list[root->val].push_back(root->right->val);\\n       list[root->right->val].push_back(root->val);\\n        adjList(root->right,list);\\n       }  \\n}\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n       vector<vector<int>> list(100001,vector<int>());\\n        vector<bool> vis(100001,false);\\n        adjList(root,list);\\n       queue<int> q;\\n        int res =0;\\n        q.push(start);\\n        vis[start] = true;\\n        while(!q.empty())\\n        {\\n            res++;\\n            int sz = q.size();\\n            for(int i=0;i<sz;i++)\\n            {\\n                int val  = q.front();\\n                q.pop();\\n                for(auto j : list[val])\\n                {\\n                    if(!vis[j])\\n                    {\\n                        q.push(j);\\n                        vis[j] = true;\\n                    }\\n                }\\n            }\\n        }\\n        return res-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465860,
                "title": "rust-solution",
                "content": "```\\nuse std::cell::RefCell;\\nuse std::collections::{HashMap, HashSet};\\nuse std::rc::Rc;\\n\\nimpl Solution {\\n    pub fn amount_of_time(root: Option<Rc<RefCell<TreeNode>>>, start: i32) -> i32 {\\n        let graph = Solution::collect_graph(root);\\n\\n        let mut max_lev = 0;\\n        let mut stack = vec![(start, 0)];\\n        let mut visited = HashSet::new();\\n        visited.insert(start);\\n\\n        while let Some((node, lev)) = stack.pop() {\\n            if let Some(nodes) = graph.get(&node) {\\n                for &next_node in nodes.iter().filter(|&&n| n > -1) {\\n                    if visited.insert(next_node) {\\n                        stack.push((next_node, lev + 1));\\n                        max_lev = max_lev.max(lev + 1);\\n                    }\\n                }\\n            }\\n        }\\n        max_lev\\n    }\\n\\n    pub fn collect_graph(root: Option<Rc<RefCell<TreeNode>>>) -> HashMap<i32, Vec<i32>> {\\n        let mut map: HashMap<i32, Vec<i32>> = HashMap::new();\\n        let mut stack = vec![(root, -1)];\\n\\n        while let Some((node, prev_val)) = stack.pop() {\\n            if let Some(node) = node {\\n                let node = node.borrow();\\n                let val = node.val;\\n\\n                map.entry(val)\\n                    .and_modify(|v| v.push(prev_val))\\n                    .or_insert_with(|| vec![prev_val]);\\n\\n                map.entry(prev_val)\\n                    .and_modify(|v| v.push(val))\\n                    .or_insert_with(|| vec![val]);\\n\\n                stack.push((node.left.clone(), val));\\n                stack.push((node.right.clone(), val));\\n            }\\n        }\\n        map\\n    }\\n}\\n```",
                "solutionTags": [
                    "Rust",
                    "Stack",
                    "Depth-First Search"
                ],
                "code": "```\\nuse std::cell::RefCell;\\nuse std::collections::{HashMap, HashSet};\\nuse std::rc::Rc;\\n\\nimpl Solution {\\n    pub fn amount_of_time(root: Option<Rc<RefCell<TreeNode>>>, start: i32) -> i32 {\\n        let graph = Solution::collect_graph(root);\\n\\n        let mut max_lev = 0;\\n        let mut stack = vec![(start, 0)];\\n        let mut visited = HashSet::new();\\n        visited.insert(start);\\n\\n        while let Some((node, lev)) = stack.pop() {\\n            if let Some(nodes) = graph.get(&node) {\\n                for &next_node in nodes.iter().filter(|&&n| n > -1) {\\n                    if visited.insert(next_node) {\\n                        stack.push((next_node, lev + 1));\\n                        max_lev = max_lev.max(lev + 1);\\n                    }\\n                }\\n            }\\n        }\\n        max_lev\\n    }\\n\\n    pub fn collect_graph(root: Option<Rc<RefCell<TreeNode>>>) -> HashMap<i32, Vec<i32>> {\\n        let mut map: HashMap<i32, Vec<i32>> = HashMap::new();\\n        let mut stack = vec![(root, -1)];\\n\\n        while let Some((node, prev_val)) = stack.pop() {\\n            if let Some(node) = node {\\n                let node = node.borrow();\\n                let val = node.val;\\n\\n                map.entry(val)\\n                    .and_modify(|v| v.push(prev_val))\\n                    .or_insert_with(|| vec![prev_val]);\\n\\n                map.entry(prev_val)\\n                    .and_modify(|v| v.push(val))\\n                    .or_insert_with(|| vec![val]);\\n\\n                stack.push((node.left.clone(), val));\\n                stack.push((node.right.clone(), val));\\n            }\\n        }\\n        map\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2464063,
                "title": "c-simple-bfs",
                "content": "```\\nclass Solution {\\nprivate:\\n    void traverse(TreeNode* root, vector<int> graph[]){\\n        if(root==NULL) return;\\n        if(root->left){\\n            graph[root->val].push_back(root->left->val);\\n            graph[root->left->val].push_back(root->val);\\n        }\\n        if(root->right){\\n            graph[root->val].push_back(root->right->val);\\n            graph[root->right->val].push_back(root->val);\\n        }\\n        traverse(root->left, graph);\\n        traverse(root->right, graph);\\n    }\\n    \\n    void bfs(int v, vector<int> graph[], int& ans){\\n        queue<pair<int, int>> q;\\n\\t\\t//Second part of queue is time to infect current element\\n        q.push({v, ans});\\n        bool* visited = new bool[100001];\\n        for(int i=0;i<100001;i++) visited[i]=0;\\n        visited[v]=1;\\n        while(!q.empty()){\\n            auto tmp=q.front();\\n            q.pop();\\n            bool flag=0;\\n            for(int x:graph[tmp.first]){\\n                if(!visited[x]){\\n                    q.push({x, tmp.second+1});\\n                    visited[x]=1;\\n                    flag=1;\\n                }\\n            }\\n            if(flag) ans=max(ans, tmp.second+1);\\n        }\\n    }\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        vector<int> graph[100001];\\n\\t\\t// traversing the tree for graph\\n        traverse(root, graph);\\n        int ans=0;\\n        bfs(start, graph, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void traverse(TreeNode* root, vector<int> graph[]){\\n        if(root==NULL) return;\\n        if(root->left){\\n            graph[root->val].push_back(root->left->val);\\n            graph[root->left->val].push_back(root->val);\\n        }\\n        if(root->right){\\n            graph[root->val].push_back(root->right->val);\\n            graph[root->right->val].push_back(root->val);\\n        }\\n        traverse(root->left, graph);\\n        traverse(root->right, graph);\\n    }\\n    \\n    void bfs(int v, vector<int> graph[], int& ans){\\n        queue<pair<int, int>> q;\\n\\t\\t//Second part of queue is time to infect current element\\n        q.push({v, ans});\\n        bool* visited = new bool[100001];\\n        for(int i=0;i<100001;i++) visited[i]=0;\\n        visited[v]=1;\\n        while(!q.empty()){\\n            auto tmp=q.front();\\n            q.pop();\\n            bool flag=0;\\n            for(int x:graph[tmp.first]){\\n                if(!visited[x]){\\n                    q.push({x, tmp.second+1});\\n                    visited[x]=1;\\n                    flag=1;\\n                }\\n            }\\n            if(flag) ans=max(ans, tmp.second+1);\\n        }\\n    }\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        vector<int> graph[100001];\\n\\t\\t// traversing the tree for graph\\n        traverse(root, graph);\\n        int ans=0;\\n        bfs(start, graph, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2462714,
                "title": "c-bfs-graph-explained",
                "content": "**Approach:**\\n\\n* store the tree in a graph so that we can access the adjacent nodes of a particular node easily\\n* now, simply perform the bfs of the tree starting from start\\n\\t* for a particular node, run a loop through all its adjacent and if they are not visited then add them in the queue and increase the time by 1 after covering all the adjacent of all the nodes at a particular level \\n\\n**Code:**\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    unordered_map<int, vector<int>> graph;\\n    void buildGraph(TreeNode *root)\\n    {\\n        queue<pair<TreeNode *, int>> q;\\n        q.push({root, -1});\\n        while (!q.empty())\\n        {\\n            auto [node, parent] = q.front();\\n            q.pop();\\n            if (parent != -1)\\n            {\\n                graph[parent].push_back(node->val);\\n                graph[node->val].push_back(parent);\\n            }\\n            if (node->left != NULL)\\n                q.push({node->left, node->val});\\n            if (node->right != NULL)\\n                q.push({node->right, node->val});\\n        }\\n    }\\n    int amountOfTime(TreeNode *root, int start)\\n    {\\n        buildGraph(root);\\n        queue<int> q;\\n        q.push(start);\\n        int t = 0;\\n        unordered_map<int, bool> vis;\\n        vis[start] = true;\\n        while (!q.empty())\\n        {\\n            int n = q.size();\\n            while (n--)\\n            {\\n                int u = q.front();\\n                q.pop();\\n                for (auto v : graph[u])\\n                {\\n                    if (vis[v] == false)\\n                    {\\n                        q.push(v);\\n                        vis[v] = true;\\n                    }\\n                }\\n            }\\n            t++;\\n        }\\n        return t - 1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\npublic:\\n    unordered_map<int, vector<int>> graph;\\n    void buildGraph(TreeNode *root)\\n    {\\n        queue<pair<TreeNode *, int>> q;\\n        q.push({root, -1});\\n        while (!q.empty())\\n        {\\n            auto [node, parent] = q.front();\\n            q.pop();\\n            if (parent != -1)\\n            {\\n                graph[parent].push_back(node->val);\\n                graph[node->val].push_back(parent);\\n            }\\n            if (node->left != NULL)\\n                q.push({node->left, node->val});\\n            if (node->right != NULL)\\n                q.push({node->right, node->val});\\n        }\\n    }\\n    int amountOfTime(TreeNode *root, int start)\\n    {\\n        buildGraph(root);\\n        queue<int> q;\\n        q.push(start);\\n        int t = 0;\\n        unordered_map<int, bool> vis;\\n        vis[start] = true;\\n        while (!q.empty())\\n        {\\n            int n = q.size();\\n            while (n--)\\n            {\\n                int u = q.front();\\n                q.pop();\\n                for (auto v : graph[u])\\n                {\\n                    if (vis[v] == false)\\n                    {\\n                        q.push(v);\\n                        vis[v] = true;\\n                    }\\n                }\\n            }\\n            t++;\\n        }\\n        return t - 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461839,
                "title": "bfs-after-creating-a-graph-c",
                "content": "****Please upvote if you like my solution****\\n```\\n void CreateGraph(TreeNode* root,unordered_map<int,vector<int>>&graph){\\n       if(root==NULL)\\n           return;\\n       if(root->left!=NULL){\\n           graph[root->val].push_back(root->left->val);\\n           graph[root->left->val].push_back(root->val);\\n           \\n       }\\n       if(root->right!=NULL){\\n           graph[root->val].push_back(root->right->val);\\n           graph[root->right->val].push_back(root->val);\\n       }\\n       CreateGraph(root->left,graph);\\n       CreateGraph(root->right,graph);\\n       \\n   }\\n    int amountOfTime(TreeNode* root, int start) {\\n     unordered_map<int,vector<int>>graph;\\n        CreateGraph(root,graph);\\n        int count=0;\\n        set<int>vis;\\n        queue<int>q;\\n        q.push(start);\\n        while(!q.empty()){\\n            int size=q.size();\\n            count++;\\n            while(size--){\\n                int src=q.front();\\n                q.pop();\\n                vis.insert(src);\\n                for(auto u:graph[src]){\\n                    if(vis.find(u)==vis.end())\\n                        q.push(u);\\n                }\\n            }\\n        }\\n        return count-1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n void CreateGraph(TreeNode* root,unordered_map<int,vector<int>>&graph){\\n       if(root==NULL)\\n           return;\\n       if(root->left!=NULL){\\n           graph[root->val].push_back(root->left->val);\\n           graph[root->left->val].push_back(root->val);\\n           \\n       }\\n       if(root->right!=NULL){\\n           graph[root->val].push_back(root->right->val);\\n           graph[root->right->val].push_back(root->val);\\n       }\\n       CreateGraph(root->left,graph);\\n       CreateGraph(root->right,graph);\\n       \\n   }\\n    int amountOfTime(TreeNode* root, int start) {\\n     unordered_map<int,vector<int>>graph;\\n        CreateGraph(root,graph);\\n        int count=0;\\n        set<int>vis;\\n        queue<int>q;\\n        q.push(start);\\n        while(!q.empty()){\\n            int size=q.size();\\n            count++;\\n            while(size--){\\n                int src=q.front();\\n                q.pop();\\n                vis.insert(src);\\n                for(auto u:graph[src]){\\n                    if(vis.find(u)==vis.end())\\n                        q.push(u);\\n                }\\n            }\\n        }\\n        return count-1;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2461045,
                "title": "python-no-graph-dfs-intuitive-solution-with-detail-comments",
                "content": "This question is very similar to [863. All Nodes Distance K in Binary Tree](https://leetcode.com/problems/all-nodes-distance-k-in-binary-tree/)\\nin a sense that we could add a \"parent\" variable to each tree node and use it to find the distance to the furthest node from the start node.\\n\\nThree steps: \\n1. Assign parent node to each node in the tree\\n2. Identify the start node\\n3. calculate the distance from start node to the furthest node\\n\\nTime O(n); Space O(n)\\n```\\nclass Solution:\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n\\t\\tself.startNode = None\\n\\t\\t\\n        def addParent(root, parent) -> None: \\n            if not node:\\n                return\\n            root.parent = parent\\n\\t\\t\\tif node.val == start: # if we run into start node we mark it\\n                self.startNode = node\\n            addParent(root.left, node)\\n            addParent(root.right, node)\\n\\n        def getDist(root, visited) -> int:\\n\\t\\t\\t# if reaching the end of the tree, or running into node previously visited, we return 0\\n            if not root or root.val in visited: \\n\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\n\\t\\t\\t # add the value into set\\n\\t\\t\\tvisited.add(root.val)\\n\\t\\t\\t# recursively visit left, right, and parent nodes, and return the max\\n            return 1 + max(getDist(root.left, visited), getDist(root.right, visited), getDist(root.parent, visited)) \\n       \\n        addParent(root, None) #assign parent node for each node in the tree\\n        dis = getDist(self.startNode, set()) #count the distance to the furthest node\\n\\n        return dis - 1\\n```\\n",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution:\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n\\t\\tself.startNode = None\\n\\t\\t\\n        def addParent(root, parent) -> None: \\n            if not node:\\n                return\\n            root.parent = parent\\n\\t\\t\\tif node.val == start: # if we run into start node we mark it\\n                self.startNode = node\\n            addParent(root.left, node)\\n            addParent(root.right, node)\\n\\n        def getDist(root, visited) -> int:\\n\\t\\t\\t# if reaching the end of the tree, or running into node previously visited, we return 0\\n            if not root or root.val in visited: \\n\\t\\t\\t\\treturn 0\\n\\t\\t\\t\\n\\t\\t\\t # add the value into set\\n\\t\\t\\tvisited.add(root.val)\\n\\t\\t\\t# recursively visit left, right, and parent nodes, and return the max\\n            return 1 + max(getDist(root.left, visited), getDist(root.right, visited), getDist(root.parent, visited)) \\n       \\n        addParent(root, None) #assign parent node for each node in the tree\\n        dis = getDist(self.startNode, set()) #count the distance to the furthest node\\n\\n        return dis - 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2461033,
                "title": "level-order-traversal-after-creating-adjacency-list",
                "content": "```\\n\\tmap<int, vector<int>> mp;\\n    int total = 0;\\n    \\n    void dfs(TreeNode* root){\\n        \\n        if(!root) return;\\n        total++;\\n\\t\\t\\n        if(root->left) {\\n            mp[root->val].push_back(root->left->val);\\n            mp[root->left->val].push_back(root->val);\\n        }\\n        if(root->right){\\n            mp[root->val].push_back(root->right->val);\\n            mp[root->right->val].push_back(root->val);\\n        }\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    \\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n\\n        if(!root->left and !root->right) return 0;\\n        \\n        dfs(root);\\n        \\n        unordered_set<int> visited;\\n        \\n        queue<int> q;\\n        \\n        q.push(start);\\n        visited.insert(start);\\n        \\n        int ans = 0;\\n        \\n        while(!q.empty()){\\n            \\n            int n = q.size();\\n            ans++;\\n            for(int i = 0; i < n; i++){\\n                \\n                int x = q.front();\\n                q.pop();\\n                \\n                for(int j = 0; j < mp[x].size(); j++){\\n                    \\n                    if(visited.find(mp[x][j]) == visited.end()){\\n                        visited.insert(mp[x][j]);\\n                        q.push(mp[x][j]);   \\n                    }   \\n                }\\n            }\\n            if(visited.size() == total) break;\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n\\tmap<int, vector<int>> mp;\\n    int total = 0;\\n    \\n    void dfs(TreeNode* root){\\n        \\n        if(!root) return;\\n        total++;\\n\\t\\t\\n        if(root->left) {\\n            mp[root->val].push_back(root->left->val);\\n            mp[root->left->val].push_back(root->val);\\n        }\\n        if(root->right){\\n            mp[root->val].push_back(root->right->val);\\n            mp[root->right->val].push_back(root->val);\\n        }\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    \\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n\\n        if(!root->left and !root->right) return 0;\\n        \\n        dfs(root);\\n        \\n        unordered_set<int> visited;\\n        \\n        queue<int> q;\\n        \\n        q.push(start);\\n        visited.insert(start);\\n        \\n        int ans = 0;\\n        \\n        while(!q.empty()){\\n            \\n            int n = q.size();\\n            ans++;\\n            for(int i = 0; i < n; i++){\\n                \\n                int x = q.front();\\n                q.pop();\\n                \\n                for(int j = 0; j < mp[x].size(); j++){\\n                    \\n                    if(visited.find(mp[x][j]) == visited.end()){\\n                        visited.insert(mp[x][j]);\\n                        q.push(mp[x][j]);   \\n                    }   \\n                }\\n            }\\n            if(visited.size() == total) break;\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2460897,
                "title": "sharing-my-self-documenting-c-code",
                "content": "```\\nclass Solution {\\npublic:\\n    struct InfectionData {\\n        int height;\\n        int dist_to_start;\\n        int max_dist_to_start;\\n    };\\n    \\n    InfectionData InfectionHelper(TreeNode* root, int start) {\\n        if (root == nullptr) {\\n            return InfectionData{0, -1, -1};\\n        }\\n        InfectionData left_data = InfectionHelper(root->left, start);\\n        InfectionData right_data = InfectionHelper(root->right, start);\\n        int height = 1 + max(left_data.height, right_data.height);\\n        int dist_to_start = -1;\\n        int max_dist_to_start = -1;\\n        if (root->val == start) {\\n            dist_to_start = 0;\\n            max_dist_to_start = height - 1;\\n        }\\n        else if (left_data.dist_to_start != -1) {\\n            dist_to_start = left_data.dist_to_start + 1;\\n            max_dist_to_start = max({left_data.max_dist_to_start, dist_to_start + right_data.height});\\n        } else if (right_data.dist_to_start != -1) {\\n            dist_to_start = right_data.dist_to_start + 1;\\n            max_dist_to_start = max({right_data.max_dist_to_start, dist_to_start + left_data.height});\\n        }\\n        return InfectionData{height, dist_to_start, max_dist_to_start};\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n        return InfectionHelper(root, start).max_dist_to_start;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    struct InfectionData {\\n        int height;\\n        int dist_to_start;\\n        int max_dist_to_start;\\n    };\\n    \\n    InfectionData InfectionHelper(TreeNode* root, int start) {\\n        if (root == nullptr) {\\n            return InfectionData{0, -1, -1};\\n        }\\n        InfectionData left_data = InfectionHelper(root->left, start);\\n        InfectionData right_data = InfectionHelper(root->right, start);\\n        int height = 1 + max(left_data.height, right_data.height);\\n        int dist_to_start = -1;\\n        int max_dist_to_start = -1;\\n        if (root->val == start) {\\n            dist_to_start = 0;\\n            max_dist_to_start = height - 1;\\n        }\\n        else if (left_data.dist_to_start != -1) {\\n            dist_to_start = left_data.dist_to_start + 1;\\n            max_dist_to_start = max({left_data.max_dist_to_start, dist_to_start + right_data.height});\\n        } else if (right_data.dist_to_start != -1) {\\n            dist_to_start = right_data.dist_to_start + 1;\\n            max_dist_to_start = max({right_data.max_dist_to_start, dist_to_start + left_data.height});\\n        }\\n        return InfectionData{height, dist_to_start, max_dist_to_start};\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n        return InfectionHelper(root, start).max_dist_to_start;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460585,
                "title": "c-undirected-graph-bfs",
                "content": "```\\nclass Solution {\\npublic:\\n    // Create undirected graph\\n    void createGraph (TreeNode* root) {\\n        queue<TreeNode*> que;\\n        \\n        if (!root) return;\\n        \\n        que.push(root);\\n        \\n        while (!que.empty()) {\\n            int size = que.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                TreeNode* cur = que.front();\\n                que.pop();\\n                \\n                if (cur->left) {\\n                    que.push(cur->left);\\n                    \\n                    adj[cur->val].push_back(cur->left->val);\\n                    adj[cur->left->val].push_back(cur->val);\\n                }\\n                \\n                if (cur->right) {\\n                    que.push(cur->right);\\n                    \\n                    adj[cur->val].push_back(cur->right->val);\\n                    adj[cur->right->val].push_back(cur->val);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n        createGraph (root);\\n        \\n        queue<int> que;\\n        que.push(start);\\n        visited[start] = true;\\n        int count = 0;\\n        \\n        // bfs\\n        while (!que.empty()) {\\n            int size = que.size();\\n            ++count;\\n            \\n            for (int i = 0; i < size; i++) {\\n                int cur =  que.front();\\n                que.pop();\\n                \\n                for (auto node : adj[cur]) {\\n                    if (!visited[node]) { // hasn\\'t been visited before\\n                        visited[node] = true;\\n                        que.push(node);\\n                    }                  \\n                }\\n            }\\n        }\\n        \\n        return count - 1;\\n    }\\n    \\nprivate:\\n    unordered_map<int, vector<int>> adj; // <node, <adj nodes>>\\n    unordered_map<int, bool> visited; // <node, whether visited>\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    // Create undirected graph\\n    void createGraph (TreeNode* root) {\\n        queue<TreeNode*> que;\\n        \\n        if (!root) return;\\n        \\n        que.push(root);\\n        \\n        while (!que.empty()) {\\n            int size = que.size();\\n            \\n            for (int i = 0; i < size; i++) {\\n                TreeNode* cur = que.front();\\n                que.pop();\\n                \\n                if (cur->left) {\\n                    que.push(cur->left);\\n                    \\n                    adj[cur->val].push_back(cur->left->val);\\n                    adj[cur->left->val].push_back(cur->val);\\n                }\\n                \\n                if (cur->right) {\\n                    que.push(cur->right);\\n                    \\n                    adj[cur->val].push_back(cur->right->val);\\n                    adj[cur->right->val].push_back(cur->val);\\n                }\\n            }\\n        }\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n        createGraph (root);\\n        \\n        queue<int> que;\\n        que.push(start);\\n        visited[start] = true;\\n        int count = 0;\\n        \\n        // bfs\\n        while (!que.empty()) {\\n            int size = que.size();\\n            ++count;\\n            \\n            for (int i = 0; i < size; i++) {\\n                int cur =  que.front();\\n                que.pop();\\n                \\n                for (auto node : adj[cur]) {\\n                    if (!visited[node]) { // hasn\\'t been visited before\\n                        visited[node] = true;\\n                        que.push(node);\\n                    }                  \\n                }\\n            }\\n        }\\n        \\n        return count - 1;\\n    }\\n    \\nprivate:\\n    unordered_map<int, vector<int>> adj; // <node, <adj nodes>>\\n    unordered_map<int, bool> visited; // <node, whether visited>\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2460456,
                "title": "simple-dfs-height-o-n-time-top-90-o-1-space-top-100-detailed-explanation",
                "content": "Basically we have to find the **max distance from the infected node to the leaf node.**\\n\\nThe intuition is that if the infected node is on the left subtree and distance between current node and the infected node on the left is **```k```**, then the max distance will be **```k + right_subtree_height```**. Same goes for the right side.\\n\\nThere will be four cases for the current node:\\n\\n1.  **If the infected node is on the left side of current node and distance between them is k, then ```max_distance = k + right_subtree_height```**\\n\\n1.  **If the infected node is on the right side of current node and distance is k, then ```max_distance = k + left_subtree_height```**\\n\\n1. **If the current node is itself the infected node then ```max_distance = height(current_node)```**\\n\\n1.   If current node is none of the above do nothing.\\n\\nFinally we find max_distance for each node and update our ans.\\n\\n![image](https://assets.leetcode.com/users/images/e6e387ae-c951-4ee2-8341-fe3371d8f542_1661107646.7277312.jpeg)\\n\\n\\n\\n**C++ code:**\\n\\n```\\nclass Solution {\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        int ans = 0;\\n        int temp = solve(root, start, ans);\\n        return ans;\\n    }\\n    \\n    int solve(TreeNode* root, int start, int &ans) {  // returns the distance of infected node from the current node, returns -1 if infected node is not found\\n        if(root == NULL) return -1;\\n        \\n        if(root->val == start) {                    // case 3: if current node is infected node, find height\\n            ans = max(ans, height(root)-1);         // updates the ans\\n            return 1;\\n        }\\n        \\n        int k_left = solve(root->left, start, ans);\\n        if(k_left != -1) {                          // case 1: if infected node is on the left\\n            ans = max(ans, height(root->right) + k_left);   // updates the ans\\n            return k_left+1;\\n        }\\n        \\n        int k_right = solve(root->right, start, ans);\\n        if(k_right != -1) {                         // case 2: if infected node is on the right\\n            ans = max(ans, height(root->left) + k_right);   // updates the ans\\n            return k_right + 1;\\n        }\\n        \\n        return -1;                                  // case 4: do nothing\\n        \\n    }\\n    \\n    int height(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        return max(height(root->left), height(root->right)) + 1;\\n    }\\n};\\n```\\n\\n**Do upvote if this helped ;)**",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```k```\n```k + right_subtree_height```\n```max_distance = k + right_subtree_height```\n```max_distance = k + left_subtree_height```\n```max_distance = height(current_node)```\n```\\nclass Solution {\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        int ans = 0;\\n        int temp = solve(root, start, ans);\\n        return ans;\\n    }\\n    \\n    int solve(TreeNode* root, int start, int &ans) {  // returns the distance of infected node from the current node, returns -1 if infected node is not found\\n        if(root == NULL) return -1;\\n        \\n        if(root->val == start) {                    // case 3: if current node is infected node, find height\\n            ans = max(ans, height(root)-1);         // updates the ans\\n            return 1;\\n        }\\n        \\n        int k_left = solve(root->left, start, ans);\\n        if(k_left != -1) {                          // case 1: if infected node is on the left\\n            ans = max(ans, height(root->right) + k_left);   // updates the ans\\n            return k_left+1;\\n        }\\n        \\n        int k_right = solve(root->right, start, ans);\\n        if(k_right != -1) {                         // case 2: if infected node is on the right\\n            ans = max(ans, height(root->left) + k_right);   // updates the ans\\n            return k_right + 1;\\n        }\\n        \\n        return -1;                                  // case 4: do nothing\\n        \\n    }\\n    \\n    int height(TreeNode* root) {\\n        if(root == NULL) return 0;\\n        return max(height(root->left), height(root->right)) + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2459760,
                "title": "bfs-c-find-parent-include-parent-too-in-bfs-3-adjacent-nodes-and-count-the-time",
                "content": "Find Parent and assign the corresponding values in the map, here in code done using DFS.\\nNow we have 3 adjacent nodes corresponding to a node where the infection can spread, parent, left and right.\\nAlso we need to keep a count of visited nodes to avoid repetition.\\nWhile doing BFS, I have used a pair to count the time and keep the node.\\n\\n```\\n    void findParents(map<TreeNode*,TreeNode*> &parent,TreeNode* root,int start,TreeNode* &startNode){\\n        if(!root) return;\\n        if(root->left)\\n            parent[root->left] = root;\\n        if(root->right)\\n            parent[root->right] = root;\\n        if(startNode==NULL and root->val==start)\\n            startNode=root;\\n        findParents(parent,root->left,start,startNode);\\n        findParents(parent,root->right,start,startNode);\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n        map<TreeNode*,bool> visited;\\n        map<TreeNode*,TreeNode*> parent;\\n        TreeNode* head = root;\\n        TreeNode* startNode;\\n        findParents(parent,root,start,startNode);\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({startNode,0});\\n        int maxi = 0;\\n        while(q.size()){\\n            auto front = q.front();\\n            TreeNode* curr = front.first;\\n            int seconds = front.second;\\n            maxi = max(seconds,maxi);\\n            q.pop();\\n            visited[front.first]=true;\\n            if(parent[curr] and !visited[parent[curr]])\\n                q.push({parent[curr],seconds+1});\\n            if(curr->left and !visited[curr->left])\\n                 q.push({curr->left,seconds+1});\\n            if(curr->right and !visited[curr->right])\\n                 q.push({curr->right,seconds+1});\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\n    void findParents(map<TreeNode*,TreeNode*> &parent,TreeNode* root,int start,TreeNode* &startNode){\\n        if(!root) return;\\n        if(root->left)\\n            parent[root->left] = root;\\n        if(root->right)\\n            parent[root->right] = root;\\n        if(startNode==NULL and root->val==start)\\n            startNode=root;\\n        findParents(parent,root->left,start,startNode);\\n        findParents(parent,root->right,start,startNode);\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n        map<TreeNode*,bool> visited;\\n        map<TreeNode*,TreeNode*> parent;\\n        TreeNode* head = root;\\n        TreeNode* startNode;\\n        findParents(parent,root,start,startNode);\\n        queue<pair<TreeNode*,int>> q;\\n        q.push({startNode,0});\\n        int maxi = 0;\\n        while(q.size()){\\n            auto front = q.front();\\n            TreeNode* curr = front.first;\\n            int seconds = front.second;\\n            maxi = max(seconds,maxi);\\n            q.pop();\\n            visited[front.first]=true;\\n            if(parent[curr] and !visited[parent[curr]])\\n                q.push({parent[curr],seconds+1});\\n            if(curr->left and !visited[curr->left])\\n                 q.push({curr->left,seconds+1});\\n            if(curr->right and !visited[curr->right])\\n                 q.push({curr->right,seconds+1});\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2459065,
                "title": "java-solution-using-bfs-graph",
                "content": "\\n    public int amountOfTime(TreeNode root, int start){\\n        HashMap<Integer, HashSet<Integer>> map = new HashMap<>();  // to store adjacent nodes of each node\\n        inorder(root, -1, map);  //convert tree to graph\\n        Queue<Integer> queue = new LinkedList<>(); \\n        queue.add(start);\\n        int result = 0;\\n        HashSet<Integer> visited = new HashSet<>();\\n        visited.add(start);\\n        \\n        // bfs to find the ans\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                int current = queue.poll();\\n                for(int num : map.get(current)){\\n                    if(!visited.contains(num)){\\n                        visited.add(num);\\n                        queue.add(num);\\n                    }\\n                }\\n            }\\n            result += 1;\\n        }\\n        return result - 1;  // -1 because time taken by the first node to infect neighbours is 0\\n    }\\n     \\n     public void inorder(TreeNode root, int prev, HashMap<Integer, HashSet<Integer>> map){\\n         if(root == null) return;\\n         if(!map.containsKey(root.val)) map.put(root.val, new HashSet<>());\\n         if(prev != -1){\\n             map.get(root.val).add(prev);\\n         }\\n         if(root.left != null) map.get(root.val).add(root.left.val);\\n         if(root.right != null) map.get(root.val).add(root.right.val);\\n         inorder(root.left, root.val, map);\\n         inorder(root.right, root.val, map);\\n     }",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "\\n    public int amountOfTime(TreeNode root, int start){\\n        HashMap<Integer, HashSet<Integer>> map = new HashMap<>();  // to store adjacent nodes of each node\\n        inorder(root, -1, map);  //convert tree to graph\\n        Queue<Integer> queue = new LinkedList<>(); \\n        queue.add(start);\\n        int result = 0;\\n        HashSet<Integer> visited = new HashSet<>();\\n        visited.add(start);\\n        \\n        // bfs to find the ans\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i = 0; i < size; i++){\\n                int current = queue.poll();\\n                for(int num : map.get(current)){\\n                    if(!visited.contains(num)){\\n                        visited.add(num);\\n                        queue.add(num);\\n                    }\\n                }\\n            }\\n            result += 1;\\n        }\\n        return result - 1;  // -1 because time taken by the first node to infect neighbours is 0\\n    }\\n     \\n     public void inorder(TreeNode root, int prev, HashMap<Integer, HashSet<Integer>> map){\\n         if(root == null) return;\\n         if(!map.containsKey(root.val)) map.put(root.val, new HashSet<>());\\n         if(prev != -1){\\n             map.get(root.val).add(prev);\\n         }\\n         if(root.left != null) map.get(root.val).add(root.left.val);\\n         if(root.right != null) map.get(root.val).add(root.right.val);\\n         inorder(root.left, root.val, map);\\n         inorder(root.right, root.val, map);\\n     }",
                "codeTag": "Unknown"
            },
            {
                "id": 2459060,
                "title": "tree-to-graph-building-bfs-java",
                "content": "```\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\\n        buildGraph(root, graph);\\n        int ans = getTimeToInfact(graph, start);\\n        return ans;\\n    }\\n    static int getTimeToInfact(HashMap<Integer, List<Integer>> graph, int start) {\\n        int ans = -1;\\n        Set<Integer> infected = new HashSet<>();\\n        Queue<Integer> pending = new LinkedList<>();\\n        pending.add(start);\\n        infected.add(start);\\n        while(pending.size() != 0) {\\n            int len = pending.size();\\n            for(int i=0; i<len; i++) {\\n                int curr = pending.poll();\\n                List<Integer> child = graph.getOrDefault(curr, new ArrayList<>());\\n                for(int j=0; j<child.size(); j++) {\\n                    if(!infected.contains(child.get(j))) {\\n                        infected.add(child.get(j));\\n                        pending.add(child.get(j));\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    static void buildGraph(TreeNode root, HashMap<Integer, List<Integer>> graph) {\\n        if (root == null) {\\n            return;\\n        }\\n        int curr = root.val;\\n        if(root.left != null) {\\n            int val = root.left.val;\\n            putNodeInGraph(curr, val, graph);\\n        }\\n        if(root.right != null) {\\n            int val = root.right.val;\\n            putNodeInGraph(curr, val, graph);\\n        }\\n        buildGraph(root.left, graph);\\n        buildGraph(root.right, graph);\\n    }\\n    static void putNodeInGraph(int curr, int val, HashMap<Integer, List<Integer>> graph) {\\n        if(!graph.containsKey(curr)) {\\n            graph.put(curr, new ArrayList<>());\\n        }\\n        if(!graph.containsKey(val)) {\\n            graph.put(val, new ArrayList<>());\\n        }\\n        List<Integer> currT = graph.get(curr);\\n        currT.add(val);\\n        graph.put(curr, currT);\\n        List<Integer> valT = graph.get(val);\\n        valT.add(curr);\\n        graph.put(val, valT);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        HashMap<Integer, List<Integer>> graph = new HashMap<>();\\n        buildGraph(root, graph);\\n        int ans = getTimeToInfact(graph, start);\\n        return ans;\\n    }\\n    static int getTimeToInfact(HashMap<Integer, List<Integer>> graph, int start) {\\n        int ans = -1;\\n        Set<Integer> infected = new HashSet<>();\\n        Queue<Integer> pending = new LinkedList<>();\\n        pending.add(start);\\n        infected.add(start);\\n        while(pending.size() != 0) {\\n            int len = pending.size();\\n            for(int i=0; i<len; i++) {\\n                int curr = pending.poll();\\n                List<Integer> child = graph.getOrDefault(curr, new ArrayList<>());\\n                for(int j=0; j<child.size(); j++) {\\n                    if(!infected.contains(child.get(j))) {\\n                        infected.add(child.get(j));\\n                        pending.add(child.get(j));\\n                    }\\n                }\\n            }\\n            ans++;\\n        }\\n        return ans;\\n    }\\n    static void buildGraph(TreeNode root, HashMap<Integer, List<Integer>> graph) {\\n        if (root == null) {\\n            return;\\n        }\\n        int curr = root.val;\\n        if(root.left != null) {\\n            int val = root.left.val;\\n            putNodeInGraph(curr, val, graph);\\n        }\\n        if(root.right != null) {\\n            int val = root.right.val;\\n            putNodeInGraph(curr, val, graph);\\n        }\\n        buildGraph(root.left, graph);\\n        buildGraph(root.right, graph);\\n    }\\n    static void putNodeInGraph(int curr, int val, HashMap<Integer, List<Integer>> graph) {\\n        if(!graph.containsKey(curr)) {\\n            graph.put(curr, new ArrayList<>());\\n        }\\n        if(!graph.containsKey(val)) {\\n            graph.put(val, new ArrayList<>());\\n        }\\n        List<Integer> currT = graph.get(curr);\\n        currT.add(val);\\n        graph.put(curr, currT);\\n        List<Integer> valT = graph.get(val);\\n        valT.add(curr);\\n        graph.put(val, valT);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458951,
                "title": "rust-building-a-graph",
                "content": "~~~\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nuse std::collections::HashMap;\\nuse std::collections::HashSet;\\nuse std::collections::VecDeque;\\ntype OptionNode = Option<Rc<RefCell<TreeNode>>>;\\n\\nimpl Solution {\\n    pub fn amount_of_time(root: OptionNode, start: i32) -> i32 {\\n        let mut graph = HashMap::<i32, Vec<i32>>::new();\\n        Self::collect(&mut graph, &root);\\n        \\n        let mut q = VecDeque::<i32>::new();\\n        let mut s = HashSet::<i32>::new();\\n        let mut count = 0;\\n        \\n        q.push_back(start);\\n        s.insert(start);\\n        while q.is_empty() == false {\\n            let sz = q.len();\\n            for _ in 0..sz {\\n                if let Some(u) = q.pop_front() {\\n                    if let Some(mp) = graph.get(&u) {\\n                        for v in mp {\\n                            if s.contains(&v) { continue }\\n                            \\n                            s.insert(*v);\\n                            q.push_back(*v);\\n                        }\\n                    }\\n                } \\n            }\\n            if q.is_empty() == false { count += 1; }\\n        }\\n        \\n        count\\n    }\\n    \\n    fn collect(graph: &mut HashMap<i32, Vec<i32>>, root: &OptionNode) {\\n        let node = root.as_ref().unwrap().borrow();\\n        \\n        if node.left.is_some() {\\n            let left = &node.left.as_ref().unwrap().borrow();\\n            \\n            graph.entry(node.val).or_insert(vec![]).push(left.val);\\n            graph.entry(left.val).or_insert(vec![]).push(node.val);\\n            \\n            Self::collect(graph, &node.left);\\n        }\\n        \\n        if node.right.is_some() { \\n            let right = &node.right.as_ref().unwrap().borrow();\\n            \\n            graph.entry(node.val).or_insert(vec![]).push(right.val);\\n            graph.entry(right.val).or_insert(vec![]).push(node.val);\\n            \\n            Self::collect(graph, &node.right);\\n        }\\n    }\\n}\\n~~~",
                "solutionTags": [
                    "Rust",
                    "Breadth-First Search"
                ],
                "code": "~~~\\nuse std::rc::Rc;\\nuse std::cell::RefCell;\\nuse std::collections::HashMap;\\nuse std::collections::HashSet;\\nuse std::collections::VecDeque;\\ntype OptionNode = Option<Rc<RefCell<TreeNode>>>;\\n\\nimpl Solution {\\n    pub fn amount_of_time(root: OptionNode, start: i32) -> i32 {\\n        let mut graph = HashMap::<i32, Vec<i32>>::new();\\n        Self::collect(&mut graph, &root);\\n        \\n        let mut q = VecDeque::<i32>::new();\\n        let mut s = HashSet::<i32>::new();\\n        let mut count = 0;\\n        \\n        q.push_back(start);\\n        s.insert(start);\\n        while q.is_empty() == false {\\n            let sz = q.len();\\n            for _ in 0..sz {\\n                if let Some(u) = q.pop_front() {\\n                    if let Some(mp) = graph.get(&u) {\\n                        for v in mp {\\n                            if s.contains(&v) { continue }\\n                            \\n                            s.insert(*v);\\n                            q.push_back(*v);\\n                        }\\n                    }\\n                } \\n            }\\n            if q.is_empty() == false { count += 1; }\\n        }\\n        \\n        count\\n    }\\n    \\n    fn collect(graph: &mut HashMap<i32, Vec<i32>>, root: &OptionNode) {\\n        let node = root.as_ref().unwrap().borrow();\\n        \\n        if node.left.is_some() {\\n            let left = &node.left.as_ref().unwrap().borrow();\\n            \\n            graph.entry(node.val).or_insert(vec![]).push(left.val);\\n            graph.entry(left.val).or_insert(vec![]).push(node.val);\\n            \\n            Self::collect(graph, &node.left);\\n        }\\n        \\n        if node.right.is_some() { \\n            let right = &node.right.as_ref().unwrap().borrow();\\n            \\n            graph.entry(node.val).or_insert(vec![]).push(right.val);\\n            graph.entry(right.val).or_insert(vec![]).push(node.val);\\n            \\n            Self::collect(graph, &node.right);\\n        }\\n    }\\n}\\n~~~",
                "codeTag": "Unknown"
            },
            {
                "id": 2458753,
                "title": "beats100-dfs-for-the-constructed-graph-from-tree",
                "content": "As long as you know how to construct a graph using queue, then it is an easy question.\\n1. construct an undirected graph using BFS (store both positive edge and negative ege)\\n2. use either dfs or bfs to find the farthest node from start node, the answer is basically the maximum number of edges you can go through from start node on the tree. \\n3. while traversing on the tree, make sure not to step on the same node twice. (Maintaining an record of already seen nodes) \\n\\nTime complexity: O(N) - traversed all the nodes on the tree\\nSpace complexity: O(N) - space for graph(hashmap), record array for already seen nodes and queue\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> g;\\n    vector<int> seen;\\n    \\n    int dfs(int root) {\\n        int ans = 0;\\n        seen[root] = 1;\\n        for (auto &adj : g[root]) {\\n            if (!seen[adj]) ans = max(ans, 1 + dfs(adj));\\n        }\\n        return ans;\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n        int n = 0;\\n        queue<TreeNode *> q;\\n        q.emplace(root);\\n        while (q.size()) {\\n            auto curr = q.front(); q.pop();\\n            n = max(n, curr->val);\\n            if (curr->left) {\\n                g[curr->val].emplace_back(curr->left->val);\\n                g[curr->left->val].emplace_back(curr->val);\\n                q.emplace(curr->left);\\n            }\\n            if (curr->right) {\\n                g[curr->val].emplace_back(curr->right->val);\\n                g[curr->right->val].emplace_back(curr->val);\\n                q.emplace(curr->right);\\n            }\\n        }\\n        seen.resize(n + 1);\\n        return dfs(start);\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int, vector<int>> g;\\n    vector<int> seen;\\n    \\n    int dfs(int root) {\\n        int ans = 0;\\n        seen[root] = 1;\\n        for (auto &adj : g[root]) {\\n            if (!seen[adj]) ans = max(ans, 1 + dfs(adj));\\n        }\\n        return ans;\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) {\\n        int n = 0;\\n        queue<TreeNode *> q;\\n        q.emplace(root);\\n        while (q.size()) {\\n            auto curr = q.front(); q.pop();\\n            n = max(n, curr->val);\\n            if (curr->left) {\\n                g[curr->val].emplace_back(curr->left->val);\\n                g[curr->left->val].emplace_back(curr->val);\\n                q.emplace(curr->left);\\n            }\\n            if (curr->right) {\\n                g[curr->val].emplace_back(curr->right->val);\\n                g[curr->right->val].emplace_back(curr->val);\\n                q.emplace(curr->right);\\n            }\\n        }\\n        seen.resize(n + 1);\\n        return dfs(start);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458627,
                "title": "simplest-solution-with-bfs-and-hashmap",
                "content": "\\t#define  tn TreeNode\\n\\tclass Solution {\\n\\tpublic:\\n\\t// hashmap to store prev node\\n    map<tn*,tn*> mp;\\n\\t\\n\\t// store the starting node \\n    tn *snode =NULL;\\n\\t\\n    void f(tn *root, tn *prev,int start){\\n        if(!root)return;\\n        mp[root] =prev; // storing prev node \\n        if(start==root->val) snode = root;\\n        f(root->left, root,start);\\n        f(root->right,root,start);        \\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        f(root,NULL,start);\\n        \\n\\t\\t// normal BFS\\n        int  ans =0;\\n        queue<tn*> q;\\n        q.push(snode);\\n        map<tn*,int> vis;\\n        while(!q.empty()){            \\n            int s = q.size();\\n            while(s--){\\n                auto node = q.front(); q.pop();\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// BFS in left,right and top\\n                if(node->left and vis[node->left]==0 ) { q.push(node->left); }\\n                if(node->right and vis[node->right]==0 ){                    \\n                    q.push(node->right);\\n                }\\n                if(mp[node] !=NULL and vis[mp[node]]==0){\\n                    q.push(mp[node]);\\n                }\\n                vis[node]++;\\n            }\\n            ans++;\\n        }\\n        return ans-1;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t// hashmap to store prev node\\n    map<tn*,tn*> mp;\\n\\t\\n\\t// store the starting node \\n    tn *snode =NULL;\\n\\t\\n    void f(tn *root, tn *prev,int start){\\n        if(!root)return;\\n        mp[root] =prev; // storing prev node \\n        if(start==root->val) snode = root;\\n        f(root->left, root,start);\\n        f(root->right,root,start);        \\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2458489,
                "title": "java-bfs-solution-build-graph-similar-like-leetcode-863",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    HashMap<TreeNode, List<TreeNode>> graph;\\n    Set<TreeNode> visited;\\n    Queue<TreeNode> queue;\\n    TreeNode infected;\\n    \\n    public int amountOfTime(TreeNode root, int start) {\\n        graph = new HashMap();\\n        visited = new HashSet();\\n        queue = new ArrayDeque<TreeNode>();\\n        \\n        buildGraph(root, start);\\n        \\n        queue.offer(infected);\\n        visited.add(infected);\\n        \\n        int minutes = 0;\\n        \\n        while(!queue.isEmpty())\\n        {\\n            int size = queue.size();\\n            while(size-- > 0)\\n            {\\n                TreeNode current = queue.poll();\\n                \\n                for(TreeNode neighbour: graph.get(current))\\n                {\\n                    if(!visited.contains(neighbour))\\n                    {\\n                        queue.offer(neighbour);\\n                        visited.add(neighbour);\\n                    }\\n                }\\n            }\\n            minutes++;\\n        }\\n        \\n        \\n        return minutes - 1;\\n    }\\n    \\n    private void buildGraph(TreeNode root, int start)\\n    {\\n        if(root == null) return;\\n        \\n        if(!graph.containsKey(root))\\n            graph.put(root, new ArrayList<TreeNode>());\\n        \\n        if(root.left != null)\\n        {\\n            if(!graph.containsKey(root.left))\\n                graph.put(root.left, new ArrayList<TreeNode>());\\n            \\n            graph.get(root).add(root.left);\\n            graph.get(root.left).add(root);\\n        }\\n        \\n       if(root.right != null)\\n        {\\n            if(!graph.containsKey(root.right))\\n                graph.put(root.right, new ArrayList<TreeNode>());\\n            \\n            graph.get(root).add(root.right);\\n            graph.get(root.right).add(root);\\n        } \\n        \\n        if(root.val == start)\\n            infected = root;\\n        \\n        buildGraph(root.left, start);\\n        buildGraph(root.right, start);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    HashMap<TreeNode, List<TreeNode>> graph;\\n    Set<TreeNode> visited;\\n    Queue<TreeNode> queue;\\n    TreeNode infected;\\n    \\n    public int amountOfTime(TreeNode root, int start) {\\n        graph = new HashMap();\\n        visited = new HashSet();\\n        queue = new ArrayDeque<TreeNode>();\\n        \\n        buildGraph(root, start);\\n        \\n        queue.offer(infected);\\n        visited.add(infected);\\n        \\n        int minutes = 0;\\n        \\n        while(!queue.isEmpty())\\n        {\\n            int size = queue.size();\\n            while(size-- > 0)\\n            {\\n                TreeNode current = queue.poll();\\n                \\n                for(TreeNode neighbour: graph.get(current))\\n                {\\n                    if(!visited.contains(neighbour))\\n                    {\\n                        queue.offer(neighbour);\\n                        visited.add(neighbour);\\n                    }\\n                }\\n            }\\n            minutes++;\\n        }\\n        \\n        \\n        return minutes - 1;\\n    }\\n    \\n    private void buildGraph(TreeNode root, int start)\\n    {\\n        if(root == null) return;\\n        \\n        if(!graph.containsKey(root))\\n            graph.put(root, new ArrayList<TreeNode>());\\n        \\n        if(root.left != null)\\n        {\\n            if(!graph.containsKey(root.left))\\n                graph.put(root.left, new ArrayList<TreeNode>());\\n            \\n            graph.get(root).add(root.left);\\n            graph.get(root.left).add(root);\\n        }\\n        \\n       if(root.right != null)\\n        {\\n            if(!graph.containsKey(root.right))\\n                graph.put(root.right, new ArrayList<TreeNode>());\\n            \\n            graph.get(root).add(root.right);\\n            graph.get(root.right).add(root);\\n        } \\n        \\n        if(root.val == start)\\n            infected = root;\\n        \\n        buildGraph(root.left, start);\\n        buildGraph(root.right, start);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458388,
                "title": "javascript-parent-hashmap-bfs",
                "content": "**Solution: Parent Hashmap & BFS**\\n\\n1. DFS through the tree to record the parent node of each node in a hashmap and get the start node.\\n1. Level-by-level BFS from the start node to get the total time to reach every node.\\n\\t*   Keep track of nodes we have visited to avoid revisiting.\\n\\t*   From every node, visit the parent, left child, and right child if they haven\\'t been visited.\\n\\nTime Complexity: `O(n)` 415ms\\nSpace Complexity: `O(n)` 90.1MB\\n```\\nvar amountOfTime = function(root, start) {\\n  let parent = new Map(), startNode = null;\\n  getParent(root);\\n  let seen = new Set([startNode.val]), queue = [startNode], time = 0;\\n  while (queue.length) {\\n    for (let i = queue.length - 1; i >= 0; i--) {\\n      let node = queue.shift();\\n      \\n      if (parent.has(node.val)) {\\n        let nodeParent = parent.get(node.val);\\n        if (!seen.has(nodeParent.val)) {\\n          queue.push(nodeParent);\\n          seen.add(nodeParent.val);\\n        }\\n      }\\n      if (node.left && !seen.has(node.left.val)) {\\n        queue.push(node.left);\\n        seen.add(node.left.val);\\n      }\\n      if (node.right && !seen.has(node.right.val)) {\\n        queue.push(node.right);\\n        seen.add(node.right.val);\\n      }\\n    }\\n    time++;\\n  }\\n  return time - 1;\\n  \\n  function getParent(node) {\\n    if (node.val === start) startNode = node;\\n    if (node.left) { // record the parent of the left child\\n      parent.set(node.left.val, node);\\n      getParent(node.left);\\n    }\\n    if (node.right) { // record the parent of the right child\\n      parent.set(node.right.val, node);\\n      getParent(node.right);\\n    } \\n  }  \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar amountOfTime = function(root, start) {\\n  let parent = new Map(), startNode = null;\\n  getParent(root);\\n  let seen = new Set([startNode.val]), queue = [startNode], time = 0;\\n  while (queue.length) {\\n    for (let i = queue.length - 1; i >= 0; i--) {\\n      let node = queue.shift();\\n      \\n      if (parent.has(node.val)) {\\n        let nodeParent = parent.get(node.val);\\n        if (!seen.has(nodeParent.val)) {\\n          queue.push(nodeParent);\\n          seen.add(nodeParent.val);\\n        }\\n      }\\n      if (node.left && !seen.has(node.left.val)) {\\n        queue.push(node.left);\\n        seen.add(node.left.val);\\n      }\\n      if (node.right && !seen.has(node.right.val)) {\\n        queue.push(node.right);\\n        seen.add(node.right.val);\\n      }\\n    }\\n    time++;\\n  }\\n  return time - 1;\\n  \\n  function getParent(node) {\\n    if (node.val === start) startNode = node;\\n    if (node.left) { // record the parent of the left child\\n      parent.set(node.left.val, node);\\n      getParent(node.left);\\n    }\\n    if (node.right) { // record the parent of the right child\\n      parent.set(node.right.val, node);\\n      getParent(node.right);\\n    } \\n  }  \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2458260,
                "title": "bfs-graph",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        // build graph:\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        traverse(root, graph);\\n        \\n        // BFS:\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        HashSet<Integer> visited = new HashSet<>();\\n        \\n        q.add(start);\\n        visited.add(start);\\n        int level = -1;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int s = 0; s < size; s++) {\\n                int curr = q.poll();\\n                \\n                List<Integer> neilist = graph.get(curr);\\n                for (int nei: neilist) {\\n                    if (!visited.contains(nei)) {\\n                        q.add(nei);\\n                        visited.add(nei);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n    private void traverse(TreeNode root, Map<Integer, List<Integer>> graph) {\\n        if (root == null) return;\\n        // top down\\n        // root - left - right\\n        if (!graph.containsKey(root.val)) {\\n            graph.put(root.val, new ArrayList<>());\\n        }\\n        if (root.left != null) {\\n            if (!graph.containsKey(root.left.val)) {\\n                graph.put(root.left.val, new ArrayList<>());\\n            }\\n            graph.get(root.left.val).add(root.val);\\n            graph.get(root.val).add(root.left.val);\\n        }\\n        if (root.right != null) {\\n            \\n            if (!graph.containsKey(root.right.val)) {\\n                graph.put(root.right.val, new ArrayList<>());\\n            }\\n            graph.get(root.right.val).add(root.val);\\n            graph.get(root.val).add(root.right.val);\\n        }\\n        \\n        traverse(root.left, graph);\\n        traverse(root.right, graph);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        // build graph:\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        traverse(root, graph);\\n        \\n        // BFS:\\n        \\n        Queue<Integer> q = new LinkedList<>();\\n        HashSet<Integer> visited = new HashSet<>();\\n        \\n        q.add(start);\\n        visited.add(start);\\n        int level = -1;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            for (int s = 0; s < size; s++) {\\n                int curr = q.poll();\\n                \\n                List<Integer> neilist = graph.get(curr);\\n                for (int nei: neilist) {\\n                    if (!visited.contains(nei)) {\\n                        q.add(nei);\\n                        visited.add(nei);\\n                    }\\n                }\\n            }\\n            level++;\\n        }\\n        return level;\\n    }\\n    private void traverse(TreeNode root, Map<Integer, List<Integer>> graph) {\\n        if (root == null) return;\\n        // top down\\n        // root - left - right\\n        if (!graph.containsKey(root.val)) {\\n            graph.put(root.val, new ArrayList<>());\\n        }\\n        if (root.left != null) {\\n            if (!graph.containsKey(root.left.val)) {\\n                graph.put(root.left.val, new ArrayList<>());\\n            }\\n            graph.get(root.left.val).add(root.val);\\n            graph.get(root.val).add(root.left.val);\\n        }\\n        if (root.right != null) {\\n            \\n            if (!graph.containsKey(root.right.val)) {\\n                graph.put(root.right.val, new ArrayList<>());\\n            }\\n            graph.get(root.right.val).add(root.val);\\n            graph.get(root.val).add(root.right.val);\\n        }\\n        \\n        traverse(root.left, graph);\\n        traverse(root.right, graph);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2458239,
                "title": "c-bsf-parent-map-explained-commented-code-o-n",
                "content": "![image](https://assets.leetcode.com/users/images/568e2d54-5dd6-468a-b68f-b0e6f2333345_1661073944.4729493.png)\\n\\n```\\n/*\\n--> use a parent array to keep track of parent of a node\\n--> search for the start node \\n--> with the help of given tree and parent node do a BSF\\n--> use a vis map to keep track of visited\\n--> increment ans after every level you traverse\\n*/\\nclass Solution {\\npublic:\\n    void pre(map<TreeNode*,TreeNode*> &parent,TreeNode* root,TreeNode* &st,int start)\\n    {\\n        if(!root) return;\\n        if(root->left) parent[root->left]=root;\\n        if(root->right) parent[root->right]=root;\\n        if(root->val==start) st=root;\\n        pre(parent,root->left,st,start);\\n        pre(parent,root->right,st,start);\\n        \\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        map<TreeNode*,TreeNode*> parent;\\n        parent[root]=NULL;\\n        TreeNode* st;\\n        pre(parent,root,st,start); // traversal for marking parent of node and to search starting node // preorder traversal\\n        queue<TreeNode*> q;         q.push(st);\\n        int ans=0;\\n        map<TreeNode*,int> vis; // visited map\\n        vis[st]=1;\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                if(curr->left && !vis[curr->left]){ q.push(curr->left); vis[curr->left]++;}\\n                if(curr->right && !vis[curr->right]){ q.push(curr->right); vis[curr->right]++;}\\n                if(parent[curr] && !vis[parent[curr]]){ q.push(parent[curr]); vis[parent[curr]]++;}\\n            }\\n            ans++;\\n        }\\n        return --ans;\\n    }\\n};\\n/*\\n--> TC O(N)\\n--> SC O(N)\\n*/\\n```\\n",
                "solutionTags": [
                    "C",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n/*\\n--> use a parent array to keep track of parent of a node\\n--> search for the start node \\n--> with the help of given tree and parent node do a BSF\\n--> use a vis map to keep track of visited\\n--> increment ans after every level you traverse\\n*/\\nclass Solution {\\npublic:\\n    void pre(map<TreeNode*,TreeNode*> &parent,TreeNode* root,TreeNode* &st,int start)\\n    {\\n        if(!root) return;\\n        if(root->left) parent[root->left]=root;\\n        if(root->right) parent[root->right]=root;\\n        if(root->val==start) st=root;\\n        pre(parent,root->left,st,start);\\n        pre(parent,root->right,st,start);\\n        \\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        map<TreeNode*,TreeNode*> parent;\\n        parent[root]=NULL;\\n        TreeNode* st;\\n        pre(parent,root,st,start); // traversal for marking parent of node and to search starting node // preorder traversal\\n        queue<TreeNode*> q;         q.push(st);\\n        int ans=0;\\n        map<TreeNode*,int> vis; // visited map\\n        vis[st]=1;\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n                TreeNode* curr=q.front();\\n                q.pop();\\n                if(curr->left && !vis[curr->left]){ q.push(curr->left); vis[curr->left]++;}\\n                if(curr->right && !vis[curr->right]){ q.push(curr->right); vis[curr->right]++;}\\n                if(parent[curr] && !vis[parent[curr]]){ q.push(parent[curr]); vis[parent[curr]]++;}\\n            }\\n            ans++;\\n        }\\n        return --ans;\\n    }\\n};\\n/*\\n--> TC O(N)\\n--> SC O(N)\\n*/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457920,
                "title": "simplet-solution-with-dfs-bfs",
                "content": "build graph: DFS\\ncalculate the number of minute: BFS\\n```\\nclass Solution {\\n    func amountOfTime(_ root: TreeNode?, _ start: Int) -> Int {\\n        var map = [Int: [Int]]()\\n        \\n        func dfs(_ node: TreeNode?, _ parentValue: Int?) {\\n            guard let node = node else { return }\\n            let val = node.val\\n            if let parentVal = parentValue {\\n                map[parentVal, default: [Int]()].append(val)\\n                map[val, default: [Int]()].append(parentVal)\\n            }\\n            dfs(node.left, val)\\n            dfs(node.right, val)\\n        }\\n        \\n        dfs(root, nil)\\n        \\n        var count = 0\\n        var queue = [start]\\n        var visited = Set<Int>()\\n        visited.insert(start)\\n        while queue.count > 0 {\\n            let size = queue.count\\n            for _ in 0..<size {\\n                let cur = queue.removeFirst()\\n                if let nexts = map[cur] {\\n                    for next in nexts {\\n                        if !visited.contains(next) {\\n                            queue.append(next)\\n                            visited.insert(next)\\n                        }\\n                    }\\n                }\\n            }\\n            count += 1\\n        }\\n        return count - 1\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    func amountOfTime(_ root: TreeNode?, _ start: Int) -> Int {\\n        var map = [Int: [Int]]()\\n        \\n        func dfs(_ node: TreeNode?, _ parentValue: Int?) {\\n            guard let node = node else { return }\\n            let val = node.val\\n            if let parentVal = parentValue {\\n                map[parentVal, default: [Int]()].append(val)\\n                map[val, default: [Int]()].append(parentVal)\\n            }\\n            dfs(node.left, val)\\n            dfs(node.right, val)\\n        }\\n        \\n        dfs(root, nil)\\n        \\n        var count = 0\\n        var queue = [start]\\n        var visited = Set<Int>()\\n        visited.insert(start)\\n        while queue.count > 0 {\\n            let size = queue.count\\n            for _ in 0..<size {\\n                let cur = queue.removeFirst()\\n                if let nexts = map[cur] {\\n                    for next in nexts {\\n                        if !visited.contains(next) {\\n                            queue.append(next)\\n                            visited.insert(next)\\n                        }\\n                    }\\n                }\\n            }\\n            count += 1\\n        }\\n        return count - 1\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457570,
                "title": "c-bfs-fully-explained-with-comments",
                "content": "**Simple approach is to convert the binary tree into an undirected graph(adjacency list) using BFS, and then again we will run BFS on the graph to find the number of levels in it**\\n```\\nclass Solution {\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        map<int,vector<int>> adj; // adjacency list\\n        queue<TreeNode*> q; // queue for tree bfs\\n\\t\\t\\n\\t\\t// Applying BFS on the tree:\\n        q.push(root); \\n        while(!q.empty())\\n        {\\n            auto curr=q.front();\\n            q.pop();\\n            if(curr->left){\\n                q.push(curr->left);\\n                adj[curr->val].push_back(curr->left->val);\\n                adj[curr->left->val].push_back(curr->val);\\n            }\\n            if(curr->right){\\n                q.push(curr->right);\\n                adj[curr->val].push_back(curr->right->val);\\n                adj[curr->right->val].push_back(curr->val);\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Now applying the usual BFS process on the undirected graph\\n        unordered_map<int,bool> vis;\\n        queue<int> qt; \\n        qt.push(start);\\n        vis[start]=true;\\n        int ct=0; // Counter to store number of levels\\n        while(!qt.empty())\\n        {\\n            int sz=qt.size();\\n            while(sz--){ // Finding the number of levels \\n                int curr=qt.front();\\n                qt.pop();\\n                for(int node:adj[curr]){\\n                    if(!vis[node]){\\n                        vis[node]=true;\\n                        qt.push(node);\\n                    }\\n                }\\n            }\\n            ct++;\\n        }\\n\\t\\t// As levels are like nodes and we want number of edges hence edges=ct-1;\\n        return ct-1;\\n    }\\n};\\n```\\n*In case of any doubt(s), do comment below* \\uD83D\\uDE0A\\uD83D\\uDE04",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Breadth-First Search",
                    "Queue"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        map<int,vector<int>> adj; // adjacency list\\n        queue<TreeNode*> q; // queue for tree bfs\\n\\t\\t\\n\\t\\t// Applying BFS on the tree:\\n        q.push(root); \\n        while(!q.empty())\\n        {\\n            auto curr=q.front();\\n            q.pop();\\n            if(curr->left){\\n                q.push(curr->left);\\n                adj[curr->val].push_back(curr->left->val);\\n                adj[curr->left->val].push_back(curr->val);\\n            }\\n            if(curr->right){\\n                q.push(curr->right);\\n                adj[curr->val].push_back(curr->right->val);\\n                adj[curr->right->val].push_back(curr->val);\\n            }\\n        }\\n\\t\\t\\n\\t\\t// Now applying the usual BFS process on the undirected graph\\n        unordered_map<int,bool> vis;\\n        queue<int> qt; \\n        qt.push(start);\\n        vis[start]=true;\\n        int ct=0; // Counter to store number of levels\\n        while(!qt.empty())\\n        {\\n            int sz=qt.size();\\n            while(sz--){ // Finding the number of levels \\n                int curr=qt.front();\\n                qt.pop();\\n                for(int node:adj[curr]){\\n                    if(!vis[node]){\\n                        vis[node]=true;\\n                        qt.push(node);\\n                    }\\n                }\\n            }\\n            ct++;\\n        }\\n\\t\\t// As levels are like nodes and we want number of edges hence edges=ct-1;\\n        return ct-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457294,
                "title": "easy-python-bfs-solution",
                "content": "STEP-1 : Convert the given tree into the graph (Adjacancy list/Adjacancy Dict; here I have used Dict).\\nSTEP-2: Do BFS traversal and find the count of levels, here the levels signifies the count of seconds.\\n\\nTime Complexity: O(n), where n is number of nodes.\\n\\n```\\nfrom collections import defaultdict\\nclass Solution:\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n        adj=self.tree_to_graph(root,None,graph=dict())\\n        res=self.bfs(adj, start)\\n        return res\\n            \\n    def tree_to_graph(self, root, parent, graph):\\n        graph[root.val] = []\\n        \\n        if(root.left != None):\\n            graph[root.val].append(root.left.val)\\n            self.tree_to_graph(root.left, root, graph)\\n            \\n        if(root.right != None):\\n            graph[root.val].append(root.right.val)\\n            self.tree_to_graph(root.right, root, graph)\\n            \\n        if(parent != None):\\n            graph[root.val].append(parent.val)\\n            \\n        return graph\\n    \\n    def bfs(self, graph, start):\\n        q=[start]\\n        visited=set()\\n        visited.add(start)\\n        res=0\\n        while q:\\n            n=len(q)\\n            for i in range(len(q)):\\n                t=q.pop(0)\\n                for neighbour in graph[t]:\\n                    if neighbour not in visited:\\n                        visited.add(neighbour)\\n                        q.append(neighbour)\\n            res+=1\\n        return res-1\\n```",
                "solutionTags": [
                    "Python",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution:\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n        adj=self.tree_to_graph(root,None,graph=dict())\\n        res=self.bfs(adj, start)\\n        return res\\n            \\n    def tree_to_graph(self, root, parent, graph):\\n        graph[root.val] = []\\n        \\n        if(root.left != None):\\n            graph[root.val].append(root.left.val)\\n            self.tree_to_graph(root.left, root, graph)\\n            \\n        if(root.right != None):\\n            graph[root.val].append(root.right.val)\\n            self.tree_to_graph(root.right, root, graph)\\n            \\n        if(parent != None):\\n            graph[root.val].append(parent.val)\\n            \\n        return graph\\n    \\n    def bfs(self, graph, start):\\n        q=[start]\\n        visited=set()\\n        visited.add(start)\\n        res=0\\n        while q:\\n            n=len(q)\\n            for i in range(len(q)):\\n                t=q.pop(0)\\n                for neighbour in graph[t]:\\n                    if neighbour not in visited:\\n                        visited.add(neighbour)\\n                        q.append(neighbour)\\n            res+=1\\n        return res-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457268,
                "title": "tree-traversal-no-graph-required-beats-100-runtime",
                "content": "So the idea is simple, at any point of time, \\nif we consider a root, \\n1. either infection is on that root, or \\n2. it\\'s coming from left subtree, or \\n3. it\\'s coming from right subtree, \\n4. or atlast, infection may still need to be discovered at higher level.\\nFrom recursion point of view, we don\\'t have to deal with last case(as it will be handled automatically when call stack is getting emptied)\\n\\n\\n\\n\\n```\\nclass Solution {\\npublic:\\n// returns a pair of bool and int\\n// bool denotes if infection(start) was found\\n// int denotes actual height if infection was not found, otherwise it denotes distance from start.\\n    pair<bool, int> infectedHeight(TreeNode *root, int start, int &ans){\\n        if(root == NULL)\\n            return {false, 0};\\n        pair<bool, int> left, right;\\n        left = infectedHeight(root->left, start, ans);\\n        right = infectedHeight(root->right, start, ans);\\n        // if cur root is infected\\n        if(root->val == start){\\n            ans = max(ans, max(left.second, right.second));\\n            return {true, 1};\\n        }\\n        // infection from left\\n        else if(left.first){\\n            ans = max(ans, left.second + right.second);\\n            return {true, left.second+1};\\n        }\\n        // infection from right\\n        else if(right.first){\\n            ans = max(ans, left.second + right.second);\\n            return {true, right.second+1}; \\n        }\\n        \\n        // no infection found yet!\\n        return {false, max(left.second, right.second)+1};\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        int ans = 0;\\n        infectedHeight(root, start, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n// returns a pair of bool and int\\n// bool denotes if infection(start) was found\\n// int denotes actual height if infection was not found, otherwise it denotes distance from start.\\n    pair<bool, int> infectedHeight(TreeNode *root, int start, int &ans){\\n        if(root == NULL)\\n            return {false, 0};\\n        pair<bool, int> left, right;\\n        left = infectedHeight(root->left, start, ans);\\n        right = infectedHeight(root->right, start, ans);\\n        // if cur root is infected\\n        if(root->val == start){\\n            ans = max(ans, max(left.second, right.second));\\n            return {true, 1};\\n        }\\n        // infection from left\\n        else if(left.first){\\n            ans = max(ans, left.second + right.second);\\n            return {true, left.second+1};\\n        }\\n        // infection from right\\n        else if(right.first){\\n            ans = max(ans, left.second + right.second);\\n            return {true, right.second+1}; \\n        }\\n        \\n        // no infection found yet!\\n        return {false, max(left.second, right.second)+1};\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        int ans = 0;\\n        infectedHeight(root, start, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457224,
                "title": "c-dfs-nodetorootpath-easy-o-n",
                "content": "**Algorithm**\\nStore path from `start` node to `root` in an array named `nodeToRootPath[]`.\\n`nodeToRootPath[i]` represents that element `nodeToRootPath[i]` will get infected at `i\\'th` minute.\\n\\nNow, for every `node` in `nodeToRootPath[]` try to calculate infection time of all its children.\\nKeep on updating `ans` to maximum time.\\n\\n**Code**\\n```\\nclass Solution {\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        int ans = INT_MIN;\\n        vector<TreeNode*> path = nodeToRootPath(root, start);\\n        \\n        for(int i=0; i<path.size(); i++) {\\n            if(i == 0) {\\n                infectionTime(path[i], NULL, i, ans);\\n            }\\n            else {\\n                infectionTime(path[i], path[i-1], i, ans);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void infectionTime(TreeNode* node, TreeNode* blockage, int time, int &ans) {\\n        if(node == NULL) return;\\n\\t\\t\\n\\t\\t// condition so that we should not end up infecting child nodes that are already infected\\n        if(blockage != NULL && (node->val == blockage->val)) return;\\n        \\n        if(time > ans) {\\n            ans = time;\\n        }\\n        \\n        infectionTime(node->left, blockage, time+1, ans);\\n        infectionTime(node->right, blockage, time+1, ans);\\n    }\\n    \\n\\t// node to root path\\n    vector<TreeNode*> nodeToRootPath(TreeNode* root, int key) {\\n        if(root == NULL) {\\n            vector<TreeNode*> path;\\n            return path;\\n        }\\n        if(root->val == key) {\\n            vector<TreeNode*> path = {root};\\n            return path;\\n        }\\n        vector<TreeNode*> lpath = nodeToRootPath(root->left, key);\\n        if(lpath.size()) {\\n            lpath.push_back(root);\\n            return lpath;\\n        }\\n        \\n        vector<TreeNode*> rpath = nodeToRootPath(root->right, key);\\n        if(rpath.size()) {\\n            rpath.push_back(root);\\n            return rpath;\\n        }\\n        vector<TreeNode*> path;\\n        return path;\\n    }\\n};\\n```\\n\\nTime : O(N)\\nEvery node is visited only once.\\n\\nSpace : O(H)",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        int ans = INT_MIN;\\n        vector<TreeNode*> path = nodeToRootPath(root, start);\\n        \\n        for(int i=0; i<path.size(); i++) {\\n            if(i == 0) {\\n                infectionTime(path[i], NULL, i, ans);\\n            }\\n            else {\\n                infectionTime(path[i], path[i-1], i, ans);\\n            }\\n        }\\n        return ans;\\n    }\\n    \\n    void infectionTime(TreeNode* node, TreeNode* blockage, int time, int &ans) {\\n        if(node == NULL) return;\\n\\t\\t\\n\\t\\t// condition so that we should not end up infecting child nodes that are already infected\\n        if(blockage != NULL && (node->val == blockage->val)) return;\\n        \\n        if(time > ans) {\\n            ans = time;\\n        }\\n        \\n        infectionTime(node->left, blockage, time+1, ans);\\n        infectionTime(node->right, blockage, time+1, ans);\\n    }\\n    \\n\\t// node to root path\\n    vector<TreeNode*> nodeToRootPath(TreeNode* root, int key) {\\n        if(root == NULL) {\\n            vector<TreeNode*> path;\\n            return path;\\n        }\\n        if(root->val == key) {\\n            vector<TreeNode*> path = {root};\\n            return path;\\n        }\\n        vector<TreeNode*> lpath = nodeToRootPath(root->left, key);\\n        if(lpath.size()) {\\n            lpath.push_back(root);\\n            return lpath;\\n        }\\n        \\n        vector<TreeNode*> rpath = nodeToRootPath(root->right, key);\\n        if(rpath.size()) {\\n            rpath.push_back(root);\\n            return rpath;\\n        }\\n        vector<TreeNode*> path;\\n        return path;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2457092,
                "title": "java-beats-100-detailed-explation-added-picture-for-illustration",
                "content": "Solution 1: Trivial but straightforward, go tree traversal and build a graph based on current node\\'s parent node, left node and right node. Then start either dfs or bfs the graph from the start node, return the longest path.\\n\\nSolution 2: beats 100%, two dfs\\nFirst dfs, traverse the tree and record all nodes\\' left height and right height, you can use a map to record the heights.\\nSecond dfs, traverse the tree and **find the start node**, and we know that the **ans = max of (upper distance from parent, left height, right height)**. The key here is how to calculate the **upper distance**?\\n--> A **left child\\'s upper distance** is either its **parent\\'s right height** or its parent\\'s upper distance\\n--> A **right child\\'s upper distance** is either its **parent\\'s left height** or its parent\\'s upper distance.\\n![image](https://assets.leetcode.com/users/images/7101a394-6b96-4a8e-9530-5ca4f1102519_1661057580.1047556.png)\\n```\\n// SOLUTION 1: BUILD THE GRAPH AND RUN BFS/DFS\\nclass Solution {\\n    Map<Integer, List<Integer>> map = new HashMap();\\n    Set<Integer> visited = new HashSet();\\n    public int amountOfTime(TreeNode root, int st) {\\n        dfs(root, -1);\\n        Queue<Integer> q = new LinkedList();\\n        q.offer(st);\\n        visited.add(st);\\n        int ans = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            boolean ok = false;\\n            for (int i = 0; i < size; i++) {\\n                int cur = q.poll();\\n                for (int next : map.get(cur)) {\\n                    if (visited.contains(next)) continue;\\n                    visited.add(next);\\n                    q.offer(next);\\n                    ok = true;\\n                }\\n            }\\n            if (ok) ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    public void dfs(TreeNode node, int p) {\\n        map.put(node.val, new ArrayList());\\n        if (p != -1) map.get(node.val).add(p);\\n        if (node.left != null) {\\n            map.get(node.val).add(node.left.val);\\n            dfs(node.left, node.val);\\n        }\\n        if (node.right != null) {\\n            map.get(node.val).add(node.right.val);\\n            dfs(node.right, node.val);\\n        }\\n    }\\n}\\n```\\n```\\n// SOLUTION 2: TWO DFS BEATS 100%\\nclass Solution {\\n    Map<TreeNode, int[]> map = new HashMap();\\n    int ans = 0;\\n    public int amountOfTime(TreeNode root, int st) {\\n        dfs(root);\\n        dfs1(root, st, 0);\\n        return ans;\\n    }\\n    \\n    public int dfs(TreeNode node) {\\n        if (node == null) return 0;\\n        int l = dfs(node.left);\\n        int r = dfs(node.right);\\n        map.put(node, new int[]{l, r});\\n        return Math.max(l, r) + 1;\\n    }\\n    \\n    public void dfs1(TreeNode node, int st, int up) {\\n        if (node == null) return;\\n        int[] lr = map.get(node);\\n        if (node.val == st) {\\n            ans = Math.max(up, Math.max(lr[0], lr[1]));\\n            return;\\n        }\\n        \\n        dfs1(node.left, st, Math.max(up, lr[1]) + 1);\\n        dfs1(node.right, st, Math.max(up, lr[0]) + 1);\\n    }\\n}\\n```\\n\\n",
                "solutionTags": [
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\n// SOLUTION 1: BUILD THE GRAPH AND RUN BFS/DFS\\nclass Solution {\\n    Map<Integer, List<Integer>> map = new HashMap();\\n    Set<Integer> visited = new HashSet();\\n    public int amountOfTime(TreeNode root, int st) {\\n        dfs(root, -1);\\n        Queue<Integer> q = new LinkedList();\\n        q.offer(st);\\n        visited.add(st);\\n        int ans = 0;\\n        while (!q.isEmpty()) {\\n            int size = q.size();\\n            boolean ok = false;\\n            for (int i = 0; i < size; i++) {\\n                int cur = q.poll();\\n                for (int next : map.get(cur)) {\\n                    if (visited.contains(next)) continue;\\n                    visited.add(next);\\n                    q.offer(next);\\n                    ok = true;\\n                }\\n            }\\n            if (ok) ans++;\\n        }\\n        return ans;\\n    }\\n    \\n    public void dfs(TreeNode node, int p) {\\n        map.put(node.val, new ArrayList());\\n        if (p != -1) map.get(node.val).add(p);\\n        if (node.left != null) {\\n            map.get(node.val).add(node.left.val);\\n            dfs(node.left, node.val);\\n        }\\n        if (node.right != null) {\\n            map.get(node.val).add(node.right.val);\\n            dfs(node.right, node.val);\\n        }\\n    }\\n}\\n```\n```\\n// SOLUTION 2: TWO DFS BEATS 100%\\nclass Solution {\\n    Map<TreeNode, int[]> map = new HashMap();\\n    int ans = 0;\\n    public int amountOfTime(TreeNode root, int st) {\\n        dfs(root);\\n        dfs1(root, st, 0);\\n        return ans;\\n    }\\n    \\n    public int dfs(TreeNode node) {\\n        if (node == null) return 0;\\n        int l = dfs(node.left);\\n        int r = dfs(node.right);\\n        map.put(node, new int[]{l, r});\\n        return Math.max(l, r) + 1;\\n    }\\n    \\n    public void dfs1(TreeNode node, int st, int up) {\\n        if (node == null) return;\\n        int[] lr = map.get(node);\\n        if (node.val == st) {\\n            ans = Math.max(up, Math.max(lr[0], lr[1]));\\n            return;\\n        }\\n        \\n        dfs1(node.left, st, Math.max(up, lr[1]) + 1);\\n        dfs1(node.right, st, Math.max(up, lr[0]) + 1);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456970,
                "title": "java-1-pass-dfs-similar-to-finding-the-diameter-of-tree",
                "content": "This is my contest solution. It\\'s very similar to the leetcode question where it asks you to find *The Diameter of a Tree*. \\nWe have a global variable that tracks the maximum value.\\nThen we do DFS, there are basically 3 cases to handle.\\n1. When the current node is our target, we update the answer to the max of depth from both its chlidren.\\n2. When the current Tree rooted at it does **not** contain the target node, we should return the maximum depth to its parent.\\n3. When the current Tree rooted at it contains the target node, we update answer = `max(dist from current node to target + maxDepth from the other child)`\\n\\n\\n`Time O(N)`\\n`Space O(Height of Tree)`\\n```Java\\nclass Solution {\\n    int res = 0;\\n    public int amountOfTime(TreeNode root, int start) {\\n        dfs(root, start);\\n        return res;\\n    }\\n\\n    int[] dfs(TreeNode root, int start){\\n        int[] ans = new int[2]; // [value, whether this tree contains target]\\n        if (root == null){\\n            return ans;\\n        }\\n        int[] L = dfs(root.left, start);\\n        int[] R = dfs(root.right, start);\\n        if (root.val == start){ // case 1\\n            ans[1] = ans[0] = 1; // reset depth and set ans[1] = 1, meaning this subtree now contains target\\n            res = Math.max(L[0], R[0]);\\n            return ans;\\n        }\\n        if (R[1]+L[1] >= 1){ // case 3\\n            ans[1] = 1;\\n            res = Math.max(res, L[0] + R[0]);\\n            ans[0] = R[1] == 1? R[0] : L[0]; // return the depth from current node to target and discard the other one.\\n        }else{ // case 2\\n            ans[0] = Math.max(R[0], L[0]);\\n        }\\n        ans[0]++; // increment depth\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```Java\\nclass Solution {\\n    int res = 0;\\n    public int amountOfTime(TreeNode root, int start) {\\n        dfs(root, start);\\n        return res;\\n    }\\n\\n    int[] dfs(TreeNode root, int start){\\n        int[] ans = new int[2]; // [value, whether this tree contains target]\\n        if (root == null){\\n            return ans;\\n        }\\n        int[] L = dfs(root.left, start);\\n        int[] R = dfs(root.right, start);\\n        if (root.val == start){ // case 1\\n            ans[1] = ans[0] = 1; // reset depth and set ans[1] = 1, meaning this subtree now contains target\\n            res = Math.max(L[0], R[0]);\\n            return ans;\\n        }\\n        if (R[1]+L[1] >= 1){ // case 3\\n            ans[1] = 1;\\n            res = Math.max(res, L[0] + R[0]);\\n            ans[0] = R[1] == 1? R[0] : L[0]; // return the depth from current node to target and discard the other one.\\n        }else{ // case 2\\n            ans[0] = Math.max(R[0], L[0]);\\n        }\\n        ans[0]++; // increment depth\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456958,
                "title": "bfs-c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    \\n    TreeNode* mark_parent(TreeNode* root, int val,unordered_map<TreeNode*,TreeNode*>&parent){\\n        TreeNode* start=nullptr;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){ \\n            TreeNode* node=q.front();\\n            q.pop();\\n            //if we found the nide then simply return\\n            if(node->val==val){\\n                start=node;\\n            }\\n            \\n            //mark parent of left child\\n            if(node->left){\\n                parent[node->left]=node;\\n                q.push(node->left);\\n                \\n            }\\n            //mark parent of right child\\n             if(node->right){\\n                parent[node->right]=node;\\n                q.push(node->right);\\n            }\\n        }\\n        return start;\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n     \\n        //mark the parent of each node\\n        unordered_map<TreeNode*,TreeNode*>parent;\\n        \\n        //this will mark the parent of each node and return the address of starting node\\n        TreeNode* startNode=mark_parent(root,start,parent);\\n        \\n        //this will keep track of the node whitch are already infected\\n        unordered_map<TreeNode*,bool>visited;\\n        \\n        \\n        queue<TreeNode*>q;\\n        q.push(startNode);\\n        visited[startNode]=true;\\n        \\n        int time=0;\\n        \\n        //level ordered\\n        while(!q.empty()){\\n            int currSize=q.size();\\n            bool infect=false;\\n            \\n            //at one time all the node which are infected at the current level will infect all the adjacent nodes to them\\n            \\n            while(currSize--){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                \\n                //if left child exist and not infected then mark\\n                if(node->left and !visited[node->left]){\\n                    q.push(node->left);\\n                    visited[node->left]=true;\\n                    infect=true;\\n                }\\n                  //if right child exist and not infected then mark\\n                 if(node->right and !visited[node->right]){\\n                    q.push(node->right);\\n                    visited[node->right]=true;\\n                    infect=true;\\n                }\\n                  //if parent of current nodeexist and not infected then mark and push to queue for next process \\n                 if(parent[node] and !visited[parent[node]]){\\n                    q.push(parent[node]);\\n                    visited[parent[node]]=true;\\n                    infect=true;\\n                }\\n            }\\n            \\n            //time will only increase if any of the node at current level infected any of it\\'s adjacent node;\\n            if(infect) time++;\\n        } \\n    return time;   \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    \\n    TreeNode* mark_parent(TreeNode* root, int val,unordered_map<TreeNode*,TreeNode*>&parent){\\n        TreeNode* start=nullptr;\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){ \\n            TreeNode* node=q.front();\\n            q.pop();\\n            //if we found the nide then simply return\\n            if(node->val==val){\\n                start=node;\\n            }\\n            \\n            //mark parent of left child\\n            if(node->left){\\n                parent[node->left]=node;\\n                q.push(node->left);\\n                \\n            }\\n            //mark parent of right child\\n             if(node->right){\\n                parent[node->right]=node;\\n                q.push(node->right);\\n            }\\n        }\\n        return start;\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n     \\n        //mark the parent of each node\\n        unordered_map<TreeNode*,TreeNode*>parent;\\n        \\n        //this will mark the parent of each node and return the address of starting node\\n        TreeNode* startNode=mark_parent(root,start,parent);\\n        \\n        //this will keep track of the node whitch are already infected\\n        unordered_map<TreeNode*,bool>visited;\\n        \\n        \\n        queue<TreeNode*>q;\\n        q.push(startNode);\\n        visited[startNode]=true;\\n        \\n        int time=0;\\n        \\n        //level ordered\\n        while(!q.empty()){\\n            int currSize=q.size();\\n            bool infect=false;\\n            \\n            //at one time all the node which are infected at the current level will infect all the adjacent nodes to them\\n            \\n            while(currSize--){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                \\n                //if left child exist and not infected then mark\\n                if(node->left and !visited[node->left]){\\n                    q.push(node->left);\\n                    visited[node->left]=true;\\n                    infect=true;\\n                }\\n                  //if right child exist and not infected then mark\\n                 if(node->right and !visited[node->right]){\\n                    q.push(node->right);\\n                    visited[node->right]=true;\\n                    infect=true;\\n                }\\n                  //if parent of current nodeexist and not infected then mark and push to queue for next process \\n                 if(parent[node] and !visited[parent[node]]){\\n                    q.push(parent[node]);\\n                    visited[parent[node]]=true;\\n                    infect=true;\\n                }\\n            }\\n            \\n            //time will only increase if any of the node at current level infected any of it\\'s adjacent node;\\n            if(infect) time++;\\n        } \\n    return time;   \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456869,
                "title": "minimum-time-to-burn-tree-nodes-at-distance-k-from-target",
                "content": "Create a parents map using BFS and then again apply bfs, keeping in mind we can go three ways instead of two\\n\\n\\n```\\npublic int amountOfTime(TreeNode root, int target) {\\n        int ans = 0;\\n\\t\\tMap<TreeNode, TreeNode> parents = new HashMap<>();\\n\\t\\tTreeNode targetNode = findParents(parents, root, target);\\n\\t\\tif(targetNode == null)\\n\\t\\t\\treturn 0;\\n\\t\\tMap<TreeNode, Boolean> visited = new HashMap<>();\\n\\t\\tQueue<TreeNode> queue = new LinkedList<>();\\n\\t\\tqueue.offer(targetNode);\\n\\t\\tvisited.put(targetNode, true);\\n\\t\\twhile(!queue.isEmpty()) {\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\tboolean enqueued = false;\\n\\t\\t\\tfor(int i = 0; i < size; i++) {\\n\\t\\t\\t\\tTreeNode polled = queue.poll();\\n\\t\\t\\t\\tif(polled.left != null && !visited.containsKey(polled.left)) {\\n\\t\\t\\t\\t\\tenqueued = true;\\n\\t\\t\\t\\t\\tqueue.offer(polled.left);\\n\\t\\t\\t\\t\\tvisited.put(polled.left, true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(polled.right != null && !visited.containsKey(polled.right)) {\\n\\t\\t\\t\\t\\tenqueued = true;\\n\\t\\t\\t\\t\\tqueue.offer(polled.right);\\n\\t\\t\\t\\t\\tvisited.put(polled.right, true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(parents.containsKey(polled) && !visited.containsKey(parents.get(polled))) {\\n\\t\\t\\t\\t\\tenqueued = true;\\n\\t\\t\\t\\t\\tqueue.offer(parents.get(polled));\\n\\t\\t\\t\\t\\tvisited.put(parents.get(polled), true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(enqueued) ans++;\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n    \\n    private TreeNode findParents(Map<TreeNode, TreeNode> parents, TreeNode root, int target) {\\n\\t\\tif(root == null) return null;\\n\\t\\tQueue<TreeNode> queue = new LinkedList<>();\\n\\t\\tTreeNode targetNode = null;\\n\\t\\tqueue.offer(root);\\n\\t\\twhile(!queue.isEmpty()) {\\n\\t\\t\\tTreeNode polled = queue.poll();\\n\\t\\t\\tif(polled.val == target)\\n\\t\\t\\t\\ttargetNode = polled;\\n\\t\\t\\tif(polled.left != null) {\\n\\t\\t\\t\\tqueue.offer(polled.left);\\n\\t\\t\\t\\tparents.put(polled.left, polled);\\n\\t\\t\\t}\\n\\t\\t\\tif(polled.right != null) {\\n\\t\\t\\t\\tqueue.offer(polled.right);\\n\\t\\t\\t\\tparents.put(polled.right, polled);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn targetNode;\\n\\t\\t\\n\\t}",
                "solutionTags": [],
                "code": "Create a parents map using BFS and then again apply bfs, keeping in mind we can go three ways instead of two\\n\\n\\n```\\npublic int amountOfTime(TreeNode root, int target) {\\n        int ans = 0;\\n\\t\\tMap<TreeNode, TreeNode> parents = new HashMap<>();\\n\\t\\tTreeNode targetNode = findParents(parents, root, target);\\n\\t\\tif(targetNode == null)\\n\\t\\t\\treturn 0;\\n\\t\\tMap<TreeNode, Boolean> visited = new HashMap<>();\\n\\t\\tQueue<TreeNode> queue = new LinkedList<>();\\n\\t\\tqueue.offer(targetNode);\\n\\t\\tvisited.put(targetNode, true);\\n\\t\\twhile(!queue.isEmpty()) {\\n\\t\\t\\tint size = queue.size();\\n\\t\\t\\tboolean enqueued = false;\\n\\t\\t\\tfor(int i = 0; i < size; i++) {\\n\\t\\t\\t\\tTreeNode polled = queue.poll();\\n\\t\\t\\t\\tif(polled.left != null && !visited.containsKey(polled.left)) {\\n\\t\\t\\t\\t\\tenqueued = true;\\n\\t\\t\\t\\t\\tqueue.offer(polled.left);\\n\\t\\t\\t\\t\\tvisited.put(polled.left, true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(polled.right != null && !visited.containsKey(polled.right)) {\\n\\t\\t\\t\\t\\tenqueued = true;\\n\\t\\t\\t\\t\\tqueue.offer(polled.right);\\n\\t\\t\\t\\t\\tvisited.put(polled.right, true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(parents.containsKey(polled) && !visited.containsKey(parents.get(polled))) {\\n\\t\\t\\t\\t\\tenqueued = true;\\n\\t\\t\\t\\t\\tqueue.offer(parents.get(polled));\\n\\t\\t\\t\\t\\tvisited.put(parents.get(polled), true);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\t\\n\\t\\t\\tif(enqueued) ans++;\\n\\t\\t}\\n\\t\\treturn ans;\\n    }\\n    \\n    private TreeNode findParents(Map<TreeNode, TreeNode> parents, TreeNode root, int target) {\\n\\t\\tif(root == null) return null;\\n\\t\\tQueue<TreeNode> queue = new LinkedList<>();\\n\\t\\tTreeNode targetNode = null;\\n\\t\\tqueue.offer(root);\\n\\t\\twhile(!queue.isEmpty()) {\\n\\t\\t\\tTreeNode polled = queue.poll();\\n\\t\\t\\tif(polled.val == target)\\n\\t\\t\\t\\ttargetNode = polled;\\n\\t\\t\\tif(polled.left != null) {\\n\\t\\t\\t\\tqueue.offer(polled.left);\\n\\t\\t\\t\\tparents.put(polled.left, polled);\\n\\t\\t\\t}\\n\\t\\t\\tif(polled.right != null) {\\n\\t\\t\\t\\tqueue.offer(polled.right);\\n\\t\\t\\t\\tparents.put(polled.right, polled);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\treturn targetNode;\\n\\t\\t\\n\\t}",
                "codeTag": "Unknown"
            },
            {
                "id": 2456864,
                "title": "no-graph-conversion-o-1-space-o-n-time-no-bfs-tree-height-traversal",
                "content": "need to do height calculation at each node of tree.\\nwhile calculating height two params need to return.\\nht -> height of tree\\ndist -> dist of the start node from curr node.\\nif dist is -1, it means start not exist in subtree rooted from curr node.\\n\\n```\\nstruct obj{\\n    int ht, dist;\\n    obj(): ht(0), dist(-1) {}\\n};\\nclass Solution {\\n    int ans = -1;\\npublic:\\n    obj dfs(TreeNode* root, int & start){\\n        obj ret = obj();\\n        if(root == nullptr) return ret;\\n        \\n        obj l, r;\\n        l = dfs(root->left, start);\\n        r = dfs(root->right, start);\\n        \\n        ret.ht = max(l.ht, r.ht) + 1;\\n        \\n        if(l.dist>0){//if start present in left subtree, then ans can be time to reach from start node to curr node + from curr node to its right subtree.\\n            ans = max(ans, l.dist + r.ht);\\n            ret.dist = l.dist + 1;\\n        }else if(r.dist>0){//if start present in right subtree, then ans can be time to reach from start node to curr node + from curr node to its left subtree.\\n            ans = max(ans, r.dist + l.ht);\\n            ret.dist = r.dist +1;\\n        }else if(root->val == start){//if curr node is the start node, then max of left and right subtree height can be answer.\\n            ans = max(ans, max(l.ht, r.ht));\\n            ret.dist = 1;\\n        }\\n        // else{ret.dist = -1;} obj constructor handling it.\\n        \\n        return ret;\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        dfs(root, start);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Tree"
                ],
                "code": "```\\nstruct obj{\\n    int ht, dist;\\n    obj(): ht(0), dist(-1) {}\\n};\\nclass Solution {\\n    int ans = -1;\\npublic:\\n    obj dfs(TreeNode* root, int & start){\\n        obj ret = obj();\\n        if(root == nullptr) return ret;\\n        \\n        obj l, r;\\n        l = dfs(root->left, start);\\n        r = dfs(root->right, start);\\n        \\n        ret.ht = max(l.ht, r.ht) + 1;\\n        \\n        if(l.dist>0){//if start present in left subtree, then ans can be time to reach from start node to curr node + from curr node to its right subtree.\\n            ans = max(ans, l.dist + r.ht);\\n            ret.dist = l.dist + 1;\\n        }else if(r.dist>0){//if start present in right subtree, then ans can be time to reach from start node to curr node + from curr node to its left subtree.\\n            ans = max(ans, r.dist + l.ht);\\n            ret.dist = r.dist +1;\\n        }else if(root->val == start){//if curr node is the start node, then max of left and right subtree height can be answer.\\n            ans = max(ans, max(l.ht, r.ht));\\n            ret.dist = 1;\\n        }\\n        // else{ret.dist = -1;} obj constructor handling it.\\n        \\n        return ret;\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        dfs(root, start);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456810,
                "title": "map-child-parent-map-the-parents-to-traverse-upwards-c",
                "content": "```\\nclass Solution {\\npublic:\\n    TreeNode* s = NULL;\\n    int start = 0;\\n    void solve(unordered_map<TreeNode*, TreeNode*> &par, TreeNode* root){\\n        if(root==NULL) return;\\n        if(root->left){\\n            par[root->left] = root;\\n        }\\n        if(root->right){\\n            par[root->right] = root;\\n        }\\n        if(root->val==start){\\n            s = root;\\n        }\\n        solve(par, root->left);\\n        solve(par, root->right);\\n    }\\n    int amountOfTime(TreeNode* root, int st) {\\n        if(root==NULL) return 0;\\n        unordered_map<TreeNode*, TreeNode*> par;\\n        unordered_set<TreeNode*> vis;\\n        start = st;\\n        solve(par, root);\\n        queue<TreeNode*> q;\\n        q.push(s);\\n        vis.insert(s);\\n        int time = 0;\\n        while(!q.empty()){\\n            int n = q.size();\\n            for(int i = 0; i<n; i++){\\n                auto t = q.front();\\n                q.pop();\\n                if(t->left and vis.find(t->left)==vis.end()){\\n                    vis.insert(t->left);\\n                    q.push(t->left);\\n                }\\n                if(t->right and vis.find(t->right)==vis.end()){\\n                    vis.insert(t->right);\\n                    q.push(t->right);\\n                }\\n                if(par[t] and vis.find(par[t])==vis.end()){\\n                    vis.insert(par[t]);\\n                    q.push(par[t]);\\n                }\\n            }\\n            time++;\\n        }\\n        return time-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* s = NULL;\\n    int start = 0;\\n    void solve(unordered_map<TreeNode*, TreeNode*> &par, TreeNode* root){\\n        if(root==NULL) return;\\n        if(root->left){\\n            par[root->left] = root;\\n        }\\n        if(root->right){\\n            par[root->right] = root;\\n        }\\n        if(root->val==start){\\n            s = root;\\n        }\\n        solve(par, root->left);\\n        solve(par, root->right);\\n    }\\n    int amountOfTime(TreeNode* root, int st) {\\n        if(root==NULL) return 0;\\n        unordered_map<TreeNode*, TreeNode*> par;\\n        unordered_set<TreeNode*> vis;\\n        start = st;\\n        solve(par, root);\\n        queue<TreeNode*> q;\\n        q.push(s);\\n        vis.insert(s);\\n        int time = 0;\\n        while(!q.empty()){\\n            int n = q.size();\\n            for(int i = 0; i<n; i++){\\n                auto t = q.front();\\n                q.pop();\\n                if(t->left and vis.find(t->left)==vis.end()){\\n                    vis.insert(t->left);\\n                    q.push(t->left);\\n                }\\n                if(t->right and vis.find(t->right)==vis.end()){\\n                    vis.insert(t->right);\\n                    q.push(t->right);\\n                }\\n                if(par[t] and vis.find(par[t])==vis.end()){\\n                    vis.insert(par[t]);\\n                    q.push(par[t]);\\n                }\\n            }\\n            time++;\\n        }\\n        return time-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456783,
                "title": "java-solution-bsf-hashmap",
                "content": "```\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        \\n        Map<TreeNode, TreeNode> map = new HashMap<>();\\n        findPar(map, root);\\n        Set<TreeNode> vis = new HashSet<>();\\n        \\n        LinkedList<TreeNode> q = new LinkedList<>();\\n        TreeNode node = findNode(root, start);\\n        \\n        q.add(node);\\n        vis.add(node);\\n        \\n        int time = 0;\\n        \\n        while(!q.isEmpty()){\\n            \\n            int sz = q.size();\\n            while(sz-- > 0){\\n                TreeNode curr = q.poll();\\n                \\n                if(map.containsKey(curr) && !vis.contains(map.get(curr))) {\\n                    q.add(map.get(curr));\\n                    vis.add(map.get(curr));\\n                }\\n                \\n                \\n                if(curr.left != null && !vis.contains(curr.left)){\\n                    q.add(curr.left);\\n                    vis.add(curr.left);\\n                }\\n                if(curr.right != null && !vis.contains(curr.right)){\\n                    q.add(curr.right);\\n                    vis.add(curr.right);\\n                }\\n            }\\n            time++;\\n        }\\n        \\n        return time-1;\\n    }\\n    private void findPar(Map<TreeNode, TreeNode> map, TreeNode root){\\n        \\n        if(root == null) return;\\n        \\n        if(root.left != null){\\n            map.put(root.left, root);\\n             \\n        }\\n        if(root.right != null){\\n            map.put(root.right, root);\\n            \\n        }\\n        // System.out.print(\"yes. \");\\n        findPar(map, root.left);\\n        findPar(map, root.right);\\n    }\\n    \\n    private TreeNode findNode(TreeNode root, int tar){\\n        if(root == null) return null;\\n        \\n        if(root.val == tar) return root;\\n        \\n        TreeNode left = findNode(root.left, tar);\\n        TreeNode right = findNode(root.right, tar);\\n        \\n        return (left == null ) ? right : left;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        \\n        Map<TreeNode, TreeNode> map = new HashMap<>();\\n        findPar(map, root);\\n        Set<TreeNode> vis = new HashSet<>();\\n        \\n        LinkedList<TreeNode> q = new LinkedList<>();\\n        TreeNode node = findNode(root, start);\\n        \\n        q.add(node);\\n        vis.add(node);\\n        \\n        int time = 0;\\n        \\n        while(!q.isEmpty()){\\n            \\n            int sz = q.size();\\n            while(sz-- > 0){\\n                TreeNode curr = q.poll();\\n                \\n                if(map.containsKey(curr) && !vis.contains(map.get(curr))) {\\n                    q.add(map.get(curr));\\n                    vis.add(map.get(curr));\\n                }\\n                \\n                \\n                if(curr.left != null && !vis.contains(curr.left)){\\n                    q.add(curr.left);\\n                    vis.add(curr.left);\\n                }\\n                if(curr.right != null && !vis.contains(curr.right)){\\n                    q.add(curr.right);\\n                    vis.add(curr.right);\\n                }\\n            }\\n            time++;\\n        }\\n        \\n        return time-1;\\n    }\\n    private void findPar(Map<TreeNode, TreeNode> map, TreeNode root){\\n        \\n        if(root == null) return;\\n        \\n        if(root.left != null){\\n            map.put(root.left, root);\\n             \\n        }\\n        if(root.right != null){\\n            map.put(root.right, root);\\n            \\n        }\\n        // System.out.print(\"yes. \");\\n        findPar(map, root.left);\\n        findPar(map, root.right);\\n    }\\n    \\n    private TreeNode findNode(TreeNode root, int tar){\\n        if(root == null) return null;\\n        \\n        if(root.val == tar) return root;\\n        \\n        TreeNode left = findNode(root.left, tar);\\n        TreeNode right = findNode(root.right, tar);\\n        \\n        return (left == null ) ? right : left;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456772,
                "title": "c",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\npublic class Solution\\n{\\n    public static int FindBurningAmount(TreeNode root, int num, Dictionary<int, HashSet<int>> answerSet)\\n    {\\n        if (root != null)\\n        {\\n            if (root.val == num)\\n            {\\n                StoreTheNumbers(root.left, 1, answerSet);\\n                StoreTheNumbers(root.right, 1, answerSet);\\n                return 1;\\n            }\\n            int k = FindBurningAmount(root.left, num, answerSet);\\n            if (k > 0)\\n            {\\n                SaveData(root, k, answerSet);\\n                StoreTheNumbers(root.right, k + 1, answerSet);\\n                return k + 1;\\n            }\\n            k = FindBurningAmount(root.right, num, answerSet);\\n            if (k > 0)\\n            {\\n                SaveData(root, k, answerSet);\\n                StoreTheNumbers(root.left, k + 1, answerSet);\\n                return k + 1;\\n            }\\n        }\\n        return -1;\\n    }\\n    public static void StoreTheNumbers(TreeNode root, int k, Dictionary<int, HashSet<int>> answerSet)\\n    {\\n        if (root != null)\\n        {\\n            SaveData(root, k, answerSet);\\n            StoreTheNumbers(root.left, k + 1, answerSet);\\n            StoreTheNumbers(root.right, k + 1, answerSet);\\n        }\\n    }\\n    private static void SaveData(TreeNode root, int k, Dictionary<int, HashSet<int>> answerSet)\\n    {\\n        if (answerSet.ContainsKey(k))\\n        {\\n            answerSet[k].Add(root.val);\\n        }\\n        else\\n        {\\n            HashSet<int> dataSet = new HashSet<int>();\\n            dataSet.Add(root.val);\\n            answerSet.Add(k, dataSet);\\n        }\\n    }\\n    static Dictionary<TreeNode, List<TreeNode>> map = new Dictionary<TreeNode, List<TreeNode>>();\\n    public int AmountOfTime(TreeNode root, int start)\\n    {\\n        Dictionary<int, HashSet<int>> answerSet   = new Dictionary<int, HashSet<int>>();\\n        FindBurningAmount(root, start, answerSet);\\n        return answerSet.Count;\\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution\\n{\\n    public static int FindBurningAmount(TreeNode root, int num, Dictionary<int, HashSet<int>> answerSet)\\n    {\\n        if (root != null)\\n        {\\n            if (root.val == num)\\n            {\\n                StoreTheNumbers(root.left, 1, answerSet);\\n                StoreTheNumbers(root.right, 1, answerSet);\\n                return 1;\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 2456736,
                "title": "java-solution",
                "content": "````java\\nclass Triplet{\\n    int max, above, below;\\n    Triplet(int max, int above, int below) {\\n        this.max = max;\\n        this.above = above;\\n        this.below = below;\\n    }\\n}\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        Triplet ans = fun(root, start);\\n        return ans.max;\\n    }\\n    public static Triplet fun(TreeNode root, int start) {\\n        if (root == null) {\\n            return new Triplet(-1, -1, 0);\\n        }\\n        Triplet left = fun(root.left, start);\\n        Triplet right = fun(root.right, start);\\n        Triplet ans = new Triplet(-1, -1, 0);\\n        // Node is the starting node\\n        if (root.val == start) {\\n            int below = Math.max(left.below, right.below);\\n            ans.max = below;\\n            ans.above = 0;\\n            ans.below = below;\\n        }\\n        // Starting Node is in left subtree\\n        else if (left.above != -1) {\\n            ans.max = Math.max(left.max, Math.max(left.below, left.above + right.below + 1));\\n            ans.above = left.above + 1;\\n            ans.below = left.below;\\n        }\\n        // Starting Node is in right subtree\\n        else if (right.above != -1) {\\n            ans.max = Math.max(right.max, Math.max(right.below, right.above + left.below + 1));\\n            ans.above = right.above + 1;\\n            ans.below = right.below;\\n        }\\n        // Starting Node doesn\\'t exist in the subtree\\n        else {\\n            ans.max = -1;\\n            ans.above = -1;\\n            ans.below = Math.max(left.below, right.below) + 1;\\n        }\\n        return ans;\\n    }\\n}",
                "solutionTags": [
                    "Tree",
                    "Breadth-First Search",
                    "Graph",
                    "Queue"
                ],
                "code": "class Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        Triplet ans = fun(root, start);\\n        return ans.max;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2456688,
                "title": "cpp-dfs-bfs",
                "content": "\\n```\\n\\nclass Solution {\\npublic:\\n    map<int, TreeNode*>mpp;\\n    void checker(TreeNode*root){\\n        if(!root){\\n            return ;\\n        }\\n        if(root->left!=NULL ){\\n            mpp[root->left->val]=root;\\n        }\\n        if(root->right!=NULL){\\n            mpp[root->right->val]=root;\\n        }\\n        checker(root->left);\\n        checker(root->right);\\n        return ;\\n    }\\n    map<int,TreeNode*>mpp1;\\n    void checker1(TreeNode*root){\\n        if(!root){\\n            return ;\\n        }\\n        mpp1[root->val]=root;\\n        checker1(root->left);\\n        checker1(root->right);\\n        \\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        checker(root);\\n        checker1(root);\\n        queue<TreeNode*>q;\\n        q.push(mpp1[start]);\\n        int cnt =0 ;\\n        map<int,int>vis;\\n        while(!q.empty()){\\n            int s = q.size();\\n            for(int i=0; i<s ; i++){\\n                 TreeNode* curr = q.front();\\n                 q.pop();\\n                 \\n                 if(!curr){\\n                     continue;\\n                 }\\n                 // cout<<curr->val<<\" \";\\n                 if(vis[curr->val]==1){\\n                     continue;\\n                 }\\n                 vis[curr->val]=1;\\n                 TreeNode* par = mpp[curr->val];\\n                 \\n                 if(par  && vis[par->val]!=1){\\n                   // cout<<vis[par->val]<<\"p\"<<\" \";\\n                   q.push(par);\\n                     \\n                 }\\n                  if(curr->left!=NULL && vis[curr->left->val]!=1){\\n                      q.push(curr->left);\\n                  }\\n                if(curr->right!=NULL && vis[curr->right->val]!=1){\\n                    q.push(curr->right);\\n                }\\n            }\\n            // cout<<endl;\\n            cnt++;\\n        }\\n        return cnt-1; \\n        \\n        \\n        \\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    map<int, TreeNode*>mpp;\\n    void checker(TreeNode*root){\\n        if(!root){\\n            return ;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2456683,
                "title": "refer-striver-s-tree-series-lec-31-o-n",
                "content": "**Please Upvote If it Helped : )**\\nYou Could Refer Striver\\'s Tree Series Lecture 31 for a detailed explanation\\n**Link:** https://www.youtube.com/watch?v=2r5wLmQfD6g&list=PLgUwDviBIf0q8Hkd7bK2Bpryj2xVJk8Vk&index=33&ab_channel=takeUforward\\n\\n1) We Traverse Tree to find start value node,and also store parent node for each node in a map. in the map.\\n2) We Use queue & map to traverse & find node infected every second and push them into the queue.\\n\\n\\n**Time Complexity: O(N)\\nSpace Complexity: O(N)\\nCode:**\\n```\\nclass Solution {\\n    // to find minimum time to infect the tree\\n    int findMin(unordered_map<TreeNode*,TreeNode*> &m,TreeNode* target){\\n        queue<TreeNode*> q;\\n        q.push(target);\\n        unordered_map<TreeNode*,int> vis;\\n        vis[target]=1;\\n        int mini=0;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            bool flag=false;\\n            for(int i=0;i<sz;++i){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                // visit node->left if it exists and isn\\'t visited\\n                if(node->left&&!vis[node->left]){\\n                    vis[node->left]=1;\\n                    flag=true;\\n                    q.push(node->left);\\n                }\\n                // visit node->left if it exists and isn\\'t visited\\n                if(node->right&&!vis[node->right]){\\n                    vis[node->right]=1;\\n                    flag=true;\\n                    q.push(node->right);\\n                }\\n                // visit node->parent(using map) if it exists and isn\\'t visited\\n                if(m[node]&&!vis[m[node]]){\\n                    vis[m[node]]=1;\\n                    flag=true;\\n                    q.push(m[node]);\\n                }\\n            }\\n            // if any of the node is infected in this visit update mini;\\n            if(flag) mini++;\\n        }\\n        return mini;\\n    }\\n    // To Map Parent Elements of a node\\n    TreeNode* mapParents(TreeNode* root,unordered_map<TreeNode*,TreeNode*> &m,int start){\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        TreeNode* res;\\n        while(!q.empty()){\\n            TreeNode* node=q.front();\\n            q.pop();\\n            // store start value node in res\\n            if(node->val==start) res=node;\\n            if(node->left){\\n                m[node->left]=node;\\n                q.push(node->left);\\n            }\\n            if(node->right){\\n                m[node->right]=node;\\n                q.push(node->right);\\n            }\\n        }\\n        return res;\\n    }\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<TreeNode*,TreeNode*> m;\\n        TreeNode* target=mapParents(root,m,start);\\n        return findMin(m,target);\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "class Solution {\\n    // to find minimum time to infect the tree\\n    int findMin(unordered_map<TreeNode*,TreeNode*> &m,TreeNode* target){\\n        queue<TreeNode*> q;\\n        q.push(target);\\n        unordered_map<TreeNode*,int> vis;\\n        vis[target]=1;\\n        int mini=0;\\n        while(!q.empty()){\\n            int sz=q.size();\\n            bool flag=false;\\n            for(int i=0;i<sz;++i){\\n                TreeNode* node=q.front();\\n                q.pop();\\n                // visit node->left if it exists and isn\\'t visited\\n                if(node->left&&!vis[node->left]){\\n                    vis[node->left]=1;\\n                    flag=true;\\n                    q.push(node->left);\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 2456661,
                "title": "java-simple-solution",
                "content": "```\\nclass Solution {\\n    TreeNode target;\\n    public int amountOfTime(TreeNode root, int start) {\\n        Map<TreeNode,TreeNode> parents=new HashMap<>();\\n        getParents(root,null,parents);\\n        findNode(root,start);\\n        Set<TreeNode> visited= new HashSet<>();\\n        int x=helper(target,parents,visited);\\n        return --x;\\n    }\\n    private int helper(TreeNode curr,Map<TreeNode,TreeNode> map,Set<TreeNode> visited){\\n        if(curr==null && visited.contains(curr))\\n            return 0;\\n        visited.add(curr);\\n        int left= curr.left==null || visited.contains(curr.left)? 0 :helper(curr.left,map,visited);\\n        int right= curr.right==null || visited.contains(curr.right)? 0:helper(curr.right,map,visited);\\n        int parent= map.get(curr)==null || visited.contains(map.get(curr)) ?0:helper(map.get(curr),map,visited);\\n        \\n        return 1+   Math.max(left,Math.max(right,parent));\\n        \\n    }\\n    private void findNode(TreeNode curr,int start){\\n        if(curr==null)\\n            return;\\n        if(curr.val==start)\\n            target=curr;\\n        findNode(curr.left,start);\\n        findNode(curr.right,start);\\n    }\\n    private void getParents(TreeNode curr,TreeNode parent,Map<TreeNode,TreeNode> map){\\n        if(curr==null)\\n            return;\\n        if(!map.containsKey(curr))\\n            map.put(curr,parent);\\n        getParents(curr.left,curr,map);\\n        getParents(curr.right,curr,map);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Interactive"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode target;\\n    public int amountOfTime(TreeNode root, int start) {\\n        Map<TreeNode,TreeNode> parents=new HashMap<>();\\n        getParents(root,null,parents);\\n        findNode(root,start);\\n        Set<TreeNode> visited= new HashSet<>();\\n        int x=helper(target,parents,visited);\\n        return --x;\\n    }\\n    private int helper(TreeNode curr,Map<TreeNode,TreeNode> map,Set<TreeNode> visited){\\n        if(curr==null && visited.contains(curr))\\n            return 0;\\n        visited.add(curr);\\n        int left= curr.left==null || visited.contains(curr.left)? 0 :helper(curr.left,map,visited);\\n        int right= curr.right==null || visited.contains(curr.right)? 0:helper(curr.right,map,visited);\\n        int parent= map.get(curr)==null || visited.contains(map.get(curr)) ?0:helper(map.get(curr),map,visited);\\n        \\n        return 1+   Math.max(left,Math.max(right,parent));\\n        \\n    }\\n    private void findNode(TreeNode curr,int start){\\n        if(curr==null)\\n            return;\\n        if(curr.val==start)\\n            target=curr;\\n        findNode(curr.left,start);\\n        findNode(curr.right,start);\\n    }\\n    private void getParents(TreeNode curr,TreeNode parent,Map<TreeNode,TreeNode> map){\\n        if(curr==null)\\n            return;\\n        if(!map.containsKey(curr))\\n            map.put(curr,parent);\\n        getParents(curr.left,curr,map);\\n        getParents(curr.right,curr,map);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2456642,
                "title": "c-bfs-easy-explanation",
                "content": "\\t//  step-1 : first we are filling the parent of each node in a parent map ( because it will be needed while going up into the tree)\\n\\t//  step-2 : then we are finding the start node in  the tree and pushing that into queue \\n\\t//  step-3 : also creating visited map for rembering visited nodes\\n\\t//\\tstep-4 : then doing a simple bfs to find out time \\n\\t//\\tstep-5 : after each step of bfs we are increasing the time counter because at each time virus will spread to end nodes by one step only\\n\\n\\tvoid fillparent(TreeNode* node,map<TreeNode*,TreeNode*> &parent,TreeNode* par)         //for finding and putting parent of each node by passing current node to their child nodes\\n    {\\n        if(!node     return;\\n       \\n        parent[node] = par;                       //assinging parent to the node\\n        fillparent(node->left,parent,node);\\n        fillparent(node->right,parent,node);        \\n    }\\n    \\n    bool fillq(queue<TreeNode*> &q,int start,TreeNode* root)         //for finding the start node and pushing it into the queue\\n    {\\n        if(!root)      return false;\\n        \\n        if(root->val == start)\\n        {\\n            q.push(root);\\n            return true;\\n        }\\n        if(fillq(q,start,root->left) || fillq(q,start,root->right))            // if start node is pushed then break the dfs call and return true else return false \\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    int bfs(map<TreeNode*,TreeNode*> parent,TreeNode* root,int start)\\n    {\\n        map<TreeNode*,int> vis;\\n        queue<TreeNode*> q;\\n        fillq(q,start,root);                                       //calling fillq for pushing start into the queue\\n        int t=0;\\n        auto n = q.front();\\n        vis[n]=1;                                                    //marking start to visited\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                auto nd = q.front();\\n                q.pop();\\n                if(nd->left != NULL && vis.find(nd->left)==vis.end())         //checking for left child node and if not visited pushing into the queue\\n                {\\n                    vis[nd->left]=1;\\n                    q.push(nd->left);\\n                }\\n                if(nd->right != NULL && vis.find(nd->right)==vis.end())         //checking for right child node and if not visited pushing into the queue\\n                {\\n                    vis[nd->right]=1;\\n                    q.push(nd->right);\\n                }\\n                if(parent[nd] != NULL && vis.find(parent[nd])==vis.end())         //checking for parent node and if not visited pushing into the queue\\n                {\\n                    vis[parent[nd]]=1;\\n                    q.push(parent[nd]);\\n                }                \\n            }\\n            t++;                            // increasing time after each step of virus spreading\\n        }\\n        \\n        return t-1;                          // for target node time will always be 0 so returning t-1\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) \\n    {\\n        map<TreeNode*,TreeNode*> parent;        \\n\\t\\tfillparent(root,parent,NULL);\\n        return bfs(parent,root,start);\\n    }",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "\\t//  step-1 : first we are filling the parent of each node in a parent map ( because it will be needed while going up into the tree)\\n\\t//  step-2 : then we are finding the start node in  the tree and pushing that into queue \\n\\t//  step-3 : also creating visited map for rembering visited nodes\\n\\t//\\tstep-4 : then doing a simple bfs to find out time \\n\\t//\\tstep-5 : after each step of bfs we are increasing the time counter because at each time virus will spread to end nodes by one step only\\n\\n\\tvoid fillparent(TreeNode* node,map<TreeNode*,TreeNode*> &parent,TreeNode* par)         //for finding and putting parent of each node by passing current node to their child nodes\\n    {\\n        if(!node     return;\\n       \\n        parent[node] = par;                       //assinging parent to the node\\n        fillparent(node->left,parent,node);\\n        fillparent(node->right,parent,node);        \\n    }\\n    \\n    bool fillq(queue<TreeNode*> &q,int start,TreeNode* root)         //for finding the start node and pushing it into the queue\\n    {\\n        if(!root)      return false;\\n        \\n        if(root->val == start)\\n        {\\n            q.push(root);\\n            return true;\\n        }\\n        if(fillq(q,start,root->left) || fillq(q,start,root->right))            // if start node is pushed then break the dfs call and return true else return false \\n            return true;\\n        \\n        return false;\\n    }\\n    \\n    int bfs(map<TreeNode*,TreeNode*> parent,TreeNode* root,int start)\\n    {\\n        map<TreeNode*,int> vis;\\n        queue<TreeNode*> q;\\n        fillq(q,start,root);                                       //calling fillq for pushing start into the queue\\n        int t=0;\\n        auto n = q.front();\\n        vis[n]=1;                                                    //marking start to visited\\n        \\n        while(!q.empty())\\n        {\\n            int size = q.size();\\n            for(int i=0;i<size;i++)\\n            {\\n                auto nd = q.front();\\n                q.pop();\\n                if(nd->left != NULL && vis.find(nd->left)==vis.end())         //checking for left child node and if not visited pushing into the queue\\n                {\\n                    vis[nd->left]=1;\\n                    q.push(nd->left);\\n                }\\n                if(nd->right != NULL && vis.find(nd->right)==vis.end())         //checking for right child node and if not visited pushing into the queue\\n                {\\n                    vis[nd->right]=1;\\n                    q.push(nd->right);\\n                }\\n                if(parent[nd] != NULL && vis.find(parent[nd])==vis.end())         //checking for parent node and if not visited pushing into the queue\\n                {\\n                    vis[parent[nd]]=1;\\n                    q.push(parent[nd]);\\n                }                \\n            }\\n            t++;                            // increasing time after each step of virus spreading\\n        }\\n        \\n        return t-1;                          // for target node time will always be 0 so returning t-1\\n    }\\n    \\n    int amountOfTime(TreeNode* root, int start) \\n    {\\n        map<TreeNode*,TreeNode*> parent;        \\n\\t\\tfillparent(root,parent,NULL);\\n        return bfs(parent,root,start);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2456608,
                "title": "python-dfs-bfs-o-n-solution",
                "content": "```python\\nfrom collections import deque, defaultdict\\nclass Solution:\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n        # go through entire tree with depth first search to \\n        # easily keep track of relationship between nodes\\n        def dfs(prev, curr):\\n            if prev: graph[curr.val].append(prev.val)\\n            if curr.left:\\n                graph[curr.val].append(curr.left.val)\\n                dfs(curr, curr.left)\\n            if curr.right:\\n                graph[curr.val].append(curr.right.val)\\n                dfs(curr, curr.right)\\n        \\n        # build undirected graph from the tree with depth first search\\n        graph = defaultdict(list)\\n        dfs(None, root)\\n        \\n        # go through entire graph with breath first search to count\\n        # how long it\\'ll take to infect all the nodes\\n        ans = -1\\n        queue, visited = deque([start]), set([start])\\n        while queue:\\n            ans += 1\\n            lvsize = len(queue)\\n            for _ in range(lvsize):\\n                node = queue.popleft()\\n                for neigh in graph[node]:\\n                    if neigh not in visited:\\n                        queue.append(neigh)\\n                        visited.add(neigh)\\n        return ans\\n",
                "solutionTags": [
                    "Python",
                    "Tree",
                    "Depth-First Search",
                    "Breadth-First Search",
                    "Graph"
                ],
                "code": "```python\\nfrom collections import deque, defaultdict\\nclass Solution:\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n        # go through entire tree with depth first search to \\n        # easily keep track of relationship between nodes\\n        def dfs(prev, curr):\\n            if prev: graph[curr.val].append(prev.val)\\n            if curr.left:\\n                graph[curr.val].append(curr.left.val)\\n                dfs(curr, curr.left)\\n            if curr.right:\\n                graph[curr.val].append(curr.right.val)\\n                dfs(curr, curr.right)\\n        \\n        # build undirected graph from the tree with depth first search\\n        graph = defaultdict(list)\\n        dfs(None, root)\\n        \\n        # go through entire graph with breath first search to count\\n        # how long it\\'ll take to infect all the nodes\\n        ans = -1\\n        queue, visited = deque([start]), set([start])\\n        while queue:\\n            ans += 1\\n            lvsize = len(queue)\\n            for _ in range(lvsize):\\n                node = queue.popleft()\\n                for neigh in graph[node]:\\n                    if neigh not in visited:\\n                        queue.append(neigh)\\n                        visited.add(neigh)\\n        return ans\\n",
                "codeTag": "Java"
            },
            {
                "id": 2456602,
                "title": "c-bfs-tree-easy-solution",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    map<TreeNode* , TreeNode*> childparent;\\n    map<TreeNode* , bool> visited;\\n  \\n  TreeNode* mynode=NULL;\\n  \\n  int time=0;\\n  \\n    //maps parent of child\\n  TreeNode* mapParentChild(TreeNode* root){\\n      if(root==NULL)return NULL;\\n      \\n      TreeNode* left=mapParentChild(root->left);\\n      TreeNode* right=mapParentChild(root->right);\\n      \\n      if(left!=NULL)childparent[left]=root;\\n      if(right!=NULL)childparent[right]=root;\\n      \\n      return root;\\n  }\\n    \\n    //to find given node\\n     TreeNode* getNode(TreeNode* root,int target){\\n      if(root==NULL)return NULL;\\n      if(root->val==target){\\n          mynode=root;\\n      }\\n      getNode(root->left,target);\\n      getNode(root->right,target);\\n      \\n      return root;\\n  }\\n    \\n    //bfs method on left right and parent i.e neighbours of the treenode and calculate time\\n     void burnTree(TreeNode* root){\\n      queue<TreeNode*> q;\\n      q.push(root);\\n      visited[root]=true;\\n      \\n      while(!q.empty()){\\n          int size=q.size();\\n          int flag=false;\\n          for(int i=0;i<size;i++){\\n             \\n          TreeNode* t=q.front();\\n          q.pop();\\n        //   cout<<t->data<<\" \"<<time<<endl;\\n          if(t->left && !visited.count(t->left)){\\n              q.push(t->left);\\n              visited[t->left]=true;\\n              flag=true;\\n          }\\n          if(t->right && !visited.count(t->right)){\\n              q.push(t->right);\\n              visited[t->right]=true;\\n              flag=true;\\n          }\\n          if(childparent.count(t) && !visited.count(childparent[t])){\\n              q.push(childparent[t]);\\n              visited[childparent[t]]=true;\\n              flag=true;\\n          }\\n         \\n          }\\n           if(flag)time++; \\n          \\n      }\\n      \\n   }\\n  \\n  \\n    int amountOfTime(TreeNode* root, int target) {\\n         mapParentChild(root);\\n        getNode(root,target);\\n        burnTree(mynode);\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    map<TreeNode* , TreeNode*> childparent;\\n    map<TreeNode* , bool> visited;\\n  \\n  TreeNode* mynode=NULL;\\n  \\n  int time=0;\\n  \\n    //maps parent of child\\n  TreeNode* mapParentChild(TreeNode* root){\\n      if(root==NULL)return NULL;\\n      \\n      TreeNode* left=mapParentChild(root->left);\\n      TreeNode* right=mapParentChild(root->right);\\n      \\n      if(left!=NULL)childparent[left]=root;\\n      if(right!=NULL)childparent[right]=root;\\n      \\n      return root;\\n  }\\n    \\n    //to find given node\\n     TreeNode* getNode(TreeNode* root,int target){\\n      if(root==NULL)return NULL;\\n      if(root->val==target){\\n          mynode=root;\\n      }\\n      getNode(root->left,target);\\n      getNode(root->right,target);\\n      \\n      return root;\\n  }\\n    \\n    //bfs method on left right and parent i.e neighbours of the treenode and calculate time\\n     void burnTree(TreeNode* root){\\n      queue<TreeNode*> q;\\n      q.push(root);\\n      visited[root]=true;\\n      \\n      while(!q.empty()){\\n          int size=q.size();\\n          int flag=false;\\n          for(int i=0;i<size;i++){\\n             \\n          TreeNode* t=q.front();\\n          q.pop();\\n        //   cout<<t->data<<\" \"<<time<<endl;\\n          if(t->left && !visited.count(t->left)){\\n              q.push(t->left);\\n              visited[t->left]=true;\\n              flag=true;\\n          }\\n          if(t->right && !visited.count(t->right)){\\n              q.push(t->right);\\n              visited[t->right]=true;\\n              flag=true;\\n          }\\n          if(childparent.count(t) && !visited.count(childparent[t])){\\n              q.push(childparent[t]);\\n              visited[childparent[t]]=true;\\n              flag=true;\\n          }\\n         \\n          }\\n           if(flag)time++; \\n          \\n      }\\n      \\n   }\\n  \\n  \\n    int amountOfTime(TreeNode* root, int target) {\\n         mapParentChild(root);\\n        getNode(root,target);\\n        burnTree(mynode);\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2456600,
                "title": "bfs-java-graph-solution",
                "content": "```\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        dfs(root, -1, graph);\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(start);\\n        int count = 0;\\n        Set<Integer> set = new HashSet<>();\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();            \\n            for (int i = 0; i < size; i++) {\\n                int value = queue.poll();\\n                List<Integer> neighbors = graph.get(value);\\n                if (neighbors == null) {\\n                    continue;\\n                }\\n                for (int neighbor : neighbors) {\\n                    if (set.contains(neighbor)) {\\n                        continue;\\n                    }\\n                    queue.offer(neighbor);\\n                    set.add(value);\\n                }\\n            }\\n            count++;\\n        }\\n        return count - 1;\\n    }\\n    public void dfs(TreeNode root, int parentValue, Map<Integer, List<Integer>> graph) {\\n        if (root == null) {\\n            return;\\n        }   \\n        int rootValue = root.val;\\n        if (parentValue == -1) {\\n            dfs(root.left, rootValue, graph);\\n            dfs(root.right, rootValue, graph);\\n            return;\\n        }   \\n        if (graph.containsKey(rootValue)) {\\n            List<Integer> list = graph.get(rootValue);\\n            list.add(parentValue);\\n            graph.put(rootValue, list);\\n        } else {\\n            List<Integer> list = new ArrayList<>();\\n            list.add(parentValue);\\n            graph.put(rootValue, list);\\n        }\\n        if (graph.containsKey(parentValue)) {\\n            List<Integer> list = graph.get(parentValue);\\n            list.add(rootValue);\\n            graph.put(parentValue, list);\\n        } else {\\n            List<Integer> list = new ArrayList<>();\\n            list.add(rootValue);\\n            graph.put(parentValue, list);\\n        }\\n        dfs(root.left, rootValue, graph);\\n        dfs(root.right, rootValue, graph);\\n        return;\\n    } \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Breadth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        dfs(root, -1, graph);\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(start);\\n        int count = 0;\\n        Set<Integer> set = new HashSet<>();\\n        while (!queue.isEmpty()) {\\n            int size = queue.size();            \\n            for (int i = 0; i < size; i++) {\\n                int value = queue.poll();\\n                List<Integer> neighbors = graph.get(value);\\n                if (neighbors == null) {\\n                    continue;\\n                }\\n                for (int neighbor : neighbors) {\\n                    if (set.contains(neighbor)) {\\n                        continue;\\n                    }\\n                    queue.offer(neighbor);\\n                    set.add(value);\\n                }\\n            }\\n            count++;\\n        }\\n        return count - 1;\\n    }\\n    public void dfs(TreeNode root, int parentValue, Map<Integer, List<Integer>> graph) {\\n        if (root == null) {\\n            return;\\n        }   \\n        int rootValue = root.val;\\n        if (parentValue == -1) {\\n            dfs(root.left, rootValue, graph);\\n            dfs(root.right, rootValue, graph);\\n            return;\\n        }   \\n        if (graph.containsKey(rootValue)) {\\n            List<Integer> list = graph.get(rootValue);\\n            list.add(parentValue);\\n            graph.put(rootValue, list);\\n        } else {\\n            List<Integer> list = new ArrayList<>();\\n            list.add(parentValue);\\n            graph.put(rootValue, list);\\n        }\\n        if (graph.containsKey(parentValue)) {\\n            List<Integer> list = graph.get(parentValue);\\n            list.add(rootValue);\\n            graph.put(parentValue, list);\\n        } else {\\n            List<Integer> list = new ArrayList<>();\\n            list.add(rootValue);\\n            graph.put(parentValue, list);\\n        }\\n        dfs(root.left, rootValue, graph);\\n        dfs(root.right, rootValue, graph);\\n        return;\\n    } \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4073608,
                "title": "java-simple-solution-tree",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void getParent(TreeNode root,HashMap<TreeNode,TreeNode> parent){\\n        if(root==null) return;\\n        if(root.left!=null){\\n            parent.put(root.left,root);\\n        }\\n        if(root.right!=null){\\n            parent.put(root.right,root);\\n        }\\n\\n        getParent(root.left,parent);\\n        getParent(root.right,parent);\\n    }\\n    public TreeNode find(TreeNode root, int target){\\n        if(root==null) return null;\\n        if(root.val==target) return root;\\n\\n        TreeNode filc=find(root.left,target);\\n        if(filc!=null) return filc;\\n\\n        TreeNode firc=find(root.right,target);\\n        if(firc!=null) return firc;\\n\\n        return null;\\n    }\\n    public int amountOfTime(TreeNode root, int start) {\\n        HashMap<TreeNode,TreeNode> parent=new HashMap<>();\\n        getParent(root,parent);\\n\\n        TreeNode src=find(root,start);\\n\\n\\n        Queue<TreeNode> que=new LinkedList<>();\\n        HashSet<TreeNode> vis=new HashSet<>();\\n\\n        que.add(src);\\n        vis.add(src);\\n\\n        int level=0;\\n\\n        while(que.size()>0){\\n            int size=que.size();\\n            while(size-->0){\\n                TreeNode rnode=que.remove();\\n                if(rnode.left!=null && vis.contains(rnode.left)==false){\\n                    que.add(rnode.left);\\n                    vis.add(rnode.left);\\n                }\\n\\n                if(rnode.right!=null && vis.contains(rnode.right)==false){\\n                    que.add(rnode.right);\\n                    vis.add(rnode.right);\\n                }\\n\\n                if(parent.get(rnode)!=null && vis.contains(parent.get(rnode))==false){\\n                    que.add(parent.get(rnode));\\n                    vis.add(parent.get(rnode));\\n                }\\n            }\\n            level++;\\n        }\\n        if(level<0) return 0;\\n        return level-1;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public void getParent(TreeNode root,HashMap<TreeNode,TreeNode> parent){\\n        if(root==null) return;\\n        if(root.left!=null){\\n            parent.put(root.left,root);\\n        }\\n        if(root.right!=null){\\n            parent.put(root.right,root);\\n        }\\n\\n        getParent(root.left,parent);\\n        getParent(root.right,parent);\\n    }\\n    public TreeNode find(TreeNode root, int target){\\n        if(root==null) return null;\\n        if(root.val==target) return root;\\n\\n        TreeNode filc=find(root.left,target);\\n        if(filc!=null) return filc;\\n\\n        TreeNode firc=find(root.right,target);\\n        if(firc!=null) return firc;\\n\\n        return null;\\n    }\\n    public int amountOfTime(TreeNode root, int start) {\\n        HashMap<TreeNode,TreeNode> parent=new HashMap<>();\\n        getParent(root,parent);\\n\\n        TreeNode src=find(root,start);\\n\\n\\n        Queue<TreeNode> que=new LinkedList<>();\\n        HashSet<TreeNode> vis=new HashSet<>();\\n\\n        que.add(src);\\n        vis.add(src);\\n\\n        int level=0;\\n\\n        while(que.size()>0){\\n            int size=que.size();\\n            while(size-->0){\\n                TreeNode rnode=que.remove();\\n                if(rnode.left!=null && vis.contains(rnode.left)==false){\\n                    que.add(rnode.left);\\n                    vis.add(rnode.left);\\n                }\\n\\n                if(rnode.right!=null && vis.contains(rnode.right)==false){\\n                    que.add(rnode.right);\\n                    vis.add(rnode.right);\\n                }\\n\\n                if(parent.get(rnode)!=null && vis.contains(parent.get(rnode))==false){\\n                    que.add(parent.get(rnode));\\n                    vis.add(parent.get(rnode));\\n                }\\n            }\\n            level++;\\n        }\\n        if(level<0) return 0;\\n        return level-1;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4055847,
                "title": "similar-to-rotten-bfs",
                "content": "Here\\'s an explanation of the approach used in the code:\\n\\n1. **Initialization:** The function begins by checking if the `root` of the binary tree is falsy (e.g., if it doesn\\'t exist). If `root` is falsy, it returns 0 as a default value.\\n\\n2. **Breadth-First Search (BFS):** The function then performs a breadth-first search (BFS) traversal of the binary tree using a queue data structure. During the BFS traversal, it maintains a `hashmap` to store the adjacency information for each node. This `hashmap` is used to represent the undirected graph.\\n\\n    - For each node visited in the BFS traversal, the code checks if it\\'s already present in the `hashmap`. If not, it initializes an empty array for that node\\'s adjacency list.\\n    - It then processes the left and right child nodes of the current node. If they exist and the current node is in the `hashmap`, it updates the adjacency lists for both the current node and its child nodes to indicate that they are connected in an undirected manner.\\n\\n3. **BFS for Maximum Time Calculation:** After building the `hashmap`, the code proceeds to calculate the maximum time it takes to reach the `start` node from any other node in the graph. It uses another BFS traversal for this purpose.\\n\\n    - It maintains a queue for BFS traversal and a set called `visited` to keep track of visited nodes.\\n    - The BFS traversal starts from the `start` node with an initial time of 0.\\n    - It explores adjacent nodes from the `hashmap`, incrementing the time for each step.\\n    - The maximum time encountered during this traversal is stored in the `maxTime` variable.\\n\\n4. **Final Result:** The function returns the maximum time (`maxTime`) as the result, which represents the maximum number of steps needed to reach the `start` node from any other node in the undirected graph.\\n\\n\\n```\\n\\nvar amountOfTime = function(root, start) {\\n    if(!root){\\n        return 0; // Return a default value when root is falsy\\n    }\\n\\n    let hashmap = new Map();\\n\\n    function bfs(node){\\n        let queue = [];\\n        queue.push(node);\\n        while(queue.length > 0){\\n            let size = queue.length;\\n            for(let i = 0; i < size; i++){\\n                let curr = queue.shift();\\n                if (!hashmap.has(curr.val)){\\n                    hashmap.set(curr.val,[]);\\n                }\\n                if(curr.left){\\n                    if (hashmap.has(curr.val)){\\n                        hashmap.get(curr.val).push(curr.left.val);\\n                        hashmap.set(curr.left.val,[curr.val]);//as undorected \\n                    }\\n                    queue.push(curr.left);\\n                }\\n                if(curr.right){\\n                    if (hashmap.has(curr.val)){\\n                        hashmap.get(curr.val).push(curr.right.val);\\n                        hashmap.set(curr.right.val,[curr.val]);//as undorected \\n                    }\\n                    queue.push(curr.right);\\n                }\\n            }\\n        }\\n    }\\n\\n    bfs(root);\\n    let queue = [];\\n    let visited = new Set();\\n    queue.push({node : start, time : 0});\\n    let maxTime = 0;\\n\\n    while(queue.length > 0){\\n        let size = queue.length;\\n        for(let i = 0; i < size; i++){\\n            let {node, time} = queue.shift();\\n            maxTime = Math.max(time, maxTime);\\n            visited.add(node);\\n            console.log(hashmap.get(node), \"cjecl\");\\n            for (let nei of hashmap.get(node)) {\\n                if(!visited.has(nei)){\\n                    queue.push({node : nei, time : time + 1});\\n                }\\n            }\\n        }\\n    }\\n\\n    return maxTime;\\n};\\n\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Breadth-First Search",
                    "Ordered Set"
                ],
                "code": "```\\n\\nvar amountOfTime = function(root, start) {\\n    if(!root){\\n        return 0; // Return a default value when root is falsy\\n    }\\n\\n    let hashmap = new Map();\\n\\n    function bfs(node){\\n        let queue = [];\\n        queue.push(node);\\n        while(queue.length > 0){\\n            let size = queue.length;\\n            for(let i = 0; i < size; i++){\\n                let curr = queue.shift();\\n                if (!hashmap.has(curr.val)){\\n                    hashmap.set(curr.val,[]);\\n                }\\n                if(curr.left){\\n                    if (hashmap.has(curr.val)){\\n                        hashmap.get(curr.val).push(curr.left.val);\\n                        hashmap.set(curr.left.val,[curr.val]);//as undorected \\n                    }\\n                    queue.push(curr.left);\\n                }\\n                if(curr.right){\\n                    if (hashmap.has(curr.val)){\\n                        hashmap.get(curr.val).push(curr.right.val);\\n                        hashmap.set(curr.right.val,[curr.val]);//as undorected \\n                    }\\n                    queue.push(curr.right);\\n                }\\n            }\\n        }\\n    }\\n\\n    bfs(root);\\n    let queue = [];\\n    let visited = new Set();\\n    queue.push({node : start, time : 0});\\n    let maxTime = 0;\\n\\n    while(queue.length > 0){\\n        let size = queue.length;\\n        for(let i = 0; i < size; i++){\\n            let {node, time} = queue.shift();\\n            maxTime = Math.max(time, maxTime);\\n            visited.add(node);\\n            console.log(hashmap.get(node), \"cjecl\");\\n            for (let nei of hashmap.get(node)) {\\n                if(!visited.has(nei)){\\n                    queue.push({node : nei, time : time + 1});\\n                }\\n            }\\n        }\\n    }\\n\\n    return maxTime;\\n};\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 4045849,
                "title": "neat-java-solution-build-graph-bfs",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        buildGraph(null, root, graph);\\n        Set<Integer> infected = new HashSet<>();\\n        infected.add(start);\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(start);\\n        int minute = 0;\\n        while(!queue.isEmpty())\\n        {\\n            int count = queue.size();\\n            for(int index = 0;index < count;index++)\\n            {\\n                Integer curr = queue.poll();\\n                for(var neighbor:graph.get(curr))\\n                {\\n                    if(!infected.contains(neighbor))\\n                    {\\n                        infected.add(neighbor);\\n                        queue.add(neighbor);\\n                    }\\n                }\\n            }\\n            minute++;\\n        }\\n        return minute-1;\\n    }\\n\\n    private void buildGraph(TreeNode parent, TreeNode curr, Map<Integer, List<Integer>> graph)\\n    {\\n        if(curr == null) return;\\n        graph.put(curr.val, new ArrayList<>());\\n        TreeNode[] neighbors = new TreeNode[] {parent,curr.left,curr.right};\\n        for(TreeNode neighbor:neighbors)\\n        {\\n            if(neighbor!=null) graph.get(curr.val).add(neighbor.val);\\n        }\\n        buildGraph(curr,curr.left,graph);\\n        buildGraph(curr,curr.right,graph);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        Map<Integer, List<Integer>> graph = new HashMap<>();\\n        buildGraph(null, root, graph);\\n        Set<Integer> infected = new HashSet<>();\\n        infected.add(start);\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(start);\\n        int minute = 0;\\n        while(!queue.isEmpty())\\n        {\\n            int count = queue.size();\\n            for(int index = 0;index < count;index++)\\n            {\\n                Integer curr = queue.poll();\\n                for(var neighbor:graph.get(curr))\\n                {\\n                    if(!infected.contains(neighbor))\\n                    {\\n                        infected.add(neighbor);\\n                        queue.add(neighbor);\\n                    }\\n                }\\n            }\\n            minute++;\\n        }\\n        return minute-1;\\n    }\\n\\n    private void buildGraph(TreeNode parent, TreeNode curr, Map<Integer, List<Integer>> graph)\\n    {\\n        if(curr == null) return;\\n        graph.put(curr.val, new ArrayList<>());\\n        TreeNode[] neighbors = new TreeNode[] {parent,curr.left,curr.right};\\n        for(TreeNode neighbor:neighbors)\\n        {\\n            if(neighbor!=null) graph.get(curr.val).add(neighbor.val);\\n        }\\n        buildGraph(curr,curr.left,graph);\\n        buildGraph(curr,curr.right,graph);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4034662,
                "title": "simple-easy-and-optimized-java-code",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public int amountOfTime(TreeNode root, int start) {\\n        HashMap<TreeNode, TreeNode> parent = new HashMap<>();\\n        TreeNode target = makeParent(root , parent , start);\\n        int ans = findTime(root , parent , target);\\n        return ans;\\n    }\\n\\n    public TreeNode makeParent(TreeNode root,HashMap<TreeNode, TreeNode> parent, int start){\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        TreeNode res = null;\\n        while(!q.isEmpty()){\\n            TreeNode curr = q.poll();\\n            if(curr.val == start) res = curr;\\n\\n            if(curr.left != null){\\n                parent.put(curr.left , curr);\\n                q.add(curr.left);\\n            }\\n             if(curr.right != null){\\n                parent.put(curr.right , curr);\\n                q.add(curr.right);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int findTime(TreeNode root,HashMap<TreeNode, TreeNode> parent, TreeNode target){\\n        if(root == null) return 0;\\n        HashMap<TreeNode,Integer> visited = new HashMap<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        visited.put(target , 1);\\n        q.add(target);\\n        int time = 0;\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            int flag = 0;\\n            for(int i = 0 ; i<n ; i++){\\n                TreeNode curr = q.poll();\\n                if(curr.left != null && visited.get(curr.left) == null){\\n                    flag = 1;\\n                    visited.put(curr.left, 1);\\n                    q.add(curr.left);\\n                }\\n                 if(curr.right != null && visited.get(curr.right) == null){\\n                    flag = 1;\\n                    visited.put(curr.right, 1);\\n                    q.add(curr.right);\\n                }\\n                 if(parent.get(curr) != null && visited.get(parent.get(curr)) == null){\\n                    flag = 1;\\n                    visited.put(parent.get(curr), 1);\\n                    q.add(parent.get(curr));\\n                }\\n            }\\n            if(flag == 1) time++;\\n        }\\n        return time;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n\\n    public int amountOfTime(TreeNode root, int start) {\\n        HashMap<TreeNode, TreeNode> parent = new HashMap<>();\\n        TreeNode target = makeParent(root , parent , start);\\n        int ans = findTime(root , parent , target);\\n        return ans;\\n    }\\n\\n    public TreeNode makeParent(TreeNode root,HashMap<TreeNode, TreeNode> parent, int start){\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        TreeNode res = null;\\n        while(!q.isEmpty()){\\n            TreeNode curr = q.poll();\\n            if(curr.val == start) res = curr;\\n\\n            if(curr.left != null){\\n                parent.put(curr.left , curr);\\n                q.add(curr.left);\\n            }\\n             if(curr.right != null){\\n                parent.put(curr.right , curr);\\n                q.add(curr.right);\\n            }\\n        }\\n        return res;\\n    }\\n\\n    public int findTime(TreeNode root,HashMap<TreeNode, TreeNode> parent, TreeNode target){\\n        if(root == null) return 0;\\n        HashMap<TreeNode,Integer> visited = new HashMap<>();\\n        Queue<TreeNode> q = new LinkedList<>();\\n        visited.put(target , 1);\\n        q.add(target);\\n        int time = 0;\\n        while(!q.isEmpty()){\\n            int n = q.size();\\n            int flag = 0;\\n            for(int i = 0 ; i<n ; i++){\\n                TreeNode curr = q.poll();\\n                if(curr.left != null && visited.get(curr.left) == null){\\n                    flag = 1;\\n                    visited.put(curr.left, 1);\\n                    q.add(curr.left);\\n                }\\n                 if(curr.right != null && visited.get(curr.right) == null){\\n                    flag = 1;\\n                    visited.put(curr.right, 1);\\n                    q.add(curr.right);\\n                }\\n                 if(parent.get(curr) != null && visited.get(parent.get(curr)) == null){\\n                    flag = 1;\\n                    visited.put(parent.get(curr), 1);\\n                    q.add(parent.get(curr));\\n                }\\n            }\\n            if(flag == 1) time++;\\n        }\\n        return time;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4032296,
                "title": "binary-tree-infected-dfs-traversal-intuitive",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n**O(N)**\\n- Space complexity:\\n**O(N)**\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        HashMap<TreeNode, TreeNode> parentMap = new HashMap<>();\\n        HashMap<TreeNode, Boolean> visitedMap = new HashMap<>();\\n        TreeNode target = makeParents(root, parentMap, start);\\n        int ans = heightTreeTarget(target, parentMap, visitedMap);\\n        return ans - 1;\\n    }\\n    public TreeNode makeParents(TreeNode root, HashMap<TreeNode, TreeNode> map, int start)\\n    {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        TreeNode res = new TreeNode(-1);\\n        while(!q.isEmpty())\\n        {\\n            TreeNode node = q.poll();\\n            if(node.val == start)\\n                res = node;\\n            if(node.left!=null)\\n            {\\n                map.put(node.left, node);\\n                q.add(node.left);\\n            }\\n            if(node.right!=null)\\n            {\\n                map.put(node.right, node);\\n                q.add(node.right);\\n            }\\n        }\\n        return res;\\n    }\\n    public int heightTreeTarget(TreeNode root, HashMap<TreeNode, TreeNode> parentMap, HashMap<TreeNode, Boolean> visitedMap)\\n    {\\n        if(root == null)\\n            return 0;\\n        \\n        visitedMap.put(root, true);\\n\\n        int left = 0, right = 0, parent = 0;\\n        if(visitedMap.get(root.left)==null)\\n            left = heightTreeTarget(root.left, parentMap, visitedMap);\\n\\n        if(visitedMap.get(root.right)==null)\\n            right = heightTreeTarget(root.right, parentMap, visitedMap);\\n\\n        if(visitedMap.get(parentMap.get(root))==null)\\n            parent = heightTreeTarget(parentMap.get(root), parentMap, visitedMap);  \\n\\n        return Math.max(left, Math.max(right, parent)) + 1;\\n\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        HashMap<TreeNode, TreeNode> parentMap = new HashMap<>();\\n        HashMap<TreeNode, Boolean> visitedMap = new HashMap<>();\\n        TreeNode target = makeParents(root, parentMap, start);\\n        int ans = heightTreeTarget(target, parentMap, visitedMap);\\n        return ans - 1;\\n    }\\n    public TreeNode makeParents(TreeNode root, HashMap<TreeNode, TreeNode> map, int start)\\n    {\\n        Queue<TreeNode> q = new LinkedList<>();\\n        q.add(root);\\n        TreeNode res = new TreeNode(-1);\\n        while(!q.isEmpty())\\n        {\\n            TreeNode node = q.poll();\\n            if(node.val == start)\\n                res = node;\\n            if(node.left!=null)\\n            {\\n                map.put(node.left, node);\\n                q.add(node.left);\\n            }\\n            if(node.right!=null)\\n            {\\n                map.put(node.right, node);\\n                q.add(node.right);\\n            }\\n        }\\n        return res;\\n    }\\n    public int heightTreeTarget(TreeNode root, HashMap<TreeNode, TreeNode> parentMap, HashMap<TreeNode, Boolean> visitedMap)\\n    {\\n        if(root == null)\\n            return 0;\\n        \\n        visitedMap.put(root, true);\\n\\n        int left = 0, right = 0, parent = 0;\\n        if(visitedMap.get(root.left)==null)\\n            left = heightTreeTarget(root.left, parentMap, visitedMap);\\n\\n        if(visitedMap.get(root.right)==null)\\n            right = heightTreeTarget(root.right, parentMap, visitedMap);\\n\\n        if(visitedMap.get(parentMap.get(root))==null)\\n            parent = heightTreeTarget(parentMap.get(root), parentMap, visitedMap);  \\n\\n        return Math.max(left, Math.max(right, parent)) + 1;\\n\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4028403,
                "title": "cpp-solution-with-full-explanation-fully-commented-code",
                "content": "```\\nclass Solution {\\nprivate:\\n    void findparent(TreeNode *root,unordered_map<TreeNode*,TreeNode*>&mp){\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            if(node->left){\\n                q.push(node->left);\\n                mp[node->left]=node;\\n            }\\n            if(node->right){\\n                q.push(node->right);\\n                mp[node->right]=node;\\n            }\\n        }\\n    }\\n    TreeNode* getnode(TreeNode *root,int target){\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            if(node->val==target) return node;\\n            if(node->left) q.push(node->left);\\n            if(node->right) q.push(node->right);\\n        }\\n        return nullptr;\\n    }\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        //mark all of the nodes with their parents \\n        unordered_map<TreeNode*,TreeNode*>mp;\\n        findparent(root,mp);\\n        //now we find the affected node \\n        auto targetnode=getnode(root,start);\\n        //now we will make a visited map to make sure that when we are going from\\n        //the target node we do not really end reaching the prev node itself \\n        unordered_map<TreeNode*,bool>mpp;\\n        //now let us start the bfs from the target node \\n        queue<TreeNode*>q;\\n        q.push(targetnode);\\n        mpp[targetnode]=true;\\n        int count=0;\\n        while(!q.empty()){\\n            count++;\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                auto node=q.front();\\n                q.pop();\\n                if(node->left and !mpp[node->left]){\\n                    q.push(node->left);\\n                    mpp[node->left]=true;\\n                }\\n                if(node->right and !mpp[node->right]){\\n                    q.push(node->right);\\n                    mpp[node->right]=true;\\n                }\\n                //after affecting nodes in the children side \\n                //we now look for affecting nodes if we go via the parent side \\n                if(mp[node] and !mpp[mp[node]]){\\n                    q.push(mp[node]);\\n                    mpp[mp[node]]=true;\\n                }\\n            }\\n        }\\n        return count-1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\nprivate:\\n    void findparent(TreeNode *root,unordered_map<TreeNode*,TreeNode*>&mp){\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            if(node->left){\\n                q.push(node->left);\\n                mp[node->left]=node;\\n            }\\n            if(node->right){\\n                q.push(node->right);\\n                mp[node->right]=node;\\n            }\\n        }\\n    }\\n    TreeNode* getnode(TreeNode *root,int target){\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            auto node = q.front();\\n            q.pop();\\n            if(node->val==target) return node;\\n            if(node->left) q.push(node->left);\\n            if(node->right) q.push(node->right);\\n        }\\n        return nullptr;\\n    }\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        //mark all of the nodes with their parents \\n        unordered_map<TreeNode*,TreeNode*>mp;\\n        findparent(root,mp);\\n        //now we find the affected node \\n        auto targetnode=getnode(root,start);\\n        //now we will make a visited map to make sure that when we are going from\\n        //the target node we do not really end reaching the prev node itself \\n        unordered_map<TreeNode*,bool>mpp;\\n        //now let us start the bfs from the target node \\n        queue<TreeNode*>q;\\n        q.push(targetnode);\\n        mpp[targetnode]=true;\\n        int count=0;\\n        while(!q.empty()){\\n            count++;\\n            int sz=q.size();\\n            for(int i=0;i<sz;i++){\\n                auto node=q.front();\\n                q.pop();\\n                if(node->left and !mpp[node->left]){\\n                    q.push(node->left);\\n                    mpp[node->left]=true;\\n                }\\n                if(node->right and !mpp[node->right]){\\n                    q.push(node->right);\\n                    mpp[node->right]=true;\\n                }\\n                //after affecting nodes in the children side \\n                //we now look for affecting nodes if we go via the parent side \\n                if(mp[node] and !mpp[mp[node]]){\\n                    q.push(mp[node]);\\n                    mpp[mp[node]]=true;\\n                }\\n            }\\n        }\\n        return count-1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4020746,
                "title": "python3-just-build-graph-and-dfs",
                "content": "# Code\\n```\\nclass Solution:\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n        self.graph = defaultdict(list)\\n\\n        # build graph\\n        def helper(root, parent):\\n            if not root: return\\n            if parent != -1:\\n                self.graph[root.val].append(parent)\\n                self.graph[parent].append(root.val)\\n            helper(root.left, root.val)\\n            helper(root.right, root.val)\\n\\n        # simple dfs\\n        self.seen = set()\\n        self.seen.add(start)\\n        def dfs(start):\\n            ret = 0\\n            for v in self.graph[start]:\\n                if v in self.seen: continue\\n                self.seen.add(v)\\n                ret = max(ret, dfs(v))\\n            return ret + 1\\n        \\n        helper(root, -1)\\n        return dfs(start)-1\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def amountOfTime(self, root: Optional[TreeNode], start: int) -> int:\\n        self.graph = defaultdict(list)\\n\\n        # build graph\\n        def helper(root, parent):\\n            if not root: return\\n            if parent != -1:\\n                self.graph[root.val].append(parent)\\n                self.graph[parent].append(root.val)\\n            helper(root.left, root.val)\\n            helper(root.right, root.val)\\n\\n        # simple dfs\\n        self.seen = set()\\n        self.seen.add(start)\\n        def dfs(start):\\n            ret = 0\\n            for v in self.graph[start]:\\n                if v in self.seen: continue\\n                self.seen.add(v)\\n                ret = max(ret, dfs(v))\\n            return ret + 1\\n        \\n        helper(root, -1)\\n        return dfs(start)-1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4019076,
                "title": "easy-best-c-solution",
                "content": "<!-- # Intuition -->\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n<!-- # Approach -->\\n<!-- Describe your approach to solving the problem. -->\\n\\n<!-- # Complexity -->\\n<!-- - Time complexity: -->\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n<!-- - Space complexity: -->\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    TreeNode* createParentMapping(TreeNode* root, int target, map<TreeNode*, TreeNode*> &nodeToParent)\\n    {\\n        TreeNode* ans = NULL;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        nodeToParent[root] = NULL;\\n        while(!q.empty())\\n        {\\n            TreeNode* frontNode = q.front();\\n            q.pop();\\n            if(frontNode -> val == target)\\n                ans = frontNode;\\n            if(frontNode -> left)\\n            {\\n                nodeToParent[frontNode -> left] = frontNode;\\n                q.push(frontNode -> left);\\n            }\\n            if(frontNode -> right)\\n            {\\n                nodeToParent[frontNode -> right] = frontNode;\\n                q.push(frontNode -> right);\\n            }\\n        }\\n        return ans;\\n    }\\n    int burnTree(TreeNode* root, map<TreeNode*, TreeNode*> &nodeToParent)\\n    {\\n        map<TreeNode*, bool> isVisited;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        isVisited[root] = true;\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            bool flag = false;\\n            int size = q.size();\\n            for(int i = 0; i < size; i++)\\n            {\\n                TreeNode* frontNode = q.front();\\n                q.pop();\\n                if(frontNode -> left && !isVisited[frontNode -> left])\\n                {\\n                    flag = true;\\n                    q.push(frontNode -> left);\\n                    isVisited[frontNode -> left] = true;\\n                }\\n                if(frontNode -> right && !isVisited[frontNode -> right])\\n                {\\n                    flag = true;\\n                    q.push(frontNode -> right);\\n                    isVisited[frontNode -> right] = true;\\n                }\\n                if(nodeToParent[frontNode] && !isVisited[nodeToParent[frontNode]])\\n                {\\n                    flag = true;\\n                    q.push(nodeToParent[frontNode]);\\n                    isVisited[nodeToParent[frontNode]] = true;\\n                }\\n            }\\n            if(flag == true)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        map<TreeNode*, TreeNode*> nodeToParent;\\n        TreeNode* targetNode = createParentMapping(root, start, nodeToParent);\\n        return burnTree(targetNode, nodeToParent);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    TreeNode* createParentMapping(TreeNode* root, int target, map<TreeNode*, TreeNode*> &nodeToParent)\\n    {\\n        TreeNode* ans = NULL;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        nodeToParent[root] = NULL;\\n        while(!q.empty())\\n        {\\n            TreeNode* frontNode = q.front();\\n            q.pop();\\n            if(frontNode -> val == target)\\n                ans = frontNode;\\n            if(frontNode -> left)\\n            {\\n                nodeToParent[frontNode -> left] = frontNode;\\n                q.push(frontNode -> left);\\n            }\\n            if(frontNode -> right)\\n            {\\n                nodeToParent[frontNode -> right] = frontNode;\\n                q.push(frontNode -> right);\\n            }\\n        }\\n        return ans;\\n    }\\n    int burnTree(TreeNode* root, map<TreeNode*, TreeNode*> &nodeToParent)\\n    {\\n        map<TreeNode*, bool> isVisited;\\n        queue<TreeNode*> q;\\n        q.push(root);\\n        isVisited[root] = true;\\n        int ans = 0;\\n        while(!q.empty())\\n        {\\n            bool flag = false;\\n            int size = q.size();\\n            for(int i = 0; i < size; i++)\\n            {\\n                TreeNode* frontNode = q.front();\\n                q.pop();\\n                if(frontNode -> left && !isVisited[frontNode -> left])\\n                {\\n                    flag = true;\\n                    q.push(frontNode -> left);\\n                    isVisited[frontNode -> left] = true;\\n                }\\n                if(frontNode -> right && !isVisited[frontNode -> right])\\n                {\\n                    flag = true;\\n                    q.push(frontNode -> right);\\n                    isVisited[frontNode -> right] = true;\\n                }\\n                if(nodeToParent[frontNode] && !isVisited[nodeToParent[frontNode]])\\n                {\\n                    flag = true;\\n                    q.push(nodeToParent[frontNode]);\\n                    isVisited[nodeToParent[frontNode]] = true;\\n                }\\n            }\\n            if(flag == true)\\n                ans++;\\n        }\\n        return ans;\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        map<TreeNode*, TreeNode*> nodeToParent;\\n        TreeNode* targetNode = createParentMapping(root, start, nodeToParent);\\n        return burnTree(targetNode, nodeToParent);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4018810,
                "title": "two-dfs-solution-c",
                "content": "\\n# Approach\\n--> we need to find the longest path from \\'start\\' to reach a leaf node\\n\\n--> doing this on a tree structure is a difficut thing to do because child do not have parent reference in binary trees\\n\\n--> so we first convert the given tree in a undirected graph;\\n\\n--> the do a dfs to find the longest path to leaf starting from the start;\\n\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    unordered_map<int, vector<int>> mp;\\npublic:\\n    void dfs(TreeNode* root){\\n        if(root == NULL)return;\\n        if(root->left){\\n            mp[root->val].push_back(root->left->val);\\n            mp[root->left->val].push_back(root->val);\\n            dfs(root->left);\\n        }\\n        if(root->right){\\n            mp[root->val].push_back(root->right->val);\\n            mp[root->right->val].push_back(root->val);\\n            dfs(root->right);\\n        }\\n    }\\n\\n    int dfs2(int u, unordered_set<int> &vis){\\n        vis.insert(u);\\n        int ans = 0;\\n        for(auto v : mp[u]){\\n            if(vis.count(v) == 0){\\n                ans = max(ans, 1 + dfs2(v, vis));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int amountOfTime(TreeNode* root, int start) {\\n        dfs(root);\\n        unordered_set<int> vis;\\n        return dfs2(start, vis);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    unordered_map<int, vector<int>> mp;\\npublic:\\n    void dfs(TreeNode* root){\\n        if(root == NULL)return;\\n        if(root->left){\\n            mp[root->val].push_back(root->left->val);\\n            mp[root->left->val].push_back(root->val);\\n            dfs(root->left);\\n        }\\n        if(root->right){\\n            mp[root->val].push_back(root->right->val);\\n            mp[root->right->val].push_back(root->val);\\n            dfs(root->right);\\n        }\\n    }\\n\\n    int dfs2(int u, unordered_set<int> &vis){\\n        vis.insert(u);\\n        int ans = 0;\\n        for(auto v : mp[u]){\\n            if(vis.count(v) == 0){\\n                ans = max(ans, 1 + dfs2(v, vis));\\n            }\\n        }\\n        return ans;\\n    }\\n\\n    int amountOfTime(TreeNode* root, int start) {\\n        dfs(root);\\n        unordered_set<int> vis;\\n        return dfs2(start, vis);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4010067,
                "title": "c-bfs-map-beginner-friendly",
                "content": "\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n   TreeNode* trackParents(unordered_map<TreeNode*,TreeNode*> &parentTrack, TreeNode* root, int start){\\n       queue<TreeNode*> nodeQueue;\\n       nodeQueue.push(root);\\n       TreeNode *res;\\n       while(!nodeQueue.empty()){\\n           int size = nodeQueue.size();\\n\\n           for(int i = 0; i < size; i++)\\n           {\\n               TreeNode *curr = nodeQueue.front();\\n               nodeQueue.pop();\\n               if(curr->val == start) res = curr;\\n\\n               if(curr->left){\\n                   parentTrack[curr->left] = curr;\\n                   nodeQueue.push(curr->left);\\n               }\\n\\n               if(curr->right){\\n                   parentTrack[curr->right] = curr;\\n                   nodeQueue.push(curr->right);\\n               }\\n           } \\n       }\\n\\n       return res;\\n   }\\n\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<TreeNode*, TreeNode*> parentTrack;\\n        TreeNode *target = trackParents(parentTrack,root,start);\\n        int time = 0;\\n\\n        queue<TreeNode*> nodeQueue;\\n        nodeQueue.push(target);\\n        unordered_map<TreeNode*, int> visited;\\n        visited[target] = 1;\\n\\n        while(!nodeQueue.empty()){\\n            int size = nodeQueue.size();\\n            int check = 0;\\n\\n            for(int i = 0; i < size; i++)\\n            {\\n                TreeNode *curr = nodeQueue.front();\\n                nodeQueue.pop();\\n\\n                if(curr->left &&  !visited[curr->left]) \\n                {\\n                   check = 1;\\n                   nodeQueue.push(curr->left); \\n                   visited[curr->left] = 1; \\n                }\\n                if(curr->right &&  !visited[curr->right]) \\n                {\\n                   check = 1;\\n                   nodeQueue.push(curr->right);\\n                   visited[curr->right] = 1;  \\n                }\\n                if(parentTrack[curr] && !visited[parentTrack[curr]])\\n                {\\n                    check = 1;\\n                    nodeQueue.push(parentTrack[curr]);\\n                    visited[parentTrack[curr]] = 1;\\n                }\\n            }\\n            if(check) time++;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Breadth-First Search",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n   TreeNode* trackParents(unordered_map<TreeNode*,TreeNode*> &parentTrack, TreeNode* root, int start){\\n       queue<TreeNode*> nodeQueue;\\n       nodeQueue.push(root);\\n       TreeNode *res;\\n       while(!nodeQueue.empty()){\\n           int size = nodeQueue.size();\\n\\n           for(int i = 0; i < size; i++)\\n           {\\n               TreeNode *curr = nodeQueue.front();\\n               nodeQueue.pop();\\n               if(curr->val == start) res = curr;\\n\\n               if(curr->left){\\n                   parentTrack[curr->left] = curr;\\n                   nodeQueue.push(curr->left);\\n               }\\n\\n               if(curr->right){\\n                   parentTrack[curr->right] = curr;\\n                   nodeQueue.push(curr->right);\\n               }\\n           } \\n       }\\n\\n       return res;\\n   }\\n\\npublic:\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<TreeNode*, TreeNode*> parentTrack;\\n        TreeNode *target = trackParents(parentTrack,root,start);\\n        int time = 0;\\n\\n        queue<TreeNode*> nodeQueue;\\n        nodeQueue.push(target);\\n        unordered_map<TreeNode*, int> visited;\\n        visited[target] = 1;\\n\\n        while(!nodeQueue.empty()){\\n            int size = nodeQueue.size();\\n            int check = 0;\\n\\n            for(int i = 0; i < size; i++)\\n            {\\n                TreeNode *curr = nodeQueue.front();\\n                nodeQueue.pop();\\n\\n                if(curr->left &&  !visited[curr->left]) \\n                {\\n                   check = 1;\\n                   nodeQueue.push(curr->left); \\n                   visited[curr->left] = 1; \\n                }\\n                if(curr->right &&  !visited[curr->right]) \\n                {\\n                   check = 1;\\n                   nodeQueue.push(curr->right);\\n                   visited[curr->right] = 1;  \\n                }\\n                if(parentTrack[curr] && !visited[parentTrack[curr]])\\n                {\\n                    check = 1;\\n                    nodeQueue.push(parentTrack[curr]);\\n                    visited[parentTrack[curr]] = 1;\\n                }\\n            }\\n            if(check) time++;\\n        }\\n        return time;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 4005637,
                "title": "need-help-in-java-code",
                "content": "can anyone tell whats wrong in below code.\\n\\n\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    TreeNode strt=null;\\n    public int amountOfTime(TreeNode root, int start) {\\n        HashMap<Integer,TreeNode> hm=new HashMap<>();\\n        hm.put(root.val,null);\\n        preorder(root,hm,start);\\n        Queue<TreeNode> q=new LinkedList<>();\\n                Map<TreeNode, Boolean> visited = new HashMap<>();\\n\\n        q.add(strt);\\n        int time=0;\\n\\n    System.out.println(\"strtval\"+strt.val);\\n        while(!q.isEmpty()){\\n            time++;\\n            int size=q.size();\\n                while(size-->0){\\n                    TreeNode temp=q.remove();\\n                    System.out.println(\"temp val and next val\"+temp.left.val+\" temp val is \"+temp.val);\\n                    if(hm.get(temp.val)!=null && visited.get(hm.get(temp.val))==null){\\n                        q.add(hm.get(temp));\\n                        visited.put(hm.get(temp.val),true);\\n                    }\\n                    if(temp.left!=null &&visited.get(temp.left)==null){\\n                        q.add(temp.left);\\n                        visited.put(temp.left,true);\\n                    }\\n                    if(temp.right!=null && visited.get(temp.right)==null){\\n                        q.add(temp.right);\\n                        visited.put(temp.right,true);\\n                    }\\n                }\\n        }\\n        return time;\\n    }\\n    public void preorder(TreeNode root,HashMap<Integer,TreeNode> hm,int start){\\n       if(root==null) {\\n           return;\\n       }\\n        if(root.val==start){\\n            strt=root;\\n        }\\n        if(root.left != null) {\\n             hm.put(root.left.val,root);\\n        } \\n        if(root.right != null) {\\n            hm.put(root.right.val,root);\\n        }\\n        preorder(root.left,hm,start);\\n        preorder(root.right,hm,start); \\n    }\\n}",
                "solutionTags": [],
                "code": "class Solution {\\n    TreeNode strt=null;\\n    public int amountOfTime(TreeNode root, int start) {\\n        HashMap<Integer,TreeNode> hm=new HashMap<>();\\n        hm.put(root.val,null);\\n        preorder(root,hm,start);\\n        Queue<TreeNode> q=new LinkedList<>();\\n                Map<TreeNode, Boolean> visited = new HashMap<>();\\n\\n        q.add(strt);\\n        int time=0;\\n\\n    System.out.println(\"strtval\"+strt.val);\\n        while(!q.isEmpty()){\\n            time++;\\n            int size=q.size();\\n                while(size-->0){\\n                    TreeNode temp=q.remove();\\n                    System.out.println(\"temp val and next val\"+temp.left.val+\" temp val is \"+temp.val);\\n                    if(hm.get(temp.val)!=null && visited.get(hm.get(temp.val))==null){\\n                        q.add(hm.get(temp));\\n                        visited.put(hm.get(temp.val),true);\\n                    }",
                "codeTag": "Java"
            },
            {
                "id": 4004666,
                "title": "c-simple-solution-using-dfs-bfs-and-map",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, unordered_map<TreeNode*, TreeNode*>&mp, TreeNode* parent){\\n        if(!root) return;\\n        mp[root] = parent;\\n        dfs(root->left, mp, root);\\n        dfs(root->right, mp, root);\\n    }\\n\\n   TreeNode* findTarget(TreeNode* root, int start){\\n        if(!root) return NULL;\\n        if(root->val == start){\\n            return root;\\n        }\\n        TreeNode* l = findTarget(root->left, start);\\n        if(l) return l;\\n        TreeNode* r = findTarget(root->right, start);\\n        return r;\\n\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<TreeNode*, TreeNode*>mp;\\n        dfs(root,mp,NULL);\\n        TreeNode* target = findTarget(root,start);\\n        queue<TreeNode*>q;\\n        unordered_map<TreeNode*, bool>vis;\\n        q.push(target);\\n        vis[target]=true;\\n        int count =-1;\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i=0; i<size; i++){\\n                auto temp = q.front();\\n                q.pop();\\n                if(!vis[mp[temp]] and mp[temp]){\\n                    q.push(mp[temp]);\\n                    vis[mp[temp]]=true;\\n                }\\n                if(!vis[temp->left] and temp->left){\\n                    q.push(temp->left);\\n                    vis[temp->left]= true;\\n                }\\n                if(temp->right and !vis[temp->right]){\\n                    q.push(temp->right);\\n                    vis[temp->right] = true;\\n                }\\n            }\\n            count++;\\n        }\\n\\n        return count;\\n\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Ordered Map"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, unordered_map<TreeNode*, TreeNode*>&mp, TreeNode* parent){\\n        if(!root) return;\\n        mp[root] = parent;\\n        dfs(root->left, mp, root);\\n        dfs(root->right, mp, root);\\n    }\\n\\n   TreeNode* findTarget(TreeNode* root, int start){\\n        if(!root) return NULL;\\n        if(root->val == start){\\n            return root;\\n        }\\n        TreeNode* l = findTarget(root->left, start);\\n        if(l) return l;\\n        TreeNode* r = findTarget(root->right, start);\\n        return r;\\n\\n    }\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<TreeNode*, TreeNode*>mp;\\n        dfs(root,mp,NULL);\\n        TreeNode* target = findTarget(root,start);\\n        queue<TreeNode*>q;\\n        unordered_map<TreeNode*, bool>vis;\\n        q.push(target);\\n        vis[target]=true;\\n        int count =-1;\\n        while(!q.empty()){\\n            int size = q.size();\\n            for(int i=0; i<size; i++){\\n                auto temp = q.front();\\n                q.pop();\\n                if(!vis[mp[temp]] and mp[temp]){\\n                    q.push(mp[temp]);\\n                    vis[mp[temp]]=true;\\n                }\\n                if(!vis[temp->left] and temp->left){\\n                    q.push(temp->left);\\n                    vis[temp->left]= true;\\n                }\\n                if(temp->right and !vis[temp->right]){\\n                    q.push(temp->right);\\n                    vis[temp->right] = true;\\n                }\\n            }\\n            count++;\\n        }\\n\\n        return count;\\n\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3998547,
                "title": "java-bfs-accepted-solution-easy-to-understand",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        if(root == null || (root.left == null && root.right == null))\\n             return 0;\\n            \\n        Map<TreeNode, TreeNode> childParent = new HashMap<>();\\n        TreeNode targetNode = makeChildParentRelation(root, start, childParent);\\n        if(targetNode == null) \\n            return 0;\\n        return burnTree(targetNode, childParent);\\n    }\\n\\n    private int burnTree(TreeNode root, Map<TreeNode, TreeNode> childParent){\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        Map<TreeNode, Boolean> visited = new HashMap<>();\\n        visited.put(root, true);\\n        queue.add(root);\\n        int minTime = 0;\\n\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            boolean flag = false;\\n\\n            for(int i=0; i<size; i++){\\n                TreeNode node = queue.poll();\\n                // checking left node is visited or not, if not then burn the node\\n                if(node.left != null && visited.get(node.left) == null){\\n                    flag = true;\\n                    visited.put(node.left, true);\\n                    queue.add(node.left);\\n                }\\n                // checking right node is visited or not, if not then burn the node\\n                if(node.right != null && visited.get(node.right) == null){\\n                    flag = true;\\n                    visited.put(node.right, true);\\n                    queue.add(node.right);\\n                }\\n                // checking node\\'s parent is visited or not, if not then burn the node\\n                TreeNode parentNode = childParent.get(node);\\n                if(parentNode != null && visited.get(parentNode) == null){\\n                    flag = true;\\n                    visited.put(parentNode, true);\\n                    queue.add(parentNode);\\n                }\\n            }\\n\\n            // increast the time, if in any of the above 3 cases we burn the node;\\n            // all the nodes (parents\\' node(upward), left node and right node) burn together;\\n            // NOTE:\\n            // LEAF NODES will not be able to burn any adajecent node because their parents are already visited and they dont have any children. That\\'s is why we will not increment time in case of leaf nodes.\\n            if(flag)\\n                minTime++;\\n        }\\n        \\n        return minTime;\\n    }\\n\\n    private TreeNode makeChildParentRelation(TreeNode root, int start, Map<TreeNode, TreeNode> childParent){\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        TreeNode targetNode = null;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i=0; i<size; i++){\\n                TreeNode node = queue.poll();\\n                // finding the targetNode;\\n                if(node.val == start){\\n                    targetNode = node;\\n                }\\n                if(node.left != null){\\n                    childParent.put(node.left, node);\\n                    queue.add(node.left);\\n                }\\n                if(node.right != null){\\n                    childParent.put(node.right, node);\\n                    queue.add(node.right);\\n                }\\n            }\\n        }\\n\\n        return targetNode;\\n    }\\n\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Breadth-First Search",
                    "Queue",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        if(root == null || (root.left == null && root.right == null))\\n             return 0;\\n            \\n        Map<TreeNode, TreeNode> childParent = new HashMap<>();\\n        TreeNode targetNode = makeChildParentRelation(root, start, childParent);\\n        if(targetNode == null) \\n            return 0;\\n        return burnTree(targetNode, childParent);\\n    }\\n\\n    private int burnTree(TreeNode root, Map<TreeNode, TreeNode> childParent){\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        Map<TreeNode, Boolean> visited = new HashMap<>();\\n        visited.put(root, true);\\n        queue.add(root);\\n        int minTime = 0;\\n\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            boolean flag = false;\\n\\n            for(int i=0; i<size; i++){\\n                TreeNode node = queue.poll();\\n                // checking left node is visited or not, if not then burn the node\\n                if(node.left != null && visited.get(node.left) == null){\\n                    flag = true;\\n                    visited.put(node.left, true);\\n                    queue.add(node.left);\\n                }\\n                // checking right node is visited or not, if not then burn the node\\n                if(node.right != null && visited.get(node.right) == null){\\n                    flag = true;\\n                    visited.put(node.right, true);\\n                    queue.add(node.right);\\n                }\\n                // checking node\\'s parent is visited or not, if not then burn the node\\n                TreeNode parentNode = childParent.get(node);\\n                if(parentNode != null && visited.get(parentNode) == null){\\n                    flag = true;\\n                    visited.put(parentNode, true);\\n                    queue.add(parentNode);\\n                }\\n            }\\n\\n            // increast the time, if in any of the above 3 cases we burn the node;\\n            // all the nodes (parents\\' node(upward), left node and right node) burn together;\\n            // NOTE:\\n            // LEAF NODES will not be able to burn any adajecent node because their parents are already visited and they dont have any children. That\\'s is why we will not increment time in case of leaf nodes.\\n            if(flag)\\n                minTime++;\\n        }\\n        \\n        return minTime;\\n    }\\n\\n    private TreeNode makeChildParentRelation(TreeNode root, int start, Map<TreeNode, TreeNode> childParent){\\n        Queue<TreeNode> queue = new LinkedList<>();\\n        queue.add(root);\\n        TreeNode targetNode = null;\\n        while(!queue.isEmpty()){\\n            int size = queue.size();\\n            for(int i=0; i<size; i++){\\n                TreeNode node = queue.poll();\\n                // finding the targetNode;\\n                if(node.val == start){\\n                    targetNode = node;\\n                }\\n                if(node.left != null){\\n                    childParent.put(node.left, node);\\n                    queue.add(node.left);\\n                }\\n                if(node.right != null){\\n                    childParent.put(node.right, node);\\n                    queue.add(node.right);\\n                }\\n            }\\n        }\\n\\n        return targetNode;\\n    }\\n\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3993404,
                "title": "java-dfs-bfs-solution",
                "content": "# Complexity\\n- Time complexity: O(N)\\n\\n# Code\\n```\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        dfs(root, map, -1);\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(start);\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(start);\\n        int time = -1;\\n        Queue<Integer> queueNext = new LinkedList<>();\\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            List<Integer> l = map.get(curr);\\n            for (int i = 0; i < l.size(); i++) {\\n                if (!visited.contains(l.get(i))) {\\n                    queueNext.add(l.get(i));\\n                    visited.add(l.get(i));\\n                }\\n            }\\n            if (queue.isEmpty()) {\\n                queue = queueNext;\\n                queueNext = new LinkedList<>();\\n                time++;\\n            }\\n        }\\n        return time;\\n    }\\n\\n    private void dfs(TreeNode node, Map<Integer, List<Integer>> map, int parent) {\\n        if (node == null) return;\\n\\n        List<Integer> list = new ArrayList<>();\\n        if (parent > 0) list.add(parent);\\n        if (node.left != null) list.add(node.left.val);\\n        if (node.right != null) list.add(node.right.val);\\n        map.put(node.val, list);\\n\\n        dfs(node.left, map, node.val);\\n        dfs(node.right, map, node.val);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int amountOfTime(TreeNode root, int start) {\\n        Map<Integer, List<Integer>> map = new HashMap<>();\\n        dfs(root, map, -1);\\n        Set<Integer> visited = new HashSet<>();\\n        visited.add(start);\\n        Queue<Integer> queue = new LinkedList<>();\\n        queue.add(start);\\n        int time = -1;\\n        Queue<Integer> queueNext = new LinkedList<>();\\n        while (!queue.isEmpty()) {\\n            int curr = queue.poll();\\n            List<Integer> l = map.get(curr);\\n            for (int i = 0; i < l.size(); i++) {\\n                if (!visited.contains(l.get(i))) {\\n                    queueNext.add(l.get(i));\\n                    visited.add(l.get(i));\\n                }\\n            }\\n            if (queue.isEmpty()) {\\n                queue = queueNext;\\n                queueNext = new LinkedList<>();\\n                time++;\\n            }\\n        }\\n        return time;\\n    }\\n\\n    private void dfs(TreeNode node, Map<Integer, List<Integer>> map, int parent) {\\n        if (node == null) return;\\n\\n        List<Integer> list = new ArrayList<>();\\n        if (parent > 0) list.add(parent);\\n        if (node.left != null) list.add(node.left.val);\\n        if (node.right != null) list.add(node.right.val);\\n        map.put(node.val, list);\\n\\n        dfs(node.left, map, node.val);\\n        dfs(node.right, map, node.val);\\n    }\\n}\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1774032,
                "content": [
                    {
                        "username": "_aka5h",
                        "content": "I turned the tree into an undirected graph and rest was easy DFS."
                    },
                    {
                        "username": "andreicheremukhin",
                        "content": "There is more efficient way without graphs. "
                    },
                    {
                        "username": "nikhil909",
                        "content": "nice you could have just assingned a new parent link like this :\\n\\nclass Solution {\\npublic:\\nTreeNode*str;\\nvoid markParent(TreeNode*root,unordered_map<TreeNode*,TreeNode*>&parent,int target){\\n    queue<TreeNode*>queue;\\n    queue.push(root);\\n    while(!queue.empty()){\\n        TreeNode*curr=queue.front();\\n        queue.pop();\\n        if(curr->val==target)str=curr;\\n        if(curr->left){\\n            parent[curr->left]=curr;\\n            queue.push(curr->left);\\n        }\\n         if(curr->right){\\n            parent[curr->right]=curr;\\n            queue.push(curr->right);\\n        }\\n    }\\n}\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<TreeNode*,TreeNode*>parent;\\n        markParent(root,parent,start);\\n        unordered_map<TreeNode*,bool>vis;\\n        queue<TreeNode*>q;\\n        q.push(str);\\n        vis[str]=1;\\n        int level=0;\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n          auto curr=q.front();\\n          q.pop();\\n          if(curr->left&&!vis[curr->left]){\\n              vis[curr->left]=1;\\n              q.push(curr->left);\\n          }\\n         if(curr->right&&!vis[curr->right]){\\n              vis[curr->right]=1;\\n              q.push(curr->right);\\n          }\\n            if(parent[curr]&&!vis[parent[curr]]){\\n              vis[parent[curr]]=1;\\n              q.push(parent[curr]);\\n          }\\n            }\\n            level++;\\n        }\\n        return level-1;\\n    }\\n};"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "# ***My easy solution-***\\nhttps://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/solutions/3362186/simplest-approach-c/\\n\\nQuestion is similar to burning tree (GFG), should be marked HARD."
                    },
                    {
                        "username": "sohamleet",
                        "content": "This question was asked in Tech Interview round of GoldmanSach Internship in 2022 (India) Offcampus."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 make child to parent relation and run bfs as like undirected graph"
                    },
                    {
                        "username": "pheoniX__7",
                        "content": "Should be marked as Hard... pretty typical problem of BFS + Hashing. Although i feel it could\\'ve been done easier using Graph conversion."
                    },
                    {
                        "username": "kaushalmistry",
                        "content": "I did it by calculating height at each node.\n\nYou can check the solution if interested in new approach rather than converting to graph.\nhttps://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/solutions/3714031/c-height-calculation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1849239,
                "content": [
                    {
                        "username": "_aka5h",
                        "content": "I turned the tree into an undirected graph and rest was easy DFS."
                    },
                    {
                        "username": "andreicheremukhin",
                        "content": "There is more efficient way without graphs. "
                    },
                    {
                        "username": "nikhil909",
                        "content": "nice you could have just assingned a new parent link like this :\\n\\nclass Solution {\\npublic:\\nTreeNode*str;\\nvoid markParent(TreeNode*root,unordered_map<TreeNode*,TreeNode*>&parent,int target){\\n    queue<TreeNode*>queue;\\n    queue.push(root);\\n    while(!queue.empty()){\\n        TreeNode*curr=queue.front();\\n        queue.pop();\\n        if(curr->val==target)str=curr;\\n        if(curr->left){\\n            parent[curr->left]=curr;\\n            queue.push(curr->left);\\n        }\\n         if(curr->right){\\n            parent[curr->right]=curr;\\n            queue.push(curr->right);\\n        }\\n    }\\n}\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<TreeNode*,TreeNode*>parent;\\n        markParent(root,parent,start);\\n        unordered_map<TreeNode*,bool>vis;\\n        queue<TreeNode*>q;\\n        q.push(str);\\n        vis[str]=1;\\n        int level=0;\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n          auto curr=q.front();\\n          q.pop();\\n          if(curr->left&&!vis[curr->left]){\\n              vis[curr->left]=1;\\n              q.push(curr->left);\\n          }\\n         if(curr->right&&!vis[curr->right]){\\n              vis[curr->right]=1;\\n              q.push(curr->right);\\n          }\\n            if(parent[curr]&&!vis[parent[curr]]){\\n              vis[parent[curr]]=1;\\n              q.push(parent[curr]);\\n          }\\n            }\\n            level++;\\n        }\\n        return level-1;\\n    }\\n};"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "# ***My easy solution-***\\nhttps://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/solutions/3362186/simplest-approach-c/\\n\\nQuestion is similar to burning tree (GFG), should be marked HARD."
                    },
                    {
                        "username": "sohamleet",
                        "content": "This question was asked in Tech Interview round of GoldmanSach Internship in 2022 (India) Offcampus."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 make child to parent relation and run bfs as like undirected graph"
                    },
                    {
                        "username": "pheoniX__7",
                        "content": "Should be marked as Hard... pretty typical problem of BFS + Hashing. Although i feel it could\\'ve been done easier using Graph conversion."
                    },
                    {
                        "username": "kaushalmistry",
                        "content": "I did it by calculating height at each node.\n\nYou can check the solution if interested in new approach rather than converting to graph.\nhttps://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/solutions/3714031/c-height-calculation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 2012665,
                "content": [
                    {
                        "username": "_aka5h",
                        "content": "I turned the tree into an undirected graph and rest was easy DFS."
                    },
                    {
                        "username": "andreicheremukhin",
                        "content": "There is more efficient way without graphs. "
                    },
                    {
                        "username": "nikhil909",
                        "content": "nice you could have just assingned a new parent link like this :\\n\\nclass Solution {\\npublic:\\nTreeNode*str;\\nvoid markParent(TreeNode*root,unordered_map<TreeNode*,TreeNode*>&parent,int target){\\n    queue<TreeNode*>queue;\\n    queue.push(root);\\n    while(!queue.empty()){\\n        TreeNode*curr=queue.front();\\n        queue.pop();\\n        if(curr->val==target)str=curr;\\n        if(curr->left){\\n            parent[curr->left]=curr;\\n            queue.push(curr->left);\\n        }\\n         if(curr->right){\\n            parent[curr->right]=curr;\\n            queue.push(curr->right);\\n        }\\n    }\\n}\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<TreeNode*,TreeNode*>parent;\\n        markParent(root,parent,start);\\n        unordered_map<TreeNode*,bool>vis;\\n        queue<TreeNode*>q;\\n        q.push(str);\\n        vis[str]=1;\\n        int level=0;\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n          auto curr=q.front();\\n          q.pop();\\n          if(curr->left&&!vis[curr->left]){\\n              vis[curr->left]=1;\\n              q.push(curr->left);\\n          }\\n         if(curr->right&&!vis[curr->right]){\\n              vis[curr->right]=1;\\n              q.push(curr->right);\\n          }\\n            if(parent[curr]&&!vis[parent[curr]]){\\n              vis[parent[curr]]=1;\\n              q.push(parent[curr]);\\n          }\\n            }\\n            level++;\\n        }\\n        return level-1;\\n    }\\n};"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "# ***My easy solution-***\\nhttps://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/solutions/3362186/simplest-approach-c/\\n\\nQuestion is similar to burning tree (GFG), should be marked HARD."
                    },
                    {
                        "username": "sohamleet",
                        "content": "This question was asked in Tech Interview round of GoldmanSach Internship in 2022 (India) Offcampus."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 make child to parent relation and run bfs as like undirected graph"
                    },
                    {
                        "username": "pheoniX__7",
                        "content": "Should be marked as Hard... pretty typical problem of BFS + Hashing. Although i feel it could\\'ve been done easier using Graph conversion."
                    },
                    {
                        "username": "kaushalmistry",
                        "content": "I did it by calculating height at each node.\n\nYou can check the solution if interested in new approach rather than converting to graph.\nhttps://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/solutions/3714031/c-height-calculation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1965525,
                "content": [
                    {
                        "username": "_aka5h",
                        "content": "I turned the tree into an undirected graph and rest was easy DFS."
                    },
                    {
                        "username": "andreicheremukhin",
                        "content": "There is more efficient way without graphs. "
                    },
                    {
                        "username": "nikhil909",
                        "content": "nice you could have just assingned a new parent link like this :\\n\\nclass Solution {\\npublic:\\nTreeNode*str;\\nvoid markParent(TreeNode*root,unordered_map<TreeNode*,TreeNode*>&parent,int target){\\n    queue<TreeNode*>queue;\\n    queue.push(root);\\n    while(!queue.empty()){\\n        TreeNode*curr=queue.front();\\n        queue.pop();\\n        if(curr->val==target)str=curr;\\n        if(curr->left){\\n            parent[curr->left]=curr;\\n            queue.push(curr->left);\\n        }\\n         if(curr->right){\\n            parent[curr->right]=curr;\\n            queue.push(curr->right);\\n        }\\n    }\\n}\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<TreeNode*,TreeNode*>parent;\\n        markParent(root,parent,start);\\n        unordered_map<TreeNode*,bool>vis;\\n        queue<TreeNode*>q;\\n        q.push(str);\\n        vis[str]=1;\\n        int level=0;\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n          auto curr=q.front();\\n          q.pop();\\n          if(curr->left&&!vis[curr->left]){\\n              vis[curr->left]=1;\\n              q.push(curr->left);\\n          }\\n         if(curr->right&&!vis[curr->right]){\\n              vis[curr->right]=1;\\n              q.push(curr->right);\\n          }\\n            if(parent[curr]&&!vis[parent[curr]]){\\n              vis[parent[curr]]=1;\\n              q.push(parent[curr]);\\n          }\\n            }\\n            level++;\\n        }\\n        return level-1;\\n    }\\n};"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "# ***My easy solution-***\\nhttps://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/solutions/3362186/simplest-approach-c/\\n\\nQuestion is similar to burning tree (GFG), should be marked HARD."
                    },
                    {
                        "username": "sohamleet",
                        "content": "This question was asked in Tech Interview round of GoldmanSach Internship in 2022 (India) Offcampus."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 make child to parent relation and run bfs as like undirected graph"
                    },
                    {
                        "username": "pheoniX__7",
                        "content": "Should be marked as Hard... pretty typical problem of BFS + Hashing. Although i feel it could\\'ve been done easier using Graph conversion."
                    },
                    {
                        "username": "kaushalmistry",
                        "content": "I did it by calculating height at each node.\n\nYou can check the solution if interested in new approach rather than converting to graph.\nhttps://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/solutions/3714031/c-height-calculation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1956416,
                "content": [
                    {
                        "username": "_aka5h",
                        "content": "I turned the tree into an undirected graph and rest was easy DFS."
                    },
                    {
                        "username": "andreicheremukhin",
                        "content": "There is more efficient way without graphs. "
                    },
                    {
                        "username": "nikhil909",
                        "content": "nice you could have just assingned a new parent link like this :\\n\\nclass Solution {\\npublic:\\nTreeNode*str;\\nvoid markParent(TreeNode*root,unordered_map<TreeNode*,TreeNode*>&parent,int target){\\n    queue<TreeNode*>queue;\\n    queue.push(root);\\n    while(!queue.empty()){\\n        TreeNode*curr=queue.front();\\n        queue.pop();\\n        if(curr->val==target)str=curr;\\n        if(curr->left){\\n            parent[curr->left]=curr;\\n            queue.push(curr->left);\\n        }\\n         if(curr->right){\\n            parent[curr->right]=curr;\\n            queue.push(curr->right);\\n        }\\n    }\\n}\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<TreeNode*,TreeNode*>parent;\\n        markParent(root,parent,start);\\n        unordered_map<TreeNode*,bool>vis;\\n        queue<TreeNode*>q;\\n        q.push(str);\\n        vis[str]=1;\\n        int level=0;\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n          auto curr=q.front();\\n          q.pop();\\n          if(curr->left&&!vis[curr->left]){\\n              vis[curr->left]=1;\\n              q.push(curr->left);\\n          }\\n         if(curr->right&&!vis[curr->right]){\\n              vis[curr->right]=1;\\n              q.push(curr->right);\\n          }\\n            if(parent[curr]&&!vis[parent[curr]]){\\n              vis[parent[curr]]=1;\\n              q.push(parent[curr]);\\n          }\\n            }\\n            level++;\\n        }\\n        return level-1;\\n    }\\n};"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "# ***My easy solution-***\\nhttps://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/solutions/3362186/simplest-approach-c/\\n\\nQuestion is similar to burning tree (GFG), should be marked HARD."
                    },
                    {
                        "username": "sohamleet",
                        "content": "This question was asked in Tech Interview round of GoldmanSach Internship in 2022 (India) Offcampus."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 make child to parent relation and run bfs as like undirected graph"
                    },
                    {
                        "username": "pheoniX__7",
                        "content": "Should be marked as Hard... pretty typical problem of BFS + Hashing. Although i feel it could\\'ve been done easier using Graph conversion."
                    },
                    {
                        "username": "kaushalmistry",
                        "content": "I did it by calculating height at each node.\n\nYou can check the solution if interested in new approach rather than converting to graph.\nhttps://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/solutions/3714031/c-height-calculation-easy-to-understand/"
                    }
                ]
            },
            {
                "id": 1955025,
                "content": [
                    {
                        "username": "_aka5h",
                        "content": "I turned the tree into an undirected graph and rest was easy DFS."
                    },
                    {
                        "username": "andreicheremukhin",
                        "content": "There is more efficient way without graphs. "
                    },
                    {
                        "username": "nikhil909",
                        "content": "nice you could have just assingned a new parent link like this :\\n\\nclass Solution {\\npublic:\\nTreeNode*str;\\nvoid markParent(TreeNode*root,unordered_map<TreeNode*,TreeNode*>&parent,int target){\\n    queue<TreeNode*>queue;\\n    queue.push(root);\\n    while(!queue.empty()){\\n        TreeNode*curr=queue.front();\\n        queue.pop();\\n        if(curr->val==target)str=curr;\\n        if(curr->left){\\n            parent[curr->left]=curr;\\n            queue.push(curr->left);\\n        }\\n         if(curr->right){\\n            parent[curr->right]=curr;\\n            queue.push(curr->right);\\n        }\\n    }\\n}\\n    int amountOfTime(TreeNode* root, int start) {\\n        unordered_map<TreeNode*,TreeNode*>parent;\\n        markParent(root,parent,start);\\n        unordered_map<TreeNode*,bool>vis;\\n        queue<TreeNode*>q;\\n        q.push(str);\\n        vis[str]=1;\\n        int level=0;\\n        while(!q.empty()){\\n            int n=q.size();\\n            for(int i=0;i<n;i++){\\n          auto curr=q.front();\\n          q.pop();\\n          if(curr->left&&!vis[curr->left]){\\n              vis[curr->left]=1;\\n              q.push(curr->left);\\n          }\\n         if(curr->right&&!vis[curr->right]){\\n              vis[curr->right]=1;\\n              q.push(curr->right);\\n          }\\n            if(parent[curr]&&!vis[parent[curr]]){\\n              vis[parent[curr]]=1;\\n              q.push(parent[curr]);\\n          }\\n            }\\n            level++;\\n        }\\n        return level-1;\\n    }\\n};"
                    },
                    {
                        "username": "SanskarGoyal_14",
                        "content": "# ***My easy solution-***\\nhttps://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/solutions/3362186/simplest-approach-c/\\n\\nQuestion is similar to burning tree (GFG), should be marked HARD."
                    },
                    {
                        "username": "sohamleet",
                        "content": "This question was asked in Tech Interview round of GoldmanSach Internship in 2022 (India) Offcampus."
                    },
                    {
                        "username": "devesh_kumar_kushwaha",
                        "content": "\\uD83D\\uDFE2 make child to parent relation and run bfs as like undirected graph"
                    },
                    {
                        "username": "pheoniX__7",
                        "content": "Should be marked as Hard... pretty typical problem of BFS + Hashing. Although i feel it could\\'ve been done easier using Graph conversion."
                    },
                    {
                        "username": "kaushalmistry",
                        "content": "I did it by calculating height at each node.\n\nYou can check the solution if interested in new approach rather than converting to graph.\nhttps://leetcode.com/problems/amount-of-time-for-binary-tree-to-be-infected/solutions/3714031/c-height-calculation-easy-to-understand/"
                    }
                ]
            }
        ]
    }
]