[
    {
        "title": "Find Mode in Binary Search Tree",
        "question_content": "Given the root of a binary search tree (BST) with duplicates, return all the mode(s) (i.e., the most frequently occurred element) in it.\nIf the tree has more than one mode, return them in any order.\nAssume a BST is defined as follows:\n\n\tThe left subtree of a node contains only nodes with keys less than or equal to the node's key.\n\tThe right subtree of a node contains only nodes with keys greater than or equal to the node's key.\n\tBoth the left and right subtrees must also be binary search trees.\n\n&nbsp;\nExample 1:\n\nInput: root = [1,null,2,2]\nOutput: [2]\n\nExample 2:\n\nInput: root = [0]\nOutput: [0]\n\n&nbsp;\nConstraints:\n\n\tThe number of nodes in the tree is in the range [1, 104].\n\t-105 <= Node.val <= 105\n\n&nbsp;\nFollow up: Could you do that without using any extra space? (Assume that the implicit stack space incurred due to recursion does not count).",
        "solutions": [
            {
                "id": 98101,
                "title": "proper-o-1-space",
                "content": "I've seen several solutions claimed to be O(1) space, but I disagree. They traverse the tree in in-order and keep track of the current set of modes (among other things). But that's not O(1) space, not even when disregarding recursion stack space (as explicitly allowed) and result space (not mentioned but reasonable). The set's contents aren't on stack space, so it can't be disregarded that way. And if the values are for example 1,2,3,4,...,n-2,n-1,n-1 (unique values followed by one double value), the set grows to &Omega;(n) and it can't be disregarded because the result only has size 1.\\n\\nI think the way to do it properly is to do two passes. One to find the highest number of occurrences of any value, and then a second pass to collect all values occurring that often. Any other ideas?\\n\\nHere's a (two-pass) solution that I think can rightfully be called O(1) space. Both passes keep track of the current value etc, and the second pass additionally collects the modes in the result array. I took the value handling out of the in-order traversal into its own function for clarity. Also, this way you could very easily replace my recursive in-order traversal with for example Morris traversal. Then you wouldn't even need to disregard the recursion stack space in order to claim O(1) extra space usage.\\n\\n```\\npublic class Solution {\\n    \\n    public int[] findMode(TreeNode root) {\\n        inorder(root);\\n        modes = new int[modeCount];\\n        modeCount = 0;\\n        currCount = 0;\\n        inorder(root);\\n        return modes;\\n    }\\n\\n    private int currVal;\\n    private int currCount = 0;\\n    private int maxCount = 0;\\n    private int modeCount = 0;\\n    \\n    private int[] modes;\\n\\n    private void handleValue(int val) {\\n        if (val != currVal) {\\n            currVal = val;\\n            currCount = 0;\\n        }\\n        currCount++;\\n        if (currCount > maxCount) {\\n            maxCount = currCount;\\n            modeCount = 1;\\n        } else if (currCount == maxCount) {\\n            if (modes != null)\\n                modes[modeCount] = currVal;\\n            modeCount++;\\n        }\\n    }\\n    \\n    private void inorder(TreeNode root) {\\n        if (root == null) return;\\n        inorder(root.left);\\n        handleValue(root.val);\\n        inorder(root.right);\\n    }\\n}\\n```\\n\\n**Edit:** Here's Morris traversal, just replace my previous `inorder` function with this. I hadn't realized it earlier, but having my separate `handleValue` function doesn't just nicely separate the traversal logic from this problem's logic, but it's also beneficial for Morris traversal because I'm calling `handleValue` from two different places in the code!\\n```\\n    private void inorder(TreeNode root) {\\n        TreeNode node = root;\\n        while (node != null) {\\n            if (node.left == null) {\\n                handleValue(node.val);\\n                node = node.right;\\n            } else {\\n                TreeNode prev = node.left;\\n                while (prev.right != null && prev.right != node)\\n                    prev = prev.right;\\n                if (prev.right == null) {\\n                    prev.right = node;\\n                    node = node.left;\\n                } else {\\n                    prev.right = null;\\n                    handleValue(node.val);\\n                    node = node.right;\\n                }\\n            }\\n        }\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    \\n    public int[] findMode(TreeNode root) {\\n        inorder(root);\\n        modes = new int[modeCount];\\n        modeCount = 0;\\n        currCount = 0;\\n        inorder(root);\\n        return modes;\\n    }\\n\\n    private int currVal;\\n    private int currCount = 0;\\n    private int maxCount = 0;\\n    private int modeCount = 0;\\n    \\n    private int[] modes;\\n\\n    private void handleValue(int val) {\\n        if (val != currVal) {\\n            currVal = val;\\n            currCount = 0;\\n        }\\n        currCount++;\\n        if (currCount > maxCount) {\\n            maxCount = currCount;\\n            modeCount = 1;\\n        } else if (currCount == maxCount) {\\n            if (modes != null)\\n                modes[modeCount] = currVal;\\n            modeCount++;\\n        }\\n    }\\n    \\n    private void inorder(TreeNode root) {\\n        if (root == null) return;\\n        inorder(root.left);\\n        handleValue(root.val);\\n        inorder(root.right);\\n    }\\n}\\n```\n```\\n    private void inorder(TreeNode root) {\\n        TreeNode node = root;\\n        while (node != null) {\\n            if (node.left == null) {\\n                handleValue(node.val);\\n                node = node.right;\\n            } else {\\n                TreeNode prev = node.left;\\n                while (prev.right != null && prev.right != node)\\n                    prev = prev.right;\\n                if (prev.right == null) {\\n                    prev.right = node;\\n                    node = node.left;\\n                } else {\\n                    prev.right = null;\\n                    handleValue(node.val);\\n                    node = node.right;\\n                }\\n            }\\n        }\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98100,
                "title": "java-4ms-beats-100-extra-o-1-solution-no-map",
                "content": "```\\npublic class Solution {\\n    Integer prev = null;\\n    int count = 1;\\n    int max = 0;\\n    public int[] findMode(TreeNode root) {\\n        if (root == null) return new int[0];\\n        \\n        List<Integer> list = new ArrayList<>();\\n        traverse(root, list);\\n        \\n        int[] res = new int[list.size()];\\n        for (int i = 0; i < list.size(); ++i) res[i] = list.get(i);\\n        return res;\\n    }\\n    \\n    private void traverse(TreeNode root, List<Integer> list) {\\n        if (root == null) return;\\n        traverse(root.left, list);\\n        if (prev != null) {\\n            if (root.val == prev)\\n                count++;\\n            else\\n                count = 1;\\n        }\\n        if (count > max) {\\n            max = count;\\n            list.clear();\\n            list.add(root.val);\\n        } else if (count == max) {\\n            list.add(root.val);\\n        }\\n        prev = root.val;\\n        traverse(root.right, list);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    Integer prev = null;\\n    int count = 1;\\n    int max = 0;\\n    public int[] findMode(TreeNode root) {\\n        if (root == null) return new int[0];\\n        \\n        List<Integer> list = new ArrayList<>();\\n        traverse(root, list);\\n        \\n        int[] res = new int[list.size()];\\n        for (int i = 0; i < list.size(); ++i) res[i] = list.get(i);\\n        return res;\\n    }\\n    \\n    private void traverse(TreeNode root, List<Integer> list) {\\n        if (root == null) return;\\n        traverse(root.left, list);\\n        if (prev != null) {\\n            if (root.val == prev)\\n                count++;\\n            else\\n                count = 1;\\n        }\\n        if (count > max) {\\n            max = count;\\n            list.clear();\\n            list.add(root.val);\\n        } else if (count == max) {\\n            list.add(root.val);\\n        }\\n        prev = root.val;\\n        traverse(root.right, list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 406028,
                "title": "python-inorder-traversal-o-1-space-with-explanation",
                "content": "Inorder traversal of a BST will find the nodes in ascending order. So just compare the current node to the previous, and if they match, increase the current count of duplicate values by 1. If they don\\'t match, reset the current count to 1. Compare the current count to the max count found so far. If they match, append the current value to the result list. If the current count of duplicates exceeds the max count, create a new result list with just the current value.\\n```\\nclass Solution(object):\\n    prev = None\\n    max_count = 0\\n    current_count = 0 \\n    result = []\\n\\n    def findMode(self, root):\\n        self.dfs(root)\\n        return self.result\\n\\n    def dfs(self, node):\\n        if not node: return\\n        self.dfs(node.left)\\n        self.current_count = 1 if node.val != self.prev else self.current_count + 1\\n        if self.current_count == self.max_count:\\n            self.result.append(node.val)\\n        elif self.current_count > self.max_count:\\n            self.result = [node.val]\\n            self.max_count = self.current_count\\n        self.prev = node.val\\n        self.dfs(node.right)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution(object):\\n    prev = None\\n    max_count = 0\\n    current_count = 0 \\n    result = []\\n\\n    def findMode(self, root):\\n        self.dfs(root)\\n        return self.result\\n\\n    def dfs(self, node):\\n        if not node: return\\n        self.dfs(node.left)\\n        self.current_count = 1 if node.val != self.prev else self.current_count + 1\\n        if self.current_count == self.max_count:\\n            self.result.append(node.val)\\n        elif self.current_count > self.max_count:\\n            self.result = [node.val]\\n            self.max_count = self.current_count\\n        self.prev = node.val\\n        self.dfs(node.right)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98191,
                "title": "c-o-n-time-and-o-1-space-by-inorder-traversal",
                "content": "The basic idea is that the inorder traversal of the BST is in ascending order. For example, the inorder traversal of the BST [2, 1, 3] is [1, 2, 3]. Then we can easily find the most frequently occurred elements by comparing the successive elements.\\n```\\nclass Solution {\\npublic:\\n    int maxFreq = 0, currFreq = 0, precursor = INT_MIN;\\n    vector<int> res;\\n\\n    vector<int> findMode(TreeNode *root)\\n    {\\n        inorderTraversal(root);\\n        return res;\\n    }\\n\\n    void inorderTraversal(TreeNode *root)\\n    {\\n        if (root == NULL) return; // Stop condition\\n        inorderTraversal(root->left); // Traverse left subtree\\n        if (precursor == root->val) currFreq++;\\n        else currFreq = 1;\\n        if (currFreq > maxFreq)\\n        {// Current node value has higher frequency than any previous visited\\n            res.clear();\\n            maxFreq = currFreq;\\n            res.push_back(root->val);\\n        }\\n        else if (currFreq == maxFreq)\\n        {// Current node value has a frequency equal to the highest of previous visited\\n            res.push_back(root->val);\\n        }\\n        precursor = root->val; // Update the precursor\\n        inorderTraversal(root->right); // Traverse right subtree\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFreq = 0, currFreq = 0, precursor = INT_MIN;\\n    vector<int> res;\\n\\n    vector<int> findMode(TreeNode *root)\\n    {\\n        inorderTraversal(root);\\n        return res;\\n    }\\n\\n    void inorderTraversal(TreeNode *root)\\n    {\\n        if (root == NULL) return; // Stop condition\\n        inorderTraversal(root->left); // Traverse left subtree\\n        if (precursor == root->val) currFreq++;\\n        else currFreq = 1;\\n        if (currFreq > maxFreq)\\n        {// Current node value has higher frequency than any previous visited\\n            res.clear();\\n            maxFreq = currFreq;\\n            res.push_back(root->val);\\n        }\\n        else if (currFreq == maxFreq)\\n        {// Current node value has a frequency equal to the highest of previous visited\\n            res.push_back(root->val);\\n        }\\n        precursor = root->val; // Update the precursor\\n        inorderTraversal(root->right); // Traverse right subtree\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98104,
                "title": "simple-python-explanation",
                "content": "Let's first visit every node in the tree and count it's value.  We can traverse the tree with a dfs.\\nAfter we have every value counted, let's look at values with the highest count and return all of them.\\n\\n```\\ncount = collections.Counter()\\n\\ndef dfs(node):\\n    if node:\\n        count[node.val] += 1\\n        dfs(node.left)\\n        dfs(node.right)\\n        \\ndfs(root)\\nmax_ct = max(count.itervalues())\\nreturn [k for k, v in count.iteritems() if v == max_ct]\\n```\\n\\n<hr>\\n\\nIf we are unfamiliar with collections.Counter, we could have also counted the values with a simple dictionary, changing two lines:\\n\\n```\\ncount = {}\\ncount[node.val] = count.get(node.val, 0) + 1\\n```",
                "solutionTags": [],
                "code": "```\\ncount = collections.Counter()\\n\\ndef dfs(node):\\n    if node:\\n        count[node.val] += 1\\n        dfs(node.left)\\n        dfs(node.right)\\n        \\ndfs(root)\\nmax_ct = max(count.itervalues())\\nreturn [k for k, v in count.iteritems() if v == max_ct]\\n```\n```\\ncount = {}\\ncount[node.val] = count.get(node.val, 0) + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1351639,
                "title": "python-easy-to-read-recursion",
                "content": "```\\nclass Solution:\\n    def findMode(self, root: TreeNode) -> List[int]:\\n        \\n        lst = []                            # result\\n        dic = {}                            # put node value in dictionary\\n        maxi = 0                            # the frequence of the most frequently occurred element\\n        \\n        def find(root):\\n            \\n            if not root:                    # leaf node\\n                return\\n            \\n            if root.val in dic:             # if node value is in the dictionry, value + 1\\n                dic[root.val] += 1\\n            else:\\n                dic[root.val] = 1           # if node value is not in the dictionary, value = 1\\n            \\n            find(root.left)\\n            find(root.right)\\n            \\n            return \\n     \\n        find(root)\\n        dicval_list = list(dic.values())    # list all the values in dictionary\\n        maxi = max(dicval_list)             # find maximum value in dictionary\\n        for key, value in dic.items():\\n            if value == maxi:               # if value = maximum, append this key to list\\n                lst.append(key)\\n        return lst\\n```\\nAny suggestions are welcome.\\nIf you like my solution, please encourage me by upvoting my post.",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findMode(self, root: TreeNode) -> List[int]:\\n        \\n        lst = []                            # result\\n        dic = {}                            # put node value in dictionary\\n        maxi = 0                            # the frequence of the most frequently occurred element\\n        \\n        def find(root):\\n            \\n            if not root:                    # leaf node\\n                return\\n            \\n            if root.val in dic:             # if node value is in the dictionry, value + 1\\n                dic[root.val] += 1\\n            else:\\n                dic[root.val] = 1           # if node value is not in the dictionary, value = 1\\n            \\n            find(root.left)\\n            find(root.right)\\n            \\n            return \\n     \\n        find(root)\\n        dicval_list = list(dic.values())    # list all the values in dictionary\\n        maxi = max(dicval_list)             # find maximum value in dictionary\\n        for key, value in dic.items():\\n            if value == maxi:               # if value = maximum, append this key to list\\n                lst.append(key)\\n        return lst\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98103,
                "title": "java-ac-solution",
                "content": "O(n) time O(n) space\\n```\\npublic class Solution {\\n    Map<Integer, Integer> map; \\n    int max = 0;\\n    public int[] findMode(TreeNode root) {\\n        if(root==null) return new int[0]; \\n        this.map = new HashMap<>(); \\n        \\n        inorder(root); \\n        \\n        List<Integer> list = new LinkedList<>();\\n        for(int key: map.keySet()){\\n            if(map.get(key) == max) list.add(key);\\n        }\\n        \\n        int[] res = new int[list.size()];\\n        for(int i = 0; i<res.length; i++) res[i] = list.get(i);\\n        return res; \\n    }\\n    \\n    private void inorder(TreeNode node){\\n        if(node.left!=null) inorder(node.left);\\n        map.put(node.val, map.getOrDefault(node.val, 0)+1);\\n        max = Math.max(max, map.get(node.val));\\n        if(node.right!=null) inorder(node.right); \\n    }\\n}\\n```\\nJust travel the tree and count, find the those with max counts. Nothing much. Spent 10min on figuring out what is mode....\\n\\nIf using this method (hashmap), inorder/preorder/postorder gives the same result. Because essentially you just travel the entire nodes and count. And BST is not necessary. This method works for any tree.",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    Map<Integer, Integer> map; \\n    int max = 0;\\n    public int[] findMode(TreeNode root) {\\n        if(root==null) return new int[0]; \\n        this.map = new HashMap<>(); \\n        \\n        inorder(root); \\n        \\n        List<Integer> list = new LinkedList<>();\\n        for(int key: map.keySet()){\\n            if(map.get(key) == max) list.add(key);\\n        }\\n        \\n        int[] res = new int[list.size()];\\n        for(int i = 0; i<res.length; i++) res[i] = list.get(i);\\n        return res; \\n    }\\n    \\n    private void inorder(TreeNode node){\\n        if(node.left!=null) inorder(node.left);\\n        map.put(node.val, map.getOrDefault(node.val, 0)+1);\\n        max = Math.max(max, map.get(node.val));\\n        if(node.right!=null) inorder(node.right); \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98107,
                "title": "11-liner-c-o-n-time-o-1-extra-space-in-order-traversal-detailed-explanation",
                "content": "**Key Observation:** Obviously, it is very easy to get modes from a ***sorted array*** since all duplicates are ***consecutive***. \\n\\nAn in-order traversal of BST gives exactly a sorted sequence.\\n\\nNaturally, in-order traversal takes `O(N)` time. To achieve `O(1)` extra space, we cannot store the array of in-order node values. But all modes can be found in two traversals:\\n1. Find max frequency of node values `mfq` by counting and update number of duplicates.\\n2. Store a mode into result `vector<int> modes` whenever the duplicates match `mfq` from first traversal.\\n\\nNote: we can accomplish both traversals by keeping 2 variables `pre` (previous node value) and `cnt` (count of current duplicates):\\n* Update `cnt` by `++(cnt*=(r->val==pre))`, i.e., `r->val==pre? ++cnt : cnt=1;`\\n* Update `pre` by simply copying `pre = r->val;`\\n```cpp\\n    vector<int> modes;\\n    \\n    vector<int> findMode(TreeNode* r) {\\n      int mfq/*max freq*/, pre/*previous val*/, cnt/*duplicates count*/;\\n      getMaxFreq(r, mfq=0, pre, cnt=0); // in-order traversal to get max frequency\\n      getMode(r, mfq, pre, cnt=0);      // in-order traversal to get all modes\\n      return modes;\\n    }\\n    \\n    void getMaxFreq(TreeNode* r, int& mfq, int& pre, int& cnt) {\\n      if (!r) return;\\n      getMaxFreq(r->left, mfq, pre, cnt);\\n      getMaxFreq(r->right, mfq=max(mfq,cnt), pre=r->val, ++(cnt*=(r->val==pre)));\\n    }\\n    \\n    void getMode(TreeNode* r, const int mfq, int& pre, int& cnt) {\\n      if (!r) return;\\n      getMode(r->left, mfq, pre, cnt);\\n      if (mfq == ++(cnt*=(r->val==pre))) modes.push_back(r->val);\\n      getMode(r->right, mfq, pre=r->val, cnt);\\n    }\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree"
                ],
                "code": "```cpp\\n    vector<int> modes;\\n    \\n    vector<int> findMode(TreeNode* r) {\\n      int mfq/*max freq*/, pre/*previous val*/, cnt/*duplicates count*/;\\n      getMaxFreq(r, mfq=0, pre, cnt=0); // in-order traversal to get max frequency\\n      getMode(r, mfq, pre, cnt=0);      // in-order traversal to get all modes\\n      return modes;\\n    }\\n    \\n    void getMaxFreq(TreeNode* r, int& mfq, int& pre, int& cnt) {\\n      if (!r) return;\\n      getMaxFreq(r->left, mfq, pre, cnt);\\n      getMaxFreq(r->right, mfq=max(mfq,cnt), pre=r->val, ++(cnt*=(r->val==pre)));\\n    }\\n    \\n    void getMode(TreeNode* r, const int mfq, int& pre, int& cnt) {\\n      if (!r) return;\\n      getMode(r->left, mfq, pre, cnt);\\n      if (mfq == ++(cnt*=(r->val==pre))) modes.push_back(r->val);\\n      getMode(r->right, mfq, pre=r->val, cnt);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 98196,
                "title": "4ms-java-solution-beats-100-o-1-space-recursion-stack-space-doesn-t-count",
                "content": "Just simple inorder traversal, whenever current frequency for current number is bigger than max frequency, update the result.\\n```\\npublic class Solution {\\n    List<Integer> ans = new ArrayList<>();\\n    Integer pre;\\n    int maxFreq = 0, curFreq = 0;\\n    public int[] findMode(TreeNode root) {\\n        traverse(root);\\n        int[] res = new int[ans.size()];\\n        for (int i = 0; i < res.length; i++) res[i] = ans.get(i);\\n        return res;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        //inorder traversal\\n        traverse(root.left);\\n        if (pre != null && root.val == pre) {\\n            curFreq++;\\n        } else {\\n            curFreq = 1;\\n        }\\n        if (curFreq == maxFreq) {\\n            ans.add(root.val);\\n        } else if (curFreq > maxFreq) {\\n            maxFreq = curFreq;\\n            ans = new ArrayList<>();\\n            ans.add(root.val);\\n        } \\n\\n        pre = root.val;\\n        traverse(root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    List<Integer> ans = new ArrayList<>();\\n    Integer pre;\\n    int maxFreq = 0, curFreq = 0;\\n    public int[] findMode(TreeNode root) {\\n        traverse(root);\\n        int[] res = new int[ans.size()];\\n        for (int i = 0; i < res.length; i++) res[i] = ans.get(i);\\n        return res;\\n    }\\n    \\n    private void traverse(TreeNode root) {\\n        if (root == null) {\\n            return;\\n        }\\n        //inorder traversal\\n        traverse(root.left);\\n        if (pre != null && root.val == pre) {\\n            curFreq++;\\n        } else {\\n            curFreq = 1;\\n        }\\n        if (curFreq == maxFreq) {\\n            ans.add(root.val);\\n        } else if (curFreq > maxFreq) {\\n            maxFreq = curFreq;\\n            ans = new ArrayList<>();\\n            ans.add(root.val);\\n        } \\n\\n        pre = root.val;\\n        traverse(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98165,
                "title": "c-dfs-time-o-n-space-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        unordered_map<int, int> map;\\n        vector<int> result;\\n        int modeCount = getModeCount(root, map);\\n        \\n        for(pair<int,int> p : map) {\\n            if(p.second == modeCount) {\\n                result.push_back(p.first);\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n    \\n    /**\\n     * Traverse the tree using depth first search.\\n     * Return the mode count (i.e. The count of a repeated number that occurs the most.) of the tree.\\n     */\\n    int getModeCount(TreeNode* root, unordered_map<int, int> &map) {\\n        if(root == NULL)\\n            return 0;\\n        \\n        if(map.find(root->val) == map.end()) {\\n            map.insert(pair<int, int>(root->val, 1));\\n        }\\n        else {\\n            map[root->val]++;\\n        }\\n        \\n        return max(map[root->val], max(getModeCount(root->left, map), getModeCount(root->right, map)));\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        unordered_map<int, int> map;\\n        vector<int> result;\\n        int modeCount = getModeCount(root, map);\\n        \\n        for(pair<int,int> p : map) {\\n            if(p.second == modeCount) {\\n                result.push_back(p.first);\\n            }\\n        }\\n        \\n        return result;\\n        \\n    }\\n    \\n    /**\\n     * Traverse the tree using depth first search.\\n     * Return the mode count (i.e. The count of a repeated number that occurs the most.) of the tree.\\n     */\\n    int getModeCount(TreeNode* root, unordered_map<int, int> &map) {\\n        if(root == NULL)\\n            return 0;\\n        \\n        if(map.find(root->val) == map.end()) {\\n            map.insert(pair<int, int>(root->val, 1));\\n        }\\n        else {\\n            map[root->val]++;\\n        }\\n        \\n        return max(map[root->val], max(getModeCount(root->left, map), getModeCount(root->right, map)));\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 984496,
                "title": "java-hashmap-easy-to-understand",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int maxCount = 1;\\n    \\n    public int[] findMode(TreeNode root) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        findMode(root, map);\\n        \\n        int[] result = new int[map.size()];\\n        int index = 0;\\n        for(Integer key: map.keySet()){\\n            if(map.get(key) == maxCount){\\n                result[index++] = key;\\n            }\\n        }\\n        \\n        return Arrays.copyOf(result, index);\\n    }\\n    \\n    private void findMode(TreeNode root, Map<Integer, Integer> map){\\n        if(root == null) {\\n            return;\\n        } else if(map.containsKey(root.val)) {\\n            int count = map.get(root.val)+1;\\n            map.put(root.val, count);\\n            maxCount = Math.max(maxCount, count);\\n        } else {\\n            map.put(root.val, 1);\\n        }\\n        \\n        findMode(root.left, map);\\n        findMode(root.right, map);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int maxCount = 1;\\n    \\n    public int[] findMode(TreeNode root) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        findMode(root, map);\\n        \\n        int[] result = new int[map.size()];\\n        int index = 0;\\n        for(Integer key: map.keySet()){\\n            if(map.get(key) == maxCount){\\n                result[index++] = key;\\n            }\\n        }\\n        \\n        return Arrays.copyOf(result, index);\\n    }\\n    \\n    private void findMode(TreeNode root, Map<Integer, Integer> map){\\n        if(root == null) {\\n            return;\\n        } else if(map.containsKey(root.val)) {\\n            int count = map.get(root.val)+1;\\n            map.put(root.val, count);\\n            maxCount = Math.max(maxCount, count);\\n        } else {\\n            map.put(root.val, 1);\\n        }\\n        \\n        findMode(root.left, map);\\n        findMode(root.right, map);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1282304,
                "title": "c-clean-solution-with-explanation-single-inorder-traversal-o-1-extra-space-o-n-time",
                "content": "Here are the BST properties which I have used in the below solution.\\n* `leftNode <= rootNode <= rightNode`\\n* Another point which some people miss to visualize using the above property is:\\n\\t`All nodes in left Subtree <= rootNode <= All nodes in right subtree`\\n* Using the above two properties, we can conclude that if there are duplicates in the tree, they will always be next to each other in the inOrder traversal of the tree. \\n* Since inOrder traversal will always be in sorted order, so, we can easily keep track of frequency of elements by keeping a single variable and then resetting it once a new element is encountered.\\n* In the meantime, we need to keep a variable which will store the max frequency of any element till now.\\n* If at some point, there is an element whose frequency equals max frequency, we can include it in the answer as per the requirement of this questions.\\n* If the frequency of element is more than maxElement, clear the answer array and insert this new element into answer array.\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxTillNow = -1000000, curr = -1000000, prev = -1000000;\\n    \\n    void inOrder(TreeNode* root, vector<int> &ans) {        \\n        if(root == NULL)\\n            return;\\n        inOrder(root->left, ans);\\n\\t\\t \\n\\t\\t// the last visited element will be inOrder predecessor so if it occurs more than once, it has to be same here because it is a BST\\n        if(root->val == prev)\\n            curr++;\\n        \\n        else if(prev != root->val)\\n            curr = 1;\\n                \\n        if(curr>maxTillNow) {\\n            ans.clear();\\n            ans.push_back(root->val);\\n            maxTillNow = curr;\\n        } \\n        else if(curr == maxTillNow)\\n            ans.push_back(root->val);\\n        \\n        prev = root->val;\\n        inOrder(root->right, ans);\\n    }\\n    \\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> ans;\\n        inOrder(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    int maxTillNow = -1000000, curr = -1000000, prev = -1000000;\\n    \\n    void inOrder(TreeNode* root, vector<int> &ans) {        \\n        if(root == NULL)\\n            return;\\n        inOrder(root->left, ans);\\n\\t\\t \\n\\t\\t// the last visited element will be inOrder predecessor so if it occurs more than once, it has to be same here because it is a BST\\n        if(root->val == prev)\\n            curr++;\\n        \\n        else if(prev != root->val)\\n            curr = 1;\\n                \\n        if(curr>maxTillNow) {\\n            ans.clear();\\n            ans.push_back(root->val);\\n            maxTillNow = curr;\\n        } \\n        else if(curr == maxTillNow)\\n            ans.push_back(root->val);\\n        \\n        prev = root->val;\\n        inOrder(root->right, ans);\\n    }\\n    \\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> ans;\\n        inOrder(root, ans);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98181,
                "title": "ugly-but-straight-forward-java-solution",
                "content": "First, here is the definition of ```Mean, Median, Mode, and Range``` http://www.purplemath.com/modules/meanmode.htm\\n\\nIdea is just traverse through the tree and record (val, count) in a map. After that, find the max count in the map and create return array.\\n\\n```\\npublic class Solution {\\n    int max = 0;\\n    \\n    public int[] findMode(TreeNode root) {\\n        if (root == null) return new int[0];\\n        Map<Integer, Integer> map = new LinkedHashMap<>();\\n        traverse(root, map);\\n        \\n        List<Integer> res = new ArrayList<>();\\n        for (int key: map.keySet()) {\\n            if (map.get(key) == max) {\\n                res.add(key);\\n            }\\n        }\\n        \\n        int[] result = new int[res.size()];\\n        for (int i = 0; i < res.size(); i++) {\\n            result[i] = res.get(i);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void traverse(TreeNode root, Map<Integer, Integer> map) {\\n        if (root == null) return;\\n        \\n        Integer value = map.getOrDefault(root.val, 0) + 1;\\n        max = Math.max(max, value);\\n        map.put(root.val, value);\\n        \\n        traverse(root.left, map);\\n        traverse(root.right, map);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```Mean, Median, Mode, and Range```\n```\\npublic class Solution {\\n    int max = 0;\\n    \\n    public int[] findMode(TreeNode root) {\\n        if (root == null) return new int[0];\\n        Map<Integer, Integer> map = new LinkedHashMap<>();\\n        traverse(root, map);\\n        \\n        List<Integer> res = new ArrayList<>();\\n        for (int key: map.keySet()) {\\n            if (map.get(key) == max) {\\n                res.add(key);\\n            }\\n        }\\n        \\n        int[] result = new int[res.size()];\\n        for (int i = 0; i < res.size(); i++) {\\n            result[i] = res.get(i);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void traverse(TreeNode root, Map<Integer, Integer> map) {\\n        if (root == null) return;\\n        \\n        Integer value = map.getOrDefault(root.val, 0) + 1;\\n        max = Math.max(max, value);\\n        map.put(root.val, value);\\n        \\n        traverse(root.left, map);\\n        traverse(root.right, map);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 809461,
                "title": "c-simple-recursive-dfs-solution-explained-100-time-40-space",
                "content": "We need to do 2 things:\\n* a complete tree traversal to create a frequency map;\\n* and then parse through that to retrieve the keys giving us the most frequent values.\\n\\nFor the first part we use a class variable `f` and populate it running `dfs`, which recursively goes until it finds valid values and stores each of them in `f`, increasing their frequency by `1`.\\n\\nFor the second part, we just have to loop through the key-value pairs in `f`, after having initialised a suppore variable to any value `< 1` in order to keep track of the most frequent element. When we find a value with frequency `== fMax`, we add it to our accumulator variable `res`, while if it has a greater value, we reset `res` to store only it.\\n\\nOnce we are done, we can just return `res` :)\\n\\nThe code:\\n\\n```cpp\\nclass Solution {\\npublic:\\n    unordered_map<int, int> f;\\n    void dfs(TreeNode* root) {\\n        if (!root) return;\\n        else f[root->val]++;\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> res;\\n        int tMax = -1;\\n        dfs(root);\\n        for (auto e: f) {\\n            if (e.second == tMax) res.push_back(e.first);\\n            else if (e.second > tMax) {\\n                tMax = e.second;\\n                res = {e.first};\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Tree",
                    "Recursion"
                ],
                "code": "```cpp\\nclass Solution {\\npublic:\\n    unordered_map<int, int> f;\\n    void dfs(TreeNode* root) {\\n        if (!root) return;\\n        else f[root->val]++;\\n        dfs(root->left);\\n        dfs(root->right);\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> res;\\n        int tMax = -1;\\n        dfs(root);\\n        for (auto e: f) {\\n            if (e.second == tMax) res.push_back(e.first);\\n            else if (e.second > tMax) {\\n                tMax = e.second;\\n                res = {e.first};\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 848001,
                "title": "c-o-1-space-solution",
                "content": "```\\nclass Solution {\\n    vector<int> modes;\\n    int p=INT_MIN,cur,mx=INT_MIN;\\npublic:\\n    #define Node TreeNode\\n    #define all(c) c.begin(), c.end()\\n    void inorder(Node* root) {\\n        if(!root)\\n            return;\\n        if(root->left)\\n            inorder(root->left);\\n        if(p==root->val) cur++;\\n        else cur=1;\\n        if(cur==mx) {\\n            modes.push_back(root->val);\\n        }\\n        if(cur>mx) {\\n            modes.clear();\\n            modes.push_back(root->val);\\n            mx=cur;\\n        }\\n        p=root->val;\\n        if(root->right)\\n            inorder(root->right);\\n    }\\n    vector<int> findMode(Node* root) {\\n        inorder(root);\\n        return modes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    vector<int> modes;\\n    int p=INT_MIN,cur,mx=INT_MIN;\\npublic:\\n    #define Node TreeNode\\n    #define all(c) c.begin(), c.end()\\n    void inorder(Node* root) {\\n        if(!root)\\n            return;\\n        if(root->left)\\n            inorder(root->left);\\n        if(p==root->val) cur++;\\n        else cur=1;\\n        if(cur==mx) {\\n            modes.push_back(root->val);\\n        }\\n        if(cur>mx) {\\n            modes.clear();\\n            modes.push_back(root->val);\\n            mx=cur;\\n        }\\n        p=root->val;\\n        if(root->right)\\n            inorder(root->right);\\n    }\\n    vector<int> findMode(Node* root) {\\n        inorder(root);\\n        return modes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98194,
                "title": "python-solution-with-detailed-explanation",
                "content": "**Solution**\\n\\n**Find Mode in Binary Search Tree** https://leetcode.com/problems/find-mode-in-binary-search-tree/\\n\\n**O(N) time & O(N) Space**\\n* Use a dictionary to store the frequency of each interger. Then simply find the largest frequency and return all the associated keys.\\n* Note we do not use the property of BST in this solution.\\n\\n```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def helper(self, root, cache):\\n        if root == None:\\n            return\\n        cache[root.val] += 1\\n        self.helper(root.left, cache)\\n        self.helper(root.right, cache)\\n        return\\n    \\n    def findMode(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if root == None:\\n            return []\\n        cache = defaultdict(int)\\n        self.helper(root, cache)\\n        max_freq = max(cache.values())\\n        result = [k for k,v in cache.items() if v == max_freq]\\n        return result\\n```\\n\\n**O(N) time and O(1) Space** \\n* Write BST Iterator class which gives the next element in_order. Now the problem reduces to finding mode in a sorted array.\\n* Instead of a BST iterator, we can use a recursive inorder traversal and store a class variable pre to indicate the previous integer.\\n* https://discuss.leetcode.com/topic/77308/4ms-java-solution-beats-100-o-1-space-recursion-stack-space-doesn-t-count\\n\\n**Divide and Conquer**\\n* Mode lies entirely in left subtree, or in right subtree or the middle element is the mode.\\n* Time would be NlogN at best and space O(1)",
                "solutionTags": [],
                "code": "```\\nfrom collections import defaultdict\\nclass Solution(object):\\n    def helper(self, root, cache):\\n        if root == None:\\n            return\\n        cache[root.val] += 1\\n        self.helper(root.left, cache)\\n        self.helper(root.right, cache)\\n        return\\n    \\n    def findMode(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if root == None:\\n            return []\\n        cache = defaultdict(int)\\n        self.helper(root, cache)\\n        max_freq = max(cache.values())\\n        result = [k for k,v in cache.items() if v == max_freq]\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1939543,
                "title": "c-hashmap-easy-to-understand-recursion-based",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int,int> map;\\n    \\n    TreeNode* helper(TreeNode* root){\\n        if(root==NULL) return NULL;\\n        map[root->val]++;\\n        helper(root->left);\\n        helper(root->right);\\n        return NULL;\\n    }\\n    \\n    \\n    vector<int> findMode(TreeNode* root) {\\n        helper(root);\\n        priority_queue<pair<int,int>> pq;\\n        for(auto it=map.begin();it!=map.end();it++){\\n               pq.push({it->second,it->first});\\n        }\\n        int max=pq.top().first;\\n        vector<int> ans;\\n        \\n        while(pq.top().first==max && pq.empty()==false){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    unordered_map<int,int> map;\\n    \\n    TreeNode* helper(TreeNode* root){\\n        if(root==NULL) return NULL;\\n        map[root->val]++;\\n        helper(root->left);\\n        helper(root->right);\\n        return NULL;\\n    }\\n    \\n    \\n    vector<int> findMode(TreeNode* root) {\\n        helper(root);\\n        priority_queue<pair<int,int>> pq;\\n        for(auto it=map.begin();it!=map.end();it++){\\n               pq.push({it->second,it->first});\\n        }\\n        int max=pq.top().first;\\n        vector<int> ans;\\n        \\n        while(pq.top().first==max && pq.empty()==false){\\n            ans.push_back(pq.top().second);\\n            pq.pop();\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1015445,
                "title": "java-simple-solution-without-using-extra-space-follow-up-0ms-100",
                "content": "The idea is simple.\\nWe know that inorder Traversal of BST will contain all the same elemets together i.e. the inorder traversal will result in a sorted array.\\nI am just keeping the track of last element of inOrderTraversal. \\n1. If it is same as current element, increase count of this element.\\n     a. If count is equal to maxCount , than this value is also an mode value.\\n\\t b. If count > maxCount, clear the previous saved modes and initialize mode with this number.\\n2. If this element is not same as last node, start current node count from zero and make this value as previous value.\\n\\n```\\nclass Solution {\\n    private int maxCount;\\n\\tprivate int currentCount;\\n\\tprivate int lastValue = Integer.MIN_VALUE;\\n\\n\\tprivate List<Integer> myList = new ArrayList<>();\\n\\n\\tpublic int[] findMode(TreeNode root) {\\n\\t\\tinOrderTraversal(root);\\n\\t\\tint[] result = new int[myList.size()];\\n\\t\\tint pos = 0;\\n\\t\\tfor (int i : myList) {\\n\\t\\t\\tresult[pos++] = i;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\n\\tprivate void inOrderTraversal(TreeNode root) {\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tinOrderTraversal(root.left);\\n\\t\\tprocessCurrentNode(root);\\n\\t\\tinOrderTraversal(root.right);\\n\\t}\\n\\n\\tprivate void processCurrentNode(TreeNode root) {\\n\\t\\tif (lastValue != root.val) {\\n\\t\\t\\tcurrentCount = 0;\\n\\t\\t\\tlastValue = root.val;\\n\\t\\t}\\n\\t\\tcurrentCount++;\\n\\t\\tif (currentCount > maxCount) {\\n\\t\\t\\tmaxCount = currentCount;\\n\\t\\t\\tmyList.clear();\\n\\t\\t\\tmyList.add(root.val);\\n\\t\\t} else if (currentCount == maxCount) {\\n\\t\\t\\tmyList.add(root.val);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private int maxCount;\\n\\tprivate int currentCount;\\n\\tprivate int lastValue = Integer.MIN_VALUE;\\n\\n\\tprivate List<Integer> myList = new ArrayList<>();\\n\\n\\tpublic int[] findMode(TreeNode root) {\\n\\t\\tinOrderTraversal(root);\\n\\t\\tint[] result = new int[myList.size()];\\n\\t\\tint pos = 0;\\n\\t\\tfor (int i : myList) {\\n\\t\\t\\tresult[pos++] = i;\\n\\t\\t}\\n\\t\\treturn result;\\n\\t}\\n\\n\\tprivate void inOrderTraversal(TreeNode root) {\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tinOrderTraversal(root.left);\\n\\t\\tprocessCurrentNode(root);\\n\\t\\tinOrderTraversal(root.right);\\n\\t}\\n\\n\\tprivate void processCurrentNode(TreeNode root) {\\n\\t\\tif (lastValue != root.val) {\\n\\t\\t\\tcurrentCount = 0;\\n\\t\\t\\tlastValue = root.val;\\n\\t\\t}\\n\\t\\tcurrentCount++;\\n\\t\\tif (currentCount > maxCount) {\\n\\t\\t\\tmaxCount = currentCount;\\n\\t\\t\\tmyList.clear();\\n\\t\\t\\tmyList.add(root.val);\\n\\t\\t} else if (currentCount == maxCount) {\\n\\t\\t\\tmyList.add(root.val);\\n\\t\\t}\\n\\t}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1396094,
                "title": "python-faster-than-100-literally-commented-code-o-1-space",
                "content": "Proof (Solution Below):  \\n![image](https://assets.leetcode.com/users/images/85e52a26-0576-4188-9e57-33ee0471a109_1628633544.4031708.png)\\n\\nSolution: \\n```\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        # main variables\\n        mode = [root.val]\\n        freq_max = 1\\n        last = inf\\n        freq = 0\\n        \\n        # main function\\n        def in_order(node):\\n            nonlocal mode, freq_max, last, freq\\n            \\n            # call left node\\n            if node.left:\\n                in_order(node.left)\\n            \\n            # main operations\\n            if last == node.val:\\n                freq += 1\\n            \\n            else:\\n                if freq > freq_max:\\n                    freq_max, mode = freq, [last]\\n            \\n                elif freq == freq_max:\\n                    mode.append(last)\\n                    \\n                freq = 1\\n                last = node.val\\n            \\n            # call right node\\n            if node.right:\\n                in_order(node.right)\\n        \\n        # calling main function\\n        in_order(root)\\n        \\n        # edge cases\\n        if freq > freq_max:\\n            return [last]\\n        elif freq == freq_max:\\n                mode.append(last)\\n    \\n        if freq_max == 1:\\n            return mode[1:]\\n        \\n        # default\\n        return mode\\n```\\n\\n",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        # main variables\\n        mode = [root.val]\\n        freq_max = 1\\n        last = inf\\n        freq = 0\\n        \\n        # main function\\n        def in_order(node):\\n            nonlocal mode, freq_max, last, freq\\n            \\n            # call left node\\n            if node.left:\\n                in_order(node.left)\\n            \\n            # main operations\\n            if last == node.val:\\n                freq += 1\\n            \\n            else:\\n                if freq > freq_max:\\n                    freq_max, mode = freq, [last]\\n            \\n                elif freq == freq_max:\\n                    mode.append(last)\\n                    \\n                freq = 1\\n                last = node.val\\n            \\n            # call right node\\n            if node.right:\\n                in_order(node.right)\\n        \\n        # calling main function\\n        in_order(root)\\n        \\n        # edge cases\\n        if freq > freq_max:\\n            return [last]\\n        elif freq == freq_max:\\n                mode.append(last)\\n    \\n        if freq_max == 1:\\n            return mode[1:]\\n        \\n        # default\\n        return mode\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98105,
                "title": "c-iterative-1-pass-o-1-space-o-n-time-with-clear-explanation",
                "content": "The idea is that all the same valued nodes will be consecutive if you do an in-order traversal.  So you just need to capture the longest streak of numbers (and any other equally long streaks) as you do your traversal.  Here I do iterative in-order traversal and while \"visiting\" the node I keep the previous value seen and a previously seen count.  If the current value is the same as previous value then the streak continues, else it is a new streak.  Each time check if the streak is a max streak.\\n\\n```\\n    public int[] FindMode(TreeNode root) \\n    {\\n        if (root == null) return new int[0];\\n        \\n        TreeNode node = root;\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        int currVal = root.val - 1;\\n        int currCnt = 0;\\n        int maxCnt = 0;\\n        HashSet<int> maxVals = new HashSet<int>();\\n        \\n        while (node != null || stack.Count > 0)\\n        {\\n            if (node != null)\\n            {\\n                stack.Push(node);\\n                node = node.left;\\n            }\\n            else\\n            {\\n                TreeNode x = stack.Pop();\\n\\n                // --------------------------------------------\\n                // visit\\n                if (x.val != currVal) currCnt = 0;\\n                \\n                currCnt++;\\n                currVal = x.val;\\n                \\n                if (currCnt == maxCnt)\\n                {\\n                    maxVals.Add(currVal);\\n                }\\n                else if (currCnt > maxCnt)\\n                {\\n                    maxCnt = currCnt;\\n                    maxVals.Clear();\\n                    maxVals.Add(currVal);\\n                }\\n                // end visit\\n                // --------------------------------------------\\n\\n                // go right\\n                node = x.right;\\n            }\\n        }\\n        \\n        return maxVals.ToArray();\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int[] FindMode(TreeNode root) \\n    {\\n        if (root == null) return new int[0];\\n        \\n        TreeNode node = root;\\n        Stack<TreeNode> stack = new Stack<TreeNode>();\\n        \\n        int currVal = root.val - 1;\\n        int currCnt = 0;\\n        int maxCnt = 0;\\n        HashSet<int> maxVals = new HashSet<int>();\\n        \\n        while (node != null || stack.Count > 0)\\n        {\\n            if (node != null)\\n            {\\n                stack.Push(node);\\n                node = node.left;\\n            }\\n            else\\n            {\\n                TreeNode x = stack.Pop();\\n\\n                // --------------------------------------------\\n                // visit\\n                if (x.val != currVal) currCnt = 0;\\n                \\n                currCnt++;\\n                currVal = x.val;\\n                \\n                if (currCnt == maxCnt)\\n                {\\n                    maxVals.Add(currVal);\\n                }\\n                else if (currCnt > maxCnt)\\n                {\\n                    maxCnt = currCnt;\\n                    maxVals.Clear();\\n                    maxVals.Add(currVal);\\n                }\\n                // end visit\\n                // --------------------------------------------\\n\\n                // go right\\n                node = x.right;\\n            }\\n        }\\n        \\n        return maxVals.ToArray();\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2278331,
                "title": "c-no-extra-space-recursion-simple",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>result;\\n    int maxFreq=0,current=0,freq=0;\\n    \\n    vector<int> findMode(TreeNode* root) {\\n        \\n    //Base condition\\n       if(!root)\\n            return result;\\n    \\n    //Traverse left sub tree    \\n       findMode(root->left);\\n        \\n    //Upon visiting a node\\n       if(current!=root->val)\\n       {\\n           freq=1;\\n           current=root->val;\\n       }\\n\\n       else if(current==root->val)\\n       {\\n         freq++;   \\n       }\\n       if(freq>maxFreq)\\n       {\\n           maxFreq=freq;\\n           result={current};\\n           \\n       }\\n        else if(freq==maxFreq)\\n        {\\n            result.push_back(current);\\n        }\\n        \\n    //Traverse right subtree\\n       findMode(root->right);\\n        \\n         return result;\\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>result;\\n    int maxFreq=0,current=0,freq=0;\\n    \\n    vector<int> findMode(TreeNode* root) {\\n        \\n    //Base condition\\n       if(!root)\\n            return result;\\n    \\n    //Traverse left sub tree    \\n       findMode(root->left);\\n        \\n    //Upon visiting a node\\n       if(current!=root->val)\\n       {\\n           freq=1;\\n           current=root->val;\\n       }\\n\\n       else if(current==root->val)\\n       {\\n         freq++;   \\n       }\\n       if(freq>maxFreq)\\n       {\\n           maxFreq=freq;\\n           result={current};\\n           \\n       }\\n        else if(freq==maxFreq)\\n        {\\n            result.push_back(current);\\n        }\\n        \\n    //Traverse right subtree\\n       findMode(root->right);\\n        \\n         return result;\\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1319111,
                "title": "easy-python-solution-98-91-recursive",
                "content": "Runtime: 44 ms, faster than 98.91% of Python3 online submissions for Find Mode in Binary Search Tree.\\nMemory Usage: 18.2 MB, less than 73.79% of Python3 online submissions for Find Mode in Binary Search Tree.\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findMode(self, root: TreeNode) -> List[int]:\\n        def h(node,l):\\n            if node is None:\\n                return l\\n            if(node.val in l):\\n                l[node.val]+=1\\n            else:\\n                l[node.val]=1\\n            if(node.left is not None):\\n                h(node.left,l)\\n            if(node.right is not None):\\n                h(node.right,l)\\n            return l\\n        l=dict()\\n        h(root,l)\\n        m=max(l.values())\\n        return (i for i,v in l.items() if(v==m))",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "Runtime: 44 ms, faster than 98.91% of Python3 online submissions for Find Mode in Binary Search Tree.\\nMemory Usage: 18.2 MB, less than 73.79% of Python3 online submissions for Find Mode in Binary Search Tree.\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findMode(self, root: TreeNode) -> List[int]:\\n        def h(node,l):\\n            if node is None:\\n                return l\\n            if(node.val in l):\\n                l[node.val]+=1\\n            else:\\n                l[node.val]=1\\n            if(node.left is not None):\\n                h(node.left,l)\\n            if(node.right is not None):\\n                h(node.right,l)\\n            return l\\n        l=dict()\\n        h(root,l)\\n        m=max(l.values())\\n        return (i for i,v in l.items() if(v==m))",
                "codeTag": "Java"
            },
            {
                "id": 3533217,
                "title": "c-solution",
                "content": "\\n# Code\\n```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, std::map<int, int> &count) {\\n        if (root) {\\n            if (count.count(root->val)){\\n                count[root->val] += 1;\\n            } else {\\n                count[root->val] = 0;\\n            }\\n            dfs(root->right, count);\\n            dfs(root->left, count);\\n        }\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        std::map<int, int> count;\\n        dfs(root, count);\\n\\n        int maxValue = std::numeric_limits<int>::lowest();\\n        std::vector<int> maxKeys;\\n\\n        for (const auto& pair : count) {\\n            if (pair.second > maxValue) {\\n                maxValue = pair.second;\\n                maxKeys.clear();\\n            }\\n            if (pair.second == maxValue) {\\n                maxKeys.push_back(pair.first);\\n            }\\n        }\\n\\n        return maxKeys;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root, std::map<int, int> &count) {\\n        if (root) {\\n            if (count.count(root->val)){\\n                count[root->val] += 1;\\n            } else {\\n                count[root->val] = 0;\\n            }\\n            dfs(root->right, count);\\n            dfs(root->left, count);\\n        }\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        std::map<int, int> count;\\n        dfs(root, count);\\n\\n        int maxValue = std::numeric_limits<int>::lowest();\\n        std::vector<int> maxKeys;\\n\\n        for (const auto& pair : count) {\\n            if (pair.second > maxValue) {\\n                maxValue = pair.second;\\n                maxKeys.clear();\\n            }\\n            if (pair.second == maxValue) {\\n                maxKeys.push_back(pair.first);\\n            }\\n        }\\n\\n        return maxKeys;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1879759,
                "title": "well-explained-with-comments-beginner-friendly",
                "content": "class Solution {\\npublic:\\n\\n\\n    vector<int> modes;                       //vector to store result\\n    int curr=INT_MIN;                         //variable to store current root value\\n    int count=0;                              //variable to store count of current root \\n    int max_count=0;                          //variable to store max count till \\n    \\n    vector<int> findMode(TreeNode* root) {\\n       if(root==NULL)                              //base case for inorder traversal\\n        return modes;\\n        \\n        findMode(root->left);\\n        helper(root->val);                        //main work in inorder part\\n        findMode(root->right);\\n        \\n        return modes;\\n    }\\n\\t\\n\\t//helper function\\n\\tvoid helper(int val){\\n        if(val!=curr){                                                     \\n\\t\\t//this represent the node is visited first time, hence set the current value of node to this value              and set the count to 1\\n           curr=val;\\n           count=1;\\n        }\\n        \\n        else\\n\\t\\t//this represent the node is visited previously hence count is increased\\n            count++;\\n        \\n        if(max_count<count){\\n\\t\\t//this node has maximum count hence we should delete the previous vector. So we are setting the value of vector to this value and max_count as this count.\\n             modes = {val};\\n            max_count = count;\\n        }\\n            \\n        else if(max_count==count)\\n\\t\\t//this node has count equal to mode value so we should add this node value in vector.\\n            modes.push_back(val);\\n        \\n    }\\n};\\n\\nplease upvote if you liked the solution :)",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "class Solution {\\npublic:\\n\\n\\n    vector<int> modes;                       //vector to store result\\n    int curr=INT_MIN;                         //variable to store current root value\\n    int count=0;                              //variable to store count of current root \\n    int max_count=0;                          //variable to store max count till \\n    \\n    vector<int> findMode(TreeNode* root) {\\n       if(root==NULL)                              //base case for inorder traversal\\n        return modes;\\n        \\n        findMode(root->left);\\n        helper(root->val);                        //main work in inorder part\\n        findMode(root->right);\\n        \\n        return modes;\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 657038,
                "title": "simple-java-solution-with-explanation",
                "content": "```\\nclass Solution {\\n    public int[] findMode(TreeNode root) {\\n        if(root==null) return new int[0];\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>(); //we are taking map to count each and every value of the tree and the no of times they occurs in the tree\\n        Queue<TreeNode> qu = new LinkedList<TreeNode>(); // to itereate over the tree\\n        List<Integer> list = new ArrayList<Integer>(); //to save our result into a dynamic arraylist then will convert into static array for return it\\n        qu.add(root);                     // add the first root node into queue to iterate over the tree\\n        while(!qu.isEmpty()) {   \\n            TreeNode tmp = qu.poll();               //we poll out the node which is last inputed to the queue\\n            if(map.containsKey(tmp.val)) {           //we are checking through the map wheather the value this node have already stored into the map or not\\n                map.put(tmp.val, map.get(tmp.val)+1);     //the value is already stored then we just increase the count by 1\\n            }\\n            else {\\n                map.put(tmp.val, 1);     //if the value is unique then we store it to the map with the count 1\\n            }\\n            if(tmp.left!=null) qu.add(tmp.left);    //this way we are checking wheather left node has any value or not respect to the current poped element of queue\\n            if(tmp.right!=null) qu.add(tmp.right);    //the same thing of the above just this is for right node of respective poped out node\\n        }\\n        int max = Integer.MIN_VALUE;   //we are taking it because of requirement to identify highest no of repeated node available in this tree \\n        for(Integer key : map.keySet()) {  //we are using keySet() for iterating over the map here key is differernt nodes and value is the no of count they have in this tree\\n            if(map.get(key)>max) { //if anything we find have greater value then previous maximum no of node like 2 2 2 - value 3, 3 3 3 3 - value 4 so now 4 is the maximum now \\n                list.clear(); //just to clear previous data that are stored into that list\\n                max = map.get(key);   //now max will replaced by the new no of count of a node\\n                list.add(key);    //we are adding the key which has most no of count\\n            }\\n            else if(max==map.get(key)) { //if we found another node which also has present maximum no of node count in the tree\\n                list.add(key);  //we are also adding those key\\n            }\\n        }\\n\\t\\t//now we just create an array transfer hole data that arraylist has and then return\\n        int[] res = new int[list.size()];\\n        for(int i=0; i<list.size(); i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findMode(TreeNode root) {\\n        if(root==null) return new int[0];\\n        Map<Integer, Integer> map = new HashMap<Integer, Integer>(); //we are taking map to count each and every value of the tree and the no of times they occurs in the tree\\n        Queue<TreeNode> qu = new LinkedList<TreeNode>(); // to itereate over the tree\\n        List<Integer> list = new ArrayList<Integer>(); //to save our result into a dynamic arraylist then will convert into static array for return it\\n        qu.add(root);                     // add the first root node into queue to iterate over the tree\\n        while(!qu.isEmpty()) {   \\n            TreeNode tmp = qu.poll();               //we poll out the node which is last inputed to the queue\\n            if(map.containsKey(tmp.val)) {           //we are checking through the map wheather the value this node have already stored into the map or not\\n                map.put(tmp.val, map.get(tmp.val)+1);     //the value is already stored then we just increase the count by 1\\n            }\\n            else {\\n                map.put(tmp.val, 1);     //if the value is unique then we store it to the map with the count 1\\n            }\\n            if(tmp.left!=null) qu.add(tmp.left);    //this way we are checking wheather left node has any value or not respect to the current poped element of queue\\n            if(tmp.right!=null) qu.add(tmp.right);    //the same thing of the above just this is for right node of respective poped out node\\n        }\\n        int max = Integer.MIN_VALUE;   //we are taking it because of requirement to identify highest no of repeated node available in this tree \\n        for(Integer key : map.keySet()) {  //we are using keySet() for iterating over the map here key is differernt nodes and value is the no of count they have in this tree\\n            if(map.get(key)>max) { //if anything we find have greater value then previous maximum no of node like 2 2 2 - value 3, 3 3 3 3 - value 4 so now 4 is the maximum now \\n                list.clear(); //just to clear previous data that are stored into that list\\n                max = map.get(key);   //now max will replaced by the new no of count of a node\\n                list.add(key);    //we are adding the key which has most no of count\\n            }\\n            else if(max==map.get(key)) { //if we found another node which also has present maximum no of node count in the tree\\n                list.add(key);  //we are also adding those key\\n            }\\n        }\\n\\t\\t//now we just create an array transfer hole data that arraylist has and then return\\n        int[] res = new int[list.size()];\\n        for(int i=0; i<list.size(); i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 642178,
                "title": "c-bfs-hashing",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        if (root == NULL) return {}; \\n        \\n        unordered_map<int, int> times;\\n        int max = INT_MIN;\\n        vector<int> answer;\\n        queue<TreeNode*> q; \\n        q.push(root);\\n\\n        while (!q.empty()) \\n        { \\n            TreeNode* curr = q.front();\\n            times[curr->val]++;\\n            \\n            max = (times[curr->val] > max) ? times[curr->val] : max;\\n            q.pop();\\n            \\n            if(curr->left) q.push(curr->left);\\n            if(curr->right) q.push(curr->right);\\n        }\\n        \\n        for(auto num : times) if(num.second == max) answer.push_back(num.first);\\n        \\n        return answer;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Breadth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        if (root == NULL) return {}; \\n        \\n        unordered_map<int, int> times;\\n        int max = INT_MIN;\\n        vector<int> answer;\\n        queue<TreeNode*> q; \\n        q.push(root);\\n\\n        while (!q.empty()) \\n        { \\n            TreeNode* curr = q.front();\\n            times[curr->val]++;\\n            \\n            max = (times[curr->val] > max) ? times[curr->val] : max;\\n            q.pop();\\n            \\n            if(curr->left) q.push(curr->left);\\n            if(curr->right) q.push(curr->right);\\n        }\\n        \\n        for(auto num : times) if(num.second == max) answer.push_back(num.first);\\n        \\n        return answer;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 481634,
                "title": "js-o-1-space-o-n-time-solution",
                "content": "Because it is a BST, we could treat it as an ascending sorted array when we do inorder traverse. \\nTo achieve constant space, during the traverse we only store current node info (value and count) and compare current node value to previous one:\\nif equal, we update current value count and maxCount\\nif not, reset current count to 1.\\n\\n```javascript\\nvar findMode = function(root) {\\n    var mode = [], \\n        curNodeVal = NaN, \\n        curNodeCount = 0, \\n        maxCount = -Infinity;\\n    \\n    var inorder = function(root) {\\n        if (!root) return;\\n        inorder(root.left);\\n        curNodeCount = (root.val === curNodeVal ? curNodeCount : 0) + 1;\\n        curNodeVal = root.val;\\n        if (curNodeCount > maxCount) {\\n            mode = [root.val];\\n            maxCount = curNodeCount;\\n        } else if (curNodeCount === maxCount) {\\n            mode.push(root.val);\\n        }\\n        inorder(root.right);\\n    }\\n    inorder(root);\\n    return mode;\\n}\\n\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```javascript\\nvar findMode = function(root) {\\n    var mode = [], \\n        curNodeVal = NaN, \\n        curNodeCount = 0, \\n        maxCount = -Infinity;\\n    \\n    var inorder = function(root) {\\n        if (!root) return;\\n        inorder(root.left);\\n        curNodeCount = (root.val === curNodeVal ? curNodeCount : 0) + 1;\\n        curNodeVal = root.val;\\n        if (curNodeCount > maxCount) {\\n            mode = [root.val];\\n            maxCount = curNodeCount;\\n        } else if (curNodeCount === maxCount) {\\n            mode.push(root.val);\\n        }\\n        inorder(root.right);\\n    }\\n    inorder(root);\\n    return mode;\\n}\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 260565,
                "title": "python-dfs-counter",
                "content": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def findMode(self, root: TreeNode) -> List[int]:\\n        def dfs(n, res):\\n            if n:\\n                res[n.val] += 1\\n                dfs(n.left, res)\\n                dfs(n.right, res)\\n        if not root:\\n            return []\\n        res = Counter()\\n        dfs(root, res)\\n        c = res.most_common()[0][1]\\n        return [k for k, v in res.items() if v==c]",
                "solutionTags": [],
                "code": "```\\nfrom collections import Counter\\n\\nclass Solution:\\n    def findMode(self, root: TreeNode) -> List[int]:\\n        def dfs(n, res):\\n            if n:\\n                res[n.val] += 1\\n                dfs(n.left, res)\\n                dfs(n.right, res)\\n        if not root:\\n            return []\\n        res = Counter()\\n        dfs(root, res)\\n        c = res.most_common()[0][1]\\n        return [k for k, v in res.items() if v==c]",
                "codeTag": "Java"
            },
            {
                "id": 3645799,
                "title": "python-3-10-lines-dfs-t-m-99-89",
                "content": "```\\nclass Solution:\\n    def findMode(self, root: TreeNode) -> list[int]:\\n\\n        def dfs(root: TreeNode)-> None:\\n            if not root: return\\n\\n            d[root.val]+=1\\n\\n            dfs(root.left)\\n            dfs(root.right)\\n\\n            return\\n\\n            \\n        d, ans = defaultdict(int), []\\n        \\n        dfs(root)\\n        mx = max(d.values())\\n\\n        return [key for key in d if d[key] == mx]\\n```\\n[https://leetcode.com/problems/find-mode-in-binary-search-tree/submissions/629179410/](http://)\\n\\n\\nI could be wrong, but I think that time complexity is *O*(*N*) and space complexity is *O*(*N*).",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMode(self, root: TreeNode) -> list[int]:\\n\\n        def dfs(root: TreeNode)-> None:\\n            if not root: return\\n\\n            d[root.val]+=1\\n\\n            dfs(root.left)\\n            dfs(root.right)\\n\\n            return\\n\\n            \\n        d, ans = defaultdict(int), []\\n        \\n        dfs(root)\\n        mx = max(d.values())\\n\\n        return [key for key in d if d[key] == mx]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3286522,
                "title": "501-solution-with-step-by-step-explanation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n1. The findMode method takes a TreeNode object root as input and returns a list of integers, which will contain the mode(s) of the values in the binary search tree (BST) represented by root.\\n\\n2. Several variables are initialized, including self.mode_count (which will keep track of the highest frequency of a value seen so far), self.current_val (which will store the current value being examined during the traversal), self.current_count (which will keep track of the frequency of the current value), and self.mode_list (which will store the mode(s) of the values seen so far).\\n\\n3. A helper function called update_mode_list is defined, which takes a value val as input and updates self.mode_list if the frequency of the current value (self.current_count) is greater than the highest frequency seen so far (self.mode_count), or if self.current_count is equal to self.mode_count.\\n\\n4. The traverse function is defined, which takes a TreeNode object node as input and performs an in-order traversal of the BST rooted at node.\\n\\n5. The traverse function first checks if node is None, in which case it returns immediately.\\n\\n6. The traverse function then recursively calls itself on the left subtree of node.\\n\\n7. Next, the current node node is processed. If node.val is equal to self.current_val, then the frequency of the current value (self.current_count) is incremented. Otherwise, the update_mode_list helper function is called on self.current_val to update the mode list, and self.current_val and self.current_count are updated to reflect the new current value.\\n\\n8. Finally, the traverse function recursively calls itself on the right subtree of node.\\n\\n9. The traverse function is called with root as input to start the traversal of the BST.\\n\\n10. After the traversal is complete, the final value of self.current_val is passed to update_mode_list to ensure that the mode list is updated with the frequency of the last value seen.\\n\\n11. The method returns self.mode_list, which contains the mode(s) of the values in the BST.\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def findMode(self, root: TreeNode) -> List[int]:\\n        # Initialize variables\\n        self.mode_count = 0\\n        self.current_val = None\\n        self.current_count = 0\\n        self.mode_list = []\\n        \\n        # Helper function to handle updating the mode list\\n        def update_mode_list(val):\\n            if self.current_count > self.mode_count:\\n                self.mode_count = self.current_count\\n                self.mode_list = [val]\\n            elif self.current_count == self.mode_count:\\n                self.mode_list.append(val)\\n        \\n        # In-order traversal of the BST\\n        def traverse(node):\\n            if node is None:\\n                return\\n            \\n            # Traverse left subtree\\n            traverse(node.left)\\n            \\n            # Process current node\\n            if node.val == self.current_val:\\n                self.current_count += 1\\n            else:\\n                update_mode_list(self.current_val)\\n                self.current_val = node.val\\n                self.current_count = 1\\n            \\n            # Traverse right subtree\\n            traverse(node.right)\\n        \\n        # Start traversal\\n        traverse(root)\\n        \\n        # Add final value to mode list\\n        update_mode_list(self.current_val)\\n        \\n        return self.mode_list\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution:\\n    def findMode(self, root: TreeNode) -> List[int]:\\n        # Initialize variables\\n        self.mode_count = 0\\n        self.current_val = None\\n        self.current_count = 0\\n        self.mode_list = []\\n        \\n        # Helper function to handle updating the mode list\\n        def update_mode_list(val):\\n            if self.current_count > self.mode_count:\\n                self.mode_count = self.current_count\\n                self.mode_list = [val]\\n            elif self.current_count == self.mode_count:\\n                self.mode_list.append(val)\\n        \\n        # In-order traversal of the BST\\n        def traverse(node):\\n            if node is None:\\n                return\\n            \\n            # Traverse left subtree\\n            traverse(node.left)\\n            \\n            # Process current node\\n            if node.val == self.current_val:\\n                self.current_count += 1\\n            else:\\n                update_mode_list(self.current_val)\\n                self.current_val = node.val\\n                self.current_count = 1\\n            \\n            # Traverse right subtree\\n            traverse(node.right)\\n        \\n        # Start traversal\\n        traverse(root)\\n        \\n        # Add final value to mode list\\n        update_mode_list(self.current_val)\\n        \\n        return self.mode_list\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2769306,
                "title": "c-solutions-eassy-0-ms-100-faster",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxFreq = 0, currFreq = 0, precursor = INT_MIN;\\n    vector<int> res;\\n\\n    vector<int> findMode(TreeNode *root)\\n    {\\n        inorderTraversal(root);\\n        return res;\\n    }\\n\\n    void inorderTraversal(TreeNode *root)\\n    {\\n        if (root == NULL) return; // Stop condition\\n        inorderTraversal(root->left); // Traverse left subtree\\n        if (precursor == root->val) currFreq++;\\n        else currFreq = 1;\\n        if (currFreq > maxFreq)\\n        {// Current node value has higher frequency than any previous visited\\n            res.clear();\\n            maxFreq = currFreq;\\n            res.push_back(root->val);\\n        }\\n        else if (currFreq == maxFreq)\\n        {// Current node value has a frequency equal to the highest of previous visited\\n            res.push_back(root->val);\\n        }\\n        precursor = root->val; // Update the precursor\\n        inorderTraversal(root->right); // Traverse right subtree\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxFreq = 0, currFreq = 0, precursor = INT_MIN;\\n    vector<int> res;\\n\\n    vector<int> findMode(TreeNode *root)\\n    {\\n        inorderTraversal(root);\\n        return res;\\n    }\\n\\n    void inorderTraversal(TreeNode *root)\\n    {\\n        if (root == NULL) return; // Stop condition\\n        inorderTraversal(root->left); // Traverse left subtree\\n        if (precursor == root->val) currFreq++;\\n        else currFreq = 1;\\n        if (currFreq > maxFreq)\\n        {// Current node value has higher frequency than any previous visited\\n            res.clear();\\n            maxFreq = currFreq;\\n            res.push_back(root->val);\\n        }\\n        else if (currFreq == maxFreq)\\n        {// Current node value has a frequency equal to the highest of previous visited\\n            res.push_back(root->val);\\n        }\\n        precursor = root->val; // Update the precursor\\n        inorderTraversal(root->right); // Traverse right subtree\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765193,
                "title": "ugly-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int>arr;\\n    \\n    void findInorder(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        \\n        findInorder(root->left);\\n        arr.push_back(root->val);\\n        findInorder(root->right);\\n    }\\n    \\n    \\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> ans;\\n        findInorder(root);\\n        \\n        map<int,int>mp;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]]++;\\n        }\\n        int maxfreq=0;\\n        \\n        map<int,int>::iterator it;\\n        \\n        for(it = mp.begin(); it!=mp.end();it++)\\n        {\\n            if(maxfreq < it->second)\\n            {\\n                maxfreq=it->second;\\n            }\\n        }\\n        \\n        for(it = mp.begin(); it!=mp.end();it++)\\n        {\\n            if(maxfreq ==it->second)\\n            {\\n               ans.push_back(it->first);\\n            }\\n        }\\n      \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int>arr;\\n    \\n    void findInorder(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        \\n        findInorder(root->left);\\n        arr.push_back(root->val);\\n        findInorder(root->right);\\n    }\\n    \\n    \\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> ans;\\n        findInorder(root);\\n        \\n        map<int,int>mp;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]]++;\\n        }\\n        int maxfreq=0;\\n        \\n        map<int,int>::iterator it;\\n        \\n        for(it = mp.begin(); it!=mp.end();it++)\\n        {\\n            if(maxfreq < it->second)\\n            {\\n                maxfreq=it->second;\\n            }\\n        }\\n        \\n        for(it = mp.begin(); it!=mp.end();it++)\\n        {\\n            if(maxfreq ==it->second)\\n            {\\n               ans.push_back(it->first);\\n            }\\n        }\\n      \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2053047,
                "title": "java-solution-using-hashmap-simple-approach",
                "content": "```\\npublic int[] findMode(TreeNode root) {\\n        HashMap<Integer, Integer> temp = new HashMap();\\n        inOrder(temp, root);\\n        \\n        int modeValue = 0;\\n        for(Map.Entry<Integer,Integer> map:temp.entrySet()){\\n            if(map.getValue() > modeValue) modeValue = map.getValue();\\n        }\\n        \\n        List<Integer> mode = new ArrayList<Integer>();\\n        for(Map.Entry<Integer,Integer> map:temp.entrySet()){\\n            if(map.getValue() == modeValue) mode.add(map.getKey());\\n        }\\n        \\n        int[] arr = new int[mode.size()];\\n        for(int i=0; i<mode.size(); i++) arr[i] = mode.get(i);\\n        \\n        return arr;\\n    }\\n    private void inOrder(HashMap<Integer, Integer> temp, TreeNode root){\\n        if(root != null){\\n            inOrder(temp, root.left);\\n            if(temp.get(root.val) == null) temp.put(root.val, 1);\\n            else {\\n                int a = temp.get(root.val);\\n                temp.put(root.val, 1+a);\\n            }\\n            inOrder(temp, root.right);\\n        }\\n    }\\n```\\n**Please upvote if the solution helped you**\\n*Feel free to ask any questions in the comment section*",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\npublic int[] findMode(TreeNode root) {\\n        HashMap<Integer, Integer> temp = new HashMap();\\n        inOrder(temp, root);\\n        \\n        int modeValue = 0;\\n        for(Map.Entry<Integer,Integer> map:temp.entrySet()){\\n            if(map.getValue() > modeValue) modeValue = map.getValue();\\n        }\\n        \\n        List<Integer> mode = new ArrayList<Integer>();\\n        for(Map.Entry<Integer,Integer> map:temp.entrySet()){\\n            if(map.getValue() == modeValue) mode.add(map.getKey());\\n        }\\n        \\n        int[] arr = new int[mode.size()];\\n        for(int i=0; i<mode.size(); i++) arr[i] = mode.get(i);\\n        \\n        return arr;\\n    }\\n    private void inOrder(HashMap<Integer, Integer> temp, TreeNode root){\\n        if(root != null){\\n            inOrder(temp, root.left);\\n            if(temp.get(root.val) == null) temp.put(root.val, 1);\\n            else {\\n                int a = temp.get(root.val);\\n                temp.put(root.val, 1+a);\\n            }\\n            inOrder(temp, root.right);\\n        }\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1285720,
                "title": "java-o-n-time-o-1-space-no-map-clean-code-beats-100-0ms",
                "content": "```\\nclass Solution {\\n    Integer prev=null;\\n    int count=1;\\n    int max=0;\\n    public int[] findMode(TreeNode root) {\\n        if(root==null) return new int []{};\\n        \\n        ArrayList<Integer> nums=new ArrayList<>();\\n        getNodes(root,nums);\\n        \\n        int temp[]=new int [nums.size()];\\n\\n        for(int i=0;i<nums.size();i++) temp[i]=nums.get(i);\\n        \\n        return temp;\\n    }\\n    \\n    public void getNodes(TreeNode root,ArrayList<Integer> nums){\\n        if(root==null) return;\\n        \\n        getNodes(root.left,nums);\\n        \\n        if(prev!=null){\\n            if(prev==root.val) count++;\\n            else count=1;\\n        }\\n        \\n        if(count>max){\\n            nums.clear();\\n            max=count;\\n            nums.add(root.val);\\n        }\\n        else if(count==max){\\n            nums.add(root.val);\\n        }\\n        \\n        prev=root.val;\\n        \\n        getNodes(root.right,nums);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    Integer prev=null;\\n    int count=1;\\n    int max=0;\\n    public int[] findMode(TreeNode root) {\\n        if(root==null) return new int []{};\\n        \\n        ArrayList<Integer> nums=new ArrayList<>();\\n        getNodes(root,nums);\\n        \\n        int temp[]=new int [nums.size()];\\n\\n        for(int i=0;i<nums.size();i++) temp[i]=nums.get(i);\\n        \\n        return temp;\\n    }\\n    \\n    public void getNodes(TreeNode root,ArrayList<Integer> nums){\\n        if(root==null) return;\\n        \\n        getNodes(root.left,nums);\\n        \\n        if(prev!=null){\\n            if(prev==root.val) count++;\\n            else count=1;\\n        }\\n        \\n        if(count>max){\\n            nums.clear();\\n            max=count;\\n            nums.add(root.val);\\n        }\\n        else if(count==max){\\n            nums.add(root.val);\\n        }\\n        \\n        prev=root.val;\\n        \\n        getNodes(root.right,nums);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 780598,
                "title": "easy-recursive-python",
                "content": "```\\nclass Solution:\\n    def findMode(self, root: TreeNode) -> List[int]:\\n        \\n        cnts = collections.Counter()\\n        mv = 0\\n        \\n        def helper(node):\\n            nonlocal mv\\n            if not node:\\n                return\\n            cnts[node.val] += 1\\n            mv = max(mv, cnts[node.val])\\n            helper(node.left)\\n            helper(node.right)\\n            \\n        helper(root)\\n        return [k for k,v in cnts.items() if v == mv]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Recursion"
                ],
                "code": "```\\nclass Solution:\\n    def findMode(self, root: TreeNode) -> List[int]:\\n        \\n        cnts = collections.Counter()\\n        mv = 0\\n        \\n        def helper(node):\\n            nonlocal mv\\n            if not node:\\n                return\\n            cnts[node.val] += 1\\n            mv = max(mv, cnts[node.val])\\n            helper(node.left)\\n            helper(node.right)\\n            \\n        helper(root)\\n        return [k for k,v in cnts.items() if v == mv]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 542939,
                "title": "java-solution-without-extra-space-explanation",
                "content": "```\\nclass Solution {\\n    private static class ModeHelper {\\n        public int mode;\\n        public Integer currentElement = null;\\n        public int currentCount;\\n        \\n        public ModeHelper() {\\n            this.mode = 0;\\n            this.currentCount = 0;\\n        }\\n    }\\n\\n    public int[] findMode(TreeNode root) {\\n        if (root == null) {\\n            return new int[0];\\n        }\\n\\n        ArrayList<Integer> modes = new ArrayList<>();\\n        ModeHelper helper = new ModeHelper();\\n        \\n        inorderTraversal(root, modes, helper);\\n        \\n        int[] modesArray = new int[modes.size()];\\n        for (int i = 0; i < modes.size(); i++) {\\n            modesArray[i] = modes.get(i);\\n        }\\n        return modesArray;\\n    }  \\n    \\n    public void inorderTraversal(TreeNode node, ArrayList<Integer> modes, ModeHelper helper) {\\n        if (node == null) {\\n            return;\\n        }\\n        \\n        inorderTraversal(node.left, modes, helper);\\n        visit(node, modes, helper);\\n        inorderTraversal(node.right, modes, helper);\\n    }\\n    \\n    public void visit(TreeNode node, ArrayList<Integer> modes, ModeHelper helper) {\\n        if (helper.currentElement == null || helper.currentElement != node.val) {\\n            helper.currentElement = node.val;\\n            helper.currentCount = 0;\\n        }\\n        \\n        helper.currentCount++;\\n        \\n        if (helper.currentCount > helper.mode) {\\n            modes.clear();\\n            modes.add(node.val);\\n        } else if (helper.currentCount == helper.mode) {\\n            modes.add(node.val);\\n        }\\n        \\n        helper.mode = Math.max(helper.currentCount, helper.mode);\\n    }\\n}\\n```\\n\\n**Thoughts before Coding**\\n- In this follow up question, we are not allowed to use any extra space\\n\\t- This means we are not allowed to use any data structure such as HashMap to keep track of the count of all of our elements\\n\\t- We will still need to use ArrayList because Java does not built in support of dynamic array like Javascript, Python, etc\\n- We are still able to use primitive variables to keep track of what we need\\n\\t- What do we need to keep track of?\\n\\t\\t- Count of the Mode\\n\\t\\t- The current value in the node and its count\\n- We will have to update the variables as we traverse the tree.\\n- Since we are traversing a BST, can we try to group same elements together?\\n\\t- Yes, if we do a in-order traversal (left -> mid -> right), we will be traversing elements in ascending order\\n\\t- Then all of the same elements will be grouped together\\n\\t\\t- For examples: [1, 2, 2, 4, 5, 5, 5, 6]\\n\\t\\t\\t- Then all we need to do is to keep track of our current element and its count\\n\\t\\t\\t- And then compare the current element\\'s count with our (mode count) and update accordingly\\n\\n**Answer**\\n- We will first validate our input parameter\\n\\t- If our root node is null, we will return an empty array\\n- Since, we are doing a in-order recursive traversal, we will need an helper object to hold our 3 variables\\n\\t- This helper object will be passed in our recursive call by reference\\n\\t\\t- This is because if we pass primitive variables into our recursive calls, the updates will be lost\\n\\t- The 3 variables that we need is\\n\\t\\t- Count of Mode\\n\\t\\t- Current element\\n\\t\\t- Count of our current element\\n- We will need an arraylist to hold our result\\n- How are we going to traverse our tree and update the variables\\n\\t- We have to traverse left subtree -> current node -> right subtree\\n\\t- When we are visiting the node, how should we compare our current node with our 3 variables?\\n\\t\\t- We will first have to check if our (Current element) exists inside our helper object\\n\\t\\t\\t- If the (Current element) does not exist, we will put the value of our current node inside our helper object\\n\\t\\t\\t\\t- Set the \\'Count of our current element\\' to zero\\n\\t\\t\\t- if the value of our (Current element) does not equal the value in our current node\\n\\t\\t\\t\\t- We will have to update the (Current element) in our helper object to the value of our current node\\n\\t\\t\\t\\t- set the \\'Count of our current element\\' to zero\\n\\t\\t- Then we will increment the \\'Count of our current element\\' inside the helper object\\n\\t\\t- We will compare \\'Count of our current element\\' with the \\'Count of Mode\\'\\n\\t\\t\\t- If the \\'Count of our current element\\' is greater than the \\'Count of Mode\\'\\n\\t\\t\\t\\t- We have found a new mode, all previous elements in our arraylist must be removed\\n\\t\\t\\t\\t\\t- We have to empty out our arraylist\\n\\t\\t\\t\\t\\t- We will add the value of our current node\\n\\t\\t\\t\\t- We will have to update \\'Count of Mode\\'\\n\\t\\t\\t\\t\\t- \\'Count of Mode\\' = \\'Count of our current element\\'\\n\\t\\t\\t- If the \\'Count of current element\\' is equal to our \\'Count of Mode\\'\\n\\t\\t\\t\\t- We have found another element that is a potential mode\\n\\t\\t\\t\\t   - We will add the value of our current node\\n\\t\\t\\t- Update our \\'Count of Mode\\' to the greater value between\\n\\t\\t\\t\\t- \\'Count of our current element\\' and \\'Count of Mode\\'\\n- Convert our arraylist to array\\n- return the array\\n\\n**What is the time and space complexity?**\\n- Time complexity = O(n) + O(n) = O(n), where n is the number of nodes in the tree\\n\\t- O(n) - inorder traversal, visit each node once\\n\\t- O(n) - converting our arraylist to array, this is language specific (JAVA)\\n\\t\\t- So technically we can achieve O(n) in other languages such as Javascript or Python\\n- Space complexity - O(n) + O(n) = O(n), where n is the number of nodes in the tree\\n\\t- O(n) - Arraylist, this is language specific (JAVA)\\n\\t- O(n) - result array, this is language specific (JAVA)\\n- We are not accounting for the recursive stack when performing our inorder recursive calls\\n- We are not using any extra space such as HashMaps or other data structures.\\n\\t- In other languages, the built in array data structure is dynamic.\\n\\t\\t- Java only have static built in arrays with a fix size, so we need to use ArrayList",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    private static class ModeHelper {\\n        public int mode;\\n        public Integer currentElement = null;\\n        public int currentCount;\\n        \\n        public ModeHelper() {\\n            this.mode = 0;\\n            this.currentCount = 0;\\n        }\\n    }\\n\\n    public int[] findMode(TreeNode root) {\\n        if (root == null) {\\n            return new int[0];\\n        }\\n\\n        ArrayList<Integer> modes = new ArrayList<>();\\n        ModeHelper helper = new ModeHelper();\\n        \\n        inorderTraversal(root, modes, helper);\\n        \\n        int[] modesArray = new int[modes.size()];\\n        for (int i = 0; i < modes.size(); i++) {\\n            modesArray[i] = modes.get(i);\\n        }\\n        return modesArray;\\n    }  \\n    \\n    public void inorderTraversal(TreeNode node, ArrayList<Integer> modes, ModeHelper helper) {\\n        if (node == null) {\\n            return;\\n        }\\n        \\n        inorderTraversal(node.left, modes, helper);\\n        visit(node, modes, helper);\\n        inorderTraversal(node.right, modes, helper);\\n    }\\n    \\n    public void visit(TreeNode node, ArrayList<Integer> modes, ModeHelper helper) {\\n        if (helper.currentElement == null || helper.currentElement != node.val) {\\n            helper.currentElement = node.val;\\n            helper.currentCount = 0;\\n        }\\n        \\n        helper.currentCount++;\\n        \\n        if (helper.currentCount > helper.mode) {\\n            modes.clear();\\n            modes.add(node.val);\\n        } else if (helper.currentCount == helper.mode) {\\n            modes.add(node.val);\\n        }\\n        \\n        helper.mode = Math.max(helper.currentCount, helper.mode);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98114,
                "title": "simple-c-solution-9ms",
                "content": "```\\nvoid helper(struct TreeNode* root,int **retArray,int *len){\\n\\tif(root==NULL) return;\\n\\thelper(root->left,retArray,len);\\n\\t*retArray=(int *)realloc(*retArray,(*len+1)*sizeof(int));\\n\\t(*retArray)[*len]=root->val;\\n\\t*len+=1;\\n\\thelper(root->right,retArray,len);\\n}\\n\\nint* findMode(struct TreeNode* root, int* returnSize) {\\n    int *retArray=(int *)calloc(0,sizeof(int));\\n    int len=0;\\n    helper(root,&retArray,&len);\\n    int *ret=(int *)calloc(0,sizeof(int));\\n    int maxsum=0,i=0,j=0;\\n    for(i=0;i<len;){\\n    \\tfor(j=i+1;j<len;j++){\\n    \\t\\tif(retArray[i]!=retArray[j]) break;\\n    \\t}\\n    \\tint tmp=j-i;\\n    \\tif(tmp==maxsum){\\n    \\t\\tret=(int *)realloc(ret,(*returnSize+1)*sizeof(int));\\n    \\t\\tret[*returnSize]=retArray[i];\\n    \\t\\t*returnSize+=1;\\n    \\t}\\n    \\telse if(tmp>maxsum){\\n    \\t\\tif(ret!=NULL) free(ret);\\n    \\t\\tmaxsum=tmp;\\n    \\t\\t*returnSize=1;\\n    \\t\\tret=(int *)calloc(1,sizeof(int));\\n    \\t\\tret[0]=retArray[i];    \\t\\t\\n    \\t}\\n    \\ti=j;\\n    }\\n    return ret;\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nvoid helper(struct TreeNode* root,int **retArray,int *len){\\n\\tif(root==NULL) return;\\n\\thelper(root->left,retArray,len);\\n\\t*retArray=(int *)realloc(*retArray,(*len+1)*sizeof(int));\\n\\t(*retArray)[*len]=root->val;\\n\\t*len+=1;\\n\\thelper(root->right,retArray,len);\\n}\\n\\nint* findMode(struct TreeNode* root, int* returnSize) {\\n    int *retArray=(int *)calloc(0,sizeof(int));\\n    int len=0;\\n    helper(root,&retArray,&len);\\n    int *ret=(int *)calloc(0,sizeof(int));\\n    int maxsum=0,i=0,j=0;\\n    for(i=0;i<len;){\\n    \\tfor(j=i+1;j<len;j++){\\n    \\t\\tif(retArray[i]!=retArray[j]) break;\\n    \\t}\\n    \\tint tmp=j-i;\\n    \\tif(tmp==maxsum){\\n    \\t\\tret=(int *)realloc(ret,(*returnSize+1)*sizeof(int));\\n    \\t\\tret[*returnSize]=retArray[i];\\n    \\t\\t*returnSize+=1;\\n    \\t}\\n    \\telse if(tmp>maxsum){\\n    \\t\\tif(ret!=NULL) free(ret);\\n    \\t\\tmaxsum=tmp;\\n    \\t\\t*returnSize=1;\\n    \\t\\tret=(int *)calloc(1,sizeof(int));\\n    \\t\\tret[0]=retArray[i];    \\t\\t\\n    \\t}\\n    \\ti=j;\\n    }\\n    return ret;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3638517,
                "title": "beginner-friendly-commented-with-explanation-step-by-step-c",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    // Do, Inorder traversal and store in a vector, all nodes\\n    // use map, to count frequency of each node value using the vector\\n    // find out the max freq from the map\\n    // iterate over the map, and check which node values are havig frequency == mxfreq\\n    // store those in the result array and return\\n    \\n    vector<int>v;\\n    \\n    void in(TreeNode* root) {\\n        if(!root) return;\\n        in(root->left);\\n        v.push_back(root->val);\\n        in(root->right);\\n    }\\n    \\n    vector<int> findMode(TreeNode* root) {\\n        in(root); // call the inorder\\n        \\n        map<int, int> mp;\\n        \\n        vector<int> ans;  // to store and return our answer\\n        for(int x : v) mp[x]++; // counting frequency of each node values\\n        \\n        int mxfreq = -1;\\n        for(auto it : mp) {\\n            mxfreq = max(it.second, mxfreq); // looking for max frequency\\n        }\\n        for(auto it : mp) {\\n            if(it.second == mxfreq) { // check which is having frequency == mxfreq\\n                ans.push_back(it.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    // Do, Inorder traversal and store in a vector, all nodes\\n    // use map, to count frequency of each node value using the vector\\n    // find out the max freq from the map\\n    // iterate over the map, and check which node values are havig frequency == mxfreq\\n    // store those in the result array and return\\n    \\n    vector<int>v;\\n    \\n    void in(TreeNode* root) {\\n        if(!root) return;\\n        in(root->left);\\n        v.push_back(root->val);\\n        in(root->right);\\n    }\\n    \\n    vector<int> findMode(TreeNode* root) {\\n        in(root); // call the inorder\\n        \\n        map<int, int> mp;\\n        \\n        vector<int> ans;  // to store and return our answer\\n        for(int x : v) mp[x]++; // counting frequency of each node values\\n        \\n        int mxfreq = -1;\\n        for(auto it : mp) {\\n            mxfreq = max(it.second, mxfreq); // looking for max frequency\\n        }\\n        for(auto it : mp) {\\n            if(it.second == mxfreq) { // check which is having frequency == mxfreq\\n                ans.push_back(it.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3612542,
                "title": "c-inorder-o-n-time-o-1-space-simple",
                "content": "# Complexity\\n- Time complexity:\\n$$O(n)$$\\n\\n- Space complexity:\\n$$O(1)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> result; \\n        int max_freq(0), curr_freq(0), prev_elem(INT_MIN);\\n        inorder(result, root, max_freq, curr_freq, prev_elem);\\n        return result;\\n    }\\n\\nprivate:\\n    void inorder(vector<int>& result, TreeNode*& root, int& max_freq, int& curr_freq, int& prev_elem) {\\n        if (!root) return;\\n        inorder(result, root->left, max_freq, curr_freq, prev_elem);\\n\\n        int curr_elem = root->val;\\n        if (curr_elem == prev_elem) curr_freq++;\\n        else curr_freq = 1;\\n\\n        if (curr_freq == max_freq) {\\n            result.emplace_back(curr_elem);\\n        } else if (curr_freq > max_freq) {\\n            result.clear();\\n            result.emplace_back(curr_elem);\\n            max_freq = curr_freq;\\n        }\\n        prev_elem = curr_elem;\\n\\n        inorder(result, root->right, max_freq, curr_freq, prev_elem);\\n    } \\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> result; \\n        int max_freq(0), curr_freq(0), prev_elem(INT_MIN);\\n        inorder(result, root, max_freq, curr_freq, prev_elem);\\n        return result;\\n    }\\n\\nprivate:\\n    void inorder(vector<int>& result, TreeNode*& root, int& max_freq, int& curr_freq, int& prev_elem) {\\n        if (!root) return;\\n        inorder(result, root->left, max_freq, curr_freq, prev_elem);\\n\\n        int curr_elem = root->val;\\n        if (curr_elem == prev_elem) curr_freq++;\\n        else curr_freq = 1;\\n\\n        if (curr_freq == max_freq) {\\n            result.emplace_back(curr_elem);\\n        } else if (curr_freq > max_freq) {\\n            result.clear();\\n            result.emplace_back(curr_elem);\\n            max_freq = curr_freq;\\n        }\\n        prev_elem = curr_elem;\\n\\n        inorder(result, root->right, max_freq, curr_freq, prev_elem);\\n    } \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3487799,
                "title": "very-easy-intutive-c-code-please-upvote",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n- O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n- O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int,int>map;\\n   \\n\\n    void solve(TreeNode* root){\\n        if(!root)\\n        return;\\n\\n        map[root->val]++;\\n\\n        if(root->left)\\n        solve(root->left);\\n\\n        if(root->right)\\n        solve(root->right);\\n    }\\n\\n    vector<int> findMode(TreeNode* root) {\\n        solve(root);\\n        int m=INT_MIN;\\n        int mf=0;\\n\\n        for(auto x:map){\\n            if(x.second>=mf){\\n                m=x.first;\\n                mf=x.second;\\n            }\\n        }\\n        vector<int>v;\\n\\n        for(auto x:map){\\n            if(x.second==mf){\\n                v.push_back(x.first);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    unordered_map<int,int>map;\\n   \\n\\n    void solve(TreeNode* root){\\n        if(!root)\\n        return;\\n\\n        map[root->val]++;\\n\\n        if(root->left)\\n        solve(root->left);\\n\\n        if(root->right)\\n        solve(root->right);\\n    }\\n\\n    vector<int> findMode(TreeNode* root) {\\n        solve(root);\\n        int m=INT_MIN;\\n        int mf=0;\\n\\n        for(auto x:map){\\n            if(x.second>=mf){\\n                m=x.first;\\n                mf=x.second;\\n            }\\n        }\\n        vector<int>v;\\n\\n        for(auto x:map){\\n            if(x.second==mf){\\n                v.push_back(x.first);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2306871,
                "title": "simple-solution-two-approaches-sc-o-1-sc-n-cpp",
                "content": "\\u2B06\\uFE0F Please Upvote, if you like this solutions !!!\\n\\n\\n**Using HashMap - Space Complexity O(N)**\\n\\n```\\nclass Solution {\\npublic:\\n    \\n    void inorder(TreeNode* root,map<int,int>&mp){\\n        if(!root) return;\\n        inorder(root->left,mp);\\n        mp[root->val]++;\\n        inorder(root->right,mp);\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        map<int,int> mp;\\n        inorder(root,mp);\\n        vector<int>res;\\n        int maxi = 0;\\n        \\n        for(auto it:mp){\\n            maxi = max(maxi,it.second);\\n        }\\n        \\n        for(auto it:mp){\\n            if(it.second==maxi){\\n                res.push_back(it.first);\\n            }\\n\\t\\t}\\n\\t\\treturn res;\\n\\t\\t}\\n\\t};\\n```\\n\\n\\t\\n**Space Complexity O(1)**\\n\\t\\n```\\n\\tclass Solution {\\npublic:\\n    vector<int>res;\\n    int maxFreq = 0, currFreq = 0,preVal = INT_MIN;\\n    \\n    void inorder(TreeNode* root){\\n        if(!root) return;\\n        inorder(root->left);\\n        if(preVal == root->val) currFreq++;\\n        else currFreq = 1;\\n        \\n        if(currFreq>maxFreq){\\n            res.clear();\\n            res.push_back(root->val);\\n            maxFreq = currFreq;\\n        }\\n        else if(currFreq == maxFreq) res.push_back(root->val);\\n        preVal = root->val;\\n        inorder(root->right);\\n        \\n    }\\n    \\n    vector<int> findMode(TreeNode* root) {\\n        inorder(root);\\n        return res;\\n    }\\n    \\n};\\n```\\n\\t",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    void inorder(TreeNode* root,map<int,int>&mp){\\n        if(!root) return;\\n        inorder(root->left,mp);\\n        mp[root->val]++;\\n        inorder(root->right,mp);\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        map<int,int> mp;\\n        inorder(root,mp);\\n        vector<int>res;\\n        int maxi = 0;\\n        \\n        for(auto it:mp){\\n            maxi = max(maxi,it.second);\\n        }\\n        \\n        for(auto it:mp){\\n            if(it.second==maxi){\\n                res.push_back(it.first);\\n            }\\n\\t\\t}\\n\\t\\treturn res;\\n\\t\\t}\\n\\t};\\n```\n```\\n\\tclass Solution {\\npublic:\\n    vector<int>res;\\n    int maxFreq = 0, currFreq = 0,preVal = INT_MIN;\\n    \\n    void inorder(TreeNode* root){\\n        if(!root) return;\\n        inorder(root->left);\\n        if(preVal == root->val) currFreq++;\\n        else currFreq = 1;\\n        \\n        if(currFreq>maxFreq){\\n            res.clear();\\n            res.push_back(root->val);\\n            maxFreq = currFreq;\\n        }\\n        else if(currFreq == maxFreq) res.push_back(root->val);\\n        preVal = root->val;\\n        inorder(root->right);\\n        \\n    }\\n    \\n    vector<int> findMode(TreeNode* root) {\\n        inorder(root);\\n        return res;\\n    }\\n    \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2126348,
                "title": "solution-with-constant-space-in-c",
                "content": "class Solution {\\npublic:\\n    \\n    vector<int>ans;\\n    TreeNode* last= nullptr;\\n    int cnt=0 , maxy=0;\\n    \\n    void solve(TreeNode * root ){\\n\\n        if(!root) return ;\\n        solve(root->left);\\n        \\n        if(last && last->val==root->val){\\n            ++cnt;\\n        }\\n        else{\\n            cnt=1;\\n        }\\n            \\n        if(cnt>maxy){  \\n            maxy=cnt;\\n            ans.clear();\\n            ans.push_back(root->val);\\n        }\\n        else if(cnt==maxy){\\n            ans.push_back(root->val);\\n        }\\n        \\n        last=root;\\n        \\n        solve(root->right );\\n    \\n    }\\n    \\n    \\n    \\n    vector<int> findMode(TreeNode* root) {\\n        \\n        solve(root );\\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C++",
                    "C",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int>ans;\\n    TreeNode* last= nullptr;\\n    int cnt=0 , maxy=0;\\n    \\n    void solve(TreeNode * root ){\\n\\n        if(!root) return ;\\n        solve(root->left);\\n        \\n        if(last && last->val==root->val){\\n            ++cnt;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1737168,
                "title": "c-solution-with-explanation-clean-and-simple-o-n-o-1",
                "content": "### **Approach:**\\nThe idea here is to traverse the tree in **sorted manner** (ascending order). This can be achieved by **inorder travesal of tree**. *We are doing this so that we get nice array where **duplicates are adjacent** to each other and we can perform futher operations.*\\n\\n**Algorithm:**\\n\\nWhile you can traverse tree:\\n* \\tWe find a new value? Make it our as **current value** and store its **count as 1**.\\n* Same value is found again? Increase its count.\\n* Update **maximum frequency count** if **count > max_count**. Add the node in collection.\\n* If frequency of any other node is equal to maximum frequency we add it to our collection.\\n* Also when, **count > max_count**, delete all the previous values that had maximum frequency, and add this new value into the collection and update the **max_count** too.\\n\\n## **C++ Solution:**\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\n    vector<int> modes;\\n\\n    int cur_num = INT_MIN;\\n    int cur_num_count = 0;\\n    int max_count = 0;\\n\\npublic:\\n    void AddInModes(const int val)\\n    {\\n        // if a new node val is encountered\\n        if (val != cur_num)\\n        {\\n            // reset current val, and add its count\\n            cur_num = val;\\n            cur_num_count = 1;\\n        }\\n        else\\n        {\\n            // increase its count\\n            cur_num_count++;\\n        }\\n\\n        // update max, reset array\\n        if (max_count < cur_num_count)\\n        {\\n            modes = {val};\\n            max_count = cur_num_count;\\n        }\\n        // append in array\\n        else if (cur_num_count == max_count)\\n            modes.push_back(val);\\n    }\\n\\n    vector<int> findMode(TreeNode *root)\\n    {\\n        if (root == nullptr)\\n            return modes;\\n\\n        findMode(root->left);\\n        AddInModes(root->val);\\n        findMode(root->right);\\n\\n        return modes;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution\\n{\\n    vector<int> modes;\\n\\n    int cur_num = INT_MIN;\\n    int cur_num_count = 0;\\n    int max_count = 0;\\n\\npublic:\\n    void AddInModes(const int val)\\n    {\\n        // if a new node val is encountered\\n        if (val != cur_num)\\n        {\\n            // reset current val, and add its count\\n            cur_num = val;\\n            cur_num_count = 1;\\n        }\\n        else\\n        {\\n            // increase its count\\n            cur_num_count++;\\n        }\\n\\n        // update max, reset array\\n        if (max_count < cur_num_count)\\n        {\\n            modes = {val};\\n            max_count = cur_num_count;\\n        }\\n        // append in array\\n        else if (cur_num_count == max_count)\\n            modes.push_back(val);\\n    }\\n\\n    vector<int> findMode(TreeNode *root)\\n    {\\n        if (root == nullptr)\\n            return modes;\\n\\n        findMode(root->left);\\n        AddInModes(root->val);\\n        findMode(root->right);\\n\\n        return modes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1400944,
                "title": "unoptimized-to-optimized-solution-morris-traversal-c-explained-code",
                "content": "this is an unoptimized solution in which i am not taking it into consideration that the tree  is BST.\\nI am just doing a pre-order traversal and storing the frequency of every single element in the tree and then finding the elements which the maximum frequency.\\n\\n\\n```\\nvoid helper(TreeNode* root,map<int,int>& mp)\\n    {\\n        if(root==NULL)return;\\n       int x=root->val;\\n        mp[x]++;\\n        helper(root->left,mp);\\n        helper(root->right,mp);\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        map<int,int> mp;\\n        helper(root,mp);\\n        int dex=0;\\n        int v=0;\\n        vector<int> ans;\\n        for(auto i:mp)\\n        {\\n            if(i.second>v)\\n            {\\n                int s=ans.size();\\n                while(s--)\\n                {\\n                    ans.pop_back();\\n                }\\n                ans.push_back(i.first);\\n                v=i.second;\\n            }\\n            else if(v==i.second)\\n            {\\n                ans.push_back(i.first);\\n            }\\n        }\\n        return ans; \\n    }\\n```\\n\\nThe second solution takes into consideration that the tree is a BST and i have used morris traversal to convert the tree into a sorted linkedlist with all the greater elements at the right. If you don\\'t know morris traversal you won\\'t be able to understand this solution so i would recommed to understand morris traversal from this link. [here](https://leetcode.com/problems/binary-tree-inorder-traversal/discuss/1377500/3-solutions-or-1-recursive-or-2-iterative-or-O(1)-space-complexity-or-morris-traversal-or-explained-code)\\n\\n**so its a trick in BST that if we apply morris traversal to a BST it gets converted into a linkedlist on sorted elements with all the greter elements in the right pointer.**\\n\\n\\nusing this trick here is the solution\\n```\\nvector<int> findMode(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* start=NULL;\\n        TreeNode* temp=root;\\n        TreeNode* temp2=root;\\n        if(!root)return ans;\\n        while(root)\\n        {\\n            if(root->left)\\n            {\\n                temp=root->left;\\n                while(temp->right)\\n                {\\n                    temp=temp->right;\\n                }\\n                temp->right=root;\\n                temp=root->left;\\n                root->left=NULL;\\n                root=temp;\\n                if(start!=NULL)\\n                {\\n                    temp2->right=root;\\n                }\\n            }\\n            else\\n            {\\n                if(start==NULL)\\n                {\\n                    start=root;\\n                }\\n                temp2=root;\\n                root=root->right;\\n            }\\n        }  \\n        root=start;\\n        start=start->right;\\n        int mc=0;\\n        int fmc=-1;\\n        while(root!=NULL)\\n        {\\n            while(start!=NULL && start->val==root->val)\\n            {\\n                mc++;\\n                start=start->right;\\n            }\\n            if(mc>fmc)\\n            {\\n                int s=ans.size();\\n                while(s--)\\n                {\\n                    ans.pop_back();\\n                }\\n                ans.push_back(root->val);\\n                fmc=mc;\\n            }\\n            else if(mc==fmc)\\n            {\\n                ans.push_back(root->val);\\n            }\\n            mc=0;\\n            root=start;\\n            if(start)start=start->right;\\n        }\\n        if(fmc==-1)\\n        {\\n            ans.push_back(root->val);\\n        }\\n         return ans;\\n    }\\n```\\n\\n**please upvote if you liked my solution**\\n#happy_coding",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nvoid helper(TreeNode* root,map<int,int>& mp)\\n    {\\n        if(root==NULL)return;\\n       int x=root->val;\\n        mp[x]++;\\n        helper(root->left,mp);\\n        helper(root->right,mp);\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        map<int,int> mp;\\n        helper(root,mp);\\n        int dex=0;\\n        int v=0;\\n        vector<int> ans;\\n        for(auto i:mp)\\n        {\\n            if(i.second>v)\\n            {\\n                int s=ans.size();\\n                while(s--)\\n                {\\n                    ans.pop_back();\\n                }\\n                ans.push_back(i.first);\\n                v=i.second;\\n            }\\n            else if(v==i.second)\\n            {\\n                ans.push_back(i.first);\\n            }\\n        }\\n        return ans; \\n    }\\n```\n```\\nvector<int> findMode(TreeNode* root) {\\n        vector<int> ans;\\n        TreeNode* start=NULL;\\n        TreeNode* temp=root;\\n        TreeNode* temp2=root;\\n        if(!root)return ans;\\n        while(root)\\n        {\\n            if(root->left)\\n            {\\n                temp=root->left;\\n                while(temp->right)\\n                {\\n                    temp=temp->right;\\n                }\\n                temp->right=root;\\n                temp=root->left;\\n                root->left=NULL;\\n                root=temp;\\n                if(start!=NULL)\\n                {\\n                    temp2->right=root;\\n                }\\n            }\\n            else\\n            {\\n                if(start==NULL)\\n                {\\n                    start=root;\\n                }\\n                temp2=root;\\n                root=root->right;\\n            }\\n        }  \\n        root=start;\\n        start=start->right;\\n        int mc=0;\\n        int fmc=-1;\\n        while(root!=NULL)\\n        {\\n            while(start!=NULL && start->val==root->val)\\n            {\\n                mc++;\\n                start=start->right;\\n            }\\n            if(mc>fmc)\\n            {\\n                int s=ans.size();\\n                while(s--)\\n                {\\n                    ans.pop_back();\\n                }\\n                ans.push_back(root->val);\\n                fmc=mc;\\n            }\\n            else if(mc==fmc)\\n            {\\n                ans.push_back(root->val);\\n            }\\n            mc=0;\\n            root=start;\\n            if(start)start=start->right;\\n        }\\n        if(fmc==-1)\\n        {\\n            ans.push_back(root->val);\\n        }\\n         return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 928583,
                "title": "javascript-iterative-solution",
                "content": "```\\nvar findMode = function(root) {\\n    const output = [];\\n    if (!root) return output;\\n    const obj = {};\\n    const q = [root];\\n    let most = 0;\\n    \\n    while (q.length) {\\n        const cur = q.shift();\\n        if (obj[cur.val]) {\\n            obj[cur.val] += 1;\\n        } else {\\n            obj[cur.val] = 1;\\n        }\\n\\n        if (obj[cur.val] > most) most = obj[cur.val];\\n        if (cur.left) q.push(cur.left);\\n        if (cur.right) q.push(cur.right);\\n    }\\n    \\n    for (let n in obj) {\\n        if (obj[n] === most) output.push(n);\\n    }\\n    \\n    return output;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findMode = function(root) {\\n    const output = [];\\n    if (!root) return output;\\n    const obj = {};\\n    const q = [root];\\n    let most = 0;\\n    \\n    while (q.length) {\\n        const cur = q.shift();\\n        if (obj[cur.val]) {\\n            obj[cur.val] += 1;\\n        } else {\\n            obj[cur.val] = 1;\\n        }\\n\\n        if (obj[cur.val] > most) most = obj[cur.val];\\n        if (cur.left) q.push(cur.left);\\n        if (cur.right) q.push(cur.right);\\n    }\\n    \\n    for (let n in obj) {\\n        if (obj[n] === most) output.push(n);\\n    }\\n    \\n    return output;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 890396,
                "title": "python-dfs-in-order-constant-extra-space-beyond-dfs",
                "content": "```\\nclass Solution:\\n    def findMode(self, root: TreeNode) -> List[int]:\\n        def dfs(node):\\n            if not node:\\n                return\\n            \\n            dfs(node.left)\\n            \\n            if node.val == self.value:\\n                self.value_count += 1\\n                if self.value_count == self.mode_count:\\n                    self.modes.append(node.val)\\n                elif self.value_count > self.mode_count:\\n                    self.mode_count = self.value_count\\n                    self.modes = [node.val]\\n            else:\\n                self.value = node.val\\n                self.value_count = 1\\n                if not self.modes:\\n                    self.modes = [node.val]\\n                elif self.mode_count == 1:\\n                    self.modes.append(node.val)\\n            \\n            dfs(node.right)        \\n        \\n        self.value = None\\n        self.value_count = 0       \\n        self.modes = []\\n        self.mode_count = 1        \\n        \\n        dfs(root)\\n        \\n        return self.modes\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMode(self, root: TreeNode) -> List[int]:\\n        def dfs(node):\\n            if not node:\\n                return\\n            \\n            dfs(node.left)\\n            \\n            if node.val == self.value:\\n                self.value_count += 1\\n                if self.value_count == self.mode_count:\\n                    self.modes.append(node.val)\\n                elif self.value_count > self.mode_count:\\n                    self.mode_count = self.value_count\\n                    self.modes = [node.val]\\n            else:\\n                self.value = node.val\\n                self.value_count = 1\\n                if not self.modes:\\n                    self.modes = [node.val]\\n                elif self.mode_count == 1:\\n                    self.modes.append(node.val)\\n            \\n            dfs(node.right)        \\n        \\n        self.value = None\\n        self.value_count = 0       \\n        self.modes = []\\n        self.mode_count = 1        \\n        \\n        dfs(root)\\n        \\n        return self.modes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 856234,
                "title": "my-python-solution-using-dictionary-extra-space",
                "content": "```\\n\"\"\"\\nMy thought process:\\n\\nHere we need to get the most frequent elemnt and move it to a list and this list have to be finally return.\\nSo I here uses a dfs approach through which we go through each and every elemnt in the tree and add them into a dictionary along with their frequency.\\n\\nThen I iterate throgh the dictionary once and find out what is the possible maximum frequency that is in our tree. So there can be multiple values with the maximum frequency, so we need to conside them too.\\n\\nSo after obtaining the maximum frequency, I again iterate through the dictionary and add all the keys of the dictionary which is actually the elements in the tree and find out if its frequency is the maximum or not. If its maximum I simply append it into the resultList> So  by doing this I get all the numbers with maximum frequency if there exists multiple such elements.\\n\\nSo thats my thought process. \\nbut here a follow up is given, to do without extra space but I couldnt get it how.\\n\\n\"\"\"\\n\\n\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findMode(self, root: TreeNode) -> List[int]:\\n        if root == None:\\n            return []\\n        resultList = []\\n        dictionary = {}\\n        def dfs(root):\\n            if root == None:\\n                return None\\n            if (root.val in dictionary):\\n                dictionary[root.val] += 1\\n            else:\\n                dictionary[root.val] = 1\\n            dfs(root.left)\\n            dfs(root.right)\\n        dfs(root)\\n        maximum = 0\\n        for k, v in dictionary.items():\\n            if (dictionary[k] > maximum):\\n                maximum = v\\n        \\n        for k, v in dictionary.items():\\n            if v == maximum:\\n                resultList.append(k)\\n        return resultList\\n            \\n                \\n        \\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\n\"\"\"\\nMy thought process:\\n\\nHere we need to get the most frequent elemnt and move it to a list and this list have to be finally return.\\nSo I here uses a dfs approach through which we go through each and every elemnt in the tree and add them into a dictionary along with their frequency.\\n\\nThen I iterate throgh the dictionary once and find out what is the possible maximum frequency that is in our tree. So there can be multiple values with the maximum frequency, so we need to conside them too.\\n\\nSo after obtaining the maximum frequency, I again iterate through the dictionary and add all the keys of the dictionary which is actually the elements in the tree and find out if its frequency is the maximum or not. If its maximum I simply append it into the resultList> So  by doing this I get all the numbers with maximum frequency if there exists multiple such elements.\\n\\nSo thats my thought process. \\nbut here a follow up is given, to do without extra space but I couldnt get it how.\\n\\n\"\"\"\\n\\n\\n\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findMode(self, root: TreeNode) -> List[int]:\\n        if root == None:\\n            return []\\n        resultList = []\\n        dictionary = {}\\n        def dfs(root):\\n            if root == None:\\n                return None\\n            if (root.val in dictionary):\\n                dictionary[root.val] += 1\\n            else:\\n                dictionary[root.val] = 1\\n            dfs(root.left)\\n            dfs(root.right)\\n        dfs(root)\\n        maximum = 0\\n        for k, v in dictionary.items():\\n            if (dictionary[k] > maximum):\\n                maximum = v\\n        \\n        for k, v in dictionary.items():\\n            if v == maximum:\\n                resultList.append(k)\\n        return resultList\\n            \\n                \\n        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 820640,
                "title": "c-o-1-space",
                "content": "```c++\\nclass Solution {\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> ans;\\n        int mxFreq=INT_MIN;\\n        int cnt=0;\\n        int prev=-1;\\n        inorder(root,ans,mxFreq,cnt,prev);\\n        return ans;\\n    }\\n    void inorder(TreeNode* root,vector<int> &ans,int &mxFreq,int &cnt,int &prev){\\n        if(root==NULL)return;\\n        inorder(root->left,ans,mxFreq,cnt,prev);\\n        if(root->val==prev)cnt++;\\n        else cnt=1;\\n        \\n        if(cnt>mxFreq){\\n            ans.clear();\\n            ans.push_back(root->val);\\n            mxFreq=cnt;\\n        }\\n        else if(cnt==mxFreq)\\n            ans.push_back(root->val);\\n        prev=root->val;\\n        inorder(root->right,ans,mxFreq,cnt,prev);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> ans;\\n        int mxFreq=INT_MIN;\\n        int cnt=0;\\n        int prev=-1;\\n        inorder(root,ans,mxFreq,cnt,prev);\\n        return ans;\\n    }\\n    void inorder(TreeNode* root,vector<int> &ans,int &mxFreq,int &cnt,int &prev){\\n        if(root==NULL)return;\\n        inorder(root->left,ans,mxFreq,cnt,prev);\\n        if(root->val==prev)cnt++;\\n        else cnt=1;\\n        \\n        if(cnt>mxFreq){\\n            ans.clear();\\n            ans.push_back(root->val);\\n            mxFreq=cnt;\\n        }\\n        else if(cnt==mxFreq)\\n            ans.push_back(root->val);\\n        prev=root->val;\\n        inorder(root->right,ans,mxFreq,cnt,prev);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 193985,
                "title": "python-code-easy-to-understand",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def findMode(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        count = {}\\n        \\n        def DFS(node):\\n            if node:\\n                count[node.val] = count.get(node.val,0) + 1\\n                DFS(node.left)\\n                DFS(node.right)\\n        if not root:\\n            return []\\n        \\n        DFS(root)\\n        most_frequent = max(count.values())\\n        \\n        res = [n for n,f in count.items() if f == most_frequent]\\n        \\n        return res\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def findMode(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        count = {}\\n        \\n        def DFS(node):\\n            if node:\\n                count[node.val] = count.get(node.val,0) + 1\\n                DFS(node.left)\\n                DFS(node.right)\\n        if not root:\\n            return []\\n        \\n        DFS(root)\\n        most_frequent = max(count.values())\\n        \\n        res = [n for n,f in count.items() if f == most_frequent]\\n        \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98108,
                "title": "javascript-solution-traverse-the-tree-only-once",
                "content": "Hi @StefanPochmann, your solution (https://discuss.leetcode.com/topic/77335/proper-o-1-space) is brilliant! I modified the `handleValue` a little bit so that we can traverse the tree only once. I really like the way how you handle the current value, current count, modes array and mode count, genius!\\n```\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst findMode = root => {\\n  const handleValue = val => {\\n    // handle current count\\n    if (val !== currVal) {\\n      currVal = val;\\n      currCount = 0;\\n    }\\n    currCount++;\\n\\n    if (currCount > maxCount) {\\n      // found a new mode\\n      maxCount = currCount;\\n      modeCount = 1;\\n      modes[0] = currVal;\\n    } else if (currCount === maxCount) {\\n      // found a mode with same count\\n      modes[modeCount] = currVal;\\n      modeCount++;\\n    }\\n  };\\n\\n  const inorder = node => {\\n    if (!node) return;\\n\\n    inorder(node.left);\\n    handleValue(node.val);\\n    inorder(node.right);\\n  };\\n\\n  let currVal = null;\\n  let currCount = 0;\\n  let maxCount = 0;\\n  let modeCount = 0;\\n\\n  const modes = [];\\n\\n  inorder(root);\\n\\n  return modes.slice(0, modeCount);\\n};\\n```\\nAnd here is the result of the JavaScript runtime:\\n![alt text](https://cdn-std.dprcdn.net/files/acc_592324/nkJbbz)",
                "solutionTags": [],
                "code": "```\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nconst findMode = root => {\\n  const handleValue = val => {\\n    // handle current count\\n    if (val !== currVal) {\\n      currVal = val;\\n      currCount = 0;\\n    }\\n    currCount++;\\n\\n    if (currCount > maxCount) {\\n      // found a new mode\\n      maxCount = currCount;\\n      modeCount = 1;\\n      modes[0] = currVal;\\n    } else if (currCount === maxCount) {\\n      // found a mode with same count\\n      modes[modeCount] = currVal;\\n      modeCount++;\\n    }\\n  };\\n\\n  const inorder = node => {\\n    if (!node) return;\\n\\n    inorder(node.left);\\n    handleValue(node.val);\\n    inorder(node.right);\\n  };\\n\\n  let currVal = null;\\n  let currCount = 0;\\n  let maxCount = 0;\\n  let modeCount = 0;\\n\\n  const modes = [];\\n\\n  inorder(root);\\n\\n  return modes.slice(0, modeCount);\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 98132,
                "title": "very-easy-to-understand-4ms-o-1-solution-with-detailed-explanation",
                "content": "Let's clarify the question first: what is considered to be O(1) in this question\\n\\nThe following space should not count:\\n1. the result array.\\n2. the stack in memory when calling recursion\\n\\nAnd all other non constant  variable should be not be considered as O(1). Thus, any list (arraylist, linkedlist etc), map should not count as the O(1) solution. \\n\\nIn order to come up with a O(1) solution, let's come up with a O(n) solution first. A simple example would be to traverse the tree in order and get a list. The list then will be sorted. Then count the occurrence of each element and get the max occurrence. Having the max occurrence, we can then find out every element with same occurrence.\\n\\nThis is a 3 pass solution. An O(1) solution will have similar process. In order to get rid of the sorted array holding all elements, we have to go recursive since the memory stack doesn't count (I think it's cheating). We can traverse the tree in order recursively and only remember the previous element.  \\n\\nThen, we need to know the max occurrence and how many elements have that occurrence. The size of the final result is needed because we can't use a list but array which requires the size when declared in JAVA (maybe other language doesn't have know the size ahead?). We can then traverse the tree twice, the first is to get max occurrence and  how many elements have that occurrence, the second time is to construct the final result.\\n\\n```\\npublic class Solution {\\n     int size;\\n     int count;\\n     TreeNode pre;\\n     int local_count;\\n    \\n    public  int[] findMode(TreeNode root) {\\n        if (root == null) {\\n            return new int[0];\\n        }\\n        \\n        size = 0;\\n        count = 0;\\n        local_count = 0;\\n        \\n        helper(root, null);\\n        int[] res = new int[size];\\n        local_count = 0; // reset the local_count var\\n        helper(root, res);\\n        \\n        return res;\\n    }\\n    \\n    private void helper(TreeNode cur, int[] res) {\\n        if (cur == null) {\\n        \\treturn;\\n        }\\n        \\n        helper(cur.left, res);\\n        \\n        if (pre != null && pre.val == cur.val) {\\n        \\tlocal_count++;\\n        }  else {\\n        \\tlocal_count = 1;\\n        }\\n        \\n       // only in the first pass, we calculate the count and size\\n        if (res == null) {\\n        \\tif (local_count > count) {\\n        \\t\\tcount = local_count;\\n        \\t\\tsize = 0;\\n        \\t}\\n        \\tif (local_count == count) {\\n        \\t\\tsize++;\\n        \\t}\\n        }\\n        \\n        if (res != null && local_count == count) {\\n            res[--size] = cur.val;\\n        }\\n        \\n        pre = cur;\\n        \\n        helper(cur.right, res);\\n    }\\n}\\n```\\nHere I used the result array being null or not to decide if it is the first pass or the second. If you don't like this, you can simply pass in a boolean. As seen in the code, only in the first pass, we calculate the occurrence. In the second pass, we only need to check if an element has max occurrence",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n     int size;\\n     int count;\\n     TreeNode pre;\\n     int local_count;\\n    \\n    public  int[] findMode(TreeNode root) {\\n        if (root == null) {\\n            return new int[0];\\n        }\\n        \\n        size = 0;\\n        count = 0;\\n        local_count = 0;\\n        \\n        helper(root, null);\\n        int[] res = new int[size];\\n        local_count = 0; // reset the local_count var\\n        helper(root, res);\\n        \\n        return res;\\n    }\\n    \\n    private void helper(TreeNode cur, int[] res) {\\n        if (cur == null) {\\n        \\treturn;\\n        }\\n        \\n        helper(cur.left, res);\\n        \\n        if (pre != null && pre.val == cur.val) {\\n        \\tlocal_count++;\\n        }  else {\\n        \\tlocal_count = 1;\\n        }\\n        \\n       // only in the first pass, we calculate the count and size\\n        if (res == null) {\\n        \\tif (local_count > count) {\\n        \\t\\tcount = local_count;\\n        \\t\\tsize = 0;\\n        \\t}\\n        \\tif (local_count == count) {\\n        \\t\\tsize++;\\n        \\t}\\n        }\\n        \\n        if (res != null && local_count == count) {\\n            res[--size] = cur.val;\\n        }\\n        \\n        pre = cur;\\n        \\n        helper(cur.right, res);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3923588,
                "title": "beats-90-cpp-sol",
                "content": "# **Upvote me if it Helped \\uD83E\\uDD79**\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void solve(TreeNode *root, unordered_map<int,int>&mpp){\\n        // base case\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        mpp[root->val]++;\\n        solve(root->left, mpp);\\n        solve(root->right, mpp);\\n    }\\n\\n    vector<int> findMode(TreeNode* root) {\\n        unordered_map<int,int>mpp;\\n        solve(root, mpp);\\n\\n        // now every tree element is mapped \\n        // finding the maxi times an element is occuring \\n        int occur = 0;\\n        int maxi = 0;\\n        for(auto &i : mpp){\\n            if(i.second > maxi){\\n                maxi = i.second;\\n            }\\n        }\\n\\n        vector<int>ans;\\n        for(auto &i : mpp){\\n            if(i.second == maxi){\\n                ans.push_back(i.first);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void solve(TreeNode *root, unordered_map<int,int>&mpp){\\n        // base case\\n        if(root == NULL){\\n            return;\\n        }\\n\\n        mpp[root->val]++;\\n        solve(root->left, mpp);\\n        solve(root->right, mpp);\\n    }\\n\\n    vector<int> findMode(TreeNode* root) {\\n        unordered_map<int,int>mpp;\\n        solve(root, mpp);\\n\\n        // now every tree element is mapped \\n        // finding the maxi times an element is occuring \\n        int occur = 0;\\n        int maxi = 0;\\n        for(auto &i : mpp){\\n            if(i.second > maxi){\\n                maxi = i.second;\\n            }\\n        }\\n\\n        vector<int>ans;\\n        for(auto &i : mpp){\\n            if(i.second == maxi){\\n                ans.push_back(i.first);\\n            }\\n        }\\n\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534712,
                "title": "why-this-solution-beats-100-java",
                "content": "\\n# Code\\n```\\nclass Solution {\\n    Map<Integer, Integer> map;\\n    public int[] findMode(TreeNode root) {\\n        map = new HashMap<>();\\n        searchInBST(root);\\n        int maxFreq = -1;\\n        List<Integer> list = new ArrayList<>();\\n        for (int key : map.keySet()) {\\n            int freq = map.get(key);\\n            if (maxFreq < freq) {\\n                maxFreq = freq;\\n                list.clear();\\n                list.add(key);\\n                continue;\\n            }\\n            if (maxFreq == freq) {\\n                list.add(key);\\n            }\\n        }\\n        int[] res = new int[list.size()];\\n        for (int i = 0; i < list.size(); i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n\\n    private void searchInBST(TreeNode node) {\\n        if (node == null) return;\\n\\n        if (map.containsKey(node.val)) {\\n            map.put(node.val, map.get(node.val) + 1);\\n        } else {\\n            map.put(node.val, 1);\\n        }\\n\\n        searchInBST(node.left);\\n        searchInBST(node.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table",
                    "Breadth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> map;\\n    public int[] findMode(TreeNode root) {\\n        map = new HashMap<>();\\n        searchInBST(root);\\n        int maxFreq = -1;\\n        List<Integer> list = new ArrayList<>();\\n        for (int key : map.keySet()) {\\n            int freq = map.get(key);\\n            if (maxFreq < freq) {\\n                maxFreq = freq;\\n                list.clear();\\n                list.add(key);\\n                continue;\\n            }\\n            if (maxFreq == freq) {\\n                list.add(key);\\n            }\\n        }\\n        int[] res = new int[list.size()];\\n        for (int i = 0; i < list.size(); i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n\\n    private void searchInBST(TreeNode node) {\\n        if (node == null) return;\\n\\n        if (map.containsKey(node.val)) {\\n            map.put(node.val, map.get(node.val) + 1);\\n        } else {\\n            map.put(node.val, 1);\\n        }\\n\\n        searchInBST(node.left);\\n        searchInBST(node.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163076,
                "title": "faster-than-74-in-time-easy-solution-using-breadth-first-search-python",
                "content": "# *Intuition*\\n*When we first read the question, we immediately see that we must obtain the values for each node before we can determine the maximum number of nodes with the same value.*\\n\\n# *Approach*\\n*So, in order to accomplish that (reach every node), we will employ breadth-first search. Then we can easily discover the most frequent node value.*\\n\\n# *Complexity*\\n- *Time complexity: 3n = O(n)*\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- *Space complexity: O(n)*\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# *Code*\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        def bfs(freq):\\n            queue = [root]\\n            while queue:\\n                curr= queue.pop()\\n                if curr.left:\\n                    queue.append(curr.left)\\n                if curr.right:\\n                    queue.append(curr.right)\\n                freq.setdefault(curr.val, 0)\\n                freq[curr.val] += 1\\n        \\n        freq = {}\\n        bfs(freq)\\n        freq = freq.items()\\n        ans = []\\n        max_cnt = 0\\n\\n        for num, cnt in freq:\\n            if cnt > max_cnt:\\n                max_cnt = cnt\\n\\n        for num, cnt in freq:\\n            if cnt == max_cnt:\\n                ans.append(num)\\n        return ans\\n```",
                "solutionTags": [
                    "Python3",
                    "Tree",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        def bfs(freq):\\n            queue = [root]\\n            while queue:\\n                curr= queue.pop()\\n                if curr.left:\\n                    queue.append(curr.left)\\n                if curr.right:\\n                    queue.append(curr.right)\\n                freq.setdefault(curr.val, 0)\\n                freq[curr.val] += 1\\n        \\n        freq = {}\\n        bfs(freq)\\n        freq = freq.items()\\n        ans = []\\n        max_cnt = 0\\n\\n        for num, cnt in freq:\\n            if cnt > max_cnt:\\n                max_cnt = cnt\\n\\n        for num, cnt in freq:\\n            if cnt == max_cnt:\\n                ans.append(num)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3163049,
                "title": "c-easy-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int>& in){\\n        if(root==NULL) return;\\n        inorder(root->left,in);\\n        in.push_back(root->val);\\n        inorder(root->right,in);\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> in;\\n        inorder(root,in);\\n        int mx=INT_MIN;\\n        unordered_map<int,int> mp;\\n\\n        for(int i=0;i<in.size();i++){\\n            mp[in[i]]++;\\n            mx=max(mp[in[i]],mx);\\n        }\\n        vector<int> res;\\n        for(auto it:mp){\\n            if(it.second==mx) res.push_back(it.first);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, vector<int>& in){\\n        if(root==NULL) return;\\n        inorder(root->left,in);\\n        in.push_back(root->val);\\n        inorder(root->right,in);\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> in;\\n        inorder(root,in);\\n        int mx=INT_MIN;\\n        unordered_map<int,int> mp;\\n\\n        for(int i=0;i<in.size();i++){\\n            mp[in[i]]++;\\n            mx=max(mp[in[i]],mx);\\n        }\\n        vector<int> res;\\n        for(auto it:mp){\\n            if(it.second==mx) res.push_back(it.first);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2956717,
                "title": "0ms-solution-depth-first-search-o-n-time-o-n-space-java",
                "content": "```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D.\\n```\\n# Code :\\n```\\nclass Solution \\n{\\n    int curCount=1,maxCount=0;\\n    TreeNode prev;\\n    public int[] findMode(TreeNode root) \\n    {\\n        if (root == null) \\n            return new int[0];\\n        \\n        List<Integer> list = new ArrayList<>();\\n        inorder(root, list);\\n        int[] res = new int[list.size()];\\n\\n        for (int i = 0; i < list.size(); i++) \\n            res[i] = list.get(i);\\n        return res;\\n        \\n    }\\n    public void inorder(TreeNode root,List<Integer> list)\\n    {\\n        if (root == null) \\n            return;\\n        inorder(root.left, list);\\n        if (prev != null) \\n        {\\n            if (root.val == prev.val)\\n                curCount++;\\n            else \\n                curCount = 1;\\n        }\\n        prev = new TreeNode(root.val);\\n        if (curCount > maxCount) \\n        {\\n            maxCount = curCount;\\n            list.clear();\\n            list.add(root.val);\\n        } \\n        else if (curCount == maxCount) \\n            list.add(root.val);\\n        inorder(root.right, list);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Tree",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\nIf you find these solutions easy to understand and helpful, then\\nPlease Upvote\\uD83D\\uDC4D\\uD83D\\uDC4D.\\n```\n```\\nclass Solution \\n{\\n    int curCount=1,maxCount=0;\\n    TreeNode prev;\\n    public int[] findMode(TreeNode root) \\n    {\\n        if (root == null) \\n            return new int[0];\\n        \\n        List<Integer> list = new ArrayList<>();\\n        inorder(root, list);\\n        int[] res = new int[list.size()];\\n\\n        for (int i = 0; i < list.size(); i++) \\n            res[i] = list.get(i);\\n        return res;\\n        \\n    }\\n    public void inorder(TreeNode root,List<Integer> list)\\n    {\\n        if (root == null) \\n            return;\\n        inorder(root.left, list);\\n        if (prev != null) \\n        {\\n            if (root.val == prev.val)\\n                curCount++;\\n            else \\n                curCount = 1;\\n        }\\n        prev = new TreeNode(root.val);\\n        if (curCount > maxCount) \\n        {\\n            maxCount = curCount;\\n            list.clear();\\n            list.add(root.val);\\n        } \\n        else if (curCount == maxCount) \\n            list.add(root.val);\\n        inorder(root.right, list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2760664,
                "title": "java-0ms-beats-100-o-1-space-solution",
                "content": "This is my solution without additonal space or map. Here I am using a \"prev\" node pointer to compare the previous node with the current node and update the count.\\n\\nAlso, I am doing inorder traversal, since the probability of finding nodes with same values close is the best that way.\\n\\n```\\n\\tint max = Integer.MIN_VALUE;\\n    int count = 1;\\n    List<Integer> list = new ArrayList<>();\\n    TreeNode prev = null;\\n    \\n    public int[] findMode(TreeNode root) {\\n        \\n        getModes(root, list);\\n            \\n        int[] result = new int[list.size()];\\n        for(int i=0; i<list.size(); i++) {\\n            result[i] = list.get(i);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void getModes(TreeNode root, List<Integer> list) {\\n        \\n        if(root == null) {\\n            return;\\n        }\\n        \\n        getModes(root.left, list);\\n        \\n        if(prev != null) {\\n            if(prev.val == root.val) {\\n                count++;\\n            } else {\\n                count = 1;\\n            }\\n        }\\n        \\n         \\n        if(count > max) {\\n          max = count;\\n          list.clear();\\n          list.add(root.val);\\n        } else if(count == max) {\\n          list.add(root.val);\\n        }\\n        \\n        prev = root;\\n        \\n        getModes(root.right, list);\\n        \\n    }\\n\\t",
                "solutionTags": [
                    "Java"
                ],
                "code": "This is my solution without additonal space or map. Here I am using a \"prev\" node pointer to compare the previous node with the current node and update the count.\\n\\nAlso, I am doing inorder traversal, since the probability of finding nodes with same values close is the best that way.\\n\\n```\\n\\tint max = Integer.MIN_VALUE;\\n    int count = 1;\\n    List<Integer> list = new ArrayList<>();\\n    TreeNode prev = null;\\n    \\n    public int[] findMode(TreeNode root) {\\n        \\n        getModes(root, list);\\n            \\n        int[] result = new int[list.size()];\\n        for(int i=0; i<list.size(); i++) {\\n            result[i] = list.get(i);\\n        }\\n        \\n        return result;\\n    }\\n    \\n    private void getModes(TreeNode root, List<Integer> list) {\\n        \\n        if(root == null) {\\n            return;\\n        }\\n        \\n        getModes(root.left, list);\\n        \\n        if(prev != null) {\\n            if(prev.val == root.val) {\\n                count++;\\n            } else {\\n                count = 1;\\n            }\\n        }\\n        \\n         \\n        if(count > max) {\\n          max = count;\\n          list.clear();\\n          list.add(root.val);\\n        } else if(count == max) {\\n          list.add(root.val);\\n        }\\n        \\n        prev = root;\\n        \\n        getModes(root.right, list);\\n        \\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2758440,
                "title": "java-hashmap-clean-and-simple",
                "content": "### **Please Upvote** :D\\n```\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap<>();\\n\\n    public int[] findMode(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        dfs(root);\\n\\n        int max = Collections.max(map.values());\\n\\n        for (int key : map.keySet()) {\\n            if (map.get(key) == max) {\\n                ans.add(key);\\n            }\\n        }\\n\\n        return ans.stream().mapToInt(i -> i).toArray();\\n\\n    }\\n\\n    public void dfs(TreeNode root) {\\n        if (root == null) return;\\n        \\n        map.put(root.val, map.getOrDefault(root.val, 0) + 1);\\n        \\n        dfs(root.left);\\n        dfs(root.right);\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap<>();\\n\\n    public int[] findMode(TreeNode root) {\\n        List<Integer> ans = new ArrayList<>();\\n        dfs(root);\\n\\n        int max = Collections.max(map.values());\\n\\n        for (int key : map.keySet()) {\\n            if (map.get(key) == max) {\\n                ans.add(key);\\n            }\\n        }\\n\\n        return ans.stream().mapToInt(i -> i).toArray();\\n\\n    }\\n\\n    public void dfs(TreeNode root) {\\n        if (root == null) return;\\n        \\n        map.put(root.val, map.getOrDefault(root.val, 0) + 1);\\n        \\n        dfs(root.left);\\n        dfs(root.right);\\n    }\\n}\\n\\n// TC: O(n), SC: O(n)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2157636,
                "title": "two-easy-approaches-explained-code-in-cpp",
                "content": "**Here I used two apraoches which us O(N) space and another O(1)**\\n\\n**Appraoch One using hashmap - Order(N) space**\\n\\n```\\n#define MAX(x,y) x>y?x:y\\nclass Solution {\\nprivate:\\n    unordered_map<int,int> m;\\n    void travel(TreeNode* root){\\n        if(!root)\\n            return;\\n        \\n        m[root->val]++;\\n        travel(root->left);\\n        travel(root->right);\\n    }\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        travel(root);\\n\\t\\t//maxi used to store max count frequency occured\\n        int maxi=0;\\n        \\n        for(auto q:m){\\n            maxi=MAX(maxi,q.second);\\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(auto q:m){\\n\\t\\t// if matches max frequency then add to answer\\n            if(q.second==maxi)\\n                ans.push_back(q.first);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**Approach 2 using const space - O(1) Explained**\\n\\n```\\n#define MAX(x,y) x>y?x:y\\nclass Solution {\\nprivate:\\n    int maxi=0;   // to store max frequency occured\\n    int count=0;  // to count current variable occurence\\n    int curr=0;   // to store current root value\\n    vector<int> ans;\\n    void travel(int val){\\n        // if previous value doesnt match update\\n        if(val!=curr){\\n            curr=val;\\n            count=1;\\n        }else\\n\\t\\t//this represent the node is visited previously hence count is increased\\n            count++;\\n        \\n        // if maxi is less than previous frequency then update\\n        if(maxi<count){\\n            maxi=count;\\n            //this node has maximum count hence we should delete the previous vector.\\n\\t\\t\\t//So we are setting the value of vector to this value and max_count as this count.\\n            ans={val};\\n        }else if(maxi==count)\\n            ans.push_back(val);\\n    }\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        if(!root)\\n            return {};\\n        \\n        findMode(root->left);\\n        travel(root->val);\\n        findMode(root->right);\\n        \\n        return ans;\\n    }\\n};\\n```\\n\\n**If you have any doubt please ask in comments and thank you**\\n\\n**Happy Coding**\\n\\n**Please Upvote**",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n#define MAX(x,y) x>y?x:y\\nclass Solution {\\nprivate:\\n    unordered_map<int,int> m;\\n    void travel(TreeNode* root){\\n        if(!root)\\n            return;\\n        \\n        m[root->val]++;\\n        travel(root->left);\\n        travel(root->right);\\n    }\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        travel(root);\\n\\t\\t//maxi used to store max count frequency occured\\n        int maxi=0;\\n        \\n        for(auto q:m){\\n            maxi=MAX(maxi,q.second);\\n        }\\n        \\n        vector<int> ans;\\n        \\n        for(auto q:m){\\n\\t\\t// if matches max frequency then add to answer\\n            if(q.second==maxi)\\n                ans.push_back(q.first);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```\n```\\n#define MAX(x,y) x>y?x:y\\nclass Solution {\\nprivate:\\n    int maxi=0;   // to store max frequency occured\\n    int count=0;  // to count current variable occurence\\n    int curr=0;   // to store current root value\\n    vector<int> ans;\\n    void travel(int val){\\n        // if previous value doesnt match update\\n        if(val!=curr){\\n            curr=val;\\n            count=1;\\n        }else\\n\\t\\t//this represent the node is visited previously hence count is increased\\n            count++;\\n        \\n        // if maxi is less than previous frequency then update\\n        if(maxi<count){\\n            maxi=count;\\n            //this node has maximum count hence we should delete the previous vector.\\n\\t\\t\\t//So we are setting the value of vector to this value and max_count as this count.\\n            ans={val};\\n        }else if(maxi==count)\\n            ans.push_back(val);\\n    }\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        if(!root)\\n            return {};\\n        \\n        findMode(root->left);\\n        travel(root->val);\\n        findMode(root->right);\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1744309,
                "title": "java-easy-recursive",
                "content": "```\\nclass Solution {\\n    Integer prev=null;\\n    int count=1;\\n    int max=0;\\n    public int[] findMode(TreeNode root) {\\n        List<Integer> list=new ArrayList<>();\\n        traverseInorder(root,list);\\n        \\n        //copying the contents of list back to array\\n        int[] res=new int[list.size()];\\n        for(int i=0;i<res.length;i++){\\n            res[i]=list.get(i);\\n        }\\n        return res;\\n    }\\n    public void traverseInorder(TreeNode node,List<Integer> list){\\n        if(node==null){\\n            return;\\n        }\\n        \\n        traverseInorder(node.left,list);\\n       \\n        //if prev is not null\\n        if(prev!=null){\\n            //check if value is equal to the current value and increment count\\n            if(prev==node.val){\\n                count++;\\n            }\\n            else{\\n                count=1;\\n            }\\n        }\\n        \\n        if(count>max){\\n            max=count;\\n            list.clear();\\n            list.add(node.val);\\n        }\\n        else if(count==max){\\n            list.add(node.val);\\n        }\\n        //to store the previous node and later compare it to the next node\\n        prev=node.val;\\n        traverseInorder(node.right,list);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    Integer prev=null;\\n    int count=1;\\n    int max=0;\\n    public int[] findMode(TreeNode root) {\\n        List<Integer> list=new ArrayList<>();\\n        traverseInorder(root,list);\\n        \\n        //copying the contents of list back to array\\n        int[] res=new int[list.size()];\\n        for(int i=0;i<res.length;i++){\\n            res[i]=list.get(i);\\n        }\\n        return res;\\n    }\\n    public void traverseInorder(TreeNode node,List<Integer> list){\\n        if(node==null){\\n            return;\\n        }\\n        \\n        traverseInorder(node.left,list);\\n       \\n        //if prev is not null\\n        if(prev!=null){\\n            //check if value is equal to the current value and increment count\\n            if(prev==node.val){\\n                count++;\\n            }\\n            else{\\n                count=1;\\n            }\\n        }\\n        \\n        if(count>max){\\n            max=count;\\n            list.clear();\\n            list.add(node.val);\\n        }\\n        else if(count==max){\\n            list.add(node.val);\\n        }\\n        //to store the previous node and later compare it to the next node\\n        prev=node.val;\\n        traverseInorder(node.right,list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1685501,
                "title": "c-map-vector",
                "content": "this code using by inorder and  map and vector\\n```\\n\\nclass Solution {\\npublic:\\n    vector<int> inorde;\\n    map<int,int> mp;                                                                                                                                                                                                                                                                                      \\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left);\\n        mp[root->val]++;\\n        inorder(root->right);\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        inorder(root);\\n        int mx=0;\\n        for (auto& y: mp)\\n        {\\n            mx=max(mx,y.second);\\n        }\\n       for (auto& x: mp) {\\n           if(x.second>=mx)\\n               inorde.push_back(x.first);\\n    }\\n        if(inorde.size()==0)\\n            return {0};\\n    return inorde;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    vector<int> inorde;\\n    map<int,int> mp;                                                                                                                                                                                                                                                                                      \\n    void inorder(TreeNode* root)\\n    {\\n        if(!root)\\n            return;\\n        inorder(root->left);\\n        mp[root->val]++;\\n        inorder(root->right);\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        inorder(root);\\n        int mx=0;\\n        for (auto& y: mp)\\n        {\\n            mx=max(mx,y.second);\\n        }\\n       for (auto& x: mp) {\\n           if(x.second>=mx)\\n               inorde.push_back(x.first);\\n    }\\n        if(inorde.size()==0)\\n            return {0};\\n    return inorde;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1647967,
                "title": "c-o-n-solution-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, int &prev, int &maxx, int& curr_count, vector<int>& res){\\n        if(root){\\n            inorder(root->left, prev, maxx, curr_count, res);\\n            if(prev == root->val) curr_count++;\\n            else{\\n                prev = root->val;\\n                curr_count = 0;\\n            }\\n            \\n            if(curr_count == maxx){\\n                res.push_back(root->val);\\n            }\\n            else if(curr_count > maxx){ \\n                maxx = curr_count;\\n                res = {};\\n                res.push_back(root->val);\\n            }\\n            inorder(root->right, prev, maxx, curr_count, res);\\n        }\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> res;\\n        int prev = INT_MIN;\\n        int curr_count = 0;\\n        int maxx = INT_MIN;\\n        inorder(root, prev, maxx, curr_count, res);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorder(TreeNode* root, int &prev, int &maxx, int& curr_count, vector<int>& res){\\n        if(root){\\n            inorder(root->left, prev, maxx, curr_count, res);\\n            if(prev == root->val) curr_count++;\\n            else{\\n                prev = root->val;\\n                curr_count = 0;\\n            }\\n            \\n            if(curr_count == maxx){\\n                res.push_back(root->val);\\n            }\\n            else if(curr_count > maxx){ \\n                maxx = curr_count;\\n                res = {};\\n                res.push_back(root->val);\\n            }\\n            inorder(root->right, prev, maxx, curr_count, res);\\n        }\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> res;\\n        int prev = INT_MIN;\\n        int curr_count = 0;\\n        int maxx = INT_MIN;\\n        inorder(root, prev, maxx, curr_count, res);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1530003,
                "title": "inorder-traversal-and-counter-solution",
                "content": "#Inorder traversal and counter solution\\n#O(N)T|O(N) space\\nApproach:\\n1)First store the tree in array,then use counter/hash for finding most frequent element \\n\\n\\n\\n\\n\\tfrom collections import defaultdict,Counter\\n\\n\\tclass Solution:\\n\\t\\tdef findMode(self, root: Optional[TreeNode]) -> List[int]:\\n\\n\\t\\t\\tdef traverse(node,li):\\n\\n\\t\\t\\t\\tif node is None:\\n\\t\\t\\t\\t\\treturn \\n\\t\\t\\t\\ttraverse(node.left,li)\\n\\t\\t\\t\\tli.append(node.val)   \\n\\t\\t\\t\\ttraverse(node.right,li)\\n\\n\\t\\t\\tconvertToList_array=[]          \\n\\t\\t\\ttraverse(root,convertToList_array)\\n\\n\\t\\t\\tcountMostFrequentElement=Counter(convertToList_array) \\n\\t\\t\\tmax_value=max(countMostFrequentElement.values())\\n\\n\\t\\t\\tmostFrequentElement=[]\\n\\t\\t\\tfor key,value in countMostFrequentElement.items():\\n\\t\\t\\t\\tif max_value==value:\\n\\t\\t\\t\\t\\tmostFrequentElement.append(key)\\n\\n\\t\\t\\treturn  mostFrequentElement\\n",
                "solutionTags": [
                    "Python3"
                ],
                "code": "#Inorder traversal and counter solution\\n#O(N)T|O(N) space\\nApproach:\\n1)First store the tree in array,then use counter/hash for finding most frequent element \\n\\n\\n\\n\\n\\tfrom collections import defaultdict,Counter\\n\\n\\tclass Solution:\\n\\t\\tdef findMode(self, root: Optional[TreeNode]) -> List[int]:\\n\\n\\t\\t\\tdef traverse(node,li):\\n\\n\\t\\t\\t\\tif node is None:\\n\\t\\t\\t\\t\\treturn \\n\\t\\t\\t\\ttraverse(node.left,li)\\n\\t\\t\\t\\tli.append(node.val)   \\n\\t\\t\\t\\ttraverse(node.right,li)\\n\\n\\t\\t\\tconvertToList_array=[]          \\n\\t\\t\\ttraverse(root,convertToList_array)\\n\\n\\t\\t\\tcountMostFrequentElement=Counter(convertToList_array) \\n\\t\\t\\tmax_value=max(countMostFrequentElement.values())\\n\\n\\t\\t\\tmostFrequentElement=[]\\n\\t\\t\\tfor key,value in countMostFrequentElement.items():\\n\\t\\t\\t\\tif max_value==value:\\n\\t\\t\\t\\t\\tmostFrequentElement.append(key)\\n\\n\\t\\t\\treturn  mostFrequentElement\\n",
                "codeTag": "Java"
            },
            {
                "id": 1379297,
                "title": "c-two-solutions-hashmap-sc-o-n-2-times-inorder-traversal-sc-o-1",
                "content": "Hashmap based Solution\\n```\\nclass Solution {\\npublic:\\n   void inorder(TreeNode *root, unordered_map<int, int> &umap)\\n{\\n    if (root == NULL)\\n        return;\\n    inorder(root->left, umap);\\n    umap[root->val] += 1;\\n    inorder(root->right, umap);\\n}\\nvector<int> findMode(TreeNode *root)\\n{\\n    unordered_map<int, int> umap;\\n    inorder(root, umap);\\n    vector<int> ans;\\n\\n    int maxval = INT_MIN;\\n    int key;\\n    for (auto e : umap)\\n    {\\n        maxval = max(maxval, e.second);\\n    }\\n    for (auto e : umap)\\n    {\\n        if (e.second == maxval)\\n            ans.push_back(e.first);\\n    }\\n    return ans;\\n}\\n};\\n```\\n\\n\\nInorder Traversal based Solution\\n```\\nclass Solution {\\npublic:\\nTreeNode *prev = NULL;\\nvoid inorder(TreeNode *root, int &maxfre, int &currfreq)\\n{\\n    if (root == NULL)\\n        return;\\n    inorder(root->left, maxfre, currfreq);\\n    if (prev != NULL)\\n    {\\n        if (prev->val == root->val)\\n            currfreq++;\\n        else\\n            currfreq = 1;\\n        maxfre = max(currfreq, maxfre);\\n    }\\n    prev = root;\\n    inorder(root->right, maxfre, currfreq);\\n}\\n\\n    \\nvoid addtolist(vector<int> &ans, TreeNode *root, int &maxfreq, int &currfreq)\\n{\\n    if (root == NULL)\\n        return;\\n    addtolist(ans, root->left, maxfreq, currfreq);\\n    if (prev != NULL)\\n    {\\n        if (prev->val == root->val)\\n            currfreq++;\\n        else\\n            currfreq = 1;\\n\\n        if (currfreq == maxfreq)\\n        {\\n            ans.push_back(root->val);\\n        }\\n    }\\n    prev = root;\\n    addtolist(ans, root->right, maxfreq, currfreq);\\n}\\n    \\n    \\n    vector<int> findMode(TreeNode* root) {\\n        int maxfreq = 1;\\n        int currfreq=1;\\n        vector<int> ans;\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            ans.push_back(root->val);\\n            return ans;\\n        }\\n        inorder(root,maxfreq,currfreq);\\n        currfreq=1;\\n        addtolist(ans,root,maxfreq,currfreq);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n   void inorder(TreeNode *root, unordered_map<int, int> &umap)\\n{\\n    if (root == NULL)\\n        return;\\n    inorder(root->left, umap);\\n    umap[root->val] += 1;\\n    inorder(root->right, umap);\\n}\\nvector<int> findMode(TreeNode *root)\\n{\\n    unordered_map<int, int> umap;\\n    inorder(root, umap);\\n    vector<int> ans;\\n\\n    int maxval = INT_MIN;\\n    int key;\\n    for (auto e : umap)\\n    {\\n        maxval = max(maxval, e.second);\\n    }\\n    for (auto e : umap)\\n    {\\n        if (e.second == maxval)\\n            ans.push_back(e.first);\\n    }\\n    return ans;\\n}\\n};\\n```\n```\\nclass Solution {\\npublic:\\nTreeNode *prev = NULL;\\nvoid inorder(TreeNode *root, int &maxfre, int &currfreq)\\n{\\n    if (root == NULL)\\n        return;\\n    inorder(root->left, maxfre, currfreq);\\n    if (prev != NULL)\\n    {\\n        if (prev->val == root->val)\\n            currfreq++;\\n        else\\n            currfreq = 1;\\n        maxfre = max(currfreq, maxfre);\\n    }\\n    prev = root;\\n    inorder(root->right, maxfre, currfreq);\\n}\\n\\n    \\nvoid addtolist(vector<int> &ans, TreeNode *root, int &maxfreq, int &currfreq)\\n{\\n    if (root == NULL)\\n        return;\\n    addtolist(ans, root->left, maxfreq, currfreq);\\n    if (prev != NULL)\\n    {\\n        if (prev->val == root->val)\\n            currfreq++;\\n        else\\n            currfreq = 1;\\n\\n        if (currfreq == maxfreq)\\n        {\\n            ans.push_back(root->val);\\n        }\\n    }\\n    prev = root;\\n    addtolist(ans, root->right, maxfreq, currfreq);\\n}\\n    \\n    \\n    vector<int> findMode(TreeNode* root) {\\n        int maxfreq = 1;\\n        int currfreq=1;\\n        vector<int> ans;\\n        if(root->left==NULL && root->right==NULL)\\n        {\\n            ans.push_back(root->val);\\n            return ans;\\n        }\\n        inorder(root,maxfreq,currfreq);\\n        currfreq=1;\\n        addtolist(ans,root,maxfreq,currfreq);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1364569,
                "title": "java-0ms-beats-100-o-1-solution",
                "content": "```\\n\\tint pre=0;\\n    int curCount = 0;\\n    int maxCount = 0;\\n    List<Integer> res;\\n    public int[] findMode(TreeNode root)\\n    {\\n        res = new ArrayList<>();\\n        inorder(root);\\n        int[] result  = new int[res.size()];\\n        int k =0;\\n        for(int i: res)\\n            result[k++]=i;\\n        return result;\\n    }\\n    \\n    public void inorder(TreeNode root)\\n    {\\n        if(root==null)\\n            return;\\n        inorder(root.left);\\n        if(root.val == pre)\\n            curCount++;\\n        else\\n        {\\n            pre = root.val;\\n            curCount = 1;\\n        }\\n        if(curCount > maxCount)\\n        {\\n            maxCount = curCount;\\n            res.clear();\\n            res.add(root.val);\\n        }\\n        else if(curCount==maxCount)\\n            res.add(root.val);\\n        inorder(root.right);\\n    }\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\n\\tint pre=0;\\n    int curCount = 0;\\n    int maxCount = 0;\\n    List<Integer> res;\\n    public int[] findMode(TreeNode root)\\n    {\\n        res = new ArrayList<>();\\n        inorder(root);\\n        int[] result  = new int[res.size()];\\n        int k =0;\\n        for(int i: res)\\n            result[k++]=i;\\n        return result;\\n    }\\n    \\n    public void inorder(TreeNode root)\\n    {\\n        if(root==null)\\n            return;\\n        inorder(root.left);\\n        if(root.val == pre)\\n            curCount++;\\n        else\\n        {\\n            pre = root.val;\\n            curCount = 1;\\n        }\\n        if(curCount > maxCount)\\n        {\\n            maxCount = curCount;\\n            res.clear();\\n            res.add(root.val);\\n        }\\n        else if(curCount==maxCount)\\n            res.add(root.val);\\n        inorder(root.right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1236715,
                "title": "c-linear-time-o-n-and-constant-space-o-1",
                "content": "I didn\\'t see many responses with linear time and meeting the constant space follow up question:\\n\\n```\\nclass Solution {\\npublic:\\n    int curr = INT_MIN;\\n    int max = 0;\\n    int count = 0;\\n    vector<int> modes;\\n\\n    void dfs(TreeNode* root) {\\n        if (root == nullptr) return;\\n\\n        dfs(root->left);\\n        \\n        if (root->val == curr) {\\n            count++;\\n        } else {\\n            count = 1;\\n            curr = root->val;\\n        }\\n        \\n        if (count > max) {\\n            max = count;\\n            modes = {root->val};\\n        } else if (count == max) {\\n            modes.push_back(root->val);\\n        }\\n        \\n        dfs(root->right);\\n    }\\n    \\n    vector<int> findMode(TreeNode* root) {\\n        dfs(root);\\n        return modes;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int curr = INT_MIN;\\n    int max = 0;\\n    int count = 0;\\n    vector<int> modes;\\n\\n    void dfs(TreeNode* root) {\\n        if (root == nullptr) return;\\n\\n        dfs(root->left);\\n        \\n        if (root->val == curr) {\\n            count++;\\n        } else {\\n            count = 1;\\n            curr = root->val;\\n        }\\n        \\n        if (count > max) {\\n            max = count;\\n            modes = {root->val};\\n        } else if (count == max) {\\n            modes.push_back(root->val);\\n        }\\n        \\n        dfs(root->right);\\n    }\\n    \\n    vector<int> findMode(TreeNode* root) {\\n        dfs(root);\\n        return modes;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 700674,
                "title": "javascript-simple-solution-using-map",
                "content": "```\\nvar findMode = function(root) {\\n    let res = [];\\n    let max = -Infinity;\\n    let map = {};\\n    if(!root) return res;\\n    function trav(node){\\n        if(!node) return;\\n        map[node.val] = (map[node.val] || 0) + 1;\\n        if(map[node.val] > max) max = map[node.val];\\n        trav(node.left);\\n        trav(node.right);\\n    }\\n    trav(root);\\n    Object.keys(map).forEach(e => {if(map[e] == max) res.push(e)});\\n    return res;\\n    \\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findMode = function(root) {\\n    let res = [];\\n    let max = -Infinity;\\n    let map = {};\\n    if(!root) return res;\\n    function trav(node){\\n        if(!node) return;\\n        map[node.val] = (map[node.val] || 0) + 1;\\n        if(map[node.val] > max) max = map[node.val];\\n        trav(node.left);\\n        trav(node.right);\\n    }\\n    trav(root);\\n    Object.keys(map).forEach(e => {if(map[e] == max) res.push(e)});\\n    return res;\\n    \\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 683080,
                "title": "java-hashmap-o-n-o-n",
                "content": "```\\nclass Solution {\\n    private Map<Integer, Integer> hashMap = new HashMap<>();\\n    private int max = 1;\\n    public int[] findMode(TreeNode root) {\\n        if(root == null){\\n            return new int[0];\\n        }\\n        helper(root);\\n        int result[] = new int[hashMap.size()]; int i = 0;\\n        for(Integer k: hashMap.keySet()){\\n            if(hashMap.get(k) == max)\\n                result[i++] = k;\\n        }\\n        return Arrays.copyOf(result, i);\\n    }\\n    \\n    private void helper(TreeNode root){\\n        if(root != null){\\n            if(hashMap.containsKey(root.val)){\\n                int count = hashMap.get(root.val) + 1;\\n                hashMap.put(root.val, hashMap.get(root.val) + 1);\\n                max = Math.max(max, count);\\n            }\\n            else\\n                hashMap.put(root.val, 1);\\n            helper(root.left);\\n            helper(root.right);\\n        }\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    private Map<Integer, Integer> hashMap = new HashMap<>();\\n    private int max = 1;\\n    public int[] findMode(TreeNode root) {\\n        if(root == null){\\n            return new int[0];\\n        }\\n        helper(root);\\n        int result[] = new int[hashMap.size()]; int i = 0;\\n        for(Integer k: hashMap.keySet()){\\n            if(hashMap.get(k) == max)\\n                result[i++] = k;\\n        }\\n        return Arrays.copyOf(result, i);\\n    }\\n    \\n    private void helper(TreeNode root){\\n        if(root != null){\\n            if(hashMap.containsKey(root.val)){\\n                int count = hashMap.get(root.val) + 1;\\n                hashMap.put(root.val, hashMap.get(root.val) + 1);\\n                max = Math.max(max, count);\\n            }\\n            else\\n                hashMap.put(root.val, 1);\\n            helper(root.left);\\n            helper(root.right);\\n        }\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645107,
                "title": "java-using-extra-space",
                "content": "```\\n class Solution {\\n    Map<Integer,Integer> map = new HashMap<>();\\n    \\n    void solve(TreeNode root){\\n        if(root == null) return;\\n        int c = map.getOrDefault(root.val,0)+1;\\n        map.put(root.val,c);\\n        solve(root.left);\\n        solve(root.right);\\n    }\\n    \\n    public int[] findMode(TreeNode root) {\\n        List<Integer> lis = new ArrayList<>();\\n        solve(root);\\n        int max=0;\\n        for(int i : map.values()) max=Math.max(max,i);\\n        for(Map.Entry<Integer,Integer> m : map.entrySet()){\\n            if(m.getValue()==max) lis.add(m.getKey());\\n        }\\n        int ans[] = new int[lis.size()];\\n        for(int i=0;i<lis.size();i++)\\n            ans[i] = lis.get(i);\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n class Solution {\\n    Map<Integer,Integer> map = new HashMap<>();\\n    \\n    void solve(TreeNode root){\\n        if(root == null) return;\\n        int c = map.getOrDefault(root.val,0)+1;\\n        map.put(root.val,c);\\n        solve(root.left);\\n        solve(root.right);\\n    }\\n    \\n    public int[] findMode(TreeNode root) {\\n        List<Integer> lis = new ArrayList<>();\\n        solve(root);\\n        int max=0;\\n        for(int i : map.values()) max=Math.max(max,i);\\n        for(Map.Entry<Integer,Integer> m : map.entrySet()){\\n            if(m.getValue()==max) lis.add(m.getKey());\\n        }\\n        int ans[] = new int[lis.size()];\\n        for(int i=0;i<lis.size();i++)\\n            ans[i] = lis.get(i);\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 601904,
                "title": "python-easy-recursive-solution-beats-98-dfs-dictionary",
                "content": "```class Solution(object):\\n    def findMode(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        self.d = defaultdict(int)\\n        \\n        def helper(root):\\n            if root is None:\\n                return\\n            \\n            helper(root.left)\\n            if root.val in self.d:\\n                self.d[root.val] += 1\\n            else:\\n                self.d[root.val] = 1\\n            helper(root.right)\\n            \\n        helper(root)\\n        li = []\\n        maxx = -float(\\'inf\\')\\n        for i,j in self.d.items():\\n            if j == maxx:\\n                li.append(i)\\n            elif j>maxx:end(i)\\n                \\n        return li",
                "solutionTags": [],
                "code": "```class Solution(object):\\n    def findMode(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        self.d = defaultdict(int)\\n        \\n        def helper(root):\\n            if root is None:\\n                return\\n            \\n            helper(root.left)\\n            if root.val in self.d:\\n                self.d[root.val] += 1\\n            else:\\n                self.d[root.val] = 1\\n            helper(root.right)\\n            \\n        helper(root)\\n        li = []\\n        maxx = -float(\\'inf\\')\\n        for i,j in self.d.items():\\n            if j == maxx:\\n                li.append(i)\\n            elif j>maxx:end(i)\\n                \\n        return li",
                "codeTag": "Java"
            },
            {
                "id": 389157,
                "title": "c-without-extra-space-using-recursion-use-inorder-traversal",
                "content": "The approach is to leverage the fact that inorder traversal of BST is always sorted in ascending order.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    void rec(TreeNode *root,int &count,int &maxcount,TreeNode** prev,vector<int> &res){\\n        if(!root)\\n            return;\\n        rec(root->left,count,maxcount,prev,res);\\n        \\n        \\n        if(!*prev || root->val!=(*prev)->val){\\n            *prev=root;\\n            count=1;\\n        }\\n        \\n        else if(root->val == (*prev)->val){\\n            // cout<<\"here\";\\n            count++;\\n        }\\n        \\n        if(count > maxcount){\\n            maxcount=count;\\n            res.clear();\\n            res.push_back(root->val);\\n        }\\n        else if(count == maxcount){\\n            res.push_back(root->val);\\n        }\\n        // cout<<root->val<<\" \"<<count<<\"  \"<<maxcount<<\"\\\\t\"<<(*prev)->val<<\"\\\\n\";\\n        \\n        rec(root->right,count,maxcount,prev,res);\\n    }\\n    \\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> res;\\n        int c=0;\\n        int cnt=0;\\n        TreeNode *prev=NULL;\\n        rec(root,cnt,c,&prev,res);\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    \\n    void rec(TreeNode *root,int &count,int &maxcount,TreeNode** prev,vector<int> &res){\\n        if(!root)\\n            return;\\n        rec(root->left,count,maxcount,prev,res);\\n        \\n        \\n        if(!*prev || root->val!=(*prev)->val){\\n            *prev=root;\\n            count=1;\\n        }\\n        \\n        else if(root->val == (*prev)->val){\\n            // cout<<\"here\";\\n            count++;\\n        }\\n        \\n        if(count > maxcount){\\n            maxcount=count;\\n            res.clear();\\n            res.push_back(root->val);\\n        }\\n        else if(count == maxcount){\\n            res.push_back(root->val);\\n        }\\n        // cout<<root->val<<\" \"<<count<<\"  \"<<maxcount<<\"\\\\t\"<<(*prev)->val<<\"\\\\n\";\\n        \\n        rec(root->right,count,maxcount,prev,res);\\n    }\\n    \\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> res;\\n        int c=0;\\n        int cnt=0;\\n        TreeNode *prev=NULL;\\n        rec(root,cnt,c,&prev,res);\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 329452,
                "title": "golang-beats-100-o-1-space",
                "content": "To have O(1) space, one needs to keep track of the previously visited value.\\nOne can do this during traversal using the following (you\\'ll find this extremely useful in many BST problems requiring O(1) space):\\n```\\nDFS(root, prev)\\n    DFS(root.Left,prev)\\n\\tUpdate prev to current root value\\n\\tDFS(root.Right,prev)\\n```\\n\\nTo find BST\\'s Mode value while traversal, one needs to keep track of number of nodes with same values, as follows:\\n```\\nDFS(root, prev)\\n    DFS(root.Left,prev)\\n\\tif root.Val == prev {count++} else {count=1}\\n\\tUpdate prev to current root value\\n\\tDFS(root.Right,prev)\\n```\\n\\nNow all that\\'s left is to keep track of max length. If count becomes greater than max, then we update max, and wipe off the existing *result* array and create a new one using the new element.\\n\\n**Golang code**:\\n```go\\nfunc findMode(root *TreeNode) []int {\\n    if root==nil {return nil}\\n    \\n    prev := -1<<31\\n    count := 0\\n    max := 1\\n    result := make([]int,0)\\n    findBSTMode(root, &prev,&count,&max, &result)\\n    \\n    return result\\n}\\n\\nfunc findBSTMode(root *TreeNode, prev,count,max *int, result *[]int) {\\n    if root==nil {return}\\n    \\n    // Go Left\\n    findBSTMode(root.Left, prev, count, max, result)\\n    \\n    // Set count,max and previous:\\n    if root.Val==*prev {*count++} else {*count=1}\\n    if *max < *count { // Found a better max\\n        *result = []int{root.Val} // Reset result array\\n        *max = *count // Set max\\n    } else if *max == *count {\\n        *result = append(*result, root.Val) // Append to result\\n    }\\n    *prev = root.Val\\n    \\n    // Go Right\\n    findBSTMode(root.Right, prev, count, max, result)\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nDFS(root, prev)\\n    DFS(root.Left,prev)\\n\\tUpdate prev to current root value\\n\\tDFS(root.Right,prev)\\n```\n```\\nDFS(root, prev)\\n    DFS(root.Left,prev)\\n\\tif root.Val == prev {count++} else {count=1}\\n\\tUpdate prev to current root value\\n\\tDFS(root.Right,prev)\\n```\n```go\\nfunc findMode(root *TreeNode) []int {\\n    if root==nil {return nil}\\n    \\n    prev := -1<<31\\n    count := 0\\n    max := 1\\n    result := make([]int,0)\\n    findBSTMode(root, &prev,&count,&max, &result)\\n    \\n    return result\\n}\\n\\nfunc findBSTMode(root *TreeNode, prev,count,max *int, result *[]int) {\\n    if root==nil {return}\\n    \\n    // Go Left\\n    findBSTMode(root.Left, prev, count, max, result)\\n    \\n    // Set count,max and previous:\\n    if root.Val==*prev {*count++} else {*count=1}\\n    if *max < *count { // Found a better max\\n        *result = []int{root.Val} // Reset result array\\n        *max = *count // Set max\\n    } else if *max == *count {\\n        *result = append(*result, root.Val) // Append to result\\n    }\\n    *prev = root.Val\\n    \\n    // Go Right\\n    findBSTMode(root.Right, prev, count, max, result)\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 233821,
                "title": "c-o-1-space",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    int mode = 0;\\n    \\n    List<int> modes = new List<int>();\\n    \\n    int len = 0;\\n    \\n    int? last = null;\\n    \\n    public int[] FindMode(TreeNode root) {\\n        Traverse(root);\\n                    \\n        last = null;\\n        len = 0;\\n        \\n        Traverse2(root);\\n        \\n        return modes.ToArray();\\n    }\\n    \\n    public void Traverse(TreeNode root) {\\n        if (root == null) return ;\\n        \\n        Traverse(root.left);\\n        \\n        if (last != root.val) len = 0;\\n        len++;\\n        last = root.val;\\n        \\n        if (len > mode) {\\n            mode = len;\\n        }\\n        \\n        Traverse(root.right);        \\n    }\\n    \\n    public void Traverse2(TreeNode root) {\\n        if (root == null) return ;\\n        \\n        Traverse2(root.left);\\n        \\n        if (last != root.val) len = 0;\\n        len++;\\n        last = root.val;\\n        \\n        if (len == mode) {\\n            modes.Add(root.val);\\n        }\\n        \\n        Traverse2(root.right);        \\n    }    \\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int x) { val = x; }\\n * }\\n */\\npublic class Solution {\\n    int mode = 0;\\n    \\n    List<int> modes = new List<int>();\\n    \\n    int len = 0;\\n    \\n    int? last = null;\\n    \\n    public int[] FindMode(TreeNode root) {\\n        Traverse(root);\\n                    \\n        last = null;\\n        len = 0;\\n        \\n        Traverse2(root);\\n        \\n        return modes.ToArray();\\n    }\\n    \\n    public void Traverse(TreeNode root) {\\n        if (root == null) return ;\\n        \\n        Traverse(root.left);\\n        \\n        if (last != root.val) len = 0;\\n        len++;\\n        last = root.val;\\n        \\n        if (len > mode) {\\n            mode = len;\\n        }\\n        \\n        Traverse(root.right);        \\n    }\\n    \\n    public void Traverse2(TreeNode root) {\\n        if (root == null) return ;\\n        \\n        Traverse2(root.left);\\n        \\n        if (last != root.val) len = 0;\\n        len++;\\n        last = root.val;\\n        \\n        if (len == mode) {\\n            modes.Add(root.val);\\n        }\\n        \\n        Traverse2(root.right);        \\n    }    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 171429,
                "title": "python-one-traversal",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def findMode(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        \\n        modes = []\\n        val, freq, max_freq, modes = self.dfs(root, None, 0, 0, modes)\\n        return modes\\n    \\n    \\n    def dfs(self, node, val, freq, max_freq, modes):\\n        if node.left:\\n            val, freq, max_freq, modes = self.dfs(node.left, val, freq, max_freq, modes)\\n        \\n        if node.val == val:\\n            freq += 1\\n        else:\\n            freq = 1\\n            val = node.val\\n        \\n        if freq > max_freq:\\n            modes = [val]\\n            max_freq = freq\\n        elif freq == max_freq:\\n            modes.append(val)\\n\\n        if node.right:\\n            val, freq, max_freq, modes = self.dfs(node.right, val, freq, max_freq, modes)\\n        \\n        return val, freq, max_freq, modes\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode(object):\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\nclass Solution(object):\\n    def findMode(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if not root:\\n            return []\\n        \\n        modes = []\\n        val, freq, max_freq, modes = self.dfs(root, None, 0, 0, modes)\\n        return modes\\n    \\n    \\n    def dfs(self, node, val, freq, max_freq, modes):\\n        if node.left:\\n            val, freq, max_freq, modes = self.dfs(node.left, val, freq, max_freq, modes)\\n        \\n        if node.val == val:\\n            freq += 1\\n        else:\\n            freq = 1\\n            val = node.val\\n        \\n        if freq > max_freq:\\n            modes = [val]\\n            max_freq = freq\\n        elif freq == max_freq:\\n            modes.append(val)\\n\\n        if node.right:\\n            val, freq, max_freq, modes = self.dfs(node.right, val, freq, max_freq, modes)\\n        \\n        return val, freq, max_freq, modes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98120,
                "title": "5ms-java-simple-inorder-traverse-solution-i-m-not-sure-whether-it-didn-t-use-extra-space",
                "content": "**Just use inorder traverse and maintain two variables, one for current mode frequency count and the other for global mode frequency count. If we meet a better mode option, clear the current result and add the new one.**\\n\\n```\\npublic class Solution {\\n    public int[] findMode(TreeNode root) {\\n        if(root==null){\\n            return new int[0];\\n        }\\n        this.cur=new LinkedList<Integer>();\\n        traverse(root);\\n        int[] res=new int[cur.size()];\\n        int i=0;\\n        Iterator<Integer> itr=cur.iterator();\\n        while(itr.hasNext()){\\n            res[i++]=itr.next();\\n        }\\n        return res;\\n    }\\n    private void traverse(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        traverse(root.left);\\n        if(root.val==pre){\\n            count++;\\n        }\\n        else{\\n            count=1;\\n        }\\n        if(count>=max){\\n            if(count>max){\\n                cur.clear();\\n            }\\n            max=count;\\n            if(cur.isEmpty()||root.val!=cur.getLast()){\\n                cur.add(root.val);\\n            }\\n        }\\n        pre=root.val;\\n        traverse(root.right);\\n    }\\n    private int max=0, count=0, pre=Integer.MIN_VALUE;\\n    private LinkedList<Integer> cur;\\n}\\n````",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    public int[] findMode(TreeNode root) {\\n        if(root==null){\\n            return new int[0];\\n        }\\n        this.cur=new LinkedList<Integer>();\\n        traverse(root);\\n        int[] res=new int[cur.size()];\\n        int i=0;\\n        Iterator<Integer> itr=cur.iterator();\\n        while(itr.hasNext()){\\n            res[i++]=itr.next();\\n        }\\n        return res;\\n    }\\n    private void traverse(TreeNode root){\\n        if(root==null){\\n            return;\\n        }\\n        traverse(root.left);\\n        if(root.val==pre){\\n            count++;\\n        }\\n        else{\\n            count=1;\\n        }\\n        if(count>=max){\\n            if(count>max){\\n                cur.clear();\\n            }\\n            max=count;\\n            if(cur.isEmpty()||root.val!=cur.getLast()){\\n                cur.add(root.val);\\n            }\\n        }\\n        pre=root.val;\\n        traverse(root.right);\\n    }\\n    private int max=0, count=0, pre=Integer.MIN_VALUE;\\n    private LinkedList<Integer> cur;\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3079098,
                "title": "c-solution-94-7-time-65-7-space-used-unordered-map",
                "content": "# Complexity\\n- Time complexity: O(n)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(n)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> findMode(TreeNode* root);\\n\\n    void updateMap(TreeNode *root, unordered_map<int,int> &m);\\n\\n    void updateMaxFreq(unordered_map<int,int> &m, vector<int> &v);\\n};\\n/***************************************************************/\\nvector<int> Solution::findMode(TreeNode* root) {\\n    unordered_map<int,int> m;\\n    vector<int> v;\\n    if (root != nullptr) {\\n        updateMap(root, m);\\n    }\\n    updateMaxFreq(m, v);\\n    return v;\\n}\\n/***************************************************************/\\nvoid Solution::updateMap(TreeNode *root, unordered_map<int,int> &m) {\\n    ++m[root->val];\\n    if (root->left != nullptr) {\\n        updateMap(root->left, m);\\n    }\\n    if (root->right != nullptr) {\\n        updateMap(root->right, m);\\n    }\\n    return;\\n}\\n/***************************************************************/\\nvoid Solution::updateMaxFreq(unordered_map<int,int> &m, vector<int> &v) {\\n    int maxFreq = 0;\\n    for(auto &p : m) {\\n        if (maxFreq < p.second) {\\n            maxFreq = p.second;\\n        }\\n    }\\n    for (auto &p : m) {\\n        if (p.second == maxFreq) {\\n            v.emplace_back(p.first);\\n        }\\n    }\\n    return;\\n}\\n/***************************************************************/\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> findMode(TreeNode* root);\\n\\n    void updateMap(TreeNode *root, unordered_map<int,int> &m);\\n\\n    void updateMaxFreq(unordered_map<int,int> &m, vector<int> &v);\\n};\\n/***************************************************************/\\nvector<int> Solution::findMode(TreeNode* root) {\\n    unordered_map<int,int> m;\\n    vector<int> v;\\n    if (root != nullptr) {\\n        updateMap(root, m);\\n    }\\n    updateMaxFreq(m, v);\\n    return v;\\n}\\n/***************************************************************/\\nvoid Solution::updateMap(TreeNode *root, unordered_map<int,int> &m) {\\n    ++m[root->val];\\n    if (root->left != nullptr) {\\n        updateMap(root->left, m);\\n    }\\n    if (root->right != nullptr) {\\n        updateMap(root->right, m);\\n    }\\n    return;\\n}\\n/***************************************************************/\\nvoid Solution::updateMaxFreq(unordered_map<int,int> &m, vector<int> &v) {\\n    int maxFreq = 0;\\n    for(auto &p : m) {\\n        if (maxFreq < p.second) {\\n            maxFreq = p.second;\\n        }\\n    }\\n    for (auto &p : m) {\\n        if (p.second == maxFreq) {\\n            v.emplace_back(p.first);\\n        }\\n    }\\n    return;\\n}\\n/***************************************************************/\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2835296,
                "title": "java-bst",
                "content": "If you like it pls upvote\\n```\\n\\n\\n    int maxCount = 1;\\n\\n    public int[] findMode(TreeNode root) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        findMode(root, map);\\n\\n        int[] result = new int[map.size()];\\n        int index = 0;\\n        for(Integer key: map.keySet()){\\n            if(map.get(key) == maxCount){\\n                result[index++] = key;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n\\n    private void findMode(TreeNode root, Map<Integer, Integer> map){\\n        if(root == null) {\\n            return;\\n        } else if(map.containsKey(root.val)) {\\n            map.put(root.val, map.get(root.val)+1);\\n            maxCount = Math.max(maxCount, map.get(root.val));\\n        } else {\\n            map.put(root.val, 1);\\n        }\\n\\n        findMode(root.left, map);\\n        findMode(root.right, map);\\n    }\\n\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree"
                ],
                "code": "```\\n\\n\\n    int maxCount = 1;\\n\\n    public int[] findMode(TreeNode root) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        findMode(root, map);\\n\\n        int[] result = new int[map.size()];\\n        int index = 0;\\n        for(Integer key: map.keySet()){\\n            if(map.get(key) == maxCount){\\n                result[index++] = key;\\n            }\\n        }\\n\\n        return Arrays.copyOf(result, index);\\n    }\\n\\n    private void findMode(TreeNode root, Map<Integer, Integer> map){\\n        if(root == null) {\\n            return;\\n        } else if(map.containsKey(root.val)) {\\n            map.put(root.val, map.get(root.val)+1);\\n            maxCount = Math.max(maxCount, map.get(root.val));\\n        } else {\\n            map.put(root.val, 1);\\n        }\\n\\n        findMode(root.left, map);\\n        findMode(root.right, map);\\n    }\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2800423,
                "title": "python-beats-82-simple-iterative-solution",
                "content": "```\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        if root.val == 0: return [0]\\n        nums, stack = {}, []\\n        \\n        while True:\\n            while root:\\n                if root.val in nums.keys(): nums[root.val] += 1\\n                else: nums[root.val] = 1\\n                    \\n                stack.append(root)\\n                root = root.left\\n            \\n            if not stack: break \\n            root = stack.pop().right\\n        \\n        maxValue = max(nums.values())\\n        \\n        return [k for k, v in nums.items() if maxValue == v]\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        if root.val == 0: return [0]\\n        nums, stack = {}, []\\n        \\n        while True:\\n            while root:\\n                if root.val in nums.keys(): nums[root.val] += 1\\n                else: nums[root.val] = 1\\n                    \\n                stack.append(root)\\n                root = root.left\\n            \\n            if not stack: break \\n            root = stack.pop().right\\n        \\n        maxValue = max(nums.values())\\n        \\n        return [k for k, v in nums.items() if maxValue == v]\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2765705,
                "title": "java-solution-using-dfs-and-map",
                "content": "# Code\\n```\\nclass Solution {\\n    Map<Integer, Integer> map;\\n    public int[] findMode(TreeNode root) {\\n        map = new HashMap<>();\\n        searchInBST(root);\\n        int maxFreq = -1;\\n        List<Integer> list = new ArrayList<>();\\n        for (int key : map.keySet()) {\\n            int freq = map.get(key);\\n            if (maxFreq < freq) {\\n                maxFreq = freq;\\n                list.clear();\\n                list.add(key);\\n                continue;\\n            }\\n            if (maxFreq == freq) {\\n                list.add(key);\\n            }\\n        }\\n        int[] res = new int[list.size()];\\n        for (int i = 0; i < list.size(); i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n\\n    private void searchInBST(TreeNode node) {\\n        if (node == null) return;\\n\\n        if (map.containsKey(node.val)) {\\n            map.put(node.val, map.get(node.val) + 1);\\n        } else {\\n            map.put(node.val, 1);\\n        }\\n\\n        searchInBST(node.left);\\n        searchInBST(node.right);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer, Integer> map;\\n    public int[] findMode(TreeNode root) {\\n        map = new HashMap<>();\\n        searchInBST(root);\\n        int maxFreq = -1;\\n        List<Integer> list = new ArrayList<>();\\n        for (int key : map.keySet()) {\\n            int freq = map.get(key);\\n            if (maxFreq < freq) {\\n                maxFreq = freq;\\n                list.clear();\\n                list.add(key);\\n                continue;\\n            }\\n            if (maxFreq == freq) {\\n                list.add(key);\\n            }\\n        }\\n        int[] res = new int[list.size()];\\n        for (int i = 0; i < list.size(); i++) {\\n            res[i] = list.get(i);\\n        }\\n        return res;\\n    }\\n\\n    private void searchInBST(TreeNode node) {\\n        if (node == null) return;\\n\\n        if (map.containsKey(node.val)) {\\n            map.put(node.val, map.get(node.val) + 1);\\n        } else {\\n            map.put(node.val, 1);\\n        }\\n\\n        searchInBST(node.left);\\n        searchInBST(node.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2701472,
                "title": "python-dfs-90-faster-easy-to-understand",
                "content": "![image](https://assets.leetcode.com/users/images/339a69f6-4101-485e-8038-cc9727bee91c_1665730958.746428.png)\\n\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        hashmap = {}\\n        res = []\\n        \\n        def dfs_ele_freq(root):\\n            if not root: return None\\n            \\n            if root.val not in hashmap:\\n                hashmap[root.val] = 1 \\n            else:\\n                hashmap[root.val] += 1\\n            \\n            dfs_ele_freq(root.left)\\n            dfs_ele_freq(root.right)\\n                        \\n            \\n        dfs_ele_freq(root)\\n        mode_list = max(list(hashmap.values()))\\n        for key, value in hashmap.items():\\n            if value == mode_list:\\n                res.append(key)\\n                \\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        hashmap = {}\\n        res = []\\n        \\n        def dfs_ele_freq(root):\\n            if not root: return None\\n            \\n            if root.val not in hashmap:\\n                hashmap[root.val] = 1 \\n            else:\\n                hashmap[root.val] += 1\\n            \\n            dfs_ele_freq(root.left)\\n            dfs_ele_freq(root.right)\\n                        \\n            \\n        dfs_ele_freq(root)\\n        mode_list = max(list(hashmap.values()))\\n        for key, value in hashmap.items():\\n            if value == mode_list:\\n                res.append(key)\\n                \\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2656599,
                "title": "javascript-simple-solution-hash-table-dfs-o-n",
                "content": "```\\n// Using hash-table & depth-first-search\\n// Time complexity = O(n)\\n// Space complexity = O(n)\\n\\nvar findMode = function(root) {\\n    let ans = []\\n    let map = new Map()\\n    let max = 0\\n    \\n    const traverse = node => {\\n        if(!node) return\\n        \\n        map.set(node.val, map.get(node.val) + 1 || 1)\\n        max = Math.max(max, map.get(node.val))\\n        \\n        if(node.left) traverse(node.left)\\n        if(node.right) traverse(node.right)\\n    }\\n    \\n    traverse(root)\\n    \\n    for(let [key, value] of map) if(value === max) ans.push(key)\\n    \\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Hash Table",
                    "Depth-First Search"
                ],
                "code": "```\\n// Using hash-table & depth-first-search\\n// Time complexity = O(n)\\n// Space complexity = O(n)\\n\\nvar findMode = function(root) {\\n    let ans = []\\n    let map = new Map()\\n    let max = 0\\n    \\n    const traverse = node => {\\n        if(!node) return\\n        \\n        map.set(node.val, map.get(node.val) + 1 || 1)\\n        max = Math.max(max, map.get(node.val))\\n        \\n        if(node.left) traverse(node.left)\\n        if(node.right) traverse(node.right)\\n    }\\n    \\n    traverse(root)\\n    \\n    for(let [key, value] of map) if(value === max) ans.push(key)\\n    \\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2547941,
                "title": "simple-o-n-java-solution-using-hashmap",
                "content": "```\\nclass Solution {\\n    int max =1;\\n    \\n    public int[] findMode(TreeNode root) \\n    {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        find_mode(root , map);\\n        \\n        int[] ans = new int[map.size()];\\n        int idx=0;\\n        \\n        for(Integer key: map.keySet())\\n        {\\n            if(map.get(key) == max)\\n                ans[idx++] = key;\\n        }\\n        return Arrays.copyOf(ans , idx);\\n    }\\n    \\n    private void find_mode(TreeNode root , HashMap<Integer,Integer> map)\\n    {\\n        if(root == null)\\n            return;\\n        \\n        if(map.containsKey(root.val))\\n        {\\n            int count = map.get(root.val) + 1;\\n            map.put(root.val , count);\\n            max = Math.max(count , max);\\n        }\\n        else\\n            map.put(root.val , 1);\\n        \\n        find_mode(root.left , map);\\n        find_mode(root.right , map);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int max =1;\\n    \\n    public int[] findMode(TreeNode root) \\n    {\\n        HashMap<Integer,Integer> map = new HashMap<>();\\n        \\n        find_mode(root , map);\\n        \\n        int[] ans = new int[map.size()];\\n        int idx=0;\\n        \\n        for(Integer key: map.keySet())\\n        {\\n            if(map.get(key) == max)\\n                ans[idx++] = key;\\n        }\\n        return Arrays.copyOf(ans , idx);\\n    }\\n    \\n    private void find_mode(TreeNode root , HashMap<Integer,Integer> map)\\n    {\\n        if(root == null)\\n            return;\\n        \\n        if(map.containsKey(root.val))\\n        {\\n            int count = map.get(root.val) + 1;\\n            map.put(root.val , count);\\n            max = Math.max(count , max);\\n        }\\n        else\\n            map.put(root.val , 1);\\n        \\n        find_mode(root.left , map);\\n        find_mode(root.right , map);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2507679,
                "title": "javascript-no-hashmap-w-explanation",
                "content": "The extremely simple key (which I didn\\'t realize for a long time, as I was thinking \"divide and conquer\") is that even in a binary search tree with duplicates, if you simply do an inorder traversal, you\\'ll get all the values in order. The implication is that you can easily count how many there are of a particular value.\\n\\nRather than pulling those values out into an array, we can keep track of the last value we saw.\\n\\nEither way, we would keep an array full of the modes; each time a new number hits the current record, we add it to the array; if it passes the record, it becomes the only contender.\\n\\n```\\nfunction findMode(root) {\\n    \\n    let modes = [];\\n    let prev = root;\\n    let count = 0;\\n    let max = 0;\\n    \\n    function traverse(node) {\\n        \\n        if (node === null) return;\\n        \\n        traverse(node.left);\\n        \\n        count = prev.val === node.val ? count + 1 : 1;\\n        prev = node;\\n        \\n        if (count === max) {\\n            modes.push(node.val);\\n        }\\n        else if (count > max) {\\n            modes = [node.val];\\n            max = count;\\n        }\\n        \\n        traverse(node.right);\\n        \\n    }\\n    \\n    traverse(root);\\n    return modes;\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nfunction findMode(root) {\\n    \\n    let modes = [];\\n    let prev = root;\\n    let count = 0;\\n    let max = 0;\\n    \\n    function traverse(node) {\\n        \\n        if (node === null) return;\\n        \\n        traverse(node.left);\\n        \\n        count = prev.val === node.val ? count + 1 : 1;\\n        prev = node;\\n        \\n        if (count === max) {\\n            modes.push(node.val);\\n        }\\n        else if (count > max) {\\n            modes = [node.val];\\n            max = count;\\n        }\\n        \\n        traverse(node.right);\\n        \\n    }\\n    \\n    traverse(root);\\n    return modes;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2493979,
                "title": "c-preorder-traversal-hashmap-finding-max-occurrences-while-traversal",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int max_count=0;\\n    void frequency(TreeNode* root, unordered_map <int,int> &hash){\\n        if(root==NULL)\\n            return ;\\n        \\n        hash[root->val]++;\\n        \\n\\t\\t//calculating the maximum frequency of any node value\\n        max_count= max(max_count, hash[root->val]);\\n        \\n        frequency(root->left,hash);\\n        frequency(root->right,hash);\\n    }\\n    \\n    vector<int> findMode(TreeNode* root) {\\n        unordered_map <int,int> hash;\\n        vector <int> ans;\\n        \\n        if(root==NULL)\\n            return ans;\\n        \\n        frequency(root, hash);\\n        \\n\\t\\t//updating the vector only if its equal to max_count\\n        for(auto it:hash){\\n            if(it.second==max_count)\\n                ans.push_back(it.first);\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "class Solution {\\npublic:\\n    int max_count=0;\\n    void frequency(TreeNode* root, unordered_map <int,int> &hash){\\n        if(root==NULL)\\n            return ;\\n        \\n        hash[root->val]++;\\n        \\n\\t\\t//calculating the maximum frequency of any node value\\n        max_count= max(max_count, hash[root->val]);\\n        \\n        frequency(root->left,hash);\\n        frequency(root->right,hash);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2040663,
                "title": "preorder-traversal-with-o-1-space",
                "content": "```\\n// regular preorder traversal instead of printing the value we keep it as prevValue\\n// inorder traveral of BST is sorted array print, so basically it is about finding most repeating\\n// numbers in the sequence\\nclass Solution {\\npublic:\\n    int maxCnt = INT_MIN;\\n    int currentCnt = 0;\\n    int prev = INT_MIN;\\n    vector<int> result;\\n    \\n    void dfs(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        dfs(root->left);\\n        if (root->val != prev) {\\n            currentCnt = 1;\\n        } else {\\n            currentCnt++;\\n        }\\n        \\n        if (currentCnt == maxCnt) {\\n            result.push_back(root->val);\\n        } else if (currentCnt > maxCnt) {\\n            maxCnt = currentCnt;\\n            result.clear();\\n            result.push_back(root->val);\\n        }\\n        \\n        prev = root->val;\\n        dfs(root->right);\\n        \\n        return;\\n        \\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        maxCnt  = 0;\\n        currentCnt = 0;\\n        dfs(root);\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n// regular preorder traversal instead of printing the value we keep it as prevValue\\n// inorder traveral of BST is sorted array print, so basically it is about finding most repeating\\n// numbers in the sequence\\nclass Solution {\\npublic:\\n    int maxCnt = INT_MIN;\\n    int currentCnt = 0;\\n    int prev = INT_MIN;\\n    vector<int> result;\\n    \\n    void dfs(TreeNode* root) {\\n        if (!root) {\\n            return;\\n        }\\n        dfs(root->left);\\n        if (root->val != prev) {\\n            currentCnt = 1;\\n        } else {\\n            currentCnt++;\\n        }\\n        \\n        if (currentCnt == maxCnt) {\\n            result.push_back(root->val);\\n        } else if (currentCnt > maxCnt) {\\n            maxCnt = currentCnt;\\n            result.clear();\\n            result.push_back(root->val);\\n        }\\n        \\n        prev = root->val;\\n        dfs(root->right);\\n        \\n        return;\\n        \\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        maxCnt  = 0;\\n        currentCnt = 0;\\n        dfs(root);\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2032921,
                "title": "0ms-java-solution-faster-than-100",
                "content": "## Solution 0ms\\n```\\nprivate int maxCount;\\n\\tprivate int currentCount;\\n\\tprivate int lastValue = Integer.MIN_VALUE;\\n\\n\\tprivate List<Integer> modeList = new ArrayList<>();\\n\\n\\tpublic int[] findMode(TreeNode root) {\\n\\t\\tinOrderTraversal(root);\\n\\t\\tint[] modes = new int[modeList.size()];\\n\\t\\tint idx = 0;\\n\\t\\tfor (int mode : modeList) {\\n\\t\\t\\tmodes[idx++] = mode;\\n\\t\\t}\\n\\t\\treturn modes;\\n\\t}\\n\\n\\tprivate void inOrderTraversal(TreeNode root) {\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tinOrderTraversal(root.left);\\n\\t\\taddMode(root);\\n\\t\\tinOrderTraversal(root.right);\\n\\t}\\n\\n\\tprivate void addMode(TreeNode node) {\\n\\t\\tif (lastValue != node.val) {\\n\\t\\t\\tcurrentCount = 0;\\n\\t\\t\\tlastValue = node.val;\\n\\t\\t}\\n\\t\\tcurrentCount++;\\n\\t\\tif (currentCount > maxCount) {\\n\\t\\t\\tmaxCount = currentCount;\\n\\t\\t\\tmodeList.clear();\\n\\t\\t\\tmodeList.add(node.val);\\n\\t\\t} else if (currentCount == maxCount) {\\n\\t\\t\\tmodeList.add(node.val);\\n\\t\\t}\\n\\t}\\n```\\n\\n## Solution 8ms\\n```\\nMap<Integer, Integer> modeMap = new HashMap<>();\\n\\t\\tQueue<TreeNode> queue = new LinkedList<>();\\n\\t\\tqueue.add(root);\\n\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tTreeNode cur = queue.poll();\\n\\t\\t\\tif (cur != null) {\\n\\t\\t\\t\\tint count = modeMap.getOrDefault(cur.val, 0);\\n\\t\\t\\t\\tmodeMap.put(cur.val, count + 1);\\n\\t\\t\\t\\tqueue.add(cur.left);\\n\\t\\t\\t\\tqueue.add(cur.right);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint max = 1;\\n\\t\\tList<Integer> modeList = new ArrayList<>();\\n\\t\\tint idx = 0;\\n\\t\\tfor (Map.Entry<Integer, Integer> entry : modeMap.entrySet()) {\\n\\t\\t\\tint key = entry.getKey();\\n\\t\\t\\tint val = entry.getValue();\\n\\n\\t\\t\\tif (val > max) {\\n\\t\\t\\t\\tmodeList.clear();\\n\\t\\t\\t\\tmodeList.add(key);\\n\\t\\t\\t\\tmax = val;\\n\\t\\t\\t\\tidx = 0;\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t} else if (val == max) {\\n\\t\\t\\t\\tmodeList.add(key);\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tint[] modes = new int[idx];\\n\\t\\tIterator<Integer> it = modeList.iterator();\\n\\t\\twhile (it.hasNext()) {\\n\\t\\t\\tmodes[--idx] = it.next();\\n\\t\\t}\\n\\n\\t\\treturn modes;\\n```",
                "solutionTags": [
                    "Java",
                    "Binary Search Tree",
                    "Recursion",
                    "Iterator"
                ],
                "code": "```\\nprivate int maxCount;\\n\\tprivate int currentCount;\\n\\tprivate int lastValue = Integer.MIN_VALUE;\\n\\n\\tprivate List<Integer> modeList = new ArrayList<>();\\n\\n\\tpublic int[] findMode(TreeNode root) {\\n\\t\\tinOrderTraversal(root);\\n\\t\\tint[] modes = new int[modeList.size()];\\n\\t\\tint idx = 0;\\n\\t\\tfor (int mode : modeList) {\\n\\t\\t\\tmodes[idx++] = mode;\\n\\t\\t}\\n\\t\\treturn modes;\\n\\t}\\n\\n\\tprivate void inOrderTraversal(TreeNode root) {\\n\\t\\tif (root == null) {\\n\\t\\t\\treturn;\\n\\t\\t}\\n\\t\\tinOrderTraversal(root.left);\\n\\t\\taddMode(root);\\n\\t\\tinOrderTraversal(root.right);\\n\\t}\\n\\n\\tprivate void addMode(TreeNode node) {\\n\\t\\tif (lastValue != node.val) {\\n\\t\\t\\tcurrentCount = 0;\\n\\t\\t\\tlastValue = node.val;\\n\\t\\t}\\n\\t\\tcurrentCount++;\\n\\t\\tif (currentCount > maxCount) {\\n\\t\\t\\tmaxCount = currentCount;\\n\\t\\t\\tmodeList.clear();\\n\\t\\t\\tmodeList.add(node.val);\\n\\t\\t} else if (currentCount == maxCount) {\\n\\t\\t\\tmodeList.add(node.val);\\n\\t\\t}\\n\\t}\\n```\n```\\nMap<Integer, Integer> modeMap = new HashMap<>();\\n\\t\\tQueue<TreeNode> queue = new LinkedList<>();\\n\\t\\tqueue.add(root);\\n\\n\\t\\twhile (!queue.isEmpty()) {\\n\\t\\t\\tTreeNode cur = queue.poll();\\n\\t\\t\\tif (cur != null) {\\n\\t\\t\\t\\tint count = modeMap.getOrDefault(cur.val, 0);\\n\\t\\t\\t\\tmodeMap.put(cur.val, count + 1);\\n\\t\\t\\t\\tqueue.add(cur.left);\\n\\t\\t\\t\\tqueue.add(cur.right);\\n\\t\\t\\t}\\n\\t\\t}\\n\\n\\t\\tint max = 1;\\n\\t\\tList<Integer> modeList = new ArrayList<>();\\n\\t\\tint idx = 0;\\n\\t\\tfor (Map.Entry<Integer, Integer> entry : modeMap.entrySet()) {\\n\\t\\t\\tint key = entry.getKey();\\n\\t\\t\\tint val = entry.getValue();\\n\\n\\t\\t\\tif (val > max) {\\n\\t\\t\\t\\tmodeList.clear();\\n\\t\\t\\t\\tmodeList.add(key);\\n\\t\\t\\t\\tmax = val;\\n\\t\\t\\t\\tidx = 0;\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t} else if (val == max) {\\n\\t\\t\\t\\tmodeList.add(key);\\n\\t\\t\\t\\tidx++;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\t\\n\\t\\tint[] modes = new int[idx];\\n\\t\\tIterator<Integer> it = modeList.iterator();\\n\\t\\twhile (it.hasNext()) {\\n\\t\\t\\tmodes[--idx] = it.next();\\n\\t\\t}\\n\\n\\t\\treturn modes;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1988354,
                "title": "python-inorder-o-n",
                "content": "````\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        \\n        if not root: return []\\n        \\n        result = []\\n        lastValue = root.val\\n        maxCount = 0\\n        count = 0\\n        \\n        def helper(node):\\n            \\n            nonlocal count, lastValue, result, maxCount\\n            \\n            if not node: return 0\\n                        \\n            helper(node.left)\\n            \\n            if lastValue != node.val:\\n                count = 1\\n            else:\\n                count += 1\\n\\n            lastValue = node.val\\n\\n            if count > maxCount:\\n                maxCount = count\\n                result = [node.val]\\n            elif count == maxCount:\\n                result.append(node.val)\\n\\n            helper(node.right)\\n        \\n        helper(root)\\n        return result\\n````",
                "solutionTags": [
                    "Python",
                    "Depth-First Search"
                ],
                "code": "````\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        \\n        if not root: return []\\n        \\n        result = []\\n        lastValue = root.val\\n        maxCount = 0\\n        count = 0\\n        \\n        def helper(node):\\n            \\n            nonlocal count, lastValue, result, maxCount\\n            \\n            if not node: return 0\\n                        \\n            helper(node.left)\\n            \\n            if lastValue != node.val:\\n                count = 1\\n            else:\\n                count += 1\\n\\n            lastValue = node.val\\n\\n            if count > maxCount:\\n                maxCount = count\\n                result = [node.val]\\n            elif count == maxCount:\\n                result.append(node.val)\\n\\n            helper(node.right)\\n        \\n        helper(root)\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1946392,
                "title": "python-short-faster-than-99-47-ms-with-o-1-sc-using-in-order-dfs-single-pass",
                "content": "Perform inorder traversal (values will be sorted). Keep check of previous values and its count, if it is more than max_count, modes will become current node value, if same add value to modes list, if less ignore. \\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    curr_count, max_count, prev_val, modes = 0, 0, None, []\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        def dfs(node):\\n            if not node: return\\n            dfs(node.left)\\n            self.curr_count = 1 if node.val != self.prev_val else self.curr_count + 1\\n            if self.curr_count > self.max_count: self.max_count, self.modes = self.curr_count, [node.val]\\n            elif self.curr_count == self.max_count: self.modes.append(node.val)\\n            self.prev_val = node.val\\n            dfs(node.right)\\n        dfs(root)\\n        return self.modes\\n```",
                "solutionTags": [
                    "Python",
                    "Depth-First Search",
                    "Binary Search Tree"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    curr_count, max_count, prev_val, modes = 0, 0, None, []\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        def dfs(node):\\n            if not node: return\\n            dfs(node.left)\\n            self.curr_count = 1 if node.val != self.prev_val else self.curr_count + 1\\n            if self.curr_count > self.max_count: self.max_count, self.modes = self.curr_count, [node.val]\\n            elif self.curr_count == self.max_count: self.modes.append(node.val)\\n            self.prev_val = node.val\\n            dfs(node.right)\\n        dfs(root)\\n        return self.modes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1763813,
                "title": "c-o-n-easy-solution",
                "content": "![image](https://assets.leetcode.com/users/images/200c9aec-ff1c-4a44-afca-076ca5e8a413_1644603101.987564.png)\\n\\n```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> map;\\n    int fre;\\n    void solve(TreeNode* root){\\n        //base case\\n        if(!root) return;\\n        //recursive case\\n        map[root->val]++;\\n        fre = max(fre, map[root->val]);\\n        solve(root->left);\\n        solve(root->right);\\n        return;\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        fre = 0;\\n        solve(root);\\n        vector<int> res;\\n        for(auto &x: map){\\n            if(x.second == fre) res.push_back(x.first);\\n        }\\n        return res;\\n    }\\n};\\n```\\n",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    unordered_map<int, int> map;\\n    int fre;\\n    void solve(TreeNode* root){\\n        //base case\\n        if(!root) return;\\n        //recursive case\\n        map[root->val]++;\\n        fre = max(fre, map[root->val]);\\n        solve(root->left);\\n        solve(root->right);\\n        return;\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        fre = 0;\\n        solve(root);\\n        vector<int> res;\\n        for(auto &x: map){\\n            if(x.second == fre) res.push_back(x.first);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1729070,
                "title": "java-inorder-o-1-solution",
                "content": "```\\nclass Solution {\\n    public int[] findMode(TreeNode root) {\\n        int[] cntTrack = {0,0,Integer.MAX_VALUE}; // curCnt,maxCnt,prev\\n        Set<Integer> res = new HashSet<>();\\n        inorder(root,res,cntTrack);\\n        return res.stream().mapToInt(k->k).toArray();\\n    }\\n    \\n    private void inorder(TreeNode node,Set<Integer> res,int[] cntTrack) {\\n        if(node == null) return;\\n        inorder(node.left,res,cntTrack);\\n        \\n        cntTrack[0] = cntTrack[2] == node.val ? cntTrack[0] + 1 : 1;\\n        if(cntTrack[0] > cntTrack[1]) {\\n            cntTrack[1] = cntTrack[0];\\n            res.clear();\\n            res.add(node.val);\\n        } else if(cntTrack[0] == cntTrack[1]) {\\n            res.add(node.val);\\n        }\\n        \\n        cntTrack[2] = node.val;\\n        inorder(node.right,res,cntTrack);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findMode(TreeNode root) {\\n        int[] cntTrack = {0,0,Integer.MAX_VALUE}; // curCnt,maxCnt,prev\\n        Set<Integer> res = new HashSet<>();\\n        inorder(root,res,cntTrack);\\n        return res.stream().mapToInt(k->k).toArray();\\n    }\\n    \\n    private void inorder(TreeNode node,Set<Integer> res,int[] cntTrack) {\\n        if(node == null) return;\\n        inorder(node.left,res,cntTrack);\\n        \\n        cntTrack[0] = cntTrack[2] == node.val ? cntTrack[0] + 1 : 1;\\n        if(cntTrack[0] > cntTrack[1]) {\\n            cntTrack[1] = cntTrack[0];\\n            res.clear();\\n            res.add(node.val);\\n        } else if(cntTrack[0] == cntTrack[1]) {\\n            res.add(node.val);\\n        }\\n        \\n        cntTrack[2] = node.val;\\n        inorder(node.right,res,cntTrack);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1724020,
                "title": "ugly-but-o-1-space",
                "content": "The idea is to traverse the tree two times. We will do inorder traversal.\\nFirst traversal will be for getting maximum frequency and,\\nSecond traversal is for storing nodes having maximum frequency.\\n\\nHere is my code:\\n```\\nclass Solution {\\n    TreeNode prev=null;\\n    int count=0,maxCount=0;\\n    public int[] findMode(TreeNode root) {\\n        if(root==null)return new int[1];\\n        getMostFreqCount(root);\\n         if(maxCount<count){\\n                maxCount=count;\\n        }\\n        prev=null;\\n        count=0;\\n        ArrayList<Integer> a=new ArrayList<>();\\n        getMostFreqNodes(root,a);\\n         if(maxCount==count){\\n               a.add(prev.val);\\n            }\\n        int ans[]=new int[a.size()];\\n        for(int i=0;i<a.size();i++)ans[i]=a.get(i);\\n        return ans;\\n    }\\n    public void getMostFreqCount(TreeNode root){\\n        if(root==null)return;\\n        getMostFreqCount(root.left);\\n        if(prev!=null&&root.val==prev.val){\\n            count++;\\n        }else{\\n            if(maxCount<count){\\n                maxCount=count;\\n            }\\n            count=1;\\n            prev=root;\\n        }\\n        getMostFreqCount(root.right);\\n    }\\n    public void getMostFreqNodes(TreeNode root,ArrayList<Integer> a){\\n        if(root==null)return;\\n        getMostFreqNodes(root.left,a);\\n        if(prev!=null&&root.val==prev.val){\\n            count++;\\n        }else{\\n            if(maxCount==count){\\n               a.add(prev.val);\\n            }\\n            count=1;\\n            prev=root;\\n        }\\n        getMostFreqNodes(root.right,a);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    TreeNode prev=null;\\n    int count=0,maxCount=0;\\n    public int[] findMode(TreeNode root) {\\n        if(root==null)return new int[1];\\n        getMostFreqCount(root);\\n         if(maxCount<count){\\n                maxCount=count;\\n        }\\n        prev=null;\\n        count=0;\\n        ArrayList<Integer> a=new ArrayList<>();\\n        getMostFreqNodes(root,a);\\n         if(maxCount==count){\\n               a.add(prev.val);\\n            }\\n        int ans[]=new int[a.size()];\\n        for(int i=0;i<a.size();i++)ans[i]=a.get(i);\\n        return ans;\\n    }\\n    public void getMostFreqCount(TreeNode root){\\n        if(root==null)return;\\n        getMostFreqCount(root.left);\\n        if(prev!=null&&root.val==prev.val){\\n            count++;\\n        }else{\\n            if(maxCount<count){\\n                maxCount=count;\\n            }\\n            count=1;\\n            prev=root;\\n        }\\n        getMostFreqCount(root.right);\\n    }\\n    public void getMostFreqNodes(TreeNode root,ArrayList<Integer> a){\\n        if(root==null)return;\\n        getMostFreqNodes(root.left,a);\\n        if(prev!=null&&root.val==prev.val){\\n            count++;\\n        }else{\\n            if(maxCount==count){\\n               a.add(prev.val);\\n            }\\n            count=1;\\n            prev=root;\\n        }\\n        getMostFreqNodes(root.right,a);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1722526,
                "title": "python3-inorder-traversal-beats-99",
                "content": "I originally did a solution using a dictionary to track the frequency of each value and then calculate the modes at the end. A nice general solution for any tree but doesn\\'t exploit the structure of the BST where the same values will be clustered into sub-trees and hence it was slow and memory intensive.\\n\\nThis solution does much better.\\n\\n```\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        def traverse(root: TreeNode) -> None:\\n            \\n            if not root:\\n                return\\n            \\n            nonlocal maxcount, count, prevval, modes\\n            \\n            traverse(root.left)\\n            \\n            if root.val == prevval:\\n                count += 1\\n            else:                \\n                count = 1\\n                \\n            if count > maxcount:\\n                maxcount = count\\n                modes = [root.val]\\n            elif count == maxcount:\\n                modes.append(root.val)\\n                \\n            prevval = root.val\\n            traverse(root.right)\\n                \\n                \\n        modes = []\\n        maxcount = 0\\n        count = 0\\n        prevval = root.val\\n        traverse(root)\\n        \\n        return modes\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        def traverse(root: TreeNode) -> None:\\n            \\n            if not root:\\n                return\\n            \\n            nonlocal maxcount, count, prevval, modes\\n            \\n            traverse(root.left)\\n            \\n            if root.val == prevval:\\n                count += 1\\n            else:                \\n                count = 1\\n                \\n            if count > maxcount:\\n                maxcount = count\\n                modes = [root.val]\\n            elif count == maxcount:\\n                modes.append(root.val)\\n                \\n            prevval = root.val\\n            traverse(root.right)\\n                \\n                \\n        modes = []\\n        maxcount = 0\\n        count = 0\\n        prevval = root.val\\n        traverse(root)\\n        \\n        return modes\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1701133,
                "title": "4ms-solution-map-dfs-java",
                "content": "```\\nclass Solution {\\n    Map<Integer,Integer> map = new HashMap<>();\\n    public int[] findMode(TreeNode root) {\\n      dfs(root);  \\n      int max = 0;\\n       List<Integer> k= new ArrayList<>();\\n        for(int i : map.values()) max = Math.max(i,max);\\n        for(int key: map.keySet()){\\n             if(map.get(key)==max){\\n                  k.add(key);\\n        }}\\n        int[] ans = new int[k.size()];\\n        for(int i = 0;i<k.size();i++){\\n            ans[i] = k.get(i);\\n        }\\n       \\n     return ans;\\n\\n}\\n\\n\\n    public void dfs(TreeNode root){\\n        if (root==null)return;\\n        map.put(root.val,map.getOrDefault(root.val, 0)+1);\\n        dfs(root.left);\\n        dfs(root.right);\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Depth-First Search"
                ],
                "code": "```\\nclass Solution {\\n    Map<Integer,Integer> map = new HashMap<>();\\n    public int[] findMode(TreeNode root) {\\n      dfs(root);  \\n      int max = 0;\\n       List<Integer> k= new ArrayList<>();\\n        for(int i : map.values()) max = Math.max(i,max);\\n        for(int key: map.keySet()){\\n             if(map.get(key)==max){\\n                  k.add(key);\\n        }}\\n        int[] ans = new int[k.size()];\\n        for(int i = 0;i<k.size();i++){\\n            ans[i] = k.get(i);\\n        }\\n       \\n     return ans;\\n\\n}\\n\\n\\n    public void dfs(TreeNode root){\\n        if (root==null)return;\\n        map.put(root.val,map.getOrDefault(root.val, 0)+1);\\n        dfs(root.left);\\n        dfs(root.right);\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1699613,
                "title": "easy-solution-using-map",
                "content": "If you like my solution please upvote!!!!\\n```\\n\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root,unordered_map<int,int>&mp){\\n         if(!root) return ;\\n        \\n        //storing frequency of element\\n        mp[root->val]++;\\n        dfs(root->left,mp);\\n        dfs(root->right,mp);\\n     \\n    }\\n    \\n    vector<int> findMode(TreeNode* root) {\\n         vector<int>v;\\n        \\n        ///map for storing the frequency of occurence of each element\\n        unordered_map<int,int>mp;\\n        \\n        dfs(root,mp);\\n        int mx = INT_MIN;\\n        \\n        //treversing through map\\n        for(auto i: mp){\\n            \\n            // if we get greater element then prev found max element ....update max element and empty the vector\\n            if(i.second>mx){\\n                v.clear();\\n                mx = i.second;\\n                v.push_back(i.first);\\n            }else if(i.second==mx){\\n                v.push_back(i.first);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    void dfs(TreeNode* root,unordered_map<int,int>&mp){\\n         if(!root) return ;\\n        \\n        //storing frequency of element\\n        mp[root->val]++;\\n        dfs(root->left,mp);\\n        dfs(root->right,mp);\\n     \\n    }\\n    \\n    vector<int> findMode(TreeNode* root) {\\n         vector<int>v;\\n        \\n        ///map for storing the frequency of occurence of each element\\n        unordered_map<int,int>mp;\\n        \\n        dfs(root,mp);\\n        int mx = INT_MIN;\\n        \\n        //treversing through map\\n        for(auto i: mp){\\n            \\n            // if we get greater element then prev found max element ....update max element and empty the vector\\n            if(i.second>mx){\\n                v.clear();\\n                mx = i.second;\\n                v.push_back(i.first);\\n            }else if(i.second==mx){\\n                v.push_back(i.first);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1566432,
                "title": "c-o-n-solution-single-traversal",
                "content": "```\\nvoid inOrder(TreeNode *root, vector<int>& v) {\\n        if(!root) return;\\n        inOrder(root->left, v);\\n        v.push_back(root->val);\\n        inOrder(root->right, v);\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> ans, v;\\n        inOrder(root, v);\\n\\t\\t\\n        int maxFreq = 1, count = 1, n = v.size();\\n\\t\\t\\n        for(int i = 1; i < n; i++) {\\n            if(v[i] == v[i - 1]) count++;\\n            else if(count > maxFreq ) { ans.clear(); ans.push_back(v[i - 1]); maxFreq = count; count = 1; }\\n            else if(count == maxFreq) { ans.push_back(v[i - 1]); count = 1; }\\n            else count = 1;\\n        }\\n        if(count > maxFreq) { ans.clear(); ans.push_back(v[n - 1]); }\\n        else if (count == maxFreq) { ans.push_back(v[n - 1]); }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nvoid inOrder(TreeNode *root, vector<int>& v) {\\n        if(!root) return;\\n        inOrder(root->left, v);\\n        v.push_back(root->val);\\n        inOrder(root->right, v);\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> ans, v;\\n        inOrder(root, v);\\n\\t\\t\\n        int maxFreq = 1, count = 1, n = v.size();\\n\\t\\t\\n        for(int i = 1; i < n; i++) {\\n            if(v[i] == v[i - 1]) count++;\\n            else if(count > maxFreq ) { ans.clear(); ans.push_back(v[i - 1]); maxFreq = count; count = 1; }\\n            else if(count == maxFreq) { ans.push_back(v[i - 1]); count = 1; }\\n            else count = 1;\\n        }\\n        if(count > maxFreq) { ans.clear(); ans.push_back(v[n - 1]); }\\n        else if (count == maxFreq) { ans.push_back(v[n - 1]); }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1552067,
                "title": "c-easy-solution-using-hashtable",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void inorder(TreeNode* root,unordered_map<int,int>& map)\\n    {\\n        if(root == nullptr)return;\\n        inorder(root->left,map);\\n        map[root->val]++;\\n        inorder(root->right,map);\\n    }\\npublic:\\n    vector<int> findMode(TreeNode* root) \\n    {\\n        unordered_map<int,int> map;\\n        inorder(root,map);\\n        int maxFreq = 0;\\n        for(auto &i: map)maxFreq = max(i.second,maxFreq);\\n        vector<int> res;\\n        for(auto &i: map)\\n        {\\n            if(i.second == maxFreq)\\n            {\\n                res.push_back(i.first);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Hash Table",
                    "Depth-First Search",
                    "Recursion"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    void inorder(TreeNode* root,unordered_map<int,int>& map)\\n    {\\n        if(root == nullptr)return;\\n        inorder(root->left,map);\\n        map[root->val]++;\\n        inorder(root->right,map);\\n    }\\npublic:\\n    vector<int> findMode(TreeNode* root) \\n    {\\n        unordered_map<int,int> map;\\n        inorder(root,map);\\n        int maxFreq = 0;\\n        for(auto &i: map)maxFreq = max(i.second,maxFreq);\\n        vector<int> res;\\n        for(auto &i: map)\\n        {\\n            if(i.second == maxFreq)\\n            {\\n                res.push_back(i.first);\\n            }\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522593,
                "title": "using-inorder-java-solution",
                "content": "```\\nclass Solution {\\n    List<Integer> list=new ArrayList<>();\\n    void inorder(TreeNode root)\\n    {\\n        if(root!=null)\\n        {\\n            inorder(root.left);\\n            list.add(root.val);\\n            inorder(root.right);\\n        }\\n    }\\n    public int[] findMode(TreeNode root) \\n    {\\n        inorder(root);\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        int max=0;\\n        List<Integer> ans=new ArrayList<>();\\n        for(int i:list)\\n        {\\n            if(!map.containsKey(i))\\n                map.put(i,1);\\n            else\\n                map.put(i,map.get(i)+1);\\n            if(map.get(i)>max)\\n                max=map.get(i);\\n        }\\n        for(Map.Entry<Integer,Integer> entry:map.entrySet())\\n        {\\n            if(entry.getValue()==max)\\n                ans.add(entry.getKey());\\n        }\\n        int a[]=new int[ans.size()];\\n        for(int i=0;i<ans.size();i++)\\n            a[i]=ans.get(i);\\n        return a;\\n        \\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    List<Integer> list=new ArrayList<>();\\n    void inorder(TreeNode root)\\n    {\\n        if(root!=null)\\n        {\\n            inorder(root.left);\\n            list.add(root.val);\\n            inorder(root.right);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1418527,
                "title": "simple-java-inorder-travel",
                "content": "```\\n    List<Integer> res = new ArrayList<>();\\n    Integer preValue = null;\\n    int currCount = 0 ;\\n    int maxCount = 0 ;\\n    public int[] findMode(TreeNode root) {\\n        inOrder(root);\\n        return res.stream().mapToInt(Integer::intValue).toArray();\\n    }\\n\\n    private void inOrder(TreeNode node) {\\n        if(node == null) return;\\n        inOrder(node.left);\\n        if(preValue != null && preValue.equals(node.val)){\\n            currCount ++;\\n        } else {\\n            preValue = node.val;\\n            currCount = 1;\\n        }\\n        if(currCount > maxCount){\\n            res.clear();\\n            maxCount = currCount;\\n            res.add(node.val);\\n        } else if (currCount == maxCount) {\\n            res.add(node.val);\\n        }\\n        inOrder(node.right);\\n    }\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    List<Integer> res = new ArrayList<>();\\n    Integer preValue = null;\\n    int currCount = 0 ;\\n    int maxCount = 0 ;\\n    public int[] findMode(TreeNode root) {\\n        inOrder(root);\\n        return res.stream().mapToInt(Integer::intValue).toArray();\\n    }\\n\\n    private void inOrder(TreeNode node) {\\n        if(node == null) return;\\n        inOrder(node.left);\\n        if(preValue != null && preValue.equals(node.val)){\\n            currCount ++;\\n        } else {\\n            preValue = node.val;\\n            currCount = 1;\\n        }\\n        if(currCount > maxCount){\\n            res.clear();\\n            maxCount = currCount;\\n            res.add(node.val);\\n        } else if (currCount == maxCount) {\\n            res.add(node.val);\\n        }\\n        inOrder(node.right);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1416921,
                "title": "easy-python-using-dictionary",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return [0]\\n        dict={}\\n        stack=[root]\\n        while stack:\\n            t=stack.pop()\\n            if t.val in dict.keys():\\n                dict[t.val]+=1\\n            else:\\n                dict[t.val]=1\\n            if t.left:\\n                stack.append(t.left)\\n            if t.right:\\n                stack.append(t.right)\\n        m=max(dict.values())\\n        ans=[]\\n        for i in dict.keys():\\n            if dict[i]==m:\\n                ans.append(i)\\n        return ans\\n            \\n                \\n",
                "solutionTags": [],
                "code": "class Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        if root is None:\\n            return [0]\\n        dict={}",
                "codeTag": "Java"
            },
            {
                "id": 1404708,
                "title": "python-simple-solution-o-1-extra-space-inorder-solution",
                "content": "```\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        prev,count=0,0\\n        ans=[]\\n        c=0\\n        def inorder(root):\\n            nonlocal prev,count,c,ans\\n            if root:\\n                inorder(root.left)\\n                if prev==root.val:\\n                    count+=1\\n                else:\\n                    prev=root.val\\n                    count=1\\n                if count>c:\\n                    c=count\\n                    ans=[root.val]\\n                elif count==c:\\n                    ans.append(root.val)\\n                inorder(root.right)\\n        inorder(root)\\n        return(ans)\\n                \\n\\t```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        prev,count=0,0\\n        ans=[]\\n        c=0\\n        def inorder(root):\\n            nonlocal prev,count,c,ans\\n            if root:\\n                inorder(root.left)\\n                if prev==root.val:\\n                    count+=1\\n                else:\\n                    prev=root.val\\n                    count=1\\n                if count>c:\\n                    c=count\\n                    ans=[root.val]\\n                elif count==c:\\n                    ans.append(root.val)\\n                inorder(root.right)\\n        inorder(root)\\n        return(ans)\\n                \\n\\t```",
                "codeTag": "Java"
            },
            {
                "id": 1340852,
                "title": "java-o-1-space",
                "content": "\\'\\'\\'\\nPlease upvote if you find it helpful!!!!\\nThanks!!\\n\\nclass Solution {\\n    private TreeNode lastSeen = null;\\n    private List<Integer> vals = new LinkedList<>();\\n    private int count = 1;\\n    private int maxCount = Integer.MIN_VALUE;\\n    \\n    private void dfs(TreeNode root){\\n        if(root == null){return;}\\n        dfs(root.left);\\n       \\n        if(lastSeen != null){\\n            if(root.val == lastSeen.val){\\n                count++;\\n            }else{\\n                if(count > maxCount){\\n                    maxCount = count;\\n                    vals.clear();\\n                    vals.add(lastSeen.val);\\n                }else if(count == maxCount){\\n                    vals.add(lastSeen.val);\\n                }\\n                count = 1;\\n            }\\n        }\\n        \\n        lastSeen = root;\\n        dfs(root.right);\\n    }\\n    \\n    public int[] findMode(TreeNode root) {\\n        dfs(root);\\n        if(count > maxCount){\\n            maxCount = count;\\n            vals.clear();\\n            vals.add(lastSeen.val);\\n        }else if(count == maxCount){\\n            vals.add(lastSeen.val);\\n        }\\n        return vals.stream().mapToInt(i->i).toArray();\\n    }\\n}\\n\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\n    private TreeNode lastSeen = null;\\n    private List<Integer> vals = new LinkedList<>();\\n    private int count = 1;\\n    private int maxCount = Integer.MIN_VALUE;\\n    \\n    private void dfs(TreeNode root){\\n        if(root == null){return;}",
                "codeTag": "Java"
            },
            {
                "id": 1338568,
                "title": "c-simple-solution-faster-than-00-constant-time-space-1-eg",
                "content": "class Solution {\\npublic:\\n```\\n    // i\\'ll give you a hint :\\n    // the biggest value we could put in the left right tree (subtree) is the root itself so any value after this value will be the root itself.\\n    // and the smallest value we could put in the right left tree(subtree) is the root itself  so any value after this value we be the root itself;\\n    // so we will do an inorder traverse ;\\n    int count = 0 ;\\n    int currNode = 0 ;\\n    int Max = 0 ;\\n    vector<int>ans ;\\n   void inorder(TreeNode*root){\\n        if (root->left)\\n            inorder(root->left) ;\\n        if (!count||currNode!=root->val){\\n            count = 1 ;\\n            currNode = root->val ;\\n        }\\n        else \\n            count++ ;\\n        if (Max<=count){\\n            if (Max<count){\\n                Max = count ;\\n                ans.clear() ;\\n            }\\n            ans.push_back(root->val) ;\\n        }\\n        if (root->right)\\n            inorder(root->right) ;\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        inorder(root) ;\\n        return ans ;\\n        // this algo is time is O(n) , space (1) ;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n    // i\\'ll give you a hint :\\n    // the biggest value we could put in the left right tree (subtree) is the root itself so any value after this value will be the root itself.\\n    // and the smallest value we could put in the right left tree(subtree) is the root itself  so any value after this value we be the root itself;\\n    // so we will do an inorder traverse ;\\n    int count = 0 ;\\n    int currNode = 0 ;\\n    int Max = 0 ;\\n    vector<int>ans ;\\n   void inorder(TreeNode*root){\\n        if (root->left)\\n            inorder(root->left) ;\\n        if (!count||currNode!=root->val){\\n            count = 1 ;\\n            currNode = root->val ;\\n        }\\n        else \\n            count++ ;\\n        if (Max<=count){\\n            if (Max<count){\\n                Max = count ;\\n                ans.clear() ;\\n            }\\n            ans.push_back(root->val) ;\\n        }\\n        if (root->right)\\n            inorder(root->right) ;\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        inorder(root) ;\\n        return ans ;\\n        // this algo is time is O(n) , space (1) ;\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1337451,
                "title": "c-short-o-n-time-inorder-recursion",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        mx = 0, l = 0, p = NULL;\\n        dfs(root);\\n        return res;\\n    }\\nprivate:\\n    vector<int> res;\\n    int mx, l;\\n    TreeNode* p;\\n    void dfs(TreeNode* root) {\\n        if (!root) return;\\n        dfs(root->left);\\n        l = (p && root->val == p->val) ? l + 1 : 1;\\n        p = root;\\n        if (l > mx) {\\n            res = {root->val}, mx = l;\\n        } else if (l == mx) {\\n            res.push_back(root->val);\\n        }\\n        dfs(root->right);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        mx = 0, l = 0, p = NULL;\\n        dfs(root);\\n        return res;\\n    }\\nprivate:\\n    vector<int> res;\\n    int mx, l;\\n    TreeNode* p;\\n    void dfs(TreeNode* root) {\\n        if (!root) return;\\n        dfs(root->left);\\n        l = (p && root->val == p->val) ? l + 1 : 1;\\n        p = root;\\n        if (l > mx) {\\n            res = {root->val}, mx = l;\\n        } else if (l == mx) {\\n            res.push_back(root->val);\\n        }\\n        dfs(root->right);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1081114,
                "title": "golang-solution-with-quick-explanation",
                "content": "The idea of this solution is to iterate through the tree, and add all the values to a map. Then get all the max values of the map and add them to the result array.\\n\\n```\\nfunc findMode(root *TreeNode) []int {\\n    max := 0\\n    m := make(map[int]int)\\n    res := []int{}\\n    stack := []*TreeNode{}\\n    stack = append(stack, root)\\n\\n    for len(stack) != 0 {\\n        pop := stack[len(stack)-1]\\n        stack = stack[:len(stack)-1]\\n\\n        if pop != nil {\\n            m[pop.Val]++\\n            stack = append(stack, pop.Left, pop.Right)\\n        }\\n    }\\n\\n    for i, i2 := range m {\\n        if i2 > max {\\n            res = []int{i}\\n            max = i2\\n        } else if i2 == max {\\n            res = append(res, i)\\n        }\\n    }\\n    return res\\n}\\n```",
                "solutionTags": [
                    "Go"
                ],
                "code": "```\\nfunc findMode(root *TreeNode) []int {\\n    max := 0\\n    m := make(map[int]int)\\n    res := []int{}\\n    stack := []*TreeNode{}\\n    stack = append(stack, root)\\n\\n    for len(stack) != 0 {\\n        pop := stack[len(stack)-1]\\n        stack = stack[:len(stack)-1]\\n\\n        if pop != nil {\\n            m[pop.Val]++\\n            stack = append(stack, pop.Left, pop.Right)\\n        }\\n    }\\n\\n    for i, i2 := range m {\\n        if i2 > max {\\n            res = []int{i}\\n            max = i2\\n        } else if i2 == max {\\n            res = append(res, i)\\n        }\\n    }\\n    return res\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1068177,
                "title": "c-easy-solution-without-using-extra-space-16-feb",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int prev=INT_MIN;\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> v;\\n        int max = 1,count=1;\\n        util(root,v,max,count);\\n        return v;\\n    }\\n    \\n    void util(TreeNode* root, vector<int>&v, int& max, int& count)\\n    {\\n        if(!root)\\n        {\\n            return;\\n        }\\n        \\n        util(root->left,v,max,count);\\n        \\n        if(prev==root->val)\\n        {\\n            count++;\\n        }\\n        else\\n        {\\n            count=1;\\n        }\\n        if(max==count)\\n        {\\n            v.push_back(root->val);\\n        }\\n        else if(max<count)\\n        {\\n            v.clear();\\n            v.push_back(root->val);\\n            max=count;\\n        }\\n        prev=root->val;\\n        \\n        util(root->right,v,max,count);        \\n    }\\n   \\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int prev=INT_MIN;\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> v;\\n        int max = 1,count=1;\\n        util(root,v,max,count);\\n        return v;\\n    }\\n    \\n    void util(TreeNode* root, vector<int>&v, int& max, int& count)\\n    {\\n        if(!root)\\n        {\\n            return;\\n        }\\n        \\n        util(root->left,v,max,count);\\n        \\n        if(prev==root->val)\\n        {\\n            count++;\\n        }\\n        else\\n        {\\n            count=1;\\n        }\\n        if(max==count)\\n        {\\n            v.push_back(root->val);\\n        }\\n        else if(max<count)\\n        {\\n            v.clear();\\n            v.push_back(root->val);\\n            max=count;\\n        }\\n        prev=root->val;\\n        \\n        util(root->right,v,max,count);        \\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1051874,
                "title": "o-1-space-python-solution",
                "content": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def findMode(self, root: TreeNode) -> List[int]:\\n        self.prev = None\\n        self.ans = list()\\n        self.count = 0\\n        self.max_count = 0\\n        \\n        def solve(root):\\n            if root is None:\\n                return\\n            \\n            solve(root.left)\\n            \\n            if self.prev is None or root.val != self.prev:\\n                self.count = 1\\n            elif root.val == self.prev:\\n                self.count += 1\\n                \\n            \\n            if self.max_count == self.count:\\n                self.ans.append(root.val)\\n            elif self.max_count < self.count:\\n                self.ans = list()\\n                self.ans.append(root.val)\\n                self.max_count = self.count\\n                \\n            self.prev = root.val\\n                \\n            solve(root.right)\\n            \\n        solve(root)\\n        return self.ans\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n\\n    def findMode(self, root: TreeNode) -> List[int]:\\n        self.prev = None\\n        self.ans = list()\\n        self.count = 0\\n        self.max_count = 0\\n        \\n        def solve(root):\\n            if root is None:\\n                return\\n            \\n            solve(root.left)\\n            \\n            if self.prev is None or root.val != self.prev:\\n                self.count = 1\\n            elif root.val == self.prev:\\n                self.count += 1\\n                \\n            \\n            if self.max_count == self.count:\\n                self.ans.append(root.val)\\n            elif self.max_count < self.count:\\n                self.ans = list()\\n                self.ans.append(root.val)\\n                self.max_count = self.count\\n                \\n            self.prev = root.val\\n                \\n            solve(root.right)\\n            \\n        solve(root)\\n        return self.ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1037093,
                "title": "simple-c-using-o-1-extra-space-and-no-global-variables",
                "content": "```\\n   void inorder(TreeNode *root,vector<int> &res,int &prev,int &count,int &maxi)\\n    {\\n        if(root==NULL)\\n            return ;\\n        inorder(root->left,res,prev,count,maxi);\\n        if(root->val==prev)\\n            count++;\\n        else\\n            count=1;\\n        if(count>maxi)\\n        { \\n            res.clear();\\n            res.push_back(root->val);\\n            maxi=count;\\n        }\\n        else if(count==maxi)\\n            res.push_back(root->val);\\n        prev=root->val;\\n        inorder(root->right,res,prev,count,maxi);\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> res;\\n        int maxi=0,prev=-1,count=0;\\n        inorder(root,res,prev,count,maxi);\\n        return res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n   void inorder(TreeNode *root,vector<int> &res,int &prev,int &count,int &maxi)\\n    {\\n        if(root==NULL)\\n            return ;\\n        inorder(root->left,res,prev,count,maxi);\\n        if(root->val==prev)\\n            count++;\\n        else\\n            count=1;\\n        if(count>maxi)\\n        { \\n            res.clear();\\n            res.push_back(root->val);\\n            maxi=count;\\n        }\\n        else if(count==maxi)\\n            res.push_back(root->val);\\n        prev=root->val;\\n        inorder(root->right,res,prev,count,maxi);\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> res;\\n        int maxi=0,prev=-1,count=0;\\n        inorder(root,res,prev,count,maxi);\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 924879,
                "title": "easy-to-understand-c-unorderd-map-and-inorder-traversal",
                "content": "The idea is simple. Traverse the tree in any fashion (inorder, preorder or postorder) and store the node\\'s values and their frequency in a hashmap. Keep a tab on the maximum frequency acheived so far and iterate the hashmap again to push the keys into the resultant vector.\\n\\n```\\n   void inorder(TreeNode* root, unordered_map<int, int>& hash, int& maxFreq) {\\n        \\n        if(root==NULL) return;\\n        \\n        inorder(root->left, hash, maxFreq);\\n        \\n        hash[root->val]++;\\n        if(hash[root->val] > maxFreq)\\n            maxFreq = hash[root->val];\\n        \\n        inorder(root->right, hash, maxFreq);\\n        \\n    }\\n    \\n    vector<int> findMode(TreeNode* root) {\\n        \\n        unordered_map<int, int> hash;\\n        vector<int> res;\\n        \\n        int maxFreq=0;\\n        inorder(root, hash, maxFreq);\\n        \\n\\n        // find maximum frequency\\n        for(auto itr: hash) {\\n            \\n            if(itr.second==maxFreq) \\n                res.push_back(itr.first);\\n        }\\n        \\n        return res;\\n        \\n    }\\n\\n\\n```\\n\\nTime Complexity: O(n) because inorder traversal goes to every node atleast once. \\nSpace Complexity: O(n) because of unordered_map and recursion stack for inorder traversal.\\n\\nLet me know if you have any questions.",
                "solutionTags": [],
                "code": "```\\n   void inorder(TreeNode* root, unordered_map<int, int>& hash, int& maxFreq) {\\n        \\n        if(root==NULL) return;\\n        \\n        inorder(root->left, hash, maxFreq);\\n        \\n        hash[root->val]++;\\n        if(hash[root->val] > maxFreq)\\n            maxFreq = hash[root->val];\\n        \\n        inorder(root->right, hash, maxFreq);\\n        \\n    }\\n    \\n    vector<int> findMode(TreeNode* root) {\\n        \\n        unordered_map<int, int> hash;\\n        vector<int> res;\\n        \\n        int maxFreq=0;\\n        inorder(root, hash, maxFreq);\\n        \\n\\n        // find maximum frequency\\n        for(auto itr: hash) {\\n            \\n            if(itr.second==maxFreq) \\n                res.push_back(itr.first);\\n        }\\n        \\n        return res;\\n        \\n    }\\n\\n\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 872879,
                "title": "java-o-1-space",
                "content": "```\\nclass Solution {\\n    int prev = Integer.MIN_VALUE;\\n    int cnt = 0;\\n    int max = 0;\\n    public int[] findMode(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        inorder(root, list);\\n        return list.stream().mapToInt(i->i).toArray();\\n    }\\n    private void inorder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorder(root.left, list);\\n        if (root.val == prev) {\\n            cnt++;\\n            \\n        } else {\\n            cnt = 1;\\n        }\\n        if (cnt >= max) {\\n            if (cnt == max) {\\n               list.add(root.val);\\n            } else {\\n                list.clear();\\n                list.add(root.val);\\n                \\n                \\n            }\\n        }\\n        max = Math.max(max,cnt);\\n        prev = root.val;\\n        inorder(root.right, list);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    int prev = Integer.MIN_VALUE;\\n    int cnt = 0;\\n    int max = 0;\\n    public int[] findMode(TreeNode root) {\\n        List<Integer> list = new ArrayList<>();\\n        inorder(root, list);\\n        return list.stream().mapToInt(i->i).toArray();\\n    }\\n    private void inorder(TreeNode root, List<Integer> list) {\\n        if (root == null) {\\n            return;\\n        }\\n        inorder(root.left, list);\\n        if (root.val == prev) {\\n            cnt++;\\n            \\n        } else {\\n            cnt = 1;\\n        }\\n        if (cnt >= max) {\\n            if (cnt == max) {\\n               list.add(root.val);\\n            } else {\\n                list.clear();\\n                list.add(root.val);\\n                \\n                \\n            }\\n        }\\n        max = Math.max(max,cnt);\\n        prev = root.val;\\n        inorder(root.right, list);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 610683,
                "title": "javascript-o-1-solution",
                "content": "```js\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar findMode = function(root) {\\n    let ans = []\\n    let count = 0, _max = 0, prev = 0  \\n    \\n    const preorder = (root) => {\\n        if(!root) return \\n        \\n        preorder(root.left)\\n        \\n        count = prev == root.val ? ++count : 1\\n        \\n        if(count > _max) {\\n            ans = [root.val]\\n            _max = count\\n        } \\n        \\n        else if(count === _max)\\n            ans.push(root.val)\\n        \\n        prev = root.val\\n        \\n        preorder(root.right)\\n    }\\n    \\n    preorder(root)\\n    return ans\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val, left, right) {\\n *     this.val = (val===undefined ? 0 : val)\\n *     this.left = (left===undefined ? null : left)\\n *     this.right = (right===undefined ? null : right)\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar findMode = function(root) {\\n    let ans = []\\n    let count = 0, _max = 0, prev = 0  \\n    \\n    const preorder = (root) => {\\n        if(!root) return \\n        \\n        preorder(root.left)\\n        \\n        count = prev == root.val ? ++count : 1\\n        \\n        if(count > _max) {\\n            ans = [root.val]\\n            _max = count\\n        } \\n        \\n        else if(count === _max)\\n            ans.push(root.val)\\n        \\n        prev = root.val\\n        \\n        preorder(root.right)\\n    }\\n    \\n    preorder(root)\\n    return ans\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 519455,
                "title": "cpp-solution-without-hash-map-12ms-99-89-23-1mb-100",
                "content": "Simple in-order recursion while keeping track of frequency without using hashmap.\\n\\n```\\n    void recur(TreeNode* root, vector<int>& res, int& val, int& count, int& maxCount) {\\n        if (!root) return;\\n        recur(root->left, res, val, count, maxCount);\\n        if (root->val == val) {\\n            count++;\\n        } else {\\n            if (count > maxCount) {\\n                res.clear();\\n                res.push_back(val);\\n                maxCount = count;\\n            } else if ((count != 0) && (count == maxCount)) {\\n                res.push_back(val);\\n            }\\n            count = 1;\\n            val = root->val;\\n        }\\n        recur(root->right, res, val, count, maxCount);\\n        return;\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> res;\\n        int val = INT_MIN, count = 0, maxCount = 0;\\n        recur(root, res, val, count, maxCount);\\n        if (count > maxCount) {\\n            res.clear();\\n            res.push_back(val);\\n        } else if ((count != 0) && (count == maxCount)) {\\n            res.push_back(val);\\n        }\\n        return res;\\n    }\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n    void recur(TreeNode* root, vector<int>& res, int& val, int& count, int& maxCount) {\\n        if (!root) return;\\n        recur(root->left, res, val, count, maxCount);\\n        if (root->val == val) {\\n            count++;\\n        } else {\\n            if (count > maxCount) {\\n                res.clear();\\n                res.push_back(val);\\n                maxCount = count;\\n            } else if ((count != 0) && (count == maxCount)) {\\n                res.push_back(val);\\n            }\\n            count = 1;\\n            val = root->val;\\n        }\\n        recur(root->right, res, val, count, maxCount);\\n        return;\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> res;\\n        int val = INT_MIN, count = 0, maxCount = 0;\\n        recur(root, res, val, count, maxCount);\\n        if (count > maxCount) {\\n            res.clear();\\n            res.push_back(val);\\n        } else if ((count != 0) && (count == maxCount)) {\\n            res.push_back(val);\\n        }\\n        return res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 473898,
                "title": "javascript-solution-with-explanation-recursively-search-bst",
                "content": "```js\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar findMode = function(root) {\\n  const modes = {};\\n  \\n  // search BST recursively\\n  function search(node) {\\n    if (!node) {\\n      return null;\\n    }\\n    \\n    let key = node.val + \\'\\';\\n    if (!modes[key]) {\\n      modes[key] = 1;\\n    } else {\\n      modes[key] += 1;\\n    }\\n    \\n    search(node.left);\\n    search(node.right);\\n  }\\n  \\n  // start search\\n  search(root);\\n  \\n  // iterate through the search result, which is stored in variable \\'modes\\'\\n  let maxCount = null;\\n  let arr = [];\\n  for (key in modes) {\\n     // if there\\'s no maxCount, assign val to maxCount and result arr directly\\n     if (maxCount === null) { \\n       maxCount = modes[key];\\n       arr = [key];\\n     } else {\\n       // if the # occurence of current item is greater than maxCount, replace\\n       if (modes[key] > maxCount) {\\n         arr = [key];\\n         maxCount = modes[key]\\n       } else if (modes[key] === maxCount) {\\n         // otherwise, push current item to result arr\\n         arr.push(key);\\n       }\\n    }\\n  }\\n  \\n  return arr;\\n};\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```js\\n/**\\n * Definition for a binary tree node.\\n * function TreeNode(val) {\\n *     this.val = val;\\n *     this.left = this.right = null;\\n * }\\n */\\n/**\\n * @param {TreeNode} root\\n * @return {number[]}\\n */\\nvar findMode = function(root) {\\n  const modes = {};\\n  \\n  // search BST recursively\\n  function search(node) {\\n    if (!node) {\\n      return null;\\n    }\\n    \\n    let key = node.val + \\'\\';\\n    if (!modes[key]) {\\n      modes[key] = 1;\\n    } else {\\n      modes[key] += 1;\\n    }\\n    \\n    search(node.left);\\n    search(node.right);\\n  }\\n  \\n  // start search\\n  search(root);\\n  \\n  // iterate through the search result, which is stored in variable \\'modes\\'\\n  let maxCount = null;\\n  let arr = [];\\n  for (key in modes) {\\n     // if there\\'s no maxCount, assign val to maxCount and result arr directly\\n     if (maxCount === null) { \\n       maxCount = modes[key];\\n       arr = [key];\\n     } else {\\n       // if the # occurence of current item is greater than maxCount, replace\\n       if (modes[key] > maxCount) {\\n         arr = [key];\\n         maxCount = modes[key]\\n       } else if (modes[key] === maxCount) {\\n         // otherwise, push current item to result arr\\n         arr.push(key);\\n       }\\n    }\\n  }\\n  \\n  return arr;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 410017,
                "title": "c-solution",
                "content": "```\\npublic class Solution\\n{\\n    public int[] FindMode(TreeNode root) \\n    {\\n        if(root == null) return new int[0];\\n        Dictionary<int, int> table = new Dictionary<int, int>();\\n\\t\\tvar stack = new Stack<TreeNode>();\\n\\t\\tstack.Push(root);\\n\\t\\twhile(stack.Count != 0) \\n        {\\n\\t\\t\\tvar node = stack.Pop();\\n\\t\\t\\tif (node != null) \\n            {\\n\\t\\t\\t\\tif (!table.ContainsKey(node.val)) \\n                    table[node.val] = 0;\\n\\t\\t\\t\\ttable[node.val]++;\\n\\t\\t\\t\\tstack.Push(node.left);\\n\\t\\t\\t\\tstack.Push(node.right);\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\tint max = table.Values.Max();\\n\\t\\treturn table.Where(x => x.Value == max).Select(x => x.Key).ToArray();    \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution\\n{\\n    public int[] FindMode(TreeNode root) \\n    {\\n        if(root == null) return new int[0];\\n        Dictionary<int, int> table = new Dictionary<int, int>();\\n\\t\\tvar stack = new Stack<TreeNode>();\\n\\t\\tstack.Push(root);\\n\\t\\twhile(stack.Count != 0) \\n        {\\n\\t\\t\\tvar node = stack.Pop();\\n\\t\\t\\tif (node != null) \\n            {\\n\\t\\t\\t\\tif (!table.ContainsKey(node.val)) \\n                    table[node.val] = 0;\\n\\t\\t\\t\\ttable[node.val]++;\\n\\t\\t\\t\\tstack.Push(node.left);\\n\\t\\t\\t\\tstack.Push(node.right);\\n\\t\\t\\t}\\n\\t\\t}\\n        \\n\\t\\tint max = table.Values.Max();\\n\\t\\treturn table.Where(x => x.Value == max).Select(x => x.Key).ToArray();    \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 401089,
                "title": "easy-c-solution-using-dfs",
                "content": "Runtime: 28 ms, faster than 50.68% of C++ online submissions for Find Mode in Binary Search Tree.\\nMemory Usage: 27.6 MB, less than 42.86% of C++ online submissions for Find Mode in Binary Search Tree.\\n\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        \\n        if(root == nullptr)\\n            return {};\\n        \\n        int maxCount = INT_MIN;\\n        map<int,int> mp;\\n        vector<int> res;\\n        fillMap(root, mp);\\n        \\n        for(auto& i : mp)\\n        {\\n            if(maxCount == i.second)\\n                res.push_back(i.first);\\n            else if(maxCount < i.second)\\n            {\\n                maxCount = i.second;\\n                res.clear();\\n                res.push_back(i.first);\\n            }\\n        }\\n        \\n        return res;\\n    }\\n    \\n    void fillMap(TreeNode* root, map<int,int>& mp)\\n    {\\n        if(root == nullptr)\\n            return;\\n        mp[root->val]++;\\n        fillMap(root->left, mp);\\n        fillMap(root->right, mp);\\n    }\\n};",
                "solutionTags": [
                    "Depth-First Search"
                ],
                "code": "class Solution {\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        \\n        if(root == nullptr)\\n            return {}",
                "codeTag": "Java"
            },
            {
                "id": 333630,
                "title": "simple-javascript-solution-with-extra-memory",
                "content": "```\\nvar findMode = function(root) {\\n  const counts = new Map();\\n  const max = walk(root, counts);\\n  const result = [];\\n  \\n  for (let [value, count] of counts) {\\n    if (count === max) {\\n      result.push(value);\\n    }\\n  }\\n  \\n  return result;\\n};\\n\\nconst walk = (root, counts) => {\\n  if (!root) {\\n    return 0;\\n  }\\n  \\n  const count = counts.has(root.val) ? counts.get(root.val) + 1 : 1;\\n  counts.set(root.val, count);\\n  \\n  return Math.max(\\n    count,\\n    walk(root.left, counts),\\n    walk(root.right, counts)\\n  );\\n}\\n```",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findMode = function(root) {\\n  const counts = new Map();\\n  const max = walk(root, counts);\\n  const result = [];\\n  \\n  for (let [value, count] of counts) {\\n    if (count === max) {\\n      result.push(value);\\n    }\\n  }\\n  \\n  return result;\\n};\\n\\nconst walk = (root, counts) => {\\n  if (!root) {\\n    return 0;\\n  }\\n  \\n  const count = counts.has(root.val) ? counts.get(root.val) + 1 : 1;\\n  counts.set(root.val, count);\\n  \\n  return Math.max(\\n    count,\\n    walk(root.left, counts),\\n    walk(root.right, counts)\\n  );\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 326284,
                "title": "c-clean-o-1-space-beats-100-time-with-comments",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    TreeNode* prev = NULL;\\n    void inorder(TreeNode* root, int &cur, int &mx, vector<int> &ans) {\\n        if(!root) return;\\n        inorder(root->left, cur, mx, ans);\\n        if(!prev) {\\n            cur = 1;\\n            mx = max(mx, cur);\\n        }\\n        else {\\n            if(root->val == prev->val) { // it is BST, consecutive elements appear together in inorder traversal\\n                cur++;\\n                if(cur > mx) { // this is the most frequent element till now\\n                    ans.clear();\\n                    mx = cur;\\n                }\\n            }\\n            else cur = 1;\\n        }\\n        if(cur == mx) ans.push_back(root->val); // its frequency has matched the highest found so far\\n        prev = root;\\n        inorder(root->right, cur, mx, ans);\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root)return ans;\\n        int cur = 0, mx = 0;\\n        inorder(root, cur, mx, ans);\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    TreeNode* prev = NULL;\\n    void inorder(TreeNode* root, int &cur, int &mx, vector<int> &ans) {\\n        if(!root) return;\\n        inorder(root->left, cur, mx, ans);\\n        if(!prev) {\\n            cur = 1;\\n            mx = max(mx, cur);\\n        }\\n        else {\\n            if(root->val == prev->val) { // it is BST, consecutive elements appear together in inorder traversal\\n                cur++;\\n                if(cur > mx) { // this is the most frequent element till now\\n                    ans.clear();\\n                    mx = cur;\\n                }\\n            }\\n            else cur = 1;\\n        }\\n        if(cur == mx) ans.push_back(root->val); // its frequency has matched the highest found so far\\n        prev = root;\\n        inorder(root->right, cur, mx, ans);\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root)return ans;\\n        int cur = 0, mx = 0;\\n        inorder(root, cur, mx, ans);\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 224580,
                "title": "my-solution-using-hashmap-and-inorder-taversal",
                "content": "/* so basically build an inorder traversal, then build hashmap from inorder traversal, keeping key as array element and value as the number of times array element appears. Then iterate the hashmap, to get the most frequently repeated element in map*/\\n``` \\npublic int[] findMode(TreeNode root) {  \\n        List<Integer> list = getInorder(root);\\n        List<Integer> newlist = new ArrayList<>();\\n        Map<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i=0;i<list.size();i++){\\n            /*if map contains the repeated element keep tract of its corresponding count*/\\n            if(map.containsKey(list.get(i))){\\n                map.put(list.get(i),map.get(list.get(i))+1);\\n            }else{\\n                map.put(list.get(i),1);\\n            }\\n        }\\n        \\n        int count=0;\\n        \\n        /*iterate the map*/\\n        for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n            if(entry.getValue()>count){\\n                count = entry.getValue();\\n                newlist.clear();\\n                newlist.add(entry.getKey());\\n            }else if(entry.getValue()==count){\\n                newlist.add(entry.getKey());\\n            }\\n        }\\n        \\n       /*Final stage Build the array from list*/\\n        int[] array = new int[newlist.size()];\\n        for(int i=0;i<newlist.size();i++){\\n            array[i] = newlist.get(i);\\n        }\\n        \\n        return array;\\n        \\n    }\\n    \\n    /*get the in-order of the tree*/\\n    \\n    public List<Integer> getInorder(TreeNode root){\\n        List<Integer> list = new ArrayList<>();\\n        if(root==null) return list;\\n        \\n        Stack<TreeNode> s = new Stack<>();\\n        \\n        while(true){\\n            if(root!=null){\\n                s.push(root);\\n                root=root.left;\\n            }else{\\n                if(s.isEmpty()) break;\\n                root = s.pop();\\n                list.add(root.val);\\n                root=root.right;\\n            }\\n        }\\n        \\n        return list;\\n    }\\n```",
                "solutionTags": [],
                "code": "``` \\npublic int[] findMode(TreeNode root) {  \\n        List<Integer> list = getInorder(root);\\n        List<Integer> newlist = new ArrayList<>();\\n        Map<Integer,Integer> map = new HashMap<>();\\n        \\n        for(int i=0;i<list.size();i++){\\n            /*if map contains the repeated element keep tract of its corresponding count*/\\n            if(map.containsKey(list.get(i))){\\n                map.put(list.get(i),map.get(list.get(i))+1);\\n            }else{\\n                map.put(list.get(i),1);\\n            }\\n        }\\n        \\n        int count=0;\\n        \\n        /*iterate the map*/\\n        for(Map.Entry<Integer,Integer> entry : map.entrySet()){\\n            if(entry.getValue()>count){\\n                count = entry.getValue();\\n                newlist.clear();\\n                newlist.add(entry.getKey());\\n            }else if(entry.getValue()==count){\\n                newlist.add(entry.getKey());\\n            }\\n        }\\n        \\n       /*Final stage Build the array from list*/\\n        int[] array = new int[newlist.size()];\\n        for(int i=0;i<newlist.size();i++){\\n            array[i] = newlist.get(i);\\n        }\\n        \\n        return array;\\n        \\n    }\\n    \\n    /*get the in-order of the tree*/\\n    \\n    public List<Integer> getInorder(TreeNode root){\\n        List<Integer> list = new ArrayList<>();\\n        if(root==null) return list;\\n        \\n        Stack<TreeNode> s = new Stack<>();\\n        \\n        while(true){\\n            if(root!=null){\\n                s.push(root);\\n                root=root.left;\\n            }else{\\n                if(s.isEmpty()) break;\\n                root = s.pop();\\n                list.add(root.val);\\n                root=root.right;\\n            }\\n        }\\n        \\n        return list;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 200875,
                "title": "most-of-the-python-solutions-posted-here-are-not-of-o-1-space-my-o-1-space-solution-beats-90",
                "content": "The algorithm is very simple. Just traverse the entire tree in in-order by remembering the in-order predecessor. Compare the next in-order node\\'s value with the predesessor and retain the frequency untill the new value differs the predecessor and keep challenging the mode each time. \\n\\nIn short I am traversing the BST in sorted order of node\\'s values and calculating the mode based on prrdesessor. Hence this problem reduces to find mode elements of a sorted array when traversed in-order.\\n\\nThe only thing with O(1) space solution is that the code gets a little lengthy. I tried my best to modularize the code. Any feedback is appreciated.\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\nclass Solution:\\n    def findMode(self, root):\\n      \"\"\"\\n      :type root: TreeNode\\n      :rtype: List[int]\\n      \"\"\"\\n      if root is None: return []\\n\\n      self.max_mode = 1\\n      self.cur_mode = 1\\n      self.max_modes = set([root.val])\\n      self.prev_node = None\\n\\n      self.find_mode_inorder(root)\\n\\n      return list(self.max_modes)\\n        \\n    def find_mode_inorder(self, root):\\n      if root is None: return\\n\\n      self.find_mode_inorder(root.left)\\n\\n      self.update_modes(root)\\n      self.prev_node = root\\n\\n      self.find_mode_inorder(root.right)\\n\\n    def update_modes(self, root):\\n      if self.prev_node is not None and self.prev_node.val == root.val:\\n        self.cur_mode += 1\\n        if self.cur_mode >= self.max_mode:\\n          if self.cur_mode > self.max_mode: self.max_modes.clear()\\n          self.max_modes.add(root.val)\\n          self.max_mode = self.cur_mode\\n      else:\\n        self.cur_mode = 1\\n        if self.max_mode == self.cur_mode: self.max_modes.add(root.val)\\n```",
                "solutionTags": [],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\nclass Solution:\\n    def findMode(self, root):\\n      \"\"\"\\n      :type root: TreeNode\\n      :rtype: List[int]\\n      \"\"\"\\n      if root is None: return []\\n\\n      self.max_mode = 1\\n      self.cur_mode = 1\\n      self.max_modes = set([root.val])\\n      self.prev_node = None\\n\\n      self.find_mode_inorder(root)\\n\\n      return list(self.max_modes)\\n        \\n    def find_mode_inorder(self, root):\\n      if root is None: return\\n\\n      self.find_mode_inorder(root.left)\\n\\n      self.update_modes(root)\\n      self.prev_node = root\\n\\n      self.find_mode_inorder(root.right)\\n\\n    def update_modes(self, root):\\n      if self.prev_node is not None and self.prev_node.val == root.val:\\n        self.cur_mode += 1\\n        if self.cur_mode >= self.max_mode:\\n          if self.cur_mode > self.max_mode: self.max_modes.clear()\\n          self.max_modes.add(root.val)\\n          self.max_mode = self.cur_mode\\n      else:\\n        self.cur_mode = 1\\n        if self.max_mode == self.cur_mode: self.max_modes.add(root.val)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 191663,
                "title": "c-extra-o-1-space",
                "content": "Method 1: using map.\\ntime: O(n)\\nspace: O(n)\\n\\nMethod 2: inorder traversal, find mode from the inorder sequence.\\ntime: O(n)\\nspace: O(1)\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    int max_count = 0;\\n    int count = 1;\\n    vector<int> findMode(TreeNode* root) {\\n        // method 1\\n        // use map to record the frequency of each number\\n        //\\n        // vector<int> res;\\n        // if (root == NULL) {\\n        //     return res;\\n        // }\\n        // map<int, int> m;\\n        // queue<TreeNode*> q;\\n        // q.push(root);\\n        // while (q.size() != 0) {\\n        //     int size = q.size();\\n        //     for (int i = 0; i < q.size(); i++) {\\n        //         TreeNode* tmp = q.front();\\n        //         q.pop();\\n        //         m[tmp->val]++;\\n        //         if (tmp->left) q.push(tmp->left);\\n        //         if (tmp->right) q.push(tmp->right);\\n        //     }\\n        // }\\n        // int count = 0;\\n        // for (auto& x : m) {\\n        //     if (x.second > count) count = x.second;\\n        // }\\n        // for (auto& x : m) {\\n        //     if (x.second == count) res.push_back(x.first);\\n        // }\\n        // return res;\\n        \\n        // method 2\\n        // inorder traversal to find the mode\\n        //\\n        if (root == NULL) {\\n            return res;\\n        }\\n        TreeNode* pre = NULL;\\n        inorder(root, pre);\\n        return res;\\n    }\\n    \\n    void inorder(TreeNode* root, TreeNode*& pre) {\\n        if (root == NULL) {\\n            return;\\n        }\\n        inorder(root->left, pre);\\n        if (pre != NULL) {\\n            if (root->val == pre->val) {\\n                count++;\\n            } else {\\n                count = 1;\\n            }\\n        }\\n        if (count >= max_count) {\\n            if (count > max_count) {\\n                res.clear();\\n            }\\n            res.push_back(root->val);\\n            max_count = count;\\n        }\\n        pre = root;\\n        inorder(root->right, pre);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> res;\\n    int max_count = 0;\\n    int count = 1;\\n    vector<int> findMode(TreeNode* root) {\\n        // method 1\\n        // use map to record the frequency of each number\\n        //\\n        // vector<int> res;\\n        // if (root == NULL) {\\n        //     return res;\\n        // }\\n        // map<int, int> m;\\n        // queue<TreeNode*> q;\\n        // q.push(root);\\n        // while (q.size() != 0) {\\n        //     int size = q.size();\\n        //     for (int i = 0; i < q.size(); i++) {\\n        //         TreeNode* tmp = q.front();\\n        //         q.pop();\\n        //         m[tmp->val]++;\\n        //         if (tmp->left) q.push(tmp->left);\\n        //         if (tmp->right) q.push(tmp->right);\\n        //     }\\n        // }\\n        // int count = 0;\\n        // for (auto& x : m) {\\n        //     if (x.second > count) count = x.second;\\n        // }\\n        // for (auto& x : m) {\\n        //     if (x.second == count) res.push_back(x.first);\\n        // }\\n        // return res;\\n        \\n        // method 2\\n        // inorder traversal to find the mode\\n        //\\n        if (root == NULL) {\\n            return res;\\n        }\\n        TreeNode* pre = NULL;\\n        inorder(root, pre);\\n        return res;\\n    }\\n    \\n    void inorder(TreeNode* root, TreeNode*& pre) {\\n        if (root == NULL) {\\n            return;\\n        }\\n        inorder(root->left, pre);\\n        if (pre != NULL) {\\n            if (root->val == pre->val) {\\n                count++;\\n            } else {\\n                count = 1;\\n            }\\n        }\\n        if (count >= max_count) {\\n            if (count > max_count) {\\n                res.clear();\\n            }\\n            res.push_back(root->val);\\n            max_count = count;\\n        }\\n        pre = root;\\n        inorder(root->right, pre);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 189003,
                "title": "java-simple-accepted-solution-using-extra-space",
                "content": "```\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    \n    Map<Integer, Integer> map = new HashMap<>();\n    public int[] findMode(TreeNode root) {\n        \n        List<Integer> res = new ArrayList<>();\n        traverse(root);\n        int maxVal = -1;\n        for (int count : map.values()){\n            if (count > maxVal)\n                maxVal = count;\n        }\n        for (Map.Entry<Integer,Integer> e : map.entrySet()){\n            if (e.getValue() == maxVal)\n                res.add(e.getKey()); \n        }\n        int[] ans = new int[res.size()];\n        for (int i=0; i<res.size(); i++)\n            ans[i] = res.get(i);\n        return ans;\n    }\n    \n    private void traverse(TreeNode t){\n        if (t == null)\n            return;\n        traverse(t.left);\n        map.put(t.val, map.getOrDefault(t.val, 0)+1);\n        traverse(t.right);\n    }\n}\n```",
                "solutionTags": [],
                "code": "```\n/**\n * Definition for a binary tree node.\n * public class TreeNode {\n *     int val;\n *     TreeNode left;\n *     TreeNode right;\n *     TreeNode(int x) { val = x; }\n * }\n */\nclass Solution {\n    \n    Map<Integer, Integer> map = new HashMap<>();\n    public int[] findMode(TreeNode root) {\n        \n        List<Integer> res = new ArrayList<>();\n        traverse(root);\n        int maxVal = -1;\n        for (int count : map.values()){\n            if (count > maxVal)\n                maxVal = count;\n        }\n        for (Map.Entry<Integer,Integer> e : map.entrySet()){\n            if (e.getValue() == maxVal)\n                res.add(e.getKey()); \n        }\n        int[] ans = new int[res.size()];\n        for (int i=0; i<res.size(); i++)\n            ans[i] = res.get(i);\n        return ans;\n    }\n    \n    private void traverse(TreeNode t){\n        if (t == null)\n            return;\n        traverse(t.left);\n        map.put(t.val, map.getOrDefault(t.val, 0)+1);\n        traverse(t.right);\n    }\n}\n```",
                "codeTag": "Java"
            },
            {
                "id": 150739,
                "title": "elegant-python-generator-and-counter",
                "content": "```py\\nfrom collections import Counter\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\ndef tree_iter(tree):\\n    if tree is not None:\\n        yield tree.val\\n        yield from tree_iter(tree.left)\\n        yield from tree_iter(tree.right)\\n\\nclass Solution:\\n    def findMode(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if root is None:\\n            return []\\n        counter = Counter(tree_iter(root))\\n        max_count = counter.most_common(1)[0][1]\\n        return [char for char, count in counter.most_common() if count == max_count]\\n            \\n```",
                "solutionTags": [],
                "code": "```py\\nfrom collections import Counter\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, x):\\n#         self.val = x\\n#         self.left = None\\n#         self.right = None\\n\\ndef tree_iter(tree):\\n    if tree is not None:\\n        yield tree.val\\n        yield from tree_iter(tree.left)\\n        yield from tree_iter(tree.right)\\n\\nclass Solution:\\n    def findMode(self, root):\\n        \"\"\"\\n        :type root: TreeNode\\n        :rtype: List[int]\\n        \"\"\"\\n        if root is None:\\n            return []\\n        counter = Counter(tree_iter(root))\\n        max_count = counter.most_common(1)[0][1]\\n        return [char for char, count in counter.most_common() if count == max_count]\\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 98098,
                "title": "a-bit-confused-how-can-you-solve-this-in-constant-space-if-you-have-to-return-an-array",
                "content": "So if the tree input was [1,-1,2,-2,0], then would you not have to return an array of size n? There is always a chance that the return value could be n, so by the virtue of the nature of the problem, the worst space case will always O(n).",
                "solutionTags": [],
                "code": "So if the tree input was [1,-1,2,-2,0], then would you not have to return an array of size n? There is always a chance that the return value could be n, so by the virtue of the nature of the problem, the worst space case will always O(n).",
                "codeTag": "Unknown"
            },
            {
                "id": 98129,
                "title": "clean-c-10-lines-dfs-o-n-time-o-n-space",
                "content": "```\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int>vec;\\n        unordered_map<int,int>m;\\n        DFS(root,m);\\n        int max=0;\\n        for(auto x:m)\\n            if(x.second>max) vec.clear(),vec.push_back(x.first),max=x.second;\\n            else if(x.second==max) vec.push_back(x.first);\\n        return vec;\\n    }\\n    \\n    void DFS(TreeNode* root, unordered_map<int,int>& m){\\n        if(!root) return;\\n        m[root->val]++,DFS(root->left,m),DFS(root->right,m);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int>vec;\\n        unordered_map<int,int>m;\\n        DFS(root,m);\\n        int max=0;\\n        for(auto x:m)\\n            if(x.second>max) vec.clear(),vec.push_back(x.first),max=x.second;\\n            else if(x.second==max) vec.push_back(x.first);\\n        return vec;\\n    }\\n    \\n    void DFS(TreeNode* root, unordered_map<int,int>& m){\\n        if(!root) return;\\n        m[root->val]++,DFS(root->left,m),DFS(root->right,m);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 98189,
                "title": "java-inorder-recursive-solution-beats-99-with-explanation",
                "content": "Idea: Duplicated numbers must be consecutive in the inorder traversal. \\n```\\n// Duplicated number of this node must be the largest in left subtree (right most) or the smallest in the right subtree (left most)\\n// Right most in left tree, visited just before this node\\n// Left most in right tree, visited just after this node */\\n    \\n    int preNode = 0;\\n    int max = 0;\\n    int currMax = 0;\\n    public int[] findMode(TreeNode root) {\\n        HashSet<Integer> set = new HashSet<>();\\n        findMode_helper(root, set);\\n        Iterator<Integer> it = set.iterator();\\n        int[] result = new int[set.size()];\\n        int i = 0;\\n        while(it.hasNext()) {\\n            result[i] = it.next();\\n            i++;\\n        }\\n        return result;\\n    }\\n    \\n    private void findMode_helper(TreeNode root, HashSet<Integer> set) {\\n        if (root == null) return;\\n        findMode_helper(root.left, set); // after visiting left subtree, preNode is the right most node in the left subtree\\n        if (preNode == root.val) {\\n            currMax++;\\n        } else {\\n            currMax = 1;\\n        }\\n        if (currMax >= max) {\\n            if (currMax > max) {\\n                set.clear();\\n            }\\n            max = currMax;\\n            set.add(root.val);\\n        }\\n        preNode = root.val; // this node will be visited just before the left most node in the right subtree\\n        findMode_helper(root.right, set);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n// Duplicated number of this node must be the largest in left subtree (right most) or the smallest in the right subtree (left most)\\n// Right most in left tree, visited just before this node\\n// Left most in right tree, visited just after this node */\\n    \\n    int preNode = 0;\\n    int max = 0;\\n    int currMax = 0;\\n    public int[] findMode(TreeNode root) {\\n        HashSet<Integer> set = new HashSet<>();\\n        findMode_helper(root, set);\\n        Iterator<Integer> it = set.iterator();\\n        int[] result = new int[set.size()];\\n        int i = 0;\\n        while(it.hasNext()) {\\n            result[i] = it.next();\\n            i++;\\n        }\\n        return result;\\n    }\\n    \\n    private void findMode_helper(TreeNode root, HashSet<Integer> set) {\\n        if (root == null) return;\\n        findMode_helper(root.left, set); // after visiting left subtree, preNode is the right most node in the left subtree\\n        if (preNode == root.val) {\\n            currMax++;\\n        } else {\\n            currMax = 1;\\n        }\\n        if (currMax >= max) {\\n            if (currMax > max) {\\n                set.clear();\\n            }\\n            max = currMax;\\n            set.add(root.val);\\n        }\\n        preNode = root.val; // this node will be visited just before the left most node in the right subtree\\n        findMode_helper(root.right, set);\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 98122,
                "title": "recursion-solution-o-1-space-if-recursion-stack-space-does-not-count",
                "content": "Maintain max frequency, current count, and pointer to previous node.\\n\\n```\\nclass Solution {\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root) return ans;\\n        \\n        int max_freq = 0, cnt = 0;\\n        TreeNode *prev = NULL;\\n        \\n        helper(root, ans, max_freq, prev, cnt);\\n        \\n        if(cnt == max_freq) ans.push_back(prev->val);\\n        \\n        return ans;\\n    }\\n    \\nprivate:\\n    void helper(TreeNode *root, vector<int> &ans, int &max_freq, TreeNode *&prev, int &cnt) {\\n        if(!root) return;\\n        \\n        helper(root->left, ans, max_freq, prev, cnt);\\n        \\n        if(prev && prev->val == root->val) {\\n            if(++cnt > max_freq) ans.clear(), max_freq = cnt;\\n        }\\n        else if(prev && prev->val != root->val) {\\n            if(cnt == max_freq) ans.push_back(prev->val);\\n            cnt = 1;\\n        }\\n        else max_freq = cnt = 1;\\n        \\n        prev = root;\\n        \\n        helper(root->right, ans, max_freq, prev, cnt);\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> ans;\\n        if(!root) return ans;\\n        \\n        int max_freq = 0, cnt = 0;\\n        TreeNode *prev = NULL;\\n        \\n        helper(root, ans, max_freq, prev, cnt);\\n        \\n        if(cnt == max_freq) ans.push_back(prev->val);\\n        \\n        return ans;\\n    }\\n    \\nprivate:\\n    void helper(TreeNode *root, vector<int> &ans, int &max_freq, TreeNode *&prev, int &cnt) {\\n        if(!root) return;\\n        \\n        helper(root->left, ans, max_freq, prev, cnt);\\n        \\n        if(prev && prev->val == root->val) {\\n            if(++cnt > max_freq) ans.clear(), max_freq = cnt;\\n        }\\n        else if(prev && prev->val != root->val) {\\n            if(cnt == max_freq) ans.push_back(prev->val);\\n            cnt = 1;\\n        }\\n        else max_freq = cnt = 1;\\n        \\n        prev = root;\\n        \\n        helper(root->right, ans, max_freq, prev, cnt);\\n    }\\n```",
                "codeTag": "Java"
            },
            {
                "id": 98205,
                "title": "clean-c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        unordered_map<int,int> counts;\\n        int max = 0;\\n        utill(root, counts, max);\\n        \\n        vector<int> modes;\\n        for(auto& y : counts){\\n            if(y.second == max) modes.push_back(y.first);\\n        }\\n        return modes;\\n    }\\n    \\n    void utill(TreeNode* r, unordered_map<int,int> &counts, int &max){\\n        if(r == nullptr) return;\\n        \\n        ++counts[r->val];\\n        max = std::max(max, counts[r->val]);\\n        utill(r->left, counts, max);\\n        utill(r->right, counts, max);\\n    }\\n    \\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        unordered_map<int,int> counts;\\n        int max = 0;\\n        utill(root, counts, max);\\n        \\n        vector<int> modes;\\n        for(auto& y : counts){\\n            if(y.second == max) modes.push_back(y.first);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3979258,
                "title": "java-best-solution-easy-to-understand",
                "content": "class Solution {\\n    public int[] findMode(TreeNode root) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int n = 0;\\n        int max = -1;\\n        helper(root, map);\\n        for(int p : map.values()){\\n            max = Math.max(max, p);\\n        }\\n        System.out.println(max);\\n\\n        for(int p : map.keySet()){\\n            if(map.get(p) == max){\\n                n++;\\n            }\\n        }\\n        int[] res = new int[n];\\n        int ind = 0;\\n        System.out.println(map);\\n        for(int p : map.keySet()){\\n            if(map.get(p) == max){\\n                res[ind++] = p;\\n            }\\n        }\\n        return res;\\n\\n    }\\n    public void helper(TreeNode root, Map<Integer, Integer> map){\\n        if(root == null){\\n            return;\\n        }\\n        map.put(root.val, map.getOrDefault(root.val, 0)+1);\\n       \\n        \\n        helper(root.right, map);\\n        helper(root.left, map);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] findMode(TreeNode root) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int n = 0;\\n        int max = -1;\\n        helper(root, map);\\n        for(int p : map.values()){\\n            max = Math.max(max, p);\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3963563,
                "title": "java-recursive-code",
                "content": "# Code\\n```\\nclass Solution {\\n    public int[] findMode(TreeNode root) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int n = 0;\\n        int max = -1;\\n        helper(root, map);\\n        for(int p : map.values()){\\n            max = Math.max(max, p);\\n        }\\n        System.out.println(max);\\n\\n        for(int p : map.keySet()){\\n            if(map.get(p) == max){\\n                n++;\\n            }\\n        }\\n        int[] res = new int[n];\\n        int ind = 0;\\n        System.out.println(map);\\n        for(int p : map.keySet()){\\n            if(map.get(p) == max){\\n                res[ind++] = p;\\n            }\\n        }\\n        return res;\\n\\n    }\\n    public void helper(TreeNode root, Map<Integer, Integer> map){\\n        if(root == null){\\n            return;\\n        }\\n        map.put(root.val, map.getOrDefault(root.val, 0)+1);\\n       \\n        \\n        helper(root.right, map);\\n        helper(root.left, map);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Hash Table"
                ],
                "code": "```\\nclass Solution {\\n    public int[] findMode(TreeNode root) {\\n        Map<Integer, Integer> map = new HashMap<>();\\n        int n = 0;\\n        int max = -1;\\n        helper(root, map);\\n        for(int p : map.values()){\\n            max = Math.max(max, p);\\n        }\\n        System.out.println(max);\\n\\n        for(int p : map.keySet()){\\n            if(map.get(p) == max){\\n                n++;\\n            }\\n        }\\n        int[] res = new int[n];\\n        int ind = 0;\\n        System.out.println(map);\\n        for(int p : map.keySet()){\\n            if(map.get(p) == max){\\n                res[ind++] = p;\\n            }\\n        }\\n        return res;\\n\\n    }\\n    public void helper(TreeNode root, Map<Integer, Integer> map){\\n        if(root == null){\\n            return;\\n        }\\n        map.put(root.val, map.getOrDefault(root.val, 0)+1);\\n       \\n        \\n        helper(root.right, map);\\n        helper(root.left, map);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3944532,
                "title": "bfs-python-3-solution",
                "content": "\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        deque = [root]\\n        d = {}\\n\\n        while deque:\\n            item = deque.pop()\\n\\n            if item.val not in d:\\n                d[item.val] = 1\\n\\n            else:\\n                d[item.val] += 1\\n\\n            if item.left:\\n                deque.append(item.left)\\n\\n            if item.right:\\n                deque.append(item.right)\\n\\n        l = sorted(d.keys(), key = lambda x: d[x])\\n        m = max(d.values())\\n        result = []\\n\\n        for i in l[::-1]:\\n            if d[i] == m:\\n                result.append(i)\\n\\n            else:\\n                break\\n\\n        return result\\n```",
                "solutionTags": [
                    "Python3",
                    "Hash Table",
                    "Breadth-First Search"
                ],
                "code": "```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        deque = [root]\\n        d = {}\\n\\n        while deque:\\n            item = deque.pop()\\n\\n            if item.val not in d:\\n                d[item.val] = 1\\n\\n            else:\\n                d[item.val] += 1\\n\\n            if item.left:\\n                deque.append(item.left)\\n\\n            if item.right:\\n                deque.append(item.right)\\n\\n        l = sorted(d.keys(), key = lambda x: d[x])\\n        m = max(d.values())\\n        result = []\\n\\n        for i in l[::-1]:\\n            if d[i] == m:\\n                result.append(i)\\n\\n            else:\\n                break\\n\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3880265,
                "title": "c-dfs-priorityqueue",
                "content": "# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int[] FindMode(TreeNode root) {\\n        \\n        var dict = new Dictionary<int, int>();\\n        void Iter(TreeNode n) {\\n            if (n is null) {\\n                return;\\n            }\\n\\n            dict[n.val] = dict.GetValueOrDefault(n.val, 0) + 1;\\n\\n            Iter(n.left);\\n            Iter(n.right);\\n        }\\n\\n        Iter(root);\\n\\n        var pq = new PriorityQueue<int, int>(Comparer<int>.Create((a,b) => b - a));\\n\\n        foreach (var kv in dict) {\\n            pq.Enqueue(kv.Key, kv.Value);\\n        }\\n\\n        var _ = pq.TryDequeue(out var element, out var count);\\n\\n        var rs = new List<int>() { element };\\n\\n        while (pq.TryDequeue(out var el, out var c)) {\\n            if (c < count) {\\n                break;\\n            }\\n            rs.Add(el);\\n        }\\n\\n        return rs.ToArray();\\n    }\\n}\\n```",
                "solutionTags": [
                    "C#"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     public int val;\\n *     public TreeNode left;\\n *     public TreeNode right;\\n *     public TreeNode(int val=0, TreeNode left=null, TreeNode right=null) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\npublic class Solution {\\n    public int[] FindMode(TreeNode root) {\\n        \\n        var dict = new Dictionary<int, int>();\\n        void Iter(TreeNode n) {\\n            if (n is null) {\\n                return;\\n            }\\n\\n            dict[n.val] = dict.GetValueOrDefault(n.val, 0) + 1;\\n\\n            Iter(n.left);\\n            Iter(n.right);\\n        }\\n\\n        Iter(root);\\n\\n        var pq = new PriorityQueue<int, int>(Comparer<int>.Create((a,b) => b - a));\\n\\n        foreach (var kv in dict) {\\n            pq.Enqueue(kv.Key, kv.Value);\\n        }\\n\\n        var _ = pq.TryDequeue(out var element, out var count);\\n\\n        var rs = new List<int>() { element };\\n\\n        while (pq.TryDequeue(out var el, out var c)) {\\n            if (c < count) {\\n                break;\\n            }\\n            rs.Add(el);\\n        }\\n\\n        return rs.ToArray();\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3852222,
                "title": "java-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    int maxcount=1;\\n    public int[] findMode(TreeNode root) {\\n        HashMap<Integer , Integer> map=new HashMap<>();\\n        FindMode(root , map);\\n        ArrayList<Integer> list=new ArrayList<>();\\n        \\n        \\n        \\n        for(Integer key : map.keySet()){\\n            if(map.get(key)==maxcount){\\n                list.add(key);\\n            }\\n        }\\n        \\n        int ans[]=new int[list.size()];\\n        for (int j = 0; j < list.size(); j++) {\\n            ans[j] = list.get(j);\\n        }\\n        return ans;\\n        \\n\\n    }\\n    public void FindMode(TreeNode root , HashMap<Integer , Integer>map){\\n        if(root==null){\\n            return;\\n        }else if(map.containsKey(root.val)){\\n            int count=map.get(root.val)+1;\\n            map.put(root.val , count);\\n            maxcount=Math.max(count , maxcount);\\n\\n        }else{\\n            map.put(root.val ,1);\\n        }\\n        FindMode(root.left , map);\\n        FindMode(root.right , map);\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass Solution {\\n    int maxcount=1;\\n    public int[] findMode(TreeNode root) {\\n        HashMap<Integer , Integer> map=new HashMap<>();\\n        FindMode(root , map);\\n        ArrayList<Integer> list=new ArrayList<>();\\n        \\n        \\n        \\n        for(Integer key : map.keySet()){\\n            if(map.get(key)==maxcount){\\n                list.add(key);\\n            }\\n        }\\n        \\n        int ans[]=new int[list.size()];\\n        for (int j = 0; j < list.size(); j++) {\\n            ans[j] = list.get(j);\\n        }\\n        return ans;\\n        \\n\\n    }\\n    public void FindMode(TreeNode root , HashMap<Integer , Integer>map){\\n        if(root==null){\\n            return;\\n        }else if(map.containsKey(root.val)){\\n            int count=map.get(root.val)+1;\\n            map.put(root.val , count);\\n            maxcount=Math.max(count , maxcount);\\n\\n        }else{\\n            map.put(root.val ,1);\\n        }\\n        FindMode(root.left , map);\\n        FindMode(root.right , map);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3660581,
                "title": "o-1-space-c-solution-short-easy-implementation",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity: O(N)\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: O(1)\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    int prev = -1, freq = 1, mx = 1;\\n    void dfs(TreeNode* node){\\n        if(!node) return;\\n        dfs(node->left);\\n\\n        if(node->val == prev) freq++;\\n        else{\\n            if(freq >= mx){\\n                if(freq > mx) ans.clear();\\n                ans.push_back(prev);\\n                mx = freq;\\n            }\\n            freq = 1;\\n            prev = node->val;\\n        }\\n        \\n        dfs(node->right);\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        dfs(root);\\n        if(freq >= mx){\\n            if(freq > mx) ans.clear();\\n            ans.push_back(prev);\\n        }\\n        if(ans[0] == -1) ans.erase(ans.begin() + 0);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int>ans;\\n    int prev = -1, freq = 1, mx = 1;\\n    void dfs(TreeNode* node){\\n        if(!node) return;\\n        dfs(node->left);\\n\\n        if(node->val == prev) freq++;\\n        else{\\n            if(freq >= mx){\\n                if(freq > mx) ans.clear();\\n                ans.push_back(prev);\\n                mx = freq;\\n            }\\n            freq = 1;\\n            prev = node->val;\\n        }\\n        \\n        dfs(node->right);\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        dfs(root);\\n        if(freq >= mx){\\n            if(freq > mx) ans.clear();\\n            ans.push_back(prev);\\n        }\\n        if(ans[0] == -1) ans.erase(ans.begin() + 0);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3291785,
                "title": "simple-c-traversal-map-solution",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nUsing map to keep track of the frequencies of elements while traversing the BST.\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nTraverse through the BST using any traversal method and increase the frequency of each element in the map without pushing them into a vector which takes extra space of o(n).\\n# Complexity\\n- Time complexity:    **O(n)** for traversing the BST.\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n\\n- Space complexity:   **O(n)** for the map.\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void inorder(TreeNode* root,unordered_map<int,int>&mp)\\n    {\\n        if(!root)return ;\\n        inorder(root->left,mp);\\n        mp[root->val]++;\\n        inorder(root->right,mp);\\n    }\\n    \\n    vector<int> findMode(TreeNode* root) {\\n        unordered_map<int,int>mp;\\n        inorder(root,mp);\\n        vector<int>v;\\n        int ans=INT_MIN;\\n        for(auto it=mp.begin();it!=mp.end();++it)\\n        {\\n            //if an element appears more times than previous answer\\n            //we replace the previous answer with current element\\\\\\n            //beacuse it appears more times\\n            if(it->second > ans)\\n            {\\n                ans=it->second;v={it->first};\\n            }\\n            //if an element appears same times as the previous answer\\n            //we pushback because this element appears same times \\n            //as previous element\\n            else if(it->second == ans)\\n            {     \\n                v.push_back(it->first);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Depth-First Search"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n\\n    void inorder(TreeNode* root,unordered_map<int,int>&mp)\\n    {\\n        if(!root)return ;\\n        inorder(root->left,mp);\\n        mp[root->val]++;\\n        inorder(root->right,mp);\\n    }\\n    \\n    vector<int> findMode(TreeNode* root) {\\n        unordered_map<int,int>mp;\\n        inorder(root,mp);\\n        vector<int>v;\\n        int ans=INT_MIN;\\n        for(auto it=mp.begin();it!=mp.end();++it)\\n        {\\n            //if an element appears more times than previous answer\\n            //we replace the previous answer with current element\\\\\\n            //beacuse it appears more times\\n            if(it->second > ans)\\n            {\\n                ans=it->second;v={it->first};\\n            }\\n            //if an element appears same times as the previous answer\\n            //we pushback because this element appears same times \\n            //as previous element\\n            else if(it->second == ans)\\n            {     \\n                v.push_back(it->first);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3209169,
                "title": "c-hash-table-easy-approach",
                "content": "Here is my c++ code for this proble.\\n\\n# Complexity\\n- Time complexity:$$O(n)$$\\n\\n- Space complexity:$$O(n)$$\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int>v;\\n        if(!root){return v;}\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            root=q.front();\\n            q.pop();\\n            v.push_back(root->val);\\n            if(root->left){q.push(root->left);}\\n            if(root->right){q.push(root->right);}\\n        }\\n        map<int, int>m;\\n        for(int i=0; i<v.size(); i++){m[v[i]]++;}\\n        vector<pair<int, int>>v1;\\n        vector<int>ans;\\n        for(auto it: m){\\n            v1.push_back({it.second, it.first});\\n        }\\n        sort(v1.begin(), v1.end());\\n        reverse(v1.begin(), v1.end());\\n        //if(ans.empty()){return v;}\\n        int l=v1[0].first;\\n        for(int i=0; i<v1.size(); i++){\\n            if(l==v1[i].first){\\n                ans.push_back(v1[i].second);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Tree",
                    "Binary Search Tree",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int>v;\\n        if(!root){return v;}\\n        queue<TreeNode*>q;\\n        q.push(root);\\n        while(!q.empty()){\\n            root=q.front();\\n            q.pop();\\n            v.push_back(root->val);\\n            if(root->left){q.push(root->left);}\\n            if(root->right){q.push(root->right);}\\n        }\\n        map<int, int>m;\\n        for(int i=0; i<v.size(); i++){m[v[i]]++;}\\n        vector<pair<int, int>>v1;\\n        vector<int>ans;\\n        for(auto it: m){\\n            v1.push_back({it.second, it.first});\\n        }\\n        sort(v1.begin(), v1.end());\\n        reverse(v1.begin(), v1.end());\\n        //if(ans.empty()){return v;}\\n        int l=v1[0].first;\\n        for(int i=0; i<v1.size(); i++){\\n            if(l==v1[i].first){\\n                ans.push_back(v1[i].second);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3098209,
                "title": "simple-inorder-solution-self-explanatory-code",
                "content": "//Please Upvote if you like the approach \\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   void inorder(TreeNode* root,vector<int>&result){\\n       if(root==NULL){\\n           return;\\n       }\\n       inorder(root->left,result);\\n       result.push_back(root->val);\\n       inorder(root->right,result);\\n   }\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int>result;\\n        inorder(root,result);\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<result.size();i++){\\n            mp[result[i]]++;\\n        }\\n        int mx=-1;\\n        int final=0;\\n        vector<int>ans;\\n        for(auto ele:mp){\\n             if(ele.second>=mx){\\n                 mx=ele.second;\\n                 final=ele.first;\\n             }\\n        }\\n        ans.push_back(final);\\n        for(auto ele:mp){\\n            if(ele.second==mx and ele.first!=final){\\n                ans.push_back(ele.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   void inorder(TreeNode* root,vector<int>&result){\\n       if(root==NULL){\\n           return;\\n       }\\n       inorder(root->left,result);\\n       result.push_back(root->val);\\n       inorder(root->right,result);\\n   }\\n    vector<int> findMode(TreeNode* root) {\\n        vector<int>result;\\n        inorder(root,result);\\n        unordered_map<int,int>mp;\\n        for(int i=0;i<result.size();i++){\\n            mp[result[i]]++;\\n        }\\n        int mx=-1;\\n        int final=0;\\n        vector<int>ans;\\n        for(auto ele:mp){\\n             if(ele.second>=mx){\\n                 mx=ele.second;\\n                 final=ele.first;\\n             }\\n        }\\n        ans.push_back(final);\\n        for(auto ele:mp){\\n            if(ele.second==mx and ele.first!=final){\\n                ans.push_back(ele.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3078436,
                "title": "easy-solution-with-explanation-using-map-recursive",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    int Max=0;\\n    unordered_map<int,int>mp;  // to store frquency of element \\n    void solve(TreeNode* root){\\n        \\n         if(root==NULL){\\n             return ;\\n         }\\n        \\n         mp[root->val]++;\\n        Max=max(Max,mp[root->val]);  // finding Max repeating number\\n         solve(root->left);\\n         solve(root->right);\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        \\n       \\n        \\n         solve(root);\\n        vector<int>v;\\n        for(auto i:mp){\\n            \\n        if(i.second==Max){  //if frequency of number equal to Max then push in vector\\n                v.push_back(i.first);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    \\n    int Max=0;\\n    unordered_map<int,int>mp;  // to store frquency of element \\n    void solve(TreeNode* root){\\n        \\n         if(root==NULL){\\n             return ;\\n         }\\n        \\n         mp[root->val]++;\\n        Max=max(Max,mp[root->val]);  // finding Max repeating number\\n         solve(root->left);\\n         solve(root->right);\\n    }\\n    vector<int> findMode(TreeNode* root) {\\n        \\n       \\n        \\n         solve(root);\\n        vector<int>v;\\n        for(auto i:mp){\\n            \\n        if(i.second==Max){  //if frequency of number equal to Max then push in vector\\n                v.push_back(i.first);\\n            }\\n        }\\n        return v;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3004189,
                "title": "java-solution-code-explanation",
                "content": "```\\nclass Solution {\\n    public int[] findMode(TreeNode root) {\\n       /*  Doing the inorder traversal of the binary search tree and \\n       then find the highest frequenecy elements.*/\\n        List<Integer> list=new ArrayList<>();\\n        helper(list,root);\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int x:list)\\n        {\\n            map.put(x,map.getOrDefault(x,0)+1);\\n        }\\n        int max=maximum(map);\\n       // List to store the elements with maximum frequency.\\n       List<Integer> res=new ArrayList<>();\\n        for(int key:map.keySet())\\n         if(max==map.get(key))\\n             res.add(key);\\n       \\n        // Storing the mode elemnts from the list in the array.\\n       int[] ans=new int[res.size()];\\n        int index=0;\\n        for(int i:res)\\n            ans[index++]=i;\\n        \\n        return ans;     \\n    }\\n    \\n    // Function to store the inorder traversal of BST in the list\\n    public void helper(List<Integer> list, TreeNode root)\\n    {\\n        if(root==null)\\n             return;\\n        helper(list,root.left);\\n        list.add(root.val);\\n        helper(list,root.right);\\n    }\\n    \\n    // Function to find the maximum frequency in the hashmap\\n    public int maximum(HashMap<Integer,Integer> map)\\n    {\\n        int maxFrequency=0;\\n         for(int x:map.keySet())\\n            maxFrequency=Math.max(maxFrequency,map.get(x));\\n         return maxFrequency;       \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int[] findMode(TreeNode root) {\\n       /*  Doing the inorder traversal of the binary search tree and \\n       then find the highest frequenecy elements.*/\\n        List<Integer> list=new ArrayList<>();\\n        helper(list,root);\\n        HashMap<Integer,Integer> map=new HashMap<>();\\n        for(int x:list)\\n        {\\n            map.put(x,map.getOrDefault(x,0)+1);\\n        }\\n        int max=maximum(map);\\n       // List to store the elements with maximum frequency.\\n       List<Integer> res=new ArrayList<>();\\n        for(int key:map.keySet())\\n         if(max==map.get(key))\\n             res.add(key);\\n       \\n        // Storing the mode elemnts from the list in the array.\\n       int[] ans=new int[res.size()];\\n        int index=0;\\n        for(int i:res)\\n            ans[index++]=i;\\n        \\n        return ans;     \\n    }\\n    \\n    // Function to store the inorder traversal of BST in the list\\n    public void helper(List<Integer> list, TreeNode root)\\n    {\\n        if(root==null)\\n             return;\\n        helper(list,root.left);\\n        list.add(root.val);\\n        helper(list,root.right);\\n    }\\n    \\n    // Function to find the maximum frequency in the hashmap\\n    public int maximum(HashMap<Integer,Integer> map)\\n    {\\n        int maxFrequency=0;\\n         for(int x:map.keySet())\\n            maxFrequency=Math.max(maxFrequency,map.get(x));\\n         return maxFrequency;       \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2716265,
                "title": "c-easy-short",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   vector<int>result;\\n    int maxFreq=0,current=0,freq=0;\\n    \\n    vector<int> findMode(TreeNode* root) {\\n    \\n       if(!root)\\n            return result;\\n    \\n       findMode(root->left);\\n    \\n       if(current!=root->val)\\n       {\\n           freq=1;\\n           current=root->val;\\n       }\\n\\n       else if(current==root->val)\\n       {\\n         freq++;   \\n       }\\n       if(freq>maxFreq)\\n       {\\n           maxFreq=freq;\\n           result={current};\\n           \\n       }\\n        else if(freq==maxFreq)\\n        {\\n            result.push_back(current);\\n        }\\n        \\n       findMode(root->right);\\n        \\n         return result;\\n    }\\n   \\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\npublic:\\n   vector<int>result;\\n    int maxFreq=0,current=0,freq=0;\\n    \\n    vector<int> findMode(TreeNode* root) {\\n    \\n       if(!root)\\n            return result;\\n    \\n       findMode(root->left);\\n    \\n       if(current!=root->val)\\n       {\\n           freq=1;\\n           current=root->val;\\n       }\\n\\n       else if(current==root->val)\\n       {\\n         freq++;   \\n       }\\n       if(freq>maxFreq)\\n       {\\n           maxFreq=freq;\\n           result={current};\\n           \\n       }\\n        else if(freq==maxFreq)\\n        {\\n            result.push_back(current);\\n        }\\n        \\n       findMode(root->right);\\n        \\n         return result;\\n    }\\n   \\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2707495,
                "title": "straightforward-inorder-traversal-solution-beats-98",
                "content": "```\\nvar findMode = function(root) {\\n    let last = -1\\n    let count = 0\\n    let max = 0\\n    let res = []\\n    \\n    search(root)\\n    return res\\n    \\n    function search(node){\\n        if(!node) return\\n        \\n        search(node.left)\\n        \\n        if(node.val !== last){\\n            last = node.val\\n            count = 1\\n            if(count>max) res.push(node.val)\\n        } else {\\n            count++\\n            if(count=== max) res.push(node.val)\\n            else if(count>max){\\n                max = count\\n                res = [node.val]\\n            }\\n        }\\n        \\n        search(node.right)\\n    }\\n};\\n```\\n![image](https://assets.leetcode.com/users/images/8c0f0339-e24b-4186-8bea-621aa9efe56a_1665867308.8240676.png)\\n",
                "solutionTags": [
                    "JavaScript"
                ],
                "code": "```\\nvar findMode = function(root) {\\n    let last = -1\\n    let count = 0\\n    let max = 0\\n    let res = []\\n    \\n    search(root)\\n    return res\\n    \\n    function search(node){\\n        if(!node) return\\n        \\n        search(node.left)\\n        \\n        if(node.val !== last){\\n            last = node.val\\n            count = 1\\n            if(count>max) res.push(node.val)\\n        } else {\\n            count++\\n            if(count=== max) res.push(node.val)\\n            else if(count>max){\\n                max = count\\n                res = [node.val]\\n            }\\n        }\\n        \\n        search(node.right)\\n    }\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2704469,
                "title": "mode-in-binary-search-tree-depth-first-search-recursion-c",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\n\\n# Complexity\\n- Time complexity:\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity:\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    private:\\n    void finding(TreeNode* root,unordered_map<int,int>&mp){\\n        if(root==NULL){\\n            return ;\\n        }\\n        mp[root->val]++;\\n        finding(root->left,mp);\\n        finding(root->right,mp);\\n    }\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        unordered_map<int,int>mp;\\n        finding(root,mp);\\n        int maxvalue=INT_MIN;\\n        vector<int>ans;\\n        for(auto i:mp){\\n            if(maxvalue<i.second){\\n                maxvalue=i.second;\\n            }\\n        }\\n        for(auto i:mp){\\n            if(i.second==maxvalue){\\n                ans.push_back(i.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "C++",
                    "Binary Search Tree",
                    "Recursion",
                    "Binary Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * struct TreeNode {\\n *     int val;\\n *     TreeNode *left;\\n *     TreeNode *right;\\n *     TreeNode() : val(0), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x) : val(x), left(nullptr), right(nullptr) {}\\n *     TreeNode(int x, TreeNode *left, TreeNode *right) : val(x), left(left), right(right) {}\\n * };\\n */\\nclass Solution {\\n    private:\\n    void finding(TreeNode* root,unordered_map<int,int>&mp){\\n        if(root==NULL){\\n            return ;\\n        }\\n        mp[root->val]++;\\n        finding(root->left,mp);\\n        finding(root->right,mp);\\n    }\\npublic:\\n    vector<int> findMode(TreeNode* root) {\\n        unordered_map<int,int>mp;\\n        finding(root,mp);\\n        int maxvalue=INT_MIN;\\n        vector<int>ans;\\n        for(auto i:mp){\\n            if(maxvalue<i.second){\\n                maxvalue=i.second;\\n            }\\n        }\\n        for(auto i:mp){\\n            if(i.second==maxvalue){\\n                ans.push_back(i.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2638555,
                "title": "c-easy-inorder-map",
                "content": "\\n\\tclass Solution {\\n\\tpublic:\\n    vector<int> tree;\\n    void inorder(TreeNode* root){\\n        if(!root)\\n            return;\\n        inorder(root->left);\\n        tree.push_back(root->val);\\n        inorder(root->right);\\n    }\\n    \\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> bstmode;\\n        inorder(root);\\n        unordered_map<int,int> m;\\n        int max=0;\\n        int mode=0;\\n        \\n        for(auto i:tree){\\n            m[i]++;\\n        }\\n        \\n        for(auto i:m){\\n            if(i.second>max)\\n                max=i.second;\\n        }\\n        \\n        for(auto j:m){\\n            if(j.second==max)\\n                bstmode.push_back(j.first);\\n        }\\n        return bstmode;     \\n    }\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n    vector<int> tree;\\n    void inorder(TreeNode* root){\\n        if(!root)\\n            return;\\n        inorder(root->left);\\n        tree.push_back(root->val);\\n        inorder(root->right);\\n    }",
                "codeTag": "Java"
            },
            {
                "id": 2610220,
                "title": "java-solution-with-morris-law-time-complexity-o-n-space-complexity-o-1",
                "content": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass Pair {\\n    int element;\\n    int count;\\n    \\n    public Pair(int element, int count) {\\n        this.element = element;\\n        this.count = count;\\n    }\\n}\\n\\n\\nclass Solution {\\n    public int[] findMode(TreeNode root) {\\n        \\n        TreeNode current = root;\\n        \\n        //initally the element is INT MIN_VALUE\\n        // and maxCount is 0;\\n        int element = Integer.MIN_VALUE;\\n        int maxCount = 0;\\n        \\n        //to store the element with count\\n        List<Pair> result = new ArrayList<>();\\n        \\n        //to identify for the first time we get some node value\\n        // and also for the second time we get again some node value\\n        int noOfTime = 0;\\n        \\n        \\n        // morris inorder traverse algorithm\\n        while(current != null) {\\n            //if current left is not null then normally we print the node value \\n            //move the current node to the right side\\n            // but here we will not print the node value instead we will checking the max frequency element\\n            if(current.left == null) {\\n                \\n                // as soon as I got my node value is greater than the previuos element\\n                if(current.val > element) {\\n                    //for the first time\\n                    // we just need to update the element and maxCount as 1\\n                    // and increment the noOfTime to represent that we got already the first node\\n                    if(noOfTime == 0) {\\n                        element = current.val;\\n                        maxCount = 1;\\n                        noOfTime++;\\n                    } \\n                    // for the second time, when we will get another node value which is greater than the previous one\\n                    // we need to add the record of the previous one to result\\n                    // and we need to reset the element and maxCount\\n                    // and also need to increase the onOfTime as to represnt for the seond time also we got\\n                    // some bigger node value\\n                    else if(noOfTime == 1) {\\n                        result.add(new Pair(element, maxCount));\\n                        element = current.val;\\n                        maxCount = 1;\\n                        noOfTime++;\\n                    } \\n                    \\n                    // if noOfTime is not 0 or 1 that means\\n                    // in out list we have already some record present\\n                    //and also right now we got some bigger value\\n                    // so we need to check with current element and count with the records stored in the list\\n                    // and after that we need to reset the element and maxCount\\n                    else {\\n                        \\n                        // if current maxCount is greater than the count stored in the list\\n                        // that means we have found more frequency element\\n                        // so need to clear the list and add the current record in the list\\n                        if(maxCount > result.get(result.size() - 1).count) {\\n                            result.clear();\\n                            result.add(new Pair(element, maxCount));\\n                            \\n                        } \\n                        \\n                        // if maxCount is equal to existing count present in the list\\n                        // then just add the new record also\\n                        else if(maxCount == result.get(result.size() - 1).count) {\\n                            result.add(new Pair(element, maxCount));\\n                        }\\n                        \\n                        //reset the element and maxCount\\n                        element = current.val;\\n                        maxCount = 1;\\n                    }\\n                    \\n                    \\n                    \\n                }\\n                \\n                // if the current node is equal to the previous element\\n                // then just increase the maxCount\\n                \\n                else if(current.val == element) {\\n                    maxCount++;\\n                }\\n                \\n                // once we are done with checking part\\n                // we can go the right side\\n                current = current.right;\\n            } \\n            \\n            else {\\n                TreeNode temp = current.left;\\n                //go to most right node\\n                while(temp.right != null && temp.right != current) {\\n                    temp = temp.right;\\n                }\\n                \\n                \\n                //if no chain is present\\n                //make the chain\\n                // go to the left side\\n                if(temp.right == null) {\\n                    temp.right = current;\\n                    current = current.left;\\n                } \\n                \\n                // if already the chain is present\\n                // break the chain\\n                // check the frequency\\n                // go to right\\n                else {\\n                    temp.right = null;\\n                    // as soon as I got my node value is greater than the previuos element\\n                    if(current.val > element) {\\n                        //for the first time\\n                        // we just need to update the element and maxCount as 1\\n                        // and increment the noOfTime to represent that we got already the first node\\n                        if(noOfTime == 0) {\\n                            element = current.val;\\n                            maxCount = 1;\\n                            noOfTime++;\\n                        } \\n                        // for the second time, when we will get another node value which is greater than the previous one\\n                        // we need to add the record of the previous one to result\\n                        // and we need to reset the element and maxCount\\n                        // and also need to increase the onOfTime as to represnt for the seond time also we got\\n                        // some bigger node value\\n                        else if(noOfTime == 1) {\\n                            result.add(new Pair(element, maxCount));\\n                            element = current.val;\\n                            maxCount = 1;\\n                            noOfTime++;\\n                        } \\n\\n                        // if noOfTime is not 0 or 1 that means\\n                        // in out list we have already some record present\\n                        //and also right now we got some bigger value\\n                        // so we need to check with current element and count with the records stored in the list\\n                        // and after that we need to reset the element and maxCount\\n                        else {\\n\\n                                // if current maxCount is greater than the count stored in the list\\n                                // that means we have found more frequency element\\n                                // so need to clear the list and add the current record in the list\\n                                if(maxCount > result.get(result.size() - 1).count) {\\n                                    result.clear();\\n                                    result.add(new Pair(element, maxCount));\\n\\n                                } \\n\\n                                // if maxCount is equal to existing count present in the list\\n                                // then just add the new record also\\n                                else if(maxCount == result.get(result.size() - 1).count) {\\n                                    result.add(new Pair(element, maxCount));\\n                                }\\n\\n                            //reset the element and maxCount\\n                            element = current.val;\\n                            maxCount = 1;\\n                            }\\n                    }\\n\\n                    // if the current node is equal to the previous element\\n                    // then just increase the maxCount\\n                    else if(current.val == element) {\\n                        maxCount++;\\n                    }\\n                current = current.right;\\n                }\\n            }\\n        }// end of main while loop\\n        \\n        \\n        // it could be that \\n        // tree is having only one node or multiple node with same value\\n        // like 1 or 1 1 1 (inorder traversal)\\n        if(noOfTime == 1) {\\n            int[] output = new int[] {element};\\n            return output;\\n        }\\n        \\n        // this portion is for last different element\\n        // like: 0 2 2 4 6 6 7 8 9(inorder traversal)\\n        // this portion is for 9\\n        // element will be the last element which is in this example is 9\\n        // maxCount will be the frequency of the last element\\n        // which is 1 in this example\\n        \\n        // if maxCount is greater than the existing record count\\n        // the clear all the records and add this new one record\\n        if(maxCount > result.get(result.size() - 1).count) {\\n            result.clear();\\n            result.add(new Pair(element, maxCount));\\n        } \\n        \\n        // if maxCount is equal to the existing record then\\n        // just add the new record with the existing\\n        else if(maxCount == result.get(result.size() - 1).count) {\\n                result.add(new Pair(element, maxCount));                \\n        }\\n        \\n        \\n        // just to return we need to create array\\n        int[] output = new int[result.size()];\\n                \\n        for(int i = 0; i < result.size(); i++) {\\n            output[i] = result.get(i).element;\\n        }\\n        \\n        \\n        return output;\\n        \\n    }\\n}\\n```",
                "solutionTags": [
                    "Tree",
                    "Binary Search Tree"
                ],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\n\\nclass Pair {\\n    int element;\\n    int count;\\n    \\n    public Pair(int element, int count) {\\n        this.element = element;\\n        this.count = count;\\n    }\\n}\\n\\n\\nclass Solution {\\n    public int[] findMode(TreeNode root) {\\n        \\n        TreeNode current = root;\\n        \\n        //initally the element is INT MIN_VALUE\\n        // and maxCount is 0;\\n        int element = Integer.MIN_VALUE;\\n        int maxCount = 0;\\n        \\n        //to store the element with count\\n        List<Pair> result = new ArrayList<>();\\n        \\n        //to identify for the first time we get some node value\\n        // and also for the second time we get again some node value\\n        int noOfTime = 0;\\n        \\n        \\n        // morris inorder traverse algorithm\\n        while(current != null) {\\n            //if current left is not null then normally we print the node value \\n            //move the current node to the right side\\n            // but here we will not print the node value instead we will checking the max frequency element\\n            if(current.left == null) {\\n                \\n                // as soon as I got my node value is greater than the previuos element\\n                if(current.val > element) {\\n                    //for the first time\\n                    // we just need to update the element and maxCount as 1\\n                    // and increment the noOfTime to represent that we got already the first node\\n                    if(noOfTime == 0) {\\n                        element = current.val;\\n                        maxCount = 1;\\n                        noOfTime++;\\n                    } \\n                    // for the second time, when we will get another node value which is greater than the previous one\\n                    // we need to add the record of the previous one to result\\n                    // and we need to reset the element and maxCount\\n                    // and also need to increase the onOfTime as to represnt for the seond time also we got\\n                    // some bigger node value\\n                    else if(noOfTime == 1) {\\n                        result.add(new Pair(element, maxCount));\\n                        element = current.val;\\n                        maxCount = 1;\\n                        noOfTime++;\\n                    } \\n                    \\n                    // if noOfTime is not 0 or 1 that means\\n                    // in out list we have already some record present\\n                    //and also right now we got some bigger value\\n                    // so we need to check with current element and count with the records stored in the list\\n                    // and after that we need to reset the element and maxCount\\n                    else {\\n                        \\n                        // if current maxCount is greater than the count stored in the list\\n                        // that means we have found more frequency element\\n                        // so need to clear the list and add the current record in the list\\n                        if(maxCount > result.get(result.size() - 1).count) {\\n                            result.clear();\\n                            result.add(new Pair(element, maxCount));\\n                            \\n                        } \\n                        \\n                        // if maxCount is equal to existing count present in the list\\n                        // then just add the new record also\\n                        else if(maxCount == result.get(result.size() - 1).count) {\\n                            result.add(new Pair(element, maxCount));\\n                        }\\n                        \\n                        //reset the element and maxCount\\n                        element = current.val;\\n                        maxCount = 1;\\n                    }\\n                    \\n                    \\n                    \\n                }\\n                \\n                // if the current node is equal to the previous element\\n                // then just increase the maxCount\\n                \\n                else if(current.val == element) {\\n                    maxCount++;\\n                }\\n                \\n                // once we are done with checking part\\n                // we can go the right side\\n                current = current.right;\\n            } \\n            \\n            else {\\n                TreeNode temp = current.left;\\n                //go to most right node\\n                while(temp.right != null && temp.right != current) {\\n                    temp = temp.right;\\n                }\\n                \\n                \\n                //if no chain is present\\n                //make the chain\\n                // go to the left side\\n                if(temp.right == null) {\\n                    temp.right = current;\\n                    current = current.left;\\n                } \\n                \\n                // if already the chain is present\\n                // break the chain\\n                // check the frequency\\n                // go to right\\n                else {\\n                    temp.right = null;\\n                    // as soon as I got my node value is greater than the previuos element\\n                    if(current.val > element) {\\n                        //for the first time\\n                        // we just need to update the element and maxCount as 1\\n                        // and increment the noOfTime to represent that we got already the first node\\n                        if(noOfTime == 0) {\\n                            element = current.val;\\n                            maxCount = 1;\\n                            noOfTime++;\\n                        } \\n                        // for the second time, when we will get another node value which is greater than the previous one\\n                        // we need to add the record of the previous one to result\\n                        // and we need to reset the element and maxCount\\n                        // and also need to increase the onOfTime as to represnt for the seond time also we got\\n                        // some bigger node value\\n                        else if(noOfTime == 1) {\\n                            result.add(new Pair(element, maxCount));\\n                            element = current.val;\\n                            maxCount = 1;\\n                            noOfTime++;\\n                        } \\n\\n                        // if noOfTime is not 0 or 1 that means\\n                        // in out list we have already some record present\\n                        //and also right now we got some bigger value\\n                        // so we need to check with current element and count with the records stored in the list\\n                        // and after that we need to reset the element and maxCount\\n                        else {\\n\\n                                // if current maxCount is greater than the count stored in the list\\n                                // that means we have found more frequency element\\n                                // so need to clear the list and add the current record in the list\\n                                if(maxCount > result.get(result.size() - 1).count) {\\n                                    result.clear();\\n                                    result.add(new Pair(element, maxCount));\\n\\n                                } \\n\\n                                // if maxCount is equal to existing count present in the list\\n                                // then just add the new record also\\n                                else if(maxCount == result.get(result.size() - 1).count) {\\n                                    result.add(new Pair(element, maxCount));\\n                                }\\n\\n                            //reset the element and maxCount\\n                            element = current.val;\\n                            maxCount = 1;\\n                            }\\n                    }\\n\\n                    // if the current node is equal to the previous element\\n                    // then just increase the maxCount\\n                    else if(current.val == element) {\\n                        maxCount++;\\n                    }\\n                current = current.right;\\n                }\\n            }\\n        }// end of main while loop\\n        \\n        \\n        // it could be that \\n        // tree is having only one node or multiple node with same value\\n        // like 1 or 1 1 1 (inorder traversal)\\n        if(noOfTime == 1) {\\n            int[] output = new int[] {element};\\n            return output;\\n        }\\n        \\n        // this portion is for last different element\\n        // like: 0 2 2 4 6 6 7 8 9(inorder traversal)\\n        // this portion is for 9\\n        // element will be the last element which is in this example is 9\\n        // maxCount will be the frequency of the last element\\n        // which is 1 in this example\\n        \\n        // if maxCount is greater than the existing record count\\n        // the clear all the records and add this new one record\\n        if(maxCount > result.get(result.size() - 1).count) {\\n            result.clear();\\n            result.add(new Pair(element, maxCount));\\n        } \\n        \\n        // if maxCount is equal to the existing record then\\n        // just add the new record with the existing\\n        else if(maxCount == result.get(result.size() - 1).count) {\\n                result.add(new Pair(element, maxCount));                \\n        }\\n        \\n        \\n        // just to return we need to create array\\n        int[] output = new int[result.size()];\\n                \\n        for(int i = 0; i < result.size(); i++) {\\n            output[i] = result.get(i).element;\\n        }\\n        \\n        \\n        return output;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2549239,
                "title": "java-sc-o-1-and-hashmap-sc-o-n",
                "content": "SC O(1)\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int count = 0;\\n    int maxCount = 0;\\n    List<Integer> list = new ArrayList();\\n    TreeNode prev;\\n    public int[] findMode(TreeNode root) {\\n        prev = root;\\n        inorder(root);\\n        int[] result = new int[list.size()];\\n        int i = 0;\\n        for(int n: list)\\n            result[i++]=n;\\n        return result;\\n    }\\n    private void inorder(TreeNode node){\\n        if (node == null)\\n            return;\\n        inorder(node.left);\\n        if (prev.val == node.val)\\n            count++;\\n        else\\n            count = 1;\\n        if (count > maxCount){\\n            list.clear();\\n            list.add(node.val);\\n            maxCount = count;\\n        }else if (count == maxCount)\\n            list.add(node.val);\\n        prev = node;\\n        inorder(node.right);\\n    }\\n}\\n```\\nHashMap SC O(n)\\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap();\\n    public int[] findMode(TreeNode root) {\\n        countElement(root);\\n        int mode = 0;\\n        for(int value: map.values())\\n            mode = Math.max(mode, value);\\n        List<Integer> list = new ArrayList();\\n        for(Map.Entry<Integer, Integer> entry: map.entrySet())\\n            if (entry.getValue() == mode)\\n                list.add(entry.getKey());\\n        int[] result = new int[list.size()];\\n        int i = 0;\\n        for(int n: list)\\n            result[i++]=n;\\n        return result;\\n    }\\n    private void countElement(TreeNode root){\\n        if (root!= null)\\n            map.put(root.val, map.getOrDefault(root.val, 0)+1);\\n        if (root.left!=null)\\n            countElement(root.left);\\n        if (root.right!=null)\\n            countElement(root.right);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    int count = 0;\\n    int maxCount = 0;\\n    List<Integer> list = new ArrayList();\\n    TreeNode prev;\\n    public int[] findMode(TreeNode root) {\\n        prev = root;\\n        inorder(root);\\n        int[] result = new int[list.size()];\\n        int i = 0;\\n        for(int n: list)\\n            result[i++]=n;\\n        return result;\\n    }\\n    private void inorder(TreeNode node){\\n        if (node == null)\\n            return;\\n        inorder(node.left);\\n        if (prev.val == node.val)\\n            count++;\\n        else\\n            count = 1;\\n        if (count > maxCount){\\n            list.clear();\\n            list.add(node.val);\\n            maxCount = count;\\n        }else if (count == maxCount)\\n            list.add(node.val);\\n        prev = node;\\n        inorder(node.right);\\n    }\\n}\\n```\n```\\n/**\\n * Definition for a binary tree node.\\n * public class TreeNode {\\n *     int val;\\n *     TreeNode left;\\n *     TreeNode right;\\n *     TreeNode() {}\\n *     TreeNode(int val) { this.val = val; }\\n *     TreeNode(int val, TreeNode left, TreeNode right) {\\n *         this.val = val;\\n *         this.left = left;\\n *         this.right = right;\\n *     }\\n * }\\n */\\nclass Solution {\\n    Map<Integer, Integer> map = new HashMap();\\n    public int[] findMode(TreeNode root) {\\n        countElement(root);\\n        int mode = 0;\\n        for(int value: map.values())\\n            mode = Math.max(mode, value);\\n        List<Integer> list = new ArrayList();\\n        for(Map.Entry<Integer, Integer> entry: map.entrySet())\\n            if (entry.getValue() == mode)\\n                list.add(entry.getKey());\\n        int[] result = new int[list.size()];\\n        int i = 0;\\n        for(int n: list)\\n            result[i++]=n;\\n        return result;\\n    }\\n    private void countElement(TreeNode root){\\n        if (root!= null)\\n            map.put(root.val, map.getOrDefault(root.val, 0)+1);\\n        if (root.left!=null)\\n            countElement(root.left);\\n        if (root.right!=null)\\n            countElement(root.right);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2545673,
                "title": "cpp-solution-inorder-traversal-map",
                "content": "```\\nclass Solution {\\npublic:\\n    \\n    vector<int>arr;\\n    \\n    void findInorder(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }\\n        \\n        findInorder(root->left);\\n        arr.push_back(root->val);\\n        findInorder(root->right);\\n    }\\n    \\n    \\n    vector<int> findMode(TreeNode* root) {\\n        vector<int> ans;\\n        findInorder(root);\\n        \\n        map<int,int>mp;\\n        \\n        for(int i=0;i<arr.size();i++)\\n        {\\n            mp[arr[i]]++;\\n        }\\n        int maxfreq=0;\\n        \\n        map<int,int>::iterator it;\\n        \\n        for(it = mp.begin(); it!=mp.end();it++)\\n        {\\n            if(maxfreq < it->second)\\n            {\\n                maxfreq=it->second;\\n            }\\n        }\\n        \\n        for(it = mp.begin(); it!=mp.end();it++)\\n        {\\n            if(maxfreq ==it->second)\\n            {\\n               ans.push_back(it->first);\\n            }\\n        }\\n      \\n        return ans;\\n    }\\n};",
                "solutionTags": [
                    "C"
                ],
                "code": "class Solution {\\npublic:\\n    \\n    vector<int>arr;\\n    \\n    void findInorder(TreeNode* root)\\n    {\\n        if(root==NULL)\\n        {\\n            return;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2507383,
                "title": "c-solution-easy-to-understand",
                "content": "\\nclass Solution {\\npublic:\\n    \\n    int cur_count = 0 ;\\n    int max_count = INT_MIN;\\n    int p = INT_MIN;\\n    \\n    \\n    void find_mode_util(TreeNode * root,vector<int>& res)\\n    {\\n        \\n        \\n        if(!root ) return ; \\n        \\n        \\n    \\n        find_mode_util(root->left , res);\\n            \\n      \\n        if(root->val==p){\\n            cur_count++;\\n            \\n        }\\n        else{\\n            p = root->val;\\n            cur_count=1;\\n        }\\n        \\n        \\n        if(cur_count > max_count){\\n            res.clear();\\n            res.push_back(p);\\n            max_count = cur_count;\\n        }\\n        else if (cur_count == max_count){\\n            res.push_back(p);\\n        }\\n         \\n        \\n        \\n            \\n        find_mode_util(root->right , res);\\n            \\n    \\n        \\n        \\n        \\n        \\n        \\n        \\n    }    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    vector<int> findMode(TreeNode* root) {\\n        \\n        \\n        \\n        vector<int> res ;\\n        \\n        find_mode_util(root ,res );\\n        \\n    return res;\\n        \\n        \\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    \\n    int cur_count = 0 ;\\n    int max_count = INT_MIN;\\n    int p = INT_MIN;\\n    \\n    \\n    void find_mode_util(TreeNode * root,vector<int>& res)\\n    {\\n        \\n        \\n        if(!root ) return ; \\n        \\n        \\n    \\n        find_mode_util(root->left , res);\\n            \\n      \\n        if(root->val==p){\\n            cur_count++;\\n            \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2506290,
                "title": "c-easy-solution-dfs",
                "content": "```\\nvoid traverse(TreeNode *root, unordered_map<int,int> &mp)\\n    {\\n        if(root == NULL)\\n            return;\\n        \\n        mp[root->val]++;\\n        \\n        traverse(root->left,mp);\\n        traverse(root->right,mp);\\n    }\\n    vector<int> findMode(TreeNode* root) \\n    {\\n        unordered_map<int,int> mp;\\n        traverse(root,mp);\\n        vector<int> ans;\\n        int mode = 0;\\n        for(auto it:mp)\\n        {\\n            mode = max(mode,it.second);\\n        }\\n        \\n        for(auto it:mp)\\n        {\\n            if(it.second == mode)\\n            ans.push_back(it.first);\\n        }\\n        return ans;\\n    }",
                "solutionTags": [
                    "Depth-First Search",
                    "Interactive"
                ],
                "code": "```\\nvoid traverse(TreeNode *root, unordered_map<int,int> &mp)\\n    {\\n        if(root == NULL)\\n            return;\\n        \\n        mp[root->val]++;\\n        \\n        traverse(root->left,mp);\\n        traverse(root->right,mp);\\n    }\\n    vector<int> findMode(TreeNode* root) \\n    {\\n        unordered_map<int,int> mp;\\n        traverse(root,mp);\\n        vector<int> ans;\\n        int mode = 0;\\n        for(auto it:mp)\\n        {\\n            mode = max(mode,it.second);\\n        }\\n        \\n        for(auto it:mp)\\n        {\\n            if(it.second == mode)\\n            ans.push_back(it.first);\\n        }\\n        return ans;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 2497034,
                "title": "c-find-mode-in-bst-approach-code-using-inorder-traversal",
                "content": "**Approach: -** \\n1. Inorder traversal of a binary search tree gives a sorted array, hence we perform an inorder traversal and store all the elements and their frequencies in a hash map;\\n2. After getting all values and their frequencies simply traverse through map once to find the largest frequency which will determine the mode;\\n3. Now again traverse through the map and check if frequency of element i is eqal to maxValue or not, if it is push it into the ans array.\\n```\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root, unordered_map<int, int> &mp){\\n        if(root == NULL) return;                                                   // inorder traversal\\n        \\n        inorderTraversal(root->left, mp);\\n        mp[root->val]++;\\n        inorderTraversal(root->right, mp);\\n    }\\n\\t\\n    vector<int> findMode(TreeNode* root) {\\n        unordered_map<int, int> mp;\\n        vector<int> ans;\\n        inorderTraversal(root, mp);\\n        int maxValue =  INT_MIN;\\n\\t\\t\\n        for(auto i: mp){                                         // for loop to find maxValue\\n            if(maxValue < i.second){\\n                maxValue = i.second;\\n            }\\n        }\\n\\t\\t\\n        for(auto i: mp){                                       // for loop to find element value and push to ans\\n            if(i.second == maxValue){\\n                ans.push_back(i.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```\\nPlease upvote, it helps :}",
                "solutionTags": [
                    "C",
                    "Binary Search Tree"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    void inorderTraversal(TreeNode* root, unordered_map<int, int> &mp){\\n        if(root == NULL) return;                                                   // inorder traversal\\n        \\n        inorderTraversal(root->left, mp);\\n        mp[root->val]++;\\n        inorderTraversal(root->right, mp);\\n    }\\n\\t\\n    vector<int> findMode(TreeNode* root) {\\n        unordered_map<int, int> mp;\\n        vector<int> ans;\\n        inorderTraversal(root, mp);\\n        int maxValue =  INT_MIN;\\n\\t\\t\\n        for(auto i: mp){                                         // for loop to find maxValue\\n            if(maxValue < i.second){\\n                maxValue = i.second;\\n            }\\n        }\\n\\t\\t\\n        for(auto i: mp){                                       // for loop to find element value and push to ans\\n            if(i.second == maxValue){\\n                ans.push_back(i.first);\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2478919,
                "title": "easy-java-solution",
                "content": "class Solution {\\n    public int[] findMode(TreeNode root) {\\n\\t\\n        HashMap<Integer, Integer> map= new HashMap<>();\\n        \\n        fill(root, map);\\n        \\n        int max=0;\\n        int size=0;  \\n        \\n        for(Map.Entry<Integer, Integer> ele : map.entrySet())\\n        {  \\n            if(ele.getValue()> max) max=ele.getValue();\\n        }\\n        \\n        for(Map.Entry<Integer, Integer> ele : map.entrySet())\\n        {\\n            if(ele.getValue()==max) size++;\\n        }\\n        \\n        int res[]= new int[size]; int i=0;  \\n        \\n        for(Map.Entry<Integer, Integer> ele : map.entrySet())\\n        {  \\n            if(ele.getValue()==max) {\\n                res[i]=ele.getKey();\\n                i++;\\n            }\\n        }\\n        \\n        return res;\\n        \\n    }\\n\\t\\n    public void fill(TreeNode root, HashMap<Integer, Integer> map)\\n    { \\n        if(root==null) return;\\n        else\\n        {\\n            if(map.containsKey(root.val))\\n            {\\n                map.put(root.val, map.get(root.val)+1);\\n            }\\n            else\\n            {\\n                map.put(root.val, 1);\\n            }\\n        }\\n        \\n        fill(root.left, map);\\n        fill(root.right, map);\\n    }\\n}",
                "solutionTags": [
                    "Java"
                ],
                "code": "class Solution {\\n    public int[] findMode(TreeNode root) {\\n\\t\\n        HashMap<Integer, Integer> map= new HashMap<>();\\n        \\n        fill(root, map);\\n        \\n        int max=0;\\n        int size=0;  \\n        \\n        for(Map.Entry<Integer, Integer> ele : map.entrySet())\\n        {  \\n            if(ele.getValue()> max) max=ele.getValue();\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 2470346,
                "title": "time-o-n-space-o-1-inorder-traversal",
                "content": "Main idea is if you perform inorder traversal of a BST you will get a sorted list. \\n\\nNow think how to solve the problem for a sorted list without space.\\n\\n```\\nclass Solution {\\npublic:\\n    int curVal = INT_MIN;\\n    int curCnt = 0;\\n    int maxCnt = 0;\\n    vector<int> result;\\n    \\n    void inOrder(TreeNode* node) {\\n        if (nullptr == node) return;\\n        inOrder(node->left);\\n        if (node->val != curVal) {\\n            if (curCnt > maxCnt) {\\n                maxCnt = curCnt;\\n                result.clear();\\n                result.push_back(curVal);\\n            } else if (curCnt && curCnt == maxCnt) {\\n                result.push_back(curVal);\\n            }\\n            curVal = node->val;\\n            curCnt = 1;\\n        } else {\\n            curCnt++;\\n        }\\n        inOrder(node->right);\\n    }\\n    \\n    vector<int> findMode(TreeNode* root) {\\n        inOrder(root);\\n        if (curCnt > maxCnt) {\\n            result.clear();\\n            result.push_back(curVal);\\n        } else if (curCnt && curCnt == maxCnt) {\\n            result.push_back(curVal);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int curVal = INT_MIN;\\n    int curCnt = 0;\\n    int maxCnt = 0;\\n    vector<int> result;\\n    \\n    void inOrder(TreeNode* node) {\\n        if (nullptr == node) return;\\n        inOrder(node->left);\\n        if (node->val != curVal) {\\n            if (curCnt > maxCnt) {\\n                maxCnt = curCnt;\\n                result.clear();\\n                result.push_back(curVal);\\n            } else if (curCnt && curCnt == maxCnt) {\\n                result.push_back(curVal);\\n            }\\n            curVal = node->val;\\n            curCnt = 1;\\n        } else {\\n            curCnt++;\\n        }\\n        inOrder(node->right);\\n    }\\n    \\n    vector<int> findMode(TreeNode* root) {\\n        inOrder(root);\\n        if (curCnt > maxCnt) {\\n            result.clear();\\n            result.push_back(curVal);\\n        } else if (curCnt && curCnt == maxCnt) {\\n            result.push_back(curVal);\\n        }\\n        return result;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2465923,
                "title": "yet-another-fast-python-solution-o-n-with-explanation",
                "content": "The task is tricky :)\\n**The Logic**\\n\\nFirst ```ROOT``` is a binary search tree that means all values in `in order traversing` not decreasing. Usually, it is decreasing, but with duplicates, values could be the same.\\nThat is why it is important to use `in order traversing`.\\nThe values during tree traversing can be appearing like that: 1,2,3,3,3,4,5,6,6,6,6,6 - here 6 is our mode. If it would be given an array, we would start the loop and either increase our `currCount` by one each time the current value is equal to the previous one or reset it to one and start the counter again. During reset we update the `maxCount = max(currCount, maxCount)`. We are going to repeat that logic.\\n1. In the first `inorder` traversal we find how many times mode appears in our tree. It is the most frequent value.\\n2. We run again `inorder`, but that time we specify `collect = True` which means that we are collecting all nodes and `col = []` - we are appending modes to the list if its frequency is equal to `maxCount`. It is important to reset `currVal = -1` after the first traversal for the algorithm works correctly.\\n\\nIn function `inorder` we check if the `node is  None` and if it is not we traverse the left node and current and right node. It means we go deep to the very left node. Then to its parent and its brother on right, etc.\\nOn each node, we run `check(val)` function and compare if the `val` is equal to the `currVal`. If it is we increase our counter `currCount` if not, we reset it to one and reset `currVal`. We keep tracking if `currCount > maxCount`.\\nIn the collection phase we run the same `check` but with `collect` argument `True`. Here as soon as the `currCount == maxCount`, we add `val` to list `col`.\\n\\n**Time Complexity: O(N)**: we run two times in order traversal. \\nHope you liked it.\\n\\n*Please upvote if you like for motivation and karma :)*\\n\\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    currVal = -1\\n    currCount = 0\\n    maxCount = 0\\n\\n    def check(self, val, collect = False, col = None):\\n        if self.currVal != val:\\n            self.currVal = val\\n            self.currCount = 1\\n        else:\\n            self.currCount += 1\\n\\n        if not collect and self.currCount > self.maxCount:\\n            self.maxCount = self.currCount\\n            \\n        if collect and self.currCount == self.maxCount:\\n            col.append(val)\\n    \\n    def inorder(self, node, collect = False, col = None):\\n        if node is None:\\n            return\\n        self.inorder(node.left, collect, col)\\n        self.check(node.val, collect, col)\\n        self.inorder(node.right, collect, col)\\n        \\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        self.inorder(root)\\n        ans = []\\n        self.currVal = -1\\n        self.inorder(root, True, ans)\\n        return ans\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```ROOT```\n```\\n# Definition for a binary tree node.\\n# class TreeNode:\\n#     def __init__(self, val=0, left=None, right=None):\\n#         self.val = val\\n#         self.left = left\\n#         self.right = right\\nclass Solution:\\n    \\n    currVal = -1\\n    currCount = 0\\n    maxCount = 0\\n\\n    def check(self, val, collect = False, col = None):\\n        if self.currVal != val:\\n            self.currVal = val\\n            self.currCount = 1\\n        else:\\n            self.currCount += 1\\n\\n        if not collect and self.currCount > self.maxCount:\\n            self.maxCount = self.currCount\\n            \\n        if collect and self.currCount == self.maxCount:\\n            col.append(val)\\n    \\n    def inorder(self, node, collect = False, col = None):\\n        if node is None:\\n            return\\n        self.inorder(node.left, collect, col)\\n        self.check(node.val, collect, col)\\n        self.inorder(node.right, collect, col)\\n        \\n    def findMode(self, root: Optional[TreeNode]) -> List[int]:\\n        \\n        self.inorder(root)\\n        ans = []\\n        self.currVal = -1\\n        self.inorder(root, True, ans)\\n        return ans\\n```",
                "codeTag": "Java"
            }
        ],
        "discussions": [
            {
                "id": 1565205,
                "content": [
                    {
                        "username": "ycc0602",
                        "content": "What does \"mode\" mean?"
                    },
                    {
                        "username": "abderahman_ht",
                        "content": "[@Ebad1001](/Ebad1001) why the hate ?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Data element with highest frequency.\\n\\nI don\\'t believe people like you exist. Know how to code but don\\'t know even basic math."
                    },
                    {
                        "username": "geekyshark",
                        "content": "it seems you guys don\\'t read question and head straight to discussion tab"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "Mode means it\\'s the most commonly occurring number in a set of numbers."
                    },
                    {
                        "username": "Vyunish",
                        "content": "The whole definition of Binary Search Tree is Comprimised here.The elements to the right shouldn\\'t be equal to the root.The fact that he doesent want us to use extra space itself makes no sense.There is extra space both in recursion and in the output list anyways."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For whatever reason, we dont count stack space or output space when doing space complexity.  This means modifying input in place, or generating a new equally sized list both have O(1) space complexity, despite it clearly being an additional O(n) actual memory usage. Same for recuriosn stacks. We pretend they dont count for some reason. I find it pretty strange but... thats the way it goes?"
                    },
                    {
                        "username": "ilfatdance",
                        "content": "There is wrong test for [1,null,0,0,1,1,0]. \\nIt\\'s not BST."
                    },
                    {
                        "username": "grasssu",
                        "content": "If all elements frequency are equal, then there is NO mode. The judge returns every element which by definition is wrong."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@solidsnake91](/solidsnake91) How to handle this!!\\n"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "That\\'s exactly my problem. My breadth first search solution passes most test cases, but it fails when there is no mode, like you said. If a tree is [1, 2, 3] for example, those numbers that occur once don\\'t get added to my vector/arraylist, lol."
                    },
                    {
                        "username": "yuanqili",
                        "content": "The BST defined in this problem is not what common human will do.\\nThe human's way is to add a second field at each node counting the number of  duplicates.\\nIt loses all elegance of BST."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Modifying your input, particularly its structure, is *not* standard. "
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "i think htis question should be medium difficulty, it is very hard to solve"
                    },
                    {
                        "username": "eminom",
                        "content": "I got one test case from my submission:\\n[6,2,8,0,4,7,9,null,null,2,6] which is not a valid BST.\\nCould somebody explain this ?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "when you go through its inorder traversal you  will get what wrong with you."
                    },
                    {
                        "username": "adis176",
                        "content": "This is not a valid BST as per universal norms, but here for this particular question it is said that the left subtree has values smaller OR EQUAL to the root, while the right subtree has values greater OR EQUAL to the root of that particular tree. Hence as per current sum's definition, the tree is a valid one."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Open the console and click the (?) button in the upper right. They don\\'t explain this [] notation well."
                    },
                    {
                        "username": "jetleet",
                        "content": "is there any solution without traversal?taking advantage of BST\\uFF1F"
                    },
                    {
                        "username": "ahmed1999khalafallah",
                        "content": "Can any one explain the question please?"
                    },
                    {
                        "username": "ScarletPumpernickel",
                        "content": "What I\\'d like to see in the description is the push() / add() method for this variety of the BST."
                    }
                ]
            },
            {
                "id": 1576115,
                "content": [
                    {
                        "username": "ycc0602",
                        "content": "What does \"mode\" mean?"
                    },
                    {
                        "username": "abderahman_ht",
                        "content": "[@Ebad1001](/Ebad1001) why the hate ?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Data element with highest frequency.\\n\\nI don\\'t believe people like you exist. Know how to code but don\\'t know even basic math."
                    },
                    {
                        "username": "geekyshark",
                        "content": "it seems you guys don\\'t read question and head straight to discussion tab"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "Mode means it\\'s the most commonly occurring number in a set of numbers."
                    },
                    {
                        "username": "Vyunish",
                        "content": "The whole definition of Binary Search Tree is Comprimised here.The elements to the right shouldn\\'t be equal to the root.The fact that he doesent want us to use extra space itself makes no sense.There is extra space both in recursion and in the output list anyways."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For whatever reason, we dont count stack space or output space when doing space complexity.  This means modifying input in place, or generating a new equally sized list both have O(1) space complexity, despite it clearly being an additional O(n) actual memory usage. Same for recuriosn stacks. We pretend they dont count for some reason. I find it pretty strange but... thats the way it goes?"
                    },
                    {
                        "username": "ilfatdance",
                        "content": "There is wrong test for [1,null,0,0,1,1,0]. \\nIt\\'s not BST."
                    },
                    {
                        "username": "grasssu",
                        "content": "If all elements frequency are equal, then there is NO mode. The judge returns every element which by definition is wrong."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@solidsnake91](/solidsnake91) How to handle this!!\\n"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "That\\'s exactly my problem. My breadth first search solution passes most test cases, but it fails when there is no mode, like you said. If a tree is [1, 2, 3] for example, those numbers that occur once don\\'t get added to my vector/arraylist, lol."
                    },
                    {
                        "username": "yuanqili",
                        "content": "The BST defined in this problem is not what common human will do.\\nThe human's way is to add a second field at each node counting the number of  duplicates.\\nIt loses all elegance of BST."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Modifying your input, particularly its structure, is *not* standard. "
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "i think htis question should be medium difficulty, it is very hard to solve"
                    },
                    {
                        "username": "eminom",
                        "content": "I got one test case from my submission:\\n[6,2,8,0,4,7,9,null,null,2,6] which is not a valid BST.\\nCould somebody explain this ?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "when you go through its inorder traversal you  will get what wrong with you."
                    },
                    {
                        "username": "adis176",
                        "content": "This is not a valid BST as per universal norms, but here for this particular question it is said that the left subtree has values smaller OR EQUAL to the root, while the right subtree has values greater OR EQUAL to the root of that particular tree. Hence as per current sum's definition, the tree is a valid one."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Open the console and click the (?) button in the upper right. They don\\'t explain this [] notation well."
                    },
                    {
                        "username": "jetleet",
                        "content": "is there any solution without traversal?taking advantage of BST\\uFF1F"
                    },
                    {
                        "username": "ahmed1999khalafallah",
                        "content": "Can any one explain the question please?"
                    },
                    {
                        "username": "ScarletPumpernickel",
                        "content": "What I\\'d like to see in the description is the push() / add() method for this variety of the BST."
                    }
                ]
            },
            {
                "id": 1568594,
                "content": [
                    {
                        "username": "ycc0602",
                        "content": "What does \"mode\" mean?"
                    },
                    {
                        "username": "abderahman_ht",
                        "content": "[@Ebad1001](/Ebad1001) why the hate ?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Data element with highest frequency.\\n\\nI don\\'t believe people like you exist. Know how to code but don\\'t know even basic math."
                    },
                    {
                        "username": "geekyshark",
                        "content": "it seems you guys don\\'t read question and head straight to discussion tab"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "Mode means it\\'s the most commonly occurring number in a set of numbers."
                    },
                    {
                        "username": "Vyunish",
                        "content": "The whole definition of Binary Search Tree is Comprimised here.The elements to the right shouldn\\'t be equal to the root.The fact that he doesent want us to use extra space itself makes no sense.There is extra space both in recursion and in the output list anyways."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For whatever reason, we dont count stack space or output space when doing space complexity.  This means modifying input in place, or generating a new equally sized list both have O(1) space complexity, despite it clearly being an additional O(n) actual memory usage. Same for recuriosn stacks. We pretend they dont count for some reason. I find it pretty strange but... thats the way it goes?"
                    },
                    {
                        "username": "ilfatdance",
                        "content": "There is wrong test for [1,null,0,0,1,1,0]. \\nIt\\'s not BST."
                    },
                    {
                        "username": "grasssu",
                        "content": "If all elements frequency are equal, then there is NO mode. The judge returns every element which by definition is wrong."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@solidsnake91](/solidsnake91) How to handle this!!\\n"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "That\\'s exactly my problem. My breadth first search solution passes most test cases, but it fails when there is no mode, like you said. If a tree is [1, 2, 3] for example, those numbers that occur once don\\'t get added to my vector/arraylist, lol."
                    },
                    {
                        "username": "yuanqili",
                        "content": "The BST defined in this problem is not what common human will do.\\nThe human's way is to add a second field at each node counting the number of  duplicates.\\nIt loses all elegance of BST."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Modifying your input, particularly its structure, is *not* standard. "
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "i think htis question should be medium difficulty, it is very hard to solve"
                    },
                    {
                        "username": "eminom",
                        "content": "I got one test case from my submission:\\n[6,2,8,0,4,7,9,null,null,2,6] which is not a valid BST.\\nCould somebody explain this ?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "when you go through its inorder traversal you  will get what wrong with you."
                    },
                    {
                        "username": "adis176",
                        "content": "This is not a valid BST as per universal norms, but here for this particular question it is said that the left subtree has values smaller OR EQUAL to the root, while the right subtree has values greater OR EQUAL to the root of that particular tree. Hence as per current sum's definition, the tree is a valid one."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Open the console and click the (?) button in the upper right. They don\\'t explain this [] notation well."
                    },
                    {
                        "username": "jetleet",
                        "content": "is there any solution without traversal?taking advantage of BST\\uFF1F"
                    },
                    {
                        "username": "ahmed1999khalafallah",
                        "content": "Can any one explain the question please?"
                    },
                    {
                        "username": "ScarletPumpernickel",
                        "content": "What I\\'d like to see in the description is the push() / add() method for this variety of the BST."
                    }
                ]
            },
            {
                "id": 1571755,
                "content": [
                    {
                        "username": "ycc0602",
                        "content": "What does \"mode\" mean?"
                    },
                    {
                        "username": "abderahman_ht",
                        "content": "[@Ebad1001](/Ebad1001) why the hate ?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Data element with highest frequency.\\n\\nI don\\'t believe people like you exist. Know how to code but don\\'t know even basic math."
                    },
                    {
                        "username": "geekyshark",
                        "content": "it seems you guys don\\'t read question and head straight to discussion tab"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "Mode means it\\'s the most commonly occurring number in a set of numbers."
                    },
                    {
                        "username": "Vyunish",
                        "content": "The whole definition of Binary Search Tree is Comprimised here.The elements to the right shouldn\\'t be equal to the root.The fact that he doesent want us to use extra space itself makes no sense.There is extra space both in recursion and in the output list anyways."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For whatever reason, we dont count stack space or output space when doing space complexity.  This means modifying input in place, or generating a new equally sized list both have O(1) space complexity, despite it clearly being an additional O(n) actual memory usage. Same for recuriosn stacks. We pretend they dont count for some reason. I find it pretty strange but... thats the way it goes?"
                    },
                    {
                        "username": "ilfatdance",
                        "content": "There is wrong test for [1,null,0,0,1,1,0]. \\nIt\\'s not BST."
                    },
                    {
                        "username": "grasssu",
                        "content": "If all elements frequency are equal, then there is NO mode. The judge returns every element which by definition is wrong."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@solidsnake91](/solidsnake91) How to handle this!!\\n"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "That\\'s exactly my problem. My breadth first search solution passes most test cases, but it fails when there is no mode, like you said. If a tree is [1, 2, 3] for example, those numbers that occur once don\\'t get added to my vector/arraylist, lol."
                    },
                    {
                        "username": "yuanqili",
                        "content": "The BST defined in this problem is not what common human will do.\\nThe human's way is to add a second field at each node counting the number of  duplicates.\\nIt loses all elegance of BST."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Modifying your input, particularly its structure, is *not* standard. "
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "i think htis question should be medium difficulty, it is very hard to solve"
                    },
                    {
                        "username": "eminom",
                        "content": "I got one test case from my submission:\\n[6,2,8,0,4,7,9,null,null,2,6] which is not a valid BST.\\nCould somebody explain this ?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "when you go through its inorder traversal you  will get what wrong with you."
                    },
                    {
                        "username": "adis176",
                        "content": "This is not a valid BST as per universal norms, but here for this particular question it is said that the left subtree has values smaller OR EQUAL to the root, while the right subtree has values greater OR EQUAL to the root of that particular tree. Hence as per current sum's definition, the tree is a valid one."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Open the console and click the (?) button in the upper right. They don\\'t explain this [] notation well."
                    },
                    {
                        "username": "jetleet",
                        "content": "is there any solution without traversal?taking advantage of BST\\uFF1F"
                    },
                    {
                        "username": "ahmed1999khalafallah",
                        "content": "Can any one explain the question please?"
                    },
                    {
                        "username": "ScarletPumpernickel",
                        "content": "What I\\'d like to see in the description is the push() / add() method for this variety of the BST."
                    }
                ]
            },
            {
                "id": 1571754,
                "content": [
                    {
                        "username": "ycc0602",
                        "content": "What does \"mode\" mean?"
                    },
                    {
                        "username": "abderahman_ht",
                        "content": "[@Ebad1001](/Ebad1001) why the hate ?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Data element with highest frequency.\\n\\nI don\\'t believe people like you exist. Know how to code but don\\'t know even basic math."
                    },
                    {
                        "username": "geekyshark",
                        "content": "it seems you guys don\\'t read question and head straight to discussion tab"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "Mode means it\\'s the most commonly occurring number in a set of numbers."
                    },
                    {
                        "username": "Vyunish",
                        "content": "The whole definition of Binary Search Tree is Comprimised here.The elements to the right shouldn\\'t be equal to the root.The fact that he doesent want us to use extra space itself makes no sense.There is extra space both in recursion and in the output list anyways."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For whatever reason, we dont count stack space or output space when doing space complexity.  This means modifying input in place, or generating a new equally sized list both have O(1) space complexity, despite it clearly being an additional O(n) actual memory usage. Same for recuriosn stacks. We pretend they dont count for some reason. I find it pretty strange but... thats the way it goes?"
                    },
                    {
                        "username": "ilfatdance",
                        "content": "There is wrong test for [1,null,0,0,1,1,0]. \\nIt\\'s not BST."
                    },
                    {
                        "username": "grasssu",
                        "content": "If all elements frequency are equal, then there is NO mode. The judge returns every element which by definition is wrong."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@solidsnake91](/solidsnake91) How to handle this!!\\n"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "That\\'s exactly my problem. My breadth first search solution passes most test cases, but it fails when there is no mode, like you said. If a tree is [1, 2, 3] for example, those numbers that occur once don\\'t get added to my vector/arraylist, lol."
                    },
                    {
                        "username": "yuanqili",
                        "content": "The BST defined in this problem is not what common human will do.\\nThe human's way is to add a second field at each node counting the number of  duplicates.\\nIt loses all elegance of BST."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Modifying your input, particularly its structure, is *not* standard. "
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "i think htis question should be medium difficulty, it is very hard to solve"
                    },
                    {
                        "username": "eminom",
                        "content": "I got one test case from my submission:\\n[6,2,8,0,4,7,9,null,null,2,6] which is not a valid BST.\\nCould somebody explain this ?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "when you go through its inorder traversal you  will get what wrong with you."
                    },
                    {
                        "username": "adis176",
                        "content": "This is not a valid BST as per universal norms, but here for this particular question it is said that the left subtree has values smaller OR EQUAL to the root, while the right subtree has values greater OR EQUAL to the root of that particular tree. Hence as per current sum's definition, the tree is a valid one."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Open the console and click the (?) button in the upper right. They don\\'t explain this [] notation well."
                    },
                    {
                        "username": "jetleet",
                        "content": "is there any solution without traversal?taking advantage of BST\\uFF1F"
                    },
                    {
                        "username": "ahmed1999khalafallah",
                        "content": "Can any one explain the question please?"
                    },
                    {
                        "username": "ScarletPumpernickel",
                        "content": "What I\\'d like to see in the description is the push() / add() method for this variety of the BST."
                    }
                ]
            },
            {
                "id": 1861402,
                "content": [
                    {
                        "username": "ycc0602",
                        "content": "What does \"mode\" mean?"
                    },
                    {
                        "username": "abderahman_ht",
                        "content": "[@Ebad1001](/Ebad1001) why the hate ?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Data element with highest frequency.\\n\\nI don\\'t believe people like you exist. Know how to code but don\\'t know even basic math."
                    },
                    {
                        "username": "geekyshark",
                        "content": "it seems you guys don\\'t read question and head straight to discussion tab"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "Mode means it\\'s the most commonly occurring number in a set of numbers."
                    },
                    {
                        "username": "Vyunish",
                        "content": "The whole definition of Binary Search Tree is Comprimised here.The elements to the right shouldn\\'t be equal to the root.The fact that he doesent want us to use extra space itself makes no sense.There is extra space both in recursion and in the output list anyways."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For whatever reason, we dont count stack space or output space when doing space complexity.  This means modifying input in place, or generating a new equally sized list both have O(1) space complexity, despite it clearly being an additional O(n) actual memory usage. Same for recuriosn stacks. We pretend they dont count for some reason. I find it pretty strange but... thats the way it goes?"
                    },
                    {
                        "username": "ilfatdance",
                        "content": "There is wrong test for [1,null,0,0,1,1,0]. \\nIt\\'s not BST."
                    },
                    {
                        "username": "grasssu",
                        "content": "If all elements frequency are equal, then there is NO mode. The judge returns every element which by definition is wrong."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@solidsnake91](/solidsnake91) How to handle this!!\\n"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "That\\'s exactly my problem. My breadth first search solution passes most test cases, but it fails when there is no mode, like you said. If a tree is [1, 2, 3] for example, those numbers that occur once don\\'t get added to my vector/arraylist, lol."
                    },
                    {
                        "username": "yuanqili",
                        "content": "The BST defined in this problem is not what common human will do.\\nThe human's way is to add a second field at each node counting the number of  duplicates.\\nIt loses all elegance of BST."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Modifying your input, particularly its structure, is *not* standard. "
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "i think htis question should be medium difficulty, it is very hard to solve"
                    },
                    {
                        "username": "eminom",
                        "content": "I got one test case from my submission:\\n[6,2,8,0,4,7,9,null,null,2,6] which is not a valid BST.\\nCould somebody explain this ?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "when you go through its inorder traversal you  will get what wrong with you."
                    },
                    {
                        "username": "adis176",
                        "content": "This is not a valid BST as per universal norms, but here for this particular question it is said that the left subtree has values smaller OR EQUAL to the root, while the right subtree has values greater OR EQUAL to the root of that particular tree. Hence as per current sum's definition, the tree is a valid one."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Open the console and click the (?) button in the upper right. They don\\'t explain this [] notation well."
                    },
                    {
                        "username": "jetleet",
                        "content": "is there any solution without traversal?taking advantage of BST\\uFF1F"
                    },
                    {
                        "username": "ahmed1999khalafallah",
                        "content": "Can any one explain the question please?"
                    },
                    {
                        "username": "ScarletPumpernickel",
                        "content": "What I\\'d like to see in the description is the push() / add() method for this variety of the BST."
                    }
                ]
            },
            {
                "id": 1572595,
                "content": [
                    {
                        "username": "ycc0602",
                        "content": "What does \"mode\" mean?"
                    },
                    {
                        "username": "abderahman_ht",
                        "content": "[@Ebad1001](/Ebad1001) why the hate ?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Data element with highest frequency.\\n\\nI don\\'t believe people like you exist. Know how to code but don\\'t know even basic math."
                    },
                    {
                        "username": "geekyshark",
                        "content": "it seems you guys don\\'t read question and head straight to discussion tab"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "Mode means it\\'s the most commonly occurring number in a set of numbers."
                    },
                    {
                        "username": "Vyunish",
                        "content": "The whole definition of Binary Search Tree is Comprimised here.The elements to the right shouldn\\'t be equal to the root.The fact that he doesent want us to use extra space itself makes no sense.There is extra space both in recursion and in the output list anyways."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For whatever reason, we dont count stack space or output space when doing space complexity.  This means modifying input in place, or generating a new equally sized list both have O(1) space complexity, despite it clearly being an additional O(n) actual memory usage. Same for recuriosn stacks. We pretend they dont count for some reason. I find it pretty strange but... thats the way it goes?"
                    },
                    {
                        "username": "ilfatdance",
                        "content": "There is wrong test for [1,null,0,0,1,1,0]. \\nIt\\'s not BST."
                    },
                    {
                        "username": "grasssu",
                        "content": "If all elements frequency are equal, then there is NO mode. The judge returns every element which by definition is wrong."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@solidsnake91](/solidsnake91) How to handle this!!\\n"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "That\\'s exactly my problem. My breadth first search solution passes most test cases, but it fails when there is no mode, like you said. If a tree is [1, 2, 3] for example, those numbers that occur once don\\'t get added to my vector/arraylist, lol."
                    },
                    {
                        "username": "yuanqili",
                        "content": "The BST defined in this problem is not what common human will do.\\nThe human's way is to add a second field at each node counting the number of  duplicates.\\nIt loses all elegance of BST."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Modifying your input, particularly its structure, is *not* standard. "
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "i think htis question should be medium difficulty, it is very hard to solve"
                    },
                    {
                        "username": "eminom",
                        "content": "I got one test case from my submission:\\n[6,2,8,0,4,7,9,null,null,2,6] which is not a valid BST.\\nCould somebody explain this ?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "when you go through its inorder traversal you  will get what wrong with you."
                    },
                    {
                        "username": "adis176",
                        "content": "This is not a valid BST as per universal norms, but here for this particular question it is said that the left subtree has values smaller OR EQUAL to the root, while the right subtree has values greater OR EQUAL to the root of that particular tree. Hence as per current sum's definition, the tree is a valid one."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Open the console and click the (?) button in the upper right. They don\\'t explain this [] notation well."
                    },
                    {
                        "username": "jetleet",
                        "content": "is there any solution without traversal?taking advantage of BST\\uFF1F"
                    },
                    {
                        "username": "ahmed1999khalafallah",
                        "content": "Can any one explain the question please?"
                    },
                    {
                        "username": "ScarletPumpernickel",
                        "content": "What I\\'d like to see in the description is the push() / add() method for this variety of the BST."
                    }
                ]
            },
            {
                "id": 1572468,
                "content": [
                    {
                        "username": "ycc0602",
                        "content": "What does \"mode\" mean?"
                    },
                    {
                        "username": "abderahman_ht",
                        "content": "[@Ebad1001](/Ebad1001) why the hate ?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Data element with highest frequency.\\n\\nI don\\'t believe people like you exist. Know how to code but don\\'t know even basic math."
                    },
                    {
                        "username": "geekyshark",
                        "content": "it seems you guys don\\'t read question and head straight to discussion tab"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "Mode means it\\'s the most commonly occurring number in a set of numbers."
                    },
                    {
                        "username": "Vyunish",
                        "content": "The whole definition of Binary Search Tree is Comprimised here.The elements to the right shouldn\\'t be equal to the root.The fact that he doesent want us to use extra space itself makes no sense.There is extra space both in recursion and in the output list anyways."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For whatever reason, we dont count stack space or output space when doing space complexity.  This means modifying input in place, or generating a new equally sized list both have O(1) space complexity, despite it clearly being an additional O(n) actual memory usage. Same for recuriosn stacks. We pretend they dont count for some reason. I find it pretty strange but... thats the way it goes?"
                    },
                    {
                        "username": "ilfatdance",
                        "content": "There is wrong test for [1,null,0,0,1,1,0]. \\nIt\\'s not BST."
                    },
                    {
                        "username": "grasssu",
                        "content": "If all elements frequency are equal, then there is NO mode. The judge returns every element which by definition is wrong."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@solidsnake91](/solidsnake91) How to handle this!!\\n"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "That\\'s exactly my problem. My breadth first search solution passes most test cases, but it fails when there is no mode, like you said. If a tree is [1, 2, 3] for example, those numbers that occur once don\\'t get added to my vector/arraylist, lol."
                    },
                    {
                        "username": "yuanqili",
                        "content": "The BST defined in this problem is not what common human will do.\\nThe human's way is to add a second field at each node counting the number of  duplicates.\\nIt loses all elegance of BST."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Modifying your input, particularly its structure, is *not* standard. "
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "i think htis question should be medium difficulty, it is very hard to solve"
                    },
                    {
                        "username": "eminom",
                        "content": "I got one test case from my submission:\\n[6,2,8,0,4,7,9,null,null,2,6] which is not a valid BST.\\nCould somebody explain this ?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "when you go through its inorder traversal you  will get what wrong with you."
                    },
                    {
                        "username": "adis176",
                        "content": "This is not a valid BST as per universal norms, but here for this particular question it is said that the left subtree has values smaller OR EQUAL to the root, while the right subtree has values greater OR EQUAL to the root of that particular tree. Hence as per current sum's definition, the tree is a valid one."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Open the console and click the (?) button in the upper right. They don\\'t explain this [] notation well."
                    },
                    {
                        "username": "jetleet",
                        "content": "is there any solution without traversal?taking advantage of BST\\uFF1F"
                    },
                    {
                        "username": "ahmed1999khalafallah",
                        "content": "Can any one explain the question please?"
                    },
                    {
                        "username": "ScarletPumpernickel",
                        "content": "What I\\'d like to see in the description is the push() / add() method for this variety of the BST."
                    }
                ]
            },
            {
                "id": 1810549,
                "content": [
                    {
                        "username": "ycc0602",
                        "content": "What does \"mode\" mean?"
                    },
                    {
                        "username": "abderahman_ht",
                        "content": "[@Ebad1001](/Ebad1001) why the hate ?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Data element with highest frequency.\\n\\nI don\\'t believe people like you exist. Know how to code but don\\'t know even basic math."
                    },
                    {
                        "username": "geekyshark",
                        "content": "it seems you guys don\\'t read question and head straight to discussion tab"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "Mode means it\\'s the most commonly occurring number in a set of numbers."
                    },
                    {
                        "username": "Vyunish",
                        "content": "The whole definition of Binary Search Tree is Comprimised here.The elements to the right shouldn\\'t be equal to the root.The fact that he doesent want us to use extra space itself makes no sense.There is extra space both in recursion and in the output list anyways."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For whatever reason, we dont count stack space or output space when doing space complexity.  This means modifying input in place, or generating a new equally sized list both have O(1) space complexity, despite it clearly being an additional O(n) actual memory usage. Same for recuriosn stacks. We pretend they dont count for some reason. I find it pretty strange but... thats the way it goes?"
                    },
                    {
                        "username": "ilfatdance",
                        "content": "There is wrong test for [1,null,0,0,1,1,0]. \\nIt\\'s not BST."
                    },
                    {
                        "username": "grasssu",
                        "content": "If all elements frequency are equal, then there is NO mode. The judge returns every element which by definition is wrong."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@solidsnake91](/solidsnake91) How to handle this!!\\n"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "That\\'s exactly my problem. My breadth first search solution passes most test cases, but it fails when there is no mode, like you said. If a tree is [1, 2, 3] for example, those numbers that occur once don\\'t get added to my vector/arraylist, lol."
                    },
                    {
                        "username": "yuanqili",
                        "content": "The BST defined in this problem is not what common human will do.\\nThe human's way is to add a second field at each node counting the number of  duplicates.\\nIt loses all elegance of BST."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Modifying your input, particularly its structure, is *not* standard. "
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "i think htis question should be medium difficulty, it is very hard to solve"
                    },
                    {
                        "username": "eminom",
                        "content": "I got one test case from my submission:\\n[6,2,8,0,4,7,9,null,null,2,6] which is not a valid BST.\\nCould somebody explain this ?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "when you go through its inorder traversal you  will get what wrong with you."
                    },
                    {
                        "username": "adis176",
                        "content": "This is not a valid BST as per universal norms, but here for this particular question it is said that the left subtree has values smaller OR EQUAL to the root, while the right subtree has values greater OR EQUAL to the root of that particular tree. Hence as per current sum's definition, the tree is a valid one."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Open the console and click the (?) button in the upper right. They don\\'t explain this [] notation well."
                    },
                    {
                        "username": "jetleet",
                        "content": "is there any solution without traversal?taking advantage of BST\\uFF1F"
                    },
                    {
                        "username": "ahmed1999khalafallah",
                        "content": "Can any one explain the question please?"
                    },
                    {
                        "username": "ScarletPumpernickel",
                        "content": "What I\\'d like to see in the description is the push() / add() method for this variety of the BST."
                    }
                ]
            },
            {
                "id": 2034613,
                "content": [
                    {
                        "username": "ycc0602",
                        "content": "What does \"mode\" mean?"
                    },
                    {
                        "username": "abderahman_ht",
                        "content": "[@Ebad1001](/Ebad1001) why the hate ?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Data element with highest frequency.\\n\\nI don\\'t believe people like you exist. Know how to code but don\\'t know even basic math."
                    },
                    {
                        "username": "geekyshark",
                        "content": "it seems you guys don\\'t read question and head straight to discussion tab"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "Mode means it\\'s the most commonly occurring number in a set of numbers."
                    },
                    {
                        "username": "Vyunish",
                        "content": "The whole definition of Binary Search Tree is Comprimised here.The elements to the right shouldn\\'t be equal to the root.The fact that he doesent want us to use extra space itself makes no sense.There is extra space both in recursion and in the output list anyways."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For whatever reason, we dont count stack space or output space when doing space complexity.  This means modifying input in place, or generating a new equally sized list both have O(1) space complexity, despite it clearly being an additional O(n) actual memory usage. Same for recuriosn stacks. We pretend they dont count for some reason. I find it pretty strange but... thats the way it goes?"
                    },
                    {
                        "username": "ilfatdance",
                        "content": "There is wrong test for [1,null,0,0,1,1,0]. \\nIt\\'s not BST."
                    },
                    {
                        "username": "grasssu",
                        "content": "If all elements frequency are equal, then there is NO mode. The judge returns every element which by definition is wrong."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@solidsnake91](/solidsnake91) How to handle this!!\\n"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "That\\'s exactly my problem. My breadth first search solution passes most test cases, but it fails when there is no mode, like you said. If a tree is [1, 2, 3] for example, those numbers that occur once don\\'t get added to my vector/arraylist, lol."
                    },
                    {
                        "username": "yuanqili",
                        "content": "The BST defined in this problem is not what common human will do.\\nThe human's way is to add a second field at each node counting the number of  duplicates.\\nIt loses all elegance of BST."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Modifying your input, particularly its structure, is *not* standard. "
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "i think htis question should be medium difficulty, it is very hard to solve"
                    },
                    {
                        "username": "eminom",
                        "content": "I got one test case from my submission:\\n[6,2,8,0,4,7,9,null,null,2,6] which is not a valid BST.\\nCould somebody explain this ?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "when you go through its inorder traversal you  will get what wrong with you."
                    },
                    {
                        "username": "adis176",
                        "content": "This is not a valid BST as per universal norms, but here for this particular question it is said that the left subtree has values smaller OR EQUAL to the root, while the right subtree has values greater OR EQUAL to the root of that particular tree. Hence as per current sum's definition, the tree is a valid one."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Open the console and click the (?) button in the upper right. They don\\'t explain this [] notation well."
                    },
                    {
                        "username": "jetleet",
                        "content": "is there any solution without traversal?taking advantage of BST\\uFF1F"
                    },
                    {
                        "username": "ahmed1999khalafallah",
                        "content": "Can any one explain the question please?"
                    },
                    {
                        "username": "ScarletPumpernickel",
                        "content": "What I\\'d like to see in the description is the push() / add() method for this variety of the BST."
                    }
                ]
            },
            {
                "id": 1565205,
                "content": [
                    {
                        "username": "ycc0602",
                        "content": "What does \"mode\" mean?"
                    },
                    {
                        "username": "abderahman_ht",
                        "content": "[@Ebad1001](/Ebad1001) why the hate ?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Data element with highest frequency.\\n\\nI don\\'t believe people like you exist. Know how to code but don\\'t know even basic math."
                    },
                    {
                        "username": "geekyshark",
                        "content": "it seems you guys don\\'t read question and head straight to discussion tab"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "Mode means it\\'s the most commonly occurring number in a set of numbers."
                    },
                    {
                        "username": "Vyunish",
                        "content": "The whole definition of Binary Search Tree is Comprimised here.The elements to the right shouldn\\'t be equal to the root.The fact that he doesent want us to use extra space itself makes no sense.There is extra space both in recursion and in the output list anyways."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For whatever reason, we dont count stack space or output space when doing space complexity.  This means modifying input in place, or generating a new equally sized list both have O(1) space complexity, despite it clearly being an additional O(n) actual memory usage. Same for recuriosn stacks. We pretend they dont count for some reason. I find it pretty strange but... thats the way it goes?"
                    },
                    {
                        "username": "ilfatdance",
                        "content": "There is wrong test for [1,null,0,0,1,1,0]. \\nIt\\'s not BST."
                    },
                    {
                        "username": "grasssu",
                        "content": "If all elements frequency are equal, then there is NO mode. The judge returns every element which by definition is wrong."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@solidsnake91](/solidsnake91) How to handle this!!\\n"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "That\\'s exactly my problem. My breadth first search solution passes most test cases, but it fails when there is no mode, like you said. If a tree is [1, 2, 3] for example, those numbers that occur once don\\'t get added to my vector/arraylist, lol."
                    },
                    {
                        "username": "yuanqili",
                        "content": "The BST defined in this problem is not what common human will do.\\nThe human's way is to add a second field at each node counting the number of  duplicates.\\nIt loses all elegance of BST."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Modifying your input, particularly its structure, is *not* standard. "
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "i think htis question should be medium difficulty, it is very hard to solve"
                    },
                    {
                        "username": "eminom",
                        "content": "I got one test case from my submission:\\n[6,2,8,0,4,7,9,null,null,2,6] which is not a valid BST.\\nCould somebody explain this ?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "when you go through its inorder traversal you  will get what wrong with you."
                    },
                    {
                        "username": "adis176",
                        "content": "This is not a valid BST as per universal norms, but here for this particular question it is said that the left subtree has values smaller OR EQUAL to the root, while the right subtree has values greater OR EQUAL to the root of that particular tree. Hence as per current sum's definition, the tree is a valid one."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Open the console and click the (?) button in the upper right. They don\\'t explain this [] notation well."
                    },
                    {
                        "username": "jetleet",
                        "content": "is there any solution without traversal?taking advantage of BST\\uFF1F"
                    },
                    {
                        "username": "ahmed1999khalafallah",
                        "content": "Can any one explain the question please?"
                    },
                    {
                        "username": "ScarletPumpernickel",
                        "content": "What I\\'d like to see in the description is the push() / add() method for this variety of the BST."
                    }
                ]
            },
            {
                "id": 1576115,
                "content": [
                    {
                        "username": "ycc0602",
                        "content": "What does \"mode\" mean?"
                    },
                    {
                        "username": "abderahman_ht",
                        "content": "[@Ebad1001](/Ebad1001) why the hate ?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Data element with highest frequency.\\n\\nI don\\'t believe people like you exist. Know how to code but don\\'t know even basic math."
                    },
                    {
                        "username": "geekyshark",
                        "content": "it seems you guys don\\'t read question and head straight to discussion tab"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "Mode means it\\'s the most commonly occurring number in a set of numbers."
                    },
                    {
                        "username": "Vyunish",
                        "content": "The whole definition of Binary Search Tree is Comprimised here.The elements to the right shouldn\\'t be equal to the root.The fact that he doesent want us to use extra space itself makes no sense.There is extra space both in recursion and in the output list anyways."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For whatever reason, we dont count stack space or output space when doing space complexity.  This means modifying input in place, or generating a new equally sized list both have O(1) space complexity, despite it clearly being an additional O(n) actual memory usage. Same for recuriosn stacks. We pretend they dont count for some reason. I find it pretty strange but... thats the way it goes?"
                    },
                    {
                        "username": "ilfatdance",
                        "content": "There is wrong test for [1,null,0,0,1,1,0]. \\nIt\\'s not BST."
                    },
                    {
                        "username": "grasssu",
                        "content": "If all elements frequency are equal, then there is NO mode. The judge returns every element which by definition is wrong."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@solidsnake91](/solidsnake91) How to handle this!!\\n"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "That\\'s exactly my problem. My breadth first search solution passes most test cases, but it fails when there is no mode, like you said. If a tree is [1, 2, 3] for example, those numbers that occur once don\\'t get added to my vector/arraylist, lol."
                    },
                    {
                        "username": "yuanqili",
                        "content": "The BST defined in this problem is not what common human will do.\\nThe human's way is to add a second field at each node counting the number of  duplicates.\\nIt loses all elegance of BST."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Modifying your input, particularly its structure, is *not* standard. "
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "i think htis question should be medium difficulty, it is very hard to solve"
                    },
                    {
                        "username": "eminom",
                        "content": "I got one test case from my submission:\\n[6,2,8,0,4,7,9,null,null,2,6] which is not a valid BST.\\nCould somebody explain this ?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "when you go through its inorder traversal you  will get what wrong with you."
                    },
                    {
                        "username": "adis176",
                        "content": "This is not a valid BST as per universal norms, but here for this particular question it is said that the left subtree has values smaller OR EQUAL to the root, while the right subtree has values greater OR EQUAL to the root of that particular tree. Hence as per current sum's definition, the tree is a valid one."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Open the console and click the (?) button in the upper right. They don\\'t explain this [] notation well."
                    },
                    {
                        "username": "jetleet",
                        "content": "is there any solution without traversal?taking advantage of BST\\uFF1F"
                    },
                    {
                        "username": "ahmed1999khalafallah",
                        "content": "Can any one explain the question please?"
                    },
                    {
                        "username": "ScarletPumpernickel",
                        "content": "What I\\'d like to see in the description is the push() / add() method for this variety of the BST."
                    }
                ]
            },
            {
                "id": 1568594,
                "content": [
                    {
                        "username": "ycc0602",
                        "content": "What does \"mode\" mean?"
                    },
                    {
                        "username": "abderahman_ht",
                        "content": "[@Ebad1001](/Ebad1001) why the hate ?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Data element with highest frequency.\\n\\nI don\\'t believe people like you exist. Know how to code but don\\'t know even basic math."
                    },
                    {
                        "username": "geekyshark",
                        "content": "it seems you guys don\\'t read question and head straight to discussion tab"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "Mode means it\\'s the most commonly occurring number in a set of numbers."
                    },
                    {
                        "username": "Vyunish",
                        "content": "The whole definition of Binary Search Tree is Comprimised here.The elements to the right shouldn\\'t be equal to the root.The fact that he doesent want us to use extra space itself makes no sense.There is extra space both in recursion and in the output list anyways."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For whatever reason, we dont count stack space or output space when doing space complexity.  This means modifying input in place, or generating a new equally sized list both have O(1) space complexity, despite it clearly being an additional O(n) actual memory usage. Same for recuriosn stacks. We pretend they dont count for some reason. I find it pretty strange but... thats the way it goes?"
                    },
                    {
                        "username": "ilfatdance",
                        "content": "There is wrong test for [1,null,0,0,1,1,0]. \\nIt\\'s not BST."
                    },
                    {
                        "username": "grasssu",
                        "content": "If all elements frequency are equal, then there is NO mode. The judge returns every element which by definition is wrong."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@solidsnake91](/solidsnake91) How to handle this!!\\n"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "That\\'s exactly my problem. My breadth first search solution passes most test cases, but it fails when there is no mode, like you said. If a tree is [1, 2, 3] for example, those numbers that occur once don\\'t get added to my vector/arraylist, lol."
                    },
                    {
                        "username": "yuanqili",
                        "content": "The BST defined in this problem is not what common human will do.\\nThe human's way is to add a second field at each node counting the number of  duplicates.\\nIt loses all elegance of BST."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Modifying your input, particularly its structure, is *not* standard. "
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "i think htis question should be medium difficulty, it is very hard to solve"
                    },
                    {
                        "username": "eminom",
                        "content": "I got one test case from my submission:\\n[6,2,8,0,4,7,9,null,null,2,6] which is not a valid BST.\\nCould somebody explain this ?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "when you go through its inorder traversal you  will get what wrong with you."
                    },
                    {
                        "username": "adis176",
                        "content": "This is not a valid BST as per universal norms, but here for this particular question it is said that the left subtree has values smaller OR EQUAL to the root, while the right subtree has values greater OR EQUAL to the root of that particular tree. Hence as per current sum's definition, the tree is a valid one."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Open the console and click the (?) button in the upper right. They don\\'t explain this [] notation well."
                    },
                    {
                        "username": "jetleet",
                        "content": "is there any solution without traversal?taking advantage of BST\\uFF1F"
                    },
                    {
                        "username": "ahmed1999khalafallah",
                        "content": "Can any one explain the question please?"
                    },
                    {
                        "username": "ScarletPumpernickel",
                        "content": "What I\\'d like to see in the description is the push() / add() method for this variety of the BST."
                    }
                ]
            },
            {
                "id": 1571755,
                "content": [
                    {
                        "username": "ycc0602",
                        "content": "What does \"mode\" mean?"
                    },
                    {
                        "username": "abderahman_ht",
                        "content": "[@Ebad1001](/Ebad1001) why the hate ?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Data element with highest frequency.\\n\\nI don\\'t believe people like you exist. Know how to code but don\\'t know even basic math."
                    },
                    {
                        "username": "geekyshark",
                        "content": "it seems you guys don\\'t read question and head straight to discussion tab"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "Mode means it\\'s the most commonly occurring number in a set of numbers."
                    },
                    {
                        "username": "Vyunish",
                        "content": "The whole definition of Binary Search Tree is Comprimised here.The elements to the right shouldn\\'t be equal to the root.The fact that he doesent want us to use extra space itself makes no sense.There is extra space both in recursion and in the output list anyways."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For whatever reason, we dont count stack space or output space when doing space complexity.  This means modifying input in place, or generating a new equally sized list both have O(1) space complexity, despite it clearly being an additional O(n) actual memory usage. Same for recuriosn stacks. We pretend they dont count for some reason. I find it pretty strange but... thats the way it goes?"
                    },
                    {
                        "username": "ilfatdance",
                        "content": "There is wrong test for [1,null,0,0,1,1,0]. \\nIt\\'s not BST."
                    },
                    {
                        "username": "grasssu",
                        "content": "If all elements frequency are equal, then there is NO mode. The judge returns every element which by definition is wrong."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@solidsnake91](/solidsnake91) How to handle this!!\\n"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "That\\'s exactly my problem. My breadth first search solution passes most test cases, but it fails when there is no mode, like you said. If a tree is [1, 2, 3] for example, those numbers that occur once don\\'t get added to my vector/arraylist, lol."
                    },
                    {
                        "username": "yuanqili",
                        "content": "The BST defined in this problem is not what common human will do.\\nThe human's way is to add a second field at each node counting the number of  duplicates.\\nIt loses all elegance of BST."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Modifying your input, particularly its structure, is *not* standard. "
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "i think htis question should be medium difficulty, it is very hard to solve"
                    },
                    {
                        "username": "eminom",
                        "content": "I got one test case from my submission:\\n[6,2,8,0,4,7,9,null,null,2,6] which is not a valid BST.\\nCould somebody explain this ?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "when you go through its inorder traversal you  will get what wrong with you."
                    },
                    {
                        "username": "adis176",
                        "content": "This is not a valid BST as per universal norms, but here for this particular question it is said that the left subtree has values smaller OR EQUAL to the root, while the right subtree has values greater OR EQUAL to the root of that particular tree. Hence as per current sum's definition, the tree is a valid one."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Open the console and click the (?) button in the upper right. They don\\'t explain this [] notation well."
                    },
                    {
                        "username": "jetleet",
                        "content": "is there any solution without traversal?taking advantage of BST\\uFF1F"
                    },
                    {
                        "username": "ahmed1999khalafallah",
                        "content": "Can any one explain the question please?"
                    },
                    {
                        "username": "ScarletPumpernickel",
                        "content": "What I\\'d like to see in the description is the push() / add() method for this variety of the BST."
                    }
                ]
            },
            {
                "id": 1571754,
                "content": [
                    {
                        "username": "ycc0602",
                        "content": "What does \"mode\" mean?"
                    },
                    {
                        "username": "abderahman_ht",
                        "content": "[@Ebad1001](/Ebad1001) why the hate ?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Data element with highest frequency.\\n\\nI don\\'t believe people like you exist. Know how to code but don\\'t know even basic math."
                    },
                    {
                        "username": "geekyshark",
                        "content": "it seems you guys don\\'t read question and head straight to discussion tab"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "Mode means it\\'s the most commonly occurring number in a set of numbers."
                    },
                    {
                        "username": "Vyunish",
                        "content": "The whole definition of Binary Search Tree is Comprimised here.The elements to the right shouldn\\'t be equal to the root.The fact that he doesent want us to use extra space itself makes no sense.There is extra space both in recursion and in the output list anyways."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For whatever reason, we dont count stack space or output space when doing space complexity.  This means modifying input in place, or generating a new equally sized list both have O(1) space complexity, despite it clearly being an additional O(n) actual memory usage. Same for recuriosn stacks. We pretend they dont count for some reason. I find it pretty strange but... thats the way it goes?"
                    },
                    {
                        "username": "ilfatdance",
                        "content": "There is wrong test for [1,null,0,0,1,1,0]. \\nIt\\'s not BST."
                    },
                    {
                        "username": "grasssu",
                        "content": "If all elements frequency are equal, then there is NO mode. The judge returns every element which by definition is wrong."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@solidsnake91](/solidsnake91) How to handle this!!\\n"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "That\\'s exactly my problem. My breadth first search solution passes most test cases, but it fails when there is no mode, like you said. If a tree is [1, 2, 3] for example, those numbers that occur once don\\'t get added to my vector/arraylist, lol."
                    },
                    {
                        "username": "yuanqili",
                        "content": "The BST defined in this problem is not what common human will do.\\nThe human's way is to add a second field at each node counting the number of  duplicates.\\nIt loses all elegance of BST."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Modifying your input, particularly its structure, is *not* standard. "
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "i think htis question should be medium difficulty, it is very hard to solve"
                    },
                    {
                        "username": "eminom",
                        "content": "I got one test case from my submission:\\n[6,2,8,0,4,7,9,null,null,2,6] which is not a valid BST.\\nCould somebody explain this ?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "when you go through its inorder traversal you  will get what wrong with you."
                    },
                    {
                        "username": "adis176",
                        "content": "This is not a valid BST as per universal norms, but here for this particular question it is said that the left subtree has values smaller OR EQUAL to the root, while the right subtree has values greater OR EQUAL to the root of that particular tree. Hence as per current sum's definition, the tree is a valid one."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Open the console and click the (?) button in the upper right. They don\\'t explain this [] notation well."
                    },
                    {
                        "username": "jetleet",
                        "content": "is there any solution without traversal?taking advantage of BST\\uFF1F"
                    },
                    {
                        "username": "ahmed1999khalafallah",
                        "content": "Can any one explain the question please?"
                    },
                    {
                        "username": "ScarletPumpernickel",
                        "content": "What I\\'d like to see in the description is the push() / add() method for this variety of the BST."
                    }
                ]
            },
            {
                "id": 1861402,
                "content": [
                    {
                        "username": "ycc0602",
                        "content": "What does \"mode\" mean?"
                    },
                    {
                        "username": "abderahman_ht",
                        "content": "[@Ebad1001](/Ebad1001) why the hate ?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Data element with highest frequency.\\n\\nI don\\'t believe people like you exist. Know how to code but don\\'t know even basic math."
                    },
                    {
                        "username": "geekyshark",
                        "content": "it seems you guys don\\'t read question and head straight to discussion tab"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "Mode means it\\'s the most commonly occurring number in a set of numbers."
                    },
                    {
                        "username": "Vyunish",
                        "content": "The whole definition of Binary Search Tree is Comprimised here.The elements to the right shouldn\\'t be equal to the root.The fact that he doesent want us to use extra space itself makes no sense.There is extra space both in recursion and in the output list anyways."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For whatever reason, we dont count stack space or output space when doing space complexity.  This means modifying input in place, or generating a new equally sized list both have O(1) space complexity, despite it clearly being an additional O(n) actual memory usage. Same for recuriosn stacks. We pretend they dont count for some reason. I find it pretty strange but... thats the way it goes?"
                    },
                    {
                        "username": "ilfatdance",
                        "content": "There is wrong test for [1,null,0,0,1,1,0]. \\nIt\\'s not BST."
                    },
                    {
                        "username": "grasssu",
                        "content": "If all elements frequency are equal, then there is NO mode. The judge returns every element which by definition is wrong."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@solidsnake91](/solidsnake91) How to handle this!!\\n"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "That\\'s exactly my problem. My breadth first search solution passes most test cases, but it fails when there is no mode, like you said. If a tree is [1, 2, 3] for example, those numbers that occur once don\\'t get added to my vector/arraylist, lol."
                    },
                    {
                        "username": "yuanqili",
                        "content": "The BST defined in this problem is not what common human will do.\\nThe human's way is to add a second field at each node counting the number of  duplicates.\\nIt loses all elegance of BST."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Modifying your input, particularly its structure, is *not* standard. "
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "i think htis question should be medium difficulty, it is very hard to solve"
                    },
                    {
                        "username": "eminom",
                        "content": "I got one test case from my submission:\\n[6,2,8,0,4,7,9,null,null,2,6] which is not a valid BST.\\nCould somebody explain this ?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "when you go through its inorder traversal you  will get what wrong with you."
                    },
                    {
                        "username": "adis176",
                        "content": "This is not a valid BST as per universal norms, but here for this particular question it is said that the left subtree has values smaller OR EQUAL to the root, while the right subtree has values greater OR EQUAL to the root of that particular tree. Hence as per current sum's definition, the tree is a valid one."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Open the console and click the (?) button in the upper right. They don\\'t explain this [] notation well."
                    },
                    {
                        "username": "jetleet",
                        "content": "is there any solution without traversal?taking advantage of BST\\uFF1F"
                    },
                    {
                        "username": "ahmed1999khalafallah",
                        "content": "Can any one explain the question please?"
                    },
                    {
                        "username": "ScarletPumpernickel",
                        "content": "What I\\'d like to see in the description is the push() / add() method for this variety of the BST."
                    }
                ]
            },
            {
                "id": 1572595,
                "content": [
                    {
                        "username": "ycc0602",
                        "content": "What does \"mode\" mean?"
                    },
                    {
                        "username": "abderahman_ht",
                        "content": "[@Ebad1001](/Ebad1001) why the hate ?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Data element with highest frequency.\\n\\nI don\\'t believe people like you exist. Know how to code but don\\'t know even basic math."
                    },
                    {
                        "username": "geekyshark",
                        "content": "it seems you guys don\\'t read question and head straight to discussion tab"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "Mode means it\\'s the most commonly occurring number in a set of numbers."
                    },
                    {
                        "username": "Vyunish",
                        "content": "The whole definition of Binary Search Tree is Comprimised here.The elements to the right shouldn\\'t be equal to the root.The fact that he doesent want us to use extra space itself makes no sense.There is extra space both in recursion and in the output list anyways."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For whatever reason, we dont count stack space or output space when doing space complexity.  This means modifying input in place, or generating a new equally sized list both have O(1) space complexity, despite it clearly being an additional O(n) actual memory usage. Same for recuriosn stacks. We pretend they dont count for some reason. I find it pretty strange but... thats the way it goes?"
                    },
                    {
                        "username": "ilfatdance",
                        "content": "There is wrong test for [1,null,0,0,1,1,0]. \\nIt\\'s not BST."
                    },
                    {
                        "username": "grasssu",
                        "content": "If all elements frequency are equal, then there is NO mode. The judge returns every element which by definition is wrong."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@solidsnake91](/solidsnake91) How to handle this!!\\n"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "That\\'s exactly my problem. My breadth first search solution passes most test cases, but it fails when there is no mode, like you said. If a tree is [1, 2, 3] for example, those numbers that occur once don\\'t get added to my vector/arraylist, lol."
                    },
                    {
                        "username": "yuanqili",
                        "content": "The BST defined in this problem is not what common human will do.\\nThe human's way is to add a second field at each node counting the number of  duplicates.\\nIt loses all elegance of BST."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Modifying your input, particularly its structure, is *not* standard. "
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "i think htis question should be medium difficulty, it is very hard to solve"
                    },
                    {
                        "username": "eminom",
                        "content": "I got one test case from my submission:\\n[6,2,8,0,4,7,9,null,null,2,6] which is not a valid BST.\\nCould somebody explain this ?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "when you go through its inorder traversal you  will get what wrong with you."
                    },
                    {
                        "username": "adis176",
                        "content": "This is not a valid BST as per universal norms, but here for this particular question it is said that the left subtree has values smaller OR EQUAL to the root, while the right subtree has values greater OR EQUAL to the root of that particular tree. Hence as per current sum's definition, the tree is a valid one."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Open the console and click the (?) button in the upper right. They don\\'t explain this [] notation well."
                    },
                    {
                        "username": "jetleet",
                        "content": "is there any solution without traversal?taking advantage of BST\\uFF1F"
                    },
                    {
                        "username": "ahmed1999khalafallah",
                        "content": "Can any one explain the question please?"
                    },
                    {
                        "username": "ScarletPumpernickel",
                        "content": "What I\\'d like to see in the description is the push() / add() method for this variety of the BST."
                    }
                ]
            },
            {
                "id": 1572468,
                "content": [
                    {
                        "username": "ycc0602",
                        "content": "What does \"mode\" mean?"
                    },
                    {
                        "username": "abderahman_ht",
                        "content": "[@Ebad1001](/Ebad1001) why the hate ?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Data element with highest frequency.\\n\\nI don\\'t believe people like you exist. Know how to code but don\\'t know even basic math."
                    },
                    {
                        "username": "geekyshark",
                        "content": "it seems you guys don\\'t read question and head straight to discussion tab"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "Mode means it\\'s the most commonly occurring number in a set of numbers."
                    },
                    {
                        "username": "Vyunish",
                        "content": "The whole definition of Binary Search Tree is Comprimised here.The elements to the right shouldn\\'t be equal to the root.The fact that he doesent want us to use extra space itself makes no sense.There is extra space both in recursion and in the output list anyways."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For whatever reason, we dont count stack space or output space when doing space complexity.  This means modifying input in place, or generating a new equally sized list both have O(1) space complexity, despite it clearly being an additional O(n) actual memory usage. Same for recuriosn stacks. We pretend they dont count for some reason. I find it pretty strange but... thats the way it goes?"
                    },
                    {
                        "username": "ilfatdance",
                        "content": "There is wrong test for [1,null,0,0,1,1,0]. \\nIt\\'s not BST."
                    },
                    {
                        "username": "grasssu",
                        "content": "If all elements frequency are equal, then there is NO mode. The judge returns every element which by definition is wrong."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@solidsnake91](/solidsnake91) How to handle this!!\\n"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "That\\'s exactly my problem. My breadth first search solution passes most test cases, but it fails when there is no mode, like you said. If a tree is [1, 2, 3] for example, those numbers that occur once don\\'t get added to my vector/arraylist, lol."
                    },
                    {
                        "username": "yuanqili",
                        "content": "The BST defined in this problem is not what common human will do.\\nThe human's way is to add a second field at each node counting the number of  duplicates.\\nIt loses all elegance of BST."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Modifying your input, particularly its structure, is *not* standard. "
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "i think htis question should be medium difficulty, it is very hard to solve"
                    },
                    {
                        "username": "eminom",
                        "content": "I got one test case from my submission:\\n[6,2,8,0,4,7,9,null,null,2,6] which is not a valid BST.\\nCould somebody explain this ?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "when you go through its inorder traversal you  will get what wrong with you."
                    },
                    {
                        "username": "adis176",
                        "content": "This is not a valid BST as per universal norms, but here for this particular question it is said that the left subtree has values smaller OR EQUAL to the root, while the right subtree has values greater OR EQUAL to the root of that particular tree. Hence as per current sum's definition, the tree is a valid one."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Open the console and click the (?) button in the upper right. They don\\'t explain this [] notation well."
                    },
                    {
                        "username": "jetleet",
                        "content": "is there any solution without traversal?taking advantage of BST\\uFF1F"
                    },
                    {
                        "username": "ahmed1999khalafallah",
                        "content": "Can any one explain the question please?"
                    },
                    {
                        "username": "ScarletPumpernickel",
                        "content": "What I\\'d like to see in the description is the push() / add() method for this variety of the BST."
                    }
                ]
            },
            {
                "id": 1810549,
                "content": [
                    {
                        "username": "ycc0602",
                        "content": "What does \"mode\" mean?"
                    },
                    {
                        "username": "abderahman_ht",
                        "content": "[@Ebad1001](/Ebad1001) why the hate ?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Data element with highest frequency.\\n\\nI don\\'t believe people like you exist. Know how to code but don\\'t know even basic math."
                    },
                    {
                        "username": "geekyshark",
                        "content": "it seems you guys don\\'t read question and head straight to discussion tab"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "Mode means it\\'s the most commonly occurring number in a set of numbers."
                    },
                    {
                        "username": "Vyunish",
                        "content": "The whole definition of Binary Search Tree is Comprimised here.The elements to the right shouldn\\'t be equal to the root.The fact that he doesent want us to use extra space itself makes no sense.There is extra space both in recursion and in the output list anyways."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For whatever reason, we dont count stack space or output space when doing space complexity.  This means modifying input in place, or generating a new equally sized list both have O(1) space complexity, despite it clearly being an additional O(n) actual memory usage. Same for recuriosn stacks. We pretend they dont count for some reason. I find it pretty strange but... thats the way it goes?"
                    },
                    {
                        "username": "ilfatdance",
                        "content": "There is wrong test for [1,null,0,0,1,1,0]. \\nIt\\'s not BST."
                    },
                    {
                        "username": "grasssu",
                        "content": "If all elements frequency are equal, then there is NO mode. The judge returns every element which by definition is wrong."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@solidsnake91](/solidsnake91) How to handle this!!\\n"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "That\\'s exactly my problem. My breadth first search solution passes most test cases, but it fails when there is no mode, like you said. If a tree is [1, 2, 3] for example, those numbers that occur once don\\'t get added to my vector/arraylist, lol."
                    },
                    {
                        "username": "yuanqili",
                        "content": "The BST defined in this problem is not what common human will do.\\nThe human's way is to add a second field at each node counting the number of  duplicates.\\nIt loses all elegance of BST."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Modifying your input, particularly its structure, is *not* standard. "
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "i think htis question should be medium difficulty, it is very hard to solve"
                    },
                    {
                        "username": "eminom",
                        "content": "I got one test case from my submission:\\n[6,2,8,0,4,7,9,null,null,2,6] which is not a valid BST.\\nCould somebody explain this ?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "when you go through its inorder traversal you  will get what wrong with you."
                    },
                    {
                        "username": "adis176",
                        "content": "This is not a valid BST as per universal norms, but here for this particular question it is said that the left subtree has values smaller OR EQUAL to the root, while the right subtree has values greater OR EQUAL to the root of that particular tree. Hence as per current sum's definition, the tree is a valid one."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Open the console and click the (?) button in the upper right. They don\\'t explain this [] notation well."
                    },
                    {
                        "username": "jetleet",
                        "content": "is there any solution without traversal?taking advantage of BST\\uFF1F"
                    },
                    {
                        "username": "ahmed1999khalafallah",
                        "content": "Can any one explain the question please?"
                    },
                    {
                        "username": "ScarletPumpernickel",
                        "content": "What I\\'d like to see in the description is the push() / add() method for this variety of the BST."
                    }
                ]
            },
            {
                "id": 2034613,
                "content": [
                    {
                        "username": "ycc0602",
                        "content": "What does \"mode\" mean?"
                    },
                    {
                        "username": "abderahman_ht",
                        "content": "[@Ebad1001](/Ebad1001) why the hate ?"
                    },
                    {
                        "username": "Ebad1001",
                        "content": "Data element with highest frequency.\\n\\nI don\\'t believe people like you exist. Know how to code but don\\'t know even basic math."
                    },
                    {
                        "username": "geekyshark",
                        "content": "it seems you guys don\\'t read question and head straight to discussion tab"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "Mode means it\\'s the most commonly occurring number in a set of numbers."
                    },
                    {
                        "username": "Vyunish",
                        "content": "The whole definition of Binary Search Tree is Comprimised here.The elements to the right shouldn\\'t be equal to the root.The fact that he doesent want us to use extra space itself makes no sense.There is extra space both in recursion and in the output list anyways."
                    },
                    {
                        "username": "cswartzell",
                        "content": "For whatever reason, we dont count stack space or output space when doing space complexity.  This means modifying input in place, or generating a new equally sized list both have O(1) space complexity, despite it clearly being an additional O(n) actual memory usage. Same for recuriosn stacks. We pretend they dont count for some reason. I find it pretty strange but... thats the way it goes?"
                    },
                    {
                        "username": "ilfatdance",
                        "content": "There is wrong test for [1,null,0,0,1,1,0]. \\nIt\\'s not BST."
                    },
                    {
                        "username": "grasssu",
                        "content": "If all elements frequency are equal, then there is NO mode. The judge returns every element which by definition is wrong."
                    },
                    {
                        "username": "Himanshu0104",
                        "content": "[@solidsnake91](/solidsnake91) How to handle this!!\\n"
                    },
                    {
                        "username": "solidsnake91",
                        "content": "That\\'s exactly my problem. My breadth first search solution passes most test cases, but it fails when there is no mode, like you said. If a tree is [1, 2, 3] for example, those numbers that occur once don\\'t get added to my vector/arraylist, lol."
                    },
                    {
                        "username": "yuanqili",
                        "content": "The BST defined in this problem is not what common human will do.\\nThe human's way is to add a second field at each node counting the number of  duplicates.\\nIt loses all elegance of BST."
                    },
                    {
                        "username": "cswartzell",
                        "content": "Modifying your input, particularly its structure, is *not* standard. "
                    },
                    {
                        "username": "denniskozevnikoff",
                        "content": "i think htis question should be medium difficulty, it is very hard to solve"
                    },
                    {
                        "username": "eminom",
                        "content": "I got one test case from my submission:\\n[6,2,8,0,4,7,9,null,null,2,6] which is not a valid BST.\\nCould somebody explain this ?"
                    },
                    {
                        "username": "21bcs069",
                        "content": "when you go through its inorder traversal you  will get what wrong with you."
                    },
                    {
                        "username": "adis176",
                        "content": "This is not a valid BST as per universal norms, but here for this particular question it is said that the left subtree has values smaller OR EQUAL to the root, while the right subtree has values greater OR EQUAL to the root of that particular tree. Hence as per current sum's definition, the tree is a valid one."
                    },
                    {
                        "username": "HapticBovine",
                        "content": "Open the console and click the (?) button in the upper right. They don\\'t explain this [] notation well."
                    },
                    {
                        "username": "jetleet",
                        "content": "is there any solution without traversal?taking advantage of BST\\uFF1F"
                    },
                    {
                        "username": "ahmed1999khalafallah",
                        "content": "Can any one explain the question please?"
                    },
                    {
                        "username": "ScarletPumpernickel",
                        "content": "What I\\'d like to see in the description is the push() / add() method for this variety of the BST."
                    }
                ]
            }
        ]
    }
]