[
    {
        "title": "Longest Turbulent Subarray",
        "question_content": "Given an integer array arr, return the length of a maximum size turbulent subarray of arr.\nA subarray is turbulent if the comparison sign flips between each adjacent pair of elements in the subarray.\nMore formally, a subarray [arr[i], arr[i + 1], ..., arr[j]] of arr is said to be turbulent if and only if:\n\n\tFor i <= k < j:\n\t\n\t\tarr[k] > arr[k + 1] when k is odd, and\n\t\tarr[k] < arr[k + 1] when k is even.\n\t\n\t\n\tOr, for i <= k < j:\n\t\n\t\tarr[k] > arr[k + 1] when k is even, and\n\t\tarr[k] < arr[k + 1] when k is odd.\n\t\n\t\n\n&nbsp;\nExample 1:\n\nInput: arr = [9,4,2,10,7,8,8,1,9]\nOutput: 5\nExplanation: arr[1] > arr[2] < arr[3] > arr[4] < arr[5]\n\nExample 2:\n\nInput: arr = [4,8,12,16]\nOutput: 2\n\nExample 3:\n\nInput: arr = [100]\nOutput: 1\n\n&nbsp;\nConstraints:\n\n\t1 <= arr.length <= 4 * 104\n\t0 <= arr[i] <= 109",
        "solutions": [
            {
                "id": 221935,
                "title": "java-o-n-time-o-1-space",
                "content": "For each `A[i]`\\n`inc`: The length of current valid sequence which ends with two **increasing** numbers\\n`dec`: The length of current valid sequence which ends with two **decreasing** numbers\\n\\n```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] A) {\\n        int inc = 1, dec = 1, result = 1;\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] < A[i - 1]) {\\n                dec = inc + 1;\\n                inc = 1;\\n            } else if (A[i] > A[i - 1]) {\\n                inc = dec + 1;\\n                dec = 1;\\n            } else {\\n                inc = 1;\\n                dec = 1;\\n            }\\n            result = Math.max(result, Math.max(dec, inc));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] A) {\\n        int inc = 1, dec = 1, result = 1;\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] < A[i - 1]) {\\n                dec = inc + 1;\\n                inc = 1;\\n            } else if (A[i] > A[i - 1]) {\\n                inc = dec + 1;\\n                dec = 1;\\n            } else {\\n                inc = 1;\\n                dec = 1;\\n            }\\n            result = Math.max(result, Math.max(dec, inc));\\n        }\\n        return result;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 221929,
                "title": "c-java-6-lines-flip-the-sign",
                "content": "We use the counter (```cnt```) to track subarray size. Our counter is positive if we expect \\'>\\', and \\'<\\' otherwise. Obviously, for each turn we flip the sign.\\n\\nIf the comparison matches the counter sign (e.g. ```A[i] > A[i + 1]``` and ``` cnt > 0``` ), we increment (or decrement the negative) counter. Otherwise, we reset the counter to 1 (or -1). One edge case here is when two numbers are equal. We set the counter to zero in this case.\\n```\\nint maxTurbulenceSize(vector<int>& A, int res = 0) {\\n  for (auto i = 0, cnt = 0; i + 1 < A.size(); ++i, cnt *= -1) {\\n    if (A[i] > A[i + 1]) cnt = cnt > 0 ? cnt + 1 : 1;\\n    else if (A[i] < A[i + 1])  cnt = cnt < 0 ? cnt - 1 : -1;\\n    else cnt = 0;\\n    res = max(res, abs(cnt));\\n  }\\n  return res + 1;\\n}\\n```\\nJava version:\\n```\\npublic int maxTurbulenceSize(int[] A) {\\n  int res = 0;\\n  for (int i = 0, cnt = 0; i + 1 < A.length; ++i, cnt *= -1) {\\n    if (A[i] > A[i + 1]) cnt = cnt > 0 ? cnt + 1 : 1;\\n    else if (A[i] < A[i + 1])  cnt = cnt < 0 ? cnt - 1 : -1;\\n    else cnt = 0;\\n    res = Math.max(res, Math.abs(cnt));\\n  }\\n  return res + 1;\\n}\\n```",
                "solutionTags": [],
                "code": "```cnt```\n```A[i] > A[i + 1]```\n``` cnt > 0```\n```\\nint maxTurbulenceSize(vector<int>& A, int res = 0) {\\n  for (auto i = 0, cnt = 0; i + 1 < A.size(); ++i, cnt *= -1) {\\n    if (A[i] > A[i + 1]) cnt = cnt > 0 ? cnt + 1 : 1;\\n    else if (A[i] < A[i + 1])  cnt = cnt < 0 ? cnt - 1 : -1;\\n    else cnt = 0;\\n    res = max(res, abs(cnt));\\n  }\\n  return res + 1;\\n}\\n```\n```\\npublic int maxTurbulenceSize(int[] A) {\\n  int res = 0;\\n  for (int i = 0, cnt = 0; i + 1 < A.length; ++i, cnt *= -1) {\\n    if (A[i] > A[i + 1]) cnt = cnt > 0 ? cnt + 1 : 1;\\n    else if (A[i] < A[i + 1])  cnt = cnt < 0 ? cnt - 1 : -1;\\n    else cnt = 0;\\n    res = Math.max(res, Math.abs(cnt));\\n  }\\n  return res + 1;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 222146,
                "title": "python-java-c-o-n-time-o-1-space-simple-and-clean-solution",
                "content": "A subarray is turbulent if the comparison sign alternates between consecutive elements (ex. ```nums[0] < nums[1] > nums[2] < nums[3] > ...``` ). Looking at the structure of the array, this means every element of a turbulent subarray must belong to either a peak ```(A[i-2] < A[i-1] > A[i])``` or a valley ```(A[i-2] > A[i-1] < A[i])``` structure.\\n\\nThe algorithm works as follows. Keep track of the length of the longest run ending at index ```i```. This is tracked in a variable named ```clen```. If the last three elements form a peak or a valley, we can extend the previous run length by 1 (meaning ```clen += 1```). Otherwise, we can no longer extend this run and need to reset ```clen``` to the length of the longest run ending at index ```i```. This run length will be ```1``` if the previous and current elements are the same (Ex: ```[2,2,2]```), or ```2``` if the previous and current elements differ (Ex: ```[2,4,6]```). The answer is the length of the best run found.\\n\\n## Python\\n```\\ndef maxTurbulenceSize(self, A):\\n    best = clen = 0\\n\\n    for i in range(len(A)):\\n        if i >= 2 and (A[i-2] > A[i-1] < A[i] or A[i-2] < A[i-1] > A[i]):\\n            clen += 1\\n        elif i >= 1 and A[i-1] != A[i]:\\n            clen = 2\\n        else:\\n            clen = 1\\n        best = max(best, clen)\\n    return best\\n```\\n## Java\\n```\\npublic int maxTurbulenceSize(int[] A) {\\n    int best = 0, clen = 0;\\n\\n    for(int i = 0; i < A.length; i++) {\\n        if(i >= 2 && ((A[i-2] > A[i-1] && A[i-1] < A[i]) ||\\n                      (A[i-2] < A[i-1] && A[i-1] > A[i])) ) {\\n            // If the last three elements are turbulent, increment run length by 1.\\n            clen++;\\n        } else if(i >= 1 && A[i-1] != A[i]) {\\n            // The last three elements are not turbulent, so we\\'ll reset the run length.\\n            // If the previous and current elements are not equal, the new run length is 2.\\n            clen = 2;\\n        } else {\\n            // Otherwise, the new run length is 1.\\n            clen = 1;\\n        }\\n        best = Math.max(best, clen);\\n    }\\n    return best;    \\n}\\n```\\n\\n## C++\\n```\\nint maxTurbulenceSize(vector<int>& A) {\\n    int best = 0, clen = 0;\\n\\n    for(int i = 0; i < A.size(); ++i) {\\n        if (i >= 2 && ((A[i-2] > A[i-1] && A[i-1] < A[i]) ||\\n                       (A[i-2] < A[i-1] && A[i-1] > A[i])) ) {\\n            clen++;\\n        } else if (i >= 1 && A[i-1] != A[i]) {\\n            clen = 2;\\n        } else {\\n            clen = 1;\\n        }\\n        best = max(best, clen);\\n    }\\n    return best;\\n}\\n```\\n",
                "solutionTags": [
                    "Java",
                    "Python",
                    "C"
                ],
                "code": "```nums[0] < nums[1] > nums[2] < nums[3] > ...```\n```(A[i-2] < A[i-1] > A[i])```\n```(A[i-2] > A[i-1] < A[i])```\n```i```\n```clen```\n```clen += 1```\n```clen```\n```i```\n```1```\n```[2,2,2]```\n```2```\n```[2,4,6]```\n```\\ndef maxTurbulenceSize(self, A):\\n    best = clen = 0\\n\\n    for i in range(len(A)):\\n        if i >= 2 and (A[i-2] > A[i-1] < A[i] or A[i-2] < A[i-1] > A[i]):\\n            clen += 1\\n        elif i >= 1 and A[i-1] != A[i]:\\n            clen = 2\\n        else:\\n            clen = 1\\n        best = max(best, clen)\\n    return best\\n```\n```\\npublic int maxTurbulenceSize(int[] A) {\\n    int best = 0, clen = 0;\\n\\n    for(int i = 0; i < A.length; i++) {\\n        if(i >= 2 && ((A[i-2] > A[i-1] && A[i-1] < A[i]) ||\\n                      (A[i-2] < A[i-1] && A[i-1] > A[i])) ) {\\n            // If the last three elements are turbulent, increment run length by 1.\\n            clen++;\\n        } else if(i >= 1 && A[i-1] != A[i]) {\\n            // The last three elements are not turbulent, so we\\'ll reset the run length.\\n            // If the previous and current elements are not equal, the new run length is 2.\\n            clen = 2;\\n        } else {\\n            // Otherwise, the new run length is 1.\\n            clen = 1;\\n        }\\n        best = Math.max(best, clen);\\n    }\\n    return best;    \\n}\\n```\n```\\nint maxTurbulenceSize(vector<int>& A) {\\n    int best = 0, clen = 0;\\n\\n    for(int i = 0; i < A.size(); ++i) {\\n        if (i >= 2 && ((A[i-2] > A[i-1] && A[i-1] < A[i]) ||\\n                       (A[i-2] < A[i-1] && A[i-1] > A[i])) ) {\\n            clen++;\\n        } else if (i >= 1 && A[i-1] != A[i]) {\\n            clen = 2;\\n        } else {\\n            clen = 1;\\n        }\\n        best = max(best, clen);\\n    }\\n    return best;\\n}\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 222511,
                "title": "dp-thinking-process-java",
                "content": ">Intuitively, we can enumerate all possible subarrays and keep track of the longest turbulent subarray.\\n\\n>After observation, we realize that the last element of the longest turbulent subarray must be one of elements in A.\\n\\nLet\\'s define \\n>state[i]: longest turbulent subarray ending at A[i]\\n\\nstate transition relies on the comparison sign between A[i - 1] and A[i], so\\n>state[i][0]: longest turbulent subarray ending at A[i] and A[i-1] < A[i]\\n>state[i][1]: longest turbulent subarray ending at A[i] and A[i-1] > A[i]\\n\\nstate transition is\\n>state[i][0] = state[i - 1][1] + 1 or 1\\n>state[i][1] = state[i - 1][0] + 1 or 1\\n\\nWe maintain `maxLen` as the maximum element in the state array.\\n\\nThe result should be `maxlen + 1`.\\n****\\n```\\n    public int maxTurbulenceSize(int[] A) {\\n        if (A.length == 0) return 0;\\n        \\n        int n = A.length, maxLen = 0;\\n        int[][] state = new int[n][2];\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (A[i - 1] < A[i]) {\\n                state[i][0] = state[i - 1][1] + 1;\\n                maxLen = Math.max(maxLen, state[i][0]);\\n            } else if (A[i - 1] > A[i]) {\\n                state[i][1] = state[i - 1][0] + 1;  \\n                maxLen = Math.max(maxLen, state[i][1]);\\n            }\\n        }\\n        \\n        return maxLen + 1;\\n    }\\n```\\n**(\\u4EBA \\u2022\\u0348\\u1D17\\u2022\\u0348)** Thanks for voting!",
                "solutionTags": [],
                "code": "```\\n    public int maxTurbulenceSize(int[] A) {\\n        if (A.length == 0) return 0;\\n        \\n        int n = A.length, maxLen = 0;\\n        int[][] state = new int[n][2];\\n        \\n        for (int i = 1; i < n; i++) {\\n            if (A[i - 1] < A[i]) {\\n                state[i][0] = state[i - 1][1] + 1;\\n                maxLen = Math.max(maxLen, state[i][0]);\\n            } else if (A[i - 1] > A[i]) {\\n                state[i][1] = state[i - 1][0] + 1;  \\n                maxLen = Math.max(maxLen, state[i][1]);\\n            }\\n        }\\n        \\n        return maxLen + 1;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1650956,
                "title": "c-standard-lis-variation-intuition-full-explanation-solution-lis",
                "content": "![image](https://assets.leetcode.com/users/images/2438ad94-c878-466a-a5bb-3c9963d4b78a_1640618760.0726762.png)\\n\\n`A few months ago , I was not able to even come through a Brute force, I was applying only Sliding window as I knew that only, But the most suitable algorithm is Dynamic Programming, That will do everything for you.`\\n\\n`Sliding Window is itself a subset of Dynamic Programming`.\\n\\nSliding Window Approach is bit complicated in this Case too.\\n\\nExplanation is a bit long but I have tried to tell the intuition behing my solution.\\n\\n# Please read LIS Below an then move forward:\\n\\nIt has 3 parts:\\n```\\nPART 1 - LIS REVISION AND HIGHLIGHTED POINT.\\nPART 2 - WHY LIS AND INTUITION\\nPART3 -  APPROACH FOR SOLVING THIS QUESTION\\n```\\n\\n# PART-1 {LIS Revision}----------------------------------\\n\\n# Revision - Longest Increasing Subsequence :\\nNote : `LIS here means Longest Increasing Subsequence`.\\n\\nThe Question is basically a variation of  `LIS`.\\n\\nYou will observe that too:\\nI would like to highlight some `very important patterns of LIS`, like you don\\'t need to cram it but it might help you.\\n\\n# In general the LIS patterns asks for following {I will use this as reference while giving intuition}:\\n```\\n1.  Longest or Smallest in terms of length.\\n2.  A chain or sequence , sequence can be one of below:\\n          I.   Subsequence.\\n          II.  Subarray.\\n          III. Any Random Order.\\n3. Every consecutive pair in that sequence must be following any of two types of property majorily:\\n         I.  This property is same throughout every pair i.e \\n\\t     \\t {Increasing or Decreasing or anything but is same between every two pair like it can be some common difference}.\\n         II. The property might be an alternative one i.e \\n\\t\\t     {the difference is alternating between every two or something like positive-negative numbers or anything which is alternating }.\\n\\t\\t\\t \\nA very good example of these type of series is AP and GP.\\n```\\n\\n\\n\\n# PART-2 {INTUITION}----------------------------------\\n\\n# Intuition and Why is this Question an extension of LIS?\\n\\nNow You can clearly Judge by seeing the above patterns very carefully, which pattern is being followed by this Question.\\n\\n`We ask these question` :\\n\\nAsk for all three similarity in above pattern highlighted :\\n\\n#   Q1. Is this question Asking for something longest or smallest in terms of length?\\n\\t Yes  {1 property of LIS satisfied}.\\n#   Q2. Is this question telling us about any sequence of above type?\\n\\tYes - Asking for a subarray { 2 property of LIS satisfied }.\\n#   Q3. Whether this question has told us about any property between consecutive pairs of that sequence?\\n\\tYes -   Asking for alternatively increasing and decreasing elements.\\n\\t        Notice very carefully -> This is the one with the second type of property we saw above in above pattern,  \\n\\t\\t\\tthat it\\'s asking for alternative similarity bewteen every pair of that sequence.\\n\\t        { 3 property of LIS satisfied }\\n\\t \\n\\t \\nNow we easily conclude that it is simply a Variation of LIS with little modification like i told above.\\n\\n\\n`How We can do?`\\nWe will do the same thing, the way we solve LIS question , like maintaing the array for length and at last return maximum.\\n\\n# PART-3 {Approach of solving with code}------------------------------\\n# First Approach:\\nThis approach follows the same sequence but here it\\'s subarray.\\n\\nWe will start from 2 index and Compare if the current pair and the last pair having opposite property{thats why we choose 2 index as we get 2 pairs for comparison} i.e: \\n1- `arr[i-2]<arr[i-1] and arr[i-1]>arr[i]`\\n2- `arr[i-2]>arr[i-1] and arr[i-1]<arr[i]`\\n\\n# Case 1-\\n\\nIf any of the above follows we simply make:\\n   `length till current = 1+ length till previous index;`\\n   \\n# Case 2-\\n\\nIf any of the property fails what then?\\n  We will consider pair of current with previous as it failed to satisfy property:\\n      `Make length till current=2 {pair of current with previous} -> A fresh start of sequence.`\\n\\t \\n#   But here is a twist, Yeah?\\n  `We ask ourself, Is the length we concluded above is actually 2 in every case`?\\n  \\n  **We ask ourself , there will be 3 cases**:\\n   ```\\n     1.  arr[i]<arr[i-1]\\n     2.  arr[i]>arr[i-1]\\n     3.  arr[i]==arr[i-1]\\n```\\n  * `Setting length as 2 is right for first 2 cases.`\\n  \\n  * `But not for 3 as it fails to follow a turbulent condition-> which says that pair should be increasing or decreasing but here it is equal.`\\n  \\n  `We set length= 1 {including current element only}`\\n  \\n  \\n#   Now you must be thinking what about index-0 and index-1?\\n  `We will do that manully before starting of loop.`\\n\\n\\nAt last we return maximum value of till every index, Like the way we do in any LIS patterns question.\\n\\n\\nNow you have to just go through code and and you are done.\\n\\n# C++:\\n\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n= size(arr);\\n        if(n==1) return 1;\\n\\t\\t\\n        int dp[n];\\n        dp[0]=1; \\n        arr[1]!=arr[0]? dp[1]=2 : dp[1]=1;      //special case for index-1\\n\\n        for(int i=2;i<n;i++){\\n            if( arr[i-2]>arr[i-1] and arr[i-1]<arr[i] or arr[i-2]<arr[i-1] and arr[i-1]>arr[i])\\n               dp[i]= dp[i-1]+1;\\n            else\\n               arr[i]!=arr[i-1]? dp[i]=2 : dp[i]=1;\\n            \\n            mx = max(mx,cnt);\\n        }\\n        \\n        return mx;\\n    }\\n\\n\\n# Second Approach: \\nIf it would have been subsequence we need to record the length so that we can check every time --> that why we needed space every time, but it\\'s subarray , you are only concerned about the previous one{We want continous}.\\n\\nNow we ask ourself that what we are actually doing?\\n```\\nWe are just increasing and resetting and updating the value in max.\\nWe are not using the length we found for previous indexes again{except for just previous} , hence we are wasting the space.\\n```\\n\\nCan\\'t we do this using a single variable.\\n\\n```\\nUsing variable we will do all things easily:\\n1. cnt will have the length found till last index which we actually want:\\n   1.1 If the property got satisfied for first , we increment cnt and we get answer for current.  \\n   1.2 If the property failed, we will reset it to 1 or 2 , and we have again the answer for current .\\n   we update in max vaiable every time using count variable.\\n```\\n\\nC++:\\n    \\n\\tint maxTurbulenceSize(vector<int>& arr) {\\n        int n= size(arr);\\n        if(n==1) return n;\\n        \\n        //int dp[n];\\n        int mx=1, cnt=1;\\n\\t\\t//for index-0 and index-1 - we handle externally{I told in previous too}\\n        if(arr[1]!=arr[0]) cnt++;\\n        mx = max(mx,cnt);\\n        \\n        for(int i=2;i<n;i++){\\n            if( arr[i-2]>arr[i-1] and arr[i-1]<arr[i] or arr[i-2]<arr[i-1] and arr[i-1]>arr[i] )\\n               cnt++;\\n            else\\n               arr[i]!=arr[i-1]? cnt=2 : cnt=1;\\n            \\n            mx = max(mx,cnt);\\n        }\\n        return mx;\\n    }\\n\\n`Hope You got, My point.`\\n\\n# Pls Upvote if you Like, If you have any questions, feel free to ask!\\n",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nPART 1 - LIS REVISION AND HIGHLIGHTED POINT.\\nPART 2 - WHY LIS AND INTUITION\\nPART3 -  APPROACH FOR SOLVING THIS QUESTION\\n```\n```\\n1.  Longest or Smallest in terms of length.\\n2.  A chain or sequence , sequence can be one of below:\\n          I.   Subsequence.\\n          II.  Subarray.\\n          III. Any Random Order.\\n3. Every consecutive pair in that sequence must be following any of two types of property majorily:\\n         I.  This property is same throughout every pair i.e \\n\\t     \\t {Increasing or Decreasing or anything but is same between every two pair like it can be some common difference}.\\n         II. The property might be an alternative one i.e \\n\\t\\t     {the difference is alternating between every two or something like positive-negative numbers or anything which is alternating }.\\n\\t\\t\\t \\nA very good example of these type of series is AP and GP.\\n```\n```\\n     1.  arr[i]<arr[i-1]\\n     2.  arr[i]>arr[i-1]\\n     3.  arr[i]==arr[i-1]\\n```\n```\\nWe are just increasing and resetting and updating the value in max.\\nWe are not using the length we found for previous indexes again{except for just previous} , hence we are wasting the space.\\n```\n```\\nUsing variable we will do all things easily:\\n1. cnt will have the length found till last index which we actually want:\\n   1.1 If the property got satisfied for first , we increment cnt and we get answer for current.  \\n   1.2 If the property failed, we will reset it to 1 or 2 , and we have again the answer for current .\\n   we update in max vaiable every time using count variable.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1464554,
                "title": "python-4-lines-dp-explained",
                "content": "Let us define `dp(i, dr)` is the longest turbulent subarray, which ends with position `i` and such that its last step was incresing if `dr = 1` and decreasing if `dr = -1`. Then:\\n\\n1. if `i == 0`, answer is `1`. Also if `(A[i] - A[i-1]) * dr >= 0`, it means that we can not continue the previous turbulent subarray, we also return `1`.\\n2. In the opposite case we return `dp(i-1, -dr) + 1`, where we change direction from `dr` to `-dr`.\\n\\n#### Complexity\\nIt is `O(n)`, because we have `O(n)` states and each state processed in `O(1)`.\\n\\n#### Code\\n```python\\nclass Solution:\\n    def maxTurbulenceSize(self, A):\\n        \\n        @lru_cache(None)\\n        def dp(i, dr):\\n            if i == 0 or (A[i] - A[i-1])*dr >= 0: return 1\\n            return dp(i-1, -dr) + 1\\n        \\n        return max(dp(i, dr) for i in range(len(A)) for dr in [-1, 1])\\n```\\n\\nIf you have any question, feel free to ask. If you like the explanations, please **Upvote!**",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```python\\nclass Solution:\\n    def maxTurbulenceSize(self, A):\\n        \\n        @lru_cache(None)\\n        def dp(i, dr):\\n            if i == 0 or (A[i] - A[i-1])*dr >= 0: return 1\\n            return dp(i-1, -dr) + 1\\n        \\n        return max(dp(i, dr) for i in range(len(A)) for dr in [-1, 1])\\n```",
                "codeTag": "Java"
            },
            {
                "id": 639545,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& A) {\\n        int increase = 1; int decrease = 1; int max_len = 1;\\n        for(int i=0; i < A.size()-1; i++){\\n            if(A[i] > A[i+1]){\\n                increase = decrease + 1;\\n                decrease = 1;\\n            }\\n            else if(A[i] < A[i+1]){\\n                decrease = increase + 1;\\n                increase = 1;\\n            }\\n            else{\\n                increase = 1;\\n                decrease = 1;\\n            }\\n            max_len = max(max_len, max(increase, decrease));\\n        }\\n        return max_len;\\n    }\\n};\\n```\\n\\nThis solution works by keeping track of 2 variables increasing and decreasing while we traverse the whole array, where 3 general cases are possible. If while we are traversing the array is valid we will be handing off the value between inc and decrease, adding one by each time. However, if at any point we reach 2 of the same sign in a row, the value gets pulled back down 2 only. The third case is if the values are equal then, the value gets pulled down to 1.\\nAt every iteration we check if increase or decrease has a value greater than the current max_len we have.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& A) {\\n        int increase = 1; int decrease = 1; int max_len = 1;\\n        for(int i=0; i < A.size()-1; i++){\\n            if(A[i] > A[i+1]){\\n                increase = decrease + 1;\\n                decrease = 1;\\n            }\\n            else if(A[i] < A[i+1]){\\n                decrease = increase + 1;\\n                increase = 1;\\n            }\\n            else{\\n                increase = 1;\\n                decrease = 1;\\n            }\\n            max_len = max(max_len, max(increase, decrease));\\n        }\\n        return max_len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 230734,
                "title": "c-well-commented-solution-with-explanation-using-dp",
                "content": "```\\n/* Note -- The space complexity can be further reduced to O(1) by using\\n           2 temporary variables for dp_greater[i+1] and dp_lesser[i+1]\\n           since we only need these to calculate dp[i] */\\nclass Solution\\n{\\npublic:\\n    int maxTurbulenceSize(vector<int>& A);\\n};\\n\\n/* Returns the length of the longest turbulent subarray */\\nint Solution :: maxTurbulenceSize(vector<int>& a)\\n{\\n    // Get the size\\n    int n = a.size();\\n    \\n    // Handle the corner case\\n    if(n==0) return 0;\\n    if(n==1) return 1;\\n    \\n    int dp_greater[n];\\n    int dp_lesser[n];\\n    \\n    /* dp_greater[i] represents the longest turbulent subarray starting at i such that the first element of \\n       the turbulent subarray is greater than the second */\\n    \\n    /* dp_lesser[i] represents the longest turbulent subarray starting at i such that the first element of \\n       the turbulent subarray is less than the second */\\n    \\n    // Initialise the dp array\\n    // dp[i] is atleast 1 for each element, i.e, the element itself\\n    for(int i=0; i<n ;i++)\\n    {\\n        dp_greater[i] = 1;\\n        dp_lesser[i] = 1;\\n    }\\n\\n    // Update the dp matrix starting from the second last element\\n    for(int i=n-2; i>=0; i--)\\n    {\\n        // If this is greater than right neighbour, append it to the lesser_turbulent subarray of the right\\n        if(a[i] > a[i+1])\\n            dp_greater[i] = dp_lesser[i+1] + 1;\\n        \\n        // Else, if it is less than the right element, append it to the greater_turbulent subarray of the right\\n        else if(a[i] < a[i+1])\\n            dp_lesser[i] = dp_greater[i+1] + 1;\\n    }\\n    \\n    // Claculate the maximum length subarray starting at any arbitrary index\\n    int maxLength = 0;\\n    for(int i=0; i<n; i++)\\n        maxLength = max({maxLength, dp_greater[i], dp_lesser[i]});\\n    \\n    // Return the maxLength turbulent subarray\\n    return maxLength;\\n}\\n\\n```",
                "solutionTags": [],
                "code": "```\\n/* Note -- The space complexity can be further reduced to O(1) by using\\n           2 temporary variables for dp_greater[i+1] and dp_lesser[i+1]\\n           since we only need these to calculate dp[i] */\\nclass Solution\\n{\\npublic:\\n    int maxTurbulenceSize(vector<int>& A);\\n};\\n\\n/* Returns the length of the longest turbulent subarray */\\nint Solution :: maxTurbulenceSize(vector<int>& a)\\n{\\n    // Get the size\\n    int n = a.size();\\n    \\n    // Handle the corner case\\n    if(n==0) return 0;\\n    if(n==1) return 1;\\n    \\n    int dp_greater[n];\\n    int dp_lesser[n];\\n    \\n    /* dp_greater[i] represents the longest turbulent subarray starting at i such that the first element of \\n       the turbulent subarray is greater than the second */\\n    \\n    /* dp_lesser[i] represents the longest turbulent subarray starting at i such that the first element of \\n       the turbulent subarray is less than the second */\\n    \\n    // Initialise the dp array\\n    // dp[i] is atleast 1 for each element, i.e, the element itself\\n    for(int i=0; i<n ;i++)\\n    {\\n        dp_greater[i] = 1;\\n        dp_lesser[i] = 1;\\n    }\\n\\n    // Update the dp matrix starting from the second last element\\n    for(int i=n-2; i>=0; i--)\\n    {\\n        // If this is greater than right neighbour, append it to the lesser_turbulent subarray of the right\\n        if(a[i] > a[i+1])\\n            dp_greater[i] = dp_lesser[i+1] + 1;\\n        \\n        // Else, if it is less than the right element, append it to the greater_turbulent subarray of the right\\n        else if(a[i] < a[i+1])\\n            dp_lesser[i] = dp_greater[i+1] + 1;\\n    }\\n    \\n    // Claculate the maximum length subarray starting at any arbitrary index\\n    int maxLength = 0;\\n    for(int i=0; i<n; i++)\\n        maxLength = max({maxLength, dp_greater[i], dp_lesser[i]});\\n    \\n    // Return the maxLength turbulent subarray\\n    return maxLength;\\n}\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466175,
                "title": "python-bottom-up-dp-o-1-space-clean-concise",
                "content": "**\\u2714\\uFE0F Solution 1: Bottom up DP**\\n- Let `dpLow[i]` denote the longest turbulent subarray end at `arr[i]` with `arr[i-1] > arr[i]`.\\n- Let `dpHigh[i]` denote the longest turbulent subarray end at `arr[i]` with `arr[i-1] < arr[i]`.\\n```python\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dpLow, dpHigh = [1] * n, [1] * n\\n        ans = 1\\n        for i in range(1, n):\\n            if arr[i-1] < arr[i]:\\n                dpHigh[i] = dpLow[i-1] + 1\\n            elif arr[i-1] > arr[i]:\\n                dpLow[i] = dpHigh[i-1] + 1\\n            ans = max(ans, dpHigh[i], dpLow[i])\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 4*10^4` is length of `arr` array.\\n- Space: `O(N)`\\n\\n---\\n**\\u2714\\uFE0F Solution 2: Bottom up DP (Space Optimized)**\\n- Since our dp only access up to 2 states: current state `dp` and previous state `dpPrev` so we can optimize to O(1) in space.\\n```python\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dpLow, dpLowPrev = 1, 1\\n        dpHigh, dpHighPrev = 1, 1\\n        ans = 1\\n        for i in range(1, n):\\n            if arr[i-1] < arr[i]:\\n                dpHigh = dpLowPrev + 1\\n                dpHighPrev = dpHigh\\n                dpLowPrev = 1\\n            elif arr[i-1] > arr[i]:\\n                dpLow = dpHighPrev + 1\\n                dpLowPrev = dpLow\\n                dpHighPrev = 1\\n            else:\\n                dpLowPrev = dpHighPrev = 1\\n            ans = max(ans, dpHigh, dpLow)\\n        return ans\\n```\\n**Complexity**\\n- Time: `O(N)`, where `N <= 4*10^4` is length of `arr` array.\\n- Space: `O(1)`",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dpLow, dpHigh = [1] * n, [1] * n\\n        ans = 1\\n        for i in range(1, n):\\n            if arr[i-1] < arr[i]:\\n                dpHigh[i] = dpLow[i-1] + 1\\n            elif arr[i-1] > arr[i]:\\n                dpLow[i] = dpHigh[i-1] + 1\\n            ans = max(ans, dpHigh[i], dpLow[i])\\n        return ans\\n```\n```python\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        dpLow, dpLowPrev = 1, 1\\n        dpHigh, dpHighPrev = 1, 1\\n        ans = 1\\n        for i in range(1, n):\\n            if arr[i-1] < arr[i]:\\n                dpHigh = dpLowPrev + 1\\n                dpHighPrev = dpHigh\\n                dpLowPrev = 1\\n            elif arr[i-1] > arr[i]:\\n                dpLow = dpHighPrev + 1\\n                dpLowPrev = dpLow\\n                dpHighPrev = 1\\n            else:\\n                dpLowPrev = dpHighPrev = 1\\n            ans = max(ans, dpHigh, dpLow)\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 529267,
                "title": "python-o-n-by-kadane-algorithm-w-hint",
                "content": "Python O(n) by 1-pass scan.\\n\\n---\\n\\n**Hint**:\\n\\nTurbulent can be viewed as a sequence of continuous combination of **\\u2197** and **\\u2198**\\nFor example, \\nboth \\n\"1 **\\u2197** 10 **\\u2198** 3 **\\u2197** 8 **\\u2198** 5\", and \\n\"9 **\\u2198** 1 **\\u2197** 8 **\\u2198** 2 **\\u2197** 7\" \\nare turbulent with length = 5\\n\\nDefine \\n**prev difference** = A[i] - A[i-1], and\\n**post difference** = A[i+1] - A[i]\\n\\nIf **prev difference** x **post difference** < 0, which means either **\\u2197\\u2198** or **\\u2198\\u2197** shows up,\\nwe can **extend length of current turbulent subarray** by adding one.\\n\\nThen, update to max turbulent length if current length > orginal one.\\n\\nOtherwise, turbulent subarray restarts from current position.\\n\\n\\n---\\n\\n```\\nclass Solution:\\n    def maxTurbulenceSize(self, A: List[int]) -> int:\\n        \\n        \\n        size = len(A)\\n        \\n        if size == 1:\\n            return 1\\n        \\n        cur_turbu_length = 1 + ( A[0] != A[1] )\\n        \\n        max_length = cur_turbu_length\\n        \\n        prev_diff = A[1] - A[0]\\n        \\n        for i in range(1, size-1):\\n            post_diff = A[i+1] - A[i]\\n            \\n            if prev_diff*post_diff < 0:\\n                # turbulent subarray can extend from previous element to next element\\n                cur_turbu_length += 1\\n            \\n            else:\\n                # turbulent subarray restarts here\\n                cur_turbu_length = 1 + (post_diff != 0)\\n            \\n            \\n            max_length = max( max_length, cur_turbu_length )\\n            \\n            # update pre_diff for next iteration\\n            prev_diff = post_diff\\n            \\n        return max_length\\n```\\n\\n---\\n\\nRelated leetcode challenge:\\n[Leetcode #53 Maximum Subarray](https://leetcode.com/problems/maximum-subarray/)\\n\\n[Leetcode #152 Maximum Product Subarray](https://leetcode.com/problems/maximum-product-subarray/)\\n\\n---\\n\\nReference:\\n\\n[1] [Wiki: Kadane algorihm and Maximum subarray](https://en.wikipedia.org/wiki/Maximum_subarray_problem#Kadane\\'s_algorithm)",
                "solutionTags": [
                    "Python",
                    "Iterator"
                ],
                "code": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, A: List[int]) -> int:\\n        \\n        \\n        size = len(A)\\n        \\n        if size == 1:\\n            return 1\\n        \\n        cur_turbu_length = 1 + ( A[0] != A[1] )\\n        \\n        max_length = cur_turbu_length\\n        \\n        prev_diff = A[1] - A[0]\\n        \\n        for i in range(1, size-1):\\n            post_diff = A[i+1] - A[i]\\n            \\n            if prev_diff*post_diff < 0:\\n                # turbulent subarray can extend from previous element to next element\\n                cur_turbu_length += 1\\n            \\n            else:\\n                # turbulent subarray restarts here\\n                cur_turbu_length = 1 + (post_diff != 0)\\n            \\n            \\n            max_length = max( max_length, cur_turbu_length )\\n            \\n            # update pre_diff for next iteration\\n            prev_diff = post_diff\\n            \\n        return max_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 223080,
                "title": "python-simple-o-n",
                "content": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        criteriaOneCounter = 1\\n        criteriaTwoCounter = 1\\n        maxTurbulence = 1\\n        for i in range(len(A)-1):\\n            criteriaOneCounter = criteriaOneCounter + 1 if ((i % 2 != 0 and A[i] > A[i+1]) or (i % 2 == 0 and A[i] < A[i+1])) else 1\\n            criteriaTwoCounter = criteriaTwoCounter + 1 if ((i % 2 == 0 and A[i] > A[i+1]) or (i % 2 != 0 and A[i] < A[i+1])) else 1\\n            maxTurbulence = max(maxTurbulence, criteriaOneCounter, criteriaTwoCounter)\\n        return maxTurbulence\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, A):\\n        \"\"\"\\n        :type A: List[int]\\n        :rtype: int\\n        \"\"\"\\n        criteriaOneCounter = 1\\n        criteriaTwoCounter = 1\\n        maxTurbulence = 1\\n        for i in range(len(A)-1):\\n            criteriaOneCounter = criteriaOneCounter + 1 if ((i % 2 != 0 and A[i] > A[i+1]) or (i % 2 == 0 and A[i] < A[i+1])) else 1\\n            criteriaTwoCounter = criteriaTwoCounter + 1 if ((i % 2 == 0 and A[i] > A[i+1]) or (i % 2 != 0 and A[i] < A[i+1])) else 1\\n            maxTurbulence = max(maxTurbulence, criteriaOneCounter, criteriaTwoCounter)\\n        return maxTurbulence\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2260177,
                "title": "c-easy-explanation-kadane-s-extension-sliding-window",
                "content": "## Logic\\n- This problem is the extension of ***kadane\\'s algorithm***.\\n- Below in the code I have explained everything and its execution you can find in the dry run done below.\\n\\n## Implementation\\n```\\nint maxTurbulenceSize(vector<int>& arr) {\\n    //From the conditions given to be followed \\n    //we have to find the maximum count of one type of pattern whether \\n    //the k is even or whether it is odd.        \\n        int ans = 1;\\n        int smaller = 1;\\n        int larger = 1;\\n    //A pattern is alternating itself if at any k(odd) arr[k]>arr[k+1] then\\n    //at the next it has to follow arr[k]<arr[k+1] as k will be even.\\n    //If the pattern is not followed then it will switch to counting in \\n    //the next pattern\\n        for (int i = 0; i < arr.size() - 1; ++i) {\\n    //We have taken 2 pointers smaller and larger which helps us in switching\\n    //between patterns\\n    //and counting the parts of specific pattern\\n            smaller = arr[i] < arr[i + 1] ? smaller + 1 : 1;\\n            larger = arr[i] > arr[i + 1] ? larger + 1 : 1;\\n            \\n            ans = max(ans, max(smaller, larger));\\n            //Decide which pattern count is high\\n            swap(smaller, larger);\\n            //Maintaining the alternating condition in the pattern\\n        }\\n        return ans;\\n    }\\n```\\n\\n## Dry Run\\n\\n![Turbulent Array](https://assets.leetcode.com/users/images/bb89e3fe-5b62-484a-822c-148e591b071f_1657393384.1781576.jpeg)\\n\\n- TC - O(N)\\n\\n**Thank You!** for reading . Do upvote\\uD83D\\uDC4D if you like the explanation and if there is any scope of improvement do mention it in the comments \\uD83D\\uDE01.\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint maxTurbulenceSize(vector<int>& arr) {\\n    //From the conditions given to be followed \\n    //we have to find the maximum count of one type of pattern whether \\n    //the k is even or whether it is odd.        \\n        int ans = 1;\\n        int smaller = 1;\\n        int larger = 1;\\n    //A pattern is alternating itself if at any k(odd) arr[k]>arr[k+1] then\\n    //at the next it has to follow arr[k]<arr[k+1] as k will be even.\\n    //If the pattern is not followed then it will switch to counting in \\n    //the next pattern\\n        for (int i = 0; i < arr.size() - 1; ++i) {\\n    //We have taken 2 pointers smaller and larger which helps us in switching\\n    //between patterns\\n    //and counting the parts of specific pattern\\n            smaller = arr[i] < arr[i + 1] ? smaller + 1 : 1;\\n            larger = arr[i] > arr[i + 1] ? larger + 1 : 1;\\n            \\n            ans = max(ans, max(smaller, larger));\\n            //Decide which pattern count is high\\n            swap(smaller, larger);\\n            //Maintaining the alternating condition in the pattern\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1338882,
                "title": "two-pointer-solution-c-o-n-sliding-window",
                "content": "```\\n//two pointer solution\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n         int i = 1;\\n         int j = 1; \\n         int max_len = 1;\\n        //two pointer soluton\\n        \\n        \\n        for(int k=0; k < arr.size()-1; k++){\\n            \\n            if(arr[k] > arr[k+1]){\\n                i = j+1;\\n                j=1;\\n            \\n            }\\n            \\n            else if(arr[k] < arr[k+1]){\\n                j = i + 1;\\n                i = 1;\\n            }\\n           \\n            else{\\n                i = 1;\\n                j = 1;\\n            }\\n            max_len = max(max_len, max(i, j));\\n        }\\n        return max_len;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Two Pointers",
                    "Sliding Window"
                ],
                "code": "```\\n//two pointer solution\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n         int i = 1;\\n         int j = 1; \\n         int max_len = 1;\\n        //two pointer soluton\\n        \\n        \\n        for(int k=0; k < arr.size()-1; k++){\\n            \\n            if(arr[k] > arr[k+1]){\\n                i = j+1;\\n                j=1;\\n            \\n            }\\n            \\n            else if(arr[k] < arr[k+1]){\\n                j = i + 1;\\n                i = 1;\\n            }\\n           \\n            else{\\n                i = 1;\\n                j = 1;\\n            }\\n            max_len = max(max_len, max(i, j));\\n        }\\n        return max_len;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466193,
                "title": "python3-sliding-window",
                "content": "```\\ndef maxTurbulenceSize(self, arr):\\n        n = len(arr)\\n        l, r = 0, 0\\n        ans = 1\\n        if n == 1:\\n\\t\\t\\treturn 1\\n        while r < n:\\n            while l < n - 1 and arr[l] == arr[l+1]: # to handle duplicates\\n                l += 1\\n            while r < n - 1 and (arr[r-1] > arr[r] < arr[r+1] or arr[r-1] < arr[r] > arr[r+1]):\\n                r += 1\\n            ans=max(ans, r - l + 1)\\n            l = r\\n            r += 1\\n        return ans\\n\\t\\t\\nTime Complexity - O(N)\\nSpace Complexity - O(1)",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef maxTurbulenceSize(self, arr):\\n        n = len(arr)\\n        l, r = 0, 0\\n        ans = 1\\n        if n == 1:\\n\\t\\t\\treturn 1\\n        while r < n:\\n            while l < n - 1 and arr[l] == arr[l+1]: # to handle duplicates\\n                l += 1\\n            while r < n - 1 and (arr[r-1] > arr[r] < arr[r+1] or arr[r-1] < arr[r] > arr[r+1]):\\n                r += 1\\n            ans=max(ans, r - l + 1)\\n            l = r\\n            r += 1\\n        return ans\\n\\t\\t\\nTime Complexity - O(N)\\nSpace Complexity - O(1)",
                "codeTag": "Python3"
            },
            {
                "id": 1465283,
                "title": "c-easy-o-n-longest-turbulent-subarray",
                "content": "If three numbers form a turbulent array then the number in middle will be either less than or greater than both predecessor and successor, so at an index **i** it will be turbulent if **arr[i] - ar[i-1]** and **arr[i] - ar[i+1]** are of same sign, ie their product must be positive.\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n<2) return n;\\n        \\n        int total=1,maxim=0;\\n        \\n        for(int i=1;i<n;i++){\\n            if(arr[i]!=arr[i-1]) total++;\\n            \\n            while(i<n-1 && (arr[i] - arr[i-1])/10000.0 * (arr[i] - arr[i+1])/10000.0>0){ \\n\\t\\t\\t//division by 10000.0 inroder to avoid integer overflow.\\n                \\n                total++;\\n                i++;\\n            }\\n            maxim = max(total,maxim);\\n            total=1;\\n        }\\n        return maxim;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n=arr.size();\\n        if(n<2) return n;\\n        \\n        int total=1,maxim=0;\\n        \\n        for(int i=1;i<n;i++){\\n            if(arr[i]!=arr[i-1]) total++;\\n            \\n            while(i<n-1 && (arr[i] - arr[i-1])/10000.0 * (arr[i] - arr[i+1])/10000.0>0){ \\n\\t\\t\\t//division by 10000.0 inroder to avoid integer overflow.\\n                \\n                total++;\\n                i++;\\n            }\\n            maxim = max(total,maxim);\\n            total=1;\\n        }\\n        return maxim;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 263982,
                "title": "java-2-solutions-for-better-understanding-sliding-window-problem-beats-99-in-time-and-space",
                "content": "2 Solutions - \\n\\n***Solution 1*** is verbose but helps understand how the solution should work  - \\nBelow is an image for example - \\n\\n![image](https://assets.leetcode.com/users/kshipra/image_1553798895.png)\\n\\n**Solution 1:**\\n```\\npublic int maxTurbulenceSize(int[] A) {\\n\\t\\tint result = 0;\\n\\t\\t\\n\\t\\tint[] mem = new int[A.length];\\n\\t\\tchar lastSign = \\'=\\';\\n\\t\\t\\n\\t\\tif(A.length == 1)\\n\\t\\t\\treturn 1;\\n\\t\\t\\n\\t\\tfor(int i = 1; i < A.length; i++) {\\n\\t\\t\\tint comp = Integer,\\n\\t\\t\\t\\tif(lastSign==\\'>\\') {\\n\\t\\t\\t\\t\\tmem[i]=mem[i-1]+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tmem[i]=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlastSign=\\'<\\';\\n\\t\\t\\t}\\n\\t\\t\\telse if(A[i] > A[i-1]) {\\n\\t\\t\\t\\tif(lastSign==\\'<\\') {\\n\\t\\t\\t\\t\\tmem[i]=mem[i-1]+1;\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tmem[i]=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlastSign=\\'>\\';\\n\\t\\t\\t}\\n\\t\\t\\telse if(A[i]==A[i-1]) {\\n\\t\\t\\t\\tmem[i]=1;\\n\\t\\t\\t\\tlastSign=\\'=\\';\\n\\t\\t\\t}\\n\\t\\t\\tresult=Math.max(result, mem[i]);\\n\\t\\t}\\n\\t\\treturn result;\\n        \\n    }\\n```\\n\\n***Solution 2*** is simplification of the above code - \\n\\n**Solution 2**\\n\\n```\\n    public int maxTurbulenceSize(int[] A) {\\n\\t\\n       int result = 0;\\n\\t\\t\\n\\t\\tint[] mem = new int[A.length];\\n\\t\\tint prev = 0;\\n\\t\\t\\n\\t\\tif(A.length == 1)\\n\\t\\t\\treturn 1;\\n\\t\\t\\n\\t\\tfor(int i = 1; i < A.length; i++) {\\n\\t\\t\\tint comp = Integer.compare(A[i],A[i-1]);\\n\\t\\t\\t\\tif(comp == 0) {\\n\\t\\t\\t\\t\\tmem[i] = 1;\\n\\t\\t\\t\\t} else if(comp == prev || (prev == 0 && comp != 0)) {\\n\\t\\t\\t\\t\\tmem[i]=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif((comp == 1 && prev == -1) || (prev == 1 && comp == -1)) {\\n\\t\\t\\t\\t\\tmem[i]=mem[i-1]+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tresult=Math.max(result, mem[i]);\\n\\t\\t\\t\\tprev = comp;\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxTurbulenceSize(int[] A) {\\n\\t\\tint result = 0;\\n\\t\\t\\n\\t\\tint[] mem = new int[A.length];\\n\\t\\tchar lastSign = \\'=\\';\\n\\t\\t\\n\\t\\tif(A.length == 1)\\n\\t\\t\\treturn 1;\\n\\t\\t\\n\\t\\tfor(int i = 1; i < A.length; i++) {\\n\\t\\t\\tint comp = Integer,\\n\\t\\t\\t\\tif(lastSign==\\'>\\') {\\n\\t\\t\\t\\t\\tmem[i]=mem[i-1]+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tmem[i]=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlastSign=\\'<\\';\\n\\t\\t\\t}\\n\\t\\t\\telse if(A[i] > A[i-1]) {\\n\\t\\t\\t\\tif(lastSign==\\'<\\') {\\n\\t\\t\\t\\t\\tmem[i]=mem[i-1]+1;\\n\\t\\t\\t\\t} \\n\\t\\t\\t\\telse {\\n\\t\\t\\t\\t\\tmem[i]=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlastSign=\\'>\\';\\n\\t\\t\\t}\\n\\t\\t\\telse if(A[i]==A[i-1]) {\\n\\t\\t\\t\\tmem[i]=1;\\n\\t\\t\\t\\tlastSign=\\'=\\';\\n\\t\\t\\t}\\n\\t\\t\\tresult=Math.max(result, mem[i]);\\n\\t\\t}\\n\\t\\treturn result;\\n        \\n    }\\n```\n```\\n    public int maxTurbulenceSize(int[] A) {\\n\\t\\n       int result = 0;\\n\\t\\t\\n\\t\\tint[] mem = new int[A.length];\\n\\t\\tint prev = 0;\\n\\t\\t\\n\\t\\tif(A.length == 1)\\n\\t\\t\\treturn 1;\\n\\t\\t\\n\\t\\tfor(int i = 1; i < A.length; i++) {\\n\\t\\t\\tint comp = Integer.compare(A[i],A[i-1]);\\n\\t\\t\\t\\tif(comp == 0) {\\n\\t\\t\\t\\t\\tmem[i] = 1;\\n\\t\\t\\t\\t} else if(comp == prev || (prev == 0 && comp != 0)) {\\n\\t\\t\\t\\t\\tmem[i]=2;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif((comp == 1 && prev == -1) || (prev == 1 && comp == -1)) {\\n\\t\\t\\t\\t\\tmem[i]=mem[i-1]+1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tresult=Math.max(result, mem[i]);\\n\\t\\t\\t\\tprev = comp;\\n\\t\\t}\\n\\t\\treturn result;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1465113,
                "title": "c-easy-to-understand-concise-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int m=arr.size(),res=0,cnt=0;\\n        vector<int>ans;\\n        for(int i=1;i<m;i++)\\n        {\\n             ans.push_back(arr[i]==arr[i-1]?-1:(arr[i]>arr[i-1])?1:0);\\n            /* these lines are equivalent to above 1 line \\n            if(arr[i]==arr[i-1])\\n                ans.push_back(-1);\\n            else if(arr[i]>arr[i-1])\\n                ans.push_back(1);\\n            else\\n                ans.push_back(0); */\\n        }\\n        for(int i=0;i<m-1;i++)\\n        {\\n            if(i==0 && ans[i]!=-1)\\n                cnt++;\\n            else if(ans[i]==-1)\\n                cnt=0;\\n            else{\\n                if(ans[i]!=ans[i-1])\\n                   cnt++;\\n                else\\n                    cnt=1;    \\n            }\\n            res=max(res,cnt);\\n        }\\n        return res+1;\\n    }\\n};\\n```\\n**Same approach as above but with O(1) space.**\\n```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int m=arr.size(),res=0,cnt=0,prev=0,cur;\\n        if(m>=2)\\n        {\\n            res=cnt=arr[1]!=arr[0]?1:0;\\n              prev=arr[1]>arr[0]?1:-1;\\n        }\\n        for(int i=2;i<m;i++)\\n        {\\n            if(arr[i]==arr[i-1])\\n            {\\n                cnt=0;  prev=0;\\n               continue;\\n            }\\n            else\\n            {\\n\\t\\t\\t   cur=arr[i]>arr[i-1]?1:-1;\\n               cnt= prev==0?1:cur!=prev?cnt+1:1;\\n\\t\\t\\t   /* these lines are equivalent to above two lines\\n                if(prev==0)\\n                    cnt++;\\n                else\\n                {\\n                  cur=arr[i]>arr[i-1]?1:-1;\\n                   cnt=cur!=prev?cnt+1:1;\\n                }   */\\n            }\\n         prev=arr[i]>arr[i-1]?1:-1;\\n              res=max(res,cnt);  \\n        }\\n        return res+1;\\n    }\\n};\\n```\\nDo UPVOTE if it helps :)",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int m=arr.size(),res=0,cnt=0;\\n        vector<int>ans;\\n        for(int i=1;i<m;i++)\\n        {\\n             ans.push_back(arr[i]==arr[i-1]?-1:(arr[i]>arr[i-1])?1:0);\\n            /* these lines are equivalent to above 1 line \\n            if(arr[i]==arr[i-1])\\n                ans.push_back(-1);\\n            else if(arr[i]>arr[i-1])\\n                ans.push_back(1);\\n            else\\n                ans.push_back(0); */\\n        }\\n        for(int i=0;i<m-1;i++)\\n        {\\n            if(i==0 && ans[i]!=-1)\\n                cnt++;\\n            else if(ans[i]==-1)\\n                cnt=0;\\n            else{\\n                if(ans[i]!=ans[i-1])\\n                   cnt++;\\n                else\\n                    cnt=1;    \\n            }\\n            res=max(res,cnt);\\n        }\\n        return res+1;\\n    }\\n};\\n```\n```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int m=arr.size(),res=0,cnt=0,prev=0,cur;\\n        if(m>=2)\\n        {\\n            res=cnt=arr[1]!=arr[0]?1:0;\\n              prev=arr[1]>arr[0]?1:-1;\\n        }\\n        for(int i=2;i<m;i++)\\n        {\\n            if(arr[i]==arr[i-1])\\n            {\\n                cnt=0;  prev=0;\\n               continue;\\n            }\\n            else\\n            {\\n\\t\\t\\t   cur=arr[i]>arr[i-1]?1:-1;\\n               cnt= prev==0?1:cur!=prev?cnt+1:1;\\n\\t\\t\\t   /* these lines are equivalent to above two lines\\n                if(prev==0)\\n                    cnt++;\\n                else\\n                {\\n                  cur=arr[i]>arr[i-1]?1:-1;\\n                   cnt=cur!=prev?cnt+1:1;\\n                }   */\\n            }\\n         prev=arr[i]>arr[i-1]?1:-1;\\n              res=max(res,cnt);  \\n        }\\n        return res+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 225616,
                "title": "java-dp-solution-beat-100-o-n-time-o-1-space",
                "content": "\\n```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] A) {\\n        if (A == null || A.length == 0) {\\n            return 0;\\n        }\\n        int res = 1;\\n        int pattern1 = 1, pattern2 = 1;\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] > A[i - 1]) {\\n                pattern1 = pattern2 + 1;\\n                pattern2 = 1;\\n                res = Math.max(res, pattern1);\\n            } else if (A[i] < A[i - 1]) {\\n                pattern2 = pattern1 + 1;\\n                pattern1 = 1;\\n                res = Math.max(res, pattern2);\\n            } else {\\n                pattern1 = 1;\\n                pattern2 = 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] A) {\\n        if (A == null || A.length == 0) {\\n            return 0;\\n        }\\n        int res = 1;\\n        int pattern1 = 1, pattern2 = 1;\\n        for (int i = 1; i < A.length; i++) {\\n            if (A[i] > A[i - 1]) {\\n                pattern1 = pattern2 + 1;\\n                pattern2 = 1;\\n                res = Math.max(res, pattern1);\\n            } else if (A[i] < A[i - 1]) {\\n                pattern2 = pattern1 + 1;\\n                pattern1 = 1;\\n                res = Math.max(res, pattern2);\\n            } else {\\n                pattern1 = 1;\\n                pattern2 = 1;\\n            }\\n        }\\n        return res;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2333439,
                "title": "clean-easy-dp-solution-fully-explained",
                "content": "For each a[i], \\nthere can be 2 states where a[i]>a[i-1] and a[i]<a[i-1], we explore both the cases and store the max.\\n\\ndp1[i] represents the longest turbulent subaray ending at i, where a[i]>a[i-1], and thus current dp1[i] would be calculated from dp2[i-1] coz  dp2[i-1] represents the longest turbulent subaray ending at i-1, where a[i-1]<a[i-2]\\nand thus we mainatin the turbulant property.\\n\\nthe same reverse logic is  applied for dp2[i] and then we calculate the max of both the cases of  \">\" and \"<\" of a[i] and store in in maxi.\\n\\nHow this intuition? This is a standard LIS variant where we store the answers of the prevs index and then use it for current index, here we had to store 2 states of possibitlites and choose the best out of it\\n\\nA  dry run on a testcase would improve understanding of why it works\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& a) {\\n        int n=a.size(), maxi=1;\\n        vector<int> dp1(n,1);\\n        vector<int> dp2(n,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(a[i]>a[i-1]) dp1[i]=1+dp2[i-1];\\n            else if(a[i]<a[i-1]) dp2[i]=1+dp1[i-1];\\n            maxi=max(maxi,max(dp1[i],dp2[i]));\\n        }\\n        return maxi;\\n    }\\n};\\n```\\n\\n**PLZ UPVOTE!!!**",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& a) {\\n        int n=a.size(), maxi=1;\\n        vector<int> dp1(n,1);\\n        vector<int> dp2(n,1);\\n        for(int i=1;i<n;i++)\\n        {\\n            if(a[i]>a[i-1]) dp1[i]=1+dp2[i-1];\\n            else if(a[i]<a[i-1]) dp2[i]=1+dp1[i-1];\\n            maxi=max(maxi,max(dp1[i],dp2[i]));\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 787970,
                "title": "javascript-solution-dp-approach",
                "content": "The way I approached the problem is to think of it like a variant of Kadane\\'s Algorithm. I reset the `oddTurb`\\'s and `evenTurb`\\'s length whenever it didn\\'t meet the definitions described in the question.\\n\\n```\\nvar maxTurbulenceSize = function(A) {\\n    let oddTurb = 1;  /* turbulent if A[k] < A[k+1] when k is even, and A[k] < A[k+1] when k is even */\\n    let evenTurb = 1; /* turbulent if A[k] > A[k+1] when k is even, and A[k] < A[k+1] when k is odd */\\n    let maxLen = 1;\\n    \\n    for (let k = 0; k < A.length - 1; k++) {\\n        if (k % 2 == 1) { // when k is odd\\n            oddTurb = (A[k] > A[k + 1]) ? oddTurb + 1 : 1;\\n            evenTurb = (A[k] < A[k + 1]) ? evenTurb + 1 : 1;\\n        }\\n        else { // when k is even\\n            evenTurb = (A[k] > A[k + 1]) ? evenTurb + 1 : 1;\\n            oddTurb = (A[k] < A[k + 1]) ? oddTurb + 1 : 1;\\n        }\\n        \\n        maxLen = Math.max(maxLen, oddTurb, evenTurb);\\n    }\\n    \\n    return maxLen;\\n};\\n```",
                "solutionTags": [
                    "JavaScript",
                    "Dynamic Programming"
                ],
                "code": "```\\nvar maxTurbulenceSize = function(A) {\\n    let oddTurb = 1;  /* turbulent if A[k] < A[k+1] when k is even, and A[k] < A[k+1] when k is even */\\n    let evenTurb = 1; /* turbulent if A[k] > A[k+1] when k is even, and A[k] < A[k+1] when k is odd */\\n    let maxLen = 1;\\n    \\n    for (let k = 0; k < A.length - 1; k++) {\\n        if (k % 2 == 1) { // when k is odd\\n            oddTurb = (A[k] > A[k + 1]) ? oddTurb + 1 : 1;\\n            evenTurb = (A[k] < A[k + 1]) ? evenTurb + 1 : 1;\\n        }\\n        else { // when k is even\\n            evenTurb = (A[k] > A[k + 1]) ? evenTurb + 1 : 1;\\n            oddTurb = (A[k] < A[k + 1]) ? oddTurb + 1 : 1;\\n        }\\n        \\n        maxLen = Math.max(maxLen, oddTurb, evenTurb);\\n    }\\n    \\n    return maxLen;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 618198,
                "title": "java-dp-solution-with-explanation",
                "content": "My dp solution:\\n1. Initial dp[0],dp[1] (Two special position we need to deal with);\\n2. if A[i] == A[i-1], the position i break the turbulent rule, so dp[i] =1;\\n3. if A[i-2] > A[i - 1] < A[i]  or   A[i-2] < A[i - 1] > A[i],  the position i match the turbulent rule, so dp[i] = dp[i-1] +1;\\n4. The another situation is that  the position i change to A rule from B rule, so dp[i] = 2.\\n```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] A) {\\n        if(A.length == 1) return 1;\\n        int[] dp = new int[A.length];\\n        dp[0] = 1;\\n        dp[1] = A[0] == A[1] ? 1 : 2;\\n        int max = A[0] == A[1] ? 1 : 2;\\n        for(int i = 2; i < A.length; i++){\\n            if(A[i] == A[i-1]){\\n                dp[i] = 1;\\n            }else if((A[i] > A[i - 1] && A[i-2] > A[i - 1]) || (A[i] < A[i - 1] && A[i-2] < A[i - 1])){\\n                dp[i] = dp[i-1] + 1;\\n            }else{\\n                dp[i] = 2;\\n            }\\n            max = Math.max(max, dp[i]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] A) {\\n        if(A.length == 1) return 1;\\n        int[] dp = new int[A.length];\\n        dp[0] = 1;\\n        dp[1] = A[0] == A[1] ? 1 : 2;\\n        int max = A[0] == A[1] ? 1 : 2;\\n        for(int i = 2; i < A.length; i++){\\n            if(A[i] == A[i-1]){\\n                dp[i] = 1;\\n            }else if((A[i] > A[i - 1] && A[i-2] > A[i - 1]) || (A[i] < A[i - 1] && A[i-2] < A[i - 1])){\\n                dp[i] = dp[i-1] + 1;\\n            }else{\\n                dp[i] = 2;\\n            }\\n            max = Math.max(max, dp[i]);\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 222048,
                "title": "easiest-simplest-o-n-js-solution-100",
                "content": "1. duplicate last value of the array\\n2. find `sign` of `A[i] - A[i+1]`\\n3. when `sign !=-prevSign`   need to check max and start new subarray\\n4. in last index sign will be `0` because, last element is duplicated\\n```\\nvar maxTurbulenceSize = function(A) {\\n  if(A.length==1) return 1;\\n  A.push(A[A.length-1]);\\n  \\n  let max = 0; \\n  let sign=0;  // sign of \\n  let prevSign=0; // previos value of sign\\n  let index=0; // index of array where the rule is broken\\n  \\n  for(let i=0;i<A.length - 1;i++) {\\n    sign= Math.sign(A[i]-A[i+1]);\\n    \\n    if(sign!=-prevSign) {\\n      max = Math.max(max, i - index + 1);\\n      index = i;\\n      prevSign=0;\\n    }\\n    prevSign=sign;\\n  } \\n  return max;\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxTurbulenceSize = function(A) {\\n  if(A.length==1) return 1;\\n  A.push(A[A.length-1]);\\n  \\n  let max = 0; \\n  let sign=0;  // sign of \\n  let prevSign=0; // previos value of sign\\n  let index=0; // index of array where the rule is broken\\n  \\n  for(let i=0;i<A.length - 1;i++) {\\n    sign= Math.sign(A[i]-A[i+1]);\\n    \\n    if(sign!=-prevSign) {\\n      max = Math.max(max, i - index + 1);\\n      index = i;\\n      prevSign=0;\\n    }\\n    prevSign=sign;\\n  } \\n  return max;\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3971366,
                "title": "easy-to-understand-explanation-simply-python-solution",
                "content": "Lets create a variable shouldBeGreater to see the current trend. \\nshouldBeGreater means if current element should be greater than the next or not. shouldBeGreater == True means current should be greater than next. shouldBeGreater == False means current should be smaller than next element.\\nLets go through the array. \\nIf shouldBeGreater and arr[i] < arr[i+1], lets flip the trend by altering the boolean value shouldBeGreater. Increment count and i. \\nIf not shouldBeGreater and arr[i] > arr[i+1], lets flip the trend by altering the boolean value shouldBeGreater. Increment count and i.\\n\\nThere are also two other cases. \\nIf the trend is not followed. In that case set the value of boolean\\nshouldBeGreater by checking what the trend is going to be from now on. \\nSet count to 1. Don\\'t increment i, because if you do so, you will miss the first\\nvalue of the current trend. \\n\\nSecond case is if current and next values are same. In that case just increment\\ni and set count to 1.\\nIf after this whatever was the previous trend in shouldBeGreater, If that is still continueing then you will go with the first two cases. \\nIf not then you will go the else and correct the trend.\\n\\n```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        if len(arr) == 1:\\n            return 1\\n        \\n        shouldBeGreater = True if arr[0] < arr[1] else False\\n        count, maxCount = 1, 1\\n        i = 0\\n        while i < len(arr) - 1:\\n            if arr[i] == arr[i+1]:\\n                i += 1\\n                count = 1\\n                continue\\n            if shouldBeGreater and arr[i] < arr[i+1]:\\n                shouldBeGreater = not shouldBeGreater\\n                count += 1\\n                maxCount = max(maxCount, count)\\n                i += 1\\n            elif not shouldBeGreater and arr[i] > arr[i+1]:\\n                shouldBeGreater = not shouldBeGreater\\n                count += 1\\n                maxCount = max(maxCount, count)\\n                i += 1\\n            else:\\n                if arr[i] < arr[i+1]:\\n                    shouldBeGreater = True\\n                else:\\n                    shouldBeGreater = False\\n                count = 1\\n        return maxCount\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        if len(arr) == 1:\\n            return 1\\n        \\n        shouldBeGreater = True if arr[0] < arr[1] else False\\n        count, maxCount = 1, 1\\n        i = 0\\n        while i < len(arr) - 1:\\n            if arr[i] == arr[i+1]:\\n                i += 1\\n                count = 1\\n                continue\\n            if shouldBeGreater and arr[i] < arr[i+1]:\\n                shouldBeGreater = not shouldBeGreater\\n                count += 1\\n                maxCount = max(maxCount, count)\\n                i += 1\\n            elif not shouldBeGreater and arr[i] > arr[i+1]:\\n                shouldBeGreater = not shouldBeGreater\\n                count += 1\\n                maxCount = max(maxCount, count)\\n                i += 1\\n            else:\\n                if arr[i] < arr[i+1]:\\n                    shouldBeGreater = True\\n                else:\\n                    shouldBeGreater = False\\n                count = 1\\n        return maxCount\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3257332,
                "title": "xor-with-dp-bottom-up-with-optimization-dp-beginner-friendly",
                "content": "\\n# Approach 1: Bottom up, Linear Space\\n<!-- Describe your approach to solving the problem. -->\\n\\nMy intuition when i see turbuelnce subarry is that \\n```\\n> < > < > < > <\\n```\\nFor a simple array [a, b, c] to be a turbulent array, we could have\\n```\\nSituation1: a > b < c\\nSituation2: a < b > c\\n``` \\nThe signs are fliping with every single time and it exisits a concise way to represent the state. If a, b ,c are distinct numbers (no duplicate) then the array `[a,b,c]` is turbulent is equivalent to the following statement\\n```\\n(a > b) XOR (b > c)\\n```\\n\\nThen, Similar to bottom-up solution for maximum subarray, we just need to define a `DP[i]` function that means the maximum turbulent subarray ending on `array[i]` (must include element `array[i]`). Then we do one pass solution while calculating `DP[i]` based on the state info stored in XOR.\\n\\n## Algorithm\\n- construct `DP[i]`\\n- initialize `DP[0]` and `DP[1]`\\n- iterate throught the `array[2:]`\\n    - case when `array[i]` = `array[i-1]`, it means the maximun turbulent subarray ending on `array[i]` is 1. Example:  array = [2,1,3,3], DP[3] = 1.\\n    - case when XOR returns `True`, it means we increment by one\\n    - else, it means XOR returns `False`, it means we reset to 2.\\n- return maximum in the `DP` array\\n\\n## Complexity\\n- Time complexity: $O(n)$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $O(n)$ to store previous maximum turbulent subarray length \\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n## Code\\n```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        # DP[i]: length of maximum turbulent subarray ending on arr[i]\\n        # bottomUp constant space Solution\\n\\n        if len(arr) == 1: return 1\\n        # initialize DP, at first two elements\\n        DP = [None for _ in range(len(arr))]\\n        DP[0] = 1        \\n        if arr[0] == arr[1]:\\n            DP[1] = 1\\n        else:\\n            DP[1] = 2\\n\\n        # bollean flag\\n        flag = arr[1] > arr[0]\\n\\n        for i in range(2,len(arr)):\\n            # edge case when equal, we reset to 1\\n            if arr[i] == arr[i-1]:\\n                DP[i] = 1\\n                continue\\n\\n            if flag ^ (arr[i] > arr[i-1]):\\n                # successfully update\\n                DP[i] = DP[i-1] + 1\\n\\n                # update flag\\n                flag = arr[i] > arr[i-1]\\n            else:\\n                # update fails, rest to maximum turbulent subarray length ending on arr[i], which is 2.\\n                DP[i] = 2\\n\\n        return max(DP)\\n```\\n\\n# Approach 2: Bottom up, Constant space\\n\\nWe don\\'t need to store the whole array and just need to track and update the maximum length of turbulent subarray for return. We do the following:\\n\\n```python\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        # bottom up, constant space\\n        # current_length: current maximum turbulent ending on\\n\\n        if len(arr) == 1: return 1\\n\\n        # initialize DP, at first two elements\\n        if arr[1] == arr[0]:\\n            current_length = 1\\n        else:\\n            current_length = 2\\n\\n        maximum_length = current_length\\n\\n        # bollean flag\\n        flag = arr[1] > arr[0]\\n\\n        for i in range(2,len(arr)):\\n            # edge case when equal, we reset to 1\\n            if arr[i] == arr[i-1]:\\n                current_length = 1\\n                maximum_length = max(maximum_length,current_length)\\n                continue\\n\\n            if flag ^ (arr[i] > arr[i-1]):\\n                # turbulent, so increment current length\\n                current_length += 1\\n                # update flag\\n                flag = arr[i] > arr[i-1]\\n            else:\\n                # rest current_length to 2, which only has two elements [0,1,2] --> [1,2] \\n                current_length = 2\\n            \\n            maximum_length = max(maximum_length,current_length)\\n\\n        return maximum_length\\n```\\n\\n# Summary\\n\\nThe problem is very similar to maximum subarry and this solution provides:\\n- a solution framework similar to the editoral of the maximum subarray \\n- the trick using `XOR` to represent state.\\n",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```\\n> < > < > < > <\\n```\n```\\nSituation1: a > b < c\\nSituation2: a < b > c\\n```\n```\\n(a > b) XOR (b > c)\\n```\n```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        # DP[i]: length of maximum turbulent subarray ending on arr[i]\\n        # bottomUp constant space Solution\\n\\n        if len(arr) == 1: return 1\\n        # initialize DP, at first two elements\\n        DP = [None for _ in range(len(arr))]\\n        DP[0] = 1        \\n        if arr[0] == arr[1]:\\n            DP[1] = 1\\n        else:\\n            DP[1] = 2\\n\\n        # bollean flag\\n        flag = arr[1] > arr[0]\\n\\n        for i in range(2,len(arr)):\\n            # edge case when equal, we reset to 1\\n            if arr[i] == arr[i-1]:\\n                DP[i] = 1\\n                continue\\n\\n            if flag ^ (arr[i] > arr[i-1]):\\n                # successfully update\\n                DP[i] = DP[i-1] + 1\\n\\n                # update flag\\n                flag = arr[i] > arr[i-1]\\n            else:\\n                # update fails, rest to maximum turbulent subarray length ending on arr[i], which is 2.\\n                DP[i] = 2\\n\\n        return max(DP)\\n```\n```python\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        # bottom up, constant space\\n        # current_length: current maximum turbulent ending on\\n\\n        if len(arr) == 1: return 1\\n\\n        # initialize DP, at first two elements\\n        if arr[1] == arr[0]:\\n            current_length = 1\\n        else:\\n            current_length = 2\\n\\n        maximum_length = current_length\\n\\n        # bollean flag\\n        flag = arr[1] > arr[0]\\n\\n        for i in range(2,len(arr)):\\n            # edge case when equal, we reset to 1\\n            if arr[i] == arr[i-1]:\\n                current_length = 1\\n                maximum_length = max(maximum_length,current_length)\\n                continue\\n\\n            if flag ^ (arr[i] > arr[i-1]):\\n                # turbulent, so increment current length\\n                current_length += 1\\n                # update flag\\n                flag = arr[i] > arr[i-1]\\n            else:\\n                # rest current_length to 2, which only has two elements [0,1,2] --> [1,2] \\n                current_length = 2\\n            \\n            maximum_length = max(maximum_length,current_length)\\n\\n        return maximum_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2618002,
                "title": "python-sliding-window-o-n-time-and-o-1-space",
                "content": "\\nLet me just make the conditions of a turbulent subarray more clear.\\n\\nWe can have two types of valid turbulent subarrays - \\n\\n\\t\\t\\ta > b < c > d < e\\n\\t\\t\\ta < b > c < d > e\\n\\t\\t\\t\\nSo, for every number, there are two cases - \\n\\n\\t\\tIt is smaller than previous and smaller than next\\n\\t\\t\\t\\t\\t\\t\\tOr\\n\\t\\tIt is bigger than previous and bigger than next\\n\\nAnd well, those are the conditions that we have to use. Forget the even and odd thing that the problem statement mentions. If any of the above two conditions are true, that means current number can be included in the current window.\\n\\nSuppose array is \\n\\n\\t\\t\\t\\t\\t[9,4,2,10,7,8,8,1,9]\\n\\t\\t\\t\\t\\t\\nAnd ofcourse, a number in itself is always turbulent. That\\'s why in code, the initial value for maxSize is 1. \\n\\nSo, we want to see if there are subarrays of size > 1 or not. If yes, we want to find the largest of them. Since first number of an array is already turbulent in itself, we will start checking from the 2nd number (Unless array has only 1 number, in that case we return 1).\\n\\nIn above example, we start from 4. Is 4 > 9? NO. Is 4 < 9? YES. This means, the number that comes after 4 should be >4. Because we are following this pattern here ->  a > b < c > d < e\\n\\nSo, for every number, we not only check its previous number but also its next number. In this way, we do not have to keep track of what was the previous comparison sign.\\n\\n## **EDGE CASES**\\n\\nWhat about cases when all elements are same in the array. \\n\\n\\t\\t\\t[100,100, 100] \\n\\t\\t\\t\\nHere initially, ith pointer will point to first 100 and jth pointer to second 100.\\n\\nNow, if our code runs, since we are calculating window size as j - i + 1, it will set maxSize to 2 which is not true. \\n\\nThis means, if a window starts with two duplicates, we cannot include both. We can only include the second one. So skip the first by pointing the start of window to the second number.\\n\\nI was literally stuck at 89/91 test cases passed due to these test cases with same numbers xD \\n\\n```\\n # Helper method to check if current index can be included in window or not\\n    def isTurbulent(self, arr, j):\\n        # If current element is greater than previous, then it should be greater than next as well\\n        condition1 = arr[j] > arr[j-1] and arr[j] > arr[j + 1]\\n            \\n        # If current element is smaller than previous, then it should be smaller than next as well\\n        condition2 = arr[j] < arr[j-1] and arr[j] < arr[j + 1]\\n        \\n        # If either of two statements are true, that means we can include index j in the window\\n        return condition1 or condition2\\n    \\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        if n == 1: return 1\\n\\n        maxSize = 1\\n        \\n\\t\\t# Since first element in itself is already turbulent, lets start with second element. That\\'s why j = 1\\n        i,j = 0,1\\n        \\n        # General Sliding Window Template\\n        while j < n:\\n            \\n            # If the first value of the window is same as second value, that means we cannot include both numbers\\n            # So skip the first number by pointing the start of window to second number\\n            if arr[i] == arr[i+1]: i += 1\\n            \\n            # While this condition is true, we can expand the window\\n            while j + 1 < n and self.isTurbulent(arr,j): j += 1\\n                \\n            # As soon as above loop ends, we can update the maxSize if current window size is bigger than previous maxSize\\n            maxSize = max(maxSize, j - i + 1)\\n            \\n            i = j\\n            j += 1\\n        \\n        return maxSize\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\n # Helper method to check if current index can be included in window or not\\n    def isTurbulent(self, arr, j):\\n        # If current element is greater than previous, then it should be greater than next as well\\n        condition1 = arr[j] > arr[j-1] and arr[j] > arr[j + 1]\\n            \\n        # If current element is smaller than previous, then it should be smaller than next as well\\n        condition2 = arr[j] < arr[j-1] and arr[j] < arr[j + 1]\\n        \\n        # If either of two statements are true, that means we can include index j in the window\\n        return condition1 or condition2\\n    \\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        if n == 1: return 1\\n\\n        maxSize = 1\\n        \\n\\t\\t# Since first element in itself is already turbulent, lets start with second element. That\\'s why j = 1\\n        i,j = 0,1\\n        \\n        # General Sliding Window Template\\n        while j < n:\\n            \\n            # If the first value of the window is same as second value, that means we cannot include both numbers\\n            # So skip the first number by pointing the start of window to second number\\n            if arr[i] == arr[i+1]: i += 1\\n            \\n            # While this condition is true, we can expand the window\\n            while j + 1 < n and self.isTurbulent(arr,j): j += 1\\n                \\n            # As soon as above loop ends, we can update the maxSize if current window size is bigger than previous maxSize\\n            maxSize = max(maxSize, j - i + 1)\\n            \\n            i = j\\n            j += 1\\n        \\n        return maxSize\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 2554837,
                "title": "c-easy-and-simple-o-n-tc-o-1-sc",
                "content": "TC: O(N)\\nSC: O(1)\\n```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n=arr.size();\\n        int i=0;\\n        int maxi=1;\\n        int curr=1;\\n        int turn=-1;  \\n        // -1-> neutral turn   1 -> last was +ve   0-> last was -ve\\n         while(i<n-1)\\n        {\\n            if(arr[i]==arr[i+1]){\\n                curr=1;\\n                turn=-1;\\n                i++;\\n            }\\n            else if(arr[i]>arr[i+1] && (turn ==-1 || turn == 0)){\\n                curr++;\\n                turn=1;\\n                i++;\\n            }\\n            else if(arr[i]<arr[i+1] &&  (turn== -1 || turn == 1)){\\n                curr++;\\n                turn=0;\\n                i++;\\n            }\\n            else{\\n                curr=1;\\n                turn =-1;\\n            }\\n            maxi=max(maxi,curr);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n=arr.size();\\n        int i=0;\\n        int maxi=1;\\n        int curr=1;\\n        int turn=-1;  \\n        // -1-> neutral turn   1 -> last was +ve   0-> last was -ve\\n         while(i<n-1)\\n        {\\n            if(arr[i]==arr[i+1]){\\n                curr=1;\\n                turn=-1;\\n                i++;\\n            }\\n            else if(arr[i]>arr[i+1] && (turn ==-1 || turn == 0)){\\n                curr++;\\n                turn=1;\\n                i++;\\n            }\\n            else if(arr[i]<arr[i+1] &&  (turn== -1 || turn == 1)){\\n                curr++;\\n                turn=0;\\n                i++;\\n            }\\n            else{\\n                curr=1;\\n                turn =-1;\\n            }\\n            maxi=max(maxi,curr);\\n        }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465684,
                "title": "python3-longest-turbulent-subarray-one-pass-o-n",
                "content": "The problem can be broken down into two parts:\\n1. Finding the current direction of the turbulence, i.e., if it is going from increasing to decreasing or vice-versa.\\n2. Finding how many numbers follow the current turbulence direction.\\n\\nNumber comparisons can be reverted when the sign of the number changes. For example, 2 < 4 but -2 > -4. Using this rule, we can maintain the previous comparison\\'s direction, i.e., if it was > sign or < sign as 1 or -1. This way, we can compare two numbers with the same sign but alternate the direction everytime and multiply it with the numbers.\\n\\nHence, for the first part, we can simply compare `arr[0]` and `arr[1]` to come up with a direction. Since I\\'m using > in my loop, I\\'m using 1 as > and < as -1. Now, within the loop, all I\\'m doing is if the current number is greater than or less than the next (based on direction), increase count and revert direction. Else not, it means the number here follows the alternate direction, as in, > where we expect < or vice-versa. Hence, update maxCount and set count to two only when the two numbers aren\\'t the same (which would mean it has a opposite direction). Note, we don\\'t update direction here because we assume the current direction is already inverted so the next comparison would be correct with the current direction.\\n\\n```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        if len(arr) < 2:\\n            return len(arr)\\n\\n        count = 1\\n        maxCount = 1\\n        direction = 1 if arr[0] > arr[1] else -1\\n        \\n        for i in range(len(arr) - 1):\\n\\t\\t\\t# If direction is -1, the sign would act like <\\n            if (direction * arr[i]) > (direction * arr[i + 1]):\\n                count += 1\\n                direction *= -1\\n            else:\\n                maxCount = max(maxCount, count)\\n                count = 2 if arr[i] != arr[i + 1] else 1\\n                \\n        return max(maxCount, count)\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        if len(arr) < 2:\\n            return len(arr)\\n\\n        count = 1\\n        maxCount = 1\\n        direction = 1 if arr[0] > arr[1] else -1\\n        \\n        for i in range(len(arr) - 1):\\n\\t\\t\\t# If direction is -1, the sign would act like <\\n            if (direction * arr[i]) > (direction * arr[i + 1]):\\n                count += 1\\n                direction *= -1\\n            else:\\n                maxCount = max(maxCount, count)\\n                count = 2 if arr[i] != arr[i + 1] else 1\\n                \\n        return max(maxCount, count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465465,
                "title": "java-kadane-s-algorithm-o-n-solution",
                "content": "We are going to take a look at how to solve this problem using **Kadane\\'s algorithm**.\\nSince we will traverse the array only once, **time complexity = O(n)**.\\n\\nBefore that, we need to consider a few test cases.\\n* If the size of the array is 1, then in that case the max. number of elements in the turbulent subarray will be 1. We\\'ll simply return 1 in that case.\\n* If the size of the array is greater than 1, in that case, we\\'ll run Kadane\\'s algorithm. \\n\\nThe code is as follows:\\n\\n```java\\nclass Solution {\\n    public int maxTurbulenceSize(int[] arr) {\\n\\t\\n\\t\\t// if length == 1, return 1\\n        int max = 1;\\n        if(arr.length == 1) return max;\\n        \\n\\t\\t// sign after first comparison (-1 for smaller, 1 for greater, 0 for equal)\\n        int sign = 0;\\n        if(arr[0] > arr[1]){\\n            sign = 1;\\n        } else if (arr[0] < arr[1]){\\n            sign = -1;\\n        }\\n        \\n\\t\\t// Only non-equal elements are considered in turbulent arrays\\n        int count;\\n        if(sign == 0){\\n            count = 0;\\n        } else {\\n            count = 2;\\n            max = count;\\n        }\\n        \\n\\t\\t// start checking from index = 1\\n        for(int i = 1; i < arr.length-1; i++){\\n\\t\\t\\t// we assume by default arr[i] == arr[i+1]\\n            int tempSign = 0;\\n            if(arr[i] > arr[i+1]){\\n                tempSign = 1;\\n            } else if (arr[i] < arr[i+1]){\\n                tempSign = -1;\\n            } \\n\\t\\t\\t\\n\\t\\t\\t// if arr[i] == arr[i+1], we reset the counter to 1 (i.e., none turbulent) and continue\\n            if (tempSign == 0) {\\n                count = 1;\\n                continue;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// if previous and present sign are same, we discard the previous sub-array and start afresh with new one\\n            if(sign == tempSign){\\n                count = 2;\\n            } else {  // else we increase the counter\\n                count++;\\n                sign = tempSign;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// if the counter increases the previous max count value, we change the max count to counter value\\n            if (count > max) {\\n                max = count;\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```java\\nclass Solution {\\n    public int maxTurbulenceSize(int[] arr) {\\n\\t\\n\\t\\t// if length == 1, return 1\\n        int max = 1;\\n        if(arr.length == 1) return max;\\n        \\n\\t\\t// sign after first comparison (-1 for smaller, 1 for greater, 0 for equal)\\n        int sign = 0;\\n        if(arr[0] > arr[1]){\\n            sign = 1;\\n        } else if (arr[0] < arr[1]){\\n            sign = -1;\\n        }\\n        \\n\\t\\t// Only non-equal elements are considered in turbulent arrays\\n        int count;\\n        if(sign == 0){\\n            count = 0;\\n        } else {\\n            count = 2;\\n            max = count;\\n        }\\n        \\n\\t\\t// start checking from index = 1\\n        for(int i = 1; i < arr.length-1; i++){\\n\\t\\t\\t// we assume by default arr[i] == arr[i+1]\\n            int tempSign = 0;\\n            if(arr[i] > arr[i+1]){\\n                tempSign = 1;\\n            } else if (arr[i] < arr[i+1]){\\n                tempSign = -1;\\n            } \\n\\t\\t\\t\\n\\t\\t\\t// if arr[i] == arr[i+1], we reset the counter to 1 (i.e., none turbulent) and continue\\n            if (tempSign == 0) {\\n                count = 1;\\n                continue;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// if previous and present sign are same, we discard the previous sub-array and start afresh with new one\\n            if(sign == tempSign){\\n                count = 2;\\n            } else {  // else we increase the counter\\n                count++;\\n                sign = tempSign;\\n            }\\n\\t\\t\\t\\n\\t\\t\\t// if the counter increases the previous max count value, we change the max count to counter value\\n            if (count > max) {\\n                max = count;\\n            }\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465241,
                "title": "c",
                "content": "int maxTurbulenceSize(vector<int>& arr) {\\n        \\n        int count = 0,ans=0;\\n        int i=0,k=1,j=k+1;\\n        int len = size(arr);\\n     \\n        \\n        if(len==1 || (len==2 && arr[0] == arr[1]))\\n            return 1;\\n        \\n        if(len==2 && arr[0] != arr[1])\\n            return 2;\\n        \\n        while(j<len)\\n        {\\n            \\n            if(arr[i]>arr[k] && arr[j]>arr[k])\\n                count++;\\n            else if(arr[i]<arr[k] && arr[j]<arr[k])\\n                count++;\\n            else{\\n                ans = max(ans,count);\\n                count=0;\\n                }\\n            i++;\\n            k++;\\n            j++;\\n        }\\n        ans = max(ans,count);\\n        \\n        if(!ans && arr[i]==arr[--k] && arr[k]==arr[--j])\\n            return 1;\\n      \\n        return ans+2;\\n    }",
                "solutionTags": [],
                "code": "int maxTurbulenceSize(vector<int>& arr) {\\n        \\n        int count = 0,ans=0;\\n        int i=0,k=1,j=k+1;\\n        int len = size(arr);\\n     \\n        \\n        if(len==1 || (len==2 && arr[0] == arr[1]))\\n            return 1;\\n        \\n        if(len==2 && arr[0] != arr[1])\\n            return 2;\\n        \\n        while(j<len)\\n        {\\n            \\n            if(arr[i]>arr[k] && arr[j]>arr[k])\\n                count++;\\n            else if(arr[i]<arr[k] && arr[j]<arr[k])\\n                count++;\\n            else{\\n                ans = max(ans,count);\\n                count=0;\\n                }\\n            i++;\\n            k++;\\n            j++;\\n        }\\n        ans = max(ans,count);\\n        \\n        if(!ans && arr[i]==arr[--k] && arr[k]==arr[--j])\\n            return 1;\\n      \\n        return ans+2;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 717232,
                "title": "java-turbulent-subarray-diff-next-diff-0",
                "content": "Java Turbulent Subarray == diff * next diff < 0\\n```\\n    public int maxTurbulenceSize(int[] A) {\\n        if (A == null || A.length == 0) return 0;\\n        long res = 1, cnt = 1, sign = 0;  // use long instead of int to avoid multi overflow;\\n        for (int i = 1; i < A.length; i++) {\\n            if (sign * (A[i] - A[i - 1]) < 0) cnt++;\\n            else cnt = (A[i] - A[i - 1]) != 0 ? 2 : 1;\\n            sign = A[i] - A[i - 1];\\n            res = Math.max(res, cnt);\\n        }\\n        return (int) res;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxTurbulenceSize(int[] A) {\\n        if (A == null || A.length == 0) return 0;\\n        long res = 1, cnt = 1, sign = 0;  // use long instead of int to avoid multi overflow;\\n        for (int i = 1; i < A.length; i++) {\\n            if (sign * (A[i] - A[i - 1]) < 0) cnt++;\\n            else cnt = (A[i] - A[i - 1]) != 0 ? 2 : 1;\\n            sign = A[i] - A[i - 1];\\n            res = Math.max(res, cnt);\\n        }\\n        return (int) res;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 681367,
                "title": "python-dp-solution",
                "content": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, A: List[int]) -> int:\\n        if len(A) <= 1:\\n            return len(A)\\n\\n        n, max_len = len(A), 1\\n\\n        dp = [[1] * n for _ in range(2)]\\n       \\n        for i in range(1, n):\\n            if (A[i-1] < A[i]):\\n                dp[0][i] = dp[1][i-1] + 1\\n                max_len = max(max_len, dp[0][i])\\n            elif (A[i-1] > A[i]):\\n                dp[1][i] = dp[0][i-1] + 1\\n                max_len = max(max_len, dp[1][i])\\n\\n        return max_len        \\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, A: List[int]) -> int:\\n        if len(A) <= 1:\\n            return len(A)\\n\\n        n, max_len = len(A), 1\\n\\n        dp = [[1] * n for _ in range(2)]\\n       \\n        for i in range(1, n):\\n            if (A[i-1] < A[i]):\\n                dp[0][i] = dp[1][i-1] + 1\\n                max_len = max(max_len, dp[0][i])\\n            elif (A[i-1] > A[i]):\\n                dp[1][i] = dp[0][i-1] + 1\\n                max_len = max(max_len, dp[1][i])\\n\\n        return max_len        \\n```",
                "codeTag": "Java"
            },
            {
                "id": 630984,
                "title": "java-sliding-window",
                "content": "I first handle the trivial case with 0 or 1 elements.\\n\\nThen, I know that the max must be >= 1 because any one element is turbulent with itself.\\n\\nNow, I use a sliding window. When finding a start for the sliding window, I know that two consecutive, equal elements cannot be turbulent because neither is greater than the other. So, if the `A[start]` is equal to the next element, I increment start and try to find another start.\\n\\nOnce we have established a start, we start looking for the end of the turbulent subarray starting from here. We increment end until we hit the end of the array or find an element that is not turbulent. Once that is a non-turbulent value, we know that it cannot be part of a turbulent subarray. So, we simply move our start to where this ending element is and continue searching for a longer turbulent subarray.\\n```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] A) {\\n        if (A.length < 2) {\\n            return A.length;\\n        }\\n        int max = 1;\\n        int start = 0;\\n        int end = 0;\\n        \\n        while (start < A.length - 1) {\\n            if (A[start] == A[start+1]) {\\n                start++;\\n                continue;\\n            }\\n            end = start+1;\\n            while (end+1 < A.length && isTurbulent(A, end)) {\\n                end++;\\n            }\\n            max = Math.max(max, end-start+1);\\n            start = end;\\n        }\\n        return max;\\n    }\\n    \\n    private boolean isTurbulent(int[] A, int k) {\\n        return (A[k] > A[k-1] && A[k] > A[k+1]) || (A[k] < A[k-1]) && (A[k] < A[k+1]);\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] A) {\\n        if (A.length < 2) {\\n            return A.length;\\n        }\\n        int max = 1;\\n        int start = 0;\\n        int end = 0;\\n        \\n        while (start < A.length - 1) {\\n            if (A[start] == A[start+1]) {\\n                start++;\\n                continue;\\n            }\\n            end = start+1;\\n            while (end+1 < A.length && isTurbulent(A, end)) {\\n                end++;\\n            }\\n            max = Math.max(max, end-start+1);\\n            start = end;\\n        }\\n        return max;\\n    }\\n    \\n    private boolean isTurbulent(int[] A, int k) {\\n        return (A[k] > A[k-1] && A[k] > A[k+1]) || (A[k] < A[k-1]) && (A[k] < A[k+1]);\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 514387,
                "title": "straight-forward-python-solution-using-dynamic-programming",
                "content": "![image](https://assets.leetcode.com/users/jefferyzzy/image_1583361827.png)\\n\\n**Latest updated(beat 99% run time)**\\n```Python\\ndef maxTurbulenceSize(self, A: List[int]) -> int:\\n        size = len(A)\\n        dp=[2]*size\\n        dp[0]=1\\n        if size < 2: return 1\\n        flag = 1 if A[1]>A[0] else 0 #1: need next to be smaller and 0: need next to be bigger\\n        for i in range(1, size):\\n            if A[i]==A[i-1]:\\n                dp[i]=1\\n                continue\\n            if flag and A[i]<A[i-1]:\\n                dp[i]=dp[i-1]+1\\n                flag = 0\\n            elif not flag and A[i]>A[i-1]:\\n                dp[i]=dp[i-1]+1\\n                flag = 1\\n        return max(dp)\\n```\\n\\n**Improved version (beat 39% run time)**\\n```Python\\ndef maxTurbulenceSize(self, A: List[int]) -> int:\\n        dp = [1 for _ in range(len(A))]\\n        max_num = 1\\n        flag = 1\\n        for i in range(len(A)-1):\\n            if i%2 == 1 and A[i]>A[i+1] or i%2 == 0 and A[i]<A[i+1]:\\n                if not flag: dp[i] = 1\\n                dp[i+1]=dp[i]+1\\n                max_num = max(max_num, dp[i+1])\\n                flag = 1\\n            elif i%2 == 0 and A[i]>A[i+1] or i%2 == 1 and A[i]<A[i+1]:\\n                if flag: dp[i] = 1\\n                dp[i+1]=dp[i]+1\\n                max_num = max(max_num, dp[i+1])\\n                flag = 0\\n        return max_num\\n```\\n\\n**Original version (beat 22% run time)**\\n```Python\\ndef maxTurbulenceSize(self, A: List[int]) -> int:\\n        dp1 = [1 for _ in range(len(A))]\\n        dp2 = [1 for _ in range(len(A))]\\n        max_num = 1\\n        for i in range(len(A)-1):\\n            if i%2 == 1 and A[i]>A[i+1] or i%2 == 0 and A[i]<A[i+1]:\\n                    dp1[i+1]=dp1[i]+1\\n                    if dp1[i+1] > max_num: max_num = dp1[i+1]\\n            elif i%2 == 0 and A[i]>A[i+1] or i%2 == 1 and A[i]<A[i+1]:\\n                    dp2[i+1]=dp2[i]+1\\n                    if dp2[i+1] > max_num: max_num = dp2[i+1]\\n        return max_num\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```Python\\ndef maxTurbulenceSize(self, A: List[int]) -> int:\\n        size = len(A)\\n        dp=[2]*size\\n        dp[0]=1\\n        if size < 2: return 1\\n        flag = 1 if A[1]>A[0] else 0 #1: need next to be smaller and 0: need next to be bigger\\n        for i in range(1, size):\\n            if A[i]==A[i-1]:\\n                dp[i]=1\\n                continue\\n            if flag and A[i]<A[i-1]:\\n                dp[i]=dp[i-1]+1\\n                flag = 0\\n            elif not flag and A[i]>A[i-1]:\\n                dp[i]=dp[i-1]+1\\n                flag = 1\\n        return max(dp)\\n```\n```Python\\ndef maxTurbulenceSize(self, A: List[int]) -> int:\\n        dp = [1 for _ in range(len(A))]\\n        max_num = 1\\n        flag = 1\\n        for i in range(len(A)-1):\\n            if i%2 == 1 and A[i]>A[i+1] or i%2 == 0 and A[i]<A[i+1]:\\n                if not flag: dp[i] = 1\\n                dp[i+1]=dp[i]+1\\n                max_num = max(max_num, dp[i+1])\\n                flag = 1\\n            elif i%2 == 0 and A[i]>A[i+1] or i%2 == 1 and A[i]<A[i+1]:\\n                if flag: dp[i] = 1\\n                dp[i+1]=dp[i]+1\\n                max_num = max(max_num, dp[i+1])\\n                flag = 0\\n        return max_num\\n```\n```Python\\ndef maxTurbulenceSize(self, A: List[int]) -> int:\\n        dp1 = [1 for _ in range(len(A))]\\n        dp2 = [1 for _ in range(len(A))]\\n        max_num = 1\\n        for i in range(len(A)-1):\\n            if i%2 == 1 and A[i]>A[i+1] or i%2 == 0 and A[i]<A[i+1]:\\n                    dp1[i+1]=dp1[i]+1\\n                    if dp1[i+1] > max_num: max_num = dp1[i+1]\\n            elif i%2 == 0 and A[i]>A[i+1] or i%2 == 1 and A[i]<A[i+1]:\\n                    dp2[i+1]=dp2[i]+1\\n                    if dp2[i+1] > max_num: max_num = dp2[i+1]\\n        return max_num\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 4022374,
                "title": "easy-solution-in-c",
                "content": "~~~\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        \\n        //Basic basecase\\n        if(n==1) return 1;\\n        else if(n==2)\\n        {\\n            if(arr[0]<arr[1]) return 2;\\n            else if(arr[0]>arr[1]) return 2;\\n            else return 1;\\n        }\\n        \\n        //main solution\\n        int maxlen=INT_MIN, c=0, cnt=1;\\n        for(int i=1; i<n-1; i++)\\n        {\\n            //checking if all elements are same\\n            if(arr[i]==arr[0]) cnt++;\\n            \\n            //count hill or valley\\n            if( (arr[i]<arr[i+1] && arr[i]<arr[i-1]) || \\n               (arr[i]>arr[i+1] && arr[i]>arr[i-1]) )\\n                c++;\\n            else if(arr[i]==arr[i+1] && arr[i]==arr[i-1])\\n                maxlen = max(maxlen, 1);\\n            else\\n            {\\n                maxlen = max(maxlen, c+2);\\n                c=0;\\n            }\\n        }\\n        \\n        //checking if all elements are same\\n        if(arr[n-1]==arr[0]) cnt++;\\n        \\n        //if all ele are equal return 1\\n        if(cnt==n) return 1;\\n        else maxlen = max(maxlen, c+2);\\n        \\n        return maxlen;  \\n    }\\n};\\n~~~",
                "solutionTags": [
                    "C",
                    "Array"
                ],
                "code": "class Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        \\n        int n=arr.size();\\n        \\n        //Basic basecase\\n        if(n==1) return 1;\\n        else if(n==2)\\n        {\\n            if(arr[0]<arr[1]) return 2;\\n            else if(arr[0]>arr[1]) return 2;\\n            else return 1;\\n        }",
                "codeTag": "Java"
            },
            {
                "id": 3233394,
                "title": "978-longest-turbulent-subarray",
                "content": "# Intuition\\nWith The Idea of Kadane\\'s Algorithm check for two possibilities:\\n\\nEither ((previous_element < current_element) && (current_element > next_element)) Or ((previous_element > current_element) && (current_element < next_element))\\n\\nSpeed : Beats 100%\\nSpace : Beats 25%\\n\\n# Approach\\nBase Logic : Kadane\\'s Algorithm\\n\\n# Complexity\\n- Time complexity : O(n)\\n\\n- Space complexity : O(n)\\n\\n# Code\\n```\\nint max(int first_value , int second_value){\\n    return ((first_value > second_value) ? (first_value) : (second_value));\\n}\\n\\nint maxTurbulenceSize(int *array, int number_of_elements){\\n    int current_turbulence_sub_array_length = 2;\\n    int maximum_turbulence_sub_array_length = 0;\\n    int atleast_one_turbulence_sub_array_found_flag = 0;\\n    (number_of_elements == 2) ? (((array[0] < array[1]) || (array[0] > array[1])) ? (atleast_one_turbulence_sub_array_found_flag = 1) : (printf(\"\"))) : (printf(\"\"));\\n    for(int i=1 ; (i < (number_of_elements - 1)) ; ((((array[(i - 1)] < array[i]) || (array[(i - 1)] > array[i])) || ((array[(i + 1)] < array[i]) || (array[(i + 1)] > array[i]))) ? (atleast_one_turbulence_sub_array_found_flag = 1) : (printf(\"\"))) , ((((array[i] < array[(i + 1)]) && (array[(i - 1)] > array[i])) || ((array[i] > array[(i + 1)]) && (array[(i - 1)] < array[i]))) ? ((atleast_one_turbulence_sub_array_found_flag = 1) , (current_turbulence_sub_array_length++)) : ((maximum_turbulence_sub_array_length = (max(current_turbulence_sub_array_length , maximum_turbulence_sub_array_length))) , (current_turbulence_sub_array_length = 2))) , (i++)){}\\n    return ((atleast_one_turbulence_sub_array_found_flag) ? (max(current_turbulence_sub_array_length , maximum_turbulence_sub_array_length)) : (1));\\n}\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint max(int first_value , int second_value){\\n    return ((first_value > second_value) ? (first_value) : (second_value));\\n}\\n\\nint maxTurbulenceSize(int *array, int number_of_elements){\\n    int current_turbulence_sub_array_length = 2;\\n    int maximum_turbulence_sub_array_length = 0;\\n    int atleast_one_turbulence_sub_array_found_flag = 0;\\n    (number_of_elements == 2) ? (((array[0] < array[1]) || (array[0] > array[1])) ? (atleast_one_turbulence_sub_array_found_flag = 1) : (printf(\"\"))) : (printf(\"\"));\\n    for(int i=1 ; (i < (number_of_elements - 1)) ; ((((array[(i - 1)] < array[i]) || (array[(i - 1)] > array[i])) || ((array[(i + 1)] < array[i]) || (array[(i + 1)] > array[i]))) ? (atleast_one_turbulence_sub_array_found_flag = 1) : (printf(\"\"))) , ((((array[i] < array[(i + 1)]) && (array[(i - 1)] > array[i])) || ((array[i] > array[(i + 1)]) && (array[(i - 1)] < array[i]))) ? ((atleast_one_turbulence_sub_array_found_flag = 1) , (current_turbulence_sub_array_length++)) : ((maximum_turbulence_sub_array_length = (max(current_turbulence_sub_array_length , maximum_turbulence_sub_array_length))) , (current_turbulence_sub_array_length = 2))) , (i++)){}\\n    return ((atleast_one_turbulence_sub_array_found_flag) ? (max(current_turbulence_sub_array_length , maximum_turbulence_sub_array_length)) : (1));\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 2745829,
                "title": "python-t-c-97-s-c-o-1",
                "content": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        l, r ,output, n =0, 0, 0, len(arr)\\n        if n==1:\\n            return 1\\n        while r < n:\\n            while r<n-1 and (arr[r-1]>arr[r]<arr[r+1] or arr[r-1]<arr[r]>arr[r+1]):\\n                r+=1\\n            while l < r and arr[l]==arr[l+1]:\\n                l+=1\\n            output = max(output,r-l+1)\\n            \\n            l=r\\n            r+=1\\n\\t\\treturn output\\n\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        l, r ,output, n =0, 0, 0, len(arr)\\n        if n==1:\\n            return 1\\n        while r < n:\\n            while r<n-1 and (arr[r-1]>arr[r]<arr[r+1] or arr[r-1]<arr[r]>arr[r+1]):\\n                r+=1\\n            while l < r and arr[l]==arr[l+1]:\\n                l+=1\\n            output = max(output,r-l+1)\\n            \\n            l=r\\n            r+=1\\n\\t\\treturn output\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2525241,
                "title": "o-n-time-complexity-and-space-complexity",
                "content": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] arr) {\\n        int n = arr.length;\\n        int[] inc = new int[n];\\n        int[] dec = new int[n];\\n        \\n        inc[0] = 1;\\n        dec[0] = 1;\\n        int max = 1;\\n        \\n        for(int i = 1; i < arr.length; i++) {\\n            inc[i] = 1;\\n            dec[i] = 1;\\n            \\n            if(arr[i] < arr[i - 1]) {\\n                dec[i] = inc[i - 1] + 1; // if current ele is smaller than prev ele than length of sequence ending at a smaller ele will 1 more than the len of seq ending at prev ele being the greater ele\\n            } else if(arr[i] > arr[i - 1]) {\\n                inc[i] = dec[i - 1] + 1;  // if current ele is larger than prev ele than length of sequence ending at a larger ele will 1 more than the len of seq ending at prev ele being the smaller ele\\n            }\\n            \\n            max = Math.max(max, Math.max(inc[i], dec[i]));\\n\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] arr) {\\n        int n = arr.length;\\n        int[] inc = new int[n];\\n        int[] dec = new int[n];\\n        \\n        inc[0] = 1;\\n        dec[0] = 1;\\n        int max = 1;\\n        \\n        for(int i = 1; i < arr.length; i++) {\\n            inc[i] = 1;\\n            dec[i] = 1;\\n            \\n            if(arr[i] < arr[i - 1]) {\\n                dec[i] = inc[i - 1] + 1; // if current ele is smaller than prev ele than length of sequence ending at a smaller ele will 1 more than the len of seq ending at prev ele being the greater ele\\n            } else if(arr[i] > arr[i - 1]) {\\n                inc[i] = dec[i - 1] + 1;  // if current ele is larger than prev ele than length of sequence ending at a larger ele will 1 more than the len of seq ending at prev ele being the smaller ele\\n            }\\n            \\n            max = Math.max(max, Math.max(inc[i], dec[i]));\\n\\n        }\\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2235929,
                "title": "beats-94-56-c-dp-solution-simplified",
                "content": "In this problem we have a dp matrix of Nx2 size here dp[i][0] denotes the max length subarray ending at ith element such that it is greater than the previous element , and dp[i][0] In this problem we have a dp matrix of Nx2 size here dp[i][0] denotes the max length subarray ending at ith element such that it is smaller than the previous element , and dp[i][0] . For the first element dp[0][0] = 1 and dp[0][1] = 1.\\nCode:\\n```\\n int maxTurbulenceSize(vector<int>& arr) {\\n        \\n        int i,j,n=arr.size(),maxi=1;\\n        int dp[n][2];\\n        dp[0][0] = 1;\\n        dp[0][1] = 1;\\n        for(i=1;i<n;i++)\\n        {\\n            if(arr[i]==arr[i-1])\\n            {\\n                dp[i][0] = 1;\\n                dp[i][1] = 1;\\n            }\\n            if(arr[i]>arr[i-1])\\n            {\\n                dp[i][0] = dp[i-1][1] + 1;\\n                dp[i][1] = 1;\\n                maxi = max(maxi,dp[i][0]);\\n            }\\n            if(arr[i]<arr[i-1])\\n            {\\n                dp[i][0] = 1;\\n                dp[i][1] = dp[i-1][0] +1;\\n                maxi = max(maxi,dp[i][1]);\\n            }\\n        }\\n        return maxi;",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "In this problem we have a dp matrix of Nx2 size here dp[i][0] denotes the max length subarray ending at ith element such that it is greater than the previous element , and dp[i][0] In this problem we have a dp matrix of Nx2 size here dp[i][0] denotes the max length subarray ending at ith element such that it is smaller than the previous element , and dp[i][0] . For the first element dp[0][0] = 1 and dp[0][1] = 1.\\nCode:\\n```\\n int maxTurbulenceSize(vector<int>& arr) {\\n        \\n        int i,j,n=arr.size(),maxi=1;\\n        int dp[n][2];\\n        dp[0][0] = 1;\\n        dp[0][1] = 1;\\n        for(i=1;i<n;i++)\\n        {\\n            if(arr[i]==arr[i-1])\\n            {\\n                dp[i][0] = 1;\\n                dp[i][1] = 1;\\n            }\\n            if(arr[i]>arr[i-1])\\n            {\\n                dp[i][0] = dp[i-1][1] + 1;\\n                dp[i][1] = 1;\\n                maxi = max(maxi,dp[i][0]);\\n            }\\n            if(arr[i]<arr[i-1])\\n            {\\n                dp[i][0] = 1;\\n                dp[i][1] = dp[i-1][0] +1;\\n                maxi = max(maxi,dp[i][1]);\\n            }\\n        }\\n        return maxi;",
                "codeTag": "Unknown"
            },
            {
                "id": 1757050,
                "title": "javascript-sliding-window-with-explanation",
                "content": "I used the sliding windows approach. \\n\\nBasically we increment right to expand the window anytime isTurbulent returns true. We stop expanding the window once isTurbulent returns false. Now we simply calculate what the maxTurbulentLength is. We move the left pointer to where the right pointer is because we\\'ve already processed everything to the left of the left pointer.\\n\\nWe also have to handle two edge cases: 1. When the input is of length 1, example: [100] and 2. When we the input has repeating numbers, example: [1,1] or [1,2,1,1]. \\n\\nWe handle the first edge case with \\n```\\nif (arr.length <= 1) return 1;\\n```\\nAnd the second case is handled with the below by simply reducing curTurbulentLength by 1 since it would\\'ve overcounted in cases of repeating numbers:\\n```\\nif (arr[right - 1] === arr[right]) curTurbulentLength--;\\n```\\n\\n\\n```\\n var maxTurbulenceSize = function(arr) {\\n    let left = 0;\\n    let right = 1;\\n    let maxTurbulentLength = 0;\\n    let curTurbulentLength = 0;\\n    \\n    if (arr.length <= 1) return 1;\\n    \\n    while (right < arr.length) {\\n        curTurbulentLength = right - left + 1;\\n\\n        if (!isTurbulent(arr, right)) {\\n            if (arr[right - 1] === arr[right]) curTurbulentLength--;\\n            maxTurbulentCount = Math.max(maxTurbulentLength, curTurbulentLength);\\n            left = right;\\n        }\\n        \\n        right++\\n    }\\n    \\n    return maxTurbulentLength;\\n};\\n\\nvar isTurbulent = function(arr, right) {\\n    if (arr[right - 1] < arr[right] && arr[right] > arr[right + 1]) return true;\\n    if (arr[right - 1] > arr[right] && arr[right] < arr[right + 1]) return true;\\n    return false;\\n}",
                "solutionTags": [
                    "JavaScript",
                    "Sliding Window"
                ],
                "code": "```\\nif (arr.length <= 1) return 1;\\n```\n```\\nif (arr[right - 1] === arr[right]) curTurbulentLength--;\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1466157,
                "title": "java-tc-o-n",
                "content": "```\\n    public int maxTurbulenceSize(int[] arr) {\\n        int sign = 0;\\n        int n = arr.length;\\n        int ret = 1;\\n        int cnt = 0;\\n        for(int i = 1; i < n; i++) {\\n            if(arr[i] == arr[i-1]) {\\n                sign = 0;\\n                cnt = 0;\\n            } else if(arr[i] > arr[i-1]) {\\n                cnt = sign == -1 ? cnt+1 : 2;\\n                sign = 1;\\n            } else {\\n                cnt = sign == 1 ? cnt+1 : 2;\\n                sign = -1;\\n            }\\n            ret = Math.max(ret,cnt);\\n        }\\n        return ret;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n    public int maxTurbulenceSize(int[] arr) {\\n        int sign = 0;\\n        int n = arr.length;\\n        int ret = 1;\\n        int cnt = 0;\\n        for(int i = 1; i < n; i++) {\\n            if(arr[i] == arr[i-1]) {\\n                sign = 0;\\n                cnt = 0;\\n            } else if(arr[i] > arr[i-1]) {\\n                cnt = sign == -1 ? cnt+1 : 2;\\n                sign = 1;\\n            } else {\\n                cnt = sign == 1 ? cnt+1 : 2;\\n                sign = -1;\\n            }\\n            ret = Math.max(ret,cnt);\\n        }\\n        return ret;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1465939,
                "title": "python-simple-2-pointers-o-n-time-o-1-space",
                "content": "Use variable `prev` to note whether the previous 2 numbers are equal (0), increase (1) or decrease (-1)\\nUse variable `cur` to note whether the current 2 numbers are equal (0), increase (1) or decrease (-1)\\n- if `cur == 0`, the current 2 consecutive numbers are equal, so we reset the window size to 1\\n- if `cur == prev`, the current 2 consecutive numbers does not flip increasing/decreasing, so we reset the window size to 2\\n- else, then `cur == -prev`, the current 2 consecutive numbers does flipped increasing/decreasing, so window size += 1\\n```\\ndef maxTurbulenceSize(self, arr):\\n\\tif len(arr) <= 1: return len(arr)\\n\\tprev = 0 if arr[1] == arr[0] else 1 if arr[1] > arr[0] else -1\\n\\tstreak = maxLen = 1 if prev == 0 else 2\\n\\tfor i in range(2, len(arr)):\\n\\t\\tcur = 0 if arr[i] == arr[i-1] else 1 if arr[i] > arr[i-1] else -1\\n\\t\\tstreak = 1 if cur == 0 else 2 if cur == prev else streak + 1\\n\\t\\tmaxLen = max(maxLen, streak)\\n\\t\\tprev = cur\\n\\treturn maxLen\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\ndef maxTurbulenceSize(self, arr):\\n\\tif len(arr) <= 1: return len(arr)\\n\\tprev = 0 if arr[1] == arr[0] else 1 if arr[1] > arr[0] else -1\\n\\tstreak = maxLen = 1 if prev == 0 else 2\\n\\tfor i in range(2, len(arr)):\\n\\t\\tcur = 0 if arr[i] == arr[i-1] else 1 if arr[i] > arr[i-1] else -1\\n\\t\\tstreak = 1 if cur == 0 else 2 if cur == prev else streak + 1\\n\\t\\tmaxLen = max(maxLen, streak)\\n\\t\\tprev = cur\\n\\treturn maxLen\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 1464950,
                "title": "python3-longest-turbulent-subarray-o-n-one-pass",
                "content": "Consider three cases for each element in the array:\\n* \\tThe element is the start of a new subarray ex. arr[1] or arr[i] (when arr[i-1] == arr[i-2])\\n* \\tThe element is a valid element in the current subarray (the turbulence differs from the previous turbulence)\\n* \\tThe element is invalid in the current subarray (the turbulence is the same as the previous turbulence)\\n```Python\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        cur, mx, t = 1, 1, None\\n        for i in range(1, len(arr)):\\n            # Start of subarray\\n            if t == None:\\n                if arr[i] != arr[i-1]: \\n                    cur = 2\\n                    t = arr[i] > arr[i-1]\\n            # Valid element in subarray, continue cur subarray\\n            elif (t and arr[i] < arr[i-1]) or (not t and arr[i] > arr[i-1]):\\n                cur += 1; t = not t\\n            # Invalid element in subarray, start new subarray\\n            else:\\n                if arr[i] == arr[i-1]: t = None\\n                mx = max(mx, cur)\\n                cur = 2\\n        \\n        return max(mx, cur)\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```Python\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        cur, mx, t = 1, 1, None\\n        for i in range(1, len(arr)):\\n            # Start of subarray\\n            if t == None:\\n                if arr[i] != arr[i-1]: \\n                    cur = 2\\n                    t = arr[i] > arr[i-1]\\n            # Valid element in subarray, continue cur subarray\\n            elif (t and arr[i] < arr[i-1]) or (not t and arr[i] > arr[i-1]):\\n                cur += 1; t = not t\\n            # Invalid element in subarray, start new subarray\\n            else:\\n                if arr[i] == arr[i-1]: t = None\\n                mx = max(mx, cur)\\n                cur = 2\\n        \\n        return max(mx, cur)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464825,
                "title": "python3-no-dp-simple-solution-o-n-time-o-1-space",
                "content": "The cmp function is the heaviest, take time to understand it! We take in odd, prev and curr information to make a judgement if the curr element is following the sequence or not.\\n\\n```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        def cmp(odd, prev, curr):\\n\\t\\t\\treturn curr < prev if odd else curr > prev\\n        \\n        n = len(arr)\\n        ans = 1\\n        for flip in [False, True]:\\n            l = 0\\n            for r in range(1, n):\\n                odd = r & 1\\n                prev = arr[r-1]\\n                curr = arr[r]\\n                if flip: odd = not odd\\n                if not cmp(odd, prev, curr): l = r\\n                ans = max(ans, r-l+1)\\n        \\n        return ans\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        def cmp(odd, prev, curr):\\n\\t\\t\\treturn curr < prev if odd else curr > prev\\n        \\n        n = len(arr)\\n        ans = 1\\n        for flip in [False, True]:\\n            l = 0\\n            for r in range(1, n):\\n                odd = r & 1\\n                prev = arr[r-1]\\n                curr = arr[r]\\n                if flip: odd = not odd\\n                if not cmp(odd, prev, curr): l = r\\n                ans = max(ans, r-l+1)\\n        \\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1335157,
                "title": "python-easy-dp-o-n-time",
                "content": "```\\nclass Solution(object):\\n    def maxTurbulenceSize(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp = [[1, 1] for i in range(len(arr))]\\n        dp[0][0] = 1\\n        dp[0][1] = 1\\n        ans = 1\\n        for i in range(1, len(arr)):\\n            if arr[i] < arr[i-1]:\\n                dp[i][0] = dp[i-1][1]+1\\n            elif arr[i] > arr[i-1]:\\n                dp[i][1] = dp[i-1][0]+1\\n            else:\\n                pass\\n            ans = max(ans, max(dp[i]))\\n        return ans\\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution(object):\\n    def maxTurbulenceSize(self, arr):\\n        \"\"\"\\n        :type arr: List[int]\\n        :rtype: int\\n        \"\"\"\\n        dp = [[1, 1] for i in range(len(arr))]\\n        dp[0][0] = 1\\n        dp[0][1] = 1\\n        ans = 1\\n        for i in range(1, len(arr)):\\n            if arr[i] < arr[i-1]:\\n                dp[i][0] = dp[i-1][1]+1\\n            elif arr[i] > arr[i-1]:\\n                dp[i][1] = dp[i-1][0]+1\\n            else:\\n                pass\\n            ans = max(ans, max(dp[i]))\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1272437,
                "title": "simple-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) \\n    {\\n     int maxi=1;\\n     for(int i=0;i<arr.size();)\\n     {\\n         int count=1;\\n         // dec start\\n       //  cout<<i<<\" \";\\n          int t=i;\\n           while(i<arr.size()-1)\\n           {\\n              \\n               if(i%2==0)\\n               {\\n                   if(arr[i]<=arr[i+1])\\n                   {\\n                       \\n                       break;\\n                   }\\n               }\\n               else\\n               {\\n                   if(arr[i]>=arr[i+1])\\n                   {\\n                       break;\\n                   }\\n               }\\n               count++;\\n               i++;\\n           }\\n       \\n          int count2=1;\\n         // inc start \\n         \\n          while(i<arr.size()-1)\\n           {\\n             \\n               if(i%2==0)\\n               {\\n                   if(arr[i]>=arr[i+1])\\n                   {\\n                       break;\\n                   }\\n               }\\n               else\\n               {\\n                   if(arr[i]<=arr[i+1])\\n                   {\\n                       break;\\n                   }\\n               }\\n              count2++;\\n              i++;\\n           }\\n         if(t==i)i++;\\n         \\n         maxi=max(maxi,max(count,count2));\\n         \\n     }\\n        return maxi;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) \\n    {\\n     int maxi=1;\\n     for(int i=0;i<arr.size();)\\n     {\\n         int count=1;\\n         // dec start\\n       //  cout<<i<<\" \";\\n          int t=i;\\n           while(i<arr.size()-1)\\n           {\\n              \\n               if(i%2==0)\\n               {\\n                   if(arr[i]<=arr[i+1])\\n                   {\\n                       \\n                       break;\\n                   }\\n               }\\n               else\\n               {\\n                   if(arr[i]>=arr[i+1])\\n                   {\\n                       break;\\n                   }\\n               }\\n               count++;\\n               i++;\\n           }\\n       \\n          int count2=1;\\n         // inc start \\n         \\n          while(i<arr.size()-1)\\n           {\\n             \\n               if(i%2==0)\\n               {\\n                   if(arr[i]>=arr[i+1])\\n                   {\\n                       break;\\n                   }\\n               }\\n               else\\n               {\\n                   if(arr[i]<=arr[i+1])\\n                   {\\n                       break;\\n                   }\\n               }\\n              count2++;\\n              i++;\\n           }\\n         if(t==i)i++;\\n         \\n         maxi=max(maxi,max(count,count2));\\n         \\n     }\\n        return maxi;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1267037,
                "title": "c-easy-dp-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int ans[100000][3],val = 1;\\n        //ans[i][0] - max subarray size ending at i with arr[i-1] < arr[i]\\n        //ans[i][1] - max subarray size ending at i with arr[i-1] > arr[i]\\n        ans[0][0] = ans[0][1] = 1;\\n        for(int i = 1;i<arr.size();i++){\\n            if(arr[i] > arr[i-1]){\\n                ans[i][1] = ans[i-1][0] + 1;\\n                ans[i][0] = 1;\\n            }\\n            else if(arr[i] < arr[i-1]){\\n                ans[i][0] = ans[i-1][1] + 1;\\n                ans[i][1] = 1;\\n            }\\n            else{\\n                ans[i][0] = ans[i][1] = 1;\\n            }\\n             val = max({val,ans[i][0],ans[i][1]});\\n        }\\n        return val;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int ans[100000][3],val = 1;\\n        //ans[i][0] - max subarray size ending at i with arr[i-1] < arr[i]\\n        //ans[i][1] - max subarray size ending at i with arr[i-1] > arr[i]\\n        ans[0][0] = ans[0][1] = 1;\\n        for(int i = 1;i<arr.size();i++){\\n            if(arr[i] > arr[i-1]){\\n                ans[i][1] = ans[i-1][0] + 1;\\n                ans[i][0] = 1;\\n            }\\n            else if(arr[i] < arr[i-1]){\\n                ans[i][0] = ans[i-1][1] + 1;\\n                ans[i][1] = 1;\\n            }\\n            else{\\n                ans[i][0] = ans[i][1] = 1;\\n            }\\n             val = max({val,ans[i][0],ans[i][1]});\\n        }\\n        return val;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1138266,
                "title": "fairly-easy-and-understandable-recursion-and-memoization",
                "content": "```\\nclass Solution {\\npublic:\\n    int t[40001][2][2];\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        \\n        if(arr.size() < 2)\\n            return arr.size();\\n        \\n        memset(t, -1, sizeof(t));\\n        \\n        int ans = 0;\\n        for(int i = 1; i < arr.size(); i++) //traversal for every element\\n            ans = max(ans, solve(arr, i, false, true)); // the first flag is for\\n           // switching comparison signs, the second is for stating that \\n\\t\\t   //this particular i(th) element is the new starting for the function solve\\n\\t\\t   //instead of using a prev variable I am using a bool because it saves me space.\\n        \\n        return ans;\\n    }\\n    \\n    int solve(vector<int>& arr, int i, bool flag, bool novel)\\n    {\\n        if(i > arr.size())\\n            return 0;\\n        \\n        if(t[i][flag][novel] != -1)\\n            return t[i][flag][novel];\\n        \\n        int ans = 0;\\n        \\n        if(novel || (!flag && arr[i - 1] < arr[i - 2])) // had I used prev variable,\\n\\t\\t//the condition would have been if(prev == 0 || .....), but this would \\n\\t\\t//take [40001][40001][2] space, the optimized code does the same work in\\n\\t\\t//[40001][2][2] space.\\n            ans = 1 + solve(arr, i + 1, true, false);\\n        \\n        if(novel || (flag && arr[i - 1] > arr[i - 2]))\\n            ans = max(ans, 1 + solve(arr, i + 1, false, false));\\n        \\n        return t[i][flag][novel] = ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "Recursion",
                    "Memoization"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int t[40001][2][2];\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        \\n        if(arr.size() < 2)\\n            return arr.size();\\n        \\n        memset(t, -1, sizeof(t));\\n        \\n        int ans = 0;\\n        for(int i = 1; i < arr.size(); i++) //traversal for every element\\n            ans = max(ans, solve(arr, i, false, true)); // the first flag is for\\n           // switching comparison signs, the second is for stating that \\n\\t\\t   //this particular i(th) element is the new starting for the function solve\\n\\t\\t   //instead of using a prev variable I am using a bool because it saves me space.\\n        \\n        return ans;\\n    }\\n    \\n    int solve(vector<int>& arr, int i, bool flag, bool novel)\\n    {\\n        if(i > arr.size())\\n            return 0;\\n        \\n        if(t[i][flag][novel] != -1)\\n            return t[i][flag][novel];\\n        \\n        int ans = 0;\\n        \\n        if(novel || (!flag && arr[i - 1] < arr[i - 2])) // had I used prev variable,\\n\\t\\t//the condition would have been if(prev == 0 || .....), but this would \\n\\t\\t//take [40001][40001][2] space, the optimized code does the same work in\\n\\t\\t//[40001][2][2] space.\\n            ans = 1 + solve(arr, i + 1, true, false);\\n        \\n        if(novel || (flag && arr[i - 1] > arr[i - 2]))\\n            ans = max(ans, 1 + solve(arr, i + 1, false, false));\\n        \\n        return t[i][flag][novel] = ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1124145,
                "title": "c-dp-92",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int dp1[arr.size()], dp2[arr.size()];\\n        for(int i = 0; i < arr.size(); i++){\\n            dp1[i] = dp2[i] = 1;\\n        }\\n        bool flag = true;\\n        for(int i = 1; i < arr.size(); i++){\\n            if(flag){\\n                if(arr[i] > arr[i - 1]){\\n                    dp1[i] = max(dp1[i], 1 + dp1[i - 1]);\\n                }else if(arr[i] < arr[i - 1]){\\n                    dp2[i] = max(dp2[i], 1 + dp2[i - 1]);\\n                }\\n                flag = false;\\n            }else{\\n                if(arr[i] < arr[i - 1]){\\n                    dp1[i] = max(dp1[i], 1 + dp1[i - 1]);\\n                }else if(arr[i] > arr[i - 1]){\\n                    dp2[i] = max(dp2[i], 1 + dp2[i - 1]);\\n                }\\n                flag = true;\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(int i = 0; i < arr.size(); i++){\\n            ans = max(ans, max(dp1[i], dp2[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int dp1[arr.size()], dp2[arr.size()];\\n        for(int i = 0; i < arr.size(); i++){\\n            dp1[i] = dp2[i] = 1;\\n        }\\n        bool flag = true;\\n        for(int i = 1; i < arr.size(); i++){\\n            if(flag){\\n                if(arr[i] > arr[i - 1]){\\n                    dp1[i] = max(dp1[i], 1 + dp1[i - 1]);\\n                }else if(arr[i] < arr[i - 1]){\\n                    dp2[i] = max(dp2[i], 1 + dp2[i - 1]);\\n                }\\n                flag = false;\\n            }else{\\n                if(arr[i] < arr[i - 1]){\\n                    dp1[i] = max(dp1[i], 1 + dp1[i - 1]);\\n                }else if(arr[i] > arr[i - 1]){\\n                    dp2[i] = max(dp2[i], 1 + dp2[i - 1]);\\n                }\\n                flag = true;\\n            }\\n        }\\n        int ans = INT_MIN;\\n        for(int i = 0; i < arr.size(); i++){\\n            ans = max(ans, max(dp1[i], dp2[i]));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1034318,
                "title": "using-sliding-window-easy-to-grasp-faster-run-time-99-24-space-98-23-efficient",
                "content": "This Code represents the first thought that comes to mind that is:\\nfor each starting point, find the subarray match one of the four case which are:\\n```\\nFor i <= k < j:\\narr[k] > arr[k + 1] when k is odd, and\\narr[k] < arr[k + 1] when k is even.\\nOr, for i <= k < j:\\narr[k] > arr[k + 1] when k is even, and\\narr[k] < arr[k + 1] when k is odd.\\n```\\n\\nand at each iteration update the ans, one thing to note in this question is that turbulent subarrays can not overlap so when a subarray is terminated the next one will surely start on or after that ending point.\\n\\nThe code:\\n```\\nint maxTurbulenceSize(vector<int>& arr) {\\n      \\n        int n= arr.size();\\n        int i=0,j=0;\\n        int ans=1;\\n        \\n        while(j<n-1)\\n        {\\n            ans= max(ans,j-i+1);\\n            if(j%2==1 && arr[j]>arr[j+1]){\\n                while(j<n){\\n                    ans= max(ans,j-i+1);\\n                    if(j==n-1)\\n                        break;\\n                    if(j%2==1 && arr[j]>arr[j+1])\\n                        j++;\\n                    else if(j%2==0 && arr[j]<arr[j+1])\\n                        j++;\\n                    else{\\n                        i=j;\\n                        break;\\n                    }\\n                    \\n                }\\n            }\\n            else if(j%2==1 && arr[j]<arr[j+1]){\\n                while(j<n){\\n                    ans= max(ans,j-i+1);\\n                    if(j==n-1)\\n                        break;\\n                    if(j%2==1 && arr[j]<arr[j+1])\\n                        j++;\\n                    else if(j%2==0 && arr[j]>arr[j+1])\\n                        j++;\\n                    else{\\n                        i=j;\\n                        break;\\n                    }\\n                }\\n            }\\n            else if(j%2==0 && arr[j]>arr[j+1]){\\n                while(j<n){\\n                    ans= max(ans,j-i+1);\\n                    if(j==n-1)\\n                        break;\\n                        \\n                    if(j%2==0 && arr[j]>arr[j+1])\\n                        j++;\\n                    else if(j%2==1 && arr[j]<arr[j+1])\\n                        j++;\\n                    else{\\n                        i=j;\\n                        break;\\n                    }\\n                }\\n            }\\n            else if(j%2==0 && arr[j]<arr[j+1]){\\n                while(j<n){\\n                    ans= max(ans,j-i+1);\\n                    \\n                    if(j==n-1)\\n                        break;\\n                    if(j%2==0 && arr[j]<arr[j+1])\\n                        j++;\\n                    else if(j%2==1 && arr[j]>arr[j+1])\\n                        j++;\\n                    else{\\n                        i=j;\\n                        break;\\n                    }\\n                }\\n            }\\n            else{\\n                j++;\\n                i=j;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nFor i <= k < j:\\narr[k] > arr[k + 1] when k is odd, and\\narr[k] < arr[k + 1] when k is even.\\nOr, for i <= k < j:\\narr[k] > arr[k + 1] when k is even, and\\narr[k] < arr[k + 1] when k is odd.\\n```\n```\\nint maxTurbulenceSize(vector<int>& arr) {\\n      \\n        int n= arr.size();\\n        int i=0,j=0;\\n        int ans=1;\\n        \\n        while(j<n-1)\\n        {\\n            ans= max(ans,j-i+1);\\n            if(j%2==1 && arr[j]>arr[j+1]){\\n                while(j<n){\\n                    ans= max(ans,j-i+1);\\n                    if(j==n-1)\\n                        break;\\n                    if(j%2==1 && arr[j]>arr[j+1])\\n                        j++;\\n                    else if(j%2==0 && arr[j]<arr[j+1])\\n                        j++;\\n                    else{\\n                        i=j;\\n                        break;\\n                    }\\n                    \\n                }\\n            }\\n            else if(j%2==1 && arr[j]<arr[j+1]){\\n                while(j<n){\\n                    ans= max(ans,j-i+1);\\n                    if(j==n-1)\\n                        break;\\n                    if(j%2==1 && arr[j]<arr[j+1])\\n                        j++;\\n                    else if(j%2==0 && arr[j]>arr[j+1])\\n                        j++;\\n                    else{\\n                        i=j;\\n                        break;\\n                    }\\n                }\\n            }\\n            else if(j%2==0 && arr[j]>arr[j+1]){\\n                while(j<n){\\n                    ans= max(ans,j-i+1);\\n                    if(j==n-1)\\n                        break;\\n                        \\n                    if(j%2==0 && arr[j]>arr[j+1])\\n                        j++;\\n                    else if(j%2==1 && arr[j]<arr[j+1])\\n                        j++;\\n                    else{\\n                        i=j;\\n                        break;\\n                    }\\n                }\\n            }\\n            else if(j%2==0 && arr[j]<arr[j+1]){\\n                while(j<n){\\n                    ans= max(ans,j-i+1);\\n                    \\n                    if(j==n-1)\\n                        break;\\n                    if(j%2==0 && arr[j]<arr[j+1])\\n                        j++;\\n                    else if(j%2==1 && arr[j]>arr[j+1])\\n                        j++;\\n                    else{\\n                        i=j;\\n                        break;\\n                    }\\n                }\\n            }\\n            else{\\n                j++;\\n                i=j;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 899241,
                "title": "c-one-pass-easy",
                "content": "\\n\\'\\'\\'\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& A) {\\n        int i,n=A.size(),len1=1,ans1=1,len2=1,ans2=1;\\n        \\n        for(i=1;i<n;i++){\\n            if(i%2 ==0){\\n                if(A[i]<A[i-1])\\n                {\\n                    len1++;\\n                    ans1=max(ans1,len1);\\n                    len2=1;\\n                }\\n                else if(A[i] > A[i-1]){\\n                    len1=1;\\n                    len2++;\\n                    ans2=max(ans2,len2);\\n                }\\n                else{\\n                    len1=1;len2=1;\\n                    \\n                }\\n                \\n            }\\n            \\n            if(i%2 !=0){\\n                if(A[i]>A[i-1])\\n                {\\n                    len1++;\\n                    ans1=max(ans1,len1);\\n                    len2=1;\\n                }\\n                else if(A[i]<A[i-1]){\\n                    len1=1;\\n                    len2++;\\n                    ans2=max(ans2,len2);\\n                }\\n                else{\\n                    len1=1;len2=1;\\n                }\\n            }\\n            \\n        }\\n        return max(ans1,ans2);\\n    }\\n};\\n\\'\\'\\'",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& A) {\\n        int i,n=A.size(),len1=1,ans1=1,len2=1,ans2=1;\\n        \\n        for(i=1;i<n;i++){\\n            if(i%2 ==0){\\n                if(A[i]<A[i-1])\\n                {\\n                    len1++;\\n                    ans1=max(ans1,len1);\\n                    len2=1;\\n                }",
                "codeTag": "Java"
            },
            {
                "id": 884651,
                "title": "java-sliding-window-faster-than-100-00",
                "content": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] A) {\\n       int start =0, max_len=1, opr=0;\\n        // max will be 1 initially since alteast 1 element array satisfies Turbulent \\n        // opr will be 1 if previous element is less than current, \\n        //            -1 if previous element is greater than current\\n        //             0 if previous element is equal\\n        \\n        for(int end=1; end<A.length; end++){\\n            \\n            if(A[end] > A[end-1]){\\n                if(opr==-1 || opr==0){\\n                    opr = 1; // changing operation for next element which should be less than current\\n                    max_len = Math.max(max_len, end - start +1);// capturing error condition\\n                }else{\\n                    start = end-1;// changing start value if tubulence condition fails, start position will be end-1 since we calculated till current value\\n                }\\n            }else if(A[end] < A[end-1]){\\n                if(opr==1 || opr==0){\\n                    opr = -1;  // changing operation for next element which should be greater than current\\n                    max_len = Math.max(max_len, end - start +1);\\n                }else{\\n                    start = end-1;// changing start value if tubulence condition fails, start position will be end-1 since we calculated till current value\\n                }\\n            }else if(A[end] == A[end-1]){\\n                opr=0; \\n                start = end; // if previous element is equal then start position will be end\\n            }\\n        }\\n        \\n        return max_len;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] A) {\\n       int start =0, max_len=1, opr=0;\\n        // max will be 1 initially since alteast 1 element array satisfies Turbulent \\n        // opr will be 1 if previous element is less than current, \\n        //            -1 if previous element is greater than current\\n        //             0 if previous element is equal\\n        \\n        for(int end=1; end<A.length; end++){\\n            \\n            if(A[end] > A[end-1]){\\n                if(opr==-1 || opr==0){\\n                    opr = 1; // changing operation for next element which should be less than current\\n                    max_len = Math.max(max_len, end - start +1);// capturing error condition\\n                }else{\\n                    start = end-1;// changing start value if tubulence condition fails, start position will be end-1 since we calculated till current value\\n                }\\n            }else if(A[end] < A[end-1]){\\n                if(opr==1 || opr==0){\\n                    opr = -1;  // changing operation for next element which should be greater than current\\n                    max_len = Math.max(max_len, end - start +1);\\n                }else{\\n                    start = end-1;// changing start value if tubulence condition fails, start position will be end-1 since we calculated till current value\\n                }\\n            }else if(A[end] == A[end-1]){\\n                opr=0; \\n                start = end; // if previous element is equal then start position will be end\\n            }\\n        }\\n        \\n        return max_len;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 668438,
                "title": "dp-similar-to-wiggle-sequence-t-o-n-s-o-1",
                "content": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, A):\\n        n=len(A)\\n        ans= up = down =1\\n        for i in range(1, n):\\n            if A[i]>A[i-1]:\\n                up, down = down+1, 1\\n                ans = max(ans, up)\\n            elif A[i]<A[i-1]:\\n                up, down = 1, up+1\\n                ans = max(ans, down)\\n            else:\\n                up = down = 1\\n        return ans\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, A):\\n        n=len(A)\\n        ans= up = down =1\\n        for i in range(1, n):\\n            if A[i]>A[i-1]:\\n                up, down = down+1, 1\\n                ans = max(ans, up)\\n            elif A[i]<A[i-1]:\\n                up, down = 1, up+1\\n                ans = max(ans, down)\\n            else:\\n                up = down = 1\\n        return ans\\n```",
                "codeTag": "Java"
            },
            {
                "id": 640728,
                "title": "c-dp-easy-to-understand-clean-code-explanation",
                "content": "**Thinking process:**\\n\\ndp[i]: longest turbulent subarray ending at A[i]\\nDefining two states: low to high transition and high to low transition.\\n\\ndp[i][0]: longest turbulent subarray ending at A[i] and A[i-1] < A[i] (low to high)\\ndp[i][1]: longest turbulent subarray ending at A[i] and A[i-1] > A[i] (high to low)\\n\\n**To increase the length there are couple of options:**\\n\\ndp[i][0] = max(dp[i][0], 1 + dp[i - 1][1]);  // prev state was [high to low] and we need to move from [low to high]\\ndp[i][1] = max(dp[i][1], 1 + dp[i - 1][0]);  // prev state was [low to high] and we need to move from [high to low]\\n\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& A) {\\n        \\n        int n = A.size();\\n        vector<vector<int>>dp(n, vector<int>(2, 1));\\n        \\n        int res = 1;\\n        for (int i = 1; i < n; i++) {\\n            if (A[i] > A[i-1])\\n                dp[i][0] = max(dp[i][0], 1 + dp[i-1][1]);\\n            else if (A[i] < A[i-1])\\n                dp[i][1] = max(dp[i][1], 1 + dp[i-1][0]);\\n            \\n            res = max(res, max(dp[i][0], dp[i][1]));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& A) {\\n        \\n        int n = A.size();\\n        vector<vector<int>>dp(n, vector<int>(2, 1));\\n        \\n        int res = 1;\\n        for (int i = 1; i < n; i++) {\\n            if (A[i] > A[i-1])\\n                dp[i][0] = max(dp[i][0], 1 + dp[i-1][1]);\\n            else if (A[i] < A[i-1])\\n                dp[i][1] = max(dp[i][1], 1 + dp[i-1][0]);\\n            \\n            res = max(res, max(dp[i][0], dp[i][1]));\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 363508,
                "title": "solve-this-problem-by-applying-standard-sliding-window-template-o-n-time-and-o-1-space",
                "content": "I solve this problem by treating it as a standard `sliding window` problem where I want to find out the maximum window that maintain the turbulent characteristics. We can then apply the standard template of sliding window for solving this problem\\n```py\\nclass Solution:\\n    def maxTurbulenceSize(self, A: List[int]) -> int:\\n        if not A:\\n            return 0 \\n\\n        nums = len(A)\\n        max_len = 1\\n\\n        # +1: prev element > current element\\n        # -1: prev element < current element\\n        # 0: prev element == current element\\n        prev, l = 2, 0\\n        for r in range(0, nums - 1):\\n            curr = 1 if A[r] > A[r + 1] else -1 if A[r] < A[r + 1] else 0\\n\\n            # in case previous comparison sign is the same as current or \\n            # previous flip sign is 0, we need to shrink window such that left\\n            # point is advanced to the right pointer\\n            if curr == prev or not prev:\\n                l = r\\n\\n            # update variable to record previous comparison sign\\n            prev = curr\\n\\n            # as long as current comparison sign is not equal (\"==\")\\n            # we should update our answer\\n            if curr:\\n                max_len = max(max_len, r - l + 2)\\n\\n        return max_len\\n```\\nHappy Coding~",
                "solutionTags": [],
                "code": "```py\\nclass Solution:\\n    def maxTurbulenceSize(self, A: List[int]) -> int:\\n        if not A:\\n            return 0 \\n\\n        nums = len(A)\\n        max_len = 1\\n\\n        # +1: prev element > current element\\n        # -1: prev element < current element\\n        # 0: prev element == current element\\n        prev, l = 2, 0\\n        for r in range(0, nums - 1):\\n            curr = 1 if A[r] > A[r + 1] else -1 if A[r] < A[r + 1] else 0\\n\\n            # in case previous comparison sign is the same as current or \\n            # previous flip sign is 0, we need to shrink window such that left\\n            # point is advanced to the right pointer\\n            if curr == prev or not prev:\\n                l = r\\n\\n            # update variable to record previous comparison sign\\n            prev = curr\\n\\n            # as long as current comparison sign is not equal (\"==\")\\n            # we should update our answer\\n            if curr:\\n                max_len = max(max_len, r - l + 2)\\n\\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 224282,
                "title": "dp-beat-100-python-3-short-and-easy-to-read-code-with-comments",
                "content": "```\\ndef maxTurbulenceSize(self, nums):\\n        dp = [1]*len(nums) #the shortest length is 1\\n    \\n        for i in range(len(nums)):\\n            if i >=2: # we update dp once all 3 numbers satisfy the turbulent condition\\n                if nums[i-2] <  nums[i-1] > nums[i] or nums[i-2] >  nums[i-1] < nums[i]:\\n                    dp[i] = dp[i-1]+1\\n                    continue\\n            if i >= 1: # if two numbers are not the same, update dp to 2\\n                if nums[i-1] != nums[i]:\\n                    dp[i] = 2\\n            if nums[i-1] == nums[i]: # don\\'t touch it if two numbers are the same\\n                continue\\n   \\n        return max(dp)\\n```",
                "solutionTags": [],
                "code": "```\\ndef maxTurbulenceSize(self, nums):\\n        dp = [1]*len(nums) #the shortest length is 1\\n    \\n        for i in range(len(nums)):\\n            if i >=2: # we update dp once all 3 numbers satisfy the turbulent condition\\n                if nums[i-2] <  nums[i-1] > nums[i] or nums[i-2] >  nums[i-1] < nums[i]:\\n                    dp[i] = dp[i-1]+1\\n                    continue\\n            if i >= 1: # if two numbers are not the same, update dp to 2\\n                if nums[i-1] != nums[i]:\\n                    dp[i] = 2\\n            if nums[i-1] == nums[i]: # don\\'t touch it if two numbers are the same\\n                continue\\n   \\n        return max(dp)\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 222286,
                "title": "2-line-python-solution-using-itertools-groupby",
                "content": "```\\ndef maxTurbulenceSize(self, A):\\n\\ts = [((y < x) - (x < y)) * (1 - (i & 1) * 2) for i, (x, y) in enumerate(zip(A, A[1:]))]\\n\\treturn max(list(len(list(b)) for a, b in itertools.groupby(s) if a != 0) or [0]) + 1\\n```\\n\\n`zip(A, A[1:])` - iterate through all pairs of consecutive elements\\n`for i, ... in enumerate(...)` - keep track of indices of the compared elements\\n`(y < x) - (x < y)` - compare two consecutive elements (`0` if equal, `1` if first one is greater, `-1` otherwise)\\n`... * (1 - (i & 1) * 2)` - invert sign of all comparison results on odd positions (so that `[1, -1, 1, -1]` becomes `[1, 1, 1, 1]`)\\n`len(list(b)) for a, b in itertools.groupby(s) if a != 0` - find length of the longest sequence of `1` only or `-1` only\\n`or [0]` - support cases where all elements of `A` are equal\\n`... + 1` - number of original elements is greater by 1 than number of their comparison results\\n\\nLet me know if something can be simplified here. Thanks.",
                "solutionTags": [],
                "code": "```\\ndef maxTurbulenceSize(self, A):\\n\\ts = [((y < x) - (x < y)) * (1 - (i & 1) * 2) for i, (x, y) in enumerate(zip(A, A[1:]))]\\n\\treturn max(list(len(list(b)) for a, b in itertools.groupby(s) if a != 0) or [0]) + 1\\n```",
                "codeTag": "Python3"
            },
            {
                "id": 221932,
                "title": "i-think-we-all-need-some-more-clarifications-on-this-question",
                "content": "Accepted submission rate was 1922/4415 ~ 43% in the contest.  I think many of us were confused.\\n```\\nFor i <= k < j, A[k] > A[k+1] when k is odd, and A[k] < A[k+1] when k is even;\\nOR, for i <= k < j, A[k] > A[k+1] when k is even, and A[k] < A[k+1] when k is odd.\\n```\\n\\nso for i <= k < j, when k is even, we get 2 conditions:  A[k] > A[k+1] and A[k] < A[k+1]?\\n\\n",
                "solutionTags": [],
                "code": "```\\nFor i <= k < j, A[k] > A[k+1] when k is odd, and A[k] < A[k+1] when k is even;\\nOR, for i <= k < j, A[k] > A[k+1] when k is even, and A[k] < A[k+1] when k is odd.\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 3892078,
                "title": "python-even-easier-explanation-o-n-time-o-1-space",
                "content": "# Intuition\\n<!-- Describe your first thoughts on how to solve this problem. -->\\nEvery non-empty subarray has a starting length of 1. If we \\'flop\\' a subarray, or we\\'ve destroyed our streak, we should restart the count at 1. \\n\\nThere are only 2 states that we need to keep track of (exluding the result, of course): whether the next element should be ```up``` or ```down``` compared  to its previous element. I used \\'up\\' and \\'down\\' because I thought of turbulent waves; they\\'re analogous to \\'greater\\' and \\'lesser.\\'\\n\\nSuppose we\\'re in a current subarray streak, and to continue this streak, the next element must be greater (```up```) than the current. So, we look at the ```up``` variable and increment it if the trend is continued. We then set ```down``` to ```up++``` and reset ```up``` to 1. At the next index, we\\'ll be looking for a value that\\'s ```down``` to continue our trend. \\n\\nWhy do we reset ```up``` to 1 right after learning ```n > n - 1``` in the previous example? If the following item breaks the streak (i.e, it\\'s greater than the current element when it should have been less), then we have the previous 1-streak available to us (stored in ```up```), making the new streak 2. \\n\\nHere\\'s a quick run-through of Example 1: ```[9,4,2,10,7,8,8,1,9]```\\n```\\nup = 1, down = 1, res = 1\\nIndex 1: 4 < 9 (previous element)\\nup = down + 1 = 1 + 1 = 2; down = 1; res = 2\\n\\nIndex 2: 2 < 4\\nup = down + 1 = 1 + 1 = 2; down = 1; res = 2\\n\\nIndex 3: 10 > 2\\ndown = up + 1 = 2 + 1 = 3; up = 1; res = 3\\n\\nIndex 4: 7 < 10\\nup = down + 1 = 3 + 1 = 4; down = 1; res = 4\\n\\nIndex 5: 8 > 7\\ndown = up + 1 = 4 + 1 = 5; up = 1; res = 5\\n\\nIndex 6: 8 == 8 (special case)\\ndown = 1; up = 1; res = 5\\n\\nIndex 7: 1 < 8\\nup = down + 1 = 1 + 1 = 2; down = 1; res = 5 (2 < 5)\\n\\nIndex 8: 9 > 1\\ndown = up + 1 = 2 + 1 = 3; up = 1; res = 5 (3 < 5)\\n\\nAnswer: 5\\n\\n```\\n\\n# Approach\\n<!-- Describe your approach to solving the problem. -->\\nYou may have noticed that there are 3 cases: \\n\\n```\\n1. current element > previous element\\n2. current element < previous element\\n3. current element == previous element\\n```\\n\\nThese are represented by the conditionals in the answer. Item 3(current == previous) is the \\'reset\\' case, the special \\'streak-breaking\\' case. When the element is not strictly greater or lesser than the previous element, the streak ends. Because they\\'re equal, both ```up``` and ```down``` streaks are erased and set to the base case.\\n\\n# Complexity\\n- Time complexity: $$O(n)$$\\n<!-- Add your time complexity here, e.g. $$O(n)$$ -->\\n\\n- Space complexity: $$O(1)$$\\n<!-- Add your space complexity here, e.g. $$O(n)$$ -->\\n\\n# Code\\n```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        down = up = res = 1\\n        for i in range(1, len(arr)):\\n            if arr[i] > arr[i - 1]:\\n                down = up + 1\\n                up = 1\\n            elif arr[i] < arr[i - 1]:\\n                up = down + 1\\n                down = 1\\n            else:\\n                down = 1\\n                up = 1\\n            res = max(res, up, down)\\n        return res\\n\\n```",
                "solutionTags": [
                    "Python3",
                    "Dynamic Programming"
                ],
                "code": "```up```\n```down```\n```up```\n```up```\n```down```\n```up++```\n```up```\n```down```\n```up```\n```n > n - 1```\n```up```\n```[9,4,2,10,7,8,8,1,9]```\n```\\nup = 1, down = 1, res = 1\\nIndex 1: 4 < 9 (previous element)\\nup = down + 1 = 1 + 1 = 2; down = 1; res = 2\\n\\nIndex 2: 2 < 4\\nup = down + 1 = 1 + 1 = 2; down = 1; res = 2\\n\\nIndex 3: 10 > 2\\ndown = up + 1 = 2 + 1 = 3; up = 1; res = 3\\n\\nIndex 4: 7 < 10\\nup = down + 1 = 3 + 1 = 4; down = 1; res = 4\\n\\nIndex 5: 8 > 7\\ndown = up + 1 = 4 + 1 = 5; up = 1; res = 5\\n\\nIndex 6: 8 == 8 (special case)\\ndown = 1; up = 1; res = 5\\n\\nIndex 7: 1 < 8\\nup = down + 1 = 1 + 1 = 2; down = 1; res = 5 (2 < 5)\\n\\nIndex 8: 9 > 1\\ndown = up + 1 = 2 + 1 = 3; up = 1; res = 5 (3 < 5)\\n\\nAnswer: 5\\n\\n```\n```\\n1. current element > previous element\\n2. current element < previous element\\n3. current element == previous element\\n```\n```up```\n```down```\n```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        down = up = res = 1\\n        for i in range(1, len(arr)):\\n            if arr[i] > arr[i - 1]:\\n                down = up + 1\\n                up = 1\\n            elif arr[i] < arr[i - 1]:\\n                up = down + 1\\n                down = 1\\n            else:\\n                down = 1\\n                up = 1\\n            res = max(res, up, down)\\n        return res\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3737901,
                "title": "c-tricky-question-with-best-possible-solution",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n=arr.size();\\n        int bestlength=0,curlength=0;\\n        for(int i=0;i<n;i++){\\n            if(i>=2 && (((arr[i-2]>arr[i-1])&&(arr[i-1]<arr[i]))||((arr[i-2]<arr[i-1])&&(arr[i-1]>arr[i])))) curlength++;\\n            else if(i>=1 && arr[i-1]!=arr[i]) curlength=2;\\n            else curlength=1;\\n            bestlength=max(bestlength,curlength);\\n        }\\n        return bestlength;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n=arr.size();\\n        int bestlength=0,curlength=0;\\n        for(int i=0;i<n;i++){\\n            if(i>=2 && (((arr[i-2]>arr[i-1])&&(arr[i-1]<arr[i]))||((arr[i-2]<arr[i-1])&&(arr[i-1]>arr[i])))) curlength++;\\n            else if(i>=1 && arr[i-1]!=arr[i]) curlength=2;\\n            else curlength=1;\\n            bestlength=max(bestlength,curlength);\\n        }\\n        return bestlength;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3534573,
                "title": "solution",
                "content": "```C++ []\\nclass Solution {\\npublic:\\nSolution(){\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n    }\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int flag=0,n=arr.size(),res=0,i=0,j=1;\\n        if(arr.size()==1)\\n        return n;\\n        if(n==2&&arr[i]==arr[j])\\n        return 1;\\n        else if(arr[i]==arr[j])\\n        {\\n            i++;j++;\\n        }\\n        while(j<n)\\n        {\\n            if(arr[j-1]>arr[j]&&flag!=1)\\n            flag=1;\\n            else if(arr[j-1]<arr[j]&&flag!=2)\\n            flag=2;\\n            else if(arr[j-1]==arr[j])\\n            {\\n                i=j;\\n                flag=0;\\n            }\\n            else\\n            i=j-1;\\n            res=max(res,j-i+1);\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```\\n\\n```Python3 []\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n\\n        max_size = 1\\n\\n        last = arr[0]\\n\\n        curr_size = 1\\n        \\n        last_op = 0 # 0 == eq, 1 == gt, 2 == lt\\n\\n        for n in arr[1:]:\\n            if n > last:\\n                if last_op != 2:\\n                    curr_size = 2\\n                else:\\n                    curr_size += 1\\n                last_op = 1\\n            elif n < last:\\n                if last_op != 1:\\n                    curr_size = 2\\n                else:\\n                    curr_size += 1\\n                last_op = 2\\n            else:\\n                curr_size = 1\\n                last_op = 0\\n                      \\n            last = n\\n\\n            if curr_size > max_size:\\n                max_size = curr_size\\n\\n        return max_size\\n```\\n\\n```Java []\\nclass Solution {\\n    public static int maxTurbulenceSize(int[] arr) {\\n        int k = 1;\\n        int max = 1;\\n        char prev = \\'p\\';\\n        char current = \\'p\\';\\n        for (int i = 0; i < arr.length - 1; i++) {\\n            if (arr[i] < arr[i + 1]) {\\n                current = \\'<\\';\\n            } else if(arr[i] > arr[i + 1]) {\\n                current = \\'>\\';\\n            }\\n            else{prev = \\'=\\';\\n                if (k > max){max = k;}\\n                k = 1;\\n                continue;\\n            }\\n            if (current != prev) {\\n                k++;\\n            }\\n            else{\\n                if (k > max){max = k;}\\n                k = 2;\\n            }\\n            prev = current;\\n        }\\n        if (k > max){max = k;}\\n        if(k==arr.length){\\n            max=k;\\n        }\\n        return max;\\n    }\\n}\\n```\\n",
                "solutionTags": [
                    "C++",
                    "Java",
                    "Python3"
                ],
                "code": "```C++ []\\nclass Solution {\\npublic:\\nSolution(){\\n        ios_base::sync_with_stdio(false);\\n        cin.tie(0);\\n    }\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int flag=0,n=arr.size(),res=0,i=0,j=1;\\n        if(arr.size()==1)\\n        return n;\\n        if(n==2&&arr[i]==arr[j])\\n        return 1;\\n        else if(arr[i]==arr[j])\\n        {\\n            i++;j++;\\n        }\\n        while(j<n)\\n        {\\n            if(arr[j-1]>arr[j]&&flag!=1)\\n            flag=1;\\n            else if(arr[j-1]<arr[j]&&flag!=2)\\n            flag=2;\\n            else if(arr[j-1]==arr[j])\\n            {\\n                i=j;\\n                flag=0;\\n            }\\n            else\\n            i=j-1;\\n            res=max(res,j-i+1);\\n            j++;\\n        }\\n        return res;\\n    }\\n};\\n```\n```Python3 []\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n\\n        max_size = 1\\n\\n        last = arr[0]\\n\\n        curr_size = 1\\n        \\n        last_op = 0 # 0 == eq, 1 == gt, 2 == lt\\n\\n        for n in arr[1:]:\\n            if n > last:\\n                if last_op != 2:\\n                    curr_size = 2\\n                else:\\n                    curr_size += 1\\n                last_op = 1\\n            elif n < last:\\n                if last_op != 1:\\n                    curr_size = 2\\n                else:\\n                    curr_size += 1\\n                last_op = 2\\n            else:\\n                curr_size = 1\\n                last_op = 0\\n                      \\n            last = n\\n\\n            if curr_size > max_size:\\n                max_size = curr_size\\n\\n        return max_size\\n```\n```Java []\\nclass Solution {\\n    public static int maxTurbulenceSize(int[] arr) {\\n        int k = 1;\\n        int max = 1;\\n        char prev = \\'p\\';\\n        char current = \\'p\\';\\n        for (int i = 0; i < arr.length - 1; i++) {\\n            if (arr[i] < arr[i + 1]) {\\n                current = \\'<\\';\\n            } else if(arr[i] > arr[i + 1]) {\\n                current = \\'>\\';\\n            }\\n            else{prev = \\'=\\';\\n                if (k > max){max = k;}\\n                k = 1;\\n                continue;\\n            }\\n            if (current != prev) {\\n                k++;\\n            }\\n            else{\\n                if (k > max){max = k;}\\n                k = 2;\\n            }\\n            prev = current;\\n        }\\n        if (k > max){max = k;}\\n        if(k==arr.length){\\n            max=k;\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3507251,
                "title": "try-both-possibilities-easy-java-dp-o-n",
                "content": "The approach used in the code is to keep track of two counts - count1 and count2, which represent the lengths of the current turbulent subarray ending at the current index, with the last two elements being in increasing and decreasing order respectively. We also maintain count1Max and count2Max which represent the maximum lengths of such subarrays seen so far.\\n\\nTo check if the current element nums[i] and the previous element nums[i-1] form a turbulent subarray or not, we use a flag variable flag that alternates between 0 and 1 at each index.\\n\\nIf flag is 0, we check if nums[i] is less than nums[i-1]. If it is, we increment count1 and update count1Max with the maximum of count1 and count1Max. If nums[i] is not less than nums[i-1], it means the turbulent subarray has ended, so we reset count1 to 1.\\n\\nSimilarly, if flag is 1, we check if nums[i] is greater than nums[i-1]. If it is, we increment count1 and update count1Max with the maximum of count1 and count1Max. If nums[i] is not greater than nums[i-1], it means the turbulent subarray has ended, so we reset count1 to 1.\\n\\nSimilar is the case for other possibility for which we have maintained count2 and count2Max.\\n\\nFinally, we return the maximum of count1Max and count2Max, which represents the length of the longest turbulent subarray in nums.\\n\\nOverall, the time complexity of the given code is O(N), where N is the length of the input array, since we only iterate through the array once.\\n\\n```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] nums) {\\n        int count1Max = 1;\\n        int count2Max = 1;\\n        int count1 = 1;\\n        int count2 = 1;\\n        int flag = 0;\\n        for(int i=1; i<nums.length; i++){\\n            if((flag==0 && nums[i]<nums[i-1]) || (flag==1 && nums[i]>nums[i-1])){\\n                count1++;\\n                count1Max = Math.max(count1Max,count1);\\n            }else{\\n                count1 = 1;\\n            }\\n            if((flag==0 && nums[i]>nums[i-1]) || (flag==1 && nums[i]<nums[i-1])){\\n                count2++;\\n                count2Max = Math.max(count2Max,count2);\\n            }else{\\n                count2 = 1;\\n            }\\n            flag^=1;\\n        }\\n        return Math.max(count1Max,count2Max);  \\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] nums) {\\n        int count1Max = 1;\\n        int count2Max = 1;\\n        int count1 = 1;\\n        int count2 = 1;\\n        int flag = 0;\\n        for(int i=1; i<nums.length; i++){\\n            if((flag==0 && nums[i]<nums[i-1]) || (flag==1 && nums[i]>nums[i-1])){\\n                count1++;\\n                count1Max = Math.max(count1Max,count1);\\n            }else{\\n                count1 = 1;\\n            }\\n            if((flag==0 && nums[i]>nums[i-1]) || (flag==1 && nums[i]<nums[i-1])){\\n                count2++;\\n                count2Max = Math.max(count2Max,count2);\\n            }else{\\n                count2 = 1;\\n            }\\n            flag^=1;\\n        }\\n        return Math.max(count1Max,count2Max);  \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3393105,
                "title": "sliding-window-approach-to-maximum-turbulent-subarray-using-c",
                "content": "# Intuition\\nThe problem asks us to find the maximum \"turbulent subarray\" of a given array. A turbulent subarray is defined as one where the sign of the difference between adjacent elements alternates between positive and negative. Our intuition would be to use a sliding window approach where we keep track of the current subarray and check if it is turbulent.\\n\\n# Approach\\nWe can use a two-pointer approach where we maintain two pointers, `l` and `r`, that define the current subarray. We also maintain a variable `prev` that stores the previous comparison result. We then iterate from index 1 to the end of the array and update our pointers and result accordingly based on whether the subarray is turbulent or not.\\n\\n# Complexity\\n- Time complexity: O(n), where n is the length of the input array. We traverse the entire array once.\\n- Space complexity: O(1), since we use constant extra space to store variables `l`, `r`, `prev`, and `res`. \\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int l = 0, r = 1;\\n        string prev = \"\";\\n        int res = 1;\\n\\n        while(r < arr.size()) {\\n            if(arr[r - 1] > arr[r] && prev != \">\") {\\n                res = max(res, r - l + 1);\\n                r += 1;\\n                prev = \">\";\\n            }\\n            else if(arr[r - 1] < arr[r] && prev != \"<\") {\\n                res = max(res, r - l + 1);\\n                r += 1;\\n                prev = \"<\";\\n            }\\n            else {\\n                r = arr[r - 1] == arr[r] ? r + 1 : r;\\n                l = r - 1;\\n                prev = \"\";\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int l = 0, r = 1;\\n        string prev = \"\";\\n        int res = 1;\\n\\n        while(r < arr.size()) {\\n            if(arr[r - 1] > arr[r] && prev != \">\") {\\n                res = max(res, r - l + 1);\\n                r += 1;\\n                prev = \">\";\\n            }\\n            else if(arr[r - 1] < arr[r] && prev != \"<\") {\\n                res = max(res, r - l + 1);\\n                r += 1;\\n                prev = \"<\";\\n            }\\n            else {\\n                r = arr[r - 1] == arr[r] ? r + 1 : r;\\n                l = r - 1;\\n                prev = \"\";\\n            }\\n        }\\n\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3335733,
                "title": "best-code-in-c-slidingwindow",
                "content": "# Complexity\\n- Time complexity:\\nO(n)\\n\\n- Space complexity:\\nO(1)\\n\\n# Code\\n### Please Upvote if u liked my Solution\\uD83E\\uDD17\\n```\\nclass Solution {\\npublic:\\n    bool flag;\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n=arr.size(),i=0,j=1,ans=1;                                                                            \\n        while(j<n){                   // > --> taking it as true\\n            if(i==j-1)                // < --> taking it as false\\n                flag = (arr[j] < arr[j-1])? true : false;\\n            if(arr[j] == arr[j-1]){\\n                i=j++;\\n                continue;\\n            }\\n            bool ch=false;\\n            if(arr[j] < arr[j-1])\\n                ch=true;\\n            if(ch == flag)\\n                i=j-1;\\n            else\\n                flag=ch;\\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n    \\n```",
                "solutionTags": [
                    "C++",
                    "Array",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    bool flag;\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n=arr.size(),i=0,j=1,ans=1;                                                                            \\n        while(j<n){                   // > --> taking it as true\\n            if(i==j-1)                // < --> taking it as false\\n                flag = (arr[j] < arr[j-1])? true : false;\\n            if(arr[j] == arr[j-1]){\\n                i=j++;\\n                continue;\\n            }\\n            bool ch=false;\\n            if(arr[j] < arr[j-1])\\n                ch=true;\\n            if(ch == flag)\\n                i=j-1;\\n            else\\n                flag=ch;\\n            ans=max(ans,j-i+1);\\n            j++;\\n        }\\n        return ans;\\n    }\\n};\\n    \\n```",
                "codeTag": "Java"
            },
            {
                "id": 3251471,
                "title": "c-recursive-top-down-bottom-up-space-optimised-bottom-up",
                "content": "```C++ []\\n\\nTC: O(n^2) for every i, we are traversing from i->0 ( maximum)\\nSC: O(n) call stack\\n\\n\\nTLE on testcase 90/91\\n\\nclass Solution {\\n    int maxlen =1;\\n    \\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n= arr.size();\\n\\n        for(int i=1; i<n; i++){\\n            int up_left = dfs(arr, i,1);      // starting from i, we move   up to (i-1) , so its a   up, down,   up, down,........ sequence\\n            int down_left = dfs(arr, i, 0);  // starting from i, we move down to (i-1) , so its a down,   up, down,   up,........ sequence\\n            maxlen = max( maxlen,  1 + max( up_left, down_left));\\n        }\\n        return maxlen;\\n    }\\n\\n    //\"next_is_greater\"  means next-to-current element > current element\\n    // i.e.,  the next of ith element is (i+1)th element\\n    // next_is_greater = 1, indicates that arr[i+1] > arr[i]\\n    // nexxt_is_greater =0, indicates that arr[i+1] < arr[i]\\n\\n    int  dfs( vector<int>& arr, int idx, int next_is_greater){\\n        if( idx== 0)\\n            return 0;\\n      \\n        int include=0, cant_include=0;\\n\\n        // if next is > , prev should also be >           or           if next is < , prev should also be <\\n        if( ( next_is_greater && arr[idx-1] > arr[idx] ) ||  ( next_is_greater ==0 && arr[idx-1] < arr[idx] )) \\n            include = 1+dfs( arr, idx-1, !next_is_greater);\\n            \\n        else \\n            cant_include = 0; // ik this is redundant, but i like to keep it readable and understandable\\n            \\n        return  max( include, cant_include);\\n        \\n    }\\n};\\n```\\n```C++ []\\nTC: O(n) because of dp\\nSC: O(n) vector + call stack\\n\\n\\nclass Solution {\\n    int maxlen =1;\\n    vector<vector<int>>dp;\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n= arr.size();\\n        dp.resize(n+1, vector<int>(2, -1));\\n        \\n        for(int i=1; i<n; i++){\\n            maxlen = max( maxlen,1+ max( dfs(arr, i,1), dfs( arr, i,0)));\\n        }\\n        return maxlen;\\n    }\\n\\n    //\"next_is_greater\"  means next-to-current element > current element\\n    int  dfs( vector<int>& arr, int idx, int next_is_greater){\\n        if( idx== 0)\\n            return 0;\\n\\n        if( dp[idx][next_is_greater] != -1)\\n            return dp[idx][next_is_greater];\\n      \\n        int include=0, cant_include=0;\\n        // if next is > , prev should also be >           or           if next is < , prev should also be <\\n        if( ( next_is_greater && arr[idx-1] > arr[idx] ) ||  ( next_is_greater ==0 && arr[idx-1] < arr[idx] )) \\n            include = 1+dfs( arr, idx-1, !next_is_greater);\\n        else \\n            cant_include = 0; // ik this is redundant, but i like to keep it readable and understandable\\n            \\n        return dp[idx][next_is_greater] = max( include, cant_include);\\n        \\n    }\\n};\\n```\\n```C++ []\\nBOTTOM - UP DP\\nTC: O(n) \\nSC: O(n) because of dp\\n\\n\\nclass Solution {\\n    int maxlen =1;\\n    vector<vector<int>>dp;\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n= arr.size();\\n        dp.resize(n, vector<int>(2, 0));\\n        \\n        for(int idx=1; idx<n; idx++){\\n            for(int next_is_greater=0; next_is_greater<=1; next_is_greater++){\\n                if( ( next_is_greater && arr[idx-1] > arr[idx] ) ||  ( next_is_greater ==0 && arr[idx-1] < arr[idx] )) \\n                    dp[idx][next_is_greater] = 1+dp[idx-1][!next_is_greater];\\n                else\\n                    dp[idx][next_is_greater] =0; // redundant , ik\\n\\n                maxlen = max( maxlen,1+ dp[idx][next_is_greater]);\\n            }\\n        }\\n        \\n        return maxlen;\\n    }\\n};\\n```\\n\\n\\n```C++ []\\nspace -optimised solution\\nTC: O(n)\\nSC: O(1)\\n\\nclass Solution {\\n    int maxlen =1;\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n= arr.size();\\n        \\n        int previous_less =1, previous_greater=1;\\n        for(int idx=1; idx<n; idx++){\\n            int curr_less=1, curr_greater=1;\\n            if( arr[idx] < arr[idx-1]  ){\\n                previous_less = (curr_less = previous_greater +1);\\n                previous_greater = (curr_greater =1);\\n            }\\n            else if( arr[idx] > arr[idx-1] ) {\\n                previous_greater = (curr_greater = previous_less +1);\\n                previous_less = (curr_less = 1);  \\n            }\\n            else{\\n                previous_less = 1;\\n                previous_greater=1;\\n            }\\n            maxlen = max( maxlen,max(curr_less, curr_greater));\\n            \\n        }\\n        \\n        return maxlen;\\n    }\\n};\\n```\\n\\n\\n",
                "solutionTags": [
                    "C++",
                    "C",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```C++ []\\n\\nTC: O(n^2) for every i, we are traversing from i->0 ( maximum)\\nSC: O(n) call stack\\n\\n\\nTLE on testcase 90/91\\n\\nclass Solution {\\n    int maxlen =1;\\n    \\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n= arr.size();\\n\\n        for(int i=1; i<n; i++){\\n            int up_left = dfs(arr, i,1);      // starting from i, we move   up to (i-1) , so its a   up, down,   up, down,........ sequence\\n            int down_left = dfs(arr, i, 0);  // starting from i, we move down to (i-1) , so its a down,   up, down,   up,........ sequence\\n            maxlen = max( maxlen,  1 + max( up_left, down_left));\\n        }\\n        return maxlen;\\n    }\\n\\n    //\"next_is_greater\"  means next-to-current element > current element\\n    // i.e.,  the next of ith element is (i+1)th element\\n    // next_is_greater = 1, indicates that arr[i+1] > arr[i]\\n    // nexxt_is_greater =0, indicates that arr[i+1] < arr[i]\\n\\n    int  dfs( vector<int>& arr, int idx, int next_is_greater){\\n        if( idx== 0)\\n            return 0;\\n      \\n        int include=0, cant_include=0;\\n\\n        // if next is > , prev should also be >           or           if next is < , prev should also be <\\n        if( ( next_is_greater && arr[idx-1] > arr[idx] ) ||  ( next_is_greater ==0 && arr[idx-1] < arr[idx] )) \\n            include = 1+dfs( arr, idx-1, !next_is_greater);\\n            \\n        else \\n            cant_include = 0; // ik this is redundant, but i like to keep it readable and understandable\\n            \\n        return  max( include, cant_include);\\n        \\n    }\\n};\\n```\n```C++ []\\nTC: O(n) because of dp\\nSC: O(n) vector + call stack\\n\\n\\nclass Solution {\\n    int maxlen =1;\\n    vector<vector<int>>dp;\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n= arr.size();\\n        dp.resize(n+1, vector<int>(2, -1));\\n        \\n        for(int i=1; i<n; i++){\\n            maxlen = max( maxlen,1+ max( dfs(arr, i,1), dfs( arr, i,0)));\\n        }\\n        return maxlen;\\n    }\\n\\n    //\"next_is_greater\"  means next-to-current element > current element\\n    int  dfs( vector<int>& arr, int idx, int next_is_greater){\\n        if( idx== 0)\\n            return 0;\\n\\n        if( dp[idx][next_is_greater] != -1)\\n            return dp[idx][next_is_greater];\\n      \\n        int include=0, cant_include=0;\\n        // if next is > , prev should also be >           or           if next is < , prev should also be <\\n        if( ( next_is_greater && arr[idx-1] > arr[idx] ) ||  ( next_is_greater ==0 && arr[idx-1] < arr[idx] )) \\n            include = 1+dfs( arr, idx-1, !next_is_greater);\\n        else \\n            cant_include = 0; // ik this is redundant, but i like to keep it readable and understandable\\n            \\n        return dp[idx][next_is_greater] = max( include, cant_include);\\n        \\n    }\\n};\\n```\n```C++ []\\nBOTTOM - UP DP\\nTC: O(n) \\nSC: O(n) because of dp\\n\\n\\nclass Solution {\\n    int maxlen =1;\\n    vector<vector<int>>dp;\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n= arr.size();\\n        dp.resize(n, vector<int>(2, 0));\\n        \\n        for(int idx=1; idx<n; idx++){\\n            for(int next_is_greater=0; next_is_greater<=1; next_is_greater++){\\n                if( ( next_is_greater && arr[idx-1] > arr[idx] ) ||  ( next_is_greater ==0 && arr[idx-1] < arr[idx] )) \\n                    dp[idx][next_is_greater] = 1+dp[idx-1][!next_is_greater];\\n                else\\n                    dp[idx][next_is_greater] =0; // redundant , ik\\n\\n                maxlen = max( maxlen,1+ dp[idx][next_is_greater]);\\n            }\\n        }\\n        \\n        return maxlen;\\n    }\\n};\\n```\n```C++ []\\nspace -optimised solution\\nTC: O(n)\\nSC: O(1)\\n\\nclass Solution {\\n    int maxlen =1;\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n= arr.size();\\n        \\n        int previous_less =1, previous_greater=1;\\n        for(int idx=1; idx<n; idx++){\\n            int curr_less=1, curr_greater=1;\\n            if( arr[idx] < arr[idx-1]  ){\\n                previous_less = (curr_less = previous_greater +1);\\n                previous_greater = (curr_greater =1);\\n            }\\n            else if( arr[idx] > arr[idx-1] ) {\\n                previous_greater = (curr_greater = previous_less +1);\\n                previous_less = (curr_less = 1);  \\n            }\\n            else{\\n                previous_less = 1;\\n                previous_greater=1;\\n            }\\n            maxlen = max( maxlen,max(curr_less, curr_greater));\\n            \\n        }\\n        \\n        return maxlen;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3171740,
                "title": "c-sliding-window-na-ve-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int low = 0;\\n        int high = 1;\\n        int cnt = 1;\\n        int ans = 1;\\n        string str = \"neutral\";\\n        while(low<high and high < arr.size()){\\n            // cout<<low<<\" \"<<high<<\" \"<<cnt<<endl;\\n            if(str == \"neutral\"){\\n                if(arr[high] == arr[low]){\\n                    low++;\\n                    high++;\\n                    continue;\\n                }\\n                else if(arr[high] > arr[low]){\\n                    str = \"smaller\";\\n                    cnt++;\\n                }\\n                else{\\n                    str = \"greater\";\\n                    cnt++;\\n                }\\n                low++;\\n                high++;\\n            }\\n            else if(str == \"smaller\"){\\n                if(arr[high] >= arr[low]){\\n                    \\n                    ans = max(ans , cnt);\\n                    str = \"neutral\";\\n                    cnt = 1;\\n                }\\n                else {\\n                    str = \"greater\";\\n                    low+=1;\\n                    high+=1;\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                if(arr[high] <= arr[low]){\\n                    ans = max(ans , cnt);\\n                    str = \"neutral\";\\n                    cnt = 1;\\n                }\\n                else{\\n                    str = \"smaller\";\\n                    cnt++;\\n                    low++;\\n                    high++;\\n                }\\n            }\\n            \\n\\n\\n        }\\n        ans = max(ans , cnt);\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int low = 0;\\n        int high = 1;\\n        int cnt = 1;\\n        int ans = 1;\\n        string str = \"neutral\";\\n        while(low<high and high < arr.size()){\\n            // cout<<low<<\" \"<<high<<\" \"<<cnt<<endl;\\n            if(str == \"neutral\"){\\n                if(arr[high] == arr[low]){\\n                    low++;\\n                    high++;\\n                    continue;\\n                }\\n                else if(arr[high] > arr[low]){\\n                    str = \"smaller\";\\n                    cnt++;\\n                }\\n                else{\\n                    str = \"greater\";\\n                    cnt++;\\n                }\\n                low++;\\n                high++;\\n            }\\n            else if(str == \"smaller\"){\\n                if(arr[high] >= arr[low]){\\n                    \\n                    ans = max(ans , cnt);\\n                    str = \"neutral\";\\n                    cnt = 1;\\n                }\\n                else {\\n                    str = \"greater\";\\n                    low+=1;\\n                    high+=1;\\n                    cnt++;\\n                }\\n            }\\n            else{\\n                if(arr[high] <= arr[low]){\\n                    ans = max(ans , cnt);\\n                    str = \"neutral\";\\n                    cnt = 1;\\n                }\\n                else{\\n                    str = \"smaller\";\\n                    cnt++;\\n                    low++;\\n                    high++;\\n                }\\n            }\\n            \\n\\n\\n        }\\n        ans = max(ans , cnt);\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 3122907,
                "title": "easy-c-solution",
                "content": "\\n\\n# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) \\n    {\\n        if (arr.size()<2) return arr.size();\\n        int ans=1;\\n        int start=0;\\n        int end=0;\\n        int n=arr.size();\\n        while(start+1<n)\\n        {\\n            if (arr[start+1]==arr[start])\\n            {\\n                start++;\\n                continue;\\n            }\\n            end=start+1;\\n            while(end+1<n && isTurbulent(arr,end))\\n            {\\n                end++;\\n            }\\n            ans=max(ans,end-start+1);\\n            start=end;\\n        }\\n        return ans;\\n\\n    }\\n    bool isTurbulent(vector<int>&arr,int end)\\n    {\\n        if ((arr[end]<arr[end+1] && arr[end]<arr[end-1])||(arr[end]>arr[end+1]&& arr[end]>arr[end-1])) return true;\\n        return false;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) \\n    {\\n        if (arr.size()<2) return arr.size();\\n        int ans=1;\\n        int start=0;\\n        int end=0;\\n        int n=arr.size();\\n        while(start+1<n)\\n        {\\n            if (arr[start+1]==arr[start])\\n            {\\n                start++;\\n                continue;\\n            }\\n            end=start+1;\\n            while(end+1<n && isTurbulent(arr,end))\\n            {\\n                end++;\\n            }\\n            ans=max(ans,end-start+1);\\n            start=end;\\n        }\\n        return ans;\\n\\n    }\\n    bool isTurbulent(vector<int>&arr,int end)\\n    {\\n        if ((arr[end]<arr[end+1] && arr[end]<arr[end-1])||(arr[end]>arr[end+1]&& arr[end]>arr[end-1])) return true;\\n        return false;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 3072412,
                "title": "function-iterator",
                "content": "\\n\\n# Code\\n```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        count = 1\\n        maxi = 1\\n        comp = cycle([gt, lt])\\n        for a, b in pairwise(arr):\\n            if next(comp)(a, b):\\n                count += 1\\n            else:\\n                maxi = max(maxi, count)\\n                count = 2 - (a == b)\\n                next(comp)\\n            \\n        return max(maxi, count)\\n```",
                "solutionTags": [
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        count = 1\\n        maxi = 1\\n        comp = cycle([gt, lt])\\n        for a, b in pairwise(arr):\\n            if next(comp)(a, b):\\n                count += 1\\n            else:\\n                maxi = max(maxi, count)\\n                count = 2 - (a == b)\\n                next(comp)\\n            \\n        return max(maxi, count)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2952839,
                "title": "sliding-window-method",
                "content": "# Code\\n```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        //sliding window method\\n        int n=arr.size(),i=0,j=0,ans=1;\\n        bool flag=1;\\n        while(j+1<n){\\n            if((arr[j]>arr[j+1] && flag==1) || (arr[j]<arr[j+1] && flag==0)){\\n                flag=!flag;\\n                ans=max(ans,j-i+2);\\n                j++;\\n            }\\n            else if((arr[j]<arr[j+1] &&flag==1)||(arr[j]>arr[j+1]&&flag==0)){\\n                flag=!flag;\\n                i=j;\\n            }\\n            else{ //equal elements\\n                j++;\\n                i=j;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        //sliding window method\\n        int n=arr.size(),i=0,j=0,ans=1;\\n        bool flag=1;\\n        while(j+1<n){\\n            if((arr[j]>arr[j+1] && flag==1) || (arr[j]<arr[j+1] && flag==0)){\\n                flag=!flag;\\n                ans=max(ans,j-i+2);\\n                j++;\\n            }\\n            else if((arr[j]<arr[j+1] &&flag==1)||(arr[j]>arr[j+1]&&flag==0)){\\n                flag=!flag;\\n                i=j;\\n            }\\n            else{ //equal elements\\n                j++;\\n                i=j;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2611981,
                "title": "c-o-n-tc-using-simple-1d-dp",
                "content": "```\\n\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        //corner cases:\\n        if(n == 1) return 1;\\n        if(n == 2){\\n            if(arr[0] != arr[1]) return 2;\\n            else return 1;\\n        }\\n        \\n        \\n        //state : dp[i] => length of maximum turbulent array ending at ith index\\n        vector<int> dp(n, 0);\\n        dp[0] = 1;\\n        if(arr[0] != arr[1]) dp[1] = 2;\\n        else dp[1] = 1;  \\n        \\n        int ans = max(dp[0], dp[1]);\\n        \\n        for(int i=2;i<n;i++){\\n            if(arr[i] < arr[i-1] && arr[i-1] > arr[i-2]){\\n                dp[i] = dp[i-1] + 1;\\n            }\\n            else if(arr[i] > arr[i-1] && arr[i-1] < arr[i-2]){\\n                dp[i] = dp[i-1] + 1;\\n            }\\n            else{\\n                if(arr[i] != arr[i-1]){\\n                    dp[i] = 2;\\n                }\\n                else{\\n                    dp[i] = 1;\\n                }\\n            }\\n            ans = max(ans, dp[i]);\\n        }\\n\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "```\\n\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        \\n        int n = arr.size();\\n        \\n        //corner cases:\\n        if(n == 1) return 1;\\n        if(n == 2){\\n            if(arr[0] != arr[1]) return 2;\\n            else return 1;\\n        }\\n        \\n        \\n        //state : dp[i] => length of maximum turbulent array ending at ith index\\n        vector<int> dp(n, 0);\\n        dp[0] = 1;\\n        if(arr[0] != arr[1]) dp[1] = 2;\\n        else dp[1] = 1;  \\n        \\n        int ans = max(dp[0], dp[1]);\\n        \\n        for(int i=2;i<n;i++){\\n            if(arr[i] < arr[i-1] && arr[i-1] > arr[i-2]){\\n                dp[i] = dp[i-1] + 1;\\n            }\\n            else if(arr[i] > arr[i-1] && arr[i-1] < arr[i-2]){\\n                dp[i] = dp[i-1] + 1;\\n            }\\n            else{\\n                if(arr[i] != arr[i-1]){\\n                    dp[i] = 2;\\n                }\\n                else{\\n                    dp[i] = 1;\\n                }\\n            }\\n            ans = max(ans, dp[i]);\\n        }\\n\\n        \\n        \\n        return ans;\\n        \\n    }\\n};\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2513165,
                "title": "compare-with-previous-element-o-n-solution",
                "content": "There are 2 variables \\nup : lenth of subarray till last element when last elemnt is at peak\\ndown : lenth of subarray till last element when last elemnt is at valley\\n\\nif current element is smaller than previous element then pre ele is a peak and current element is a valley \\nso updated values are down = up + 1 ans up = 1;\\n\\nif current element is larget than previous element then pre ele is a valley and current element is a peak \\nso updated values are up = down + 1 ans down = 1;\\n\\nif current element is same as previous element then \\nso updated values are down = 1 ans up = 1;\\n\\n```\\nint maxTurbulenceSize(vector<int>& arr) {\\n        int up = 1 , down = 1;\\n        int n = arr.size();\\n        int ans = 1;\\n        for(int i = 1 ; i < n ; i++){\\n            if(arr[i-1] < arr[i]){\\n                up = down+1;\\n                down = 1;\\n                if(up > ans)\\n                    ans = up;\\n            }\\n            else if(arr[i-1] > arr[i]){\\n                down = up+1;\\n                up=1;\\n                if(down > ans)\\n                    ans = down;\\n                \\n            }\\n            else{\\n                up = down = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t",
                "solutionTags": [],
                "code": "There are 2 variables \\nup : lenth of subarray till last element when last elemnt is at peak\\ndown : lenth of subarray till last element when last elemnt is at valley\\n\\nif current element is smaller than previous element then pre ele is a peak and current element is a valley \\nso updated values are down = up + 1 ans up = 1;\\n\\nif current element is larget than previous element then pre ele is a valley and current element is a peak \\nso updated values are up = down + 1 ans down = 1;\\n\\nif current element is same as previous element then \\nso updated values are down = 1 ans up = 1;\\n\\n```\\nint maxTurbulenceSize(vector<int>& arr) {\\n        int up = 1 , down = 1;\\n        int n = arr.size();\\n        int ans = 1;\\n        for(int i = 1 ; i < n ; i++){\\n            if(arr[i-1] < arr[i]){\\n                up = down+1;\\n                down = 1;\\n                if(up > ans)\\n                    ans = up;\\n            }\\n            else if(arr[i-1] > arr[i]){\\n                down = up+1;\\n                up=1;\\n                if(down > ans)\\n                    ans = down;\\n                \\n            }\\n            else{\\n                up = down = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n\\t",
                "codeTag": "Unknown"
            },
            {
                "id": 2468596,
                "title": "sliding-window-c",
                "content": "# Approach\\nWhen is our window valid -> When there is alternate sequence from left to right and at every index.\\nWhen we need to update our window ->\\n**Case 1** -> Two **same elements** - We need to start a new window from the later element as if we start from any index before current then these two equal elements will be included.\\n\\nExample -> 2 4 1 **5 5** 6 3. Here we need to start from the second 5 so that the sequence 5 5 is not included.\\n\\n**Case 2** -> Two **same inequalities** -> We need to start from the later inequality as if we start from any index before this inequality then two same consecutive inequalities will be included.\\n\\nExample -> 2 4 **1 3 6** 2 5 3. Here we need to start from the middle element which is 3 because if we start from any element before 3 then 1 3 6 sequence will be included and it is not valid.\\n```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n = arr.size();\\n\\t\\t// op 0 indicates we can choose any new inequality bcoz we have only 1 element in our window\\n\\t\\t// op 1 indicates prev inequality was increment so curr should be decrement\\n\\t\\t// op 2 indicates prev inequality was decrement so curr should be increment\\n        int op = 0,ans = 1, prev = arr[0], l = 0;\\n        // find the max subarray upto current index\\n        for(int i=1; i<n; i++){\\n            // if we have got two elements equal then we need to start new sequence\\n            // from the 2nd element\\n            if(arr[i] == prev) l = i, op = 0;\\n            // if curr is greater than prev but prev is > prev-1, then \\n            // new seq needs to be started from prev\\n            else if(arr[i] > prev){\\n                if(op == 1) l = i-1;\\n                op = 1;\\n            }\\n            // same case for smaller\\n            else{\\n                if(op == -1) l = i-1;\\n                op = -1;\\n            }\\n            // cout<<i<<\" \"<<l<<\"\\\\n\";\\n            // check the curr range and see if it is max\\n            ans = max(ans, i-l+1);\\n            // update prev\\n            prev = arr[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n = arr.size();\\n\\t\\t// op 0 indicates we can choose any new inequality bcoz we have only 1 element in our window\\n\\t\\t// op 1 indicates prev inequality was increment so curr should be decrement\\n\\t\\t// op 2 indicates prev inequality was decrement so curr should be increment\\n        int op = 0,ans = 1, prev = arr[0], l = 0;\\n        // find the max subarray upto current index\\n        for(int i=1; i<n; i++){\\n            // if we have got two elements equal then we need to start new sequence\\n            // from the 2nd element\\n            if(arr[i] == prev) l = i, op = 0;\\n            // if curr is greater than prev but prev is > prev-1, then \\n            // new seq needs to be started from prev\\n            else if(arr[i] > prev){\\n                if(op == 1) l = i-1;\\n                op = 1;\\n            }\\n            // same case for smaller\\n            else{\\n                if(op == -1) l = i-1;\\n                op = -1;\\n            }\\n            // cout<<i<<\" \"<<l<<\"\\\\n\";\\n            // check the curr range and see if it is max\\n            ans = max(ans, i-l+1);\\n            // update prev\\n            prev = arr[i];\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 2409086,
                "title": "python-dp-solution",
                "content": "Whenever you see subarrays, always think of dp[i] = something something... for subarrays ending at index i\\n```\\nclass Solution:\\n    # 1 <= arr.length <= 4 * 104 -> it\\'s asking for a O(N) solution\\n    # and clearly it\\'s a DP problem\\n    # And because we can have arr[i] > arr[i-1] or arr[i] < arr[i-1], so we separate out the two cases    \\n    # dp[j][i] = length of a maximum size turbulent subarray ending at index [i], ending with arr[i] gone up (j = 0) and down (j = 1) from arr[i-1]\\n    # So the recurrence relation will be:\\n    # dp[0][i] = 1, dp[1][i] = 1\\n    # if arr[i] > arr[i-1]: dp[0][i] = max(dp[0][i], 1+ dp[1][i-1])\\n    # if arr[i] < arr[i-1]: dp[1][i] = max(dp[1][i], 1+ dp[0][i-1])\\n    # Since dp[j][i] only depends on dp[j][i-1], in principle the space complexity can be \\n\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        n, result = len(arr), 1\\n        dp = [[1 for i in range(n)] for j in range(2)]\\n        \\n        for i in range(1, n):\\n            if arr[i] > arr[i-1]:\\n                dp[0][i] = max(dp[0][i], 1 + dp[1][i-1])\\n                result = max(result, dp[0][i])\\n            elif arr[i] < arr[i-1]:\\n                dp[1][i] = max(dp[1][i], 1 + dp[0][i-1])\\n                result = max(result, dp[1][i])\\n        return result\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    # 1 <= arr.length <= 4 * 104 -> it\\'s asking for a O(N) solution\\n    # and clearly it\\'s a DP problem\\n    # And because we can have arr[i] > arr[i-1] or arr[i] < arr[i-1], so we separate out the two cases    \\n    # dp[j][i] = length of a maximum size turbulent subarray ending at index [i], ending with arr[i] gone up (j = 0) and down (j = 1) from arr[i-1]\\n    # So the recurrence relation will be:\\n    # dp[0][i] = 1, dp[1][i] = 1\\n    # if arr[i] > arr[i-1]: dp[0][i] = max(dp[0][i], 1+ dp[1][i-1])\\n    # if arr[i] < arr[i-1]: dp[1][i] = max(dp[1][i], 1+ dp[0][i-1])\\n    # Since dp[j][i] only depends on dp[j][i-1], in principle the space complexity can be \\n\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        n, result = len(arr), 1\\n        dp = [[1 for i in range(n)] for j in range(2)]\\n        \\n        for i in range(1, n):\\n            if arr[i] > arr[i-1]:\\n                dp[0][i] = max(dp[0][i], 1 + dp[1][i-1])\\n                result = max(result, dp[0][i])\\n            elif arr[i] < arr[i-1]:\\n                dp[1][i] = max(dp[1][i], 1 + dp[0][i-1])\\n                result = max(result, dp[1][i])\\n        return result\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2154592,
                "title": "easy-cpp-without-dp-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int maxl=1,maxr=1,l=1,r=1;\\n        for(int i=1;i<arr.size();i++){\\n            if(i%2 && arr[i]>arr[i-1]) l++;\\n            else if(i%2==0 && arr[i]<arr[i-1]) l++;\\n            else l=1;\\n            maxl=max(l,maxl);\\n        }\\n         for(int i=1;i<arr.size();i++){\\n            if(i%2 && arr[i]<arr[i-1]) r++;\\n            else if(i%2==0 && arr[i]>arr[i-1]) r++;\\n            else r=1;\\n            maxr=max(r,maxr);\\n        }\\n        return max(maxl,maxr);\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int maxl=1,maxr=1,l=1,r=1;\\n        for(int i=1;i<arr.size();i++){\\n            if(i%2 && arr[i]>arr[i-1]) l++;\\n            else if(i%2==0 && arr[i]<arr[i-1]) l++;\\n            else l=1;\\n            maxl=max(l,maxl);\\n        }\\n         for(int i=1;i<arr.size();i++){\\n            if(i%2 && arr[i]<arr[i-1]) r++;\\n            else if(i%2==0 && arr[i]>arr[i-1]) r++;\\n            else r=1;\\n            maxr=max(r,maxr);\\n        }\\n        return max(maxl,maxr);\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2087791,
                "title": "c-solution-of-normal-logic",
                "content": "Just remember to update the longest turbulent at the end of the loop.\\n```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n = arr.size();\\n        if (n == 1){return 1;}\\n        int turbulent, longest_turbulent = 1;\\n        int pre_state, state;\\n        for (int i = 1; i < n; i++){\\n            if (i == 1){\\n                if (arr[i] > arr[i - 1]){\\n                    state = 1;\\n                    turbulent = 2;\\n                }             \\n                else if(arr[i] < arr[i - 1]){\\n                    state = 2;\\n                    turbulent = 2;\\n                }\\n                else{\\n                    state = 0;\\n                    turbulent = 0;\\n                }\\n            }\\n            else{\\n                if (arr[i] > arr[i - 1]){\\n                    state = 1;\\n                    if (pre_state == 2){\\n                        turbulent++;\\n                    }\\n                    else if (pre_state == 1){\\n                        longest_turbulent = max(longest_turbulent, turbulent);\\n                        turbulent = 2;\\n                    }\\n                    else{\\n                        turbulent = 2;\\n                    }\\n                }\\n                else if (arr[i] < arr[i - 1]){\\n                    state = 2;\\n                    if (pre_state == 2){\\n                        longest_turbulent = max(longest_turbulent, turbulent);\\n                        turbulent = 2;\\n                    }\\n                    else if (pre_state == 1){\\n                        turbulent++;\\n                    }\\n                    else{\\n                        turbulent = 2;\\n                    }\\n                }\\n                else{\\n                    state = 0;\\n                    longest_turbulent = max(longest_turbulent, turbulent);\\n                    turbulent = 0;\\n                }\\n            }\\n            pre_state = state;\\n        }\\n        longest_turbulent = max(longest_turbulent, turbulent);\\n        return longest_turbulent;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n = arr.size();\\n        if (n == 1){return 1;}\\n        int turbulent, longest_turbulent = 1;\\n        int pre_state, state;\\n        for (int i = 1; i < n; i++){\\n            if (i == 1){\\n                if (arr[i] > arr[i - 1]){\\n                    state = 1;\\n                    turbulent = 2;\\n                }             \\n                else if(arr[i] < arr[i - 1]){\\n                    state = 2;\\n                    turbulent = 2;\\n                }\\n                else{\\n                    state = 0;\\n                    turbulent = 0;\\n                }\\n            }\\n            else{\\n                if (arr[i] > arr[i - 1]){\\n                    state = 1;\\n                    if (pre_state == 2){\\n                        turbulent++;\\n                    }\\n                    else if (pre_state == 1){\\n                        longest_turbulent = max(longest_turbulent, turbulent);\\n                        turbulent = 2;\\n                    }\\n                    else{\\n                        turbulent = 2;\\n                    }\\n                }\\n                else if (arr[i] < arr[i - 1]){\\n                    state = 2;\\n                    if (pre_state == 2){\\n                        longest_turbulent = max(longest_turbulent, turbulent);\\n                        turbulent = 2;\\n                    }\\n                    else if (pre_state == 1){\\n                        turbulent++;\\n                    }\\n                    else{\\n                        turbulent = 2;\\n                    }\\n                }\\n                else{\\n                    state = 0;\\n                    longest_turbulent = max(longest_turbulent, turbulent);\\n                    turbulent = 0;\\n                }\\n            }\\n            pre_state = state;\\n        }\\n        longest_turbulent = max(longest_turbulent, turbulent);\\n        return longest_turbulent;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 2076983,
                "title": "c-simple-alternate-slope-check-o-n-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n = arr.size();\\n        if (n == 1) {\\n            return 1;\\n        }\\n        int slope = arr[0] - arr[1];\\n        int len=slope==0?1:2;\\n        int ans = len;\\n        for (int i = 1; i < n - 1; i++) {\\n            if(arr[i]==arr[i+1]){\\n                len=1;\\n                continue;\\n            }\\n            int newslope = arr[i] - arr[i + 1];\\n            if ((newslope > 0 && slope < 0 ) || ( newslope < 0 && slope > 0) ) {\\n                len++;\\n            }\\n            else {\\n                len = 2;\\n            }\\n             ans=max(ans,len);\\n            slope = newslope;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n = arr.size();\\n        if (n == 1) {\\n            return 1;\\n        }\\n        int slope = arr[0] - arr[1];\\n        int len=slope==0?1:2;\\n        int ans = len;\\n        for (int i = 1; i < n - 1; i++) {\\n            if(arr[i]==arr[i+1]){\\n                len=1;\\n                continue;\\n            }\\n            int newslope = arr[i] - arr[i + 1];\\n            if ((newslope > 0 && slope < 0 ) || ( newslope < 0 && slope > 0) ) {\\n                len++;\\n            }\\n            else {\\n                len = 2;\\n            }\\n             ans=max(ans,len);\\n            slope = newslope;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1945926,
                "title": "easy-c-71-faster-61-space",
                "content": "```\\nint maxTurbulenceSize(vector<int>& arr) {\\n    if(arr.size()==1) return 1;\\n    int i, ans=1, n=arr.size()-1, curr=1;\\n    bool less = arr[0]<arr[1] ? true:false; \\n    for(i=0;i<n;++i){\\n        ans = max(ans,curr);\\n        if((less and arr[i]<arr[i+1]) or (!less and arr[i]>arr[i+1])) ++curr;\\n        else{\\n            while(i<n and arr[i]==arr[i+1]) ++i;\\n            if(i==n) break;\\n            curr=2;\\n            less = arr[i]<arr[i+1] ? true:false;\\n        }\\n        less = less ? false:true;\\n    }\\n    return max(ans,curr);\\n}\\n```",
                "solutionTags": [
                    "C++",
                    "C",
                    "Sliding Window"
                ],
                "code": "```\\nint maxTurbulenceSize(vector<int>& arr) {\\n    if(arr.size()==1) return 1;\\n    int i, ans=1, n=arr.size()-1, curr=1;\\n    bool less = arr[0]<arr[1] ? true:false; \\n    for(i=0;i<n;++i){\\n        ans = max(ans,curr);\\n        if((less and arr[i]<arr[i+1]) or (!less and arr[i]>arr[i+1])) ++curr;\\n        else{\\n            while(i<n and arr[i]==arr[i+1]) ++i;\\n            if(i==n) break;\\n            curr=2;\\n            less = arr[i]<arr[i+1] ? true:false;\\n        }\\n        less = less ? false:true;\\n    }\\n    return max(ans,curr);\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1921535,
                "title": "c-o-n-and-o-1-space-3-lines-aolution",
                "content": "```\\nint maxTurbulenceSize(vector<int>& v) {\\n      //BAZ64 PERSONAL\\n      std::ios_base::sync_with_stdio(0);\\n      int ans=1,res=1;\\n      for(int i=1;i<v.size();i++)\\n      {\\n        if(i==v.size()-1 && v[i]!=v[i-1]){res++;ans=max(ans,res);continue;}\\n        if(i!=v.size()-1 && v[i]>v[i+1] && v[i]>v[i-1]) {res++; continue;}\\n        if(i!=v.size()-1 && v[i]<v[i+1] && v[i]<v[i-1]) {res++; continue;}\\n        if(v[i]!=v[i-1]) res++; ans = max(ans,res);res = 1; \\n        \\n      }\\n  \\n      return ans;\\n    \\n      \\n        \\n      \\n        \\n    }",
                "solutionTags": [],
                "code": "```\\nint maxTurbulenceSize(vector<int>& v) {\\n      //BAZ64 PERSONAL\\n      std::ios_base::sync_with_stdio(0);\\n      int ans=1,res=1;\\n      for(int i=1;i<v.size();i++)\\n      {\\n        if(i==v.size()-1 && v[i]!=v[i-1]){res++;ans=max(ans,res);continue;}\\n        if(i!=v.size()-1 && v[i]>v[i+1] && v[i]>v[i-1]) {res++; continue;}\\n        if(i!=v.size()-1 && v[i]<v[i+1] && v[i]<v[i-1]) {res++; continue;}\\n        if(v[i]!=v[i-1]) res++; ans = max(ans,res);res = 1; \\n        \\n      }\\n  \\n      return ans;\\n    \\n      \\n        \\n      \\n        \\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1894531,
                "title": "a-c-solution-using-dp-variant-of-kadane-algorithm",
                "content": "Kandane algorithm scans whole array once and records local maximum and global maximum. Here, we repeatly swap two variables: `s` and `l` to capture turbulent pattern.\\n\\n```c++\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {        \\n        int ans = 1;\\n        int s = 1;\\n        int l = 1;\\n        \\n        for (int i = 0; i < arr.size() - 1; ++i) {\\n            s = arr[i] < arr[i + 1] ? s + 1 : 1;\\n            l = arr[i] > arr[i + 1] ? l + 1 : 1;\\n            \\n            ans = max(ans, max(s, l));\\n            swap(s, l);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```c++\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {        \\n        int ans = 1;\\n        int s = 1;\\n        int l = 1;\\n        \\n        for (int i = 0; i < arr.size() - 1; ++i) {\\n            s = arr[i] < arr[i + 1] ? s + 1 : 1;\\n            l = arr[i] > arr[i + 1] ? l + 1 : 1;\\n            \\n            ans = max(ans, max(s, l));\\n            swap(s, l);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1891042,
                "title": "simplistic-approach-with-loop-o-n-time-and-o-1-space",
                "content": "```\\n**//if u like this approach u can upvote **\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int max_v=0;\\n        int cnt=0;\\n        if(arr.size()==1)return 1;\\n       for(int k=0;k<arr.size()-1;k++){\\n           if(k%2==0 && arr[k] > arr[k + 1])cnt++;\\n           else if(k%2!=0 && arr[k] < arr[k + 1])cnt++;\\n           else cnt=0;\\n           max_v=max(max_v,cnt);\\n       } \\n        cnt=0;\\n       for(int k=0;k<arr.size()-1;k++){\\n           if(k%2==0 && arr[k] < arr[k + 1])cnt++;\\n           else if(k%2!=0 && arr[k] > arr[k + 1])cnt++;\\n           else cnt=0;\\n           max_v=max(max_v,cnt);\\n       } \\n        return max_v+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\n**//if u like this approach u can upvote **\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int max_v=0;\\n        int cnt=0;\\n        if(arr.size()==1)return 1;\\n       for(int k=0;k<arr.size()-1;k++){\\n           if(k%2==0 && arr[k] > arr[k + 1])cnt++;\\n           else if(k%2!=0 && arr[k] < arr[k + 1])cnt++;\\n           else cnt=0;\\n           max_v=max(max_v,cnt);\\n       } \\n        cnt=0;\\n       for(int k=0;k<arr.size()-1;k++){\\n           if(k%2==0 && arr[k] < arr[k + 1])cnt++;\\n           else if(k%2!=0 && arr[k] > arr[k + 1])cnt++;\\n           else cnt=0;\\n           max_v=max(max_v,cnt);\\n       } \\n        return max_v+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1732130,
                "title": "java-dp-recursive",
                "content": "```\\nclass Solution {\\n    int max = 0;\\n    public int maxTurbulenceSize(int[] arr) {\\n        if(arr.length == 1) return 1;\\n        solve(arr, 1, 0, true, 0); // Gives answer for initial increasing substring\\n        solve(arr, 1, 0, false, 0); // Gives answer for initial decreasing substring\\n        return max;\\n    }\\n    \\n    private int solve(int[] arr, int n, int p, boolean up, int count) {\\n        \\n        max = Math.max(max, count);\\n        \\n        if(n == arr.length) {\\n            return 0;\\n        }\\n        \\n        if(up && arr[n] > arr[p]) {\\n            return solve(arr, n+1, n, !up, count+1);\\n        } if(!up && arr[n] < arr[p]) {\\n            return solve(arr, n+1, n, !up, count+1);\\n        } else {\\n            if(arr[n] == arr[p]) {\\n                return solve(arr, n+1, n, up, 1);\\n            } else {\\n\\t\\t\\t\\t// TC : [2, 8, 10, 5]  After 8 we are expecting some lesser number (current up value = false),\\n\\t\\t\\t\\t// but we got larger number, so we reset substring count to 2 for (8, 10) and send the \\n\\t\\t\\t\\t// current up value i.e. false because we are expecting next value after 10 to be lower. \\n                return solve(arr, n+1, n, up, 2);\\n            }\\n            \\n        }\\n    }\\n    \\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming",
                    "Recursion"
                ],
                "code": "```\\nclass Solution {\\n    int max = 0;\\n    public int maxTurbulenceSize(int[] arr) {\\n        if(arr.length == 1) return 1;\\n        solve(arr, 1, 0, true, 0); // Gives answer for initial increasing substring\\n        solve(arr, 1, 0, false, 0); // Gives answer for initial decreasing substring\\n        return max;\\n    }\\n    \\n    private int solve(int[] arr, int n, int p, boolean up, int count) {\\n        \\n        max = Math.max(max, count);\\n        \\n        if(n == arr.length) {\\n            return 0;\\n        }\\n        \\n        if(up && arr[n] > arr[p]) {\\n            return solve(arr, n+1, n, !up, count+1);\\n        } if(!up && arr[n] < arr[p]) {\\n            return solve(arr, n+1, n, !up, count+1);\\n        } else {\\n            if(arr[n] == arr[p]) {\\n                return solve(arr, n+1, n, up, 1);\\n            } else {\\n\\t\\t\\t\\t// TC : [2, 8, 10, 5]  After 8 we are expecting some lesser number (current up value = false),\\n\\t\\t\\t\\t// but we got larger number, so we reset substring count to 2 for (8, 10) and send the \\n\\t\\t\\t\\t// current up value i.e. false because we are expecting next value after 10 to be lower. \\n                return solve(arr, n+1, n, up, 2);\\n            }\\n            \\n        }\\n    }\\n    \\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1694085,
                "title": "python-o-n-dp-solution",
                "content": "Standard DP process.\\n\\nTime Complexity: O(n)\\nSpace Complexity: O(n)\\n\\nSpace complexity can be decreased to O(1) if one squeezes a dp list to a dp tuple, which only keeps track of the last item of the original dp list.\\n\\n```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:    \\n        n = len(arr)\\n        \\n\\t\\t# dp[i][0]: the length of the longest turbulent subarray of arr[0...i]\\n\\t\\t# dp[i][1]: difference between arr[i] and arr[i-1]\\n        dp = [(1, 0)] * n\\n\\t\\t\\n\\t\\t# now that arr.length >= 1, so res is initiated to 1\\n        res = 1\\n        \\n        for i in range(1, n):               \\n            diff = arr[i] - arr[i-1]\\n\\t\\t\\t\\n\\t\\t\\t# current diff > 0 and previous diff <= 0\\n\\t\\t\\t# => arr[i] can be appended to the end of last turbulent subarray\\n            if diff > 0 and dp[i-1][1] <= 0:\\n                dp[i] = (dp[i-1][0] + 1, diff)\\n\\t\\t\\t\\n\\t\\t\\t# current diff < 0 and previous diff >= 0\\n\\t\\t\\t# => arr[i] can be appended to the end of last turbulent subarray\\n            elif diff < 0 and dp[i-1][1] >= 0:\\n                dp[i] = (dp[i-1][0] + 1, diff)\\n\\t\\t\\t\\n            else:\\n\\t\\t\\t\\t# arr[i] != arr[i-1]\\n\\t\\t\\t\\t# => dp[i] = (2, diff)\\n                if diff != 0:\\n                    dp[i] = (2, diff)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t# update res in each loop\\n            res = max(res, dp[i][0])\\n\\n        return res\\n```",
                "solutionTags": [
                    "Python",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:    \\n        n = len(arr)\\n        \\n\\t\\t# dp[i][0]: the length of the longest turbulent subarray of arr[0...i]\\n\\t\\t# dp[i][1]: difference between arr[i] and arr[i-1]\\n        dp = [(1, 0)] * n\\n\\t\\t\\n\\t\\t# now that arr.length >= 1, so res is initiated to 1\\n        res = 1\\n        \\n        for i in range(1, n):               \\n            diff = arr[i] - arr[i-1]\\n\\t\\t\\t\\n\\t\\t\\t# current diff > 0 and previous diff <= 0\\n\\t\\t\\t# => arr[i] can be appended to the end of last turbulent subarray\\n            if diff > 0 and dp[i-1][1] <= 0:\\n                dp[i] = (dp[i-1][0] + 1, diff)\\n\\t\\t\\t\\n\\t\\t\\t# current diff < 0 and previous diff >= 0\\n\\t\\t\\t# => arr[i] can be appended to the end of last turbulent subarray\\n            elif diff < 0 and dp[i-1][1] >= 0:\\n                dp[i] = (dp[i-1][0] + 1, diff)\\n\\t\\t\\t\\n            else:\\n\\t\\t\\t\\t# arr[i] != arr[i-1]\\n\\t\\t\\t\\t# => dp[i] = (2, diff)\\n                if diff != 0:\\n                    dp[i] = (2, diff)\\n\\t\\t\\t\\t\\n\\t\\t\\t\\n\\t\\t\\t# update res in each loop\\n            res = max(res, dp[i][0])\\n\\n        return res\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1666452,
                "title": "c-solution-using-dp",
                "content": "# The key is idea is to maintain a dp table where dp[i] denotes the length of turbulent subarray with last element as arr[i]. After populating the dp array, take the maximum of the dp array elements.\\ndp[i]= if (i-1)th element is a part of a turbulent subarray then **dp[i-1]+1**\\n           else \\n\\t\\t        if ith and (i-1)th are identical then **1**\\n\\t\\t\\t\\telse **2**\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        if(arr.size()<=1) {\\n            return arr.size();\\n        }\\n        vector<int>dp(arr.size());\\n        dp[0]=1;\\n        dp[1]=(arr[1]==arr[0])?1:2;\\n        int ans=max(dp[0],dp[1]);\\n        for(int i=2;i<arr.size();i++) {\\n            bool one=arr[i]>arr[i-1] && arr[i-1]<arr[i-2];\\n            bool two=arr[i]<arr[i-1] && arr[i-1]>arr[i-2];\\n            dp[i]=(one || two)?dp[i-1]+1:(arr[i]!=arr[i-1]?2:1);\\n            ans=max(ans,dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```\\n***Please upvote if you have got any help from my code. Thank you.***",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        if(arr.size()<=1) {\\n            return arr.size();\\n        }\\n        vector<int>dp(arr.size());\\n        dp[0]=1;\\n        dp[1]=(arr[1]==arr[0])?1:2;\\n        int ans=max(dp[0],dp[1]);\\n        for(int i=2;i<arr.size();i++) {\\n            bool one=arr[i]>arr[i-1] && arr[i-1]<arr[i-2];\\n            bool two=arr[i]<arr[i-1] && arr[i-1]>arr[i-2];\\n            dp[i]=(one || two)?dp[i-1]+1:(arr[i]!=arr[i-1]?2:1);\\n            ans=max(ans,dp[i]);\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1590766,
                "title": "python-sliding-window-o-n",
                "content": "```python\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        ret = 0\\n        cnt = 0\\n\\n        for i in range(len(arr)):\\n            if i >= 2 and (arr[i-2] > arr[i-1] < arr[i] or arr[i-2] < arr[i-1] > arr[i]):\\n                cnt += 1\\n            elif i >= 1 and arr[i-1] != arr[i]:\\n                cnt = 2\\n            else:\\n                cnt = 1\\n            ret = max(ret, cnt)\\n        return ret\\n```\\nWe simply need to use the current, and last 2 elements to ensure that the ordering of elements is turbulent. If we see such a case, then we increment our count by 1. We start count at 2 if we our current element is not the previous, as any length 2 array with inequal elements must be turbulent. We finally have a base case that resets count to 1 if we have a single element array.",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        ret = 0\\n        cnt = 0\\n\\n        for i in range(len(arr)):\\n            if i >= 2 and (arr[i-2] > arr[i-1] < arr[i] or arr[i-2] < arr[i-1] > arr[i]):\\n                cnt += 1\\n            elif i >= 1 and arr[i-1] != arr[i]:\\n                cnt = 2\\n            else:\\n                cnt = 1\\n            ret = max(ret, cnt)\\n        return ret\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1588841,
                "title": "c-o-n-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n = arr.size();\\n        bool prevG = 1, prevL = 1;\\n        int l = 0;\\n        int mx = 1;\\n        for (int i = 0; i < n-1; ++i) {\\n            bool currG = arr[i] > arr[i+1];\\n            bool currL = arr[i] < arr[i+1];\\n            if (!( (prevG && currL) || (prevL && currG) )) {\\n                l = i;\\n            }\\n            if (arr[i] != arr[i+1]) {\\n                mx = max(i - l + 2, mx);\\n                prevG = currG;\\n                prevL = currL;\\n            }\\n            else {\\n                ++l;\\n                prevG = 1, prevL = 1;\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```\\n`prevG` and `prevL` track the greater and lesser values of the previous comparison, likewise with `currG` and `currL` for the current comparison. `l` tracks the left bound of the turbulent window, and `mx` tracks the longest (valid) window size.\\n\\nTo solve the problem, we can break it down into casework:\\nIf `prevG && currL` or `prevL && currG`, then the window from `l` to `i` is turbulent.\\nOtherwise, the window is not turbulent and we must update the left bound.\\nIf `arr[i] != arr[i+1]`, then the comparison flipped at index `i`, so we set `l = i`. We then pass on the values of `currG` and `currL` to `prevG` and `prevL` so future comparisons can make the correct decision.\\nIf `arr[i] == arr[i+1]`, then the comparison did not flip at `i`, so we must set `l = i + 1`. If they are equal, then the next comparison can be either greater or lesser, so we set `currG` and `currL` to 1 to signify that either comparison works.",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n = arr.size();\\n        bool prevG = 1, prevL = 1;\\n        int l = 0;\\n        int mx = 1;\\n        for (int i = 0; i < n-1; ++i) {\\n            bool currG = arr[i] > arr[i+1];\\n            bool currL = arr[i] < arr[i+1];\\n            if (!( (prevG && currL) || (prevL && currG) )) {\\n                l = i;\\n            }\\n            if (arr[i] != arr[i+1]) {\\n                mx = max(i - l + 2, mx);\\n                prevG = currG;\\n                prevL = currL;\\n            }\\n            else {\\n                ++l;\\n                prevG = 1, prevL = 1;\\n            }\\n        }\\n        return mx;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1579159,
                "title": "swift-dp",
                "content": "**Inuition**\\nSeem it is dp problem at glance, since we need to find max or min from something\\n\\n**Algorithms**\\n- Create `up` to store the the pattern length, start from: Smaller Larger Smaller Larger ... so on (eg: 1 2 1 2).\\n- Create `down` to store the the pattern length, start from: Larger Smaller Larger Smaller ... so on (eg: 2 1 2 1).\\n- Initially, it is obviously 1\\n\\nWe can realized this rules (from index based one)\\n\\n* When increase pattern (eg: 1 to 2)\\n\\t- `up` on odd length will be +1, otherwise down will back to 1\\n\\t- `down` on even length will back to 1, otherwise down will be + 1\\n* When decrease pattern (eg: 6 to 4)\\n\\t- `up` on even length will be +1, otherwise down will back to 1\\n\\t- `down` on odd length will back to 1, otherwise down will be + 1\\n* When equals pattern (eg: 5 to 5)\\n\\t- obviously both `up` and `down` back to 1\\n\\n* Example:\\n1. `0 1 2 3 4 5 6 7` (index based 0)\\n1. `e o e o e o e o`  (odd index or even index)\\n1. `1 3 2 4 2 3 4 5` (array)\\n1. `1 2 3 4 5 6 7 8` (up)\\n1. `1 1 1 1 1 1 1 1 ` (down)\\n\\n```\\nclass Solution {\\n    // Time: O(n)\\n    // Space: O(n)\\n    func maxTurbulenceSize(_ arr: [Int]) -> Int {\\n        var up = Array(repeating: 0, count: arr.count)\\n        var down = Array(repeating: 0, count: arr.count)\\n        up[0] = 1\\n        down[0] = 1\\n        var ans = 1\\n        for i in 1..<arr.count {\\n            let isEven = i % 2 == 0\\n            if arr[i] > arr[i - 1] {\\n                if !isEven {\\n                    up[i] = up[i - 1] + 1\\n                    down[i] = 1\\n                } else {\\n                    up[i] = 1\\n                    down[i] = down[i - 1] + 1\\n                }\\n            } else if arr[i] < arr[i - 1] {\\n                if isEven {\\n                    up[i] = up[i - 1] + 1\\n                    down[i] = 1\\n                } else {\\n                    up[i] = 1\\n                    down[i] = down[i - 1] + 1\\n                }\\n            } else {\\n                up[i] = 1\\n                down[i] = 1\\n            }\\n            ans = max(ans, max(up[i], down[i]))\\n        }\\n        return ans\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    // Time: O(n)\\n    // Space: O(n)\\n    func maxTurbulenceSize(_ arr: [Int]) -> Int {\\n        var up = Array(repeating: 0, count: arr.count)\\n        var down = Array(repeating: 0, count: arr.count)\\n        up[0] = 1\\n        down[0] = 1\\n        var ans = 1\\n        for i in 1..<arr.count {\\n            let isEven = i % 2 == 0\\n            if arr[i] > arr[i - 1] {\\n                if !isEven {\\n                    up[i] = up[i - 1] + 1\\n                    down[i] = 1\\n                } else {\\n                    up[i] = 1\\n                    down[i] = down[i - 1] + 1\\n                }\\n            } else if arr[i] < arr[i - 1] {\\n                if isEven {\\n                    up[i] = up[i - 1] + 1\\n                    down[i] = 1\\n                } else {\\n                    up[i] = 1\\n                    down[i] = down[i - 1] + 1\\n                }\\n            } else {\\n                up[i] = 1\\n                down[i] = 1\\n            }\\n            ans = max(ans, max(up[i], down[i]))\\n        }\\n        return ans\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1522494,
                "title": "python3-dp-73-faster",
                "content": "\\n```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        lower =[1]*len(arr)\\n        upper = [1]*len(arr)\\n        for i in range(1,len(arr)):\\n            if arr[i] < arr[i-1]:\\n                lower[i] = max(upper[i-1]+1, lower[i])\\n            elif arr[i] > arr[i-1]:\\n                upper[i] = max(lower[i-1]+1, upper[i])\\n        #print(*lower)\\n        #print(*upper)\\n        return max(max(lower), max(upper))\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        lower =[1]*len(arr)\\n        upper = [1]*len(arr)\\n        for i in range(1,len(arr)):\\n            if arr[i] < arr[i-1]:\\n                lower[i] = max(upper[i-1]+1, lower[i])\\n            elif arr[i] > arr[i-1]:\\n                upper[i] = max(lower[i-1]+1, upper[i])\\n        #print(*lower)\\n        #print(*upper)\\n        return max(max(lower), max(upper))\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1484704,
                "title": "simple-c-solution",
                "content": "``` \\nint maxTurbulenceSize(vector<int>& arr) {\\n        if(arr.size() == 0)\\n            return 0;\\n        if(arr.size()== 1)\\n            return 1;\\n        int max_so_far1 = INT_MIN;\\n        int max_so_far2 = INT_MIN;\\n        int count = 0;\\n        \\n        for(int i = 0; i < arr.size()-1; i++) {\\n            if(i % 2 == 0) {\\n                if(arr[i] < arr[i+1])\\n                    count++;\\n                else \\n                    count = 0;\\n            }\\n            else {\\n                if(arr[i] > arr[i+1]) \\n                    count++;\\n                else\\n                    count = 0;\\n            }\\n            max_so_far1 = max(max_so_far1, count+1);\\n        }\\n        \\n        count = 0;\\n        for(int i = 0; i < arr.size()-1; i++) {\\n            if(i % 2 == 0) {\\n                if(arr[i] > arr[i+1])\\n                    count++;\\n                else \\n                    count = 0;\\n            }\\n            else {\\n                if(arr[i] < arr[i+1]) \\n                    count++;\\n                else\\n                    count = 0;\\n            }\\n            max_so_far2 = max(max_so_far2, count+1);\\n        }\\n        return max(max_so_far1, max_so_far2);\\n    }",
                "solutionTags": [],
                "code": "``` \\nint maxTurbulenceSize(vector<int>& arr) {\\n        if(arr.size() == 0)\\n            return 0;\\n        if(arr.size()== 1)\\n            return 1;\\n        int max_so_far1 = INT_MIN;\\n        int max_so_far2 = INT_MIN;\\n        int count = 0;\\n        \\n        for(int i = 0; i < arr.size()-1; i++) {\\n            if(i % 2 == 0) {\\n                if(arr[i] < arr[i+1])\\n                    count++;\\n                else \\n                    count = 0;\\n            }\\n            else {\\n                if(arr[i] > arr[i+1]) \\n                    count++;\\n                else\\n                    count = 0;\\n            }\\n            max_so_far1 = max(max_so_far1, count+1);\\n        }\\n        \\n        count = 0;\\n        for(int i = 0; i < arr.size()-1; i++) {\\n            if(i % 2 == 0) {\\n                if(arr[i] > arr[i+1])\\n                    count++;\\n                else \\n                    count = 0;\\n            }\\n            else {\\n                if(arr[i] < arr[i+1]) \\n                    count++;\\n                else\\n                    count = 0;\\n            }\\n            max_so_far2 = max(max_so_far2, count+1);\\n        }\\n        return max(max_so_far1, max_so_far2);\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1476293,
                "title": "c-clean-concise-solution-with-detailed-explaination",
                "content": "* **Solution**\\nThe solution is pretty simple we keep counting and updating the result when the we still have the subarray that satisfies one of two conditions if not then we reset the count value to 1 and keep couting. The tricky part is how we know when we will reset the count value so view the source code for detailed explainations.\\n\\n* **Time Complexity**\\nWe just go through all the element of arr array so the time complexity is **O(n)**.\\n\\n* **Space Complexity**\\nBecause we just use a constant number of variables so the space complexity is **O(1)**.\\n\\n* **Source Code**\\n\\n```\\nclass Solution {\\npublic:\\n    //check function for the case when k is even then arr[k]<a[k+1]\\n    //input a = arr[k], b = arr[k+1]\\n    //even_smaller = true if k is even \\n    //even_smaller = false if k is odd\\n    bool check_even_smaller(int &a,int &b,bool &even_smaller) {\\n        if (even_smaller) return a<b;\\n        return a>b;\\n    }\\n    //check function for the case when k is even then arr[k]>a[k+1]\\n    //input a = arr[k], b = arr[k+1]\\n    //even_larger = true if k is even \\n    //even_larger = false if k is odd\\n    bool check_even_larger(int &a,int &b,bool &even_larger) {\\n        if (even_larger) return a>b;\\n        return a<b;\\n    }\\n    \\n    int maxTurbulenceSize(vector<int>& arr) {\\n        if (arr.size()==1) return 1;\\n        \\n        bool even_smaller,even_larger;\\n        int even_smaller_count =1, even_larger_count = 1;\\n        int max_even_smaller = 1,max_even_larger = 1;\\n        \\n        for (int i=0;i<arr.size()-1;++i) {\\n            \\n            //check i is odd or even\\n            if (i%2==0) {\\n                even_smaller = true;\\n                even_larger = true;\\n            }\\n            else {\\n                even_smaller = false;\\n                even_larger = false;\\n            }\\n            //even_smaller\\n            //still true keep counting\\n            if (check_even_smaller(arr[i],arr[i+1],even_smaller)) \\n                ++even_smaller_count;\\n            //false then reset count value to 1\\n            else even_smaller_count = 1;\\n            \\n            //update the max value\\n            if (even_smaller_count>max_even_smaller)\\n                max_even_smaller = even_smaller_count;\\n            \\n            //even_larger\\n            //still true keep couting\\n            if (check_even_larger(arr[i],arr[i+1],even_larger)) \\n                ++even_larger_count;\\n            //false then reset count value to 1\\n            else even_larger_count = 1;\\n            \\n            //update the max value\\n            if (even_larger_count>max_even_larger)\\n                max_even_larger = even_larger_count;\\n        }\\n        //return the largest value that we have from two cases\\n        return max( max_even_smaller,max_even_larger);\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //check function for the case when k is even then arr[k]<a[k+1]\\n    //input a = arr[k], b = arr[k+1]\\n    //even_smaller = true if k is even \\n    //even_smaller = false if k is odd\\n    bool check_even_smaller(int &a,int &b,bool &even_smaller) {\\n        if (even_smaller) return a<b;\\n        return a>b;\\n    }\\n    //check function for the case when k is even then arr[k]>a[k+1]\\n    //input a = arr[k], b = arr[k+1]\\n    //even_larger = true if k is even \\n    //even_larger = false if k is odd\\n    bool check_even_larger(int &a,int &b,bool &even_larger) {\\n        if (even_larger) return a>b;\\n        return a<b;\\n    }\\n    \\n    int maxTurbulenceSize(vector<int>& arr) {\\n        if (arr.size()==1) return 1;\\n        \\n        bool even_smaller,even_larger;\\n        int even_smaller_count =1, even_larger_count = 1;\\n        int max_even_smaller = 1,max_even_larger = 1;\\n        \\n        for (int i=0;i<arr.size()-1;++i) {\\n            \\n            //check i is odd or even\\n            if (i%2==0) {\\n                even_smaller = true;\\n                even_larger = true;\\n            }\\n            else {\\n                even_smaller = false;\\n                even_larger = false;\\n            }\\n            //even_smaller\\n            //still true keep counting\\n            if (check_even_smaller(arr[i],arr[i+1],even_smaller)) \\n                ++even_smaller_count;\\n            //false then reset count value to 1\\n            else even_smaller_count = 1;\\n            \\n            //update the max value\\n            if (even_smaller_count>max_even_smaller)\\n                max_even_smaller = even_smaller_count;\\n            \\n            //even_larger\\n            //still true keep couting\\n            if (check_even_larger(arr[i],arr[i+1],even_larger)) \\n                ++even_larger_count;\\n            //false then reset count value to 1\\n            else even_larger_count = 1;\\n            \\n            //update the max value\\n            if (even_larger_count>max_even_larger)\\n                max_even_larger = even_larger_count;\\n        }\\n        //return the largest value that we have from two cases\\n        return max( max_even_smaller,max_even_larger);\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 1468561,
                "title": "c-o-n-time-and-space-solution",
                "content": "Plz upvote if it helps you :)\\n\\n\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxTurbulenceSize(vector<int>& arr) {\\n\\t\\t\\tint n = arr.size();\\n\\n\\t\\t\\tint result = 1;\\n\\t\\t\\tvector<int>change;\\n\\t\\t\\tint temp = 0;\\n\\t\\t\\tchange.push_back(0);\\n\\t\\t\\tfor(int i=0;i+1<n;i++){\\n\\t\\t\\t\\tif(arr[i] == arr[i+1]){\\n\\t\\t\\t\\t\\tchange.push_back(0);\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse{\\n\\t\\t\\t\\t\\tif(arr[i] > arr[i+1]){\\n\\t\\t\\t\\t\\t\\tchange.push_back(1);\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tchange.push_back(-1);\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}       \\n\\t\\t\\t}\\n\\t\\t\\tint count = 1;\\n\\t\\t\\tfor(int i=1;i<change.size();i++){\\n\\t\\t\\t\\tif(change[i] == 0){\\n\\t\\t\\t\\t\\tcount = 1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse\\n\\t\\t\\t\\t{\\n\\t\\t\\t\\t\\tif(count == 1 && change[i]!=0){\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\telse if(change[i]!=change[i-1] && change[i]!=0) {\\n\\t\\t\\t\\t\\t\\tcount++;\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t//min length\\n\\t\\t\\t\\t\\t\\tcount = 1;\\n\\t\\t\\t\\t\\t\\ti--;\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tresult=max(result,count);\\n\\t\\t\\t}\\n\\t\\t\\treturn result;\\n\\t\\t}\\n\\t};\\n",
                "solutionTags": [
                    "C++"
                ],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxTurbulenceSize(vector<int>& arr) {\\n\\t\\t\\tint n = arr.size();\\n\\n\\t\\t\\tint result = 1;\\n\\t\\t\\tvector<int>change;\\n\\t\\t\\tint temp = 0;\\n\\t\\t\\tchange.push_back(0);\\n\\t\\t\\tfor(int i=0;i+1<n;i++){\\n\\t\\t\\t\\tif(arr[i] == arr[i+1]){\\n\\t\\t\\t\\t\\tchange.push_back(0);\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1468159,
                "title": "python-o-n-time-sliding-window",
                "content": "For the given example, a = [9,4,2,10,7,8,8,1,9]\\nThe sliding window will look like this on each iteration\\n[0]\\n[0, -1]\\n[0, 0, -1]\\n[0, 0, -1, 1]\\n[0, 0, -1, 1, -1]\\n[0, 0, -1, 1, -1, 1]\\n[0, 0, -1, 1, -1, 1, 0]\\n[0, 0, -1, 1, -1, 1, 0, -1]\\n[0, 0, -1, 1, -1, 1, 0, -1, 1]\\n1 denotes increasing\\n-1 denotes decreasing\\n0 denotes neutral\\n\\nIf increasing/decreasing occurs twice in a row, the window will break and the new window begins. Record the window size on each breaks. Return max window size.\\n\\n        q = [0]\\n        left = 0\\n        res = 1\\n        def window(right):\\n            if a[right] > a[right-1] : q.append(1)\\n            elif a[right] < a[right-1]: q.append(-1)\\n            else: q.append(0) \\n        for right in range(1,len(a)): \\n            window(right)\\n            if q[-1] == 0: \\n                left = right \\n            elif q[-1] == q[-2]: \\n                left = right-1 \\n                q[left] = 0 \\n            res = max(res,right-left+1) \\n        return res",
                "solutionTags": [],
                "code": "For the given example, a = [9,4,2,10,7,8,8,1,9]\\nThe sliding window will look like this on each iteration\\n[0]\\n[0, -1]\\n[0, 0, -1]\\n[0, 0, -1, 1]\\n[0, 0, -1, 1, -1]\\n[0, 0, -1, 1, -1, 1]\\n[0, 0, -1, 1, -1, 1, 0]\\n[0, 0, -1, 1, -1, 1, 0, -1]\\n[0, 0, -1, 1, -1, 1, 0, -1, 1]\\n1 denotes increasing\\n-1 denotes decreasing\\n0 denotes neutral\\n\\nIf increasing/decreasing occurs twice in a row, the window will break and the new window begins. Record the window size on each breaks. Return max window size.\\n\\n        q = [0]\\n        left = 0\\n        res = 1\\n        def window(right):\\n            if a[right] > a[right-1] : q.append(1)\\n            elif a[right] < a[right-1]: q.append(-1)\\n            else: q.append(0) \\n        for right in range(1,len(a)): \\n            window(right)\\n            if q[-1] == 0: \\n                left = right \\n            elif q[-1] == q[-2]: \\n                left = right-1 \\n                q[left] = 0 \\n            res = max(res,right-left+1) \\n        return res",
                "codeTag": "Python3"
            },
            {
                "id": 1466291,
                "title": "java-dp-easy",
                "content": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] arr) {\\n        int ans = 0, n = arr.length;\\n        int[][] dp = new int[n][];\\n        if(n > 0) {\\n            dp[0] = new int[]{1, 1};\\n            ans = 1;\\n            for(int i = 1; i < n; i++) {\\n                dp[i] = new int[]{1, 1};\\n                if(arr[i] > arr[i-1]) {\\n                    dp[i][0] = 1 + dp[i-1][1];\\n                    ans = Math.max(ans, dp[i][0]);\\n                }\\n                else if(arr[i] < arr[i-1]) {\\n                    dp[i][1] = 1 + dp[i-1][0];\\n                    ans = Math.max(ans, dp[i][1]);\\n                }\\n            }\\n        }\\n        // System.out.println(Arrays.deepToString(dp));\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] arr) {\\n        int ans = 0, n = arr.length;\\n        int[][] dp = new int[n][];\\n        if(n > 0) {\\n            dp[0] = new int[]{1, 1};\\n            ans = 1;\\n            for(int i = 1; i < n; i++) {\\n                dp[i] = new int[]{1, 1};\\n                if(arr[i] > arr[i-1]) {\\n                    dp[i][0] = 1 + dp[i-1][1];\\n                    ans = Math.max(ans, dp[i][0]);\\n                }\\n                else if(arr[i] < arr[i-1]) {\\n                    dp[i][1] = 1 + dp[i-1][0];\\n                    ans = Math.max(ans, dp[i][1]);\\n                }\\n            }\\n        }\\n        // System.out.println(Arrays.deepToString(dp));\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466207,
                "title": "c-easy-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) \\n\\t{\\n        int res=1;\\n        int prevsmall=1;int prevbig=1;\\n        int cursmall=1;int curbig=1;\\n   for(int i=1;i<arr.size();i++)\\n        {\\n           if(arr[i]>arr[i-1])\\n           {\\n               curbig=1+prevsmall;\\n             }\\n           if(arr[i]<arr[i-1])\\n           {\\n               cursmall=1+prevbig;\\n           }\\n           res=max({res,curbig,cursmall});\\n       prevsmall=cursmall;\\n       prevbig=curbig;\\n       curbig=1;\\n       cursmall=1;           \\n        }\\n        return res;        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) \\n\\t{\\n        int res=1;\\n        int prevsmall=1;int prevbig=1;\\n        int cursmall=1;int curbig=1;\\n   for(int i=1;i<arr.size();i++)\\n        {\\n           if(arr[i]>arr[i-1])\\n           {\\n               curbig=1+prevsmall;\\n             }\\n           if(arr[i]<arr[i-1])\\n           {\\n               cursmall=1+prevbig;\\n           }\\n           res=max({res,curbig,cursmall});\\n       prevsmall=cursmall;\\n       prevbig=curbig;\\n       curbig=1;\\n       cursmall=1;           \\n        }\\n        return res;        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1466203,
                "title": "c-commented-no-dp-easy-solution",
                "content": "```\\nint maxTurbulenceSize(vector<int>& arr) {\\n        int i, size, sign =1, count=1, maxSize =1;\\n        size =arr.size();\\n        vector<int> vec(size, 0);\\n        vec[0] = arr[0];\\n        for(i=1; i<size; i++)\\n        {\\n            if(arr[i] < arr[i-1]) //if current number is < prev number, check previous sign\\n            {\\n                if(sign == 1)       // if previous sign is +ve\\n                    count++;\\n                else\\n                    count=2;\\n                 maxSize = max(maxSize, count);\\n                sign = -1;      // set current sign for next number\\n            }\\n            else if(arr[i] > arr[i-1]) \\n            {\\n                if(sign == -1)      // if previous sign is -ve\\n                    count++;\\n                else\\n                    count= 2;\\n                maxSize = max(maxSize, count);\\n                sign = 1;\\n            }\\n            else        // if number is same as previous, count resets to 1.\\n            {\\n                count =1;\\n                sign = 1;\\n                maxSize = max(maxSize, count);\\n            }       \\n        }\\n        return maxSize;\\n    }\\n```\\nPlease UPVOTE if my approach helped you.",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nint maxTurbulenceSize(vector<int>& arr) {\\n        int i, size, sign =1, count=1, maxSize =1;\\n        size =arr.size();\\n        vector<int> vec(size, 0);\\n        vec[0] = arr[0];\\n        for(i=1; i<size; i++)\\n        {\\n            if(arr[i] < arr[i-1]) //if current number is < prev number, check previous sign\\n            {\\n                if(sign == 1)       // if previous sign is +ve\\n                    count++;\\n                else\\n                    count=2;\\n                 maxSize = max(maxSize, count);\\n                sign = -1;      // set current sign for next number\\n            }\\n            else if(arr[i] > arr[i-1]) \\n            {\\n                if(sign == -1)      // if previous sign is -ve\\n                    count++;\\n                else\\n                    count= 2;\\n                maxSize = max(maxSize, count);\\n                sign = 1;\\n            }\\n            else        // if number is same as previous, count resets to 1.\\n            {\\n                count =1;\\n                sign = 1;\\n                maxSize = max(maxSize, count);\\n            }       \\n        }\\n        return maxSize;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1466151,
                "title": "c-easy-and-fast-o-n-there-can-only-be-2-possible-array-to-calculate-answer",
                "content": "Let\\'s say for a particular element is in the answer array. There can be only be 2 scenarios . \\n1) Element is smaller than its adjacent elements.\\n2) Element is greter than its adjacent elements.\\n3) So there is only 2 possible sign for each element to respect to answer array. It may be greater or smaller.\\n\\nSo we are going to calculate both possibilites by taking 1st element to be grater in 1 array and smaller in 2nd array.\\nMinimum answer is single element. \\n\\n\\tclass Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint maxTurbulenceSize(vector<int>& arr) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tint s = arr.size();\\n\\t\\t\\t\\tif(s==0 || s==1) return s;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Initialized with 1 because every sigle element can be answer to our question.\\n\\t\\t\\t\\t// Thats say cal[] array 1st rows element is greater and 2nd element is smaller in answer array.\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tvector<vector<int>> cal(2,vector<int> (s,1));\\n\\t\\t\\t\\tint ans = 1;\\n\\t\\t\\t\\tfor(int i=1;i<s;i++){\\n\\t\\t\\t\\t\\tif(arr[i]==arr[i-1]) continue;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif(i&1){\\n\\t\\t\\t\\t\\t\\tif(arr[i]>arr[i-1]){\\n\\t\\t\\t\\t\\t\\t\\tcal[1][i]+=cal[1][i-1];\\n\\t\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t\\tcal[0][i]+=cal[0][i-1];\\n\\t\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\tif(arr[i]>arr[i-1]){\\n\\t\\t\\t\\t\\t\\t\\tcal[0][i]+=cal[0][i-1];\\n\\t\\t\\t\\t\\t\\t}else{\\n\\t\\t\\t\\t\\t\\t\\tcal[1][i]+=cal[1][i-1];\\n\\t\\t\\t\\t\\t\\t}                \\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tans = max({ans,cal[0][i],cal[1][i]});\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn ans;\\n\\t\\t\\t}\\n\\t\\t};\\n\\t\\t\\n\\t\\tBy this algorithm we are generating both the possible arrays and finding the maximum from both.\\n\\t\\tUpvote if you liked the solution.",
                "solutionTags": [],
                "code": "class Solution {\\n\\t\\tpublic:\\n\\t\\t\\tint maxTurbulenceSize(vector<int>& arr) {\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tint s = arr.size();\\n\\t\\t\\t\\tif(s==0 || s==1) return s;\\n\\t\\t\\t\\t\\n\\t\\t\\t\\t// Initialized with 1 because every sigle element can be answer to our question.\\n\\t\\t\\t\\t// Thats say cal[] array 1st rows element is greater and 2nd element is smaller in answer array.\\n\\t\\t\\t\\t\\n\\t\\t\\t\\tvector<vector<int>> cal(2,vector<int> (s,1));\\n\\t\\t\\t\\tint ans = 1;\\n\\t\\t\\t\\tfor(int i=1;i<s;i++){\\n\\t\\t\\t\\t\\tif(arr[i]==arr[i-1]) continue;\\n\\t\\t\\t\\t\\t\\n\\t\\t\\t\\t\\tif(i&1){\\n\\t\\t\\t\\t\\t\\tif(arr[i]>arr[i-1]){\\n\\t\\t\\t\\t\\t\\t\\tcal[1][i]+=cal[1][i-1];\\n\\t\\t\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1466121,
                "title": "javascript-100-very-different-easier-than-solution-imo-approach",
                "content": "![image](https://assets.leetcode.com/users/images/a777ad2a-2cdd-4e22-b9ef-597c6733a2f9_1631825310.8851755.png)\\n\\nDoing the Blind 75 list and posting all solutions.\\n\\nHere is my own solution.  O(n), only compares one direction, and gets a solid 76ms.\\nIntuition and how I\\'ve started thinking about these problems -\\n```\\n[9, 4, 2, 10, 7, 8, 8, 1, 9]\\n  [f, f, t,  f, t, 0, f, t]\\n```\\nThese are our comparisons.  If descending - f, ascending - t and equivalent 0.\\nAs we can see, the comparisons are 1 less than the original array.  If comparison = 0, we know we can only use one of the two elements compared - 1 count to start.  If it\\'s a t or an f, both are allowed - 2 counts to start (unless it\\'s first in arr, then only 1 since it\\'s the edge.  It\\'s still worth 2, but comp wont === last no matter what here because last is undefined, so count will increment anyway because t or f alone mean 2 numbers are ascending or descending).  From there, each comparison is worth 1 as long as it\\'s not 0 or the same as the last.  Capture max and reset accordingly if so.\\n\\nOur answer for this one is 5, so when looking at [f,f,t,f,t,0,f,t] - we need a formula that gives us five no matter how we iterate across, forward or back.  (Because it could be the opposite if arr reversed, we still need to capture 5 either way.)...  If we start from left, count is reset at second f to 2 -> 2 + 1, + 1, + 1 -> we hit the zero, capture the 5 as max and reset.  Nice!  Works that way. How about [t, f, 0, t, f, t, f, f] ?  Start at count 1. 1 + 1 -> hit zero -> capture 3, reset to 1 since current is 0 -> 1 + 1 + 1 + 1 + 1 -> capture 5.  It works!\\n\\ntl:dr - Pattern is if it\\'s a t or f underneath two numbers at the start, it \\'captures\\' those two numberss above it, then each !last after \\'captures\\' the one to the right / left until there\\'s either an ff repeat, a tt repeat or a 0.  Each 0 \\'captures\\' either num above it, but not both.  Then, as long as next !== last, you can iterate either way \\'capturing\\' ones above.\\n```\\nfunction maxTurbulenceSize(arr) {\\n  const cmp = (num1, num2) => num1 === num2 ? 0 : num1 < num2;\\n  let last, count = 1, max = 1;\\n  for (let i = 0, comp = cmp(arr[i], arr[++i]); i < arr.length; comp = cmp(arr[i], arr[++i])) {\\n    if (comp === 0) max = Math.max(max, count), last = 0, count = 1;\\n    else if (comp !== last) last = comp, count++, max = Math.max(max, count);\\n    else max = Math.max(max, count), last = comp, count = 2;\\n  }\\n  return max;\\n}\\n```\\n\\nHere is the recommended Python solution transcribed to JS.  Great solution, but I wanted to solve it in my own way as well.\\n```\\nvar maxTurbulenceSize = function(arr) {\\n  let n = arr.length, ans = 1, anchor = 0;\\n  const cmp = (num1, num2) => num1 === num2 ? 0 : (num1 < num2 ? 1 : -1)\\n  for (let i = 1; i < arr.length; i++) {\\n    let c = cmp(arr[i - 1], arr[i]);\\n    if (c === 0) anchor = i;\\n    else if (i === n - 1 || c * cmp(arr[i], arr[i + 1]) !== -1) {\\n      ans = Math.max(ans, i - anchor + 1);\\n      anchor = i;\\n    }\\n  }\\n  return ans;\\n}\\n```\\n\\n![image](https://assets.leetcode.com/users/images/890f01ec-1877-4b4a-a5b4-bf5b6d83c987_1631773588.913079.png)\\n\\n\\n![image](https://assets.leetcode.com/users/images/b061dfba-535f-4185-a81d-09ab466fcec4_1631764608.637569.png)\\n",
                "solutionTags": [],
                "code": "```\\n[9, 4, 2, 10, 7, 8, 8, 1, 9]\\n  [f, f, t,  f, t, 0, f, t]\\n```\n```\\nfunction maxTurbulenceSize(arr) {\\n  const cmp = (num1, num2) => num1 === num2 ? 0 : num1 < num2;\\n  let last, count = 1, max = 1;\\n  for (let i = 0, comp = cmp(arr[i], arr[++i]); i < arr.length; comp = cmp(arr[i], arr[++i])) {\\n    if (comp === 0) max = Math.max(max, count), last = 0, count = 1;\\n    else if (comp !== last) last = comp, count++, max = Math.max(max, count);\\n    else max = Math.max(max, count), last = comp, count = 2;\\n  }\\n  return max;\\n}\\n```\n```\\nvar maxTurbulenceSize = function(arr) {\\n  let n = arr.length, ans = 1, anchor = 0;\\n  const cmp = (num1, num2) => num1 === num2 ? 0 : (num1 < num2 ? 1 : -1)\\n  for (let i = 1; i < arr.length; i++) {\\n    let c = cmp(arr[i - 1], arr[i]);\\n    if (c === 0) anchor = i;\\n    else if (i === n - 1 || c * cmp(arr[i], arr[i + 1]) !== -1) {\\n      ans = Math.max(ans, i - anchor + 1);\\n      anchor = i;\\n    }\\n  }\\n  return ans;\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1465509,
                "title": "python-using-the-problem-definition-in-o-n-time-and-o-1-space",
                "content": "```\\n# run 1 iteration to cover 2 possible turbulence conditions and return max of both\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        max1 = max2 = 1\\n        temp1 = temp2 = 1\\n        \\n        for i in range(n-1):\\n            #1st case\\n            if (i%2 == 1 and arr[i]>arr[i+1]) or (i%2 == 0 and arr[i]<arr[i+1]):\\n                temp1 += 1\\n                max1 = max(max1, temp1)\\n            else:\\n                temp1 = 1\\n                \\n            #2nd case\\n            if (i%2 == 1 and arr[i]<arr[i+1]) or (i%2 == 0 and arr[i]>arr[i+1]):\\n                temp2 += 1\\n                max2 = max(max2, temp2)\\n            else:\\n                temp2 = 1\\n                \\n        return max(max1, max2)\\n```",
                "solutionTags": [
                    "Python"
                ],
                "code": "```\\n# run 1 iteration to cover 2 possible turbulence conditions and return max of both\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        n = len(arr)\\n        max1 = max2 = 1\\n        temp1 = temp2 = 1\\n        \\n        for i in range(n-1):\\n            #1st case\\n            if (i%2 == 1 and arr[i]>arr[i+1]) or (i%2 == 0 and arr[i]<arr[i+1]):\\n                temp1 += 1\\n                max1 = max(max1, temp1)\\n            else:\\n                temp1 = 1\\n                \\n            #2nd case\\n            if (i%2 == 1 and arr[i]<arr[i+1]) or (i%2 == 0 and arr[i]>arr[i+1]):\\n                temp2 += 1\\n                max2 = max(max2, temp2)\\n            else:\\n                temp2 = 1\\n                \\n        return max(max1, max2)\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465479,
                "title": "easy-time-o-n-space-o-1-soln",
                "content": "```\\npublic class Solution {\\n    // Time O(n) Space O(1), n = length of \\'A\\'\\n    public int MaxTurbulenceSize(int[] A) {\\n        int maxTurbulent=1, i=-1, currMax=1;\\n        bool lookingForGreater=true;\\n        while(++i < A.Length-1)\\n        {\\n            if(lookingForGreater)\\n            {\\n                if(A[i] > A[i+1])\\n                {\\n                    currMax++;\\n                    lookingForGreater=!lookingForGreater;\\n                }\\n                else\\n                    currMax=A[i]!=A[i+1]? 2 : 1;\\n            }\\n            else // !lookingForGreater\\n            {\\n                if(A[i] < A[i+1])\\n                {\\n                    currMax++;\\n                    lookingForGreater=!lookingForGreater;\\n                }\\n                else\\n                    currMax=A[i]!=A[i+1]? 2 : 1;\\n            }   \\n            maxTurbulent=Math.Max(maxTurbulent,currMax);\\n        }\\n        return maxTurbulent;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\npublic class Solution {\\n    // Time O(n) Space O(1), n = length of \\'A\\'\\n    public int MaxTurbulenceSize(int[] A) {\\n        int maxTurbulent=1, i=-1, currMax=1;\\n        bool lookingForGreater=true;\\n        while(++i < A.Length-1)\\n        {\\n            if(lookingForGreater)\\n            {\\n                if(A[i] > A[i+1])\\n                {\\n                    currMax++;\\n                    lookingForGreater=!lookingForGreater;\\n                }\\n                else\\n                    currMax=A[i]!=A[i+1]? 2 : 1;\\n            }\\n            else // !lookingForGreater\\n            {\\n                if(A[i] < A[i+1])\\n                {\\n                    currMax++;\\n                    lookingForGreater=!lookingForGreater;\\n                }\\n                else\\n                    currMax=A[i]!=A[i+1]? 2 : 1;\\n            }   \\n            maxTurbulent=Math.Max(maxTurbulent,currMax);\\n        }\\n        return maxTurbulent;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465374,
                "title": "longest-turbulent-subarray-python-o-n-easy-solution",
                "content": "If two numbers are of opposite sign then their product should be negative\\n```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        best = curr = lastDiff = 0\\n        \\n        for i in range( 0, len(arr) - 1 ):\\n            diff = arr[i] - arr[i+1]\\n            if lastDiff == 0:\\n                lastDiff = diff * -1\\n            if diff * lastDiff < 0:\\n                curr += 1\\n                if best < curr: \\n                    best = curr\\n            elif diff * lastDiff > 0:\\n                curr = 1\\n            else:\\n                curr = 0\\n            lastDiff = diff\\n        return best + 1\\n```",
                "solutionTags": [
                    "Python",
                    "Python3"
                ],
                "code": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        best = curr = lastDiff = 0\\n        \\n        for i in range( 0, len(arr) - 1 ):\\n            diff = arr[i] - arr[i+1]\\n            if lastDiff == 0:\\n                lastDiff = diff * -1\\n            if diff * lastDiff < 0:\\n                curr += 1\\n                if best < curr: \\n                    best = curr\\n            elif diff * lastDiff > 0:\\n                curr = 1\\n            else:\\n                curr = 0\\n            lastDiff = diff\\n        return best + 1\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465340,
                "title": "85-faster-one-pass-solution-veryeasy",
                "content": "Just do what question had said. Its that simple.\\nTime Complexity : O(n)\\nSpace Complexity: O(1)\\n```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int maxi=1,maxi2=1;\\n        int count=1,count2=1;\\n        for(int i=0; i<arr.size()-1; i++){\\n            if(i%2==0){\\n                if(arr[i] < arr[i+1]){\\n                    count++;\\n                }\\n                else{\\n                    maxi=max(count,maxi);\\n                    count=1;\\n                }\\n            }\\n            else{\\n                 if(arr[i] > arr[i+1]){\\n                    count++;\\n                }\\n                else{\\n                    maxi=max(count,maxi);\\n                    count=1;\\n                }\\n            }\\n            \\n            \\n            if(i%2!=0){\\n                if(arr[i] < arr[i+1]){\\n                    count2++;\\n                }\\n                else{\\n                    maxi2=max(count2,maxi2);\\n                    count2=1;\\n                }\\n            }\\n            else{\\n                 if(arr[i] > arr[i+1]){\\n                    count2++;\\n                }\\n                else{\\n                    maxi2=max(count2,maxi2);\\n                    count2=1;\\n                }\\n            }\\n\\n        }\\n        maxi=max(maxi,count);\\n        maxi2=max(maxi2,count2);\\n        int res=max(maxi,maxi2);\\n\\n     \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int maxi=1,maxi2=1;\\n        int count=1,count2=1;\\n        for(int i=0; i<arr.size()-1; i++){\\n            if(i%2==0){\\n                if(arr[i] < arr[i+1]){\\n                    count++;\\n                }\\n                else{\\n                    maxi=max(count,maxi);\\n                    count=1;\\n                }\\n            }\\n            else{\\n                 if(arr[i] > arr[i+1]){\\n                    count++;\\n                }\\n                else{\\n                    maxi=max(count,maxi);\\n                    count=1;\\n                }\\n            }\\n            \\n            \\n            if(i%2!=0){\\n                if(arr[i] < arr[i+1]){\\n                    count2++;\\n                }\\n                else{\\n                    maxi2=max(count2,maxi2);\\n                    count2=1;\\n                }\\n            }\\n            else{\\n                 if(arr[i] > arr[i+1]){\\n                    count2++;\\n                }\\n                else{\\n                    maxi2=max(count2,maxi2);\\n                    count2=1;\\n                }\\n            }\\n\\n        }\\n        maxi=max(maxi,count);\\n        maxi2=max(maxi2,count2);\\n        int res=max(maxi,maxi2);\\n\\n     \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465338,
                "title": "longest-turbulent-subarray-c",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int mlen = 0;\\n        int odd = 0;\\n        int even = 0;\\n        int left = 0;\\n        int right = 1;\\n        for(int i = 0; i < arr.size()-1; ++i)\\n        {\\n            if(arr[i+left] < arr[i+right]) {\\n                odd = 0;\\n                ++even;\\n            } else if(arr[i+left] > arr[i+right]) {\\n                even = 0;\\n                ++odd;\\n            } else {\\n                odd = 0;\\n                even = 0;\\n            }\\n            swap(left, right);\\n            mlen = max({mlen, odd, even});\\n        }\\n        return mlen+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int mlen = 0;\\n        int odd = 0;\\n        int even = 0;\\n        int left = 0;\\n        int right = 1;\\n        for(int i = 0; i < arr.size()-1; ++i)\\n        {\\n            if(arr[i+left] < arr[i+right]) {\\n                odd = 0;\\n                ++even;\\n            } else if(arr[i+left] > arr[i+right]) {\\n                even = 0;\\n                ++odd;\\n            } else {\\n                odd = 0;\\n                even = 0;\\n            }\\n            swap(left, right);\\n            mlen = max({mlen, odd, even});\\n        }\\n        return mlen+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1465202,
                "title": "c-2-pointer-approach-with-explanation",
                "content": "Using 2 pointer technique, prev_sign store the information that previous element is smaller or greater or equal to the current element.\\nIf prev_sign is different from the current sign then we consider that subarray in our answer.\\n\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n=arr.size();  // Size of array\\n        if(n<2)\\n            return n;\\n\\t\\t// if size of array is 0 or 1 then it will return 0 or 1 because single element is turbulant itself\\n\\t\\t\\n        int i=0,j=1; \\n\\t\\t// initializing 2 pointers \\n\\t\\t\\n        int prev_sign=2;  \\n\\t\\t// take random value (which is not possible) as their difference\\n\\t\\t// prev_sign is:\\n\\t\\t//                     0 if previous element is same as the current element\\n\\t\\t//                     -1 if previous element is smaller than current element\\n\\t\\t//                     1 if previous element is greater than the current element\\n\\t\\t\\n        int len=1;\\n\\t\\t// minimum length of turbulent array can be 1\\n\\t\\t\\n        while(j<n){\\n            int s;\\n\\t\\t\\t// to store whether the current element is greater or smaller or equal to the previous element\\n            if(arr[j-1]>arr[j])\\n                s=1;\\n            else if(arr[j-1]<arr[j])\\n                s=-1;\\n            else{\\n                s=0;\\n                i=j;\\n\\t\\t\\t\\t// if previous element is same as current element then we place i pointer on current element\\n            }\\n            if(s==prev_sign){\\n                i=j-1;\\n\\t\\t\\t\\t// if prev_sign is same as current sign then subarray [i,j] is not turbulant so we have to update i pointer to j for obtaining next subarray\\n            }\\n            else{\\n                len=max(len,j-i+1);\\n\\t\\t\\t\\t// if prev_sign is not same as current sign then subarray [i,j] can be our possible answer. \\n                prev_sign=s;\\n\\t\\t\\t\\t// updating prev_sign for next iteration\\n            }\\n            j++;\\n        }\\n        return len;\\n    }",
                "solutionTags": [
                    "C",
                    "Two Pointers"
                ],
                "code": "Using 2 pointer technique, prev_sign store the information that previous element is smaller or greater or equal to the current element.\\nIf prev_sign is different from the current sign then we consider that subarray in our answer.\\n\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n=arr.size();  // Size of array\\n        if(n<2)\\n            return n;\\n\\t\\t// if size of array is 0 or 1 then it will return 0 or 1 because single element is turbulant itself\\n\\t\\t\\n        int i=0,j=1; \\n\\t\\t// initializing 2 pointers \\n\\t\\t\\n        int prev_sign=2;  \\n\\t\\t// take random value (which is not possible) as their difference\\n\\t\\t// prev_sign is:\\n\\t\\t//                     0 if previous element is same as the current element\\n\\t\\t//                     -1 if previous element is smaller than current element\\n\\t\\t//                     1 if previous element is greater than the current element\\n\\t\\t\\n        int len=1;\\n\\t\\t// minimum length of turbulent array can be 1\\n\\t\\t\\n        while(j<n){\\n            int s;\\n\\t\\t\\t// to store whether the current element is greater or smaller or equal to the previous element\\n            if(arr[j-1]>arr[j])\\n                s=1;\\n            else if(arr[j-1]<arr[j])\\n                s=-1;\\n            else{\\n                s=0;\\n                i=j;\\n\\t\\t\\t\\t// if previous element is same as current element then we place i pointer on current element\\n            }\\n            if(s==prev_sign){\\n                i=j-1;\\n\\t\\t\\t\\t// if prev_sign is same as current sign then subarray [i,j] is not turbulant so we have to update i pointer to j for obtaining next subarray\\n            }\\n            else{\\n                len=max(len,j-i+1);\\n\\t\\t\\t\\t// if prev_sign is not same as current sign then subarray [i,j] can be our possible answer. \\n                prev_sign=s;\\n\\t\\t\\t\\t// updating prev_sign for next iteration\\n            }\\n            j++;\\n        }\\n        return len;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 1465080,
                "title": "c-easy-and-simple-solution-using-two-pointer-approach",
                "content": "it is basic two pointer question . the subarrray will consist of elements with the following two conditions\\n1 an element[i] smaller then both prev[i-1] and next[i+1]\\nor greater than both prev[i-1] and next[i+1].\\n```\\nclass Solution {\\npublic:\\n    bool isvalid(vector<int>& arr, int j){\\n        return (arr[j]<arr[j-1]&&arr[j]<arr[j+1])||(arr[j]>arr[j-1]&&arr[j]>arr[j+1]);\\n    }\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n<2)\\n            return n; // if size is smaller then 2 return the size;\\n        int ans = 1;\\n        int st=0,end=0;\\n        while(st+1<n){\\n            if(arr[st]==arr[st+1]){// ex 8 8 9 5 skip the first 8\\n                st++;\\n                continue;\\n            }\\n            end=st+1;\\n            while(end+1 < n && isvalid(arr,end)){\\n                end++;\\n            }\\n            ans = max(ans, end-st+1); // caluclating curr subarray length and comparing it with ans\\n            st = end;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    bool isvalid(vector<int>& arr, int j){\\n        return (arr[j]<arr[j-1]&&arr[j]<arr[j+1])||(arr[j]>arr[j-1]&&arr[j]>arr[j+1]);\\n    }\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int n = arr.size();\\n        if(n<2)\\n            return n; // if size is smaller then 2 return the size;\\n        int ans = 1;\\n        int st=0,end=0;\\n        while(st+1<n){\\n            if(arr[st]==arr[st+1]){// ex 8 8 9 5 skip the first 8\\n                st++;\\n                continue;\\n            }\\n            end=st+1;\\n            while(end+1 < n && isvalid(arr,end)){\\n                end++;\\n            }\\n            ans = max(ans, end-st+1); // caluclating curr subarray length and comparing it with ans\\n            st = end;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464992,
                "title": "c-978-longest-turbulent-subarray",
                "content": "\\n```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int ans = 1, prev = 0; \\n        for (int i = 1, ii = 0; i < arr.size(); ++i) {\\n            int diff = arr[i] - arr[i-1]; \\n            if (diff == 0) ii = i; \\n            else if ((long)prev * diff > 0) ii = i-1; \\n            ans = max(ans, i - ii + 1); \\n            prev = diff; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int ans = 1, prev = 0; \\n        for (int i = 1, ii = 0; i < arr.size(); ++i) {\\n            int diff = arr[i] - arr[i-1]; \\n            if (diff == 0) ii = i; \\n            else if ((long)prev * diff > 0) ii = i-1; \\n            ans = max(ans, i - ii + 1); \\n            prev = diff; \\n        }\\n        return ans; \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464984,
                "title": "c-easy-to-understand-longest-turbulent-subarray",
                "content": "// find all the comparison relation between  every number \\n// check for both the given conditios to find longest turbulent subarray\\n\\n\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n    \\n        int n = arr.size();\\n        if(n ==1)\\n            return 1;\\n        string s;\\n        int ans =0;\\n        for(int i=0; i<n-1; i++){\\n            if(arr[i] > arr[i+1]){\\n                s.push_back(\\'>\\');\\n            }\\n            else if(arr[i] < arr[i+1]){\\n                s.push_back(\\'<\\');\\n            }\\n            else{\\n                s.push_back(\\'=\\');\\n            }    \\n        }\\n         //cout<<s<<\" \";\\n        int opt1=1,opt2=1,ctr1=1,ctr2=1;\\n        for(int i=0;i<s.length();i++){\\n            if((i%2 == 0 and s[i] == \\'>\\') || (i%2 == 1 and s[i] ==\\'<\\')){\\n                ctr1++;\\n               // cout<<ctr1<<\" \";\\n            }\\n            else{\\n                opt1 = max(opt1,ctr1);\\n                ctr1=1;\\n            }\\n        }\\n        opt1 = max(opt1,ctr1);\\n        for(int i=0; i<s.length(); i++){\\n          if((i%2 == 0 and s[i] == \\'<\\') || (i%2 == 1 and s[i] ==\\'>\\')){\\n                ctr2++;\\n              cout<<ctr2<<\" \";\\n            }\\n            else{\\n                opt2 = max(opt2,ctr2);\\n                ctr2=1;\\n            }\\n        }\\n        opt2 = max(opt2,ctr2);\\n        \\n\\n        return max(opt1,opt2);\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n    \\n        int n = arr.size();\\n        if(n ==1)\\n            return 1;\\n        string s;\\n        int ans =0;\\n        for(int i=0; i<n-1; i++){\\n            if(arr[i] > arr[i+1]){\\n                s.push_back(\\'>\\');\\n            }",
                "codeTag": "Java"
            },
            {
                "id": 1464951,
                "title": "rust-single-pass-iterator-fold",
                "content": "We use the `i32::signum` method. Keep in mind that\\n - `(x - y).signum() = - 1`, when `x < y`\\n - `(x - y).signum() = 1`, when `x > y`\\n \\nWe walk through windows of size 2 and calculate neighbor difference `signum`s.   \\nThen, we search the longest consecutive  segment such that `a[i - 1] - a[i]).signum() * (a[i] - a[i + 1]).signum() == -1`. \\nThat way, we automatically rull out equal neighbors as well.\\n\\nOur fold state constists of three integers in the following order:\\n1. total size of current sign change sequence\\n2. previous signum\\n3. maximum size found yet\\n\\nWhen the condition is failed, the current size is reset to `(a[i] - a[i + 1]).signum().abs()` which gives us 0 for pair of equal neighbors and 1 for non-equals.\\n\\nFinally, we add 1 to the result since we counting elements, not pairs\\n\\n```rust\\nimpl Solution {\\n\\tpub fn max_turbulence_size(arr: Vec<i32>) -> i32 {\\n\\t\\tarr.windows(2)\\n\\t\\t\\t.map(|v| (v[0] - v[1]).signum())\\n\\t\\t\\t.fold((0, 0, 0), |(cnt, ps, mx), s| {\\n\\t\\t\\t\\tlet cnt = if ps * s == -1 { cnt + 1 } else { s.abs() };\\n\\t\\t\\t\\t(cnt, s, mx.max(cnt))\\n\\t\\t\\t})\\n\\t\\t\\t.2 + 1\\n\\t}\\n}\\n```",
                "solutionTags": [],
                "code": "```rust\\nimpl Solution {\\n\\tpub fn max_turbulence_size(arr: Vec<i32>) -> i32 {\\n\\t\\tarr.windows(2)\\n\\t\\t\\t.map(|v| (v[0] - v[1]).signum())\\n\\t\\t\\t.fold((0, 0, 0), |(cnt, ps, mx), s| {\\n\\t\\t\\t\\tlet cnt = if ps * s == -1 { cnt + 1 } else { s.abs() };\\n\\t\\t\\t\\t(cnt, s, mx.max(cnt))\\n\\t\\t\\t})\\n\\t\\t\\t.2 + 1\\n\\t}\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1464920,
                "title": "c-two-pointer-approach-faster-than-93-submissions-tc-o-n-sc-o-1",
                "content": "Approach is similar to sliding window:\\n```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int sign = 0, prev = 0, ans = 0; //Initialise current sign, previous sign and answer to 0\\n        for(int i=0, j=0; j<arr.size(); j++) {\\n            if(j== arr.size()-1) { // If right most pointer reaches array size, return maximum of ans, window size\\n                return max(ans, j-i+1);\\n            }\\n            if(arr[j]>arr[j+1]) sign =1;\\n            else if(arr[j]<arr[j+1]) sign = -1;\\n            else sign =0;\\n            \\n            if(sign ==0) { // If current and next elements are equal, update answer and then update left pointer to next element index\\n                ans = max(ans, j-i+1);\\n                i = j+1;\\n            }\\n            if(sign != -prev) { // If current sign not equals to opposite of previous sign, then update answer and left most pointer to current index\\n                ans = max(ans, j-i+1);\\n                i = j;\\n            } \\n            prev = sign; // update previous sign to current sign after end of every iteration\\n        }\\n        return ans;\\n    }\\n}; \\n```\\n\\nTime Complexity: O(N)\\nSpace Complexity: O(1)",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int sign = 0, prev = 0, ans = 0; //Initialise current sign, previous sign and answer to 0\\n        for(int i=0, j=0; j<arr.size(); j++) {\\n            if(j== arr.size()-1) { // If right most pointer reaches array size, return maximum of ans, window size\\n                return max(ans, j-i+1);\\n            }\\n            if(arr[j]>arr[j+1]) sign =1;\\n            else if(arr[j]<arr[j+1]) sign = -1;\\n            else sign =0;\\n            \\n            if(sign ==0) { // If current and next elements are equal, update answer and then update left pointer to next element index\\n                ans = max(ans, j-i+1);\\n                i = j+1;\\n            }\\n            if(sign != -prev) { // If current sign not equals to opposite of previous sign, then update answer and left most pointer to current index\\n                ans = max(ans, j-i+1);\\n                i = j;\\n            } \\n            prev = sign; // update previous sign to current sign after end of every iteration\\n        }\\n        return ans;\\n    }\\n}; \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464919,
                "title": "simple-c-solution-two-pointer-approach-easy-to-understand",
                "content": "```\\nclass Solution {\\npublic:\\n    //checking whether current index is turbulent or not\\n    //current index is turbulent when it forms valley(local min)  or  mountain(local max)\\n    //valley or mountain can be indentified by given below lines \\n    //valley: arr[k-1] > arr[k] < arr[k+1]\\n    //mountain: arr[k-1] < arr[k] > arr[k+1]\\n    \\n    bool IsCurrIndexTurbulent(vector<int>& arr , int k){\\n        return ( ( arr[k-1] < arr[k] && arr[k] > arr[k+1] )  || ( arr[k] < arr[k-1] && arr[k] < arr[k+1] )  ) ;\\n    }\\n    \\n    \\n    int maxTurbulenceSize(vector<int>& arr) {\\n        \\n        int len = arr.size();\\n        \\n        if( len < 2)\\n            return len;\\n        \\n        // when all the elements are equal \\n        int ans = 1;\\n        \\n        \\n        //using 2 pointer approach\\n        int s = 0 ;\\n        int e = 0 ;\\n        \\n        while( s+1 < len){\\n            \\n            //just skipping the iteration\\n            if(arr[s] == arr[s+1] ){\\n                s++;\\n                continue;\\n            }\\n               \\n            \\n            e = s+1;\\n            \\n            //incrementing e until we find a non-turbulent element\\n            while( e+1 < len && IsCurrIndexTurbulent(arr , e) ){\\n                e++;\\n            }\\n            \\n            //calculating current turbulent subarrray size\\n            int CurrlengthOfTurbulent = (e - s + 1);\\n            \\n            //max of all turbulent subarray\\n            ans = max ( ans , CurrlengthOfTurbulent );\\n            //updating e\\n            s = e;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    //checking whether current index is turbulent or not\\n    //current index is turbulent when it forms valley(local min)  or  mountain(local max)\\n    //valley or mountain can be indentified by given below lines \\n    //valley: arr[k-1] > arr[k] < arr[k+1]\\n    //mountain: arr[k-1] < arr[k] > arr[k+1]\\n    \\n    bool IsCurrIndexTurbulent(vector<int>& arr , int k){\\n        return ( ( arr[k-1] < arr[k] && arr[k] > arr[k+1] )  || ( arr[k] < arr[k-1] && arr[k] < arr[k+1] )  ) ;\\n    }\\n    \\n    \\n    int maxTurbulenceSize(vector<int>& arr) {\\n        \\n        int len = arr.size();\\n        \\n        if( len < 2)\\n            return len;\\n        \\n        // when all the elements are equal \\n        int ans = 1;\\n        \\n        \\n        //using 2 pointer approach\\n        int s = 0 ;\\n        int e = 0 ;\\n        \\n        while( s+1 < len){\\n            \\n            //just skipping the iteration\\n            if(arr[s] == arr[s+1] ){\\n                s++;\\n                continue;\\n            }\\n               \\n            \\n            e = s+1;\\n            \\n            //incrementing e until we find a non-turbulent element\\n            while( e+1 < len && IsCurrIndexTurbulent(arr , e) ){\\n                e++;\\n            }\\n            \\n            //calculating current turbulent subarrray size\\n            int CurrlengthOfTurbulent = (e - s + 1);\\n            \\n            //max of all turbulent subarray\\n            ans = max ( ans , CurrlengthOfTurbulent );\\n            //updating e\\n            s = e;\\n        }\\n        \\n        return ans;\\n        \\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464888,
                "title": "kotlin-simple-short-solution",
                "content": "```\\nclass Solution {\\n    fun maxTurbulenceSize(arr: IntArray): Int {\\n        var res = 1\\n        var currentSize = 1\\n        var diff = 0\\n        for (i in 1..arr.lastIndex) {\\n            val newDiff = arr[i] - arr[i - 1]\\n            when {\\n                diff < 0 && newDiff > 0 || diff > 0 && newDiff < 0 -> ++currentSize\\n                newDiff == 0 -> currentSize = 1\\n                else -> currentSize = 2\\n            }\\n            diff = newDiff\\n            res = maxOf(res, currentSize)\\n        }\\n        return res\\n    }\\n}\\n```",
                "solutionTags": [
                    "Kotlin"
                ],
                "code": "```\\nclass Solution {\\n    fun maxTurbulenceSize(arr: IntArray): Int {\\n        var res = 1\\n        var currentSize = 1\\n        var diff = 0\\n        for (i in 1..arr.lastIndex) {\\n            val newDiff = arr[i] - arr[i - 1]\\n            when {\\n                diff < 0 && newDiff > 0 || diff > 0 && newDiff < 0 -> ++currentSize\\n                newDiff == 0 -> currentSize = 1\\n                else -> currentSize = 2\\n            }\\n            diff = newDiff\\n            res = maxOf(res, currentSize)\\n        }\\n        return res\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464593,
                "title": "python-solution",
                "content": "Hope it helps\\n\\n```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        # arr[i] < arr[i+1] ----> comp = -1\\n        # arr[i] > arr[i+1] ----> comp = 1\\n        # arr[i] == arr[i+1] ---> comp = 0\\n        start = comp = max_length = end = 0\\n        n = len(arr)\\n        for end in range(1, n):\\n            if arr[end - 1] < arr[end]:\\n                if comp == -1:\\n                    max_length = max(max_length, end - start)\\n                    start = end - 1\\n                comp = -1\\n            elif arr[end - 1] > arr[end]:\\n                if comp == 1:\\n                    max_length = max(max_length, end - start)\\n                    start = end - 1\\n                comp = 1\\n            else:\\n                max_length = max(max_length, end - start)\\n                start = end\\n                comp = 0\\n        return max(max_length, end - start + 1)\\n\\n```",
                "solutionTags": [
                    "Python",
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        # arr[i] < arr[i+1] ----> comp = -1\\n        # arr[i] > arr[i+1] ----> comp = 1\\n        # arr[i] == arr[i+1] ---> comp = 0\\n        start = comp = max_length = end = 0\\n        n = len(arr)\\n        for end in range(1, n):\\n            if arr[end - 1] < arr[end]:\\n                if comp == -1:\\n                    max_length = max(max_length, end - start)\\n                    start = end - 1\\n                comp = -1\\n            elif arr[end - 1] > arr[end]:\\n                if comp == 1:\\n                    max_length = max(max_length, end - start)\\n                    start = end - 1\\n                comp = 1\\n            else:\\n                max_length = max(max_length, end - start)\\n                start = end\\n                comp = 0\\n        return max(max_length, end - start + 1)\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1464560,
                "title": "o-n-time-o-1-space-96-time-97-space-c-easy",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) \\n    {\\n        if(arr.size()<2)\\n            return arr.size();\\n        int ctr = 1;\\n        int maxctr = INT_MIN;\\n        int mutex;\\n        if(arr[0]>arr[1])\\n            mutex = 0;\\n        else\\n            mutex = 1;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            if(mutex == 0 && arr[i]>arr[i+1])\\n            {\\n                ctr++;\\n                mutex = 1;\\n            }\\n            else if(mutex == 1 && arr[i]<arr[i+1])\\n            {\\n                ctr++;\\n                mutex = 0;\\n            }\\n            else if(arr[i] == arr[i+1])\\n            {\\n                maxctr = max(maxctr,ctr);\\n                ctr = 1;\\n            }\\n            else\\n            {\\n                maxctr = max(maxctr,ctr);\\n                ctr = 2;\\n                \\n            }\\n        }\\n        maxctr = max(maxctr,ctr);\\n        return maxctr;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) \\n    {\\n        if(arr.size()<2)\\n            return arr.size();\\n        int ctr = 1;\\n        int maxctr = INT_MIN;\\n        int mutex;\\n        if(arr[0]>arr[1])\\n            mutex = 0;\\n        else\\n            mutex = 1;\\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            if(mutex == 0 && arr[i]>arr[i+1])\\n            {\\n                ctr++;\\n                mutex = 1;\\n            }\\n            else if(mutex == 1 && arr[i]<arr[i+1])\\n            {\\n                ctr++;\\n                mutex = 0;\\n            }\\n            else if(arr[i] == arr[i+1])\\n            {\\n                maxctr = max(maxctr,ctr);\\n                ctr = 1;\\n            }\\n            else\\n            {\\n                maxctr = max(maxctr,ctr);\\n                ctr = 2;\\n                \\n            }\\n        }\\n        maxctr = max(maxctr,ctr);\\n        return maxctr;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1454556,
                "title": "python-o-n-sliding-window-solution",
                "content": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n                \\n        N = len(arr)\\n        if N == 1:\\n            return 1\\n        \\n        if arr[0] != arr[1]:\\n            window = 2\\n        else:\\n            window = 1\\n        \\n        maxLen = window \\n        \\n        for i in range(2, N):\\n            \\n            if arr[i] == arr[i-1]:\\n                window = 1\\n            elif (arr[i-2] < arr[i-1] <= arr[i]) or (arr[i-2] > arr[i-1] >= arr[i]):\\n                window = 2\\n            else:\\n                window += 1\\n                maxLen = max(maxLen, window)\\n        \\n        return maxLen\\n\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n                \\n        N = len(arr)\\n        if N == 1:\\n            return 1\\n        \\n        if arr[0] != arr[1]:\\n            window = 2\\n        else:\\n            window = 1\\n        \\n        maxLen = window \\n        \\n        for i in range(2, N):\\n            \\n            if arr[i] == arr[i-1]:\\n                window = 1\\n            elif (arr[i-2] < arr[i-1] <= arr[i]) or (arr[i-2] > arr[i-1] >= arr[i]):\\n                window = 2\\n            else:\\n                window += 1\\n                maxLen = max(maxLen, window)\\n        \\n        return maxLen\\n\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1417330,
                "title": "c-sliding-window",
                "content": "```\\nclass Solution \\n{\\n    public:\\n    int findSign(int a, int b)\\n    {\\n        return a!=b ? (a-b)/abs(a-b) : 0;\\n    }\\n    \\n    int maxTurbulenceSize(vector<int>& A) \\n    {\\n        int n = A.size(), ans = 1, initial = 0;\\n        \\n        for(int i = 1 ; i < n ; i++)\\n        {\\n            int c = findSign(A[i-1],A[i]);\\n            if (c == 0)\\n                initial = i;\\n            else if (i == n - 1 || c*findSign(A[i],A[i+1]) != -1)\\n            {\\n                ans = max(ans, i - initial + 1);\\n                initial = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution \\n{\\n    public:\\n    int findSign(int a, int b)\\n    {\\n        return a!=b ? (a-b)/abs(a-b) : 0;\\n    }\\n    \\n    int maxTurbulenceSize(vector<int>& A) \\n    {\\n        int n = A.size(), ans = 1, initial = 0;\\n        \\n        for(int i = 1 ; i < n ; i++)\\n        {\\n            int c = findSign(A[i-1],A[i]);\\n            if (c == 0)\\n                initial = i;\\n            else if (i == n - 1 || c*findSign(A[i],A[i+1]) != -1)\\n            {\\n                ans = max(ans, i - initial + 1);\\n                initial = i;\\n            }\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1404936,
                "title": "c-o-n",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int sz=arr.size();\\n        if(sz==1) return 1;\\n        \\n        int l=1;\\n        int ans=1;\\n        while(l<sz)\\n        {\\n            if(arr[l]>arr[l-1])\\n            {\\n              bool b=1;\\n                int count=0;\\n              while(l<sz)\\n              {\\n                 if(b and arr[l]>arr[l-1])\\n                 {\\n                     b=0;\\n                     count++;\\n                 }\\n                  else if(!b and arr[l]<arr[l-1])\\n                  {\\n                      b=1;\\n                      count++;\\n                  }\\n                  else\\n                      break;\\n                  l++;\\n              }\\n                ans=max(ans,count+1);\\n            }\\n            else if(arr[l]<arr[l-1])\\n            {\\n                int count=0,b=1;\\n                while(l<sz)\\n                {\\n                    if(b and arr[l]<arr[l-1])\\n                    {\\n                        b=0;\\n                        count++;\\n                    }\\n                    else if(!b and arr[l]>arr[l-1])\\n                    {\\n                        b=1;\\n                        count++;\\n                    }\\n                    else\\n                        break;\\n                    l++;\\n                }\\n                ans=max(ans,count+1);\\n            }\\n            else\\n                l++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        int sz=arr.size();\\n        if(sz==1) return 1;\\n        \\n        int l=1;\\n        int ans=1;\\n        while(l<sz)\\n        {\\n            if(arr[l]>arr[l-1])\\n            {\\n              bool b=1;\\n                int count=0;\\n              while(l<sz)\\n              {\\n                 if(b and arr[l]>arr[l-1])\\n                 {\\n                     b=0;\\n                     count++;\\n                 }\\n                  else if(!b and arr[l]<arr[l-1])\\n                  {\\n                      b=1;\\n                      count++;\\n                  }\\n                  else\\n                      break;\\n                  l++;\\n              }\\n                ans=max(ans,count+1);\\n            }\\n            else if(arr[l]<arr[l-1])\\n            {\\n                int count=0,b=1;\\n                while(l<sz)\\n                {\\n                    if(b and arr[l]<arr[l-1])\\n                    {\\n                        b=0;\\n                        count++;\\n                    }\\n                    else if(!b and arr[l]>arr[l-1])\\n                    {\\n                        b=1;\\n                        count++;\\n                    }\\n                    else\\n                        break;\\n                    l++;\\n                }\\n                ans=max(ans,count+1);\\n            }\\n            else\\n                l++;\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1366022,
                "title": "easy-o-n-time-and-o-1-space-c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        \\n        int res=1;\\n        \\n        int currRes=1;\\n        \\n        \\n        if(arr.size()==1)\\n            return 1;\\n        int sign=0;\\n        \\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            if(sign==-1)\\n            {\\n                //it is decreasing\\n                if(arr[i+1] > arr[i])\\n                {\\n                    currRes++;\\n                    sign=1;\\n                }\\n                else if(arr[i+1]<arr[i])\\n                {\\n                    //decreasing\\n                    currRes=2;\\n                    sign=-1;\\n                }\\n                else{\\n                    currRes=1;\\n                }\\n            }\\n            else{\\n                //it is increasing\\n                if(arr[i] > arr[i+1])\\n                {\\n                    currRes++;\\n                    sign=-1;\\n                }\\n                else if(arr[i] < arr[i+1]   ){\\n                    currRes=2;\\n                    sign=1;\\n                }\\n                else{\\n                    currRes=1;\\n                }\\n            }\\n            res=max(currRes,res);\\n        }\\n        return res;\\n    }\\n};\\n```\\n**upvote if this helps you :)**",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        \\n        int res=1;\\n        \\n        int currRes=1;\\n        \\n        \\n        if(arr.size()==1)\\n            return 1;\\n        int sign=0;\\n        \\n        for(int i=0;i<arr.size()-1;i++)\\n        {\\n            if(sign==-1)\\n            {\\n                //it is decreasing\\n                if(arr[i+1] > arr[i])\\n                {\\n                    currRes++;\\n                    sign=1;\\n                }\\n                else if(arr[i+1]<arr[i])\\n                {\\n                    //decreasing\\n                    currRes=2;\\n                    sign=-1;\\n                }\\n                else{\\n                    currRes=1;\\n                }\\n            }\\n            else{\\n                //it is increasing\\n                if(arr[i] > arr[i+1])\\n                {\\n                    currRes++;\\n                    sign=-1;\\n                }\\n                else if(arr[i] < arr[i+1]   ){\\n                    currRes=2;\\n                    sign=1;\\n                }\\n                else{\\n                    currRes=1;\\n                }\\n            }\\n            res=max(currRes,res);\\n        }\\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1356420,
                "title": "c-6-lines-both-o-n-and-o-1-solutions-dp-with-explanation",
                "content": "\\n```\\n// O(N) SOLUTION\\nint maxTurbulenceSize(vector<int>& arr) {\\n        vector<int> inc(arr.size(),0); //inc[i]=length of turb subarray ending at i with last element increasing\\n        vector<int> dec(arr.size(),0); //dec[i]=length of turb subarray ending at i with last element decreasing\\n\\n        int ans=1,f=0;\\n        inc[0]=dec[0]=1;\\n        for(int i=1;i<arr.size();i++){\\n           //if arr[i]>arr[i-1], add arr[i] to turb subarr with last element decreasing\\n            inc[i]=arr[i]>arr[i-1]?dec[i-1]+1:1;\\n            \\n\\t\\t\\t//if arr[i]<arr[i-1], add arr[i] to turb subarr with last element increasing\\n            dec[i]=arr[i]<arr[i-1]?inc[i-1]+1:1;\\n            \\n\\t\\t\\t//calculate overall max, of subarrays ending at each index\\n            ans=max({ans,dec[i],inc[i]});\\n           \\n        }\\n        return ans;\\n    }\\n```\\nWe can use variables instead of dp arrays as we just need prev values(inc[i-1] and dec[i-1] at each i)\\n```\\n//O(1) SOLUTION\\nint maxTurbulenceSize(vector<int>& arr) {\\n        int inc,dec,tmp;\\n        int ans=1,f=0;\\n        inc=dec=1;\\n        for(int i=1;i<arr.size();i++){\\n            tmp=inc;\\n            inc=arr[i]>arr[i-1]?dec+1:1;\\n            \\n            dec=arr[i]<arr[i-1]?tmp+1:1;\\n            \\n            ans=max({ans,dec,inc});\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\n// O(N) SOLUTION\\nint maxTurbulenceSize(vector<int>& arr) {\\n        vector<int> inc(arr.size(),0); //inc[i]=length of turb subarray ending at i with last element increasing\\n        vector<int> dec(arr.size(),0); //dec[i]=length of turb subarray ending at i with last element decreasing\\n\\n        int ans=1,f=0;\\n        inc[0]=dec[0]=1;\\n        for(int i=1;i<arr.size();i++){\\n           //if arr[i]>arr[i-1], add arr[i] to turb subarr with last element decreasing\\n            inc[i]=arr[i]>arr[i-1]?dec[i-1]+1:1;\\n            \\n\\t\\t\\t//if arr[i]<arr[i-1], add arr[i] to turb subarr with last element increasing\\n            dec[i]=arr[i]<arr[i-1]?inc[i-1]+1:1;\\n            \\n\\t\\t\\t//calculate overall max, of subarrays ending at each index\\n            ans=max({ans,dec[i],inc[i]});\\n           \\n        }\\n        return ans;\\n    }\\n```\n```\\n//O(1) SOLUTION\\nint maxTurbulenceSize(vector<int>& arr) {\\n        int inc,dec,tmp;\\n        int ans=1,f=0;\\n        inc=dec=1;\\n        for(int i=1;i<arr.size();i++){\\n            tmp=inc;\\n            inc=arr[i]>arr[i-1]?dec+1:1;\\n            \\n            dec=arr[i]<arr[i-1]?tmp+1:1;\\n            \\n            ans=max({ans,dec,inc});\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1330430,
                "title": "java-dp-solution-simple-approach",
                "content": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] arr) {\\n        int max=1;\\n        int dp[]=new int[arr.length];\\n        Arrays.fill(dp,1);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(i==arr.length-1)\\n            {\\n                max=Math.max(max,dp[i]);\\n                break;\\n            }\\n            if((i&1)==1)\\n            {\\n                if(arr[i]>arr[i+1])\\n                    dp[i+1]=dp[i]+1;\\n            }\\n            else\\n            {\\n                if(arr[i]<arr[i+1])\\n                     dp[i+1]=dp[i]+1;\\n            }\\n            max=Math.max(max,dp[i]);\\n        }\\n        Arrays.fill(dp,1);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(i==arr.length-1)\\n            {\\n                max=Math.max(max,dp[i]);\\n                break;\\n            }\\n            if((i&1)==1)\\n            {\\n                if(arr[i]<arr[i+1])\\n                     dp[i+1]=dp[i]+1;\\n            }\\n            else\\n            {\\n                if(arr[i]>arr[i+1])\\n                     dp[i+1]=dp[i]+1;\\n            }\\n            max=Math.max(max,dp[i]);\\n             \\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] arr) {\\n        int max=1;\\n        int dp[]=new int[arr.length];\\n        Arrays.fill(dp,1);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(i==arr.length-1)\\n            {\\n                max=Math.max(max,dp[i]);\\n                break;\\n            }\\n            if((i&1)==1)\\n            {\\n                if(arr[i]>arr[i+1])\\n                    dp[i+1]=dp[i]+1;\\n            }\\n            else\\n            {\\n                if(arr[i]<arr[i+1])\\n                     dp[i+1]=dp[i]+1;\\n            }\\n            max=Math.max(max,dp[i]);\\n        }\\n        Arrays.fill(dp,1);\\n        for(int i=0;i<arr.length;i++)\\n        {\\n            if(i==arr.length-1)\\n            {\\n                max=Math.max(max,dp[i]);\\n                break;\\n            }\\n            if((i&1)==1)\\n            {\\n                if(arr[i]<arr[i+1])\\n                     dp[i+1]=dp[i]+1;\\n            }\\n            else\\n            {\\n                if(arr[i]>arr[i+1])\\n                     dp[i+1]=dp[i]+1;\\n            }\\n            max=Math.max(max,dp[i]);\\n             \\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1298280,
                "title": "simple-solution",
                "content": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] arr) {\\n    int max = 0, len = 0;\\n\\n    for(int i = 0; i < arr.length; i++) {\\n        if(i >= 2 && ((arr[i-2] > arr[i-1] && arr[i-1] < arr[i]) ||\\n                      (arr[i-2] < arr[i-1] && arr[i-1] > arr[i])) ) {\\n            len++;\\n        } else if(i >= 1 && arr[i-1] != arr[i]) {\\n            len = 2;\\n        } else {\\n            len = 1;\\n        }\\n        max = Math.max(max, len);\\n    }\\n    return max;    \\n}\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] arr) {\\n    int max = 0, len = 0;\\n\\n    for(int i = 0; i < arr.length; i++) {\\n        if(i >= 2 && ((arr[i-2] > arr[i-1] && arr[i-1] < arr[i]) ||\\n                      (arr[i-2] < arr[i-1] && arr[i-1] > arr[i])) ) {\\n            len++;\\n        } else if(i >= 1 && arr[i-1] != arr[i]) {\\n            len = 2;\\n        } else {\\n            len = 1;\\n        }\\n        max = Math.max(max, len);\\n    }\\n    return max;    \\n}\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1288195,
                "title": "lis-pattern-o-n",
                "content": "Lis pattern but no need to check for all the previous elements just check for just previous element.\\ndp[0][i] means optimal ans when this slope forms \\'/\\' (A[i-1]<A[i])\\ndp[1][i] means optimal ans when this slope forms  \\'\\\\\\\\\\' (A[i-1]>A[i])\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& A) {\\n        int ans = 1, len = 1, last = 0, n = A.size();\\n        int dp[2][n+1];\\n        dp[0][0] = 1;\\n        dp[1][0] = 1;\\n        for (int i = 1; i < n;i++) {\\n            dp[0][i] = 1;\\n            dp[1][i] = 1;\\n\\t\\t\\tif(A[i-1]<A[i]) \\n                dp[0][i] = max(dp[0][i],dp[1][i-1]+1);\\n\\n            else if(A[i-1]>A[i])\\n                dp[1][i] = max(dp[1][i],dp[0][i-1]+1);\\n        \\n            ans = max({ans,dp[0][i],dp[1][i]});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& A) {\\n        int ans = 1, len = 1, last = 0, n = A.size();\\n        int dp[2][n+1];\\n        dp[0][0] = 1;\\n        dp[1][0] = 1;\\n        for (int i = 1; i < n;i++) {\\n            dp[0][i] = 1;\\n            dp[1][i] = 1;\\n\\t\\t\\tif(A[i-1]<A[i]) \\n                dp[0][i] = max(dp[0][i],dp[1][i-1]+1);\\n\\n            else if(A[i-1]>A[i])\\n                dp[1][i] = max(dp[1][i],dp[0][i-1]+1);\\n        \\n            ans = max({ans,dp[0][i],dp[1][i]});\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1281350,
                "title": "python3-use-double-dp",
                "content": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        dp = [1 for _ in arr]\\n        max_len = 1\\n        for i in range(0,len(arr) - 1): # check condition 1\\n            if (i % 2 == 1 and arr[i] > arr[i + 1]) or (i % 2 == 0 and arr[i] < arr[i + 1]):\\n                dp[i + 1] = dp[i] + 1\\n                max_len = max(max_len, dp[i + 1])    \\n        dp = [1 for _ in arr]\\n        for i in range(0,len(arr) - 1): # check condition 2\\n            if (i % 2 == 0 and arr[i] > arr[i + 1]) or (i % 2 == 1 and arr[i] < arr[i + 1]):\\n                dp[i + 1] = dp[i] + 1\\n                max_len = max(max_len, dp[i + 1])\\n        return max_len\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        dp = [1 for _ in arr]\\n        max_len = 1\\n        for i in range(0,len(arr) - 1): # check condition 1\\n            if (i % 2 == 1 and arr[i] > arr[i + 1]) or (i % 2 == 0 and arr[i] < arr[i + 1]):\\n                dp[i + 1] = dp[i] + 1\\n                max_len = max(max_len, dp[i + 1])    \\n        dp = [1 for _ in arr]\\n        for i in range(0,len(arr) - 1): # check condition 2\\n            if (i % 2 == 0 and arr[i] > arr[i + 1]) or (i % 2 == 1 and arr[i] < arr[i + 1]):\\n                dp[i + 1] = dp[i] + 1\\n                max_len = max(max_len, dp[i + 1])\\n        return max_len\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1247741,
                "title": "c-10-lines-clean-and-straightforward-o-n-solution",
                "content": "\\n\\n```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& v) {\\n        int len = 0, n = v.size(), i, j;\\n        auto is_turbulent = [&]() {\\n            if(j-i==0) return true;\\n            else if(j-i==1) return v[i]!=v[j];\\n            else return (v[j]>v[j-1] && v[j-2]>v[j-1]) || (v[j]<v[j-1] && v[j-2]<v[j-1]);\\n        };\\n        for(i=0, j=0; j<n; j++) {\\n            while(!is_turbulent()) i++;\\n            len = max(len,j-i+1);\\n        }\\n        return len;\\n    }\\n};\\n\\n```\\n\\n```\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& v) {\\n        int len = 0, n = v.size(), i, j;\\n        auto is_turbulent = [&]() {\\n            if(j-i==0) return true;\\n            else if(j-i==1) return v[i]!=v[j];\\n            else return (v[j]>v[j-1] && v[j-2]>v[j-1]) || (v[j]<v[j-1] && v[j-2]<v[j-1]);\\n        };\\n        for(i=0, j=0; j<n; j++) {\\n            while(!is_turbulent()) i++;\\n            len = max(len,j-i+1);\\n        }\\n        return len;\\n    }\\n};\\n\\n```\n```\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1238211,
                "title": "c-recursion-memoisation",
                "content": "```\\nclass Solution {\\npublic:\\n    vector<int>arr;\\n    vector<vector<int>>dp;\\n    \\n    int recurs(int i,char sign)\\n    {\\n        if(i>=arr.size())\\n        {\\n         return 0;\\n        }\\n        \\n        if(dp[i][sign-60]!=-1)\\n        {\\n            return dp[i][sign-60];\\n        }\\n        \\n        \\n        if(sign==\\'<\\')\\n        {\\n            if(arr[i]<arr[i-1])\\n            {\\n                return dp[i][sign-60]=recurs(i+1,\\'>\\')+1;\\n            }\\n            else\\n            {\\n                return dp[i][sign-60]=0;\\n            }\\n        }\\n        if(sign==\\'>\\')\\n        {\\n               if(arr[i]>arr[i-1])\\n            {\\n                return dp[i][sign-60]=recurs(i+1,\\'<\\')+1;\\n            }\\n            else\\n            {\\n                return dp[i][sign-60]=0;\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    int maxTurbulenceSize(vector<int>& a) {\\n        arr=a;\\n        dp.resize(40002,vector<int>(3,-1));\\n      \\n           for(int i=1;i<a.size()+1;i++)\\n        {\\n              recurs(i,\\'<\\');\\n              recurs(i,\\'>\\');\\n           }\\n        int k=0;\\n        for(int i=0;i<a.size()+1;i++)\\n        {\\n              k=max(k,dp[i][0]);\\n              k=max(k,dp[i][1]);\\n              k=max(k,dp[i][2]);\\n        }\\n    \\n        return k+1;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C",
                    "Dynamic Programming"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    vector<int>arr;\\n    vector<vector<int>>dp;\\n    \\n    int recurs(int i,char sign)\\n    {\\n        if(i>=arr.size())\\n        {\\n         return 0;\\n        }\\n        \\n        if(dp[i][sign-60]!=-1)\\n        {\\n            return dp[i][sign-60];\\n        }\\n        \\n        \\n        if(sign==\\'<\\')\\n        {\\n            if(arr[i]<arr[i-1])\\n            {\\n                return dp[i][sign-60]=recurs(i+1,\\'>\\')+1;\\n            }\\n            else\\n            {\\n                return dp[i][sign-60]=0;\\n            }\\n        }\\n        if(sign==\\'>\\')\\n        {\\n               if(arr[i]>arr[i-1])\\n            {\\n                return dp[i][sign-60]=recurs(i+1,\\'<\\')+1;\\n            }\\n            else\\n            {\\n                return dp[i][sign-60]=0;\\n            }\\n            \\n        }\\n        return 0;\\n    }\\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    \\n    int maxTurbulenceSize(vector<int>& a) {\\n        arr=a;\\n        dp.resize(40002,vector<int>(3,-1));\\n      \\n           for(int i=1;i<a.size()+1;i++)\\n        {\\n              recurs(i,\\'<\\');\\n              recurs(i,\\'>\\');\\n           }\\n        int k=0;\\n        for(int i=0;i<a.size()+1;i++)\\n        {\\n              k=max(k,dp[i][0]);\\n              k=max(k,dp[i][1]);\\n              k=max(k,dp[i][2]);\\n        }\\n    \\n        return k+1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1237174,
                "title": "c-two-iterations-100-faster-o-1-space",
                "content": "\\tclass Solution {\\n\\tpublic:\\n\\t\\tint maxTurbulenceSize(vector<int>& arr) {\\n\\t\\t\\tconst int n = arr.size();\\n\\t\\t\\tint max_ans=1,f=0,ans=1;\\n\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tif(f==1){\\n\\t\\t\\t\\t\\tif(arr[i]>arr[i-1])ans++;\\n\\t\\t\\t\\t\\telse ans=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(f==0){\\n\\t\\t\\t\\t\\tif(arr[i]<arr[i-1])ans++;\\n\\t\\t\\t\\t\\telse ans=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(ans>max_ans)max_ans=ans;\\n\\t\\t\\t\\tf=1-f;\\n\\t\\t\\t}\\n\\t\\t\\tf=0;\\n\\t\\t\\tans=1;\\n\\t\\t\\tfor(int i=1;i<n;i++){\\n\\n\\t\\t\\t\\tif(f==0){\\n\\t\\t\\t\\t\\tif(arr[i]>arr[i-1])ans++;\\n\\t\\t\\t\\t\\telse ans=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\telse if(f==1){\\n\\t\\t\\t\\t\\tif(arr[i]<arr[i-1])ans++;\\n\\t\\t\\t\\t\\telse ans=1;\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tif(ans>max_ans)max_ans=ans;\\n\\t\\t\\t\\tf=1-f;\\n\\t\\t\\t}\\n\\t\\t\\treturn max_ans;\\n\\t\\t}\\n\\t};",
                "solutionTags": [],
                "code": "class Solution {\\n\\tpublic:\\n\\t\\tint maxTurbulenceSize(vector<int>& arr) {\\n\\t\\t\\tconst int n = arr.size();\\n\\t\\t\\tint max_ans=1,f=0,ans=1;\\n\\t\\t\\tfor(int i=1;i<n;i++){\\n\\t\\t\\t\\tif(f==1){\\n\\t\\t\\t\\t\\tif(arr[i]>arr[i-1])ans++;\\n\\t\\t\\t\\t\\telse ans=1;\\n\\t\\t\\t\\t}",
                "codeTag": "Java"
            },
            {
                "id": 1218747,
                "title": "c-solution",
                "content": "This approach uses a variable that keeps track of the difference and relationship between the previous two array items. If the array is size 1, we return a length of 1. Otherwise, the difference between previous pair is calculated. If the difference is not equal to zero, we check the current index and the previous index for turbulence and update the difference and maximum length accordingly. Else, turbulence is not satisfied, so the current length of the substring will be updated to 2 if the current and previous item are not equal or 1 if the items are equal. Continue these steps until the end of arr is reached. \\n```\\nint maxTurbulenceSize(vector<int>& arr) {\\n        int currLen = 1;\\n        int maxLen = 1;\\n        int diffPrev = 0;\\n        if(arr.size() == 1)\\n        {\\n            return currLen;\\n        }\\n        for(int i = 1; i < arr.size(); i++)\\n        {\\n            if((diffPrev > 0) && (arr[i] < arr[i-1]) || (diffPrev < 0) && (arr[i] > arr[i-1]))\\n            {\\n                currLen++;\\n                diffPrev = arr[i] - arr[i-1];\\n            }\\n            else\\n            {\\n                diffPrev = arr[i] - arr[i-1];\\n                currLen = (diffPrev != 0) ? 2 : 1;\\n            }\\n            maxLen = max(maxLen, currLen);\\n        }\\n        return maxLen;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxTurbulenceSize(vector<int>& arr) {\\n        int currLen = 1;\\n        int maxLen = 1;\\n        int diffPrev = 0;\\n        if(arr.size() == 1)\\n        {\\n            return currLen;\\n        }\\n        for(int i = 1; i < arr.size(); i++)\\n        {\\n            if((diffPrev > 0) && (arr[i] < arr[i-1]) || (diffPrev < 0) && (arr[i] > arr[i-1]))\\n            {\\n                currLen++;\\n                diffPrev = arr[i] - arr[i-1];\\n            }\\n            else\\n            {\\n                diffPrev = arr[i] - arr[i-1];\\n                currLen = (diffPrev != 0) ? 2 : 1;\\n            }\\n            maxLen = max(maxLen, currLen);\\n        }\\n        return maxLen;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1195277,
                "title": "easy-python-solution",
                "content": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        if len(arr) == 1:\\n            return 1\\n        prev = \"equal\"\\n        maxlength = 0\\n        curlength = 0\\n        for i in range(0, len(arr)-1):\\n            if prev == \\'dec\\' and arr[i] < arr[i+1]:\\n                curlength += 1\\n            elif prev == \\'inc\\' and arr[i] > arr[i+1]:\\n                curlength += 1\\n            elif arr[i] == arr[i+1]:\\n                curlength = 1\\n            else:\\n                curlength = 2\\n                \\n            maxlength = max(maxlength, curlength)\\n            \\n            if arr[i] < arr[i+1]:\\n                prev = \\'inc\\'\\n            elif arr[i] > arr[i+1]:\\n                prev = \\'dec\\'\\n            else:\\n                prev = \\'equal\\'\\n        return maxlength\\n       \\n            \\n```\\n",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        if len(arr) == 1:\\n            return 1\\n        prev = \"equal\"\\n        maxlength = 0\\n        curlength = 0\\n        for i in range(0, len(arr)-1):\\n            if prev == \\'dec\\' and arr[i] < arr[i+1]:\\n                curlength += 1\\n            elif prev == \\'inc\\' and arr[i] > arr[i+1]:\\n                curlength += 1\\n            elif arr[i] == arr[i+1]:\\n                curlength = 1\\n            else:\\n                curlength = 2\\n                \\n            maxlength = max(maxlength, curlength)\\n            \\n            if arr[i] < arr[i+1]:\\n                prev = \\'inc\\'\\n            elif arr[i] > arr[i+1]:\\n                prev = \\'dec\\'\\n            else:\\n                prev = \\'equal\\'\\n        return maxlength\\n       \\n            \\n```",
                "codeTag": "Java"
            },
            {
                "id": 1188924,
                "title": "dp-solution-with-sliding-windows-which-beats-99-11",
                "content": "\\nclass Solution {\\n\\npublic:\\n\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        ios_base::sync_with_stdio(false);\\n\\t\\t\\n        cin.tie(NULL);\\n        int n=arr.size();\\n        vector<int> dp(n);\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(arr[i]>arr[i+1])\\n                dp[i]=1;\\n            else if(arr[i]<arr[i+1])\\n                dp[i]=2;\\n            else\\n                dp[i]=0;\\n                \\n        }\\n        \\n        int i=0;\\n        int j=0;\\n        int ans=1;\\n        \\n        while(i<n-1){\\n            int flag=dp[i];\\n            int j=i+1;\\n            if(flag==0){\\n                i++;\\n                continue;\\n            }\\n            while(j<n-1){\\n                if(flag==1){\\n                    if(dp[j]==2){\\n                        flag=2;\\n                        j++;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                else if(flag==2){\\n                    if(dp[j]==1){\\n                        flag=1;\\n                        j++;\\n                    }\\n                    else{\\n                        break;\\n                    }\\n                }\\n                else\\n                    break;\\n            }\\n            ans=max(ans,j-i+1);\\n            \\n            i=j;\\n        }\\n        \\n        return ans;\\n    }\\n};",
                "solutionTags": [],
                "code": "class Solution {\\n\\npublic:\\n\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        ios_base::sync_with_stdio(false);\\n\\t\\t\\n        cin.tie(NULL);\\n        int n=arr.size();\\n        vector<int> dp(n);\\n        \\n        for(int i=0;i<n-1;i++){\\n            if(arr[i]>arr[i+1])\\n                dp[i]=1;\\n            else if(arr[i]<arr[i+1])\\n                dp[i]=2;\\n            else\\n                dp[i]=0;\\n                \\n        }",
                "codeTag": "Java"
            },
            {
                "id": 1123333,
                "title": "simple-c-solution",
                "content": "```\\nint maxTurbulenceSize(vector<int>& arr) {\\n        int len=arr.size();\\n        int incr=0, decr=0, incr1=0, decr1=0, cnt=0, maxCnt=1;\\n        if(len<2) { return len; }\\n        for(int i=0,j=1;j<len;i++,j++) {\\n            if(i==0 || (incr==0 && decr==0)) {\\n                if(arr[i] > arr[j]) {\\n                    incr=0;\\n                    decr=1;\\n                    cnt=2;\\n                } else if(arr[i] < arr[j]) {\\n                    incr=1;\\n                    decr=0;\\n                    cnt=2;\\n                } else {\\n                    incr=decr=0;\\n                    cnt=1;\\n                }\\n            } else {\\n                incr1=decr1=0;\\n                if(arr[i] > arr[j]) {\\n                    incr1=0;\\n                    decr1=1;\\n                } else if(arr[i] < arr[j]) {\\n                    incr1=1;\\n                    decr1=0;\\n                } else {\\n                    incr1=decr1=0;\\n                }\\n                if(incr!=incr1 && decr!=decr1) {\\n                    cnt++;\\n                } else {\\n                    cnt=2;\\n                }\\n                incr=incr1;\\n                decr=decr1;\\n            }\\n            maxCnt = max(maxCnt, cnt);\\n        }\\n        return maxCnt;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\nint maxTurbulenceSize(vector<int>& arr) {\\n        int len=arr.size();\\n        int incr=0, decr=0, incr1=0, decr1=0, cnt=0, maxCnt=1;\\n        if(len<2) { return len; }\\n        for(int i=0,j=1;j<len;i++,j++) {\\n            if(i==0 || (incr==0 && decr==0)) {\\n                if(arr[i] > arr[j]) {\\n                    incr=0;\\n                    decr=1;\\n                    cnt=2;\\n                } else if(arr[i] < arr[j]) {\\n                    incr=1;\\n                    decr=0;\\n                    cnt=2;\\n                } else {\\n                    incr=decr=0;\\n                    cnt=1;\\n                }\\n            } else {\\n                incr1=decr1=0;\\n                if(arr[i] > arr[j]) {\\n                    incr1=0;\\n                    decr1=1;\\n                } else if(arr[i] < arr[j]) {\\n                    incr1=1;\\n                    decr1=0;\\n                } else {\\n                    incr1=decr1=0;\\n                }\\n                if(incr!=incr1 && decr!=decr1) {\\n                    cnt++;\\n                } else {\\n                    cnt=2;\\n                }\\n                incr=incr1;\\n                decr=decr1;\\n            }\\n            maxCnt = max(maxCnt, cnt);\\n        }\\n        return maxCnt;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 1051799,
                "title": "c-sliding-window-concise-o-n-faster-than-90",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& a) {\\n        int msf = 1, ans = 1, len = a.size();\\n        for (int i=1; i<len; i++) {\\n            bool res = (i % 2 == 1) ? a[i-1] > a[i]: a[i-1] < a[i];\\n            msf = res ? msf + 1: 1;            \\n            ans = max(ans, msf);\\n        }\\n        \\n        msf = 1;\\n        for (int i=1; i<len; i++) {\\n            bool res = (i % 2 == 1) ? a[i-1] < a[i]: a[i-1] > a[i];\\n            msf = res ? msf + 1: 1; \\n            ans = max(ans, msf);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& a) {\\n        int msf = 1, ans = 1, len = a.size();\\n        for (int i=1; i<len; i++) {\\n            bool res = (i % 2 == 1) ? a[i-1] > a[i]: a[i-1] < a[i];\\n            msf = res ? msf + 1: 1;            \\n            ans = max(ans, msf);\\n        }\\n        \\n        msf = 1;\\n        for (int i=1; i<len; i++) {\\n            bool res = (i % 2 == 1) ? a[i-1] < a[i]: a[i-1] > a[i];\\n            msf = res ? msf + 1: 1; \\n            ans = max(ans, msf);\\n        }\\n        \\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1047428,
                "title": "simple-sign-check-in-single-loop-python-solution",
                "content": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, A):\\n        maxlength=1\\n        curlength=1\\n        flip= False\\n        for i in range(len(A)-1):\\n            if A[i]==A[i+1]:\\n                curlength=1\\n                continue\\n            if A[i]>A[i+1]:\\n                if flip:\\n                    curlength=2\\n                else:\\n                    curlength+=1\\n                flip=True\\n            if A[i]<A[i+1]:\\n                if flip:\\n                    curlength+=1\\n                else:\\n                    curlength=2\\n                flip=False\\n            maxlength=max(maxlength,curlength)\\n        return maxlength\\n```",
                "solutionTags": [
                    "Python",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, A):\\n        maxlength=1\\n        curlength=1\\n        flip= False\\n        for i in range(len(A)-1):\\n            if A[i]==A[i+1]:\\n                curlength=1\\n                continue\\n            if A[i]>A[i+1]:\\n                if flip:\\n                    curlength=2\\n                else:\\n                    curlength+=1\\n                flip=True\\n            if A[i]<A[i+1]:\\n                if flip:\\n                    curlength+=1\\n                else:\\n                    curlength=2\\n                flip=False\\n            maxlength=max(maxlength,curlength)\\n        return maxlength\\n```",
                "codeTag": "Java"
            },
            {
                "id": 1030695,
                "title": "java-93-fast",
                "content": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] arr) {\\n        if(arr.length<2)return arr.length;\\n      \\n        int ans = 1; boolean flag = arr[1]<arr[0];\\n        for(int left = 0, right = 1;right<arr.length;right++){\\n          int curr = arr[right], prev= arr[right-1];\\n          if(curr==prev){\\n            left=right;\\n            continue;\\n          }\\n          if(curr>prev == flag){\\n            left=right-1;\\n          }\\n          flag = curr>prev;\\n          ans = Math.max(ans, right-left+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] arr) {\\n        if(arr.length<2)return arr.length;\\n      \\n        int ans = 1; boolean flag = arr[1]<arr[0];\\n        for(int left = 0, right = 1;right<arr.length;right++){\\n          int curr = arr[right], prev= arr[right-1];\\n          if(curr==prev){\\n            left=right;\\n            continue;\\n          }\\n          if(curr>prev == flag){\\n            left=right-1;\\n          }\\n          flag = curr>prev;\\n          ans = Math.max(ans, right-left+1);\\n        }\\n        return ans;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 998819,
                "title": "concise-and-easy-c-solution-one-pass-constant-space",
                "content": "Define up and down for recording current turbulent lenght, and update the maximum lenghth while scanning.\\n\\nint maxTurbulenceSize(vector<int>& arr) \\n    {\\n        int res=1,up=1,down=1;\\n        for(int i=1;i<arr.size();i++)\\n        {\\n            if(arr[i]>arr[i-1])\\n                up=down+1,down=1;\\n            else if(arr[i]<arr[i-1])\\n                down=up+1,up=1;\\n            else\\n                up=1,down=1;\\n            res=max(res,max(up,down));\\n        }\\n        return res;\\n    }",
                "solutionTags": [],
                "code": "Define up and down for recording current turbulent lenght, and update the maximum lenghth while scanning.\\n\\nint maxTurbulenceSize(vector<int>& arr) \\n    {\\n        int res=1,up=1,down=1;\\n        for(int i=1;i<arr.size();i++)\\n        {\\n            if(arr[i]>arr[i-1])\\n                up=down+1,down=1;\\n            else if(arr[i]<arr[i-1])\\n                down=up+1,up=1;\\n            else\\n                up=1,down=1;\\n            res=max(res,max(up,down));\\n        }\\n        return res;\\n    }",
                "codeTag": "Unknown"
            },
            {
                "id": 960582,
                "title": "c-solution-beats-98",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        if(arr.size()<2)\\n            return arr.size();\\n        int result =0;\\n        int cnt = 1 ;\\n        int flag = 0;\\n        for(int i=1;i<arr.size();i++){\\n            if(arr[i-1]< arr[i] and flag != 1){ //cheking for incresing array\\n                cnt++;\\n                flag = 1;\\n            }else if(arr[i-1]>arr[i] and flag != -1){ // cheking for decresing array\\n                cnt++; flag = -1;\\n            }else if(arr[i-1]< arr[i] and flag == 1){ // if array is increaing with size > 2\\n                cnt =2;\\n            }else if(arr[i-1]>arr[i] and flag == -1){ // if array of size >2 deacresing continuously\\n                cnt =2;\\n            }else{\\n                cnt =1;\\n                flag=0;\\n            } //cout<<cnt<<\" \";\\n            result = max(cnt , result);\\n        } \\n        return result;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& arr) {\\n        if(arr.size()<2)\\n            return arr.size();\\n        int result =0;\\n        int cnt = 1 ;\\n        int flag = 0;\\n        for(int i=1;i<arr.size();i++){\\n            if(arr[i-1]< arr[i] and flag != 1){ //cheking for incresing array\\n                cnt++;\\n                flag = 1;\\n            }else if(arr[i-1]>arr[i] and flag != -1){ // cheking for decresing array\\n                cnt++; flag = -1;\\n            }else if(arr[i-1]< arr[i] and flag == 1){ // if array is increaing with size > 2\\n                cnt =2;\\n            }else if(arr[i-1]>arr[i] and flag == -1){ // if array of size >2 deacresing continuously\\n                cnt =2;\\n            }else{\\n                cnt =1;\\n                flag=0;\\n            } //cout<<cnt<<\" \";\\n            result = max(cnt , result);\\n        } \\n        return result;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 950741,
                "title": "python3-explanation-runtime-and-space-analysis-o-n-time-o-1-space",
                "content": "**Explanation**\\nWe start the first subarray on position `0` and expand it to the right as long as the condition given in the problem description is met. As soon as two adjacent elements violate the condition, a new subarray starts from the right element of both but the start is shifted to the right as long as two adjecent elements are equal. The process is repeated until all elements have been examined. The condition check is set to be `sign * arr[index] < sign * arr[index]` while the sign flips after every comparison. If `sign = -1`, the check will be equivalent to `(-1) * arr[index] < (-1) * arr[index + 1] |* (-1) <=> arr[index] > arr[index + 1]`. In the case of `sign = 1`, sign can be ignored such that the comparison is `arr[index] < arr[index + 1]`.\\n__________________________\\n**Runtime Complexity** \\n`O(n)` since each input element is examined once.\\n_________________________\\n**Space Complexity**\\n`O(1)`\\n________________________\\n**Python Implementation**\\n```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        max_length = 1\\n        index      = 0\\n        last_index = len(arr) - 1\\n        \\n        \\n        while ( index < last_index and last_index - index + 1 > max_length ):  \\n            if ( arr[index] != arr[index + 1] ):\\n                start_index = index\\n                sign        = -1 if ( arr[index] < arr[index + 1] ) else 1   \\n                index      += 1\\n\\n\\n                while ( index < last_index and sign * arr[index] < sign * arr[index + 1] ):\\n                    index += 1\\n                    sign  *= -1\\n\\n                max_length = max(max_length, index - start_index + 1)   \\n            else:\\n                index += 1\\n                \\n        return max_length\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, arr: List[int]) -> int:\\n        max_length = 1\\n        index      = 0\\n        last_index = len(arr) - 1\\n        \\n        \\n        while ( index < last_index and last_index - index + 1 > max_length ):  \\n            if ( arr[index] != arr[index + 1] ):\\n                start_index = index\\n                sign        = -1 if ( arr[index] < arr[index + 1] ) else 1   \\n                index      += 1\\n\\n\\n                while ( index < last_index and sign * arr[index] < sign * arr[index + 1] ):\\n                    index += 1\\n                    sign  *= -1\\n\\n                max_length = max(max_length, index - start_index + 1)   \\n            else:\\n                index += 1\\n                \\n        return max_length\\n```",
                "codeTag": "Java"
            },
            {
                "id": 925493,
                "title": "python-sliding-window-95",
                "content": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, A: List[int]):\\n        start = 0\\n        maxLen = 1\\n        opr = 0\\n        \\n        for end in range(1,len(A)):\\n            if A[end] > A[end-1]:\\n                if opr == -1 or opr == 0:\\n                    opr = 1\\n                    maxLen = max(maxLen, end - start +1)\\n                else:\\n                    start = end-1;\\n            elif A[end] < A[end - 1]:\\n                if opr == 1 or opr == 0:\\n                    opr = -1\\n                    maxLen = max(maxLen, end - start + 1)\\n                else:\\n                    start = end-1\\n            elif A[end] == A[end - 1]:\\n                opr = 0\\n                start = end\\n        \\n        return maxLen\\n```\\nReference: https://leetcode.com/problems/longest-turbulent-subarray/discuss/884651/Java-sliding-window-faster-than-100.00",
                "solutionTags": [
                    "Python3",
                    "Sliding Window"
                ],
                "code": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, A: List[int]):\\n        start = 0\\n        maxLen = 1\\n        opr = 0\\n        \\n        for end in range(1,len(A)):\\n            if A[end] > A[end-1]:\\n                if opr == -1 or opr == 0:\\n                    opr = 1\\n                    maxLen = max(maxLen, end - start +1)\\n                else:\\n                    start = end-1;\\n            elif A[end] < A[end - 1]:\\n                if opr == 1 or opr == 0:\\n                    opr = -1\\n                    maxLen = max(maxLen, end - start + 1)\\n                else:\\n                    start = end-1\\n            elif A[end] == A[end - 1]:\\n                opr = 0\\n                start = end\\n        \\n        return maxLen\\n```",
                "codeTag": "Java"
            },
            {
                "id": 904403,
                "title": "c-o-n-solution-with-constant-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& A) {\\n        int n = A.size();\\n        \\n        int dec = 1, inc = 1, res = 1, currDec, currInc;\\n        \\n        for(int i=1;i<n;i++){\\n            currDec = A[i] < A[i-1] ? inc + 1 : 1;\\n            currInc = A[i] > A[i-1] ? dec + 1 : 1;\\n            \\n            dec = currDec;\\n            inc = currInc;\\n            \\n            res = max({res, dec, inc});\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& A) {\\n        int n = A.size();\\n        \\n        int dec = 1, inc = 1, res = 1, currDec, currInc;\\n        \\n        for(int i=1;i<n;i++){\\n            currDec = A[i] < A[i-1] ? inc + 1 : 1;\\n            currInc = A[i] > A[i-1] ? dec + 1 : 1;\\n            \\n            dec = currDec;\\n            inc = currInc;\\n            \\n            res = max({res, dec, inc});\\n        }\\n        \\n        return res;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 888109,
                "title": "java-o-n",
                "content": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] A) {\\n        if (A == null || A.length == 0) return 0;\\n        int i = 0;\\n        int max = 1;\\n        for (int j = 1; j < A.length; j++) {\\n            if (j == A.length - 1 || \\n                Integer.compare(A[j], A[j - 1]) * Integer.compare(A[j], A[j + 1]) != 1) {\\n                if (A[j] != A[j - 1]) max = Integer.max(max, j - i + 1);\\n                i = j;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] A) {\\n        if (A == null || A.length == 0) return 0;\\n        int i = 0;\\n        int max = 1;\\n        for (int j = 1; j < A.length; j++) {\\n            if (j == A.length - 1 || \\n                Integer.compare(A[j], A[j - 1]) * Integer.compare(A[j], A[j + 1]) != 1) {\\n                if (A[j] != A[j - 1]) max = Integer.max(max, j - i + 1);\\n                i = j;\\n            }\\n        }\\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 857292,
                "title": "java-solution-using-kadane-s-algo-in-o-n-97-runtime",
                "content": "```\\n    public int maxTurbulenceSize(int[] A) {\\n        if(A.length==0) return 0;\\n        int max = 1;\\n        int curmax=1;\\n        boolean now = true;\\n        for(int i=1;i<A.length;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                if(A[i]<A[i-1]){\\n                    curmax = now ? ++curmax : 2;\\n                    now=true;\\n                    max = Math.max(curmax,max);\\n                }\\n                else if(A[i]>A[i-1])\\n                {\\n                    curmax = !now ? ++curmax : 2;\\n                    now = false;\\n                    max = Math.max(curmax,max);\\n                } \\n                else {\\n                    curmax=1;\\n                    continue;\\n                }\\n            }\\n            else {\\n                if(A[i]>A[i-1]){\\n                    curmax = now ? ++curmax : 2;\\n                    now=true;\\n                    max = Math.max(curmax,max);\\n                }\\n                else if(A[i]<A[i-1])\\n                {\\n                    curmax = !now ? ++curmax : 2;\\n                    now = false;\\n                    max = Math.max(curmax,max);\\n                } \\n                else {\\n                    curmax=1;\\n                    continue;\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        return max;\\n    }\\n}\\n```",
                "solutionTags": [
                    "Java"
                ],
                "code": "```\\n    public int maxTurbulenceSize(int[] A) {\\n        if(A.length==0) return 0;\\n        int max = 1;\\n        int curmax=1;\\n        boolean now = true;\\n        for(int i=1;i<A.length;i++)\\n        {\\n            if(i%2==0)\\n            {\\n                if(A[i]<A[i-1]){\\n                    curmax = now ? ++curmax : 2;\\n                    now=true;\\n                    max = Math.max(curmax,max);\\n                }\\n                else if(A[i]>A[i-1])\\n                {\\n                    curmax = !now ? ++curmax : 2;\\n                    now = false;\\n                    max = Math.max(curmax,max);\\n                } \\n                else {\\n                    curmax=1;\\n                    continue;\\n                }\\n            }\\n            else {\\n                if(A[i]>A[i-1]){\\n                    curmax = now ? ++curmax : 2;\\n                    now=true;\\n                    max = Math.max(curmax,max);\\n                }\\n                else if(A[i]<A[i-1])\\n                {\\n                    curmax = !now ? ++curmax : 2;\\n                    now = false;\\n                    max = Math.max(curmax,max);\\n                } \\n                else {\\n                    curmax=1;\\n                    continue;\\n                }\\n            }\\n        }\\n        \\n        \\n        \\n        return max;\\n    }\\n}\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 842477,
                "title": "cpp-easy-to-understand-clean-short-o-n-space-and-o-n-time",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& A) {\\n        int high = 1,low = 1;\\n        int ans = 1;\\n        for(int i=1;i<A.size();i++){\\n            if(A[i]>A[i-1]){\\n                high = 1+low;\\n                low = 1;\\n            }\\n            else if(A[i] == A[i-1])\\n                high = low = 1;\\n            else{\\n                low = 1+high;\\n                high = 1;\\n            }\\n            ans = max(ans,max(low,high));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++",
                    "C"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& A) {\\n        int high = 1,low = 1;\\n        int ans = 1;\\n        for(int i=1;i<A.size();i++){\\n            if(A[i]>A[i-1]){\\n                high = 1+low;\\n                low = 1;\\n            }\\n            else if(A[i] == A[i-1])\\n                high = low = 1;\\n            else{\\n                low = 1+high;\\n                high = 1;\\n            }\\n            ans = max(ans,max(low,high));\\n        }\\n        return ans;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 733707,
                "title": "python-dp-solution-with-explanation",
                "content": "```\\n#dp[i][0]-> represents max turbulent subarray  ending with > sign till index i\\n#dp[i][1]-> represent max turbulent subarray  ending with < sign till index i\\nclass Solution:\\n    def maxTurbulenceSize(self, A: List[int]) -> int: \\n        dp=[[1 for _ in range(2)] for _ in range(len(A))]\\n        res=1\\n        for i in range(1,len(A)):\\n            if A[i-1]<A[i]:\\n                dp[i][1]=dp[i-1][0]+1 #if previous sign was < then the next sign should be > and plus 1\\n            if A[i-1]>A[i]:\\n                dp[i][0]=dp[i-1][1]+1 ##if previous sign was > then the next sign should be < and plus 1\\n            res=max(res,dp[i][1],dp[i][0])\\n        return res\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n",
                "solutionTags": [],
                "code": "```\\n#dp[i][0]-> represents max turbulent subarray  ending with > sign till index i\\n#dp[i][1]-> represent max turbulent subarray  ending with < sign till index i\\nclass Solution:\\n    def maxTurbulenceSize(self, A: List[int]) -> int: \\n        dp=[[1 for _ in range(2)] for _ in range(len(A))]\\n        res=1\\n        for i in range(1,len(A)):\\n            if A[i-1]<A[i]:\\n                dp[i][1]=dp[i-1][0]+1 #if previous sign was < then the next sign should be > and plus 1\\n            if A[i-1]>A[i]:\\n                dp[i][0]=dp[i-1][1]+1 ##if previous sign was > then the next sign should be < and plus 1\\n            res=max(res,dp[i][1],dp[i][0])\\n        return res\\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n        \\n",
                "codeTag": "Java"
            },
            {
                "id": 685272,
                "title": "c-counter-check",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& A) {\\n        //if(A.size() <= 2) return A.size();\\n        //we define a ch function\\n        //cntr +1 : >\\n        //cntr -1 : <\\n        //cntr  0 : its either starting or equal no\\n        int n=A.size(),ans=0;\\n        \\n        //***********************************\\n        //  USING an alternating counter is really good technique for alternating sub array questions\\n        //***********************************\\n        for(auto i=0, cntr =0;i<n-1;cntr*=-1,i++)\\n        {\\n            if(A[i]>A[i+1]) cntr=cntr>0? cntr+1:1;\\n            \\n            else if(A[i]<A[i+1]) cntr=cntr<0? cntr-1:-1;\\n            \\n            else cntr=0; //if no are equal\\n            ans=max(abs(cntr),ans);\\n            //cout<<cntr<<\" \";\\n        }\\n        \\n        return ans+1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& A) {\\n        //if(A.size() <= 2) return A.size();\\n        //we define a ch function\\n        //cntr +1 : >\\n        //cntr -1 : <\\n        //cntr  0 : its either starting or equal no\\n        int n=A.size(),ans=0;\\n        \\n        //***********************************\\n        //  USING an alternating counter is really good technique for alternating sub array questions\\n        //***********************************\\n        for(auto i=0, cntr =0;i<n-1;cntr*=-1,i++)\\n        {\\n            if(A[i]>A[i+1]) cntr=cntr>0? cntr+1:1;\\n            \\n            else if(A[i]<A[i+1]) cntr=cntr<0? cntr-1:-1;\\n            \\n            else cntr=0; //if no are equal\\n            ans=max(abs(cntr),ans);\\n            //cout<<cntr<<\" \";\\n        }\\n        \\n        return ans+1;\\n    }\\n};\\n```",
                "codeTag": "C++"
            },
            {
                "id": 668693,
                "title": "java-clean-sliding-window-solution",
                "content": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] A) {\\n        int start = 0;\\n        int end = 1;\\n        int maxZigZagSize = 1;\\n\\n        while (end < A.length) {\\n            if (isZigZag(A, start, end)) {\\n                maxZigZagSize = Math.max(end - start + 1, maxZigZagSize);\\n                ++end;\\n                continue;\\n            }\\n\\n            if (A[end] == A[end - 1]) {\\n                start = end;\\n                end = end + 1;\\n                continue;\\n            }\\n\\n            start = end - 1;\\n            end = end + 1;\\n        }\\n\\n        return maxZigZagSize;\\n    }\\n\\n    private boolean isZigZag(int[] A, int start, int end) {\\n        if (A[start] == A[start + 1]) {\\n            return false;\\n        }\\n\\n        boolean increasing = A[start] < A[start + 1];\\n\\n        for (int i = start + 1; i <= end  - 1; ++i) {\\n            increasing = !increasing;\\n\\n            if ((increasing && A[i] >= A[i + 1]) || (!increasing && A[i] <= A[i + 1])) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] A) {\\n        int start = 0;\\n        int end = 1;\\n        int maxZigZagSize = 1;\\n\\n        while (end < A.length) {\\n            if (isZigZag(A, start, end)) {\\n                maxZigZagSize = Math.max(end - start + 1, maxZigZagSize);\\n                ++end;\\n                continue;\\n            }\\n\\n            if (A[end] == A[end - 1]) {\\n                start = end;\\n                end = end + 1;\\n                continue;\\n            }\\n\\n            start = end - 1;\\n            end = end + 1;\\n        }\\n\\n        return maxZigZagSize;\\n    }\\n\\n    private boolean isZigZag(int[] A, int start, int end) {\\n        if (A[start] == A[start + 1]) {\\n            return false;\\n        }\\n\\n        boolean increasing = A[start] < A[start + 1];\\n\\n        for (int i = start + 1; i <= end  - 1; ++i) {\\n            increasing = !increasing;\\n\\n            if ((increasing && A[i] >= A[i + 1]) || (!increasing && A[i] <= A[i + 1])) {\\n                return false;\\n            }\\n        }\\n\\n        return true;\\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 645963,
                "title": "java-sliding-window",
                "content": "This solution utilizes two pointers to keep track of the left and right of the sliding window. A boolean is also used to keep track of whether the next number should be less or greater than the previous. The algorithm will keep running until the right side of the window has not reached the end of the array. First, we will check if the next number is greater than the current right most number in the window. If the window is only 1 integer wide, OR it is larger than 2 integers but the next number is supposed to be greater, then we will set the boolean to true, meaning that the next number checked should be less now, and increment the right of the window, as well as set the max length accordingly. If the next number is less, we will do the same thing, but set the boolean to false instead since the next number should now be greater instead. If the numbers are equal, we will \"reset\" the window by setting the left side of the window equal to the right side, and incrementing the right side of the window to skip pass this road block, as the subarray can never contain two of the same number in a row to be turbulent. Finally, the else statement catches the condition where the next number does not follow the turbulent pattern, i.e. there were two numbers that were consecutively less than the previous. In this case, we will again reset the window, but one step back by setting the left-most pointer to be one less than the right-most pointer.\\n```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] A) {\\n        int i = 0;\\n        int j = 1;\\n        boolean checkingLess = false;\\n\\n        int max = 1;\\n        while(j < A.length){\\n            if(A[j] > A[j-1] && (!checkingLess || j - i < 2)){\\n                checkingLess = true;\\n                j++;\\n                max = Math.max(max, j-i);\\n            } else if (A[j] < A[j-1] && (checkingLess || j - i < 2)){\\n                checkingLess = false;\\n                j++;\\n                max = Math.max(max, j-i);\\n            } else if (A[j] == A[j-1]){\\n                i = j;\\n                j++;\\n            } else{\\n                i = j - 1;\\n\\n            }\\n        }\\n        return max;\\n        \\n    }\\n}\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\n    public int maxTurbulenceSize(int[] A) {\\n        int i = 0;\\n        int j = 1;\\n        boolean checkingLess = false;\\n\\n        int max = 1;\\n        while(j < A.length){\\n            if(A[j] > A[j-1] && (!checkingLess || j - i < 2)){\\n                checkingLess = true;\\n                j++;\\n                max = Math.max(max, j-i);\\n            } else if (A[j] < A[j-1] && (checkingLess || j - i < 2)){\\n                checkingLess = false;\\n                j++;\\n                max = Math.max(max, j-i);\\n            } else if (A[j] == A[j-1]){\\n                i = j;\\n                j++;\\n            } else{\\n                i = j - 1;\\n\\n            }\\n        }\\n        return max;\\n        \\n    }\\n}\\n```",
                "codeTag": "Java"
            },
            {
                "id": 584976,
                "title": "very-easy-java-solution-o-n-time-and-o-1-space-beats-100-memory",
                "content": "```\\npublic int maxTurbulenceSize(int[] A) {\\n        int n = A.length;\\n        if(n==1) return 1;\\n        int ans = 1,tmp=1;\\n        for(int i=1;i<n;i++) {\\n            //an element can either be in middle of turbulence or could\\'ve ended it\\n            //middle of turbulence if A<B>C (rise) or A>B<C (fall) where B is curr elt\\n            if(A[i-1]!=A[i]) tmp++;\\n            ans = Math.max(ans,tmp);\\n\\n\\t\\t\\t//current element is ending the turbulence\\n            if(i+1<n && !((A[i-1]<A[i] && A[i]>A[i+1]) || (A[i-1]>A[i] && A[i]<A[i+1]))) {\\n                tmp = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxTurbulenceSize(int[] A) {\\n        int n = A.length;\\n        if(n==1) return 1;\\n        int ans = 1,tmp=1;\\n        for(int i=1;i<n;i++) {\\n            //an element can either be in middle of turbulence or could\\'ve ended it\\n            //middle of turbulence if A<B>C (rise) or A>B<C (fall) where B is curr elt\\n            if(A[i-1]!=A[i]) tmp++;\\n            ans = Math.max(ans,tmp);\\n\\n\\t\\t\\t//current element is ending the turbulence\\n            if(i+1<n && !((A[i-1]<A[i] && A[i]>A[i+1]) || (A[i-1]>A[i] && A[i]<A[i+1]))) {\\n                tmp = 1;\\n            }\\n        }\\n        return ans;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 538094,
                "title": "javascript-dp-solution",
                "content": "Similar to the 376. Wiggle Subsequence.\\nThe difference between them is that in wiggle subsequence, if `nums[i] > nums[i - 1]` we just need to give the `down + 1` to `up` and the value `down` don\\'t need to update. It\\'s the same in `nums[i] < nums[i - 1]`. While in this problem, if `A[i] > A[i - 1]` we should not just give the `down + 1` to `up` but also need to  initialize the `down` value to `1` so that when next round `A[i + 1] > A[i]` the `down + 1` will be `1 + 1` which is `2`. It\\'s the problem that wanna us to do.\\n\\n```\\nvar maxTurbulenceSize = function(A) {\\n    let up = down = max =1\\n    for (let i = 1; i < A.length; i++) {\\n        if (A[i] < A[i - 1]) {\\n            down = up + 1\\n            up = 1\\n        } else if (A[i] > A[i - 1]) {\\n            up = down + 1\\n            down = 1\\n        } else {\\n            up = down = 1\\n        }\\n        max = Math.max(max, Math.max(down, up))\\n    }\\n    return max\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nvar maxTurbulenceSize = function(A) {\\n    let up = down = max =1\\n    for (let i = 1; i < A.length; i++) {\\n        if (A[i] < A[i - 1]) {\\n            down = up + 1\\n            up = 1\\n        } else if (A[i] > A[i - 1]) {\\n            up = down + 1\\n            down = 1\\n        } else {\\n            up = down = 1\\n        }\\n        max = Math.max(max, Math.max(down, up))\\n    }\\n    return max\\n};\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 461726,
                "title": "python3-solution-with-comments-o-n-single-pass-beats-85",
                "content": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, A: List[int]) -> int:\\n        # Trivial case\\n        if len(A) == 1: return 1\\n        \\n        # dp[i] is the maximum turbulent subarray ending at the i-th element.\\n        # By default, our maximum subarray is a single element\\n        dp = [1]*len(A)\\n        \\n        # By default, if the previous element does not equal the current element\\n        # we have achieved a maximum subarray of len==2\\n        dp[1] = 2 if A[1] != A[0] else 1\\n        \\n        # Keep track of if the last element was greater than or less than previous\\n        # element\\n        last_was_gt = A[1] > A[0]\\n        \\n        \\n        for i in range(2, len(A)):\\n            # If element is equal to previous element reset dp[i]\\n            if A[i] == A[i-1]:\\n                dp[i] = 1\\n                continue\\n            \\n            # if last element was greater than the previous, we need\\n            # the current element to be less than the previous. Vice versa\\n            if last_was_gt:\\n                dp[i] = dp[i-1]+1 if A[i] < A[i-1] else 2\\n            else:\\n                dp[i] = dp[i-1]+1 if A[i] > A[i-1] else 2\\n            \\n            last_was_gt = A[i] > A[i-1]\\n        \\n        return max(dp)",
                "solutionTags": [],
                "code": "```\\nclass Solution:\\n    def maxTurbulenceSize(self, A: List[int]) -> int:\\n        # Trivial case\\n        if len(A) == 1: return 1\\n        \\n        # dp[i] is the maximum turbulent subarray ending at the i-th element.\\n        # By default, our maximum subarray is a single element\\n        dp = [1]*len(A)\\n        \\n        # By default, if the previous element does not equal the current element\\n        # we have achieved a maximum subarray of len==2\\n        dp[1] = 2 if A[1] != A[0] else 1\\n        \\n        # Keep track of if the last element was greater than or less than previous\\n        # element\\n        last_was_gt = A[1] > A[0]\\n        \\n        \\n        for i in range(2, len(A)):\\n            # If element is equal to previous element reset dp[i]\\n            if A[i] == A[i-1]:\\n                dp[i] = 1\\n                continue\\n            \\n            # if last element was greater than the previous, we need\\n            # the current element to be less than the previous. Vice versa\\n            if last_was_gt:\\n                dp[i] = dp[i-1]+1 if A[i] < A[i-1] else 2\\n            else:\\n                dp[i] = dp[i-1]+1 if A[i] > A[i-1] else 2\\n            \\n            last_was_gt = A[i] > A[i-1]\\n        \\n        return max(dp)",
                "codeTag": "Java"
            },
            {
                "id": 456626,
                "title": "c-solution",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& A) {\\n        // trival case\\n        if (A.size() <= 1) return A.size(); \\n        // loop\\n        int prevsign = 0;\\n        int cur = 1;\\n        int rst = 1;\\n        int i = 1;\\n        while (i < A.size()) {\\n            if (A[i] > A[i-1]) {\\n                cur = (prevsign == -1 ? cur + 1 : 2);\\n                prevsign = 1;\\n            }\\n            else if (A[i] < A[i-1]) {\\n                cur = (prevsign == 1 ? cur + 1 : 2);\\n                prevsign = -1;\\n            }\\n            else {\\n                cur = 1;\\n                prevsign = 0;\\n            }\\n            rst = max(rst, cur);\\n            i += 1;\\n        }\\n        return rst;\\n    }\\n};\\n```",
                "solutionTags": [
                    "C++"
                ],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& A) {\\n        // trival case\\n        if (A.size() <= 1) return A.size(); \\n        // loop\\n        int prevsign = 0;\\n        int cur = 1;\\n        int rst = 1;\\n        int i = 1;\\n        while (i < A.size()) {\\n            if (A[i] > A[i-1]) {\\n                cur = (prevsign == -1 ? cur + 1 : 2);\\n                prevsign = 1;\\n            }\\n            else if (A[i] < A[i-1]) {\\n                cur = (prevsign == 1 ? cur + 1 : 2);\\n                prevsign = -1;\\n            }\\n            else {\\n                cur = 1;\\n                prevsign = 0;\\n            }\\n            rst = max(rst, cur);\\n            i += 1;\\n        }\\n        return rst;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 445145,
                "title": "c-o-n-time-and-o-1-space",
                "content": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& A) {\\n        int n = A.size();\\n        if(n == 1) return 1;\\n        if(n == 2) return (A[0] == A[1]) ? 1 : 2;\\n        int current = 1, maxC = 1;\\n        bool allEqual = true;\\n        for(int i=0; i < n-2; ++i) {\\n            if(A[i] == A[i+1] && A[i+1] == A[i+2]) {\\n                continue;\\n            }\\n            else if( ((long)(A[i]-A[i+1])) * (A[i+1]-A[i+2]) < 0) {\\n                ++current;\\n                maxC = max(current, maxC);\\n            } else {\\n                current = 1;\\n            }\\n            allEqual = false;\\n        }\\n        return allEqual? 1: maxC + 1;\\n    }\\n};\\n```",
                "solutionTags": [],
                "code": "```\\nclass Solution {\\npublic:\\n    int maxTurbulenceSize(vector<int>& A) {\\n        int n = A.size();\\n        if(n == 1) return 1;\\n        if(n == 2) return (A[0] == A[1]) ? 1 : 2;\\n        int current = 1, maxC = 1;\\n        bool allEqual = true;\\n        for(int i=0; i < n-2; ++i) {\\n            if(A[i] == A[i+1] && A[i+1] == A[i+2]) {\\n                continue;\\n            }\\n            else if( ((long)(A[i]-A[i+1])) * (A[i+1]-A[i+2]) < 0) {\\n                ++current;\\n                maxC = max(current, maxC);\\n            } else {\\n                current = 1;\\n            }\\n            allEqual = false;\\n        }\\n        return allEqual? 1: maxC + 1;\\n    }\\n};\\n```",
                "codeTag": "Java"
            },
            {
                "id": 404587,
                "title": "from-generic-dp-solution-o-n-time-o-n-space-to-optimized-solution-with-o-1-space",
                "content": "1) Look at the problem to figure out the invariant/the state you need to infer a next step from previous calculations.\\n\\nIn this case you can calculate the longest sequence up to point i+1 when you have the information about the longest sequence ending in i where A[i] < A[i-1] and the longest sequence ending in i where A[i] > A[i-1].\\n\\nYou can then calculate the two longest sequences ending in A[i+1] where the number is bigger and smaller than A[i]\\n\\n//sequence ending in i where A[i] > A[i-1]\\ndp_big[i] = A[i] > A[i-1] ? 1 + dp_small[i-1] : 1;\\ndp_small[i] = A[i] > A[i-1] ? 1 + dp_big[i-1] : 1;\\n\\nThe biggest sequence observed is than the biggest entry from dp_big and dp_small:\\n\\n        //Accepted faster than 26%\\t\\n\\t\\tpublic int maxTurbulenceSize(int[] A) {\\n\\t\\t\\tint[] dp_small = new int[A.length];\\n\\t\\t\\tint[] dp_big = new int[A.length];\\n\\n\\t\\t\\tdp_small[0] = 1;\\n\\t\\t\\tdp_big[0] = 1;\\n\\t\\t\\tint max = 1;\\n\\n\\t\\t\\tfor (int i = 1; i < A.length; i++) {\\n\\t\\t\\t\\tdp_small[i] = A[i] < A[i-1] ? 1 + dp_big[i-1] : 1;\\n\\t\\t\\t\\tdp_big[i] = A[i] > A[i-1] ? 1 + dp_small[i-1] : 1;\\n\\t\\t\\t\\tmax = Math.max(dp_small[i], Math.max(dp_big[i], max));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\t\\t\\n2) Observe that you only use dp_small[i-1] and dp_big[i-1] to calculate dp_small[i]/dp_big[i]\\n--> remove dp array und use state variables\\n\\n\\t\\t// faster than 59%\\n\\t\\tpublic int maxTurbulenceSize(int[] A) {\\n\\t\\t\\tint size_small = 1;\\n\\t\\t\\tint size_big = 1;\\n\\t\\t\\tint max = 1;\\n\\n\\t\\t\\tfor (int i = 1; i < A.length; i++) {\\n\\t\\t\\t\\tint new_size_small = A[i] < A[i-1] ? 1 + size_big : 1;\\n\\t\\t\\t\\tsize_big = A[i] > A[i-1] ? 1 + size_small : 1;\\n\\t\\t\\t\\tsize_small = new_size_small;\\n\\t\\t\\t\\tmax = Math.max(max, Math.max(size_small, size_big));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\n3) Now it gets a little hairy. You can see that one of size_small and size_big is always 1, which tells you that you only need the one that is not 1 plus the information whether the next number has to be bigger or not. Basically the insight is that at each position i there can only be one longest alternating sequence that ends. Either one that has a higher number A[i] than A[i-1] or one that has a lower one and that is the reason for only needing to track the length of one sequence. \\n\\n\\t\\t\\t//Better than 93.8%\\n\\t\\t\\tpublic int maxTurbulenceSize(int[] A) {\\n\\t\\t\\t\\tif (A.length <= 1) return A.length;\\n\\n\\t\\t\\t\\tint current_size = 1;\\n\\t\\t\\t\\tboolean bigger = A[1] > A[0];//force true\\n\\t\\t\\t\\tint max = 1;\\n\\n\\t\\t\\t\\tfor (int i = 1; i < A.length; i++) {\\n\\t\\t\\t\\t\\tif ((bigger && A[i] > A[i-1]) || (!bigger && A[i] < A[i-1])) {\\n\\t\\t\\t\\t\\t\\tcurrent_size++;\\n\\t\\t\\t\\t\\t\\tbigger = !bigger;\\n\\t\\t\\t\\t\\t} else if (A[i] != A[i-1]) {\\n\\t\\t\\t\\t\\t\\tcurrent_size = 2;\\n\\t\\t\\t\\t\\t\\tbigger = !(A[i] > A[i-1]);//could be deleted\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcurrent_size = 1;\\n\\t\\t\\t\\t\\t\\tif (i+1 < A.length)\\n\\t\\t\\t\\t\\t\\t\\tbigger = A[i+1] > A[i];//force true\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmax = Math.max(max, current_size);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn max;\\n\\t\\t\\t}\\n\\nHope this helps. I wrote the last code first, but I think it is helpful to know how to derive this from a generic dp solution in case one does not notice what a more optimized solution would be right away.\\n",
                "solutionTags": [
                    "Dynamic Programming"
                ],
                "code": "1) Look at the problem to figure out the invariant/the state you need to infer a next step from previous calculations.\\n\\nIn this case you can calculate the longest sequence up to point i+1 when you have the information about the longest sequence ending in i where A[i] < A[i-1] and the longest sequence ending in i where A[i] > A[i-1].\\n\\nYou can then calculate the two longest sequences ending in A[i+1] where the number is bigger and smaller than A[i]\\n\\n//sequence ending in i where A[i] > A[i-1]\\ndp_big[i] = A[i] > A[i-1] ? 1 + dp_small[i-1] : 1;\\ndp_small[i] = A[i] > A[i-1] ? 1 + dp_big[i-1] : 1;\\n\\nThe biggest sequence observed is than the biggest entry from dp_big and dp_small:\\n\\n        //Accepted faster than 26%\\t\\n\\t\\tpublic int maxTurbulenceSize(int[] A) {\\n\\t\\t\\tint[] dp_small = new int[A.length];\\n\\t\\t\\tint[] dp_big = new int[A.length];\\n\\n\\t\\t\\tdp_small[0] = 1;\\n\\t\\t\\tdp_big[0] = 1;\\n\\t\\t\\tint max = 1;\\n\\n\\t\\t\\tfor (int i = 1; i < A.length; i++) {\\n\\t\\t\\t\\tdp_small[i] = A[i] < A[i-1] ? 1 + dp_big[i-1] : 1;\\n\\t\\t\\t\\tdp_big[i] = A[i] > A[i-1] ? 1 + dp_small[i-1] : 1;\\n\\t\\t\\t\\tmax = Math.max(dp_small[i], Math.max(dp_big[i], max));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\t\\t\\n2) Observe that you only use dp_small[i-1] and dp_big[i-1] to calculate dp_small[i]/dp_big[i]\\n--> remove dp array und use state variables\\n\\n\\t\\t// faster than 59%\\n\\t\\tpublic int maxTurbulenceSize(int[] A) {\\n\\t\\t\\tint size_small = 1;\\n\\t\\t\\tint size_big = 1;\\n\\t\\t\\tint max = 1;\\n\\n\\t\\t\\tfor (int i = 1; i < A.length; i++) {\\n\\t\\t\\t\\tint new_size_small = A[i] < A[i-1] ? 1 + size_big : 1;\\n\\t\\t\\t\\tsize_big = A[i] > A[i-1] ? 1 + size_small : 1;\\n\\t\\t\\t\\tsize_small = new_size_small;\\n\\t\\t\\t\\tmax = Math.max(max, Math.max(size_small, size_big));\\n\\t\\t\\t}\\n\\n\\t\\t\\treturn max;\\n\\t\\t}\\n\\n3) Now it gets a little hairy. You can see that one of size_small and size_big is always 1, which tells you that you only need the one that is not 1 plus the information whether the next number has to be bigger or not. Basically the insight is that at each position i there can only be one longest alternating sequence that ends. Either one that has a higher number A[i] than A[i-1] or one that has a lower one and that is the reason for only needing to track the length of one sequence. \\n\\n\\t\\t\\t//Better than 93.8%\\n\\t\\t\\tpublic int maxTurbulenceSize(int[] A) {\\n\\t\\t\\t\\tif (A.length <= 1) return A.length;\\n\\n\\t\\t\\t\\tint current_size = 1;\\n\\t\\t\\t\\tboolean bigger = A[1] > A[0];//force true\\n\\t\\t\\t\\tint max = 1;\\n\\n\\t\\t\\t\\tfor (int i = 1; i < A.length; i++) {\\n\\t\\t\\t\\t\\tif ((bigger && A[i] > A[i-1]) || (!bigger && A[i] < A[i-1])) {\\n\\t\\t\\t\\t\\t\\tcurrent_size++;\\n\\t\\t\\t\\t\\t\\tbigger = !bigger;\\n\\t\\t\\t\\t\\t} else if (A[i] != A[i-1]) {\\n\\t\\t\\t\\t\\t\\tcurrent_size = 2;\\n\\t\\t\\t\\t\\t\\tbigger = !(A[i] > A[i-1]);//could be deleted\\n\\t\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\t\\tcurrent_size = 1;\\n\\t\\t\\t\\t\\t\\tif (i+1 < A.length)\\n\\t\\t\\t\\t\\t\\t\\tbigger = A[i+1] > A[i];//force true\\n\\t\\t\\t\\t\\t}\\n\\t\\t\\t\\t\\tmax = Math.max(max, current_size);\\n\\t\\t\\t\\t}\\n\\n\\t\\t\\t\\treturn max;\\n\\t\\t\\t}\\n\\nHope this helps. I wrote the last code first, but I think it is helpful to know how to derive this from a generic dp solution in case one does not notice what a more optimized solution would be right away.\\n",
                "codeTag": "Unknown"
            },
            {
                "id": 394473,
                "title": "sliding-windows-one-pass-o-1-space",
                "content": "```\\n    bool isPosL(vector<int>&arr, int ind, int low)\\n    {\\n        bool res = true;\\n        if(ind-2 >= low)\\n        {\\n            return (arr[ind-1] > arr[ind] && arr[ind-1] > arr[ind-2]) ||(arr[ind-1] < arr[ind] && arr[ind-1] < arr[ind-2]);\\n        }\\n        else\\n        {\\n            return ind>low ? arr[ind] != arr[ind-1] : true;\\n        }\\n        return res;\\n    }\\n\\t\\n    int maxTurbulenceSize(vector<int>& A) {\\n        if(A.size() == 0 || A.size() == 1)\\n            return A.size();\\n        int i=0,j=0;\\n        int len = 1;\\n        while(j<A.size())\\n        {\\n            while(j<A.size() && isPosL(A,j,i))\\n            {\\n                len = std::max(len,j-i+1);\\n                j++;\\n            }\\n            if(i!=j-1)\\n                i = j-1;\\n            else\\n                i = j;\\n        }\\n        return len;\\n    }\\n```",
                "solutionTags": [
                    "C"
                ],
                "code": "```\\n    bool isPosL(vector<int>&arr, int ind, int low)\\n    {\\n        bool res = true;\\n        if(ind-2 >= low)\\n        {\\n            return (arr[ind-1] > arr[ind] && arr[ind-1] > arr[ind-2]) ||(arr[ind-1] < arr[ind] && arr[ind-1] < arr[ind-2]);\\n        }\\n        else\\n        {\\n            return ind>low ? arr[ind] != arr[ind-1] : true;\\n        }\\n        return res;\\n    }\\n\\t\\n    int maxTurbulenceSize(vector<int>& A) {\\n        if(A.size() == 0 || A.size() == 1)\\n            return A.size();\\n        int i=0,j=0;\\n        int len = 1;\\n        while(j<A.size())\\n        {\\n            while(j<A.size() && isPosL(A,j,i))\\n            {\\n                len = std::max(len,j-i+1);\\n                j++;\\n            }\\n            if(i!=j-1)\\n                i = j-1;\\n            else\\n                i = j;\\n        }\\n        return len;\\n    }\\n```",
                "codeTag": "Unknown"
            },
            {
                "id": 389122,
                "title": "python-o-n",
                "content": "We can change the original array A to a new array:\\nSuppose we have two consecutive numbers A[i-1], A[i].\\nif A[i]==A[i-1], we get 0.\\nIf A[i]>A[i-1]: we get 1.\\nif A[i]<A[i-1], we get -1. \\nThen a new array named res will contains 0, -1 or 1.\\nWe can change the problem to caculate the maximum valid subarray. A subarray is valid if 1)it does not have 0.   2) any two consecutive  numbers of this subarray are not the same.  \\nUsing one pass to count the length of all valid subarrays and \\'the maximum length +1\\' will be the final res.\\n```python\\nclass Solution:\\n    def maxTurbulenceSize(self, A: List[int]) -> int:\\n        # two cases: len(A)==1 or A only has one element such as [100, 100, 100]\\n        if len(set(A))==1:return 1\\n        res = []\\n        for i in range(1, len(A)):\\n            if A[i]>A[i-1]:\\n                res.append(1)\\n            elif A[i]==A[i-1]:\\n                res.append(0)\\n            else:\\n                res.append(-1)\\n        # res will be something like [0, -1, 1, -1, 1, 1]. Caculate the maximum valid subarray. A subarray is valid if 1)it does not have 0. 2) every neighbors of this subarray re not the same.  Using one pass to count the length of all valid subarrays and the maximum will be the final res\\n        fin_res = [0]\\n        for i in range(1, len(res)):\\n            if res[i]!=res[i-1] and res[i]!=0 and res[i-1]!=0:\\n                fin_res.append(fin_res[-1]+1)\\n            else:\\n                fin_res.append(0)\\n        # max(fin_res)+1 is the maximum of the subarray. Add another one, as these 1 and -1 connect one more element.\\n        return max(fin_res)+2\\n```",
                "solutionTags": [],
                "code": "```python\\nclass Solution:\\n    def maxTurbulenceSize(self, A: List[int]) -> int:\\n        # two cases: len(A)==1 or A only has one element such as [100, 100, 100]\\n        if len(set(A))==1:return 1\\n        res = []\\n        for i in range(1, len(A)):\\n            if A[i]>A[i-1]:\\n                res.append(1)\\n            elif A[i]==A[i-1]:\\n                res.append(0)\\n            else:\\n                res.append(-1)\\n        # res will be something like [0, -1, 1, -1, 1, 1]. Caculate the maximum valid subarray. A subarray is valid if 1)it does not have 0. 2) every neighbors of this subarray re not the same.  Using one pass to count the length of all valid subarrays and the maximum will be the final res\\n        fin_res = [0]\\n        for i in range(1, len(res)):\\n            if res[i]!=res[i-1] and res[i]!=0 and res[i-1]!=0:\\n                fin_res.append(fin_res[-1]+1)\\n            else:\\n                fin_res.append(0)\\n        # max(fin_res)+1 is the maximum of the subarray. Add another one, as these 1 and -1 connect one more element.\\n        return max(fin_res)+2\\n```",
                "codeTag": "Java"
            },
            {
                "id": 368599,
                "title": "java-5ms-dp",
                "content": "2 arrays dp\\nup[i] means the longest turbulent subarray length that ends at i-th num , and A[i] is > A[i-1];\\nin another way , \\ndown[i] means the longest turbulent subarray length that ends at i-th num , and A[i] is < A[i-1];\\n\\nObviously , when A[i]>A[i-1] , up[i]=1+down[i-1]   , or when A[i]<A[i-1] , down[i]=1+up[i-1].\\n\\nComplexity is O(n)\\n\\n```\\npublic int maxTurbulenceSize(int[] A) {\\n        if(A.length<2){\\n            return A.length;\\n        }   \\n        \\n        int[] up = new int[A.length];\\n        int[] down = new int[A.length];\\n        int result = 1;\\n        up[0]=1;\\n        down[0]=1;\\n        for(int i = 1;i<A.length;i++){\\n            if(A[i]>A[i-1]){\\n                up[i]=down[i-1]+1;\\n                down[i]=1;\\n                result = Math.max(result,up[i]);\\n            }else if(A[i]<A[i-1]){\\n                down[i]=up[i-1]+1;\\n                up[i]=1;\\n                result = Math.max(result,down[i]);\\n            }else{\\n                up[i]=1;\\n                down[i]=1;\\n            }\\n            \\n            \\n        }\\n        return result;\\n    }\\n```",
                "solutionTags": [],
                "code": "```\\npublic int maxTurbulenceSize(int[] A) {\\n        if(A.length<2){\\n            return A.length;\\n        }   \\n        \\n        int[] up = new int[A.length];\\n        int[] down = new int[A.length];\\n        int result = 1;\\n        up[0]=1;\\n        down[0]=1;\\n        for(int i = 1;i<A.length;i++){\\n            if(A[i]>A[i-1]){\\n                up[i]=down[i-1]+1;\\n                down[i]=1;\\n                result = Math.max(result,up[i]);\\n            }else if(A[i]<A[i-1]){\\n                down[i]=up[i-1]+1;\\n                up[i]=1;\\n                result = Math.max(result,down[i]);\\n            }else{\\n                up[i]=1;\\n                down[i]=1;\\n            }\\n            \\n            \\n        }\\n        return result;\\n    }\\n```",
                "codeTag": "Unknown"
            }
        ],
        "discussions": [
            {
                "id": 1575257,
                "content": [
                    {
                        "username": "amritha_patil",
                        "content": "For the input : [4,8,12,16],\\nthe expected output is 2. Can anyone explain why is that so. Shouldn\\'t the output be 1 as the array is in ascending order."
                    },
                    {
                        "username": "haridavinci",
                        "content": "Good question..In [4,8] the sign change is valid becuse the first part of definition still holds! Idea is just to track sign changes and the longest one is the result ..no need of complicating even odd cases explicitly"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "[@doublegthe7th](/doublegthe7th) i didn\\'t understand what you mean by that :D "
                    },
                    {
                        "username": "doublegthe7th",
                        "content": "Consider [4,8]. Since 4 < 8, the sign does flip with each comparsion (aka all 0 times) so it\\'s true"
                    },
                    {
                        "username": "nylime",
                        "content": "The sliding window algorithm can be used to approach this solution, in which two pointers are used to keep track of the start and end of a window. In this method, the window should only keep valid a valid subarray (in which the subarray is turbulent).\\n\\nFirst, the case in which the array has only 0 or 1 element can be taken care of.\\n\\nThen, the window of the array can start with the first two elements.\\n- If the two consecutive elements are equal, the window can be readjusted so that the second repetitive element is the start of the window.\\n- Otherwise, we can include the third element to the subarray:\\n   - If the first element is less than the second and the second element is less than the third, the start of the window can be readjusted to point to the third element, to represent the start of a new subarray. Same goes for if the first element is greater than the second and the second element is greater than the third.\\n   - If the second element is less than the second and the second element is greater than the third, the maximum length of a turbulent subarray can be updated. Same goes for if the first element is greater than the second and the second element is less than the third.\\n\\nIn summary, only the last 3 elements within the window need to be analyzed for their sign relationships: the third to last must be compared to the second to last in order to determine what sign to expect for the second to last compared to the very last. This process can be repeated until the window reaches the end of the array."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/01/21/Leetcode-978-Longest-Turbulent-Subarray/\\n\\nHope helpful!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "so i have doubt...can we do it  in finding LCS dp problem way where we keep two pointers i and j and can do i-1, j + 1 in recursive calls?"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The example 2 expected output is not consistent with the explanation of example 1"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "We use the counter (cnt) to track subarray size. Our counter is positive if we expect \\'>\\', and \\'<\\' otherwise. Obviously, for each turn we flip the sign.\\n\\nIf the comparison matches the counter sign (e.g. A[i] > A[i + 1] and cnt > 0 ), we increment (or decrement the negative) counter. Otherwise, we reset the counter to 1 (or -1). One edge case here is when two numbers are equal. We set the counter to zero in this case."
                    }
                ]
            },
            {
                "id": 1695732,
                "content": [
                    {
                        "username": "amritha_patil",
                        "content": "For the input : [4,8,12,16],\\nthe expected output is 2. Can anyone explain why is that so. Shouldn\\'t the output be 1 as the array is in ascending order."
                    },
                    {
                        "username": "haridavinci",
                        "content": "Good question..In [4,8] the sign change is valid becuse the first part of definition still holds! Idea is just to track sign changes and the longest one is the result ..no need of complicating even odd cases explicitly"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "[@doublegthe7th](/doublegthe7th) i didn\\'t understand what you mean by that :D "
                    },
                    {
                        "username": "doublegthe7th",
                        "content": "Consider [4,8]. Since 4 < 8, the sign does flip with each comparsion (aka all 0 times) so it\\'s true"
                    },
                    {
                        "username": "nylime",
                        "content": "The sliding window algorithm can be used to approach this solution, in which two pointers are used to keep track of the start and end of a window. In this method, the window should only keep valid a valid subarray (in which the subarray is turbulent).\\n\\nFirst, the case in which the array has only 0 or 1 element can be taken care of.\\n\\nThen, the window of the array can start with the first two elements.\\n- If the two consecutive elements are equal, the window can be readjusted so that the second repetitive element is the start of the window.\\n- Otherwise, we can include the third element to the subarray:\\n   - If the first element is less than the second and the second element is less than the third, the start of the window can be readjusted to point to the third element, to represent the start of a new subarray. Same goes for if the first element is greater than the second and the second element is greater than the third.\\n   - If the second element is less than the second and the second element is greater than the third, the maximum length of a turbulent subarray can be updated. Same goes for if the first element is greater than the second and the second element is less than the third.\\n\\nIn summary, only the last 3 elements within the window need to be analyzed for their sign relationships: the third to last must be compared to the second to last in order to determine what sign to expect for the second to last compared to the very last. This process can be repeated until the window reaches the end of the array."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/01/21/Leetcode-978-Longest-Turbulent-Subarray/\\n\\nHope helpful!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "so i have doubt...can we do it  in finding LCS dp problem way where we keep two pointers i and j and can do i-1, j + 1 in recursive calls?"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The example 2 expected output is not consistent with the explanation of example 1"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "We use the counter (cnt) to track subarray size. Our counter is positive if we expect \\'>\\', and \\'<\\' otherwise. Obviously, for each turn we flip the sign.\\n\\nIf the comparison matches the counter sign (e.g. A[i] > A[i + 1] and cnt > 0 ), we increment (or decrement the negative) counter. Otherwise, we reset the counter to 1 (or -1). One edge case here is when two numbers are equal. We set the counter to zero in this case."
                    }
                ]
            },
            {
                "id": 1569409,
                "content": [
                    {
                        "username": "amritha_patil",
                        "content": "For the input : [4,8,12,16],\\nthe expected output is 2. Can anyone explain why is that so. Shouldn\\'t the output be 1 as the array is in ascending order."
                    },
                    {
                        "username": "haridavinci",
                        "content": "Good question..In [4,8] the sign change is valid becuse the first part of definition still holds! Idea is just to track sign changes and the longest one is the result ..no need of complicating even odd cases explicitly"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "[@doublegthe7th](/doublegthe7th) i didn\\'t understand what you mean by that :D "
                    },
                    {
                        "username": "doublegthe7th",
                        "content": "Consider [4,8]. Since 4 < 8, the sign does flip with each comparsion (aka all 0 times) so it\\'s true"
                    },
                    {
                        "username": "nylime",
                        "content": "The sliding window algorithm can be used to approach this solution, in which two pointers are used to keep track of the start and end of a window. In this method, the window should only keep valid a valid subarray (in which the subarray is turbulent).\\n\\nFirst, the case in which the array has only 0 or 1 element can be taken care of.\\n\\nThen, the window of the array can start with the first two elements.\\n- If the two consecutive elements are equal, the window can be readjusted so that the second repetitive element is the start of the window.\\n- Otherwise, we can include the third element to the subarray:\\n   - If the first element is less than the second and the second element is less than the third, the start of the window can be readjusted to point to the third element, to represent the start of a new subarray. Same goes for if the first element is greater than the second and the second element is greater than the third.\\n   - If the second element is less than the second and the second element is greater than the third, the maximum length of a turbulent subarray can be updated. Same goes for if the first element is greater than the second and the second element is less than the third.\\n\\nIn summary, only the last 3 elements within the window need to be analyzed for their sign relationships: the third to last must be compared to the second to last in order to determine what sign to expect for the second to last compared to the very last. This process can be repeated until the window reaches the end of the array."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/01/21/Leetcode-978-Longest-Turbulent-Subarray/\\n\\nHope helpful!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "so i have doubt...can we do it  in finding LCS dp problem way where we keep two pointers i and j and can do i-1, j + 1 in recursive calls?"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The example 2 expected output is not consistent with the explanation of example 1"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "We use the counter (cnt) to track subarray size. Our counter is positive if we expect \\'>\\', and \\'<\\' otherwise. Obviously, for each turn we flip the sign.\\n\\nIf the comparison matches the counter sign (e.g. A[i] > A[i + 1] and cnt > 0 ), we increment (or decrement the negative) counter. Otherwise, we reset the counter to 1 (or -1). One edge case here is when two numbers are equal. We set the counter to zero in this case."
                    }
                ]
            },
            {
                "id": 1964777,
                "content": [
                    {
                        "username": "amritha_patil",
                        "content": "For the input : [4,8,12,16],\\nthe expected output is 2. Can anyone explain why is that so. Shouldn\\'t the output be 1 as the array is in ascending order."
                    },
                    {
                        "username": "haridavinci",
                        "content": "Good question..In [4,8] the sign change is valid becuse the first part of definition still holds! Idea is just to track sign changes and the longest one is the result ..no need of complicating even odd cases explicitly"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "[@doublegthe7th](/doublegthe7th) i didn\\'t understand what you mean by that :D "
                    },
                    {
                        "username": "doublegthe7th",
                        "content": "Consider [4,8]. Since 4 < 8, the sign does flip with each comparsion (aka all 0 times) so it\\'s true"
                    },
                    {
                        "username": "nylime",
                        "content": "The sliding window algorithm can be used to approach this solution, in which two pointers are used to keep track of the start and end of a window. In this method, the window should only keep valid a valid subarray (in which the subarray is turbulent).\\n\\nFirst, the case in which the array has only 0 or 1 element can be taken care of.\\n\\nThen, the window of the array can start with the first two elements.\\n- If the two consecutive elements are equal, the window can be readjusted so that the second repetitive element is the start of the window.\\n- Otherwise, we can include the third element to the subarray:\\n   - If the first element is less than the second and the second element is less than the third, the start of the window can be readjusted to point to the third element, to represent the start of a new subarray. Same goes for if the first element is greater than the second and the second element is greater than the third.\\n   - If the second element is less than the second and the second element is greater than the third, the maximum length of a turbulent subarray can be updated. Same goes for if the first element is greater than the second and the second element is less than the third.\\n\\nIn summary, only the last 3 elements within the window need to be analyzed for their sign relationships: the third to last must be compared to the second to last in order to determine what sign to expect for the second to last compared to the very last. This process can be repeated until the window reaches the end of the array."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/01/21/Leetcode-978-Longest-Turbulent-Subarray/\\n\\nHope helpful!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "so i have doubt...can we do it  in finding LCS dp problem way where we keep two pointers i and j and can do i-1, j + 1 in recursive calls?"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The example 2 expected output is not consistent with the explanation of example 1"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "We use the counter (cnt) to track subarray size. Our counter is positive if we expect \\'>\\', and \\'<\\' otherwise. Obviously, for each turn we flip the sign.\\n\\nIf the comparison matches the counter sign (e.g. A[i] > A[i + 1] and cnt > 0 ), we increment (or decrement the negative) counter. Otherwise, we reset the counter to 1 (or -1). One edge case here is when two numbers are equal. We set the counter to zero in this case."
                    }
                ]
            },
            {
                "id": 1905180,
                "content": [
                    {
                        "username": "amritha_patil",
                        "content": "For the input : [4,8,12,16],\\nthe expected output is 2. Can anyone explain why is that so. Shouldn\\'t the output be 1 as the array is in ascending order."
                    },
                    {
                        "username": "haridavinci",
                        "content": "Good question..In [4,8] the sign change is valid becuse the first part of definition still holds! Idea is just to track sign changes and the longest one is the result ..no need of complicating even odd cases explicitly"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "[@doublegthe7th](/doublegthe7th) i didn\\'t understand what you mean by that :D "
                    },
                    {
                        "username": "doublegthe7th",
                        "content": "Consider [4,8]. Since 4 < 8, the sign does flip with each comparsion (aka all 0 times) so it\\'s true"
                    },
                    {
                        "username": "nylime",
                        "content": "The sliding window algorithm can be used to approach this solution, in which two pointers are used to keep track of the start and end of a window. In this method, the window should only keep valid a valid subarray (in which the subarray is turbulent).\\n\\nFirst, the case in which the array has only 0 or 1 element can be taken care of.\\n\\nThen, the window of the array can start with the first two elements.\\n- If the two consecutive elements are equal, the window can be readjusted so that the second repetitive element is the start of the window.\\n- Otherwise, we can include the third element to the subarray:\\n   - If the first element is less than the second and the second element is less than the third, the start of the window can be readjusted to point to the third element, to represent the start of a new subarray. Same goes for if the first element is greater than the second and the second element is greater than the third.\\n   - If the second element is less than the second and the second element is greater than the third, the maximum length of a turbulent subarray can be updated. Same goes for if the first element is greater than the second and the second element is less than the third.\\n\\nIn summary, only the last 3 elements within the window need to be analyzed for their sign relationships: the third to last must be compared to the second to last in order to determine what sign to expect for the second to last compared to the very last. This process can be repeated until the window reaches the end of the array."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/01/21/Leetcode-978-Longest-Turbulent-Subarray/\\n\\nHope helpful!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "so i have doubt...can we do it  in finding LCS dp problem way where we keep two pointers i and j and can do i-1, j + 1 in recursive calls?"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The example 2 expected output is not consistent with the explanation of example 1"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "We use the counter (cnt) to track subarray size. Our counter is positive if we expect \\'>\\', and \\'<\\' otherwise. Obviously, for each turn we flip the sign.\\n\\nIf the comparison matches the counter sign (e.g. A[i] > A[i + 1] and cnt > 0 ), we increment (or decrement the negative) counter. Otherwise, we reset the counter to 1 (or -1). One edge case here is when two numbers are equal. We set the counter to zero in this case."
                    }
                ]
            },
            {
                "id": 1705791,
                "content": [
                    {
                        "username": "amritha_patil",
                        "content": "For the input : [4,8,12,16],\\nthe expected output is 2. Can anyone explain why is that so. Shouldn\\'t the output be 1 as the array is in ascending order."
                    },
                    {
                        "username": "haridavinci",
                        "content": "Good question..In [4,8] the sign change is valid becuse the first part of definition still holds! Idea is just to track sign changes and the longest one is the result ..no need of complicating even odd cases explicitly"
                    },
                    {
                        "username": "justfoundpassion",
                        "content": "[@doublegthe7th](/doublegthe7th) i didn\\'t understand what you mean by that :D "
                    },
                    {
                        "username": "doublegthe7th",
                        "content": "Consider [4,8]. Since 4 < 8, the sign does flip with each comparsion (aka all 0 times) so it\\'s true"
                    },
                    {
                        "username": "nylime",
                        "content": "The sliding window algorithm can be used to approach this solution, in which two pointers are used to keep track of the start and end of a window. In this method, the window should only keep valid a valid subarray (in which the subarray is turbulent).\\n\\nFirst, the case in which the array has only 0 or 1 element can be taken care of.\\n\\nThen, the window of the array can start with the first two elements.\\n- If the two consecutive elements are equal, the window can be readjusted so that the second repetitive element is the start of the window.\\n- Otherwise, we can include the third element to the subarray:\\n   - If the first element is less than the second and the second element is less than the third, the start of the window can be readjusted to point to the third element, to represent the start of a new subarray. Same goes for if the first element is greater than the second and the second element is greater than the third.\\n   - If the second element is less than the second and the second element is greater than the third, the maximum length of a turbulent subarray can be updated. Same goes for if the first element is greater than the second and the second element is less than the third.\\n\\nIn summary, only the last 3 elements within the window need to be analyzed for their sign relationships: the third to last must be compared to the second to last in order to determine what sign to expect for the second to last compared to the very last. This process can be repeated until the window reaches the end of the array."
                    },
                    {
                        "username": "bupt_wc",
                        "content": "https://buptwc.com/2019/01/21/Leetcode-978-Longest-Turbulent-Subarray/\\n\\nHope helpful!"
                    },
                    {
                        "username": "JigglyyPuff",
                        "content": "so i have doubt...can we do it  in finding LCS dp problem way where we keep two pointers i and j and can do i-1, j + 1 in recursive calls?"
                    },
                    {
                        "username": "DarianaSanchez",
                        "content": "The example 2 expected output is not consistent with the explanation of example 1"
                    },
                    {
                        "username": "ranjeet43",
                        "content": "We use the counter (cnt) to track subarray size. Our counter is positive if we expect \\'>\\', and \\'<\\' otherwise. Obviously, for each turn we flip the sign.\\n\\nIf the comparison matches the counter sign (e.g. A[i] > A[i + 1] and cnt > 0 ), we increment (or decrement the negative) counter. Otherwise, we reset the counter to 1 (or -1). One edge case here is when two numbers are equal. We set the counter to zero in this case."
                    }
                ]
            }
        ]
    }
]